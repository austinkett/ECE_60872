diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index 92e64f26be3..247b6727229 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -592,6 +592,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1128,17 +1153,12 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
-
 /**
- * Double Clicking of LCD Panel's Encoder Wheel while at the Status Screen will jump
- * to the Z-BabyStepping menu.
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
  */
-//#define DOUBLE_CLICK_JUMPS_TO_Z_BABYSTEPPING
-#define DOUBLE_CLICK_TIME_WINDOW 1250   // How quickly the double click must be done in miliseconds.
-                                        // Please notice this time must be a little bit longer than what
-                                        // is actually desired because there is some latency in detecting a
-                                        // change in LCD Panel Button Status.
-
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
 
 /**
  * Volumetric extrusion default state
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index b7b4473c962..9310e7a31ff 100755
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -572,10 +572,6 @@ static uint8_t target_extruder;
 
   float delta_safe_distance_from_top();
 
-#else
-
-  static bool home_all_axis = true;
-
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
@@ -1582,7 +1578,7 @@ inline void set_destination_to_current() { memcpy(destination, current_position,
  *  The final current_position may not be the one that was requested
  */
 void do_blocking_move_to(const float &x, const float &y, const float &z, const float &fr_mm_s /*=0.0*/) {
-  float old_feedrate_mm_s = feedrate_mm_s;
+  const float old_feedrate_mm_s = feedrate_mm_s;
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, x, y, z);
@@ -2034,8 +2030,8 @@ static void clean_up_after_endstop_or_probe_move() {
       if (axis_unhomed_error(true, true,  true )) { stop(); return true; }
     #endif
 
-    float oldXpos = current_position[X_AXIS],
-          oldYpos = current_position[Y_AXIS];
+    const float oldXpos = current_position[X_AXIS],
+                oldYpos = current_position[Y_AXIS];
 
     #ifdef _TRIGGERED_WHEN_STOWED_TEST
 
@@ -2178,7 +2174,7 @@ static void clean_up_after_endstop_or_probe_move() {
   //   - Raise to the BETWEEN height
   // - Return the probed Z position
   //
-  static float probe_pt(const float &x, const float &y, bool stow = true, int verbose_level = 1) {
+  static float probe_pt(const float &x, const float &y, const bool stow = true, const int verbose_level = 1) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR(">>> probe_pt(", x);
@@ -2189,7 +2185,7 @@ static void clean_up_after_endstop_or_probe_move() {
       }
     #endif
 
-    float old_feedrate_mm_s = feedrate_mm_s;
+    const float old_feedrate_mm_s = feedrate_mm_s;
 
     #if ENABLED(DELTA)
       if (current_position[Z_AXIS] > delta_clip_start_height)
@@ -2206,7 +2202,7 @@ static void clean_up_after_endstop_or_probe_move() {
 
     if (DEPLOY_PROBE()) return NAN;
 
-    float measured_z = run_z_probe();
+    const float measured_z = run_z_probe();
 
     if (!stow)
       do_probe_raise(Z_CLEARANCE_BETWEEN_PROBES);
@@ -2370,7 +2366,7 @@ static void clean_up_after_endstop_or_probe_move() {
     if (b2 == UNPROBED) b2 = 0.0; if (b1 == UNPROBED) b1 = b2;
     if (c2 == UNPROBED) c2 = 0.0; if (c1 == UNPROBED) c1 = c2;
 
-    float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
+    const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
 
     // Take the average instead of the median
     bed_level_grid[x][y] = (a + b + c) / 3.0;
@@ -2416,10 +2412,10 @@ static void clean_up_after_endstop_or_probe_move() {
       for (uint8_t yo = 0; yo <= ylen; yo++) {
         uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
         #ifndef HALF_IN_X
-          uint8_t x1 = ctrx1 - xo;
+          const uint8_t x1 = ctrx1 - xo;
         #endif
         #ifndef HALF_IN_Y
-          uint8_t y1 = ctry1 - yo;
+          const uint8_t y1 = ctry1 - yo;
           #ifndef HALF_IN_X
             extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
           #endif
@@ -2436,33 +2432,41 @@ static void clean_up_after_endstop_or_probe_move() {
   /**
    * Print calibration results for plotting or manual frame adjustment.
    */
-  static void print_bilinear_leveling_grid() {
-    SERIAL_ECHOPGM("Bilinear Leveling Grid:\n ");
-    for (uint8_t x = 0; x < ABL_GRID_MAX_POINTS_X; x++) {
-      SERIAL_PROTOCOLPGM("    ");
-      if (x < 10) SERIAL_PROTOCOLCHAR(' ');
+  static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {
+    for (uint8_t x = 0; x < sx; x++) {
+      for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
+        SERIAL_PROTOCOLCHAR(' ');
       SERIAL_PROTOCOL((int)x);
     }
     SERIAL_EOL;
-    for (uint8_t y = 0; y < ABL_GRID_MAX_POINTS_Y; y++) {
+    for (uint8_t y = 0; y < sy; y++) {
       if (y < 10) SERIAL_PROTOCOLCHAR(' ');
       SERIAL_PROTOCOL((int)y);
-      for (uint8_t x = 0; x < ABL_GRID_MAX_POINTS_X; x++) {
+      for (uint8_t x = 0; x < sx; x++) {
         SERIAL_PROTOCOLCHAR(' ');
-        float offset = bed_level_grid[x][y];
+        float offset = fn(x, y);
         if (offset != UNPROBED) {
-          if (offset > 0) SERIAL_CHAR('+');
-          SERIAL_PROTOCOL_F(offset, 2);
+          if (offset >= 0) SERIAL_CHAR('+');
+          SERIAL_PROTOCOL_F(offset, precision);
         }
         else
-          SERIAL_PROTOCOLPGM(" ====");
+          for (uint8_t i = 0; i < precision + 3; i++)
+            SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
       }
       SERIAL_EOL;
     }
     SERIAL_EOL;
   }
 
+  static void print_bilinear_leveling_grid() {
+    SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
+    print_2d_array(ABL_GRID_MAX_POINTS_X, ABL_GRID_MAX_POINTS_Y, 2,
+      [](const uint8_t x, const uint8_t y) { return bed_level_grid[x][y]; }
+    );
+  }
+
   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+
     #define ABL_GRID_POINTS_VIRT_X (ABL_GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
     #define ABL_GRID_POINTS_VIRT_Y (ABL_GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
     #define ABL_TEMP_POINTS_X (ABL_GRID_MAX_POINTS_X + 2)
@@ -2472,29 +2476,11 @@ static void clean_up_after_endstop_or_probe_move() {
 
     static void bed_level_virt_print() {
       SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
-      for (uint8_t x = 0; x < ABL_GRID_POINTS_VIRT_X; x++) {
-        SERIAL_PROTOCOLPGM("       ");
-        if (x < 10) SERIAL_PROTOCOLCHAR(' ');
-        SERIAL_PROTOCOL((int)x);
-      }
-      SERIAL_EOL;
-      for (uint8_t y = 0; y < ABL_GRID_POINTS_VIRT_Y; y++) {
-        if (y < 10) SERIAL_PROTOCOLCHAR(' ');
-        SERIAL_PROTOCOL((int)y);
-        for (uint8_t x = 0; x < ABL_GRID_POINTS_VIRT_X; x++) {
-          SERIAL_PROTOCOLCHAR(' ');
-          float offset = bed_level_grid_virt[x][y];
-          if (offset != UNPROBED) {
-            if (offset >= 0) SERIAL_CHAR('+');
-            SERIAL_PROTOCOL_F(offset, 5);
-          }
-          else
-            SERIAL_PROTOCOLPGM(" ====");
-        }
-        SERIAL_EOL;
-      }
-      SERIAL_EOL;
+      print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
+        [](const uint8_t x, const uint8_t y) { return bed_level_grid_virt[x][y]; }
+      );
     }
+
     #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
     float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
       uint8_t ep = 0, ip = 1;
@@ -2532,6 +2518,7 @@ static void clean_up_after_endstop_or_probe_move() {
       }
       return bed_level_grid[x - 1][y - 1];
     }
+
     static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
       return (
           p[i-1] * -t * sq(1 - t)
@@ -2540,6 +2527,7 @@ static void clean_up_after_endstop_or_probe_move() {
         - p[i+2] * sq(t) * (1 - t)
       ) * 0.5;
     }
+
     static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
       float row[4], column[4];
       for (uint8_t i = 0; i < 4; i++) {
@@ -2550,6 +2538,7 @@ static void clean_up_after_endstop_or_probe_move() {
       }
       return bed_level_virt_cmr(row, 1, tx);
     }
+
     void bed_level_virt_interpolate() {
       for (uint8_t y = 0; y < ABL_GRID_MAX_POINTS_Y; y++)
         for (uint8_t x = 0; x < ABL_GRID_MAX_POINTS_X; x++)
@@ -2569,7 +2558,6 @@ static void clean_up_after_endstop_or_probe_move() {
   #endif // ABL_BILINEAR_SUBDIVISION
 #endif // AUTO_BED_LEVELING_BILINEAR
 
-
 /**
  * Home an individual linear axis
  */
@@ -2586,7 +2574,7 @@ static void do_homing_move(const AxisEnum axis, float distance, float fr_mm_s=0.
   #endif
 
   #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-    bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
+    const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
     if (deploy_bltouch) set_bltouch_deployed(true);
   #endif
 
@@ -2634,7 +2622,7 @@ static void do_homing_move(const AxisEnum axis, float distance, float fr_mm_s=0.
 
 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
 
-static void homeaxis(AxisEnum axis) {
+static void homeaxis(const AxisEnum axis) {
 
   #if IS_SCARA
     // Only Z homing (with probe) is permitted
@@ -2653,7 +2641,7 @@ static void homeaxis(AxisEnum axis) {
     }
   #endif
 
-  int axis_home_dir =
+  const int axis_home_dir =
     #if ENABLED(DUAL_X_CARRIAGE)
       (axis == X_AXIS) ? x_home_dir(active_extruder) :
     #endif
@@ -2769,13 +2757,13 @@ static void homeaxis(AxisEnum axis) {
 
 #if ENABLED(FWRETRACT)
 
-  void retract(bool retracting, bool swapping = false) {
+  void retract(const bool retracting, const bool swapping = false) {
 
     static float hop_height;
 
     if (retracting == retracted[active_extruder]) return;
 
-    float old_feedrate_mm_s = feedrate_mm_s;
+    const float old_feedrate_mm_s = feedrate_mm_s;
 
     set_destination_to_current();
 
@@ -2805,7 +2793,7 @@ static void homeaxis(AxisEnum axis) {
       }
 
       feedrate_mm_s = retract_recover_feedrate_mm_s;
-      float move_e = swapping ? retract_length_swap + retract_recover_length_swap : retract_length + retract_recover_length;
+      const float move_e = swapping ? retract_length_swap + retract_recover_length_swap : retract_length + retract_recover_length;
       current_position[E_AXIS] -= move_e / volumetric_multiplier[active_extruder];
       sync_plan_position_e();
 
@@ -2824,11 +2812,11 @@ static void homeaxis(AxisEnum axis) {
 
   void normalize_mix() {
     float mix_total = 0.0;
-    for (int i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
+    for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
     // Scale all values if they don't add up to ~1.0
     if (!NEAR(mix_total, 1.0)) {
       SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
-      for (int i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
+      for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
     }
   }
 
@@ -2908,7 +2896,7 @@ void unknown_command_error() {
    * while the machine is not accepting commands.
    */
   void host_keepalive() {
-    millis_t ms = millis();
+    const millis_t ms = millis();
     if (host_keepalive_interval && busy_state != NOT_BUSY) {
       if (PENDING(ms, next_busy_signal_ms)) return;
       switch (busy_state) {
@@ -2984,7 +2972,7 @@ inline void gcode_G0_G1(
     #if ENABLED(FWRETRACT)
 
       if (autoretract_enabled && !(code_seen('X') || code_seen('Y') || code_seen('Z')) && code_seen('E')) {
-        float echange = destination[E_AXIS] - current_position[E_AXIS];
+        const float echange = destination[E_AXIS] - current_position[E_AXIS];
         // Is this move an attempt to retract or recover?
         if ((echange < -MIN_RETRACT && !retracted[active_extruder]) || (echange > MIN_RETRACT && retracted[active_extruder])) {
           current_position[E_AXIS] = destination[E_AXIS]; // hide the slicer-generated retract/recover from calculations
@@ -3032,7 +3020,7 @@ inline void gcode_G0_G1(
     if (IsRunning()) {
 
       #if ENABLED(SF_ARC_FIX)
-        bool relative_mode_backup = relative_mode;
+        const bool relative_mode_backup = relative_mode;
         relative_mode = true;
       #endif
 
@@ -3113,7 +3101,7 @@ inline void gcode_G4() {
 
       gcode_get_destination();
 
-      float offset[] = {
+      const float offset[] = {
         code_seen('I') ? code_value_axis_units(X_AXIS) : 0.0,
         code_seen('J') ? code_value_axis_units(Y_AXIS) : 0.0,
         code_seen('P') ? code_value_axis_units(X_AXIS) : 0.0,
@@ -3155,9 +3143,9 @@ inline void gcode_G4() {
     // Don't allow nozzle cleaning without homing first
     if (axis_unhomed_error(true, true, true)) { return; }
 
-    uint8_t const pattern = code_seen('P') ? code_value_ushort() : 0;
-    uint8_t const strokes = code_seen('S') ? code_value_ushort() : NOZZLE_CLEAN_STROKES;
-    uint8_t const objects = code_seen('T') ? code_value_ushort() : NOZZLE_CLEAN_TRIANGLES;
+    const uint8_t pattern = code_seen('P') ? code_value_ushort() : 0,
+                  strokes = code_seen('S') ? code_value_ushort() : NOZZLE_CLEAN_STROKES,
+                  objects = code_seen('T') ? code_value_ushort() : NOZZLE_CLEAN_TRIANGLES;
 
     Nozzle::clean(pattern, strokes, objects);
   }
@@ -3181,9 +3169,8 @@ inline void gcode_G4() {
    */
   inline void gcode_G27() {
     // Don't allow nozzle parking without homing first
-    if (axis_unhomed_error(true, true, true)) { return; }
-    uint8_t const z_action = code_seen('P') ? code_value_ushort() : 0;
-    Nozzle::park(z_action);
+    if (axis_unhomed_error(true, true, true)) return;
+    Nozzle::park(code_seen('P') ? code_value_ushort() : 0);
   }
 #endif // NOZZLE_PARK_FEATURE
 
@@ -3195,7 +3182,7 @@ inline void gcode_G4() {
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
     sync_plan_position();
 
-    int x_axis_home_dir =
+    const int x_axis_home_dir =
       #if ENABLED(DUAL_X_CARRIAGE)
         x_home_dir(active_extruder)
       #else
@@ -3203,15 +3190,14 @@ inline void gcode_G4() {
       #endif
     ;
 
-    float mlx = max_length(X_AXIS),
-          mly = max_length(Y_AXIS),
-          mlratio = mlx > mly ? mly / mlx : mlx / mly,
-          fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * sqrt(sq(mlratio) + 1.0);
+    const float mlx = max_length(X_AXIS),
+                mly = max_length(Y_AXIS),
+                mlratio = mlx > mly ? mly / mlx : mlx / mly,
+                fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * sqrt(sq(mlratio) + 1.0);
 
     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
     endstops.hit_on_purpose(); // clear endstop hit flags
     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
-
   }
 
 #endif // QUICK_HOME
@@ -3459,7 +3445,7 @@ inline void gcode_G28() {
 
   // Always home with tool 0 active
   #if HOTENDS > 1
-    uint8_t old_tool_index = active_extruder;
+    const uint8_t old_tool_index = active_extruder;
     tool_change(0, 0, true);
   #endif
 
@@ -3504,9 +3490,8 @@ inline void gcode_G28() {
 
   #else // NOT DELTA
 
-    bool homeX = code_seen('X'), homeY = code_seen('Y'), homeZ = code_seen('Z');
-
-    home_all_axis = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
+    const bool homeX = code_seen('X'), homeY = code_seen('Y'), homeZ = code_seen('Z'),
+               home_all_axis = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
 
     set_destination_to_current();
 
@@ -3692,8 +3677,8 @@ inline void gcode_G28() {
 
 #if ENABLED(MESH_BED_LEVELING)
 
-  inline void _mbl_goto_xy(float x, float y) {
-    float old_feedrate_mm_s = feedrate_mm_s;
+  inline void _mbl_goto_xy(const float &x, const float &y) {
+    const float old_feedrate_mm_s = feedrate_mm_s;
     feedrate_mm_s = homing_feedrate_mm_s[Z_AXIS];
 
     current_position[Z_AXIS] = MESH_HOME_SEARCH_Z
@@ -3760,8 +3745,8 @@ inline void gcode_G28() {
    */
   inline void gcode_G29() {
 
-    static int probe_point = -1;
-    MeshLevelingState state = code_seen('S') ? (MeshLevelingState)code_value_byte() : MeshReport;
+    static int probe_index = -1;
+    const MeshLevelingState state = code_seen('S') ? (MeshLevelingState)code_value_byte() : MeshReport;
     if (state < 0 || state > 5) {
       SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
       return;
@@ -3781,17 +3766,17 @@ inline void gcode_G28() {
 
       case MeshStart:
         mbl.reset();
-        probe_point = 0;
+        probe_index = 0;
         enqueue_and_echo_commands_P(PSTR("G28\nG29 S2"));
         break;
 
       case MeshNext:
-        if (probe_point < 0) {
+        if (probe_index < 0) {
           SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
           return;
         }
         // For each G29 S2...
-        if (probe_point == 0) {
+        if (probe_index == 0) {
           // For the initial G29 S2 make Z a positive value (e.g., 4.0)
           current_position[Z_AXIS] = MESH_HOME_SEARCH_Z
             #if Z_HOME_DIR > 0
@@ -3802,13 +3787,13 @@ inline void gcode_G28() {
         }
         else {
           // For G29 S2 after adjusting Z.
-          mbl.set_zigzag_z(probe_point - 1, current_position[Z_AXIS]);
+          mbl.set_zigzag_z(probe_index - 1, current_position[Z_AXIS]);
         }
         // If there's another point to sample, move there with optional lift.
-        if (probe_point < (MESH_NUM_X_POINTS) * (MESH_NUM_Y_POINTS)) {
-          mbl.zigzag(probe_point, px, py);
+        if (probe_index < (MESH_NUM_X_POINTS) * (MESH_NUM_Y_POINTS)) {
+          mbl.zigzag(probe_index, px, py);
           _mbl_goto_xy(mbl.get_probe_x(px), mbl.get_probe_y(py));
-          probe_point++;
+          probe_index++;
         }
         else {
           // One last "return to the bed" (as originally coded) at completion
@@ -3824,7 +3809,7 @@ inline void gcode_G28() {
 
           // After recording the last point, activate the mbl and home
           SERIAL_PROTOCOLLNPGM("Mesh probing done.");
-          probe_point = -1;
+          probe_index = -1;
           mbl.set_has_mesh(true);
           enqueue_and_echo_commands_P(PSTR("G28"));
         }
@@ -3936,8 +3921,8 @@ inline void gcode_G28() {
   inline void gcode_G29() {
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
-      bool query = code_seen('Q');
-      uint8_t old_debug_flags = marlin_debug_flags;
+      const bool query = code_seen('Q');
+      const uint8_t old_debug_flags = marlin_debug_flags;
       if (query) marlin_debug_flags |= DEBUG_LEVELING;
       if (DEBUGGING(LEVELING)) {
         DEBUG_POS(">>> gcode_G29", current_position);
@@ -3950,7 +3935,7 @@ inline void gcode_G28() {
     // Don't allow auto-leveling without homing first
     if (axis_unhomed_error(true, true, true)) return;
 
-    int verbose_level = code_seen('V') ? code_value_int() : 1;
+    const int verbose_level = code_seen('V') ? code_value_int() : 1;
     if (verbose_level < 0 || verbose_level > 4) {
       SERIAL_PROTOCOLLNPGM("?(V)erbose Level is implausible (0-4).");
       return;
@@ -3995,14 +3980,14 @@ inline void gcode_G28() {
           front_probe_bed_position = code_seen('F') ? (int)code_value_axis_units(Y_AXIS) : LOGICAL_Y_POSITION(FRONT_PROBE_BED_POSITION),
           back_probe_bed_position = code_seen('B') ? (int)code_value_axis_units(Y_AXIS) : LOGICAL_Y_POSITION(BACK_PROBE_BED_POSITION);
 
-      bool left_out_l = left_probe_bed_position < LOGICAL_X_POSITION(MIN_PROBE_X),
-           left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
-           right_out_r = right_probe_bed_position > LOGICAL_X_POSITION(MAX_PROBE_X),
-           right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
-           front_out_f = front_probe_bed_position < LOGICAL_Y_POSITION(MIN_PROBE_Y),
-           front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
-           back_out_b = back_probe_bed_position > LOGICAL_Y_POSITION(MAX_PROBE_Y),
-           back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
+      const bool left_out_l = left_probe_bed_position < LOGICAL_X_POSITION(MIN_PROBE_X),
+                 left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
+                 right_out_r = right_probe_bed_position > LOGICAL_X_POSITION(MAX_PROBE_X),
+                 right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
+                 front_out_f = front_probe_bed_position < LOGICAL_Y_POSITION(MIN_PROBE_Y),
+                 front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
+                 back_out_b = back_probe_bed_position > LOGICAL_Y_POSITION(MAX_PROBE_Y),
+                 back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
 
       if (left_out || right_out || front_out || back_out) {
         if (left_out) {
@@ -4068,8 +4053,10 @@ inline void gcode_G28() {
           || left_probe_bed_position != bilinear_start[X_AXIS]
           || front_probe_bed_position != bilinear_start[Y_AXIS]
         ) {
-          // Before reset bed level, re-enable to correct the position
-          planner.abl_enabled = abl_should_enable;
+          if (dryrun) {
+            // Before reset bed level, re-enable to correct the position
+            planner.abl_enabled = abl_should_enable;
+          }
           // Reset grid to 0.0 or "not probed". (Also disables ABL)
           reset_bed_level();
 
@@ -4097,9 +4084,10 @@ inline void gcode_G28() {
          * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
          */
 
-        int abl2 = abl_grid_points_x * abl_grid_points_y,
-            indexIntoAB[abl_grid_points_x][abl_grid_points_y],
-            probePointCounter = -1;
+        const int abl2 = abl_grid_points_x * abl_grid_points_y;
+
+        int indexIntoAB[abl_grid_points_x][abl_grid_points_y],
+            probe_index = -1;
 
         float eqnAMatrix[abl2 * 3], // "A" matrix of the linear system of equations
               eqnBVector[abl2],     // "B" vector of Z points
@@ -4109,30 +4097,30 @@ inline void gcode_G28() {
 
       #if ENABLED(PROBE_Y_FIRST)
         #define PR_OUTER_VAR xCount
-        #define PR_OUTER_END abl_grid_points_x
+        #define PR_OUTER_NUM abl_grid_points_x
         #define PR_INNER_VAR yCount
-        #define PR_INNER_END abl_grid_points_y
+        #define PR_INNER_NUM abl_grid_points_y
       #else
         #define PR_OUTER_VAR yCount
-        #define PR_OUTER_END abl_grid_points_y
+        #define PR_OUTER_NUM abl_grid_points_y
         #define PR_INNER_VAR xCount
-        #define PR_INNER_END abl_grid_points_x
+        #define PR_INNER_NUM abl_grid_points_x
       #endif
 
-      bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
+      bool zig = PR_OUTER_NUM & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
 
       // Outer loop is Y with PROBE_Y_FIRST disabled
-      for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END; PR_OUTER_VAR++) {
+      for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_NUM; PR_OUTER_VAR++) {
 
         int8_t inStart, inStop, inInc;
 
         if (zig) { // away from origin
           inStart = 0;
-          inStop = PR_INNER_END;
+          inStop = PR_INNER_NUM;
           inInc = 1;
         }
         else {     // towards origin
-          inStart = PR_INNER_END - 1;
+          inStart = PR_INNER_NUM - 1;
           inStop = -1;
           inInc = -1;
         }
@@ -4149,7 +4137,7 @@ inline void gcode_G28() {
           yProbe = floor(yBase + (yBase < 0 ? 0 : 0.5));
 
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-            indexIntoAB[xCount][yCount] = ++probePointCounter;
+            indexIntoAB[xCount][yCount] = ++probe_index;
           #endif
 
           #if IS_KINEMATIC
@@ -4168,10 +4156,10 @@ inline void gcode_G28() {
           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
 
             mean += measured_z;
-            eqnBVector[probePointCounter] = measured_z;
-            eqnAMatrix[probePointCounter + 0 * abl2] = xProbe;
-            eqnAMatrix[probePointCounter + 1 * abl2] = yProbe;
-            eqnAMatrix[probePointCounter + 2 * abl2] = 1;
+            eqnBVector[probe_index] = measured_z;
+            eqnAMatrix[probe_index + 0 * abl2] = xProbe;
+            eqnAMatrix[probe_index + 1 * abl2] = yProbe;
+            eqnAMatrix[probe_index + 2 * abl2] = 1;
 
           #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
@@ -4181,8 +4169,8 @@ inline void gcode_G28() {
 
           idle();
 
-        } //xProbe
-      } //yProbe
+        } // inner
+      } // outer
 
     #elif ENABLED(AUTO_BED_LEVELING_3POINT)
 
@@ -5208,8 +5196,8 @@ inline void gcode_M42() {
             SERIAL_PROTOCOLPGM(" range: ");
             SERIAL_PROTOCOL_F(max-min, 3);
           }
+          SERIAL_EOL;
         }
-        SERIAL_EOL;
       }
 
     } // End of probe loop
@@ -5308,7 +5296,7 @@ inline void gcode_M104() {
       }
     #endif
 
-    if (code_value_temp_abs() > thermalManager.degHotend(target_extruder)) status_printf(0, "E%i %s", target_extruder + 1, PSTR(MSG_HEATING));
+    if (code_value_temp_abs() > thermalManager.degHotend(target_extruder)) status_printf(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
   }
 
   #if ENABLED(AUTOTEMP)
@@ -5506,7 +5494,7 @@ inline void gcode_M109() {
       else print_job_timer.start();
     #endif
 
-    if (thermalManager.isHeatingHotend(target_extruder)) status_printf(0, "E%i %s", target_extruder + 1, PSTR(MSG_HEATING));
+    if (thermalManager.isHeatingHotend(target_extruder)) status_printf(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
   }
 
   #if ENABLED(AUTOTEMP)
@@ -7601,7 +7589,24 @@ inline void gcode_M503() {
    */
   inline void gcode_M905() {
     stepper.synchronize();
-    planner.advance_M905(code_seen('K') ? code_value_float() : -1.0);
+
+    const float newK = code_seen('K') ? code_value_float() : -1,
+                newD = code_seen('D') ? code_value_float() : -1,
+                newW = code_seen('W') ? code_value_float() : -1,
+                newH = code_seen('H') ? code_value_float() : -1;
+
+    if (newK >= 0.0) planner.set_extruder_advance_k(newK);
+
+    SERIAL_ECHO_START;
+    SERIAL_ECHOLNPAIR("Advance factor: ", planner.get_extruder_advance_k());
+
+    if (newD >= 0 || newW >= 0 || newH >= 0) {
+      const float ratio = (!newD || !newW || !newH) ? 0 : (newW * newH) / (sq(newD * 0.5) * M_PI);
+      planner.set_advance_ed_ratio(ratio);
+      SERIAL_ECHO_START;
+      SERIAL_ECHOPGM("E/D ratio: ");
+      if (ratio) SERIAL_ECHOLN(ratio); else SERIAL_ECHOLNPGM("Automatic");
+    }
   }
 #endif
 
@@ -7843,9 +7848,9 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       if (tmp_extruder >= EXTRUDERS)
         return invalid_extruder_error(tmp_extruder);
 
-      float old_feedrate_mm_s = feedrate_mm_s;
+      const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
 
-      feedrate_mm_s = fr_mm_s > 0.0 ? (old_feedrate_mm_s = fr_mm_s) : XY_PROBE_FEEDRATE_MM_S;
+      feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
       if (tmp_extruder != active_extruder) {
         if (!no_move && axis_unhomed_error(true, true, true)) {
diff --git a/Marlin/example_configurations/Cartesio/Configuration_adv.h b/Marlin/example_configurations/Cartesio/Configuration_adv.h
index 4f2572e4a27..5280af8cd12 100644
--- a/Marlin/example_configurations/Cartesio/Configuration_adv.h
+++ b/Marlin/example_configurations/Cartesio/Configuration_adv.h
@@ -589,6 +589,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1125,6 +1150,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/Felix/Configuration_adv.h b/Marlin/example_configurations/Felix/Configuration_adv.h
index 96775c9d865..2ebb2f5e4ee 100644
--- a/Marlin/example_configurations/Felix/Configuration_adv.h
+++ b/Marlin/example_configurations/Felix/Configuration_adv.h
@@ -589,6 +589,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1125,6 +1150,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/Hephestos/Configuration_adv.h b/Marlin/example_configurations/Hephestos/Configuration_adv.h
index 67981af9580..65af0e844c3 100644
--- a/Marlin/example_configurations/Hephestos/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos/Configuration_adv.h
@@ -589,6 +589,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1125,6 +1150,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/Hephestos_2/Configuration_adv.h b/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
index e7caa3f3395..d4adbb60e6d 100644
--- a/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
+++ b/Marlin/example_configurations/Hephestos_2/Configuration_adv.h
@@ -572,6 +572,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1108,6 +1133,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/K8200/Configuration_adv.h b/Marlin/example_configurations/K8200/Configuration_adv.h
index 2cdc1365a1f..fbd4aeff4dd 100644
--- a/Marlin/example_configurations/K8200/Configuration_adv.h
+++ b/Marlin/example_configurations/K8200/Configuration_adv.h
@@ -602,6 +602,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 140 // start value for PLA on K8200
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1138,6 +1163,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/K8400/Configuration_adv.h b/Marlin/example_configurations/K8400/Configuration_adv.h
index a0889024b25..992bab4251b 100644
--- a/Marlin/example_configurations/K8400/Configuration_adv.h
+++ b/Marlin/example_configurations/K8400/Configuration_adv.h
@@ -589,6 +589,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1125,6 +1150,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/RigidBot/Configuration_adv.h b/Marlin/example_configurations/RigidBot/Configuration_adv.h
index 843c2b04284..f8f2f0b4c29 100644
--- a/Marlin/example_configurations/RigidBot/Configuration_adv.h
+++ b/Marlin/example_configurations/RigidBot/Configuration_adv.h
@@ -589,6 +589,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1125,6 +1150,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/SCARA/Configuration_adv.h b/Marlin/example_configurations/SCARA/Configuration_adv.h
index 68304e71217..63eaedfb4d2 100644
--- a/Marlin/example_configurations/SCARA/Configuration_adv.h
+++ b/Marlin/example_configurations/SCARA/Configuration_adv.h
@@ -589,6 +589,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1125,6 +1150,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/TAZ4/Configuration_adv.h b/Marlin/example_configurations/TAZ4/Configuration_adv.h
index 8e42b827195..d0c2b481b0a 100644
--- a/Marlin/example_configurations/TAZ4/Configuration_adv.h
+++ b/Marlin/example_configurations/TAZ4/Configuration_adv.h
@@ -597,6 +597,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1133,6 +1158,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/WITBOX/Configuration_adv.h b/Marlin/example_configurations/WITBOX/Configuration_adv.h
index 67981af9580..65af0e844c3 100644
--- a/Marlin/example_configurations/WITBOX/Configuration_adv.h
+++ b/Marlin/example_configurations/WITBOX/Configuration_adv.h
@@ -589,6 +589,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1125,6 +1150,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/delta/generic/Configuration_adv.h b/Marlin/example_configurations/delta/generic/Configuration_adv.h
index d362d727e95..a2236a9c80e 100644
--- a/Marlin/example_configurations/delta/generic/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/generic/Configuration_adv.h
@@ -591,6 +591,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1127,6 +1152,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
index d362d727e95..a2236a9c80e 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
@@ -591,6 +591,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1127,6 +1152,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
index 61c38d38aae..cc39740a3cf 100644
--- a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
@@ -596,6 +596,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1132,6 +1157,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
index 9584ae34110..814bcc464af 100644
--- a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
@@ -591,6 +591,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1127,6 +1152,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/makibox/Configuration_adv.h b/Marlin/example_configurations/makibox/Configuration_adv.h
index 184dc0dac0a..9d06015a8bb 100644
--- a/Marlin/example_configurations/makibox/Configuration_adv.h
+++ b/Marlin/example_configurations/makibox/Configuration_adv.h
@@ -589,6 +589,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1125,6 +1150,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
index 2092b3b60fd..c9601c6c746 100644
--- a/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
+++ b/Marlin/example_configurations/tvrrug/Round2/Configuration_adv.h
@@ -589,6 +589,31 @@
 
 #if ENABLED(LIN_ADVANCE)
   #define LIN_ADVANCE_K 75
+
+  /**
+   * Some Slicers produce Gcode with randomly jumping extrusion widths occasionally.
+   * For example within a 0.4mm perimeter it may produce a single segment of 0.05mm width.
+   * While this is harmless for normal printing (the fluid nature of the filament will
+   * close this very, very tiny gap), it throws off the LIN_ADVANCE pressure adaption.
+   *
+   * For this case LIN_ADVANCE_E_D_RATIO can be used to set the extrusion:distance ratio
+   * to a fixed value. Note that using a fixed ratio will lead to wrong nozzle pressures
+   * if the slicer is using variable widths or layer heights within one print!
+   *
+   * This option sets the default E:D ratio at startup. Use `M905` to override this value.
+   *
+   * Example: `M905 W0.4 H0.2 D1.75`, where:
+   *   - W is the extrusion width in mm
+   *   - H is the layer height in mm
+   *   - D is the filament diameter in mm
+   *
+   * Set to 0 to auto-detect the ratio based on given Gcode G1 print moves.
+   *
+   * Slic3r (including Prusa Slic3r) produces Gcode compatible with the automatic mode.
+   * Cura (as of this writing) may produce Gcode incompatible with the automatic mode.
+   */
+  #define LIN_ADVANCE_E_D_RATIO 0 // The calculated ratio (or 0) according to the formula W * H / ((D / 2) ^ 2 * PI)
+                                  // Example: 0.4 * 0.2 / ((1.75 / 2) ^ 2 * PI) = 0.033260135
 #endif
 
 // @section leveling
@@ -1125,6 +1150,13 @@
  */
 //#define EXTENDED_CAPABILITIES_REPORT
 
+/**
+ * Double-click the Encoder button on the Status Screen for Z Babystepping.
+ */
+//#define DOUBLECLICK_FOR_Z_BABYSTEPPING
+#define DOUBLECLICK_MAX_INTERVAL 1250   // Maximum interval between clicks, in milliseconds.
+                                        // Note: You may need to add extra time to mitigate controller latency.
+
 /**
  * Volumetric extrusion default state
  * Activate to make volumetric extrusion the default method,
diff --git a/Marlin/language_ca.h b/Marlin/language_ca.h
index 9a694192a3f..24bb53a4e97 100644
--- a/Marlin/language_ca.h
+++ b/Marlin/language_ca.h
@@ -34,47 +34,58 @@
 #define DISPLAY_CHARSET_ISO10646_1
 
 #define WELCOME_MSG                         MACHINE_NAME _UxGT(" preparada.")
-#define MSG_SD_INSERTED                     _UxGT("SD detectada.")
-#define MSG_SD_REMOVED                      _UxGT("SD expulsada.")
-#define MSG_MAIN                            _UxGT("Menu principal")
+#define MSG_SD_INSERTED                     _UxGT("Targeta detectada.")
+#define MSG_SD_REMOVED                      _UxGT("Targeta extreta.")
+#define MSG_LCD_ENDSTOPS                    _UxGT("Endstops")
+#define MSG_MAIN                            _UxGT("Men principal")
 #define MSG_AUTOSTART                       _UxGT("Inici automatic")
-#define MSG_DISABLE_STEPPERS                _UxGT("Apagar motors")
-#define MSG_AUTO_HOME                       _UxGT("Home global")
-#define MSG_LEVEL_BED_HOMING                _UxGT("Homing XYZ")
-#define MSG_LEVEL_BED_WAITING               _UxGT("Click to Begin")
-#define MSG_LEVEL_BED_DONE                  _UxGT("Leveling Done!")
-#define MSG_LEVEL_BED_CANCEL                _UxGT("Cancel")
-#define MSG_SET_HOME_OFFSETS                _UxGT("Set home offsets")
-#define MSG_HOME_OFFSETS_APPLIED            _UxGT("Offsets applied")
-#define MSG_SET_ORIGIN                      _UxGT("Establir origen")
-#define MSG_PREHEAT_1                       _UxGT("Preescalfar PLA")
-#define MSG_PREHEAT_1_N                     _UxGT("Preescalfar PLA ")
-#define MSG_PREHEAT_1_ALL                   _UxGT("Preesc. tot PLA")
-#define MSG_PREHEAT_1_BEDONLY               _UxGT("Preesc. llit PLA")
-#define MSG_PREHEAT_1_SETTINGS              _UxGT("Configuraci PLA")
-#define MSG_PREHEAT_2                       _UxGT("Preescalfar ABS")
-#define MSG_PREHEAT_2_N                     _UxGT("Preescalfar ABS ")
-#define MSG_PREHEAT_2_ALL                   _UxGT("Preesc. tot ABS")
-#define MSG_PREHEAT_2_BEDONLY               _UxGT("Preesc. llit ABS")
-#define MSG_PREHEAT_2_SETTINGS              _UxGT("Configuraci ABS")
-#define MSG_COOLDOWN                        _UxGT("Refredar")
+#define MSG_DISABLE_STEPPERS                _UxGT("Desactiva motors")
+#define MSG_DEBUG_MENU                      _UxGT("Menu de depuracio")
+#define MSG_PROGRESS_BAR_TEST               _UxGT("Test barra progres")
+#define MSG_AUTO_HOME                       _UxGT("Ves a l'origen")
+#define MSG_AUTO_HOME_X                     _UxGT("X a origen")
+#define MSG_AUTO_HOME_Y                     _UxGT("Y a origen")
+#define MSG_AUTO_HOME_Z                     _UxGT("Z a origen")
+#define MSG_LEVEL_BED_HOMING                _UxGT("Origen XYZ")
+#define MSG_LEVEL_BED_WAITING               _UxGT("Premeu per iniciar")
+#define MSG_LEVEL_BED_NEXT_POINT            _UxGT("Segent punt")
+#define MSG_LEVEL_BED_DONE                  _UxGT("Anivellament fet!")
+#define MSG_LEVEL_BED_CANCEL                _UxGT("Cancel.la")
+#define MSG_SET_HOME_OFFSETS                _UxGT("Ajusta decalatge")
+#define MSG_HOME_OFFSETS_APPLIED            _UxGT("Decalatge aplicat")
+#define MSG_SET_ORIGIN                      _UxGT("Estableix origen")
+#define MSG_PREHEAT_1                       _UxGT("Preescalfa PLA")
+#define MSG_PREHEAT_1_N                     MSG_PREHEAT_1 _UxGT(" ")
+#define MSG_PREHEAT_1_ALL                   MSG_PREHEAT_1 _UxGT(" Tot")
+#define MSG_PREHEAT_1_BEDONLY               MSG_PREHEAT_1 _UxGT(" Llit")
+#define MSG_PREHEAT_1_SETTINGS              MSG_PREHEAT_1 _UxGT(" Conf.")
+#define MSG_PREHEAT_2                       _UxGT("Preescalfa ABS")
+#define MSG_PREHEAT_2_N                     MSG_PREHEAT_2 _UxGT(" ")
+#define MSG_PREHEAT_2_ALL                   MSG_PREHEAT_2 _UxGT(" Tot")
+#define MSG_PREHEAT_2_BEDONLY               MSG_PREHEAT_2 _UxGT(" Llit")
+#define MSG_PREHEAT_2_SETTINGS              MSG_PREHEAT_2 _UxGT(" Conf.")
+#define MSG_COOLDOWN                        _UxGT("Refreda")
 #define MSG_SWITCH_PS_ON                    _UxGT("Switch power on")
 #define MSG_SWITCH_PS_OFF                   _UxGT("Switch power off")
-#define MSG_EXTRUDE                         _UxGT("Extruir")
-#define MSG_RETRACT                         _UxGT("Refredar")
-#define MSG_MOVE_AXIS                       _UxGT("Moure eixos")
-#define MSG_MOVE_X                          _UxGT("Moure X")
-#define MSG_MOVE_Y                          _UxGT("Moure Y")
-#define MSG_MOVE_Z                          _UxGT("Moure Z")
+#define MSG_EXTRUDE                         _UxGT("Extrudeix")
+#define MSG_RETRACT                         _UxGT("Retreu")
+#define MSG_MOVE_AXIS                       _UxGT("Mou eixos")
+#define MSG_LEVEL_BED                       _UxGT("Anivella llit")
+#define MSG_MOVING                          _UxGT("Movent..")
+#define MSG_FREE_XY                         _UxGT("XY lliures")
+#define MSG_MOVE_X                          _UxGT("Mou X")
+#define MSG_MOVE_Y                          _UxGT("Mou Y")
+#define MSG_MOVE_Z                          _UxGT("Mou Z")
 #define MSG_MOVE_E                          _UxGT("Extrusor")
-#define MSG_MOVE_01MM                       _UxGT("Moure 0.1mm")
-#define MSG_MOVE_1MM                        _UxGT("Moure 1mm")
-#define MSG_MOVE_10MM                       _UxGT("Moure 10mm")
+#define MSG_MOVE_01MM                       _UxGT("Mou 0.1mm")
+#define MSG_MOVE_1MM                        _UxGT("Mou 1mm")
+#define MSG_MOVE_10MM                       _UxGT("Mou 10mm")
 #define MSG_SPEED                           _UxGT("Velocitat")
+#define MSG_BED_Z                           _UxGT("Llit Z")
 #define MSG_NOZZLE                          _UxGT("Nozzle")
 #define MSG_BED                             _UxGT("Llit")
 #define MSG_FAN_SPEED                       _UxGT("Vel. Ventilador")
-#define MSG_FLOW                            _UxGT("Fluxe")
+#define MSG_FLOW                            _UxGT("Flux")
 #define MSG_CONTROL                         _UxGT("Control")
 #define MSG_MIN                             LCD_STR_THERMOMETER _UxGT(" Min")
 #define MSG_MAX                             LCD_STR_THERMOMETER _UxGT(" Max")
@@ -86,6 +97,7 @@
 #define MSG_PID_I                           _UxGT("PID-I")
 #define MSG_PID_D                           _UxGT("PID-D")
 #define MSG_PID_C                           _UxGT("PID-C")
+#define MSG_SELECT                          _UxGT("Select")
 #define MSG_ACC                             _UxGT("Accel")
 #define MSG_VX_JERK                         _UxGT("Vx-jerk")
 #define MSG_VY_JERK                         _UxGT("Vy-jerk")
@@ -93,9 +105,10 @@
 #define MSG_VE_JERK                         _UxGT("Ve-jerk")
 #define MSG_VMAX                            _UxGT("Vmax ")
 #define MSG_VMIN                            _UxGT("Vmin")
-#define MSG_VTRAV_MIN                       _UxGT("VTrav min")
-#define MSG_AMAX                            _UxGT("Amax ")
-#define MSG_A_RETRACT                       _UxGT("A-retract")
+#define MSG_VTRAV_MIN                       _UxGT("VViatge min")
+#define MSG_AMAX                            _UxGT("Accel. max ")
+#define MSG_A_RETRACT                       _UxGT("Accel. retracc")
+#define MSG_A_TRAVEL                        _UxGT("Accel. Viatge")
 #define MSG_XSTEPS                          _UxGT("Xpassos/mm")
 #define MSG_YSTEPS                          _UxGT("Ypassos/mm")
 #define MSG_ZSTEPS                          _UxGT("Zpassos/mm")
@@ -107,51 +120,140 @@
 #define MSG_TEMPERATURE                     _UxGT("Temperatura")
 #define MSG_MOTION                          _UxGT("Moviment")
 #define MSG_VOLUMETRIC                      _UxGT("Filament")
-#define MSG_VOLUMETRIC_ENABLED              _UxGT("E in mm3")
-#define MSG_FILAMENT_DIAM                   _UxGT("Fil. Dia.")
+#define MSG_VOLUMETRIC_ENABLED              _UxGT("E en mm3")
+#define MSG_FILAMENT_DIAM                   _UxGT("Diam. Fil.")
 #define MSG_CONTRAST                        _UxGT("Contrast de LCD")
-#define MSG_STORE_EPROM                     _UxGT("Desar a memoria")
-#define MSG_LOAD_EPROM                      _UxGT("Carregar de mem.")
-#define MSG_RESTORE_FAILSAFE                _UxGT("Rest. emergencia")
-#define MSG_REFRESH                         _UxGT("Refrescar")
+#define MSG_STORE_EPROM                     _UxGT("Desa memoria")
+#define MSG_LOAD_EPROM                      _UxGT("Carrega memoria")
+#define MSG_RESTORE_FAILSAFE                _UxGT("Restaura valors")
+#define MSG_REFRESH                         _UxGT("Actualitza")
 #define MSG_WATCH                           _UxGT("Pantalla Info.")
-#define MSG_PREPARE                         _UxGT("Preparar")
-#define MSG_TUNE                            _UxGT("Calibrar")
-#define MSG_PAUSE_PRINT                     _UxGT("Pausa imp.")
-#define MSG_RESUME_PRINT                    _UxGT("Reprendre imp.")
-#define MSG_STOP_PRINT                      _UxGT("Parar inp.")
-#define MSG_CARD_MENU                       _UxGT("Imprimir de SD")
-#define MSG_NO_CARD                         _UxGT("-Sense targeta SD")
-#define MSG_DWELL                           _UxGT("Repos...")
+#define MSG_PREPARE                         _UxGT("Prepara")
+#define MSG_TUNE                            _UxGT("Ajusta")
+#define MSG_PAUSE_PRINT                     _UxGT("Pausa impressio")
+#define MSG_RESUME_PRINT                    _UxGT("Repren impressio")
+#define MSG_STOP_PRINT                      _UxGT("Atura impressio.")
+#define MSG_CARD_MENU                       _UxGT("Imprimeix de SD")
+#define MSG_NO_CARD                         _UxGT("No hi ha targeta")
+#define MSG_DWELL                           _UxGT("En repos...")
 #define MSG_USERWAIT                        _UxGT("Esperant usuari..")
 #define MSG_RESUMING                        _UxGT("Reprenent imp.")
-#define MSG_PRINT_ABORTED                   _UxGT("Print aborted")
+#define MSG_PRINT_ABORTED                   _UxGT("Imp. cancelada")
 #define MSG_NO_MOVE                         _UxGT("Sense moviment.")
-#define MSG_KILLED                          _UxGT("PARADA DE EMERG. ")
-#define MSG_STOPPED                         _UxGT("ATURAT. ")
-#define MSG_CONTROL_RETRACT                 _UxGT("Retreure mm")
+#define MSG_KILLED                          _UxGT("MATAT.")
+#define MSG_STOPPED                         _UxGT("ATURADA.")
+#define MSG_CONTROL_RETRACT                 _UxGT("Retreu mm")
 #define MSG_CONTROL_RETRACT_SWAP            _UxGT("Swap Retreure mm")
-#define MSG_CONTROL_RETRACTF                _UxGT("Retreure  F")
-#define MSG_CONTROL_RETRACT_ZLIFT           _UxGT("Aixecar mm")
-#define MSG_CONTROL_RETRACT_RECOVER         _UxGT("DesRet mm")
-#define MSG_CONTROL_RETRACT_RECOVER_SWAP    _UxGT("Swap DesRet mm")
-#define MSG_CONTROL_RETRACT_RECOVERF        _UxGT("DesRet  F")
-#define MSG_AUTORETRACT                     _UxGT("AutoRetr.")
-#define MSG_FILAMENTCHANGE                  _UxGT("Canviar filament")
-#define MSG_INIT_SDCARD                     _UxGT("Iniciant SD")
-#define MSG_CNG_SDCARD                      _UxGT("Canviar SD")
-#define MSG_ZPROBE_OUT                      _UxGT("Z probe out. bed")
+#define MSG_CONTROL_RETRACTF                _UxGT("Retreu V")
+#define MSG_CONTROL_RETRACT_ZLIFT           _UxGT("Aixeca mm")
+#define MSG_CONTROL_RETRACT_RECOVER         _UxGT("DesRet +mm")
+#define MSG_CONTROL_RETRACT_RECOVER_SWAP    _UxGT("Swap DesRet +mm")
+#define MSG_CONTROL_RETRACT_RECOVERF        _UxGT("DesRet V")
+#define MSG_AUTORETRACT                     _UxGT("Auto retraccio")
+#define MSG_FILAMENTCHANGE                  _UxGT("Canvia filament")
+#define MSG_INIT_SDCARD                     _UxGT("Inicialitza SD")
+#define MSG_CNG_SDCARD                      _UxGT("Canvia SD")
+#define MSG_ZPROBE_OUT                      _UxGT("Sonda Z fora")
+#define MSG_BLTOUCH_RESET                   _UxGT("Reinicia BLTouch")
 #define MSG_HOME                            _UxGT("Home")  // Used as MSG_HOME " " MSG_X MSG_Y MSG_Z " " MSG_FIRST
-#define MSG_FIRST                           _UxGT("first")
-#define MSG_ZPROBE_ZOFFSET                  _UxGT("Z Offset")
-#define MSG_BABYSTEP_X                      _UxGT("Babystep X")
-#define MSG_BABYSTEP_Y                      _UxGT("Babystep Y")
-#define MSG_BABYSTEP_Z                      _UxGT("Babystep Z")
-#define MSG_ENDSTOP_ABORT                   _UxGT("Endstop abort")
-#define MSG_DELTA_CALIBRATE                 _UxGT("Delta Calibration")
-#define MSG_DELTA_CALIBRATE_X               _UxGT("Calibrate X")
-#define MSG_DELTA_CALIBRATE_Y               _UxGT("Calibrate Y")
-#define MSG_DELTA_CALIBRATE_Z               _UxGT("Calibrate Z")
-#define MSG_DELTA_CALIBRATE_CENTER          _UxGT("Calibrate Center")
+#define MSG_FIRST                           _UxGT("primer")
+#define MSG_ZPROBE_ZOFFSET                  _UxGT("Decalatge Z")
+#define MSG_BABYSTEP_X                      _UxGT("Micropas X")
+#define MSG_BABYSTEP_Y                      _UxGT("Micropas Y")
+#define MSG_BABYSTEP_Z                      _UxGT("Micropas Z")
+#define MSG_ENDSTOP_ABORT                   _UxGT("Cancel. Endstop")
+#define MSG_HEATING_FAILED_LCD              _UxGT("Error al escalfar")
+#define MSG_ERR_REDUNDANT_TEMP              _UxGT("Err: TEMP REDUNDANT")
+#define MSG_THERMAL_RUNAWAY                 _UxGT("THERMAL RUNAWAY")
+#define MSG_ERR_MAXTEMP                     _UxGT("Err: TEMP MAXIMA")
+#define MSG_ERR_MINTEMP                     _UxGT("Err: TEMP MINIMA")
+#define MSG_ERR_MAXTEMP_BED                 _UxGT("Err: TEMPMAX LLIT")
+#define MSG_ERR_MINTEMP_BED                 _UxGT("Err: TEMPMIN LLIT")
+#define MSG_ERR_Z_HOMING                    _UxGT("G28 Z No permes")
+#define MSG_HALTED                          _UxGT("IMPRESSORA PARADA")
+#define MSG_PLEASE_RESET                    _UxGT("Reinicieu")
+#define MSG_SHORT_DAY                       _UxGT("d") // One character only
+#define MSG_SHORT_HOUR                      _UxGT("h") // One character only
+#define MSG_SHORT_MINUTE                    _UxGT("m") // One character only
+#define MSG_HEATING                         _UxGT("Escalfant...")
+#define MSG_HEATING_COMPLETE                _UxGT("Escalfament fet.")
+#define MSG_BED_HEATING                     _UxGT("Escalfant llit")
+#define MSG_BED_DONE                        _UxGT("Llit fet.")
+#define MSG_DELTA_CALIBRATE                 _UxGT("Calibratge Delta")
+#define MSG_DELTA_CALIBRATE_X               _UxGT("Calibra X")
+#define MSG_DELTA_CALIBRATE_Y               _UxGT("Calibra Y")
+#define MSG_DELTA_CALIBRATE_Z               _UxGT("Calibra Z")
+#define MSG_DELTA_CALIBRATE_CENTER          _UxGT("Calibra el centre")
+
+#define MSG_INFO_MENU                       _UxGT("Quant a la impr.")
+#define MSG_INFO_PRINTER_MENU               _UxGT("Info Impressora")
+#define MSG_INFO_STATS_MENU                 _UxGT("Estadistiques")
+#define MSG_INFO_BOARD_MENU                 _UxGT("Info placa")
+#define MSG_INFO_THERMISTOR_MENU            _UxGT("Termistors")
+#define MSG_INFO_EXTRUDERS                  _UxGT("Extrusors")
+#define MSG_INFO_BAUDRATE                   _UxGT("Baud")
+#define MSG_INFO_PROTOCOL                   _UxGT("Protocol")
+#define MSG_LIGHTS_ON                       _UxGT("Encen el llum")
+#define MSG_LIGHTS_OFF                      _UxGT("Apaga el llum")
+
+#if LCD_WIDTH >= 20
+  #define MSG_INFO_PRINT_COUNT              _UxGT("Total impressions")
+  #define MSG_INFO_COMPLETED_PRINTS         _UxGT("Acabades")
+  #define MSG_INFO_PRINT_TIME               _UxGT("Temps imprimint")
+  #define MSG_INFO_PRINT_LONGEST            _UxGT("Treball mes llarg")
+  #define MSG_INFO_PRINT_FILAMENT           _UxGT("Total extrudit")
+#else
+  #define MSG_INFO_PRINT_COUNT              _UxGT("Impressions")
+  #define MSG_INFO_COMPLETED_PRINTS         _UxGT("Acabades")
+  #define MSG_INFO_PRINT_TIME               _UxGT("Total")
+  #define MSG_INFO_PRINT_LONGEST            _UxGT("Mes llarg")
+  #define MSG_INFO_PRINT_FILAMENT           _UxGT("Extrudit")
+#endif
+
+#define MSG_INFO_MIN_TEMP                   _UxGT("Temp. mnima")
+#define MSG_INFO_MAX_TEMP                   _UxGT("Temp. mxima")
+#define MSG_INFO_PSU                        _UxGT("Font alimentacio")
+
+#define MSG_DRIVE_STRENGTH                  _UxGT("Fora motor")
+#define MSG_DAC_PERCENT                     _UxGT("Driver %")
+#define MSG_DAC_EEPROM_WRITE                _UxGT("DAC EEPROM Write")
+#define MSG_FILAMENT_CHANGE_HEADER          _UxGT("CANVI DE FILAMENT")
+#define MSG_FILAMENT_CHANGE_OPTION_HEADER   _UxGT("OPCIONS CANVI:")
+#define MSG_FILAMENT_CHANGE_OPTION_EXTRUDE  _UxGT("Extrudeix mes")
+#define MSG_FILAMENT_CHANGE_OPTION_RESUME   _UxGT("Repren impressi")
+#define MSG_FILAMENT_CHANGE_MINTEMP         _UxGT("Temp minima es ")
+
+//
+// Filament Change screens show up to 3 lines on a 4-line display
+//                        ...or up to 2 lines on a 3-line display
+//
+#if LCD_HEIGHT >= 4
+  #define MSG_FILAMENT_CHANGE_INIT_1          _UxGT("Esperant per")
+  #define MSG_FILAMENT_CHANGE_INIT_2          _UxGT("iniciar el canvi")
+  #define MSG_FILAMENT_CHANGE_INIT_3          _UxGT("de filament")
+  #define MSG_FILAMENT_CHANGE_UNLOAD_1        _UxGT("Esperant per")
+  #define MSG_FILAMENT_CHANGE_UNLOAD_2        _UxGT("treure filament")
+  #define MSG_FILAMENT_CHANGE_INSERT_1        _UxGT("Poseu filament")
+  #define MSG_FILAMENT_CHANGE_INSERT_2        _UxGT("i premeu el boto")
+  #define MSG_FILAMENT_CHANGE_INSERT_3        _UxGT("per continuar...")
+  #define MSG_FILAMENT_CHANGE_HEAT_1          _UxGT("Premeu boto per")
+  #define MSG_FILAMENT_CHANGE_HEAT_2          _UxGT("escalfar nozzle.")
+  #define MSG_FILAMENT_CHANGE_HEATING_1       _UxGT("Escalfant nozzle")
+  #define MSG_FILAMENT_CHANGE_HEATING_2       _UxGT("Espereu...")
+  #define MSG_FILAMENT_CHANGE_LOAD_1          _UxGT("Esperant carrega")
+  #define MSG_FILAMENT_CHANGE_LOAD_2          _UxGT("de filament")
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_1       _UxGT("Esperant per")
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_2       _UxGT("extreure filament")
+  #define MSG_FILAMENT_CHANGE_RESUME_1        _UxGT("Esperant per")
+  #define MSG_FILAMENT_CHANGE_RESUME_2        _UxGT("reprendre")
+#else // LCD_HEIGHT < 4
+  #define MSG_FILAMENT_CHANGE_INIT_1          _UxGT("Espereu...")
+  #define MSG_FILAMENT_CHANGE_UNLOAD_1        _UxGT("Expulsant...")
+  #define MSG_FILAMENT_CHANGE_INSERT_1        _UxGT("Insereix i prem")
+  #define MSG_FILAMENT_CHANGE_HEATING_1       _UxGT("Escalfant...")
+  #define MSG_FILAMENT_CHANGE_LOAD_1          _UxGT("Carregant...")
+  #define MSG_FILAMENT_CHANGE_EXTRUDE_1       _UxGT("Extrudint...")
+  #define MSG_FILAMENT_CHANGE_RESUME_1        _UxGT("Reprenent...")
+#endif // LCD_HEIGHT < 4
 
 #endif // LANGUAGE_CA_H
diff --git a/Marlin/pins_SANGUINOLOLU_11.h b/Marlin/pins_SANGUINOLOLU_11.h
index cd8d1ccda66..4e644b74eb4 100644
--- a/Marlin/pins_SANGUINOLOLU_11.h
+++ b/Marlin/pins_SANGUINOLOLU_11.h
@@ -121,10 +121,6 @@
 //
 #if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)
 
-  // No buzzer installed
-  #define BEEPER_PIN -1
-
-  // LCD Pins
   #if ENABLED(DOGLCD)
 
     #if ENABLED(U8GLIB_ST7920) // SPI GLCD 12864 ST7920 ( like [www.digole.com] ) For Melzi V2.0
@@ -137,7 +133,7 @@
         // Marlin so this can be used for BEEPER_PIN. You can use this pin
         // with M42 instead of BEEPER_PIN.
         #define BEEPER_PIN      27
-      #else         // Sanguinololu 1.3
+      #else        // Sanguinololu 1.3
         #define LCD_PINS_RS      4
         #define LCD_PINS_ENABLE 17
         #define LCD_PINS_D4     30
@@ -149,9 +145,20 @@
     #else // DOGM SPI LCD Support
 
       #define DOGLCD_A0         30
-      #define DOGLCD_CS         29
       #define LCD_CONTRAST       1
 
+      #if ENABLED(MAKRPANEL)
+
+        #define BEEPER_PIN      29
+        #define DOGLCD_CS       17
+        #define LCD_BACKLIGHT_PIN 28 // PA3
+
+      #else // !MAKRPANEL
+
+        #define DOGLCD_CS       29
+
+      #endif
+
     #endif
 
     // Uncomment screen orientation
@@ -160,7 +167,7 @@
     //#define LCD_SCREEN_ROT_180
     //#define LCD_SCREEN_ROT_270
 
-  #else // !DOGLCD - Standard Hitachi LCD controller
+  #else // !DOGLCD
 
     #define LCD_PINS_RS          4
     #define LCD_PINS_ENABLE     17
@@ -171,9 +178,9 @@
 
   #endif // !DOGLCD
 
-  //The encoder and click button
   #define BTN_EN1               11
   #define BTN_EN2               10
+
   #if ENABLED(LCD_I2C_PANELOLU2)
     #if IS_MELZI
       #define BTN_ENC           29
@@ -181,33 +188,11 @@
     #else
       #define BTN_ENC           30
     #endif
-  #else
+  #else  // !Panelolu2
     #define BTN_ENC             16
     #define LCD_SDSS            28 // Smart Controller SD card reader rather than the Melzi
-  #endif // Panelolu2
-
-  #define SD_DETECT_PIN         -1
-
-#elif ENABLED(MAKRPANEL)
-
-  #define BEEPER_PIN            29
-
-  // Pins for DOGM SPI LCD Support
-  #define DOGLCD_A0             30
-  #define DOGLCD_CS             17
-  #define LCD_BACKLIGHT_PIN     28 // backlight LED on PA3
-  // GLCD features
-  #define LCD_CONTRAST           1
-  // Uncomment screen orientation
-  #define LCD_SCREEN_ROT_0
-  //#define LCD_SCREEN_ROT_90
-  //#define LCD_SCREEN_ROT_180
-  //#define LCD_SCREEN_ROT_270
-  //The encoder and click button
-  #define BTN_EN1               11
-  #define BTN_EN2               10
-  #define BTN_ENC               16
+  #endif // !Panelolu2
 
   #define SD_DETECT_PIN         -1
 
-#endif // MAKRPANEL
+#endif // ULTRA_LCD && NEWPANEL
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 459e0b11d58..ec81cd300d7 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -142,6 +142,7 @@ float Planner::previous_speed[NUM_AXIS],
 
 #if ENABLED(LIN_ADVANCE)
   float Planner::extruder_advance_k = LIN_ADVANCE_K,
+        Planner::advance_ed_ratio = LIN_ADVANCE_E_D_RATIO,
         Planner::position_float[NUM_AXIS] = { 0 };
 #endif
 
@@ -1324,7 +1325,12 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
                             && (uint32_t)esteps != block->step_event_count
                             && de_float > 0.0;
     if (block->use_advance_lead)
-      block->abs_adv_steps_multiplier8 = lround(extruder_advance_k * (de_float / mm_D_float) * block->nominal_speed / (float)block->nominal_rate * axis_steps_per_mm[E_AXIS_N] * 256.0);
+      block->abs_adv_steps_multiplier8 = lround(
+        extruder_advance_k
+        * (UNEAR_ZERO(advance_ed_ratio) ? de_float / mm_D_float : advance_ed_ratio) // Use the fixed ratio, if set
+        * (block->nominal_speed / (float)block->nominal_rate)
+        * axis_steps_per_mm[E_AXIS_N] * 256.0
+      );
 
   #elif ENABLED(ADVANCE)
 
@@ -1478,14 +1484,3 @@ void Planner::refresh_positioning() {
   }
 
 #endif
-
-#if ENABLED(LIN_ADVANCE)
-
-  void Planner::advance_M905(const float &k) {
-    if (k >= 0.0) extruder_advance_k = k;
-    SERIAL_ECHO_START;
-    SERIAL_ECHOPAIR("Advance factor: ", extruder_advance_k);
-    SERIAL_EOL;
-  }
-
-#endif
diff --git a/Marlin/planner.h b/Marlin/planner.h
index 3e8609a904d..c002c9977ba 100644
--- a/Marlin/planner.h
+++ b/Marlin/planner.h
@@ -210,6 +210,7 @@ class Planner {
     #if ENABLED(LIN_ADVANCE)
       static float position_float[NUM_AXIS];
       static float extruder_advance_k;
+      static float advance_ed_ratio;
     #endif
 
     #if ENABLED(ULTRA_LCD)
@@ -266,7 +267,9 @@ class Planner {
     #endif
 
     #if ENABLED(LIN_ADVANCE)
-      void advance_M905(const float &k);
+      static void set_extruder_advance_k(const float &k) { extruder_advance_k = k; };
+      static float get_extruder_advance_k() { return extruder_advance_k; };
+      static void set_advance_ed_ratio(const float &ratio) { advance_ed_ratio = ratio; };
     #endif
 
     /**
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index c0facef97dc..ac7fc6b367e 100755
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -51,7 +51,6 @@ int lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2], lcd_preheat_fan_speed[2
 
 #if ENABLED(BABYSTEPPING)
   long babysteps_done = 0;
-  millis_t status_screen_click_time = 0;
   static void lcd_babystep_z();
 #endif
 
@@ -417,22 +416,20 @@ uint16_t max_display_update_time = 0;
    * General function to go directly to a screen
    */
   void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder = 0) {
-    #ifdef DOUBLE_CLICK_JUMPS_TO_Z_BABYSTEPPING
-      #if ENABLED(BABYSTEPPING) 
-        if (currentScreen==lcd_status_screen && screen==lcd_main_menu)  // We are in leaving the status screen to goto the main_menu  
-          status_screen_click_time = millis();       // screen.  Mark the time so we know how quick the user is 
-                     // pressing buttons. 
-        if (currentScreen==lcd_main_menu)  { 
-          if ( screen==lcd_status_screen && status_screen_click_time+DOUBLE_CLICK_TIME_WINDOW>millis() ) { 
-            lcdDrawUpdate = LCDVIEW_CLEAR_CALL_REDRAW; 
-            status_screen_click_time = 0; 
-            lcd_babystep_z(); 
-          return; 
-          } 
-        } 
-      #endif 
-    #endif 
     if (currentScreen != screen) {
+
+      #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
+        static millis_t doubleclick_expire_ms = 0;
+        // Going to lcd_main_menu from status screen? Remember first click time.
+        // Going back to status screen within a very short time? Go to Z babystepping.
+        if (screen == lcd_main_menu) {
+          if (currentScreen == lcd_status_screen)
+            doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
+        }
+        else if (screen == lcd_status_screen && currentScreen == lcd_main_menu && PENDING(millis(), doubleclick_expire_ms))
+          screen = lcd_babystep_z;
+      #endif 
+
       currentScreen = screen;
       encoderPosition = encoder;
       if (screen == lcd_status_screen) {
@@ -788,9 +785,7 @@ void kill_screen(const char* lcd_msg) {
         babysteps_done += babystep_increment;
       }
       if (lcdDrawUpdate)
-        lcd_implementation_drawedit(msg, ftostr43sign(
-          ((1000 * babysteps_done) * planner.steps_to_mm[axis]) * 0.001f
-        ));
+        lcd_implementation_drawedit(msg, ftostr43sign(planner.steps_to_mm[axis] * babysteps_done));
     }
 
     #if ENABLED(BABYSTEP_XY)
diff --git a/Marlin/ultralcd_impl_DOGM.h b/Marlin/ultralcd_impl_DOGM.h
index 636f66baa27..cbfecacfe80 100644
--- a/Marlin/ultralcd_impl_DOGM.h
+++ b/Marlin/ultralcd_impl_DOGM.h
@@ -634,7 +634,7 @@ static void lcd_implementation_status_screen() {
 
       u8g.setPrintPos(LCD_PIXEL_WIDTH - 11 * (DOG_CHAR_WIDTH), row_y2);
       lcd_print('E');
-      lcd_print((char)('0' + active_extruder));
+      lcd_print((char)('1' + active_extruder));
       lcd_print(' ');
       lcd_print(itostr3(thermalManager.degHotend(active_extruder)));
       lcd_print('/');
diff --git a/Marlin/ultralcd_impl_HD44780.h b/Marlin/ultralcd_impl_HD44780.h
index f488fe220a7..8ccc961238c 100644
--- a/Marlin/ultralcd_impl_HD44780.h
+++ b/Marlin/ultralcd_impl_HD44780.h
@@ -807,7 +807,7 @@ static void lcd_implementation_status_screen() {
     static void lcd_implementation_hotend_status(const uint8_t row) {
       if (row < LCD_HEIGHT) {
         lcd.setCursor(LCD_WIDTH - 9, row);
-        lcd.print(LCD_STR_THERMOMETER[active_extruder]);
+        lcd.print(LCD_STR_THERMOMETER[0]);
         lcd.print(itostr3(thermalManager.degHotend(active_extruder)));
         lcd.print('/');
         lcd.print(itostr3(thermalManager.degTargetHotend(active_extruder)));
