diff --git a/.travis.yml b/.travis.yml
index eacedee8f1b..30210b42ffb 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -101,10 +101,10 @@ script:
   - opt_enable AUTO_BED_LEVELING_FEATURE DEBUG_LEVELING_FEATURE
   - build_marlin
   #
-  # Test a Mechanical Probe
+  # Test a Sled Z Probe
   #
   - restore_configs
-  - opt_enable MECHANICAL_PROBE
+  - opt_enable Z_PROBE_SLED
   - build_marlin
   #
   # ...with AUTO_BED_LEVELING_FEATURE & DEBUG_LEVELING_FEATURE
diff --git a/Marlin/Conditionals.h b/Marlin/Conditionals.h
index ad7d23cc440..c1db34cb19b 100644
--- a/Marlin/Conditionals.h
+++ b/Marlin/Conditionals.h
@@ -363,9 +363,11 @@
   #endif //!MANUAL_HOME_POSITIONS
 
   /**
-   * Auto Bed Leveling
+   * Auto Bed Leveling and Z Probe Repeatability Test
    */
-  #if ENABLED(AUTO_BED_LEVELING_FEATURE)
+  #define HAS_PROBING_PROCEDURE (ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST))
+
+  #if HAS_PROBING_PROCEDURE
     // Boundaries for probing based on set limits
     #define MIN_PROBE_X (max(X_MIN_POS, X_MIN_POS + X_PROBE_OFFSET_FROM_EXTRUDER))
     #define MAX_PROBE_X (min(X_MAX_POS, X_MAX_POS + X_PROBE_OFFSET_FROM_EXTRUDER))
@@ -376,12 +378,24 @@
   #define HAS_Z_SERVO_ENDSTOP (defined(Z_ENDSTOP_SERVO_NR) && Z_ENDSTOP_SERVO_NR >= 0)
 
   /**
-   * Sled Options
+   * Z Sled Probe requires Z_SAFE_HOMING
    */
   #if ENABLED(Z_PROBE_SLED)
     #define Z_SAFE_HOMING
   #endif
 
+  /**
+   * Safe Homing Options
+   */
+  #if ENABLED(Z_SAFE_HOMING)
+    #ifndef Z_SAFE_HOMING_X_POINT
+      #define Z_SAFE_HOMING_X_POINT ((X_MIN_POS + X_MAX_POS) / 2)
+    #endif
+    #ifndef Z_SAFE_HOMING_Y_POINT
+      #define Z_SAFE_HOMING_Y_POINT ((Y_MIN_POS + Y_MAX_POS) / 2)
+    #endif
+  #endif
+
   /**
    * Host keep alive
    */
@@ -750,7 +764,7 @@
     #endif
   #endif
 
-  #define PROBE_SELECTED (ENABLED(FIX_MOUNTED_PROBE) || ENABLED(MECHANICAL_PROBE) || ENABLED(Z_PROBE_ALLEN_KEY) || HAS_Z_SERVO_ENDSTOP || ENABLED(Z_PROBE_SLED))
+  #define PROBE_SELECTED (ENABLED(FIX_MOUNTED_PROBE) || ENABLED(Z_PROBE_ALLEN_KEY) || HAS_Z_SERVO_ENDSTOP || ENABLED(Z_PROBE_SLED))
 
   #define PROBE_PIN_CONFIGURED (HAS_Z_MIN_PROBE_PIN || (HAS_Z_MIN && ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)))
 
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index a55c878c196..d8f6af1fe83 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -419,8 +419,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -431,10 +433,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -517,6 +515,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -670,8 +669,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index b99c3fb9b08..17a1c421bec 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -352,7 +352,7 @@ float code_value_temp_diff();
 #if ENABLED(FWRETRACT)
   extern bool autoretract_enabled;
   extern bool retracted[EXTRUDERS]; // extruder[n].retracted
-  extern float retract_length, retract_length_swap, retract_feedrate, retract_zlift;
+  extern float retract_length, retract_length_swap, retract_feedrate_mm_s, retract_zlift;
   extern float retract_recover_length, retract_recover_length_swap, retract_recover_feedrate;
 #endif
 
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index ad83f42ea1c..0e42a4bad0b 100644
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -366,6 +366,8 @@ static uint8_t target_extruder;
   float zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;
 #endif
 
+#define PLANNER_XY_FEEDRATE() (min(planner.max_feedrate[X_AXIS], planner.max_feedrate[Y_AXIS]))
+
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   int xy_probe_speed = XY_PROBE_SPEED;
   bool bed_leveling_in_progress = false;
@@ -373,7 +375,7 @@ static uint8_t target_extruder;
 #elif defined(XY_PROBE_SPEED)
   #define XY_PROBE_FEEDRATE XY_PROBE_SPEED
 #else
-  #define XY_PROBE_FEEDRATE (min(planner.max_feedrate[X_AXIS], planner.max_feedrate[Y_AXIS]) * 60)
+  #define XY_PROBE_FEEDRATE (PLANNER_XY_FEEDRATE() * 60)
 #endif
 
 #if ENABLED(Z_DUAL_ENDSTOPS) && DISABLED(DELTA)
@@ -414,7 +416,7 @@ static uint8_t target_extruder;
 
   float retract_length = RETRACT_LENGTH;
   float retract_length_swap = RETRACT_LENGTH_SWAP;
-  float retract_feedrate = RETRACT_FEEDRATE;
+  float retract_feedrate_mm_s = RETRACT_FEEDRATE;
   float retract_zlift = RETRACT_ZLIFT;
   float retract_recover_length = RETRACT_RECOVER_LENGTH;
   float retract_recover_length_swap = RETRACT_RECOVER_LENGTH_SWAP;
@@ -493,8 +495,10 @@ static bool send_ok[BUFSIZE];
 #if HAS_SERVOS
   Servo servo[NUM_SERVOS];
   #define MOVE_SERVO(I, P) servo[I].move(P)
-  #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
-  #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
+  #if HAS_Z_SERVO_ENDSTOP
+    #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
+    #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
+  #endif
 #endif
 
 #ifdef CHDK
@@ -582,6 +586,9 @@ static void report_current_position();
     calculate_delta(current_position);
     planner.set_position_mm(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
   }
+  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_delta()
+#else
+  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
 #endif
 
 #if ENABLED(SDSUPPORT)
@@ -861,13 +868,16 @@ void setup() {
   // loads data from EEPROM if available else uses defaults (and resets step acceleration rate)
   Config_RetrieveSettings();
 
-  thermalManager.init();    // Initialize temperature loop
+  // Initialize current position based on home_offset
+  memcpy(current_position, home_offset, sizeof(home_offset));
 
   #if ENABLED(DELTA) || ENABLED(SCARA)
     // Vital to init kinematic equivalent for X0 Y0 Z0
-    sync_plan_position_delta();
+    SYNC_PLAN_POSITION_KINEMATIC();
   #endif
 
+  thermalManager.init();    // Initialize temperature loop
+
   #if ENABLED(USE_WATCHDOG)
     watchdog_init();
   #endif
@@ -918,8 +928,6 @@ void setup() {
       lcd_init();
     #endif
   #endif
-
-
 }
 
 /**
@@ -1581,33 +1589,40 @@ inline void set_destination_to_current() { memcpy(destination, current_position,
 //
 //  - Save current feedrates
 //  - Reset the rate multiplier
-//  - Enable the endstops
 //  - Reset the command timeout
+//  - Enable the endstops (for endstop moves)
 //
 // clean_up_after_endstop_move() restores
 // feedrates, sets endstops back to global state.
 //
-static void setup_for_endstop_move() {
+static void setup_for_endstop_or_probe_move() {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
+  #endif
   saved_feedrate = feedrate;
   saved_feedrate_multiplier = feedrate_multiplier;
   feedrate_multiplier = 100;
   refresh_cmd_timeout();
+}
+static void setup_for_endstop_move() {
+  setup_for_endstop_or_probe_move();
+  endstops.enable();
+}
+
+static void clean_up_after_endstop_or_probe_move() {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("setup_for_endstop_move > endstops.enable()");
+    if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
   #endif
-  endstops.enable();
+  feedrate = saved_feedrate;
+  feedrate_multiplier = saved_feedrate_multiplier;
+  refresh_cmd_timeout();
 }
 
 #if HAS_BED_PROBE
 
   static void clean_up_after_endstop_move() {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("clean_up_after_endstop_move > endstops.not_homing()");
-    #endif
+    clean_up_after_endstop_or_probe_move();
     endstops.not_homing();
-    feedrate = saved_feedrate;
-    feedrate_multiplier = saved_feedrate_multiplier;
-    refresh_cmd_timeout();
   }
 
   #if ENABLED(DELTA)
@@ -1678,37 +1693,55 @@ static void setup_for_endstop_move() {
     do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z);
   }
 
-  inline void raise_z_after_probing() {
-    #if Z_RAISE_AFTER_PROBING > 0
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("raise_z_after_probing()");
-      #endif
-      do_blocking_move_to_z(current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING);
-    #endif
-  }
-#endif //HAS_BED_PROBE
-
-#if HAS_Z_SERVO_ENDSTOP
-
   /**
-   * Raise Z to a minimum height to make room for a servo to move
+   * Raise Z to a minimum height to make room for a probe to move
    *
    * zprobe_zoffset: Negative of the Z height where the probe engages
-   *         z_dest: The before / after probing raise distance
+   *        z_raise: The probing raise distance
    *
    * The zprobe_zoffset is negative for a switch below the nozzle, so
    * multiply by Z_HOME_DIR (-1) to move enough away from the bed.
    */
-  void raise_z_for_servo(float z_dest) {
-    z_dest += home_offset[Z_AXIS];
+  inline void do_probe_raise(float z_raise) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
+        SERIAL_ECHOLNPGM(")");
+      }
+    #endif
+    float z_dest = home_offset[Z_AXIS] + z_raise;
 
     if ((Z_HOME_DIR) < 0 && zprobe_zoffset < 0)
       z_dest -= zprobe_zoffset;
 
-    if (z_dest > current_position[Z_AXIS])
-      do_blocking_move_to_z(z_dest); // also updates current_position
+    if (z_dest > current_position[Z_AXIS]) {
+      float old_feedrate = feedrate;
+      feedrate = homing_feedrate[Z_AXIS];
+      do_blocking_move_to_z(z_dest);
+      feedrate = old_feedrate;
+    }
+  }
+
+  inline void raise_z_after_probing() {
+    #if Z_RAISE_AFTER_PROBING > 0
+      do_probe_raise(Z_RAISE_AFTER_PROBING);
+    #endif
   }
+#endif //HAS_BED_PROBE
 
+#if ENABLED(Z_PROBE_SLED) || ENABLED(Z_SAFE_HOMING) || HAS_PROBING_PROCEDURE
+  static void axis_unhomed_error(bool xyz=false) {
+    if (xyz) {
+      LCD_MESSAGEPGM(MSG_XYZ_UNHOMED);
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM(MSG_XYZ_UNHOMED);
+    }
+    else {
+      LCD_MESSAGEPGM(MSG_YX_UNHOMED);
+      SERIAL_ECHO_START;
+      SERIAL_ECHOLNPGM(MSG_YX_UNHOMED);
+    }
+  }
 #endif
 
 #if ENABLED(Z_PROBE_SLED)
@@ -1739,19 +1772,24 @@ static void setup_for_endstop_move() {
     if (endstops.z_probe_enabled == !dock) return; // already docked/undocked?
 
     float oldXpos = current_position[X_AXIS]; // save x position
+    float old_feedrate = feedrate;
     if (dock) {
       raise_z_after_probing(); // raise Z
       // Dock sled a bit closer to ensure proper capturing
+      feedrate = XY_PROBE_FEEDRATE;
       do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET + offset - 1);
       digitalWrite(SLED_PIN, LOW); // turn off magnet
     }
     else {
+      feedrate = XY_PROBE_FEEDRATE;
       float z_loc = current_position[Z_AXIS];
       if (z_loc < Z_RAISE_BEFORE_PROBING + 5) z_loc = Z_RAISE_BEFORE_PROBING;
       do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset, current_position[Y_AXIS], z_loc); // this also updates current_position
       digitalWrite(SLED_PIN, HIGH); // turn on magnet
     }
     do_blocking_move_to_x(oldXpos); // return to position before docking
+
+    feedrate = old_feedrate;
   }
 
 #endif // Z_PROBE_SLED
@@ -1773,7 +1811,7 @@ static void setup_for_endstop_move() {
     #elif HAS_Z_SERVO_ENDSTOP
 
       // Make room for Z Servo
-      raise_z_for_servo(Z_RAISE_BEFORE_PROBING);
+      do_probe_raise(Z_RAISE_BEFORE_PROBING);
 
       // Engage Z Servo endstop if enabled
       DEPLOY_Z_SERVO();
@@ -1852,7 +1890,7 @@ static void setup_for_endstop_move() {
           stop();
         }
 
-    #elif ENABLED(FIX_MOUNTED_PROBE)
+    #else
 
       // Nothing to be done. Just enable_z_probe below...
 
@@ -1875,7 +1913,7 @@ static void setup_for_endstop_move() {
     #elif HAS_Z_SERVO_ENDSTOP
 
       // Make room for the servo
-      raise_z_for_servo(Z_RAISE_AFTER_PROBING);
+      do_probe_raise(Z_RAISE_AFTER_PROBING);
 
       // Change the Z servo angle
       STOW_Z_SERVO();
@@ -1944,7 +1982,7 @@ static void setup_for_endstop_move() {
           stop();
         }
 
-    #elif ENABLED(FIX_MOUNTED_PROBE)
+    #else
 
       // Nothing to do here. Just clear endstops.z_probe_enabled
 
@@ -1953,14 +1991,13 @@ static void setup_for_endstop_move() {
     endstops.enable_z_probe(false);
   }
 
-  static void run_z_probe() {
+  // Do a single Z probe and return with current_position[Z_AXIS]
+  // at the height where the probe triggered.
+  static float run_z_probe() {
 
     float old_feedrate = feedrate;
 
-    /**
-     * To prevent stepper_inactive_time from running out and
-     * EXTRUDER_RUNOUT_PREVENT from extruding
-     */
+    // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
     refresh_cmd_timeout();
 
     #if ENABLED(DELTA)
@@ -1991,7 +2028,7 @@ static void setup_for_endstop_move() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("run_z_probe (DELTA) 2", current_position);
       #endif
 
-      sync_plan_position_delta();
+      SYNC_PLAN_POSITION_KINEMATIC();
 
     #else // !DELTA
 
@@ -2029,7 +2066,8 @@ static void setup_for_endstop_move() {
 
       // Get the current stepper position after bumping an endstop
       current_position[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
-      sync_plan_position();
+
+      SYNC_PLAN_POSITION_KINEMATIC();
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("run_z_probe", current_position);
@@ -2038,10 +2076,96 @@ static void setup_for_endstop_move() {
     #endif // !DELTA
 
     feedrate = old_feedrate;
+
+    return current_position[Z_AXIS];
   }
 
 #endif // HAS_BED_PROBE
 
+#if HAS_PROBING_PROCEDURE
+
+  inline void do_blocking_move_to_xy(float x, float y) {
+    do_blocking_move_to(x, y, current_position[Z_AXIS]);
+  }
+
+  enum ProbeAction {
+    ProbeStay          = 0,
+    ProbeDeploy        = _BV(0),
+    ProbeStow          = _BV(1),
+    ProbeDeployAndStow = (ProbeDeploy | ProbeStow)
+  };
+
+  // Probe bed height at position (x,y), returns the measured z value
+  static float probe_pt(float x, float y, float z_raise, ProbeAction probe_action = ProbeDeployAndStow, int verbose_level = 1) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOLNPGM("probe_pt >>>");
+        SERIAL_ECHOPAIR("> ProbeAction:", probe_action);
+        SERIAL_EOL;
+        DEBUG_POS("", current_position);
+      }
+    #endif
+
+    float old_feedrate = feedrate;
+
+    // Raise by z_raise, then move the Z probe to the given XY
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("Z Raise by z_raise ", z_raise);
+        SERIAL_EOL;
+      }
+    #endif
+    do_probe_raise(z_raise); // this also updates current_position
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("> do_blocking_move_to_xy ", x - (X_PROBE_OFFSET_FROM_EXTRUDER));
+        SERIAL_ECHOPAIR(", ", y - (Y_PROBE_OFFSET_FROM_EXTRUDER));
+        SERIAL_EOL;
+      }
+    #endif
+
+    // this also updates current_position
+    feedrate = XY_PROBE_FEEDRATE;
+    do_blocking_move_to_xy(x - (X_PROBE_OFFSET_FROM_EXTRUDER), y - (Y_PROBE_OFFSET_FROM_EXTRUDER));
+
+    if (probe_action & ProbeDeploy) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> ProbeDeploy");
+      #endif
+      deploy_z_probe();
+    }
+
+    float measured_z = run_z_probe();
+
+    if (probe_action & ProbeStow) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> ProbeStow (stow_z_probe will do Z Raise)");
+      #endif
+      stow_z_probe();
+    }
+
+    if (verbose_level > 2) {
+      SERIAL_PROTOCOLPGM("Bed X: ");
+      SERIAL_PROTOCOL_F(x, 3);
+      SERIAL_PROTOCOLPGM(" Y: ");
+      SERIAL_PROTOCOL_F(y, 3);
+      SERIAL_PROTOCOLPGM(" Z: ");
+      SERIAL_PROTOCOL_F(measured_z, 3);
+      SERIAL_EOL;
+    }
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
+    #endif
+
+    feedrate = old_feedrate;
+
+    return measured_z;
+  }
+
+#endif // AUTO_BED_LEVELING_FEATURE || Z_MIN_PROBE_REPEATABILITY_TEST
+
 #if ENABLED(AUTO_BED_LEVELING_FEATURE)
 
   #if ENABLED(AUTO_BED_LEVELING_GRID)
@@ -2073,7 +2197,7 @@ static void setup_for_endstop_move() {
           if (DEBUGGING(LEVELING)) DEBUG_POS("<<< set_bed_level_equation_lsq", corrected_position);
         #endif
 
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
       }
 
     #endif // !DELTA
@@ -2084,6 +2208,13 @@ static void setup_for_endstop_move() {
 
       planner.bed_level_matrix.set_to_identity();
 
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) {
+          vector_3 uncorrected_position = planner.adjusted_position();
+          DEBUG_POS("set_bed_level_equation_3pts", uncorrected_position);
+        }
+      #endif
+
       vector_3 pt1 = vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, z_at_pt_1);
       vector_3 pt2 = vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, z_at_pt_2);
       vector_3 pt3 = vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, z_at_pt_3);
@@ -2096,16 +2227,8 @@ static void setup_for_endstop_move() {
       }
 
       planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
-
       vector_3 corrected_position = planner.adjusted_position();
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          vector_3 uncorrected_position = corrected_position;
-          DEBUG_POS("set_bed_level_equation_3pts", uncorrected_position);
-        }
-      #endif
-
       current_position[X_AXIS] = corrected_position.x;
       current_position[Y_AXIS] = corrected_position.y;
       current_position[Z_AXIS] = corrected_position.z;
@@ -2114,94 +2237,11 @@ static void setup_for_endstop_move() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("set_bed_level_equation_3pts", corrected_position);
       #endif
 
-      sync_plan_position();
+      SYNC_PLAN_POSITION_KINEMATIC();
     }
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  inline void do_blocking_move_to_xy(float x, float y) {
-    do_blocking_move_to(x, y, current_position[Z_AXIS]);
-  }
-
-  enum ProbeAction {
-    ProbeStay          = 0,
-    ProbeDeploy        = _BV(0),
-    ProbeStow          = _BV(1),
-    ProbeDeployAndStow = (ProbeDeploy | ProbeStow)
-  };
-
-  // Probe bed height at position (x,y), returns the measured z value
-  static float probe_pt(float x, float y, float z_before, ProbeAction probe_action = ProbeDeployAndStow, int verbose_level = 1) {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("probe_pt >>>");
-        SERIAL_ECHOPAIR("> ProbeAction:", probe_action);
-        SERIAL_EOL;
-        DEBUG_POS("", current_position);
-      }
-    #endif
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("Z Raise to z_before ", z_before);
-        SERIAL_EOL;
-        SERIAL_ECHOPAIR("> do_blocking_move_to_z ", z_before);
-        SERIAL_EOL;
-      }
-    #endif
-
-    // Move Z up to the z_before height, then move the Z probe to the given XY
-    do_blocking_move_to_z(z_before); // this also updates current_position
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("> do_blocking_move_to_xy ", x - (X_PROBE_OFFSET_FROM_EXTRUDER));
-        SERIAL_ECHOPAIR(", ", y - (Y_PROBE_OFFSET_FROM_EXTRUDER));
-        SERIAL_EOL;
-      }
-    #endif
-
-    // this also updates current_position
-    do_blocking_move_to_xy(x - (X_PROBE_OFFSET_FROM_EXTRUDER), y - (Y_PROBE_OFFSET_FROM_EXTRUDER));
-
-    #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)
-      if (probe_action & ProbeDeploy) {
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> ProbeDeploy");
-        #endif
-        deploy_z_probe();
-      }
-    #endif
-
-    run_z_probe();
-    float measured_z = current_position[Z_AXIS];
-
-    #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)
-      if (probe_action & ProbeStow) {
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> ProbeStow (stow_z_probe will do Z Raise)");
-        #endif
-        stow_z_probe();
-      }
-    #endif
-
-    if (verbose_level > 2) {
-      SERIAL_PROTOCOLPGM("Bed X: ");
-      SERIAL_PROTOCOL_F(x, 3);
-      SERIAL_PROTOCOLPGM(" Y: ");
-      SERIAL_PROTOCOL_F(y, 3);
-      SERIAL_PROTOCOLPGM(" Z: ");
-      SERIAL_PROTOCOL_F(measured_z, 3);
-      SERIAL_EOL;
-    }
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
-    #endif
-
-    return measured_z;
-  }
-
   #if ENABLED(DELTA)
 
     /**
@@ -2274,21 +2314,6 @@ static void setup_for_endstop_move() {
 
 #endif // AUTO_BED_LEVELING_FEATURE
 
-#if ENABLED(Z_PROBE_SLED) || ENABLED(Z_SAFE_HOMING) || ENABLED(AUTO_BED_LEVELING_FEATURE)
-  static void axis_unhomed_error(bool xyz=false) {
-    if (xyz) {
-      LCD_MESSAGEPGM(MSG_XYZ_UNHOMED);
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM(MSG_XYZ_UNHOMED);
-    }
-    else {
-      LCD_MESSAGEPGM(MSG_YX_UNHOMED);
-      SERIAL_ECHO_START;
-      SERIAL_ECHOLNPGM(MSG_YX_UNHOMED);
-    }
-  }
-#endif
-
 /**
  * Home an individual axis
  */
@@ -2315,7 +2340,7 @@ static void homeaxis(AxisEnum axis) {
 
     // Set the axis position as setup for the move
     current_position[axis] = 0;
-    sync_plan_position();
+    SYNC_PLAN_POSITION_KINEMATIC();
 
     // Homing Z towards the bed? Deploy the Z probe or endstop.
     #if HAS_BED_PROBE
@@ -2340,7 +2365,7 @@ static void homeaxis(AxisEnum axis) {
 
     // Set the axis position as setup for the move
     current_position[axis] = 0;
-    sync_plan_position();
+    SYNC_PLAN_POSITION_KINEMATIC();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(false)");
@@ -2381,7 +2406,7 @@ static void homeaxis(AxisEnum axis) {
           lockZ1 = (z_endstop_adj < 0);
 
         if (lockZ1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
 
         // Move to the adjusted endstop height
         feedrate = homing_feedrate[axis];
@@ -2401,7 +2426,7 @@ static void homeaxis(AxisEnum axis) {
           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(false)");
         #endif
         endstops.enable(false); // Disable endstops while moving away
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
         destination[axis] = endstop_adj[axis];
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
@@ -2428,7 +2453,8 @@ static void homeaxis(AxisEnum axis) {
 
     // Set the axis position to its home position (plus home offsets)
     set_axis_is_at_home(axis);
-    sync_plan_position();
+
+    SYNC_PLAN_POSITION_KINEMATIC();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
@@ -2466,24 +2492,20 @@ static void homeaxis(AxisEnum axis) {
 
     if (retracting == retracted[active_extruder]) return;
 
-    float oldFeedrate = feedrate;
+    float old_feedrate = feedrate;
 
     set_destination_to_current();
 
     if (retracting) {
 
-      feedrate = retract_feedrate * 60;
+      feedrate = retract_feedrate_mm_s * 60;
       current_position[E_AXIS] += (swapping ? retract_length_swap : retract_length) / volumetric_multiplier[active_extruder];
       sync_plan_position_e();
       prepare_move_to_destination();
 
       if (retract_zlift > 0.01) {
         current_position[Z_AXIS] -= retract_zlift;
-        #if ENABLED(DELTA)
-          sync_plan_position_delta();
-        #else
-          sync_plan_position();
-        #endif
+        SYNC_PLAN_POSITION_KINEMATIC();
         prepare_move_to_destination();
       }
     }
@@ -2491,11 +2513,7 @@ static void homeaxis(AxisEnum axis) {
 
       if (retract_zlift > 0.01) {
         current_position[Z_AXIS] += retract_zlift;
-        #if ENABLED(DELTA)
-          sync_plan_position_delta();
-        #else
-          sync_plan_position();
-        #endif
+        SYNC_PLAN_POSITION_KINEMATIC();
       }
 
       feedrate = retract_recover_feedrate * 60;
@@ -2505,7 +2523,7 @@ static void homeaxis(AxisEnum axis) {
       prepare_move_to_destination();
     }
 
-    feedrate = oldFeedrate;
+    feedrate = old_feedrate;
     retracted[active_extruder] = retracting;
 
   } // retract()
@@ -2806,7 +2824,7 @@ inline void gcode_G28() {
     HOMEAXIS(Y);
     HOMEAXIS(Z);
 
-    sync_plan_position_delta();
+    SYNC_PLAN_POSITION_KINEMATIC();
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("(DELTA)", current_position);
@@ -2868,7 +2886,7 @@ inline void gcode_G28() {
           int x_axis_home_dir = home_dir(X_AXIS);
         #endif
 
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
 
         float mlx = max_length(X_AXIS), mly = max_length(Y_AXIS),
               mlratio = mlx > mly ? mly / mlx : mlx / mly;
@@ -2881,7 +2899,7 @@ inline void gcode_G28() {
 
         set_axis_is_at_home(X_AXIS);
         set_axis_is_at_home(Y_AXIS);
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("> QUICK_HOME 1", current_position);
@@ -2965,7 +2983,7 @@ inline void gcode_G28() {
              * enough to reach Z_SAFE_HOMING XY positions.
              * Just make sure the planner is in sync.
              */
-            sync_plan_position();
+            SYNC_PLAN_POSITION_KINEMATIC();
 
             /**
              * Set the Z probe (or just the nozzle) destination to the safe
@@ -3050,29 +3068,18 @@ inline void gcode_G28() {
 
     #endif // Z_HOME_DIR < 0
 
-    sync_plan_position();
-
-  #endif // else DELTA
+    SYNC_PLAN_POSITION_KINEMATIC();
 
-  #if ENABLED(SCARA)
-    sync_plan_position_delta();
-  #endif
+  #endif // !DELTA (gcode_G28)
 
-  #if ENABLED(ENDSTOPS_ONLY_FOR_HOMING)
-    endstops.enable(false);
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("ENDSTOPS_ONLY_FOR_HOMING endstops.enable(false)");
-      }
-    #endif
-  #endif
+  endstops.not_homing();
 
   // Enable mesh leveling again
   #if ENABLED(MESH_BED_LEVELING)
     if (mbl.has_mesh()) {
       if (home_all_axis || (axis_homed[X_AXIS] && axis_homed[Y_AXIS] && homeZ)) {
         current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
         mbl.set_active(true);
         #if ENABLED(MESH_G28_REST_ORIGIN)
           current_position[Z_AXIS] = 0.0;
@@ -3088,7 +3095,7 @@ inline void gcode_G28() {
       }
       else if ((axis_homed[X_AXIS] && axis_homed[Y_AXIS] && axis_homed[Z_AXIS]) && (homeX || homeY)) {
         current_position[Z_AXIS] = pre_home_z;
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
         mbl.set_active(true);
         current_position[Z_AXIS] = pre_home_z -
           mbl.get_z(current_position[X_AXIS] - home_offset[X_AXIS],
@@ -3097,20 +3104,27 @@ inline void gcode_G28() {
     }
   #endif
 
-  feedrate = saved_feedrate;
-  feedrate_multiplier = saved_feedrate_multiplier;
-  refresh_cmd_timeout();
+  clean_up_after_endstop_or_probe_move();
+
   endstops.hit_on_purpose(); // clear endstop hit flags
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOLNPGM("<<< gcode_G28");
-    }
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
   #endif
 
   report_current_position();
 }
 
+#if HAS_PROBING_PROCEDURE
+
+  void out_of_range_error(const char* p_edge) {
+    SERIAL_PROTOCOLPGM("?Probe ");
+    serialprintPGM(p_edge);
+    SERIAL_PROTOCOLLNPGM(" position out of range.");
+  }
+
+#endif
+
 #if ENABLED(MESH_BED_LEVELING)
 
   enum MeshLevelingState { MeshReport, MeshStart, MeshNext, MeshSet, MeshSetZOffset, MeshReset };
@@ -3216,7 +3230,7 @@ inline void gcode_G28() {
         if (probe_point == 0) {
           // For the intial G29 S2 make Z a positive value (e.g., 4.0)
           current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
-          sync_plan_position();
+          SYNC_PLAN_POSITION_KINEMATIC();
         }
         else {
           // For G29 S2 after adjusting Z.
@@ -3296,7 +3310,7 @@ inline void gcode_G28() {
             mbl.get_z(current_position[X_AXIS] - home_offset[X_AXIS],
                       current_position[Y_AXIS] - home_offset[Y_AXIS]) - MESH_HOME_SEARCH_Z;
           mbl.reset();
-          sync_plan_position();
+          SYNC_PLAN_POSITION_KINEMATIC();
         }
         else
           mbl.reset();
@@ -3308,12 +3322,6 @@ inline void gcode_G28() {
 
 #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
 
-  void out_of_range_error(const char* p_edge) {
-    SERIAL_PROTOCOLPGM("?Probe ");
-    serialprintPGM(p_edge);
-    SERIAL_PROTOCOLLNPGM(" position out of range.");
-  }
-
   /**
    * G29: Detailed Z probe, probes the bed at 3 or more points.
    *      Will fail if the printer has not been homed with G28.
@@ -3373,8 +3381,11 @@ inline void gcode_G28() {
       return;
     }
 
-    bool dryrun = code_seen('D'),
-         deploy_probe_for_each_reading = code_seen('E');
+    bool dryrun = code_seen('D');
+
+    #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)
+      bool deploy_probe_for_each_reading = code_seen('E');
+    #endif
 
     #if ENABLED(AUTO_BED_LEVELING_GRID)
 
@@ -3464,20 +3475,17 @@ inline void gcode_G28() {
           if (DEBUGGING(LEVELING)) DEBUG_POS("AFTER matrix.set_to_identity", uncorrected_position);
         #endif
 
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
 
       #endif // !DELTA
     }
 
-    #if HAS_BED_PROBE
-      deploy_z_probe();
-    #endif
-
     stepper.synchronize();
 
-    setup_for_endstop_move();
+    setup_for_endstop_or_probe_move();
 
-    feedrate = homing_feedrate[Z_AXIS];
+    // Deploy the probe. Servo will raise if needed.
+    deploy_z_probe();
 
     bed_leveling_in_progress = true;
 
@@ -3535,16 +3543,16 @@ inline void gcode_G28() {
 
           // raise extruder
           float measured_z,
-                z_before = probePointCounter ? Z_RAISE_BETWEEN_PROBINGS + current_position[Z_AXIS] : Z_RAISE_BEFORE_PROBING + home_offset[Z_AXIS];
+                z_raise = probePointCounter ? Z_RAISE_BETWEEN_PROBINGS : Z_RAISE_BEFORE_PROBING;
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPGM("z_before = (");
+              SERIAL_ECHOPGM("z_raise = (");
               if (probePointCounter)
                 SERIAL_ECHOPGM("between) ");
               else
                 SERIAL_ECHOPGM("before) ");
-              SERIAL_ECHOLN(z_before);
+              SERIAL_ECHOLN(z_raise);
             }
           #endif
 
@@ -3554,17 +3562,21 @@ inline void gcode_G28() {
             if (distance_from_center > DELTA_PROBEABLE_RADIUS) continue;
           #endif //DELTA
 
-          ProbeAction act;
-          if (deploy_probe_for_each_reading) // G29 E - Stow between probes
-            act = ProbeDeployAndStow;
-          else if (yCount == 0 && xCount == xStart)
-            act = ProbeDeploy;
-          else if (yCount == auto_bed_leveling_grid_points - 1 && xCount == xStop - xInc)
-            act = ProbeStow;
-          else
-            act = ProbeStay;
+          #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
+            const ProbeAction act = ProbeStay;
+          #else
+            ProbeAction act;
+            if (deploy_probe_for_each_reading) // G29 E - Stow between probes
+              act = ProbeDeployAndStow;
+            else if (yCount == 0 && xCount == xStart)
+              act = ProbeDeploy;
+            else if (yCount == auto_bed_leveling_grid_points - 1 && xCount == xStop - xInc)
+              act = ProbeStow;
+            else
+              act = ProbeStay;
+          #endif
 
-          measured_z = probe_pt(xProbe, yProbe, z_before, act, verbose_level);
+          measured_z = probe_pt(xProbe, yProbe, z_raise, act, verbose_level);
 
           #if DISABLED(DELTA)
             mean += measured_z;
@@ -3589,8 +3601,6 @@ inline void gcode_G28() {
         if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
       #endif
 
-      clean_up_after_endstop_move();
-
       #if ENABLED(DELTA)
 
         if (!dryrun) extrapolate_unprobed_bed_level();
@@ -3690,32 +3700,34 @@ inline void gcode_G28() {
     #else // !AUTO_BED_LEVELING_GRID
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOLNPGM("> 3-point Leveling");
-        }
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
       #endif
 
-      // Actions for each probe
-      ProbeAction p1, p2, p3;
-      if (deploy_probe_for_each_reading)
-        p1 = p2 = p3 = ProbeDeployAndStow;
-      else
-        p1 = ProbeDeploy, p2 = ProbeStay, p3 = ProbeStow;
+      #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
+        const ProbeAction p1 = ProbeStay, p2 = ProbeStay, p3 = ProbeStay;
+      #else
+        // Actions for each probe
+        ProbeAction p1, p2, p3;
+        if (deploy_probe_for_each_reading)
+          p1 = p2 = p3 = ProbeDeployAndStow;
+        else
+          p1 = ProbeDeploy, p2 = ProbeStay, p3 = ProbeStow;
+      #endif
 
       // Probe at 3 arbitrary points
       float z_at_pt_1 = probe_pt( ABL_PROBE_PT_1_X + home_offset[X_AXIS],
                                   ABL_PROBE_PT_1_Y + home_offset[Y_AXIS],
-                                  Z_RAISE_BEFORE_PROBING + home_offset[Z_AXIS],
+                                  Z_RAISE_BEFORE_PROBING,
                                   p1, verbose_level),
             z_at_pt_2 = probe_pt( ABL_PROBE_PT_2_X + home_offset[X_AXIS],
                                   ABL_PROBE_PT_2_Y + home_offset[Y_AXIS],
-                                  current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS,
+                                  Z_RAISE_BETWEEN_PROBINGS,
                                   p2, verbose_level),
             z_at_pt_3 = probe_pt( ABL_PROBE_PT_3_X + home_offset[X_AXIS],
                                   ABL_PROBE_PT_3_Y + home_offset[Y_AXIS],
-                                  current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS,
+                                  Z_RAISE_BETWEEN_PROBINGS,
                                   p3, verbose_level);
-      clean_up_after_endstop_move();
+
       if (!dryrun) set_bed_level_equation_3pts(z_at_pt_1, z_at_pt_2, z_at_pt_3);
 
     #endif // !AUTO_BED_LEVELING_GRID
@@ -3782,23 +3794,23 @@ inline void gcode_G28() {
           #endif
         ;
         // current_position[Z_AXIS] += home_offset[Z_AXIS]; // The Z probe determines Z=0, not "Z home"
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("> corrected Z in G29", current_position);
         #endif
       }
+
     #endif // !DELTA
 
-    #if DISABLED(Z_PROBE_ALLEN_KEY) && DISABLED(Z_PROBE_SLED) && !HAS_Z_SERVO_ENDSTOP
-      raise_z_after_probing();
-    #endif
+    // Final raise of Z axis after probing.
+    raise_z_after_probing();
 
-    #if ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || ENABLED(MECHANICAL_PROBE)
-      stow_z_probe();
-    #else
-      endstops.enable_z_probe(false);
-    #endif
+    // Stow the probe. Servo will raise if needed.
+    stow_z_probe();
+
+    // Restore state after probing
+    clean_up_after_endstop_or_probe_move();
 
     #ifdef Z_PROBE_END_SCRIPT
       #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -3833,26 +3845,26 @@ inline void gcode_G28() {
    */
   inline void gcode_G30() {
 
-    setup_for_endstop_move();
+    setup_for_endstop_or_probe_move();
 
     deploy_z_probe();
 
     stepper.synchronize();
 
     // TODO: clear the leveling matrix or the planner will be set incorrectly
-    run_z_probe(); // clears the ABL non-delta matrix only
+    float measured_z = run_z_probe(); // clears the ABL non-delta matrix only
 
     SERIAL_PROTOCOLPGM("Bed X: ");
     SERIAL_PROTOCOL(current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER + 0.0001);
     SERIAL_PROTOCOLPGM(" Y: ");
     SERIAL_PROTOCOL(current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER + 0.0001);
     SERIAL_PROTOCOLPGM(" Z: ");
-    SERIAL_PROTOCOL(current_position[Z_AXIS] + 0.0001);
+    SERIAL_PROTOCOL(measured_z + 0.0001);
     SERIAL_EOL;
 
     stow_z_probe();
 
-    clean_up_after_endstop_move();
+    clean_up_after_endstop_or_probe_move();
 
     report_current_position();
   }
@@ -3882,16 +3894,10 @@ inline void gcode_G92() {
       }
     }
   }
-  if (didXYZ) {
-    #if ENABLED(DELTA) || ENABLED(SCARA)
-      sync_plan_position_delta();
-    #else
-      sync_plan_position();
-    #endif
-  }
-  else if (didE) {
+  if (didXYZ)
+    SYNC_PLAN_POSITION_KINEMATIC();
+  else if (didE)
     sync_plan_position_e();
-  }
 }
 
 #if ENABLED(ULTIPANEL)
@@ -4201,9 +4207,13 @@ inline void gcode_M42() {
     }
 
     float  X_current = current_position[X_AXIS],
-           Y_current = current_position[Y_AXIS],
-           Z_start_location = current_position[Z_AXIS] + Z_RAISE_BEFORE_PROBING;
-    bool deploy_probe_for_each_reading = code_seen('E');
+           Y_current = current_position[Y_AXIS];
+
+    #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
+      const bool deploy_probe_for_each_reading = false;
+    #else
+      bool deploy_probe_for_each_reading = code_seen('E');
+    #endif
 
     float X_probe_location = code_seen('X') ? code_value_axis_units(X_AXIS) : X_current + X_PROBE_OFFSET_FROM_EXTRUDER;
     #if DISABLED(DELTA)
@@ -4228,7 +4238,7 @@ inline void gcode_M42() {
 
     bool seen_L = code_seen('L');
     uint8_t n_legs = seen_L ? code_value_byte() : 0;
-    if (n_legs < 0 || n_legs > 15) {
+    if (n_legs > 15) {
       SERIAL_PROTOCOLPGM("?Number of legs in movement not plausible (0-15).\n");
       return;
     }
@@ -4248,34 +4258,35 @@ inline void gcode_M42() {
     #if ENABLED(DELTA)
       // we don't do bed level correction in M48 because we want the raw data when we probe
       reset_bed_level();
-    #else
+    #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
       // we don't do bed level correction in M48 because we want the raw data when we probe
       planner.bed_level_matrix.set_to_identity();
     #endif
 
-    if (Z_start_location < Z_RAISE_BEFORE_PROBING * 2.0)
-      do_blocking_move_to_z(Z_start_location);
+    setup_for_endstop_or_probe_move();
+
+    do_probe_raise(Z_RAISE_BEFORE_PROBING);
 
+    feedrate = XY_PROBE_FEEDRATE;
     do_blocking_move_to_xy(X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER), Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER));
 
     /**
      * OK, do the initial probe to get us close to the bed.
      * Then retrace the right amount and use that in subsequent probes
      */
-    setup_for_endstop_move();
 
     // Height before each probe (except the first)
-    float z_between = home_offset[Z_AXIS] + (deploy_probe_for_each_reading ? Z_RAISE_BEFORE_PROBING : Z_RAISE_BETWEEN_PROBINGS);
+    float z_between = deploy_probe_for_each_reading ? Z_RAISE_BEFORE_PROBING : Z_RAISE_BETWEEN_PROBINGS;
 
     // Deploy the probe and probe the first point
     probe_pt(X_probe_location, Y_probe_location,
-      home_offset[Z_AXIS] + Z_RAISE_BEFORE_PROBING,
+      Z_RAISE_BEFORE_PROBING,
       deploy_probe_for_each_reading ? ProbeDeployAndStow : ProbeDeploy,
       verbose_level);
 
     randomSeed(millis());
 
-    double mean, sigma, sample_set[n_samples];
+    double mean = 0, sigma = 0, sample_set[n_samples];
     for (uint8_t n = 0; n < n_samples; n++) {
       if (n_legs) {
         int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
@@ -4399,8 +4410,10 @@ inline void gcode_M42() {
 
       // Raise before the next loop for the legs,
       // or do the final raise after the last probe
-      if (n_legs || last_probe) {
-        do_blocking_move_to_z(last_probe ? home_offset[Z_AXIS] + Z_RAISE_AFTER_PROBING : z_between);
+      if (last_probe)
+        do_probe_raise(Z_RAISE_AFTER_PROBING);
+      else if (n_legs) {
+        do_probe_raise(z_between);
         if (!last_probe) delay(500);
       }
 
@@ -4416,7 +4429,7 @@ inline void gcode_M42() {
     SERIAL_PROTOCOL_F(sigma, 6);
     SERIAL_EOL; SERIAL_EOL;
 
-    clean_up_after_endstop_move();
+    clean_up_after_endstop_or_probe_move();
 
     report_current_position();
   }
@@ -5383,7 +5396,7 @@ inline void gcode_M206() {
     if (code_seen('P')) set_home_offset(Y_AXIS, code_value_axis_units(Y_AXIS)); // Psi
   #endif
 
-  sync_plan_position();
+  SYNC_PLAN_POSITION_KINEMATIC();
   report_current_position();
 }
 
@@ -5456,12 +5469,12 @@ inline void gcode_M206() {
    *
    *   S[+mm]    retract_length
    *   W[+mm]    retract_length_swap (multi-extruder)
-   *   F[mm/min] retract_feedrate
+   *   F[mm/min] retract_feedrate_mm_s
    *   Z[mm]     retract_zlift
    */
   inline void gcode_M207() {
     if (code_seen('S')) retract_length = code_value_axis_units(E_AXIS);
-    if (code_seen('F')) retract_feedrate = code_value_axis_units(E_AXIS) / 60;
+    if (code_seen('F')) retract_feedrate_mm_s = code_value_axis_units(E_AXIS) / 60;
     if (code_seen('Z')) retract_zlift = code_value_axis_units(Z_AXIS);
     #if EXTRUDERS > 1
       if (code_seen('W')) retract_length_swap = code_value_axis_units(E_AXIS);
@@ -5949,7 +5962,7 @@ inline void gcode_M303() {
  */
 inline void gcode_M400() { stepper.synchronize(); }
 
-#if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(Z_PROBE_SLED) && (HAS_Z_SERVO_ENDSTOP || ENABLED(Z_PROBE_ALLEN_KEY))
+#if HAS_BED_PROBE
 
   /**
    * M401: Engage Z Servo endstop if available
@@ -5965,7 +5978,7 @@ inline void gcode_M400() { stepper.synchronize(); }
     stow_z_probe();
   }
 
-#endif // AUTO_BED_LEVELING_FEATURE && (HAS_Z_SERVO_ENDSTOP || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED
+#endif // HAS_BED_PROBE
 
 #if ENABLED(FILAMENT_WIDTH_SENSOR)
 
@@ -6134,11 +6147,7 @@ inline void gcode_M428() {
   }
 
   if (!err) {
-    #if ENABLED(DELTA) || ENABLED(SCARA)
-      sync_plan_position_delta();
-    #else
-      sync_plan_position();
-    #endif
+    SYNC_PLAN_POSITION_KINEMATIC();
     report_current_position();
     LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
     #if HAS_BUZZER
@@ -6556,15 +6565,8 @@ inline void gcode_T(uint8_t tmp_extruder) {
       float next_feedrate = code_value_axis_units(X_AXIS);
       if (next_feedrate > 0.0) stored_feedrate = feedrate = next_feedrate;
     }
-    else {
-      feedrate =
-        #ifdef XY_PROBE_SPEED
-          XY_PROBE_SPEED
-        #else
-          min(planner.max_feedrate[X_AXIS], planner.max_feedrate[Y_AXIS]) * 60
-        #endif
-      ;
-    }
+    else
+      feedrate = XY_PROBE_FEEDRATE;
 
     if (tmp_extruder != active_extruder) {
       bool no_move = code_seen('S') && code_value_bool();
@@ -6704,11 +6706,7 @@ inline void gcode_T(uint8_t tmp_extruder) {
       #endif // !DUAL_X_CARRIAGE
 
       // Tell the planner the new "current position"
-      #if ENABLED(DELTA)
-        sync_plan_position_delta();
-      #else
-        sync_plan_position();
-      #endif
+      SYNC_PLAN_POSITION_KINEMATIC();
 
       // Move to the "old position" (move the extruder into place)
       if (!no_move && IsRunning()) prepare_move_to_destination();
@@ -7262,14 +7260,14 @@ void process_next_command() {
         gcode_M400();
         break;
 
-      #if ENABLED(AUTO_BED_LEVELING_FEATURE) && (HAS_Z_SERVO_ENDSTOP || ENABLED(Z_PROBE_ALLEN_KEY)) && DISABLED(Z_PROBE_SLED)
+      #if HAS_BED_PROBE
         case 401:
           gcode_M401();
           break;
         case 402:
           gcode_M402();
           break;
-      #endif // AUTO_BED_LEVELING_FEATURE && (HAS_Z_SERVO_ENDSTOP || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED
+      #endif // HAS_BED_PROBE
 
       #if ENABLED(FILAMENT_WIDTH_SENSOR)
         case 404:  //M404 Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
@@ -7657,7 +7655,7 @@ void mesh_buffer_line(float x, float y, float z, const float e, float feed_rate,
         planner.set_position_mm(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
         planner.buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset,
                          current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.max_feedrate[X_AXIS], 1);
-        sync_plan_position();
+        SYNC_PLAN_POSITION_KINEMATIC();
         stepper.synchronize();
         extruder_duplication_enabled = true;
         active_extruder_parked = false;
@@ -7677,7 +7675,7 @@ void mesh_buffer_line(float x, float y, float z, const float e, float feed_rate,
         delayed_move_time = 0;
         // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
         planner.buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], planner.max_feedrate[Z_AXIS], active_extruder);
-        planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], min(planner.max_feedrate[X_AXIS], planner.max_feedrate[Y_AXIS]), active_extruder);
+        planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], PLANNER_XY_FEEDRATE(), active_extruder);
         planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.max_feedrate[Z_AXIS], active_extruder);
         active_extruder_parked = false;
       }
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index a757f8a292f..dda663900cb 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -233,6 +233,17 @@
 
 #if PROBE_SELECTED
 
+  /**
+   * NUM_SERVOS is required for a Z servo probe
+   */
+  #if HAS_Z_SERVO_ENDSTOP
+    #ifndef NUM_SERVOS
+      #error "You must set NUM_SERVOS for a Z servo probe (Z_ENDSTOP_SERVO_NR)."
+    #elif Z_ENDSTOP_SERVO_NR >= NUM_SERVOS
+      #error "Z_ENDSTOP_SERVO_NR must be less than NUM_SERVOS."
+    #endif
+  #endif
+
   /**
    * A probe needs a pin
    */
@@ -257,11 +268,10 @@
   /**
    * Only allow one probe option to be defined
    */
-  #if (ENABLED(FIX_MOUNTED_PROBE) && (ENABLED(MECHANICAL_PROBE) || ENABLED(Z_PROBE_ALLEN_KEY) || HAS_Z_SERVO_ENDSTOP || ENABLED(Z_PROBE_SLED))) \
-       || (ENABLED(MECHANICAL_PROBE) && (ENABLED(Z_PROBE_ALLEN_KEY) || HAS_Z_SERVO_ENDSTOP || ENABLED(Z_PROBE_SLED))) \
+  #if (ENABLED(FIX_MOUNTED_PROBE) && (ENABLED(Z_PROBE_ALLEN_KEY) || HAS_Z_SERVO_ENDSTOP || ENABLED(Z_PROBE_SLED))) \
        || (ENABLED(Z_PROBE_ALLEN_KEY) && (HAS_Z_SERVO_ENDSTOP || ENABLED(Z_PROBE_SLED))) \
        || (HAS_Z_SERVO_ENDSTOP && ENABLED(Z_PROBE_SLED))
-    #error "Please define only one type of probe: Z Servo, MECHANICAL_PROBE, Z_PROBE_ALLEN_KEY, Z_PROBE_SLED, or FIX_MOUNTED_PROBE."
+    #error "Please define only one type of probe: Z Servo, Z_PROBE_ALLEN_KEY, Z_PROBE_SLED, or FIX_MOUNTED_PROBE."
   #endif
 
   /**
@@ -303,9 +313,9 @@
    * Require some kind of probe for bed leveling and probe testing
    */
   #if ENABLED(AUTO_BED_LEVELING_FEATURE)
-    #error "AUTO_BED_LEVELING_FEATURE requires a probe! Define a Z Servo, MECHANICAL_PROBE, Z_PROBE_ALLEN_KEY, Z_PROBE_SLED, or FIX_MOUNTED_PROBE."
+    #error "AUTO_BED_LEVELING_FEATURE requires a probe! Define a Z Servo, Z_PROBE_ALLEN_KEY, Z_PROBE_SLED, or FIX_MOUNTED_PROBE."
   #elif ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
-    #error "Z_MIN_PROBE_REPEATABILITY_TEST requires a probe! Define a Z Servo, MECHANICAL_PROBE, Z_PROBE_ALLEN_KEY, Z_PROBE_SLED, or FIX_MOUNTED_PROBE."
+    #error "Z_MIN_PROBE_REPEATABILITY_TEST requires a probe! Define a Z Servo, Z_PROBE_ALLEN_KEY, Z_PROBE_SLED, or FIX_MOUNTED_PROBE."
   #endif
 
 #endif
diff --git a/Marlin/configuration_store.cpp b/Marlin/configuration_store.cpp
index 4bad3ce0ce3..3def1c3eb8c 100644
--- a/Marlin/configuration_store.cpp
+++ b/Marlin/configuration_store.cpp
@@ -107,7 +107,7 @@
  *  391  M209 S    autoretract_enabled (bool)
  *  392  M207 S    retract_length (float)
  *  396  M207 W    retract_length_swap (float)
- *  400  M207 F    retract_feedrate (float)
+ *  400  M207 F    retract_feedrate_mm_s (float)
  *  404  M207 Z    retract_zlift (float)
  *  408  M208 S    retract_recover_length (float)
  *  412  M208 W    retract_recover_length_swap (float)
@@ -304,7 +304,7 @@ void Config_StoreSettings()  {
       dummy = 0.0f;
       EEPROM_WRITE_VAR(i, dummy);
     #endif
-    EEPROM_WRITE_VAR(i, retract_feedrate);
+    EEPROM_WRITE_VAR(i, retract_feedrate_mm_s);
     EEPROM_WRITE_VAR(i, retract_zlift);
     EEPROM_WRITE_VAR(i, retract_recover_length);
     #if EXTRUDERS > 1
@@ -482,7 +482,7 @@ void Config_RetrieveSettings() {
       #else
         EEPROM_READ_VAR(i, dummy);
       #endif
-      EEPROM_READ_VAR(i, retract_feedrate);
+      EEPROM_READ_VAR(i, retract_feedrate_mm_s);
       EEPROM_READ_VAR(i, retract_zlift);
       EEPROM_READ_VAR(i, retract_recover_length);
       #if EXTRUDERS > 1
@@ -617,7 +617,7 @@ void Config_ResetDefault() {
     #if EXTRUDERS > 1
       retract_length_swap = RETRACT_LENGTH_SWAP;
     #endif
-    retract_feedrate = RETRACT_FEEDRATE;
+    retract_feedrate_mm_s = RETRACT_FEEDRATE;
     retract_zlift = RETRACT_ZLIFT;
     retract_recover_length = RETRACT_RECOVER_LENGTH;
     #if EXTRUDERS > 1
@@ -864,7 +864,7 @@ void Config_PrintSettings(bool forReplay) {
     #if EXTRUDERS > 1
       SERIAL_ECHOPAIR(" W", retract_length_swap);
     #endif
-    SERIAL_ECHOPAIR(" F", retract_feedrate * 60);
+    SERIAL_ECHOPAIR(" F", retract_feedrate_mm_s * 60);
     SERIAL_ECHOPAIR(" Z", retract_zlift);
     SERIAL_EOL;
     CONFIG_ECHO_START;
diff --git a/Marlin/example_configurations/Cartesio/Configuration.h b/Marlin/example_configurations/Cartesio/Configuration.h
index 5eebcb077d6..bbc7d10bf98 100644
--- a/Marlin/example_configurations/Cartesio/Configuration.h
+++ b/Marlin/example_configurations/Cartesio/Configuration.h
@@ -418,8 +418,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -430,10 +432,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -516,6 +514,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -669,8 +668,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/Felix/Configuration.h b/Marlin/example_configurations/Felix/Configuration.h
index fce00f7e06f..4c79f69a1e4 100644
--- a/Marlin/example_configurations/Felix/Configuration.h
+++ b/Marlin/example_configurations/Felix/Configuration.h
@@ -401,8 +401,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -413,10 +415,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -499,6 +497,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -652,8 +651,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/Felix/DUAL/Configuration.h b/Marlin/example_configurations/Felix/DUAL/Configuration.h
index 4881d29a03b..28e0862faf8 100644
--- a/Marlin/example_configurations/Felix/DUAL/Configuration.h
+++ b/Marlin/example_configurations/Felix/DUAL/Configuration.h
@@ -399,8 +399,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -411,10 +413,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -497,6 +495,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -650,8 +649,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/Hephestos/Configuration.h b/Marlin/example_configurations/Hephestos/Configuration.h
index 91d879da465..2389c10a93d 100644
--- a/Marlin/example_configurations/Hephestos/Configuration.h
+++ b/Marlin/example_configurations/Hephestos/Configuration.h
@@ -411,8 +411,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -423,10 +425,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -509,6 +507,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -662,8 +661,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/Hephestos_2/Configuration.h b/Marlin/example_configurations/Hephestos_2/Configuration.h
index dce0c97eef0..46db141181d 100644
--- a/Marlin/example_configurations/Hephestos_2/Configuration.h
+++ b/Marlin/example_configurations/Hephestos_2/Configuration.h
@@ -413,8 +413,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 #define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -425,10 +427,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -511,6 +509,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 5    // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 5     // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 2  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -664,8 +663,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 2  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/K8200/Configuration.h b/Marlin/example_configurations/K8200/Configuration.h
index 0431ff3b32b..1f7504e110e 100644
--- a/Marlin/example_configurations/K8200/Configuration.h
+++ b/Marlin/example_configurations/K8200/Configuration.h
@@ -436,8 +436,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -448,10 +450,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -534,6 +532,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -687,8 +686,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h b/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
index b84730898c9..15e3d56adaa 100644
--- a/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
+++ b/Marlin/example_configurations/RepRapWorld/Megatronics/Configuration.h
@@ -419,8 +419,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -431,10 +433,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -517,6 +515,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -670,8 +669,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/RigidBot/Configuration.h b/Marlin/example_configurations/RigidBot/Configuration.h
index 7d842551537..29f26f43d3c 100644
--- a/Marlin/example_configurations/RigidBot/Configuration.h
+++ b/Marlin/example_configurations/RigidBot/Configuration.h
@@ -413,8 +413,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -425,10 +427,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -511,6 +509,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -664,8 +663,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/SCARA/Configuration.h b/Marlin/example_configurations/SCARA/Configuration.h
index 7bb2c7d7b43..7b29ec92c97 100644
--- a/Marlin/example_configurations/SCARA/Configuration.h
+++ b/Marlin/example_configurations/SCARA/Configuration.h
@@ -427,8 +427,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -439,10 +441,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -525,6 +523,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -678,8 +677,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/TAZ4/Configuration.h b/Marlin/example_configurations/TAZ4/Configuration.h
index fbaed6a81db..5565df7e06b 100644
--- a/Marlin/example_configurations/TAZ4/Configuration.h
+++ b/Marlin/example_configurations/TAZ4/Configuration.h
@@ -440,8 +440,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -452,10 +454,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -538,6 +536,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -691,8 +690,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/WITBOX/Configuration.h b/Marlin/example_configurations/WITBOX/Configuration.h
index 1fa1f66b30d..65ffac1a1ee 100644
--- a/Marlin/example_configurations/WITBOX/Configuration.h
+++ b/Marlin/example_configurations/WITBOX/Configuration.h
@@ -411,8 +411,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -423,10 +425,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -509,6 +507,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -662,8 +661,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/adafruit/ST7565/Configuration.h b/Marlin/example_configurations/adafruit/ST7565/Configuration.h
index 1d24232325a..21a47e76291 100644
--- a/Marlin/example_configurations/adafruit/ST7565/Configuration.h
+++ b/Marlin/example_configurations/adafruit/ST7565/Configuration.h
@@ -419,8 +419,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -431,10 +433,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -517,6 +515,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -670,8 +669,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/delta/biv2.5/Configuration.h b/Marlin/example_configurations/delta/biv2.5/Configuration.h
index 527e917f90b..35202c9eade 100644
--- a/Marlin/example_configurations/delta/biv2.5/Configuration.h
+++ b/Marlin/example_configurations/delta/biv2.5/Configuration.h
@@ -461,8 +461,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -473,10 +475,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -596,6 +594,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 50    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -753,8 +752,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/delta/generic/Configuration.h b/Marlin/example_configurations/delta/generic/Configuration.h
index c870c8a10bb..46bb74b458c 100644
--- a/Marlin/example_configurations/delta/generic/Configuration.h
+++ b/Marlin/example_configurations/delta/generic/Configuration.h
@@ -461,8 +461,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -473,10 +475,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -590,6 +588,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 50    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -747,8 +746,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration.h b/Marlin/example_configurations/delta/kossel_mini/Configuration.h
index 2052ccf6723..f94964a16c8 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration.h
@@ -461,8 +461,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -473,10 +475,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -593,6 +591,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 50    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -750,8 +749,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration.h b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
index 64c242bb936..d9b18cf7dee 100644
--- a/Marlin/example_configurations/delta/kossel_pro/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
@@ -450,8 +450,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -462,10 +464,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -587,6 +585,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 100  // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -744,8 +743,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/delta/kossel_xl/Configuration.h b/Marlin/example_configurations/delta/kossel_xl/Configuration.h
index a992ffbf373..d453fc5893e 100644
--- a/Marlin/example_configurations/delta/kossel_xl/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_xl/Configuration.h
@@ -459,8 +459,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 #define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -471,10 +473,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -588,6 +586,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 20   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 20    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 10 // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -745,8 +744,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 10 // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/makibox/Configuration.h b/Marlin/example_configurations/makibox/Configuration.h
index af2b9f9f971..fcc45adec01 100644
--- a/Marlin/example_configurations/makibox/Configuration.h
+++ b/Marlin/example_configurations/makibox/Configuration.h
@@ -422,8 +422,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -434,10 +436,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -520,6 +518,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -673,8 +672,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the l
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/example_configurations/tvrrug/Round2/Configuration.h b/Marlin/example_configurations/tvrrug/Round2/Configuration.h
index efbc931ccc7..7fcf6e39437 100644
--- a/Marlin/example_configurations/tvrrug/Round2/Configuration.h
+++ b/Marlin/example_configurations/tvrrug/Round2/Configuration.h
@@ -409,8 +409,10 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // Use M851 to set the Z probe vertical offset from the nozzle. Store with M500.
 //
 
-// A fix mounted probe, like the normal inductive probe, must be deactivated to go
-// below Z_PROBE_OFFSET_FROM_EXTRUDER when the hardware endstops are active.
+// A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
+// For example an inductive probe, or a setup that uses the nozzle to probe.
+// An inductive probe must be deactivated to go below
+// its trigger-point if hardware endstops are active.
 //#define FIX_MOUNTED_PROBE
 
 // Z Servo Probe, such as an endstop switch on a rotating arm.
@@ -421,10 +423,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
 
-// A Mechanical Probe is any probe that either doesn't deploy or needs manual deployment
-// For example any setup that uses the nozzle itself as a probe.
-//#define MECHANICAL_PROBE
-
 // Z Probe to nozzle (X,Y) offset, relative to (0, 0).
 // X and Y offsets must be integers.
 //
@@ -507,6 +505,7 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 // For G29 these apply before and after the full procedure.
 #define Z_RAISE_BEFORE_PROBING 15   // Raise before probe deploy (e.g., the first probe).
 #define Z_RAISE_AFTER_PROBING 15    // Raise before probe stow (e.g., the last probe).
+#define Z_RAISE_BETWEEN_PROBINGS 5  // Raise between probing points.
 
 //
 // For M851 give a range for adjusting the Z probe offset
@@ -660,8 +659,6 @@ const bool Z_MIN_PROBE_ENDSTOP_INVERTING = true; // set to true to invert the lo
 
   #endif // !AUTO_BED_LEVELING_GRID
 
-  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.
-
   //#define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.
                                                                              // Useful to retract a deployable Z probe.
 
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index cb10f9d2517..4a19968d0d6 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -462,7 +462,7 @@ int Temperature::getHeaterPower(int heater) {
       EXTRUDER_3_AUTO_FAN_PIN == EXTRUDER_2_AUTO_FAN_PIN ? 2 : 3
     };
     uint8_t fanState = 0;
-    for (int f = 0; f <= HOTENDS; f++) {
+    for (int f = 0; f < HOTENDS; f++) {
       if (current_temperature[f] > EXTRUDER_AUTO_FAN_TEMPERATURE)
         SBI(fanState, fanBit[f]);
     }
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 6f5990acada..3b33a97a686 100755
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -1797,7 +1797,7 @@ static void lcd_status_screen() {
       #if EXTRUDERS > 1
         MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &retract_length_swap, 0, 100);
       #endif
-      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate, 1, 999);
+      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate_mm_s, 1, 999);
       MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);
       MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, 0, 100);
       #if EXTRUDERS > 1
