diff --git a/Marlin/src/HAL/HAL_DUE/usb/conf_access.h b/Marlin/src/HAL/HAL_DUE/usb/conf_access.h
index ccb50199d92..fdac1ab7e84 100644
--- a/Marlin/src/HAL/HAL_DUE/usb/conf_access.h
+++ b/Marlin/src/HAL/HAL_DUE/usb/conf_access.h
@@ -54,11 +54,7 @@
  */
 //! @{
 
-#ifdef SDSUPPORT
-  #define LUN_0              ENABLE    //!< SD/MMC Card over MCI Slot 0.
-#else
-  #define LUN_0              DISABLE
-#endif
+#define LUN_0                ENABLE    //!< SD/MMC Card over MCI Slot 0.
 #define LUN_1                DISABLE
 #define LUN_2                DISABLE
 #define LUN_3                DISABLE
diff --git a/Marlin/src/HAL/HAL_DUE/usb/conf_usb.h b/Marlin/src/HAL/HAL_DUE/usb/conf_usb.h
index 21189652aa3..604fd2019b1 100644
--- a/Marlin/src/HAL/HAL_DUE/usb/conf_usb.h
+++ b/Marlin/src/HAL/HAL_DUE/usb/conf_usb.h
@@ -114,48 +114,51 @@
 #define  USB_DEVICE_SPECIFIC_REQUEST()  usb_task_other_requests()
 //@}
 
-/**
- * USB Device low level configuration
- * When only one interface is used, these configurations are defined by the class module.
- * For composite device, these configuration must be defined here
- * @{
- */
-//! Control endpoint size
-#define  USB_DEVICE_EP_CTRL_SIZE       64
-
-//! Two interfaces for this device (CDC COM + CDC DATA + MSC)
-#define  USB_DEVICE_NB_INTERFACE       3
-
-//! 5 endpoints used by CDC and MSC interfaces
-#if SAM3U
-// (3 | USB_EP_DIR_IN)  // CDC Notify endpoint
-// (6 | USB_EP_DIR_IN)  // CDC TX
-// (5 | USB_EP_DIR_OUT) // CDC RX
-// (1 | USB_EP_DIR_IN)  // MSC IN
-// (2 | USB_EP_DIR_OUT) // MSC OUT
-#  define  USB_DEVICE_MAX_EP           6
-#  if defined(USB_DEVICE_HS_SUPPORT)
-// In HS mode, size of bulk endpoints are 512
-// If CDC and MSC endpoints all uses 2 banks, DPRAM is not enough: 4 bulk
-// endpoints requires 4K bytes. So reduce the number of banks of CDC bulk
-// endpoints to use less DPRAM. Keep MSC setting to keep MSC performance.
-#     define  UDD_BULK_NB_BANK(ep) ((ep == 5 || ep== 6) ? 1 : 2)
-#endif
-#else
-// (3 | USB_EP_DIR_IN)  // CDC Notify endpoint
-// (4 | USB_EP_DIR_IN)  // CDC TX
-// (5 | USB_EP_DIR_OUT) // CDC RX
-// (1 | USB_EP_DIR_IN)  // MSC IN
-// (2 | USB_EP_DIR_OUT) // MSC OUT
-#  define  USB_DEVICE_MAX_EP           5
-#  if SAM3XA && defined(USB_DEVICE_HS_SUPPORT)
-// In HS mode, size of bulk endpoints are 512
-// If CDC and MSC endpoints all uses 2 banks, DPRAM is not enough: 4 bulk
-// endpoints requires 4K bytes. So reduce the number of banks of CDC bulk
-// endpoints to use less DPRAM. Keep MSC setting to keep MSC performance.
-#     define  UDD_BULK_NB_BANK(ep) ((ep == 4 || ep== 5) ? 1 : 2)
-#  endif
+#if ENABLED(SDSUPPORT)
+  /**
+   * USB Device low level configuration
+   * When only one interface is used, these configurations are defined by the class module.
+   * For composite device, these configuration must be defined here
+   * @{
+   */
+  //! Control endpoint size
+  #define  USB_DEVICE_EP_CTRL_SIZE       64
+
+  //! Two interfaces for this device (CDC COM + CDC DATA + MSC)
+  #define  USB_DEVICE_NB_INTERFACE       3
+
+  //! 5 endpoints used by CDC and MSC interfaces
+  #if SAM3U
+  // (3 | USB_EP_DIR_IN)  // CDC Notify endpoint
+  // (6 | USB_EP_DIR_IN)  // CDC TX
+  // (5 | USB_EP_DIR_OUT) // CDC RX
+  // (1 | USB_EP_DIR_IN)  // MSC IN
+  // (2 | USB_EP_DIR_OUT) // MSC OUT
+  #  define  USB_DEVICE_MAX_EP           6
+  #  if defined(USB_DEVICE_HS_SUPPORT)
+  // In HS mode, size of bulk endpoints are 512
+  // If CDC and MSC endpoints all uses 2 banks, DPRAM is not enough: 4 bulk
+  // endpoints requires 4K bytes. So reduce the number of banks of CDC bulk
+  // endpoints to use less DPRAM. Keep MSC setting to keep MSC performance.
+  #     define  UDD_BULK_NB_BANK(ep) ((ep == 5 || ep== 6) ? 1 : 2)
+  #endif
+  #else
+  // (3 | USB_EP_DIR_IN)  // CDC Notify endpoint
+  // (4 | USB_EP_DIR_IN)  // CDC TX
+  // (5 | USB_EP_DIR_OUT) // CDC RX
+  // (1 | USB_EP_DIR_IN)  // MSC IN
+  // (2 | USB_EP_DIR_OUT) // MSC OUT
+  #  define  USB_DEVICE_MAX_EP           5
+  #  if SAM3XA && defined(USB_DEVICE_HS_SUPPORT)
+  // In HS mode, size of bulk endpoints are 512
+  // If CDC and MSC endpoints all uses 2 banks, DPRAM is not enough: 4 bulk
+  // endpoints requires 4K bytes. So reduce the number of banks of CDC bulk
+  // endpoints to use less DPRAM. Keep MSC setting to keep MSC performance.
+  #     define  UDD_BULK_NB_BANK(ep) ((ep == 4 || ep== 5) ? 1 : 2)
+  #  endif
+  #endif
 #endif
+
 //@}
 
 //@}
@@ -195,107 +198,112 @@
 //! Enable id string of interface to add an extra USB string
 #define  UDI_CDC_IAD_STRING_ID            4
 
-/**
- * USB CDC low level configuration
- * In standalone these configurations are defined by the CDC module.
- * For composite device, these configuration must be defined here
- * @{
- */
-//! Endpoint numbers definition
-#if SAM3U
-#  define  UDI_CDC_COMM_EP_0             (3 | USB_EP_DIR_IN) // Notify endpoint
-#  define  UDI_CDC_DATA_EP_IN_0          (6 | USB_EP_DIR_IN) // TX
-#  define  UDI_CDC_DATA_EP_OUT_0         (5 | USB_EP_DIR_OUT)// RX
+#if ENABLED(SDSUPPORT)
+  /**
+   * USB CDC low level configuration
+   * In standalone these configurations are defined by the CDC module.
+   * For composite device, these configuration must be defined here
+   * @{
+   */
+  //! Endpoint numbers definition
+  #if SAM3U
+  #  define  UDI_CDC_COMM_EP_0             (3 | USB_EP_DIR_IN) // Notify endpoint
+  #  define  UDI_CDC_DATA_EP_IN_0          (6 | USB_EP_DIR_IN) // TX
+  #  define  UDI_CDC_DATA_EP_OUT_0         (5 | USB_EP_DIR_OUT)// RX
+  #else
+  #  define  UDI_CDC_COMM_EP_0             (3 | USB_EP_DIR_IN) // Notify endpoint
+  #  define  UDI_CDC_DATA_EP_IN_0          (4 | USB_EP_DIR_IN) // TX
+  #  define  UDI_CDC_DATA_EP_OUT_0         (5 | USB_EP_DIR_OUT)// RX
+  #endif
+
+  //! Interface numbers
+  #define  UDI_CDC_COMM_IFACE_NUMBER_0   0
+  #define  UDI_CDC_DATA_IFACE_NUMBER_0   1
+
+  //@}
+  //@}
+
+
+  /**
+   * Configuration of MSC interface
+   * @{
+   */
+  //! Vendor name and Product version of MSC interface
+  #define UDI_MSC_GLOBAL_VENDOR_ID            \
+     'M', 'A', 'R', 'L', 'I', 'N', '3', 'D'
+  #define UDI_MSC_GLOBAL_PRODUCT_VERSION            \
+     '1', '.', '0', '0'
+
+  //! Interface callback definition
+  #define  UDI_MSC_ENABLE_EXT()          usb_task_msc_enable()
+  #define  UDI_MSC_DISABLE_EXT()         usb_task_msc_disable()
+
+  //! Enable id string of interface to add an extra USB string
+  #define  UDI_MSC_STRING_ID             5
+
+  /**
+   * USB MSC low level configuration
+   * In standalone these configurations are defined by the MSC module.
+   * For composite device, these configuration must be defined here
+   * @{
+   */
+  //! Endpoint numbers definition
+  #define  UDI_MSC_EP_IN                 (1 | USB_EP_DIR_IN)
+  #define  UDI_MSC_EP_OUT                (2 | USB_EP_DIR_OUT)
+
+  //! Interface number
+  #define  UDI_MSC_IFACE_NUMBER          2
+  //@}
+  //@}
+
+  //@}
+
+
+  /**
+   * Description of Composite Device
+   * @{
+   */
+  //! USB Interfaces descriptor structure
+  #define UDI_COMPOSITE_DESC_T \
+    usb_iad_desc_t       udi_cdc_iad; \
+    udi_cdc_comm_desc_t  udi_cdc_comm; \
+    udi_cdc_data_desc_t  udi_cdc_data; \
+    udi_msc_desc_t       udi_msc
+
+  //! USB Interfaces descriptor value for Full Speed
+  #define UDI_COMPOSITE_DESC_FS \
+    .udi_cdc_iad   = UDI_CDC_IAD_DESC_0, \
+    .udi_cdc_comm  = UDI_CDC_COMM_DESC_0, \
+    .udi_cdc_data  = UDI_CDC_DATA_DESC_0_FS, \
+    .udi_msc       = UDI_MSC_DESC_FS
+
+  //! USB Interfaces descriptor value for High Speed
+  #define UDI_COMPOSITE_DESC_HS \
+    .udi_cdc_iad   = UDI_CDC_IAD_DESC_0, \
+    .udi_cdc_comm  = UDI_CDC_COMM_DESC_0, \
+    .udi_cdc_data  = UDI_CDC_DATA_DESC_0_HS, \
+    .udi_msc       = UDI_MSC_DESC_HS
+
+  //! USB Interface APIs
+  #define UDI_COMPOSITE_API \
+    &udi_api_cdc_comm, \
+    &udi_api_cdc_data, \
+    &udi_api_msc
+  //@}
+
+  /**
+   * USB Device Driver Configuration
+   * @{
+   */
+  //@}
+
+  //! The includes of classes and other headers must be done at the end of this file to avoid compile error
+  #include "udi_cdc.h"
+  #include "udi_msc.h"
 #else
-#  define  UDI_CDC_COMM_EP_0             (3 | USB_EP_DIR_IN) // Notify endpoint
-#  define  UDI_CDC_DATA_EP_IN_0          (4 | USB_EP_DIR_IN) // TX
-#  define  UDI_CDC_DATA_EP_OUT_0         (5 | USB_EP_DIR_OUT)// RX
+  #include "udi_cdc_conf.h"
 #endif
 
-//! Interface numbers
-#define  UDI_CDC_COMM_IFACE_NUMBER_0   0
-#define  UDI_CDC_DATA_IFACE_NUMBER_0   1
-//@}
-//@}
-
-
-/**
- * Configuration of MSC interface
- * @{
- */
-//! Vendor name and Product version of MSC interface
-#define UDI_MSC_GLOBAL_VENDOR_ID            \
-   'M', 'A', 'R', 'L', 'I', 'N', '3', 'D'
-#define UDI_MSC_GLOBAL_PRODUCT_VERSION            \
-   '1', '.', '0', '0'
-
-//! Interface callback definition
-#define  UDI_MSC_ENABLE_EXT()          usb_task_msc_enable()
-#define  UDI_MSC_DISABLE_EXT()         usb_task_msc_disable()
-
-//! Enable id string of interface to add an extra USB string
-#define  UDI_MSC_STRING_ID                5
-
-/**
- * USB MSC low level configuration
- * In standalone these configurations are defined by the MSC module.
- * For composite device, these configuration must be defined here
- * @{
- */
-//! Endpoint numbers definition
-#define  UDI_MSC_EP_IN                 (1 | USB_EP_DIR_IN)
-#define  UDI_MSC_EP_OUT                (2 | USB_EP_DIR_OUT)
-
-//! Interface number
-#define  UDI_MSC_IFACE_NUMBER          2
-//@}
-//@}
-
-//@}
-
-
-/**
- * Description of Composite Device
- * @{
- */
-//! USB Interfaces descriptor structure
-#define UDI_COMPOSITE_DESC_T \
-  usb_iad_desc_t       udi_cdc_iad; \
-  udi_cdc_comm_desc_t  udi_cdc_comm; \
-  udi_cdc_data_desc_t  udi_cdc_data; \
-  udi_msc_desc_t       udi_msc
-
-//! USB Interfaces descriptor value for Full Speed
-#define UDI_COMPOSITE_DESC_FS \
-  .udi_cdc_iad   = UDI_CDC_IAD_DESC_0, \
-  .udi_cdc_comm  = UDI_CDC_COMM_DESC_0, \
-  .udi_cdc_data  = UDI_CDC_DATA_DESC_0_FS, \
-  .udi_msc       = UDI_MSC_DESC_FS
-
-//! USB Interfaces descriptor value for High Speed
-#define UDI_COMPOSITE_DESC_HS \
-  .udi_cdc_iad   = UDI_CDC_IAD_DESC_0, \
-  .udi_cdc_comm  = UDI_CDC_COMM_DESC_0, \
-  .udi_cdc_data  = UDI_CDC_DATA_DESC_0_HS, \
-  .udi_msc       = UDI_MSC_DESC_HS
-
-//! USB Interface APIs
-#define UDI_COMPOSITE_API \
-  &udi_api_cdc_comm, \
-  &udi_api_cdc_data, \
-  &udi_api_msc
-//@}
-
-
-/**
- * USB Device Driver Configuration
- * @{
- */
-//@}
-
-//! The includes of classes and other headers must be done at the end of this file to avoid compile error
-#include "udi_cdc.h"
-#include "udi_msc.h"
 #include "usb_task.h"
 
 #endif // _CONF_USB_H_
diff --git a/Marlin/src/HAL/HAL_DUE/usb/udi_cdc_conf.h b/Marlin/src/HAL/HAL_DUE/usb/udi_cdc_conf.h
new file mode 100644
index 00000000000..b99d6111713
--- /dev/null
+++ b/Marlin/src/HAL/HAL_DUE/usb/udi_cdc_conf.h
@@ -0,0 +1,156 @@
+/**
+ * \file
+ *
+ * \brief Default CDC configuration for a USB Device with a single interface
+ *
+ * Copyright (c) 2009-2015 Atmel Corporation. All rights reserved.
+ *
+ * \asf_license_start
+ *
+ * \page License
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an
+ *    Atmel microcontroller product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * \asf_license_stop
+ *
+ */
+/*
+ * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
+ */
+
+#ifndef _UDI_CDC_CONF_H_
+#define _UDI_CDC_CONF_H_
+
+#include "usb_protocol_cdc.h"
+#include "conf_usb.h"
+
+#ifndef  UDI_CDC_PORT_NB
+# define  UDI_CDC_PORT_NB 1
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \addtogroup udi_cdc_group_single_desc
+ * @{
+ */
+
+//! Control endpoint size (Endpoint 0)
+#define  USB_DEVICE_EP_CTRL_SIZE       64
+
+#if XMEGA
+/**
+ * \name Endpoint configuration on XMEGA
+ * The XMEGA supports a IN and OUT endpoint with the same number endpoint,
+ * thus XMEGA can support up to 7 CDC interfaces.
+ */
+//@{
+#define  UDI_CDC_DATA_EP_IN_0          ( 1 | USB_EP_DIR_IN)  // TX
+#define  UDI_CDC_DATA_EP_OUT_0         ( 2 | USB_EP_DIR_OUT) // RX
+#define  UDI_CDC_COMM_EP_0             ( 2 | USB_EP_DIR_IN)  // Notify endpoint
+#define  UDI_CDC_DATA_EP_IN_1          ( 3 | USB_EP_DIR_IN)  // TX
+#define  UDI_CDC_DATA_EP_OUT_1         ( 4 | USB_EP_DIR_OUT) // RX
+#define  UDI_CDC_COMM_EP_1             ( 4 | USB_EP_DIR_IN)  // Notify endpoint
+#define  UDI_CDC_DATA_EP_IN_2          ( 5 | USB_EP_DIR_IN)  // TX
+#define  UDI_CDC_DATA_EP_OUT_2         ( 6 | USB_EP_DIR_OUT) // RX
+#define  UDI_CDC_COMM_EP_2             ( 6 | USB_EP_DIR_IN)  // Notify endpoint
+#define  UDI_CDC_DATA_EP_IN_3          ( 7 | USB_EP_DIR_IN)  // TX
+#define  UDI_CDC_DATA_EP_OUT_3         ( 8 | USB_EP_DIR_OUT) // RX
+#define  UDI_CDC_COMM_EP_3             ( 8 | USB_EP_DIR_IN)  // Notify endpoint
+#define  UDI_CDC_DATA_EP_IN_4          ( 9 | USB_EP_DIR_IN)  // TX
+#define  UDI_CDC_DATA_EP_OUT_4         (10 | USB_EP_DIR_OUT) // RX
+#define  UDI_CDC_COMM_EP_4             (10 | USB_EP_DIR_IN)  // Notify endpoint
+#define  UDI_CDC_DATA_EP_IN_5          (11 | USB_EP_DIR_IN)  // TX
+#define  UDI_CDC_DATA_EP_OUT_5         (12 | USB_EP_DIR_OUT) // RX
+#define  UDI_CDC_COMM_EP_5             (12 | USB_EP_DIR_IN)  // Notify endpoint
+#define  UDI_CDC_DATA_EP_IN_6          (13 | USB_EP_DIR_IN)  // TX
+#define  UDI_CDC_DATA_EP_OUT_6         (14 | USB_EP_DIR_OUT) // RX
+#define  UDI_CDC_COMM_EP_6             (14 | USB_EP_DIR_IN)  // Notify endpoint
+//! 2 endpoints numbers used per CDC interface
+#define  USB_DEVICE_MAX_EP             (2*UDI_CDC_PORT_NB)
+//@}
+
+#else
+
+/**
+ * \name Default endpoint configuration
+ * The USBB, UDP, UDPHS and UOTGHS interfaces can support up to 2 CDC interfaces.
+ */
+//@{
+#  if UDI_CDC_PORT_NB > 2
+#    error USBB, UDP, UDPHS and UOTGHS interfaces have not enought endpoints.
+#  endif
+#define  UDI_CDC_DATA_EP_IN_0          (1 | USB_EP_DIR_IN)  // TX
+#define  UDI_CDC_DATA_EP_OUT_0         (2 | USB_EP_DIR_OUT) // RX
+#define  UDI_CDC_COMM_EP_0             (3 | USB_EP_DIR_IN)  // Notify endpoint
+#  if SAM3U
+     /* For 3U max endpoint size of 4 is 64, use 5 and 6 as bulk tx and rx */
+#    define  UDI_CDC_DATA_EP_IN_1          (6 | USB_EP_DIR_IN)  // TX
+#    define  UDI_CDC_DATA_EP_OUT_1         (5 | USB_EP_DIR_OUT) // RX
+#    define  UDI_CDC_COMM_EP_1             (4 | USB_EP_DIR_IN)  // Notify
+#  else
+#    define  UDI_CDC_DATA_EP_IN_1          (4 | USB_EP_DIR_IN)  // TX
+#    define  UDI_CDC_DATA_EP_OUT_1         (5 | USB_EP_DIR_OUT) // RX
+#    define  UDI_CDC_COMM_EP_1             (6 | USB_EP_DIR_IN)  // Notify
+#  endif
+//! 3 endpoints used per CDC interface
+#undef USB_DEVICE_MAX_EP   // undefine this definition in header file
+#define  USB_DEVICE_MAX_EP             (3*UDI_CDC_PORT_NB)
+//@}
+
+#endif
+
+/**
+ * \name Default Interface numbers
+ */
+//@{
+#define  UDI_CDC_COMM_IFACE_NUMBER_0   0
+#define  UDI_CDC_DATA_IFACE_NUMBER_0   1
+#define  UDI_CDC_COMM_IFACE_NUMBER_1   2
+#define  UDI_CDC_DATA_IFACE_NUMBER_1   3
+#define  UDI_CDC_COMM_IFACE_NUMBER_2   4
+#define  UDI_CDC_DATA_IFACE_NUMBER_2   5
+#define  UDI_CDC_COMM_IFACE_NUMBER_3   6
+#define  UDI_CDC_DATA_IFACE_NUMBER_3   7
+#define  UDI_CDC_COMM_IFACE_NUMBER_4   8
+#define  UDI_CDC_DATA_IFACE_NUMBER_4   9
+#define  UDI_CDC_COMM_IFACE_NUMBER_5   10
+#define  UDI_CDC_DATA_IFACE_NUMBER_5   11
+#define  UDI_CDC_COMM_IFACE_NUMBER_6   12
+#define  UDI_CDC_DATA_IFACE_NUMBER_6   13
+//@}
+
+//@}
+
+#ifdef __cplusplus
+}
+#endif
+#endif // _UDI_CDC_CONF_H_
diff --git a/Marlin/src/HAL/HAL_DUE/usb/udi_cdc_desc.c b/Marlin/src/HAL/HAL_DUE/usb/udi_cdc_desc.c
new file mode 100644
index 00000000000..98e8ba194d2
--- /dev/null
+++ b/Marlin/src/HAL/HAL_DUE/usb/udi_cdc_desc.c
@@ -0,0 +1,259 @@
+/**
+ * \file
+ *
+ * \brief Default descriptors for a USB Device with a single interface CDC
+ *
+ * Copyright (c) 2009-2016 Atmel Corporation. All rights reserved.
+ *
+ * \asf_license_start
+ *
+ * \page License
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an
+ *    Atmel microcontroller product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * \asf_license_stop
+ *
+ */
+/*
+ * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
+ */
+
+#ifdef ARDUINO_ARCH_SAM
+
+#include "conf_usb.h"
+#include "udd.h"
+#include "udc_desc.h"
+#include "udi_cdc.h"
+
+#if DISABLED(SDSUPPORT)
+
+/**
+ * \defgroup udi_cdc_group_single_desc USB device descriptors for a single interface
+ *
+ * The following structures provide the USB device descriptors required for
+ * USB Device with a single interface CDC.
+ *
+ * It is ready to use and do not require more definition.
+ *
+ * @{
+ */
+
+//! Two interfaces for a CDC device
+#define  USB_DEVICE_NB_INTERFACE       (2*UDI_CDC_PORT_NB)
+
+#ifdef USB_DEVICE_LPM_SUPPORT
+# define USB_VERSION   USB_V2_1
+#else
+# define USB_VERSION   USB_V2_0
+#endif
+
+//! USB Device Descriptor
+COMPILER_WORD_ALIGNED
+UDC_DESC_STORAGE usb_dev_desc_t udc_device_desc = {
+  .bLength                   = sizeof(usb_dev_desc_t),
+  .bDescriptorType           = USB_DT_DEVICE,
+  .bcdUSB                    = LE16(USB_VERSION),
+#if UDI_CDC_PORT_NB > 1
+  .bDeviceClass              = 0,
+#else
+  .bDeviceClass              = CDC_CLASS_DEVICE,
+#endif
+  .bDeviceSubClass           = 0,
+  .bDeviceProtocol           = 0,
+  .bMaxPacketSize0           = USB_DEVICE_EP_CTRL_SIZE,
+  .idVendor                  = LE16(USB_DEVICE_VENDOR_ID),
+  .idProduct                 = LE16(USB_DEVICE_PRODUCT_ID),
+  .bcdDevice                 = LE16((USB_DEVICE_MAJOR_VERSION << 8)
+      | USB_DEVICE_MINOR_VERSION),
+#ifdef USB_DEVICE_MANUFACTURE_NAME
+  .iManufacturer = 1,
+#else
+  .iManufacturer             = 0,  // No manufacture string
+#endif
+#ifdef USB_DEVICE_PRODUCT_NAME
+  .iProduct = 2,
+#else
+  .iProduct                  = 0,  // No product string
+#endif
+#if (defined USB_DEVICE_SERIAL_NAME || defined USB_DEVICE_GET_SERIAL_NAME_POINTER)
+  .iSerialNumber = 3,
+#else
+  .iSerialNumber             = 0,  // No serial string
+#endif
+  .bNumConfigurations = 1
+};
+
+
+#ifdef USB_DEVICE_HS_SUPPORT
+//! USB Device Qualifier Descriptor for HS
+COMPILER_WORD_ALIGNED
+UDC_DESC_STORAGE usb_dev_qual_desc_t udc_device_qual = {
+  .bLength                   = sizeof(usb_dev_qual_desc_t),
+  .bDescriptorType           = USB_DT_DEVICE_QUALIFIER,
+  .bcdUSB                    = LE16(USB_VERSION),
+#if UDI_CDC_PORT_NB > 1
+  .bDeviceClass              = 0,
+#else
+  .bDeviceClass              = CDC_CLASS_DEVICE,
+#endif
+  .bDeviceSubClass           = 0,
+  .bDeviceProtocol           = 0,
+  .bMaxPacketSize0           = USB_DEVICE_EP_CTRL_SIZE,
+  .bNumConfigurations        = 1
+};
+#endif
+
+#ifdef USB_DEVICE_LPM_SUPPORT
+//! USB Device Qualifier Descriptor
+COMPILER_WORD_ALIGNED
+UDC_DESC_STORAGE usb_dev_lpm_desc_t udc_device_lpm = {
+  .bos.bLength               = sizeof(usb_dev_bos_desc_t),
+  .bos.bDescriptorType       = USB_DT_BOS,
+  .bos.wTotalLength          = LE16(sizeof(usb_dev_bos_desc_t) + sizeof(usb_dev_capa_ext_desc_t)),
+  .bos.bNumDeviceCaps        = 1,
+  .capa_ext.bLength          = sizeof(usb_dev_capa_ext_desc_t),
+  .capa_ext.bDescriptorType  = USB_DT_DEVICE_CAPABILITY,
+  .capa_ext.bDevCapabilityType = USB_DC_USB20_EXTENSION,
+  .capa_ext.bmAttributes     = USB_DC_EXT_LPM,
+};
+#endif
+
+//! Structure for USB Device Configuration Descriptor
+COMPILER_PACK_SET(1)
+typedef struct {
+  usb_conf_desc_t conf;
+#if UDI_CDC_PORT_NB == 1
+  udi_cdc_comm_desc_t udi_cdc_comm_0;
+  udi_cdc_data_desc_t udi_cdc_data_0;
+#else
+#  define UDI_CDC_DESC_STRUCTURE(index, unused) \
+  usb_iad_desc_t      udi_cdc_iad_##index; \
+  udi_cdc_comm_desc_t udi_cdc_comm_##index; \
+  udi_cdc_data_desc_t udi_cdc_data_##index;
+  MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DESC_STRUCTURE, ~)
+#  undef UDI_CDC_DESC_STRUCTURE
+#endif
+} udc_desc_t;
+COMPILER_PACK_RESET()
+
+//! USB Device Configuration Descriptor filled for full and high speed
+COMPILER_WORD_ALIGNED
+UDC_DESC_STORAGE udc_desc_t udc_desc_fs = {
+  .conf.bLength              = sizeof(usb_conf_desc_t),
+  .conf.bDescriptorType      = USB_DT_CONFIGURATION,
+  .conf.wTotalLength         = LE16(sizeof(udc_desc_t)),
+  .conf.bNumInterfaces       = USB_DEVICE_NB_INTERFACE,
+  .conf.bConfigurationValue  = 1,
+  .conf.iConfiguration       = 0,
+  .conf.bmAttributes         = USB_CONFIG_ATTR_MUST_SET | USB_DEVICE_ATTR,
+  .conf.bMaxPower            = USB_CONFIG_MAX_POWER(USB_DEVICE_POWER),
+#if UDI_CDC_PORT_NB == 1
+  .udi_cdc_comm_0            = UDI_CDC_COMM_DESC_0,
+  .udi_cdc_data_0            = UDI_CDC_DATA_DESC_0_FS,
+#else
+#  define UDI_CDC_DESC_FS(index, unused) \
+  .udi_cdc_iad_##index             = UDI_CDC_IAD_DESC_##index,\
+  .udi_cdc_comm_##index            = UDI_CDC_COMM_DESC_##index,\
+  .udi_cdc_data_##index            = UDI_CDC_DATA_DESC_##index##_FS,
+  MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DESC_FS, ~)
+#  undef UDI_CDC_DESC_FS
+#endif
+};
+
+#ifdef USB_DEVICE_HS_SUPPORT
+COMPILER_WORD_ALIGNED
+UDC_DESC_STORAGE udc_desc_t udc_desc_hs = {
+  .conf.bLength              = sizeof(usb_conf_desc_t),
+  .conf.bDescriptorType      = USB_DT_CONFIGURATION,
+  .conf.wTotalLength         = LE16(sizeof(udc_desc_t)),
+  .conf.bNumInterfaces       = USB_DEVICE_NB_INTERFACE,
+  .conf.bConfigurationValue  = 1,
+  .conf.iConfiguration       = 0,
+  .conf.bmAttributes         = USB_CONFIG_ATTR_MUST_SET | USB_DEVICE_ATTR,
+  .conf.bMaxPower            = USB_CONFIG_MAX_POWER(USB_DEVICE_POWER),
+#if UDI_CDC_PORT_NB == 1
+  .udi_cdc_comm_0            = UDI_CDC_COMM_DESC_0,
+  .udi_cdc_data_0            = UDI_CDC_DATA_DESC_0_HS,
+#else
+#  define UDI_CDC_DESC_HS(index, unused) \
+  .udi_cdc_iad_##index             = UDI_CDC_IAD_DESC_##index, \
+  .udi_cdc_comm_##index            = UDI_CDC_COMM_DESC_##index, \
+  .udi_cdc_data_##index            = UDI_CDC_DATA_DESC_##index##_HS,
+  MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DESC_HS, ~)
+#  undef UDI_CDC_DESC_HS
+#endif
+};
+#endif
+
+/**
+ * \name UDC structures which content all USB Device definitions
+ */
+//@{
+
+//! Associate an UDI for each USB interface
+UDC_DESC_STORAGE udi_api_t *udi_apis[USB_DEVICE_NB_INTERFACE] = {
+#  define UDI_CDC_API(index, unused) \
+  &udi_api_cdc_comm, \
+  &udi_api_cdc_data,
+  MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_API, ~)
+#  undef UDI_CDC_API
+};
+
+//! Add UDI with USB Descriptors FS & HS
+UDC_DESC_STORAGE udc_config_speed_t udc_config_fs[1] = { {
+  .desc          = (usb_conf_desc_t UDC_DESC_STORAGE*)&udc_desc_fs,
+  .udi_apis = udi_apis,
+}};
+#ifdef USB_DEVICE_HS_SUPPORT
+UDC_DESC_STORAGE udc_config_speed_t udc_config_hs[1] = { {
+  .desc          = (usb_conf_desc_t UDC_DESC_STORAGE*)&udc_desc_hs,
+  .udi_apis = udi_apis,
+}};
+#endif
+
+//! Add all information about USB Device in global structure for UDC
+UDC_DESC_STORAGE udc_config_t udc_config = {
+  .confdev_lsfs = &udc_device_desc,
+  .conf_lsfs = udc_config_fs,
+#ifdef USB_DEVICE_HS_SUPPORT
+  .confdev_hs = &udc_device_desc,
+  .qualifier = &udc_device_qual,
+  .conf_hs = udc_config_hs,
+#endif
+#ifdef USB_DEVICE_LPM_SUPPORT
+  .conf_bos = &udc_device_lpm.bos,
+#else
+  .conf_bos = NULL,
+#endif
+};
+
+//@}
+//@}
+#endif
+#endif
diff --git a/Marlin/src/HAL/HAL_DUE/usb/udi_composite_desc.c b/Marlin/src/HAL/HAL_DUE/usb/udi_composite_desc.c
index 6ba06afbf97..d4b155e0148 100644
--- a/Marlin/src/HAL/HAL_DUE/usb/udi_composite_desc.c
+++ b/Marlin/src/HAL/HAL_DUE/usb/udi_composite_desc.c
@@ -50,6 +50,8 @@
 #include "udd.h"
 #include "udc_desc.h"
 
+#if ENABLED(SDSUPPORT)
+
 /**
  * \defgroup udi_group_desc Descriptors for a USB Device
  * composite
@@ -62,33 +64,33 @@
 //! USB Device Descriptor
 COMPILER_WORD_ALIGNED
 UDC_DESC_STORAGE usb_dev_desc_t udc_device_desc = {
-	.bLength                   = sizeof(usb_dev_desc_t),
-	.bDescriptorType           = USB_DT_DEVICE,
-	.bcdUSB                    = LE16(USB_V2_0),
-	.bDeviceClass              = 0,
-	.bDeviceSubClass           = 0,
-	.bDeviceProtocol           = 0,
-	.bMaxPacketSize0           = USB_DEVICE_EP_CTRL_SIZE,
-	.idVendor                  = LE16(USB_DEVICE_VENDOR_ID),
-	.idProduct                 = LE16(USB_DEVICE_PRODUCT_ID),
-	.bcdDevice                 = LE16((USB_DEVICE_MAJOR_VERSION << 8)
-		| USB_DEVICE_MINOR_VERSION),
+  .bLength                   = sizeof(usb_dev_desc_t),
+  .bDescriptorType           = USB_DT_DEVICE,
+  .bcdUSB                    = LE16(USB_V2_0),
+  .bDeviceClass              = 0,
+  .bDeviceSubClass           = 0,
+  .bDeviceProtocol           = 0,
+  .bMaxPacketSize0           = USB_DEVICE_EP_CTRL_SIZE,
+  .idVendor                  = LE16(USB_DEVICE_VENDOR_ID),
+  .idProduct                 = LE16(USB_DEVICE_PRODUCT_ID),
+  .bcdDevice                 = LE16((USB_DEVICE_MAJOR_VERSION << 8)
+    | USB_DEVICE_MINOR_VERSION),
 #ifdef USB_DEVICE_MANUFACTURE_NAME
-	.iManufacturer             = 1,
+  .iManufacturer             = 1,
 #else
-	.iManufacturer             = 0,  // No manufacture string
+  .iManufacturer             = 0,  // No manufacture string
 #endif
 #ifdef USB_DEVICE_PRODUCT_NAME
-	.iProduct                  = 2,
+  .iProduct                  = 2,
 #else
-	.iProduct                  = 0,  // No product string
+  .iProduct                  = 0,  // No product string
 #endif
 #if (defined USB_DEVICE_SERIAL_NAME || defined USB_DEVICE_GET_SERIAL_NAME_POINTER)
-	.iSerialNumber             = 3,
+  .iSerialNumber             = 3,
 #else
-	.iSerialNumber             = 0,  // No serial string
+  .iSerialNumber             = 0,  // No serial string
 #endif
-	.bNumConfigurations        = 1
+  .bNumConfigurations        = 1
 };
 
 
@@ -96,52 +98,52 @@ UDC_DESC_STORAGE usb_dev_desc_t udc_device_desc = {
 //! USB Device Qualifier Descriptor for HS
 COMPILER_WORD_ALIGNED
 UDC_DESC_STORAGE usb_dev_qual_desc_t udc_device_qual = {
-	.bLength                   = sizeof(usb_dev_qual_desc_t),
-	.bDescriptorType           = USB_DT_DEVICE_QUALIFIER,
-	.bcdUSB                    = LE16(USB_V2_0),
-	.bDeviceClass              = 0,
-	.bDeviceSubClass           = 0,
-	.bDeviceProtocol           = 0,
-	.bMaxPacketSize0           = USB_DEVICE_EP_CTRL_SIZE,
-	.bNumConfigurations        = 1
+  .bLength                   = sizeof(usb_dev_qual_desc_t),
+  .bDescriptorType           = USB_DT_DEVICE_QUALIFIER,
+  .bcdUSB                    = LE16(USB_V2_0),
+  .bDeviceClass              = 0,
+  .bDeviceSubClass           = 0,
+  .bDeviceProtocol           = 0,
+  .bMaxPacketSize0           = USB_DEVICE_EP_CTRL_SIZE,
+  .bNumConfigurations        = 1
 };
 #endif
 
 //! Structure for USB Device Configuration Descriptor
 COMPILER_PACK_SET(1)
 typedef struct {
-	usb_conf_desc_t conf;
-	UDI_COMPOSITE_DESC_T;
+  usb_conf_desc_t conf;
+  UDI_COMPOSITE_DESC_T;
 } udc_desc_t;
 COMPILER_PACK_RESET()
 
 //! USB Device Configuration Descriptor filled for FS
 COMPILER_WORD_ALIGNED
 UDC_DESC_STORAGE udc_desc_t udc_desc_fs = {
-	.conf.bLength              = sizeof(usb_conf_desc_t),
-	.conf.bDescriptorType      = USB_DT_CONFIGURATION,
-	.conf.wTotalLength         = LE16(sizeof(udc_desc_t)),
-	.conf.bNumInterfaces       = USB_DEVICE_NB_INTERFACE,
-	.conf.bConfigurationValue  = 1,
-	.conf.iConfiguration       = 0,
-	.conf.bmAttributes         = USB_CONFIG_ATTR_MUST_SET | USB_DEVICE_ATTR,
-	.conf.bMaxPower            = USB_CONFIG_MAX_POWER(USB_DEVICE_POWER),
-	UDI_COMPOSITE_DESC_FS
+  .conf.bLength              = sizeof(usb_conf_desc_t),
+  .conf.bDescriptorType      = USB_DT_CONFIGURATION,
+  .conf.wTotalLength         = LE16(sizeof(udc_desc_t)),
+  .conf.bNumInterfaces       = USB_DEVICE_NB_INTERFACE,
+  .conf.bConfigurationValue  = 1,
+  .conf.iConfiguration       = 0,
+  .conf.bmAttributes         = USB_CONFIG_ATTR_MUST_SET | USB_DEVICE_ATTR,
+  .conf.bMaxPower            = USB_CONFIG_MAX_POWER(USB_DEVICE_POWER),
+  UDI_COMPOSITE_DESC_FS
 };
 
 #ifdef USB_DEVICE_HS_SUPPORT
 //! USB Device Configuration Descriptor filled for HS
 COMPILER_WORD_ALIGNED
 UDC_DESC_STORAGE udc_desc_t udc_desc_hs = {
-	.conf.bLength              = sizeof(usb_conf_desc_t),
-	.conf.bDescriptorType      = USB_DT_CONFIGURATION,
-	.conf.wTotalLength         = LE16(sizeof(udc_desc_t)),
-	.conf.bNumInterfaces       = USB_DEVICE_NB_INTERFACE,
-	.conf.bConfigurationValue  = 1,
-	.conf.iConfiguration       = 0,
-	.conf.bmAttributes         = USB_CONFIG_ATTR_MUST_SET | USB_DEVICE_ATTR,
-	.conf.bMaxPower            = USB_CONFIG_MAX_POWER(USB_DEVICE_POWER),
-	UDI_COMPOSITE_DESC_HS
+  .conf.bLength              = sizeof(usb_conf_desc_t),
+  .conf.bDescriptorType      = USB_DT_CONFIGURATION,
+  .conf.wTotalLength         = LE16(sizeof(udc_desc_t)),
+  .conf.bNumInterfaces       = USB_DEVICE_NB_INTERFACE,
+  .conf.bConfigurationValue  = 1,
+  .conf.iConfiguration       = 0,
+  .conf.bmAttributes         = USB_CONFIG_ATTR_MUST_SET | USB_DEVICE_ATTR,
+  .conf.bMaxPower            = USB_CONFIG_MAX_POWER(USB_DEVICE_POWER),
+  UDI_COMPOSITE_DESC_HS
 };
 #endif
 
@@ -153,31 +155,31 @@ UDC_DESC_STORAGE udc_desc_t udc_desc_hs = {
 
 //! Associate an UDI for each USB interface
 UDC_DESC_STORAGE udi_api_t *udi_apis[USB_DEVICE_NB_INTERFACE] = {
-	UDI_COMPOSITE_API
+  UDI_COMPOSITE_API
 };
 
 //! Add UDI with USB Descriptors FS
 UDC_DESC_STORAGE udc_config_speed_t   udc_config_lsfs[1] = {{
-	.desc          = (usb_conf_desc_t UDC_DESC_STORAGE*)&udc_desc_fs,
-	.udi_apis      = udi_apis,
+  .desc          = (usb_conf_desc_t UDC_DESC_STORAGE*)&udc_desc_fs,
+  .udi_apis      = udi_apis,
 }};
 
 #ifdef USB_DEVICE_HS_SUPPORT
 //! Add UDI with USB Descriptors HS
 UDC_DESC_STORAGE udc_config_speed_t   udc_config_hs[1] = {{
-	.desc          = (usb_conf_desc_t UDC_DESC_STORAGE*)&udc_desc_hs,
-	.udi_apis      = udi_apis,
+  .desc          = (usb_conf_desc_t UDC_DESC_STORAGE*)&udc_desc_hs,
+  .udi_apis      = udi_apis,
 }};
 #endif
 
 //! Add all information about USB Device in global structure for UDC
 UDC_DESC_STORAGE udc_config_t udc_config = {
-	.confdev_lsfs = &udc_device_desc,
-	.conf_lsfs = udc_config_lsfs,
+  .confdev_lsfs = &udc_device_desc,
+  .conf_lsfs = udc_config_lsfs,
 #ifdef USB_DEVICE_HS_SUPPORT
-	.confdev_hs = &udc_device_desc,
-	.qualifier = &udc_device_qual,
-	.conf_hs = udc_config_hs,
+  .confdev_hs = &udc_device_desc,
+  .qualifier = &udc_device_qual,
+  .conf_hs = udc_config_hs,
 #endif
 };
 
@@ -185,4 +187,5 @@ UDC_DESC_STORAGE udc_config_t udc_config = {
 /**INDENT-ON**/
 //@}
 
+#endif
 #endif
\ No newline at end of file
diff --git a/Marlin/src/HAL/HAL_DUE/usb/udi_msc.c b/Marlin/src/HAL/HAL_DUE/usb/udi_msc.c
index 2dd9ad53532..83d44475612 100644
--- a/Marlin/src/HAL/HAL_DUE/usb/udi_msc.c
+++ b/Marlin/src/HAL/HAL_DUE/usb/udi_msc.c
@@ -57,6 +57,8 @@
 #include "ctrl_access.h"
 #include <string.h>
 
+#if ENABLED(SDSUPPORT)
+
 #ifndef UDI_MSC_NOTIFY_TRANS_EXT
 #  define UDI_MSC_NOTIFY_TRANS_EXT()
 #endif
@@ -76,11 +78,11 @@ uint8_t udi_msc_getsetting(void);
 
 //! Global structure which contains standard UDI API for UDC
 UDC_DESC_STORAGE udi_api_t udi_api_msc = {
-	.enable = udi_msc_enable,
-	.disable = udi_msc_disable,
-	.setup = udi_msc_setup,
-	.getsetting = udi_msc_getsetting,
-	.sof_notify = NULL,
+  .enable = udi_msc_enable,
+  .disable = udi_msc_disable,
+  .setup = udi_msc_setup,
+  .getsetting = udi_msc_getsetting,
+  .sof_notify = NULL,
 };
 //@}
 
@@ -105,7 +107,7 @@ UDC_DESC_STORAGE udi_api_t udi_api_msc = {
 UDC_BSS(4) static struct usb_msc_cbw udi_msc_cbw;
 //! Structure to send a CSW packet
 UDC_DATA(4) static struct usb_msc_csw udi_msc_csw =
-		{.dCSWSignature = CPU_TO_BE32(USB_CSW_SIGNATURE) };
+    {.dCSWSignature = CPU_TO_BE32(USB_CSW_SIGNATURE) };
 //! Number of lun
 UDC_DATA(4) static uint8_t udi_msc_nb_lun = 0;
 //! Structure with current SCSI sense data
@@ -174,7 +176,7 @@ static void udi_msc_cbw_wait(void);
  * \param nb_received  number of data transfered
  */
 static void udi_msc_cbw_received(udd_ep_status_t status,
-		iram_size_t nb_received, udd_ep_id_t ep);
+    iram_size_t nb_received, udd_ep_id_t ep);
 
 /**
  * \brief Function to check the CBW length and direction
@@ -212,7 +214,7 @@ static void udi_msc_data_send(uint8_t * buffer, uint8_t buf_size);
  * \param nb_sent    number of data transfered
  */
 static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,
-		udd_ep_id_t ep);
+    udd_ep_id_t ep);
 //@}
 
 
@@ -245,7 +247,7 @@ void udi_msc_csw_send(void);
  * \param nb_sent    number of data transfered
  */
 static void udi_msc_csw_sent(udd_ep_status_t status, iram_size_t nb_sent,
-		udd_ep_id_t ep);
+    udd_ep_id_t ep);
 //@}
 
 
@@ -267,7 +269,7 @@ static void udi_msc_clear_sense(void);
  * \param lba           LBA corresponding at error
  */
 static void udi_msc_sense_fail(uint8_t sense_key, uint16_t add_sense,
-		uint32_t lba);
+    uint32_t lba);
 
 /**
  * \brief Update sense data with new value to signal success
@@ -373,85 +375,85 @@ static void udi_msc_sbc_trans(bool b_read);
 
 bool udi_msc_enable(void)
 {
-	uint8_t lun;
-	udi_msc_b_trans_req = false;
-	udi_msc_b_cbw_invalid = false;
-	udi_msc_b_ack_trans = true;
-	udi_msc_b_reset_trans = true;
-	udi_msc_nb_lun = get_nb_lun();
-	if (0 == udi_msc_nb_lun)
-		return false; // No lun available, then not authorize to enable interface
-	udi_msc_nb_lun--;
-	// Call application callback
-	// to initialize memories or signal that interface is enabled
-	if (!UDI_MSC_ENABLE_EXT())
-		return false;
-	// Load the medium on each LUN
-	for (lun = 0; lun <= udi_msc_nb_lun; lun ++) {
-		mem_unload(lun, false);
-	}
-	// Start MSC process by CBW reception
-	udi_msc_cbw_wait();
-	return true;
+  uint8_t lun;
+  udi_msc_b_trans_req = false;
+  udi_msc_b_cbw_invalid = false;
+  udi_msc_b_ack_trans = true;
+  udi_msc_b_reset_trans = true;
+  udi_msc_nb_lun = get_nb_lun();
+  if (0 == udi_msc_nb_lun)
+    return false; // No lun available, then not authorize to enable interface
+  udi_msc_nb_lun--;
+  // Call application callback
+  // to initialize memories or signal that interface is enabled
+  if (!UDI_MSC_ENABLE_EXT())
+    return false;
+  // Load the medium on each LUN
+  for (lun = 0; lun <= udi_msc_nb_lun; lun ++) {
+    mem_unload(lun, false);
+  }
+  // Start MSC process by CBW reception
+  udi_msc_cbw_wait();
+  return true;
 }
 
 
 void udi_msc_disable(void)
 {
-	udi_msc_b_trans_req = false;
-	udi_msc_b_ack_trans = true;
-	udi_msc_b_reset_trans = true;
-	UDI_MSC_DISABLE_EXT();
+  udi_msc_b_trans_req = false;
+  udi_msc_b_ack_trans = true;
+  udi_msc_b_reset_trans = true;
+  UDI_MSC_DISABLE_EXT();
 }
 
 
 bool udi_msc_setup(void)
 {
-	if (Udd_setup_is_in()) {
-		// Requests Interface GET
-		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
-			// Requests Class Interface Get
-			switch (udd_g_ctrlreq.req.bRequest) {
-			case USB_REQ_MSC_GET_MAX_LUN:
-				// Give the number of memories available
-				if (1 != udd_g_ctrlreq.req.wLength)
-					return false;	// Error for USB host
-				if (0 != udd_g_ctrlreq.req.wValue)
-					return false;
-				udd_g_ctrlreq.payload = &udi_msc_nb_lun;
-				udd_g_ctrlreq.payload_size = 1;
-				return true;
-			}
-		}
-	}
-	if (Udd_setup_is_out()) {
-		// Requests Interface SET
-		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
-			// Requests Class Interface Set
-			switch (udd_g_ctrlreq.req.bRequest) {
-			case USB_REQ_MSC_BULK_RESET:
-				// Reset MSC interface
-				if (0 != udd_g_ctrlreq.req.wLength)
-					return false;
-				if (0 != udd_g_ctrlreq.req.wValue)
-					return false;
-				udi_msc_b_cbw_invalid = false;
-				udi_msc_b_trans_req = false;
-				// Abort all tasks (transfer or clear stall wait) on endpoints
-				udd_ep_abort(UDI_MSC_EP_OUT);
-				udd_ep_abort(UDI_MSC_EP_IN);
-				// Restart by CBW wait
-				udi_msc_cbw_wait();
-				return true;
-			}
-		}
-	}
-	return false;	// Not supported request
+  if (Udd_setup_is_in()) {
+    // Requests Interface GET
+    if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
+      // Requests Class Interface Get
+      switch (udd_g_ctrlreq.req.bRequest) {
+      case USB_REQ_MSC_GET_MAX_LUN:
+        // Give the number of memories available
+        if (1 != udd_g_ctrlreq.req.wLength)
+          return false; // Error for USB host
+        if (0 != udd_g_ctrlreq.req.wValue)
+          return false;
+        udd_g_ctrlreq.payload = &udi_msc_nb_lun;
+        udd_g_ctrlreq.payload_size = 1;
+        return true;
+      }
+    }
+  }
+  if (Udd_setup_is_out()) {
+    // Requests Interface SET
+    if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
+      // Requests Class Interface Set
+      switch (udd_g_ctrlreq.req.bRequest) {
+      case USB_REQ_MSC_BULK_RESET:
+        // Reset MSC interface
+        if (0 != udd_g_ctrlreq.req.wLength)
+          return false;
+        if (0 != udd_g_ctrlreq.req.wValue)
+          return false;
+        udi_msc_b_cbw_invalid = false;
+        udi_msc_b_trans_req = false;
+        // Abort all tasks (transfer or clear stall wait) on endpoints
+        udd_ep_abort(UDI_MSC_EP_OUT);
+        udd_ep_abort(UDI_MSC_EP_IN);
+        // Restart by CBW wait
+        udi_msc_cbw_wait();
+        return true;
+      }
+    }
+  }
+  return false; // Not supported request
 }
 
 uint8_t udi_msc_getsetting(void)
 {
-	return 0;	// MSC don't have multiple alternate setting
+  return 0; // MSC don't have multiple alternate setting
 }
 
 
@@ -460,154 +462,154 @@ uint8_t udi_msc_getsetting(void)
 
 static void udi_msc_cbw_invalid(void)
 {
-	if (!udi_msc_b_cbw_invalid)
-		return;	// Don't re-stall endpoint if error reseted by setup
-	udd_ep_set_halt(UDI_MSC_EP_OUT);
-	// If stall cleared then re-stall it. Only Setup MSC Reset can clear it
-	udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_invalid);
+  if (!udi_msc_b_cbw_invalid)
+    return; // Don't re-stall endpoint if error reseted by setup
+  udd_ep_set_halt(UDI_MSC_EP_OUT);
+  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it
+  udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_invalid);
 }
 
 static void udi_msc_csw_invalid(void)
 {
-	if (!udi_msc_b_cbw_invalid)
-		return;	// Don't re-stall endpoint if error reseted by setup
-	udd_ep_set_halt(UDI_MSC_EP_IN);
-	// If stall cleared then re-stall it. Only Setup MSC Reset can clear it
-	udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_invalid);
+  if (!udi_msc_b_cbw_invalid)
+    return; // Don't re-stall endpoint if error reseted by setup
+  udd_ep_set_halt(UDI_MSC_EP_IN);
+  // If stall cleared then re-stall it. Only Setup MSC Reset can clear it
+  udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_invalid);
 }
 
 static void udi_msc_cbw_wait(void)
 {
-	// Register buffer and callback on OUT endpoint
-	if (!udd_ep_run(UDI_MSC_EP_OUT, true,
-					(uint8_t *) & udi_msc_cbw,
-					sizeof(udi_msc_cbw),
-					udi_msc_cbw_received)) {
-		// OUT endpoint not available (halted), then wait a clear of halt.
-		udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_wait);
-	}
+  // Register buffer and callback on OUT endpoint
+  if (!udd_ep_run(UDI_MSC_EP_OUT, true,
+          (uint8_t *) & udi_msc_cbw,
+          sizeof(udi_msc_cbw),
+          udi_msc_cbw_received)) {
+    // OUT endpoint not available (halted), then wait a clear of halt.
+    udd_ep_wait_stall_clear(UDI_MSC_EP_OUT, udi_msc_cbw_wait);
+  }
 }
 
 
 static void udi_msc_cbw_received(udd_ep_status_t status,
-		iram_size_t nb_received, udd_ep_id_t ep)
+    iram_size_t nb_received, udd_ep_id_t ep)
 {
-	UNUSED(ep);
-	// Check status of transfer
-	if (UDD_EP_TRANSFER_OK != status) {
-		// Transfer aborted
-		// Now wait MSC setup reset to relaunch CBW reception
-		return;
-	}
-	// Check CBW integrity:
-	// transfer status/CBW length/CBW signature
-	if ((sizeof(udi_msc_cbw) != nb_received)
-			|| (udi_msc_cbw.dCBWSignature !=
-					CPU_TO_BE32(USB_CBW_SIGNATURE))) {
-		// (5.2.1) Devices receiving a CBW with an invalid signature should stall
-		// further traffic on the Bulk In pipe, and either stall further traffic
-		// or accept and discard further traffic on the Bulk Out pipe, until
-		// reset recovery.
-		udi_msc_b_cbw_invalid = true;
-		udi_msc_cbw_invalid();
-		udi_msc_csw_invalid();
-		return;
-	}
-	// Check LUN asked
-	udi_msc_cbw.bCBWLUN &= USB_CBW_LUN_MASK;
-	if (udi_msc_cbw.bCBWLUN > udi_msc_nb_lun) {
-		// Bad LUN, then stop command process
-		udi_msc_sense_fail_cdb_invalid();
-		udi_msc_csw_process();
-		return;
-	}
-	// Prepare CSW residue field with the size requested
-	udi_msc_csw.dCSWDataResidue =
-			le32_to_cpu(udi_msc_cbw.dCBWDataTransferLength);
-
-	// Decode opcode
-	switch (udi_msc_cbw.CDB[0]) {
-	case SPC_REQUEST_SENSE:
-		udi_msc_spc_requestsense();
-		break;
-
-	case SPC_INQUIRY:
-		udi_msc_spc_inquiry();
-		break;
-
-	case SPC_MODE_SENSE6:
-		udi_msc_spc_mode_sense(false);
-		break;
-	case SPC_MODE_SENSE10:
-		udi_msc_spc_mode_sense(true);
-		break;
-
-	case SPC_TEST_UNIT_READY:
-		udi_msc_spc_testunitready();
-		break;
-
-	case SBC_READ_CAPACITY10:
-		udi_msc_sbc_read_capacity();
-		break;
-
-	case SBC_START_STOP_UNIT:
-		udi_msc_sbc_start_stop();
-		break;
-
-		// Accepts request to support plug/plug in case of card reader
-	case SPC_PREVENT_ALLOW_MEDIUM_REMOVAL:
-		udi_msc_spc_prevent_allow_medium_removal();
-		break;
-
-		// Accepts request to support full format from Windows
-	case SBC_VERIFY10:
-		udi_msc_sense_pass();
-		udi_msc_csw_process();
-		break;
-
-	case SBC_READ10:
-		udi_msc_sbc_trans(true);
-		break;
-
-	case SBC_WRITE10:
-		udi_msc_sbc_trans(false);
-		break;
-
-	default:
-		udi_msc_sense_command_invalid();
-		udi_msc_csw_process();
-		break;
-	}
+  UNUSED(ep);
+  // Check status of transfer
+  if (UDD_EP_TRANSFER_OK != status) {
+    // Transfer aborted
+    // Now wait MSC setup reset to relaunch CBW reception
+    return;
+  }
+  // Check CBW integrity:
+  // transfer status/CBW length/CBW signature
+  if ((sizeof(udi_msc_cbw) != nb_received)
+      || (udi_msc_cbw.dCBWSignature !=
+          CPU_TO_BE32(USB_CBW_SIGNATURE))) {
+    // (5.2.1) Devices receiving a CBW with an invalid signature should stall
+    // further traffic on the Bulk In pipe, and either stall further traffic
+    // or accept and discard further traffic on the Bulk Out pipe, until
+    // reset recovery.
+    udi_msc_b_cbw_invalid = true;
+    udi_msc_cbw_invalid();
+    udi_msc_csw_invalid();
+    return;
+  }
+  // Check LUN asked
+  udi_msc_cbw.bCBWLUN &= USB_CBW_LUN_MASK;
+  if (udi_msc_cbw.bCBWLUN > udi_msc_nb_lun) {
+    // Bad LUN, then stop command process
+    udi_msc_sense_fail_cdb_invalid();
+    udi_msc_csw_process();
+    return;
+  }
+  // Prepare CSW residue field with the size requested
+  udi_msc_csw.dCSWDataResidue =
+      le32_to_cpu(udi_msc_cbw.dCBWDataTransferLength);
+
+  // Decode opcode
+  switch (udi_msc_cbw.CDB[0]) {
+  case SPC_REQUEST_SENSE:
+    udi_msc_spc_requestsense();
+    break;
+
+  case SPC_INQUIRY:
+    udi_msc_spc_inquiry();
+    break;
+
+  case SPC_MODE_SENSE6:
+    udi_msc_spc_mode_sense(false);
+    break;
+  case SPC_MODE_SENSE10:
+    udi_msc_spc_mode_sense(true);
+    break;
+
+  case SPC_TEST_UNIT_READY:
+    udi_msc_spc_testunitready();
+    break;
+
+  case SBC_READ_CAPACITY10:
+    udi_msc_sbc_read_capacity();
+    break;
+
+  case SBC_START_STOP_UNIT:
+    udi_msc_sbc_start_stop();
+    break;
+
+    // Accepts request to support plug/plug in case of card reader
+  case SPC_PREVENT_ALLOW_MEDIUM_REMOVAL:
+    udi_msc_spc_prevent_allow_medium_removal();
+    break;
+
+    // Accepts request to support full format from Windows
+  case SBC_VERIFY10:
+    udi_msc_sense_pass();
+    udi_msc_csw_process();
+    break;
+
+  case SBC_READ10:
+    udi_msc_sbc_trans(true);
+    break;
+
+  case SBC_WRITE10:
+    udi_msc_sbc_trans(false);
+    break;
+
+  default:
+    udi_msc_sense_command_invalid();
+    udi_msc_csw_process();
+    break;
+  }
 }
 
 
 static bool udi_msc_cbw_validate(uint32_t alloc_len, uint8_t dir_flag)
 {
-	/*
-	 * The following cases should result in a phase error:
-	 *  - Case  2: Hn < Di
-	 *  - Case  3: Hn < Do
-	 *  - Case  7: Hi < Di
-	 *  - Case  8: Hi <> Do
-	 *  - Case 10: Ho <> Di
-	 *  - Case 13: Ho < Do
-	 */
-	if (((udi_msc_cbw.bmCBWFlags ^ dir_flag) & USB_CBW_DIRECTION_IN)
-			|| (udi_msc_csw.dCSWDataResidue < alloc_len)) {
-		udi_msc_sense_fail_cdb_invalid();
-		udi_msc_csw_process();
-		return false;
-	}
-
-	/*
-	 * The following cases should result in a stall and nonzero
-	 * residue:
-	 *  - Case  4: Hi > Dn
-	 *  - Case  5: Hi > Di
-	 *  - Case  9: Ho > Dn
-	 *  - Case 11: Ho > Do
-	 */
-	return true;
+  /*
+   * The following cases should result in a phase error:
+   *  - Case  2: Hn < Di
+   *  - Case  3: Hn < Do
+   *  - Case  7: Hi < Di
+   *  - Case  8: Hi <> Do
+   *  - Case 10: Ho <> Di
+   *  - Case 13: Ho < Do
+   */
+  if (((udi_msc_cbw.bmCBWFlags ^ dir_flag) & USB_CBW_DIRECTION_IN)
+      || (udi_msc_csw.dCSWDataResidue < alloc_len)) {
+    udi_msc_sense_fail_cdb_invalid();
+    udi_msc_csw_process();
+    return false;
+  }
+
+  /*
+   * The following cases should result in a stall and nonzero
+   * residue:
+   *  - Case  4: Hi > Dn
+   *  - Case  5: Hi > Di
+   *  - Case  9: Ho > Dn
+   *  - Case 11: Ho > Do
+   */
+  return true;
 }
 
 
@@ -616,30 +618,30 @@ static bool udi_msc_cbw_validate(uint32_t alloc_len, uint8_t dir_flag)
 
 static void udi_msc_data_send(uint8_t * buffer, uint8_t buf_size)
 {
-	// Sends data on IN endpoint
-	if (!udd_ep_run(UDI_MSC_EP_IN, true,
-					buffer, buf_size, udi_msc_data_sent)) {
-		// If endpoint not available, then exit process command
-		udi_msc_sense_fail_hardware();
-		udi_msc_csw_process();
-	}
+  // Sends data on IN endpoint
+  if (!udd_ep_run(UDI_MSC_EP_IN, true,
+          buffer, buf_size, udi_msc_data_sent)) {
+    // If endpoint not available, then exit process command
+    udi_msc_sense_fail_hardware();
+    udi_msc_csw_process();
+  }
 }
 
 
 static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,
-		udd_ep_id_t ep)
+    udd_ep_id_t ep)
 {
-	UNUSED(ep);
-	if (UDD_EP_TRANSFER_OK != status) {
-		// Error protocol
-		// Now wait MSC setup reset to relaunch CBW reception
-		return;
-	}
-	// Update sense data
-	udi_msc_sense_pass();
-	// Update CSW
-	udi_msc_csw.dCSWDataResidue -= nb_sent;
-	udi_msc_csw_process();
+  UNUSED(ep);
+  if (UDD_EP_TRANSFER_OK != status) {
+    // Error protocol
+    // Now wait MSC setup reset to relaunch CBW reception
+    return;
+  }
+  // Update sense data
+  udi_msc_sense_pass();
+  // Update CSW
+  udi_msc_csw.dCSWDataResidue -= nb_sent;
+  udi_msc_csw_process();
 }
 
 
@@ -648,44 +650,44 @@ static void udi_msc_data_sent(udd_ep_status_t status, iram_size_t nb_sent,
 
 static void udi_msc_csw_process(void)
 {
-	if (0 != udi_msc_csw.dCSWDataResidue) {
-		// Residue not NULL
-		// then STALL next request from USB host on corresponding endpoint
-		if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)
-			udd_ep_set_halt(UDI_MSC_EP_IN);
-		else
-			udd_ep_set_halt(UDI_MSC_EP_OUT);
-	}
-	// Prepare and send CSW
-	udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;
-	udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);
-	udi_msc_csw_send();
+  if (0 != udi_msc_csw.dCSWDataResidue) {
+    // Residue not NULL
+    // then STALL next request from USB host on corresponding endpoint
+    if (udi_msc_cbw.bmCBWFlags & USB_CBW_DIRECTION_IN)
+      udd_ep_set_halt(UDI_MSC_EP_IN);
+    else
+      udd_ep_set_halt(UDI_MSC_EP_OUT);
+  }
+  // Prepare and send CSW
+  udi_msc_csw.dCSWTag = udi_msc_cbw.dCBWTag;
+  udi_msc_csw.dCSWDataResidue = cpu_to_le32(udi_msc_csw.dCSWDataResidue);
+  udi_msc_csw_send();
 }
 
 
 void udi_msc_csw_send(void)
 {
-	// Sends CSW on IN endpoint
-	if (!udd_ep_run(UDI_MSC_EP_IN, false,
-					(uint8_t *) & udi_msc_csw,
-					sizeof(udi_msc_csw),
-					udi_msc_csw_sent)) {
-		// Endpoint not available
-		// then restart CSW sent when endpoint IN STALL will be cleared
-		udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_send);
-	}
+  // Sends CSW on IN endpoint
+  if (!udd_ep_run(UDI_MSC_EP_IN, false,
+          (uint8_t *) & udi_msc_csw,
+          sizeof(udi_msc_csw),
+          udi_msc_csw_sent)) {
+    // Endpoint not available
+    // then restart CSW sent when endpoint IN STALL will be cleared
+    udd_ep_wait_stall_clear(UDI_MSC_EP_IN, udi_msc_csw_send);
+  }
 }
 
 
 static void udi_msc_csw_sent(udd_ep_status_t status, iram_size_t nb_sent,
-		udd_ep_id_t ep)
+    udd_ep_id_t ep)
 {
-	UNUSED(ep);
-	UNUSED(status);
-	UNUSED(nb_sent);
-	// CSW is sent or not
-	// In all case, restart process and wait CBW
-	udi_msc_cbw_wait();
+  UNUSED(ep);
+  UNUSED(status);
+  UNUSED(nb_sent);
+  // CSW is sent or not
+  // In all case, restart process and wait CBW
+  udi_msc_cbw_wait();
 }
 
 
@@ -694,64 +696,64 @@ static void udi_msc_csw_sent(udd_ep_status_t status, iram_size_t nb_sent,
 
 static void udi_msc_clear_sense(void)
 {
-	memset((uint8_t*)&udi_msc_sense, 0, sizeof(struct scsi_request_sense_data));
-	udi_msc_sense.valid_reponse_code = SCSI_SENSE_VALID | SCSI_SENSE_CURRENT;
-	udi_msc_sense.AddSenseLen = SCSI_SENSE_ADDL_LEN(sizeof(udi_msc_sense));
+  memset((uint8_t*)&udi_msc_sense, 0, sizeof(struct scsi_request_sense_data));
+  udi_msc_sense.valid_reponse_code = SCSI_SENSE_VALID | SCSI_SENSE_CURRENT;
+  udi_msc_sense.AddSenseLen = SCSI_SENSE_ADDL_LEN(sizeof(udi_msc_sense));
 }
 
 static void udi_msc_sense_fail(uint8_t sense_key, uint16_t add_sense,
-		uint32_t lba)
+    uint32_t lba)
 {
-	udi_msc_clear_sense();
-	udi_msc_csw.bCSWStatus = USB_CSW_STATUS_FAIL;
-	udi_msc_sense.sense_flag_key = sense_key;
-	udi_msc_sense.information[0] = lba >> 24;
-	udi_msc_sense.information[1] = lba >> 16;
-	udi_msc_sense.information[2] = lba >> 8;
-	udi_msc_sense.information[3] = lba;
-	udi_msc_sense.AddSenseCode = add_sense >> 8;
-	udi_msc_sense.AddSnsCodeQlfr = add_sense;
+  udi_msc_clear_sense();
+  udi_msc_csw.bCSWStatus = USB_CSW_STATUS_FAIL;
+  udi_msc_sense.sense_flag_key = sense_key;
+  udi_msc_sense.information[0] = lba >> 24;
+  udi_msc_sense.information[1] = lba >> 16;
+  udi_msc_sense.information[2] = lba >> 8;
+  udi_msc_sense.information[3] = lba;
+  udi_msc_sense.AddSenseCode = add_sense >> 8;
+  udi_msc_sense.AddSnsCodeQlfr = add_sense;
 }
 
 static void udi_msc_sense_pass(void)
 {
-	udi_msc_clear_sense();
-	udi_msc_csw.bCSWStatus = USB_CSW_STATUS_PASS;
+  udi_msc_clear_sense();
+  udi_msc_csw.bCSWStatus = USB_CSW_STATUS_PASS;
 }
 
 
 static void udi_msc_sense_fail_not_present(void)
 {
-	udi_msc_sense_fail(SCSI_SK_NOT_READY, SCSI_ASC_MEDIUM_NOT_PRESENT, 0);
+  udi_msc_sense_fail(SCSI_SK_NOT_READY, SCSI_ASC_MEDIUM_NOT_PRESENT, 0);
 }
 
 static void udi_msc_sense_fail_busy_or_change(void)
 {
-	udi_msc_sense_fail(SCSI_SK_UNIT_ATTENTION,
-			SCSI_ASC_NOT_READY_TO_READY_CHANGE, 0);
+  udi_msc_sense_fail(SCSI_SK_UNIT_ATTENTION,
+      SCSI_ASC_NOT_READY_TO_READY_CHANGE, 0);
 }
 
 static void udi_msc_sense_fail_hardware(void)
 {
-	udi_msc_sense_fail(SCSI_SK_HARDWARE_ERROR,
-			SCSI_ASC_NO_ADDITIONAL_SENSE_INFO, 0);
+  udi_msc_sense_fail(SCSI_SK_HARDWARE_ERROR,
+      SCSI_ASC_NO_ADDITIONAL_SENSE_INFO, 0);
 }
 
 static void udi_msc_sense_fail_protected(void)
 {
-	udi_msc_sense_fail(SCSI_SK_DATA_PROTECT, SCSI_ASC_WRITE_PROTECTED, 0);
+  udi_msc_sense_fail(SCSI_SK_DATA_PROTECT, SCSI_ASC_WRITE_PROTECTED, 0);
 }
 
 static void udi_msc_sense_fail_cdb_invalid(void)
 {
-	udi_msc_sense_fail(SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_FIELD_IN_CDB, 0);
+  udi_msc_sense_fail(SCSI_SK_ILLEGAL_REQUEST,
+      SCSI_ASC_INVALID_FIELD_IN_CDB, 0);
 }
 
 static void udi_msc_sense_command_invalid(void)
 {
-	udi_msc_sense_fail(SCSI_SK_ILLEGAL_REQUEST,
-			SCSI_ASC_INVALID_COMMAND_OPERATION_CODE, 0);
+  udi_msc_sense_fail(SCSI_SK_ILLEGAL_REQUEST,
+      SCSI_ASC_INVALID_COMMAND_OPERATION_CODE, 0);
 }
 
 
@@ -760,369 +762,370 @@ static void udi_msc_sense_command_invalid(void)
 
 static void udi_msc_spc_requestsense(void)
 {
-	uint8_t length = udi_msc_cbw.CDB[4];
+  uint8_t length = udi_msc_cbw.CDB[4];
 
-	// Can't send more than sense data length
-	if (length > sizeof(udi_msc_sense))
-		length = sizeof(udi_msc_sense);
+  // Can't send more than sense data length
+  if (length > sizeof(udi_msc_sense))
+    length = sizeof(udi_msc_sense);
 
-	if (!udi_msc_cbw_validate(length, USB_CBW_DIRECTION_IN))
-		return;
-	// Send sense data
-	udi_msc_data_send((uint8_t*)&udi_msc_sense, length);
+  if (!udi_msc_cbw_validate(length, USB_CBW_DIRECTION_IN))
+    return;
+  // Send sense data
+  udi_msc_data_send((uint8_t*)&udi_msc_sense, length);
 }
 
 
 static void udi_msc_spc_inquiry(void)
 {
-	uint8_t length, i;
-	UDC_DATA(4)
-	// Constant inquiry data for all LUNs
-	static struct scsi_inquiry_data udi_msc_inquiry_data = {
-		.pq_pdt = SCSI_INQ_PQ_CONNECTED | SCSI_INQ_DT_DIR_ACCESS,
-		.version = SCSI_INQ_VER_SPC,
-		.flags3 = SCSI_INQ_RSP_SPC2,
-		.addl_len = SCSI_INQ_ADDL_LEN(sizeof(struct scsi_inquiry_data)),
-		.vendor_id = {UDI_MSC_GLOBAL_VENDOR_ID},
-		.product_rev = {UDI_MSC_GLOBAL_PRODUCT_VERSION},
-	};
-
-	length = udi_msc_cbw.CDB[4];
-
-	// Can't send more than inquiry data length
-	if (length > sizeof(udi_msc_inquiry_data))
-		length = sizeof(udi_msc_inquiry_data);
-
-	if (!udi_msc_cbw_validate(length, USB_CBW_DIRECTION_IN))
-		return;
-	if ((0 != (udi_msc_cbw.CDB[1] & (SCSI_INQ_REQ_EVPD | SCSI_INQ_REQ_CMDT)))
-			|| (0 != udi_msc_cbw.CDB[2])) {
-		// CMDT and EPVD bits are not at 0
-		// PAGE or OPERATION CODE fields are not empty
-		//  = No standard inquiry asked
-		udi_msc_sense_fail_cdb_invalid(); // Command is unsupported
-		udi_msc_csw_process();
-		return;
-	}
-
-	udi_msc_inquiry_data.flags1 = mem_removal(udi_msc_cbw.bCBWLUN) ?
-			SCSI_INQ_RMB : 0;
-
-	//* Fill product ID field
-	// Copy name in product id field
-	memcpy(udi_msc_inquiry_data.product_id,
-			mem_name(udi_msc_cbw.bCBWLUN)+1, // To remove first '"'
-			sizeof(udi_msc_inquiry_data.product_id));
-
-	// Search end of name '/0' or '"'
-	i = 0;
-	while (sizeof(udi_msc_inquiry_data.product_id) != i) {
-		if ((0 == udi_msc_inquiry_data.product_id[i])
-				|| ('"' == udi_msc_inquiry_data.product_id[i])) {
-			break;
-		}
-		i++;
-	}
-	// Padding with space char
-	while (sizeof(udi_msc_inquiry_data.product_id) != i) {
-		udi_msc_inquiry_data.product_id[i] = ' ';
-		i++;
-	}
-
-	// Send inquiry data
-	udi_msc_data_send((uint8_t *) & udi_msc_inquiry_data, length);
+  uint8_t length, i;
+  UDC_DATA(4)
+  // Constant inquiry data for all LUNs
+  static struct scsi_inquiry_data udi_msc_inquiry_data = {
+    .pq_pdt = SCSI_INQ_PQ_CONNECTED | SCSI_INQ_DT_DIR_ACCESS,
+    .version = SCSI_INQ_VER_SPC,
+    .flags3 = SCSI_INQ_RSP_SPC2,
+    .addl_len = SCSI_INQ_ADDL_LEN(sizeof(struct scsi_inquiry_data)),
+    .vendor_id = {UDI_MSC_GLOBAL_VENDOR_ID},
+    .product_rev = {UDI_MSC_GLOBAL_PRODUCT_VERSION},
+  };
+
+  length = udi_msc_cbw.CDB[4];
+
+  // Can't send more than inquiry data length
+  if (length > sizeof(udi_msc_inquiry_data))
+    length = sizeof(udi_msc_inquiry_data);
+
+  if (!udi_msc_cbw_validate(length, USB_CBW_DIRECTION_IN))
+    return;
+  if ((0 != (udi_msc_cbw.CDB[1] & (SCSI_INQ_REQ_EVPD | SCSI_INQ_REQ_CMDT)))
+      || (0 != udi_msc_cbw.CDB[2])) {
+    // CMDT and EPVD bits are not at 0
+    // PAGE or OPERATION CODE fields are not empty
+    //  = No standard inquiry asked
+    udi_msc_sense_fail_cdb_invalid(); // Command is unsupported
+    udi_msc_csw_process();
+    return;
+  }
+
+  udi_msc_inquiry_data.flags1 = mem_removal(udi_msc_cbw.bCBWLUN) ?
+      SCSI_INQ_RMB : 0;
+
+  //* Fill product ID field
+  // Copy name in product id field
+  memcpy(udi_msc_inquiry_data.product_id,
+      mem_name(udi_msc_cbw.bCBWLUN)+1, // To remove first '"'
+      sizeof(udi_msc_inquiry_data.product_id));
+
+  // Search end of name '/0' or '"'
+  i = 0;
+  while (sizeof(udi_msc_inquiry_data.product_id) != i) {
+    if ((0 == udi_msc_inquiry_data.product_id[i])
+        || ('"' == udi_msc_inquiry_data.product_id[i])) {
+      break;
+    }
+    i++;
+  }
+  // Padding with space char
+  while (sizeof(udi_msc_inquiry_data.product_id) != i) {
+    udi_msc_inquiry_data.product_id[i] = ' ';
+    i++;
+  }
+
+  // Send inquiry data
+  udi_msc_data_send((uint8_t *) & udi_msc_inquiry_data, length);
 }
 
 
 static bool udi_msc_spc_testunitready_global(void)
 {
-	switch (mem_test_unit_ready(udi_msc_cbw.bCBWLUN)) {
-	case CTRL_GOOD:
-		return true;	// Don't change sense data
-	case CTRL_BUSY:
-		udi_msc_sense_fail_busy_or_change();
-		break;
-	case CTRL_NO_PRESENT:
-		udi_msc_sense_fail_not_present();
-		break;
-	case CTRL_FAIL:
-	default:
-		udi_msc_sense_fail_hardware();
-		break;
-	}
-	return false;
+  switch (mem_test_unit_ready(udi_msc_cbw.bCBWLUN)) {
+  case CTRL_GOOD:
+    return true;  // Don't change sense data
+  case CTRL_BUSY:
+    udi_msc_sense_fail_busy_or_change();
+    break;
+  case CTRL_NO_PRESENT:
+    udi_msc_sense_fail_not_present();
+    break;
+  case CTRL_FAIL:
+  default:
+    udi_msc_sense_fail_hardware();
+    break;
+  }
+  return false;
 }
 
 
 static void udi_msc_spc_testunitready(void)
 {
-	if (udi_msc_spc_testunitready_global()) {
-		// LUN ready, then update sense data with status pass
-		udi_msc_sense_pass();
-	}
-	// Send status in CSW packet
-	udi_msc_csw_process();
+  if (udi_msc_spc_testunitready_global()) {
+    // LUN ready, then update sense data with status pass
+    udi_msc_sense_pass();
+  }
+  // Send status in CSW packet
+  udi_msc_csw_process();
 }
 
 
 static void udi_msc_spc_mode_sense(bool b_sense10)
 {
-	// Union of all mode sense structures
-	union sense_6_10 {
-		struct {
-			struct scsi_mode_param_header6 header;
-			struct spc_control_page_info_execpt sense_data;
-		} s6;
-		struct {
-			struct scsi_mode_param_header10 header;
-			struct spc_control_page_info_execpt sense_data;
-		} s10;
-	};
-
-	uint8_t data_sense_lgt;
-	uint8_t mode;
-	uint8_t request_lgt;
-	uint8_t wp;
-	struct spc_control_page_info_execpt *ptr_mode;
-	UDC_BSS(4)  static union sense_6_10 sense;
-
-	// Clear all fields
-	memset(&sense, 0, sizeof(sense));
-
-	// Initialize process
-	if (b_sense10) {
-		request_lgt = udi_msc_cbw.CDB[8];
-		ptr_mode = &sense.s10.sense_data;
-		data_sense_lgt = sizeof(struct scsi_mode_param_header10);
-	} else {
-		request_lgt = udi_msc_cbw.CDB[4];
-		ptr_mode = &sense.s6.sense_data;
-		data_sense_lgt = sizeof(struct scsi_mode_param_header6);
-	}
-
-	// No Block descriptor
-
-	// Fill page(s)
-	mode = udi_msc_cbw.CDB[2] & SCSI_MS_MODE_ALL;
-	if ((SCSI_MS_MODE_INFEXP == mode)
-			|| (SCSI_MS_MODE_ALL == mode)) {
-		// Informational exceptions control page (from SPC)
-		ptr_mode->page_code =
-				SCSI_MS_MODE_INFEXP;
-		ptr_mode->page_length =
-				SPC_MP_INFEXP_PAGE_LENGTH;
-		ptr_mode->mrie =
-				SPC_MP_INFEXP_MRIE_NO_SENSE;
-		data_sense_lgt += sizeof(struct spc_control_page_info_execpt);
-	}
-	// Can't send more than mode sense data length
-	if (request_lgt > data_sense_lgt)
-		request_lgt = data_sense_lgt;
-	if (!udi_msc_cbw_validate(request_lgt, USB_CBW_DIRECTION_IN))
-		return;
-
-	// Fill mode parameter header length
-	wp = (mem_wr_protect(udi_msc_cbw.bCBWLUN)) ? SCSI_MS_SBC_WP : 0;
-
-	if (b_sense10) {
-		sense.s10.header.mode_data_length =
-				cpu_to_be16((data_sense_lgt - 2));
-		//sense.s10.header.medium_type                 = 0;
-		sense.s10.header.device_specific_parameter = wp;
-		//sense.s10.header.block_descriptor_length     = 0;
-	} else {
-		sense.s6.header.mode_data_length = data_sense_lgt - 1;
-		//sense.s6.header.medium_type                  = 0;
-		sense.s6.header.device_specific_parameter = wp;
-		//sense.s6.header.block_descriptor_length      = 0;
-	}
-
-	// Send mode sense data
-	udi_msc_data_send((uint8_t *) & sense, request_lgt);
+  // Union of all mode sense structures
+  union sense_6_10 {
+    struct {
+      struct scsi_mode_param_header6 header;
+      struct spc_control_page_info_execpt sense_data;
+    } s6;
+    struct {
+      struct scsi_mode_param_header10 header;
+      struct spc_control_page_info_execpt sense_data;
+    } s10;
+  };
+
+  uint8_t data_sense_lgt;
+  uint8_t mode;
+  uint8_t request_lgt;
+  uint8_t wp;
+  struct spc_control_page_info_execpt *ptr_mode;
+  UDC_BSS(4)  static union sense_6_10 sense;
+
+  // Clear all fields
+  memset(&sense, 0, sizeof(sense));
+
+  // Initialize process
+  if (b_sense10) {
+    request_lgt = udi_msc_cbw.CDB[8];
+    ptr_mode = &sense.s10.sense_data;
+    data_sense_lgt = sizeof(struct scsi_mode_param_header10);
+  } else {
+    request_lgt = udi_msc_cbw.CDB[4];
+    ptr_mode = &sense.s6.sense_data;
+    data_sense_lgt = sizeof(struct scsi_mode_param_header6);
+  }
+
+  // No Block descriptor
+
+  // Fill page(s)
+  mode = udi_msc_cbw.CDB[2] & SCSI_MS_MODE_ALL;
+  if ((SCSI_MS_MODE_INFEXP == mode)
+      || (SCSI_MS_MODE_ALL == mode)) {
+    // Informational exceptions control page (from SPC)
+    ptr_mode->page_code =
+        SCSI_MS_MODE_INFEXP;
+    ptr_mode->page_length =
+        SPC_MP_INFEXP_PAGE_LENGTH;
+    ptr_mode->mrie =
+        SPC_MP_INFEXP_MRIE_NO_SENSE;
+    data_sense_lgt += sizeof(struct spc_control_page_info_execpt);
+  }
+  // Can't send more than mode sense data length
+  if (request_lgt > data_sense_lgt)
+    request_lgt = data_sense_lgt;
+  if (!udi_msc_cbw_validate(request_lgt, USB_CBW_DIRECTION_IN))
+    return;
+
+  // Fill mode parameter header length
+  wp = (mem_wr_protect(udi_msc_cbw.bCBWLUN)) ? SCSI_MS_SBC_WP : 0;
+
+  if (b_sense10) {
+    sense.s10.header.mode_data_length =
+        cpu_to_be16((data_sense_lgt - 2));
+    //sense.s10.header.medium_type                 = 0;
+    sense.s10.header.device_specific_parameter = wp;
+    //sense.s10.header.block_descriptor_length     = 0;
+  } else {
+    sense.s6.header.mode_data_length = data_sense_lgt - 1;
+    //sense.s6.header.medium_type                  = 0;
+    sense.s6.header.device_specific_parameter = wp;
+    //sense.s6.header.block_descriptor_length      = 0;
+  }
+
+  // Send mode sense data
+  udi_msc_data_send((uint8_t *) & sense, request_lgt);
 }
 
 
 static void udi_msc_spc_prevent_allow_medium_removal(void)
 {
-	uint8_t prevent = udi_msc_cbw.CDB[4];
-	if (0 == prevent) {
-		udi_msc_sense_pass();
-	} else {
-		udi_msc_sense_fail_cdb_invalid(); // Command is unsupported
-	}
-	udi_msc_csw_process();
+  uint8_t prevent = udi_msc_cbw.CDB[4];
+  if (0 == prevent) {
+    udi_msc_sense_pass();
+  } else {
+    udi_msc_sense_fail_cdb_invalid(); // Command is unsupported
+  }
+  udi_msc_csw_process();
 }
 
 
 static void udi_msc_sbc_start_stop(void)
 {
-	bool start = 0x1 & udi_msc_cbw.CDB[4];
-	bool loej = 0x2 & udi_msc_cbw.CDB[4];
-	if (loej) {
-		mem_unload(udi_msc_cbw.bCBWLUN, !start);
-	}
-	udi_msc_sense_pass();
-	udi_msc_csw_process();
+  bool start = 0x1 & udi_msc_cbw.CDB[4];
+  bool loej = 0x2 & udi_msc_cbw.CDB[4];
+  if (loej) {
+    mem_unload(udi_msc_cbw.bCBWLUN, !start);
+  }
+  udi_msc_sense_pass();
+  udi_msc_csw_process();
 }
 
 
 static void udi_msc_sbc_read_capacity(void)
 {
-	UDC_BSS(4) static struct sbc_read_capacity10_data udi_msc_capacity;
-
-	if (!udi_msc_cbw_validate(sizeof(udi_msc_capacity),
-					USB_CBW_DIRECTION_IN))
-		return;
-
-	// Get capacity of LUN
-	switch (mem_read_capacity(udi_msc_cbw.bCBWLUN,
-					&udi_msc_capacity.max_lba)) {
-	case CTRL_GOOD:
-		break;
-	case CTRL_BUSY:
-		udi_msc_sense_fail_busy_or_change();
-		udi_msc_csw_process();
-		return;
-	case CTRL_NO_PRESENT:
-		udi_msc_sense_fail_not_present();
-		udi_msc_csw_process();
-		return;
-	default:
-		udi_msc_sense_fail_hardware();
-		udi_msc_csw_process();
-		return;
-	}
-
-	// Format capacity data
-	udi_msc_capacity.block_len = CPU_TO_BE32(UDI_MSC_BLOCK_SIZE);
-	udi_msc_capacity.max_lba = cpu_to_be32(udi_msc_capacity.max_lba);
-	// Send the corresponding sense data
-	udi_msc_data_send((uint8_t *) & udi_msc_capacity,
-			sizeof(udi_msc_capacity));
+  UDC_BSS(4) static struct sbc_read_capacity10_data udi_msc_capacity;
+
+  if (!udi_msc_cbw_validate(sizeof(udi_msc_capacity),
+          USB_CBW_DIRECTION_IN))
+    return;
+
+  // Get capacity of LUN
+  switch (mem_read_capacity(udi_msc_cbw.bCBWLUN,
+          &udi_msc_capacity.max_lba)) {
+  case CTRL_GOOD:
+    break;
+  case CTRL_BUSY:
+    udi_msc_sense_fail_busy_or_change();
+    udi_msc_csw_process();
+    return;
+  case CTRL_NO_PRESENT:
+    udi_msc_sense_fail_not_present();
+    udi_msc_csw_process();
+    return;
+  default:
+    udi_msc_sense_fail_hardware();
+    udi_msc_csw_process();
+    return;
+  }
+
+  // Format capacity data
+  udi_msc_capacity.block_len = CPU_TO_BE32(UDI_MSC_BLOCK_SIZE);
+  udi_msc_capacity.max_lba = cpu_to_be32(udi_msc_capacity.max_lba);
+  // Send the corresponding sense data
+  udi_msc_data_send((uint8_t *) & udi_msc_capacity,
+      sizeof(udi_msc_capacity));
 }
 
 
 static void udi_msc_sbc_trans(bool b_read)
 {
-	uint32_t trans_size;
-
-	if (!b_read) {
-		// Write operation then check Write Protect
-		if (mem_wr_protect(udi_msc_cbw.bCBWLUN)) {
-			// Write not authorized
-			udi_msc_sense_fail_protected();
-			udi_msc_csw_process();
-			return;
-		}
-	}
-	// Read/Write command fields (address and number of block)
-	MSB0(udi_msc_addr) = udi_msc_cbw.CDB[2];
-	MSB1(udi_msc_addr) = udi_msc_cbw.CDB[3];
-	MSB2(udi_msc_addr) = udi_msc_cbw.CDB[4];
-	MSB3(udi_msc_addr) = udi_msc_cbw.CDB[5];
-	MSB(udi_msc_nb_block) = udi_msc_cbw.CDB[7];
-	LSB(udi_msc_nb_block) = udi_msc_cbw.CDB[8];
-
-	// Compute number of byte to transfer and valid it
-	trans_size = (uint32_t) udi_msc_nb_block *UDI_MSC_BLOCK_SIZE;
-	if (!udi_msc_cbw_validate(trans_size,
-					(b_read) ? USB_CBW_DIRECTION_IN :
-					USB_CBW_DIRECTION_OUT))
-		return;
-
-	// Record transfer request to do it in a task and not under interrupt
-	udi_msc_b_read = b_read;
-	udi_msc_b_trans_req = true;
-	UDI_MSC_NOTIFY_TRANS_EXT();
+  uint32_t trans_size;
+
+  if (!b_read) {
+    // Write operation then check Write Protect
+    if (mem_wr_protect(udi_msc_cbw.bCBWLUN)) {
+      // Write not authorized
+      udi_msc_sense_fail_protected();
+      udi_msc_csw_process();
+      return;
+    }
+  }
+  // Read/Write command fields (address and number of block)
+  MSB0(udi_msc_addr) = udi_msc_cbw.CDB[2];
+  MSB1(udi_msc_addr) = udi_msc_cbw.CDB[3];
+  MSB2(udi_msc_addr) = udi_msc_cbw.CDB[4];
+  MSB3(udi_msc_addr) = udi_msc_cbw.CDB[5];
+  MSB(udi_msc_nb_block) = udi_msc_cbw.CDB[7];
+  LSB(udi_msc_nb_block) = udi_msc_cbw.CDB[8];
+
+  // Compute number of byte to transfer and valid it
+  trans_size = (uint32_t) udi_msc_nb_block *UDI_MSC_BLOCK_SIZE;
+  if (!udi_msc_cbw_validate(trans_size,
+          (b_read) ? USB_CBW_DIRECTION_IN :
+          USB_CBW_DIRECTION_OUT))
+    return;
+
+  // Record transfer request to do it in a task and not under interrupt
+  udi_msc_b_read = b_read;
+  udi_msc_b_trans_req = true;
+  UDI_MSC_NOTIFY_TRANS_EXT();
 }
 
 
 bool udi_msc_process_trans(void)
 {
-	Ctrl_status status;
-
-	if (!udi_msc_b_trans_req)
-		return false;	// No Transfer request to do
-	udi_msc_b_trans_req = false;
-	udi_msc_b_reset_trans = false;
-
-	// Start transfer
-	if (udi_msc_b_read) {
-		status = memory_2_usb(udi_msc_cbw.bCBWLUN, udi_msc_addr,
-				udi_msc_nb_block);
-	} else {
-		status = usb_2_memory(udi_msc_cbw.bCBWLUN, udi_msc_addr,
-				udi_msc_nb_block);
-	}
-
-	// Check if transfer is aborted by reset
-	if (udi_msc_b_reset_trans) {
-		udi_msc_b_reset_trans = false;
-		return true;
-	}
-
-	// Check status of transfer
-	switch (status) {
-	case CTRL_GOOD:
-		udi_msc_sense_pass();
-		break;
-	case CTRL_BUSY:
-		udi_msc_sense_fail_busy_or_change();
-		break;
-	case CTRL_NO_PRESENT:
-		udi_msc_sense_fail_not_present();
-		break;
-	default:
-	case CTRL_FAIL:
-		udi_msc_sense_fail_hardware();
-		break;
-	}
-	// Send status of transfer in CSW packet
-	udi_msc_csw_process();
-	return true;
+  Ctrl_status status;
+
+  if (!udi_msc_b_trans_req)
+    return false; // No Transfer request to do
+  udi_msc_b_trans_req = false;
+  udi_msc_b_reset_trans = false;
+
+  // Start transfer
+  if (udi_msc_b_read) {
+    status = memory_2_usb(udi_msc_cbw.bCBWLUN, udi_msc_addr,
+        udi_msc_nb_block);
+  } else {
+    status = usb_2_memory(udi_msc_cbw.bCBWLUN, udi_msc_addr,
+        udi_msc_nb_block);
+  }
+
+  // Check if transfer is aborted by reset
+  if (udi_msc_b_reset_trans) {
+    udi_msc_b_reset_trans = false;
+    return true;
+  }
+
+  // Check status of transfer
+  switch (status) {
+  case CTRL_GOOD:
+    udi_msc_sense_pass();
+    break;
+  case CTRL_BUSY:
+    udi_msc_sense_fail_busy_or_change();
+    break;
+  case CTRL_NO_PRESENT:
+    udi_msc_sense_fail_not_present();
+    break;
+  default:
+  case CTRL_FAIL:
+    udi_msc_sense_fail_hardware();
+    break;
+  }
+  // Send status of transfer in CSW packet
+  udi_msc_csw_process();
+  return true;
 }
 
 
 static void udi_msc_trans_ack(udd_ep_status_t status, iram_size_t n,
-		udd_ep_id_t ep)
+    udd_ep_id_t ep)
 {
-	UNUSED(ep);
-	UNUSED(n);
-	// Update variable to signal the end of transfer
-	udi_msc_b_abort_trans = (UDD_EP_TRANSFER_OK != status) ? true : false;
-	udi_msc_b_ack_trans = true;
+  UNUSED(ep);
+  UNUSED(n);
+  // Update variable to signal the end of transfer
+  udi_msc_b_abort_trans = (UDD_EP_TRANSFER_OK != status) ? true : false;
+  udi_msc_b_ack_trans = true;
 }
 
 
 bool udi_msc_trans_block(bool b_read, uint8_t * block, iram_size_t block_size,
-		void (*callback) (udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep))
+    void (*callback) (udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep))
 {
-	if (!udi_msc_b_ack_trans)
-		return false;	// No possible, transfer on going
-
-	// Start transfer Internal RAM<->USB line
-	udi_msc_b_ack_trans = false;
-	if (!udd_ep_run((b_read) ? UDI_MSC_EP_IN : UDI_MSC_EP_OUT,
-					false,
-					block,
-					block_size,
-					(NULL == callback) ? udi_msc_trans_ack :
-					callback)) {
-		udi_msc_b_ack_trans = true;
-		return false;
-	}
-	if (NULL == callback) {
-		while (!udi_msc_b_ack_trans);
-		if (udi_msc_b_abort_trans) {
-			return false;
-		}
-		udi_msc_csw.dCSWDataResidue -= block_size;
-		return (!udi_msc_b_abort_trans);
-	}
-	udi_msc_csw.dCSWDataResidue -= block_size;
-	return true;
+  if (!udi_msc_b_ack_trans)
+    return false; // No possible, transfer on going
+
+  // Start transfer Internal RAM<->USB line
+  udi_msc_b_ack_trans = false;
+  if (!udd_ep_run((b_read) ? UDI_MSC_EP_IN : UDI_MSC_EP_OUT,
+          false,
+          block,
+          block_size,
+          (NULL == callback) ? udi_msc_trans_ack :
+          callback)) {
+    udi_msc_b_ack_trans = true;
+    return false;
+  }
+  if (NULL == callback) {
+    while (!udi_msc_b_ack_trans);
+    if (udi_msc_b_abort_trans) {
+      return false;
+    }
+    udi_msc_csw.dCSWDataResidue -= block_size;
+    return (!udi_msc_b_abort_trans);
+  }
+  udi_msc_csw.dCSWDataResidue -= block_size;
+  return true;
 }
 
 //@}
 
+#endif
 #endif
\ No newline at end of file
diff --git a/Marlin/src/HAL/HAL_DUE/usb/usb_task.c b/Marlin/src/HAL/HAL_DUE/usb/usb_task.c
index 711cbf9640f..55d3e846fb3 100644
--- a/Marlin/src/HAL/HAL_DUE/usb/usb_task.c
+++ b/Marlin/src/HAL/HAL_DUE/usb/usb_task.c
@@ -50,24 +50,30 @@
 #include <Arduino.h>
 #include <Reset.h>
 
-static volatile bool main_b_msc_enable = false;
+#if ENABLED(SDSUPPORT)
+  static volatile bool main_b_msc_enable = false;
+#endif
 static volatile bool main_b_cdc_enable = false;
 static volatile bool main_b_dtr_active = false;
 
 void HAL_idletask(void) {
-  // Attend SD card access from the USB MSD -- Prioritize access to improve speed
-  int delay = 2;
-  while (main_b_msc_enable && --delay > 0) {
-    if (udi_msc_process_trans()) delay = 10000;
-
-    // Reset the watchdog, just to be sure
-    REG_WDT_CR = WDT_CR_WDRSTT | WDT_CR_KEY(0xA5);
-  }
+  #if ENABLED(SDSUPPORT)
+    // Attend SD card access from the USB MSD -- Prioritize access to improve speed
+    int delay = 2;
+    while (main_b_msc_enable && --delay > 0) {
+      if (udi_msc_process_trans()) delay = 10000;
+
+      // Reset the watchdog, just to be sure
+      REG_WDT_CR = WDT_CR_WDRSTT | WDT_CR_KEY(0xA5);
+    }
+  #endif
 }
 
-bool usb_task_msc_enable(void)                { return ((main_b_msc_enable = true)); }
-void usb_task_msc_disable(void)               { main_b_msc_enable = false; }
-bool usb_task_msc_isenabled(void)             { return main_b_msc_enable; }
+#if ENABLED(SDSUPPORT)
+  bool usb_task_msc_enable(void)                { return ((main_b_msc_enable = true)); }
+  void usb_task_msc_disable(void)               { main_b_msc_enable = false; }
+  bool usb_task_msc_isenabled(void)             { return main_b_msc_enable; }
+#endif
 
 bool usb_task_cdc_enable(const uint8_t port)  { return ((main_b_cdc_enable = true)); }
 void usb_task_cdc_disable(const uint8_t port) { main_b_cdc_enable = false; main_b_dtr_active = false; }
@@ -192,11 +198,17 @@ static USB_MicrosoftExtendedPropertiesDescriptor microsoft_extended_properties_d
 bool usb_task_extra_string(void) {
   static uint8_t udi_msft_magic[] = "MSFT100\xEE";
   static uint8_t udi_cdc_name[] = "CDC interface";
-  static uint8_t udi_msc_name[] = "MSC interface";
+  #if ENABLED(SDSUPPORT)
+    static uint8_t udi_msc_name[] = "MSC interface";
+  #endif
 
   struct extra_strings_desc_t {
     usb_str_desc_t header;
-    le16_t string[Max(Max(sizeof(udi_cdc_name) - 1, sizeof(udi_msc_name) - 1), sizeof(udi_msft_magic) - 1)];
+    #if ENABLED(SDSUPPORT)
+      le16_t string[Max(Max(sizeof(udi_cdc_name) - 1, sizeof(udi_msc_name) - 1), sizeof(udi_msft_magic) - 1)];
+    #else
+      le16_t string[Max(sizeof(udi_cdc_name) - 1, sizeof(udi_msft_magic) - 1)];
+    #endif
   };
   static UDC_DESC_STORAGE struct extra_strings_desc_t extra_strings_desc = {
     .header.bDescriptorType = USB_DT_STRING
@@ -211,10 +223,12 @@ bool usb_task_extra_string(void) {
     str_lgt = sizeof(udi_cdc_name) - 1;
     str = udi_cdc_name;
     break;
-  case UDI_MSC_STRING_ID:
-    str_lgt = sizeof(udi_msc_name) - 1;
-    str = udi_msc_name;
-    break;
+  #if ENABLED(SDSUPPORT)
+    case UDI_MSC_STRING_ID:
+      str_lgt = sizeof(udi_msc_name) - 1;
+      str = udi_msc_name;
+      break;
+  #endif
   case 0xEE:
     str_lgt = sizeof(udi_msft_magic) - 1;
     str = udi_msft_magic;
