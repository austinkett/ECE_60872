diff --git a/.travis.yml b/.travis.yml
index 951e9852767..33af6698210 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -120,7 +120,7 @@ script:
   # Test a simple build of AUTO_BED_LEVELING_UBL
   #
   - restore_configs
-  - opt_enable AUTO_BED_LEVELING_UBL UBL_G26_MESH_EDITING FIX_MOUNTED_PROBE EEPROM_SETTINGS G3D_PANEL
+  - opt_enable AUTO_BED_LEVELING_UBL UBL_G26_MESH_EDITING ENABLE_LEVELING_FADE_HEIGHT FIX_MOUNTED_PROBE EEPROM_SETTINGS G3D_PANEL
   - build_marlin
   #
   # Test a Sled Z Probe
diff --git a/Marlin/G26_Mesh_Validation_Tool.cpp b/Marlin/G26_Mesh_Validation_Tool.cpp
index bd17b9d0251..8d250de4854 100644
--- a/Marlin/G26_Mesh_Validation_Tool.cpp
+++ b/Marlin/G26_Mesh_Validation_Tool.cpp
@@ -47,8 +47,8 @@
   #define OOZE_AMOUNT 0.3
 
   #define SIZE_OF_INTERSECTION_CIRCLES 5
-  #define SIZE_OF_CROSS_HAIRS 3 // cross hairs inside the circle.  This number should be
-                                // less than SIZE_OR_INTERSECTION_CIRCLES
+  #define SIZE_OF_CROSSHAIRS 3 // crosshairs inside the circle.  This number should be
+                               // less than SIZE_OR_INTERSECTION_CIRCLES
 
   /**
    *   Roxy's G26 Mesh Validation Tool
@@ -132,12 +132,12 @@
   void line_to_destination(float );
   void gcode_G28();
   void sync_plan_position_e();
-  void un_retract_filament();
-  void retract_filament();
+  void un_retract_filament(float where[XYZE]);
+  void retract_filament(float where[XYZE]);
   void look_for_lines_to_connect();
   bool parse_G26_parameters();
   void move_to(const float&, const float&, const float&, const float&) ;
-  void print_line_from_here_to_there(float sx, float sy, float sz, float ex, float ey, float ez);
+  void print_line_from_here_to_there(const float&, const float&, const float&, const float&, const float&, const float&);
   bool turn_on_heaters();
   bool prime_nozzle();
   void chirp_at_user();
@@ -154,8 +154,6 @@
 
   float valid_trig_angle(float);
   mesh_index_pair find_closest_circle_to_print(float, float);
-  void ubl_line_to_destination(const float&, const float&, const float&, const float&, const float&, uint8_t);
-  //uint16_t x_splits = 0xFFFF, uint16_t y_splits = 0xFFFF);  /* needed for the old mesh_buffer_line() routine */
 
   static float extrusion_multiplier = EXTRUSION_MULTIPLIER,
                retraction_multiplier = RETRACTION_MULTIPLIER,
@@ -269,7 +267,7 @@
         #endif
 
         // TODO: Change this to use `position_is_reachable`
-        if (circle_x < (X_MIN_POS) || circle_x > (X_MAX_POS) || circle_y < (Y_MIN_POS) || circle_y > (Y_MAX_POS)) {
+        if (!WITHIN(circle_x, X_MIN_POS, X_MAX_POS) || !WITHIN(circle_y, Y_MIN_POS, Y_MAX_POS)) {
           SERIAL_ERROR_START;
           SERIAL_ERRORLNPGM("Attempt to print off the bed.");
           goto LEAVE;
@@ -359,7 +357,7 @@
     lcd_reset_alert_level();
     lcd_setstatuspgm(PSTR("Leaving G26"));
 
-    retract_filament();
+    retract_filament(destination);
     destination[Z_AXIS] = Z_CLEARANCE_BETWEEN_PROBES;
 
     //debug_current_and_destination((char*)"ready to do Z-Raise.");
@@ -445,18 +443,12 @@
               // We found two circles that need a horizontal line to connect them
               // Print it!
               //
-              sx = ubl.mesh_index_to_xpos[i];
-              sx = sx + SIZE_OF_INTERSECTION_CIRCLES - SIZE_OF_CROSS_HAIRS; // get the right edge of the circle
-              sy = ubl.mesh_index_to_ypos[j];
+              sx = ubl.mesh_index_to_xpos[  i  ] + (SIZE_OF_INTERSECTION_CIRCLES - (SIZE_OF_CROSSHAIRS)); // right edge
+              ex = ubl.mesh_index_to_xpos[i + 1] - (SIZE_OF_INTERSECTION_CIRCLES - (SIZE_OF_CROSSHAIRS)); // left edge
 
-              ex = ubl.mesh_index_to_xpos[i + 1];
-              ex = ex - SIZE_OF_INTERSECTION_CIRCLES + SIZE_OF_CROSS_HAIRS; // get the left edge of the circle
-              ey = sy;
-
-              sx = constrain(sx, X_MIN_POS + 1, X_MAX_POS - 1);             // This keeps us from bumping the endstops
-              sy = constrain(sy, Y_MIN_POS + 1, Y_MAX_POS - 1);
+              sx = constrain(sx, X_MIN_POS + 1, X_MAX_POS - 1);
+              sy = ey = constrain(ubl.mesh_index_to_ypos[j], Y_MIN_POS + 1, Y_MAX_POS - 1);
               ex = constrain(ex, X_MIN_POS + 1, X_MAX_POS - 1);
-              ey = constrain(ey, Y_MIN_POS + 1, Y_MAX_POS - 1);
 
               if (ubl.g26_debug_flag) {
                 SERIAL_ECHOPAIR(" Connecting with horizontal line (sx=", sx);
@@ -468,7 +460,7 @@
                 //debug_current_and_destination((char*)"Connecting horizontal line.");
               }
 
-              print_line_from_here_to_there(sx, sy, layer_height, ex, ey, layer_height);
+              print_line_from_here_to_there(LOGICAL_X_POSITION(sx), LOGICAL_Y_POSITION(sy), layer_height, LOGICAL_X_POSITION(ex), LOGICAL_Y_POSITION(ey), layer_height);
               bit_set(horizontal_mesh_line_flags, i, j);   // Mark it as done so we don't do it again
             }
           }
@@ -482,17 +474,11 @@
                 // We found two circles that need a vertical line to connect them
                 // Print it!
                 //
-                sx = ubl.mesh_index_to_xpos[i];
-                sy = ubl.mesh_index_to_ypos[j];
-                sy = sy + SIZE_OF_INTERSECTION_CIRCLES - SIZE_OF_CROSS_HAIRS; // get the top edge of the circle
-
-                ex = sx;
-                ey = ubl.mesh_index_to_ypos[j + 1];
-                ey = ey - SIZE_OF_INTERSECTION_CIRCLES + SIZE_OF_CROSS_HAIRS; // get the bottom edge of the circle
+                sy = ubl.mesh_index_to_ypos[  j  ] + (SIZE_OF_INTERSECTION_CIRCLES - (SIZE_OF_CROSSHAIRS)); // top edge
+                ey = ubl.mesh_index_to_ypos[j + 1] - (SIZE_OF_INTERSECTION_CIRCLES - (SIZE_OF_CROSSHAIRS)); // bottom edge
 
-                sx = constrain(sx, X_MIN_POS + 1, X_MAX_POS - 1);             // This keeps us from bumping the endstops
+                sx = ex = constrain(ubl.mesh_index_to_xpos[i], X_MIN_POS + 1, X_MAX_POS - 1);
                 sy = constrain(sy, Y_MIN_POS + 1, Y_MAX_POS - 1);
-                ex = constrain(ex, X_MIN_POS + 1, X_MAX_POS - 1);
                 ey = constrain(ey, Y_MIN_POS + 1, Y_MAX_POS - 1);
 
                 if (ubl.g26_debug_flag) {
@@ -504,8 +490,8 @@
                   SERIAL_EOL;
                   debug_current_and_destination((char*)"Connecting vertical line.");
                 }
-                print_line_from_here_to_there(sx, sy, layer_height, ex, ey, layer_height);
-                bit_set( vertical_mesh_line_flags, i, j);   // Mark it as done so we don't do it again
+                print_line_from_here_to_there(LOGICAL_X_POSITION(sx), LOGICAL_Y_POSITION(sy), layer_height, LOGICAL_X_POSITION(ex), LOGICAL_Y_POSITION(ey), layer_height);
+                bit_set(vertical_mesh_line_flags, i, j);   // Mark it as done so we don't do it again
               }
             }
           }
@@ -533,7 +519,7 @@
       destination[Z_AXIS] = z;                          // We know the last_z==z or we wouldn't be in this block of code.
       destination[E_AXIS] = current_position[E_AXIS];
 
-      ubl_line_to_destination(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feed_value, 0);
+      ubl_line_to_destination(feed_value, 0);
 
       stepper.synchronize();
       set_destination_to_current();
@@ -553,7 +539,7 @@
 
     //if (ubl.g26_debug_flag) debug_current_and_destination((char*)" in move_to() doing last move");
 
-    ubl_line_to_destination(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feed_value, 0);
+    ubl_line_to_destination(feed_value, 0);
 
     //if (ubl.g26_debug_flag) debug_current_and_destination((char*)" in move_to() after last move");
 
@@ -562,18 +548,18 @@
 
   }
 
-  void retract_filament() {
+  void retract_filament(float where[XYZE]) {
     if (!g26_retracted) { // Only retract if we are not already retracted!
       g26_retracted = true;
       //if (ubl.g26_debug_flag) SERIAL_ECHOLNPGM(" Decided to do retract.");
-      move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], -1.0 * retraction_multiplier);
+      move_to(where[X_AXIS], where[Y_AXIS], where[Z_AXIS], -1.0 * retraction_multiplier);
       //if (ubl.g26_debug_flag) SERIAL_ECHOLNPGM(" Retraction done.");
     }
   }
 
-  void un_retract_filament() {
+  void un_retract_filament(float where[XYZE]) {
     if (g26_retracted) { // Only un-retract if we are retracted.
-      move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], 1.2 * retraction_multiplier);
+      move_to(where[X_AXIS], where[Y_AXIS], where[Z_AXIS], 1.2 * retraction_multiplier);
       g26_retracted = false;
       //if (ubl.g26_debug_flag) SERIAL_ECHOLNPGM(" unretract done.");
     }
@@ -594,7 +580,7 @@
    * segment of a 'circle'.   The time this requires is very short and is easily saved by the other
    * cases where the optimization comes into play.
    */
-  void print_line_from_here_to_there( float sx, float sy, float sz, float ex, float ey, float ez) {
+  void print_line_from_here_to_there(const float &sx, const float &sy, const float &sz, const float &ex, const float &ey, const float &ez) {
     const float dx_s = current_position[X_AXIS] - sx,   // find our distance from the start of the actual line segment
                 dy_s = current_position[Y_AXIS] - sy,
                 dist_start = HYPOT2(dx_s, dy_s),        // We don't need to do a sqrt(), we can compare the distance^2
@@ -603,31 +589,26 @@
                 dy_e = current_position[Y_AXIS] - ey,
                 dist_end = HYPOT2(dx_e, dy_e),
 
-                dx = ex - sx,
-                dy = ey - sy,
-                line_length = HYPOT(dx, dy);
+                line_length = HYPOT(ex - sx, ey - sy);
 
-    // If the end point of the line is closer to the nozzle, we are going to
-    // flip the direction of this line.   We will print it from the end to the start.
-    // On very small lines we don't do the optimization because it just isn't worth it.
-    //
+    // If the end point of the line is closer to the nozzle, flip the direction,
+    // moving from the end to the start. On very small lines the optimization isn't worth it.
     if (dist_end < dist_start && (SIZE_OF_INTERSECTION_CIRCLES) < abs(line_length)) {
       //if (ubl.g26_debug_flag) SERIAL_ECHOLNPGM("  Reversing start and end of print_line_from_here_to_there()");
-      print_line_from_here_to_there(ex, ey, ez, sx, sy, sz);
-      return;
+      return print_line_from_here_to_there(ex, ey, ez, sx, sy, sz);
     }
 
-    // Now decide if we should retract.
+    // Decide whether to retract.
 
     if (dist_start > 2.0) {
-      retract_filament();
+      retract_filament(destination);
       //if (ubl.g26_debug_flag) SERIAL_ECHOLNPGM("  filament retracted.");
     }
     move_to(sx, sy, sz, 0.0); // Get to the starting point with no extrusion
 
     const float e_pos_delta = line_length * g26_e_axis_feedrate * extrusion_multiplier;
 
-    un_retract_filament();
+    un_retract_filament(destination);
 
     //if (ubl.g26_debug_flag) {
     //  SERIAL_ECHOLNPGM("  doing printing move.");
@@ -657,7 +638,7 @@
 
     if (code_seen('B')) {
       bed_temp = code_value_float();
-      if (bed_temp < 15.0 || bed_temp > 140.0) {
+      if (!WITHIN(bed_temp, 15.0, 140.0)) {
         SERIAL_PROTOCOLLNPGM("?Specified bed temperature not plausible.");
         return UBL_ERR;
       }
@@ -667,7 +648,7 @@
 
     if (code_seen('L')) {
       layer_height = code_value_float();
-      if (layer_height < 0.0 || layer_height > 2.0) {
+      if (!WITHIN(layer_height, 0.0, 2.0)) {
         SERIAL_PROTOCOLLNPGM("?Specified layer height not plausible.");
         return UBL_ERR;
       }
@@ -676,7 +657,7 @@
     if (code_seen('Q')) {
       if (code_has_value()) {
         retraction_multiplier = code_value_float();
-        if (retraction_multiplier < 0.05 || retraction_multiplier > 15.0) {
+        if (!WITHIN(retraction_multiplier, 0.05, 15.0)) {
           SERIAL_PROTOCOLLNPGM("?Specified Retraction Multiplier not plausible.");
           return UBL_ERR;
         }
@@ -689,7 +670,7 @@
 
     if (code_seen('N')) {
       nozzle = code_value_float();
-      if (nozzle < 0.1 || nozzle > 1.0) {
+      if (!WITHIN(nozzle, 0.1, 1.0)) {
         SERIAL_PROTOCOLLNPGM("?Specified nozzle size not plausible.");
         return UBL_ERR;
       }
@@ -706,7 +687,7 @@
       else {
         prime_flag++;
         prime_length = code_value_float();
-        if (prime_length < 0.0 || prime_length > 25.0) {
+        if (!WITHIN(prime_length, 0.0, 25.0)) {
           SERIAL_PROTOCOLLNPGM("?Specified prime length not plausible.");
           return UBL_ERR;
         }
@@ -715,7 +696,7 @@
 
     if (code_seen('F')) {
       filament_diameter = code_value_float();
-      if (filament_diameter < 1.0 || filament_diameter > 4.0) {
+      if (!WITHIN(filament_diameter, 1.0, 4.0)) {
         SERIAL_PROTOCOLLNPGM("?Specified filament size not plausible.");
         return UBL_ERR;
       }
@@ -728,7 +709,7 @@
 
     if (code_seen('H')) {
       hotend_temp = code_value_float();
-      if (hotend_temp < 165.0 || hotend_temp > 280.0) {
+      if (!WITHIN(hotend_temp, 165.0, 280.0)) {
         SERIAL_PROTOCOLLNPGM("?Specified nozzle temperature not plausible.");
         return UBL_ERR;
       }
@@ -744,7 +725,7 @@
 
     if (code_seen('X')) {
       x_pos = code_value_float();
-      if (x_pos < X_MIN_POS || x_pos > X_MAX_POS) {
+      if (!WITHIN(x_pos, X_MIN_POS, X_MAX_POS)) {
         SERIAL_PROTOCOLLNPGM("?Specified X coordinate not plausible.");
         return UBL_ERR;
       }
@@ -753,7 +734,7 @@
 
     if (code_seen('Y')) {
       y_pos = code_value_float();
-      if (y_pos < Y_MIN_POS || y_pos > Y_MAX_POS) {
+      if (!WITHIN(y_pos, Y_MIN_POS, Y_MAX_POS)) {
         SERIAL_PROTOCOLLNPGM("?Specified Y coordinate not plausible.");
         return UBL_ERR;
       }
@@ -814,6 +795,7 @@
       lcd_setstatuspgm(PSTR(""));
       lcd_quick_feedback();
     #endif
+
     return UBL_OK;
   }
 
@@ -832,9 +814,8 @@
 
       set_destination_to_current();
 
-      un_retract_filament();    // Lets make sure the G26 command doesn't think the filament is
-                                // retracted().  We are here because we want to prime the nozzle.
-                                // So let's just unretract just to be sure.
+      un_retract_filament(destination); // Make sure G26 doesn't think the filament is retracted().
+
       while (!ubl_lcd_clicked()) {
         chirp_at_user();
         destination[E_AXIS] += 0.25;
@@ -842,10 +823,7 @@
           Total_Prime += 0.25;
           if (Total_Prime >= EXTRUDE_MAXLENGTH) return UBL_ERR;
         #endif
-        ubl_line_to_destination(
-          destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS],
-          planner.max_feedrate_mm_s[E_AXIS] / 15.0, 0
-        );
+        ubl_line_to_destination(planner.max_feedrate_mm_s[E_AXIS] / 15.0, 0);
 
         stepper.synchronize();    // Without this synchronize, the purge is more consistent,
                                   // but because the planner has a buffer, we won't be able
@@ -874,13 +852,10 @@
       #endif
       set_destination_to_current();
       destination[E_AXIS] += prime_length;
-      ubl_line_to_destination(
-        destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS],
-        planner.max_feedrate_mm_s[E_AXIS] / 15.0, 0
-      );
+      ubl_line_to_destination(planner.max_feedrate_mm_s[E_AXIS] / 15.0, 0);
       stepper.synchronize();
       set_destination_to_current();
-      retract_filament();
+      retract_filament(destination);
     }
 
     return UBL_OK;
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 7254d345e87..87169cbe534 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -244,7 +244,6 @@ inline bool IsRunning() { return  Running; }
 inline bool IsStopped() { return !Running; }
 
 bool enqueue_and_echo_command(const char* cmd, bool say_ok=false); //put a single ASCII command at the end of the current buffer or return false when it is full
-void enqueue_and_echo_command_now(const char* cmd); // enqueue now, only return when the command has been enqueued
 void enqueue_and_echo_commands_P(const char* cmd); //put one or many ASCII commands at the end of the current buffer, read from flash
 void clear_command_queue();
 
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index f0ec84f2019..d1ae914ad68 100755
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -896,10 +896,6 @@ bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
   return false;
 }
 
-void enqueue_and_echo_command_now(const char* cmd) {
-  while (!enqueue_and_echo_command(cmd)) idle();
-}
-
 void setup_killpin() {
   #if HAS_KILL
     SET_INPUT_PULLUP(KILL_PIN);
@@ -2237,7 +2233,7 @@ static void clean_up_after_endstop_or_probe_move() {
         SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
       }
     #endif
-    return current_position[Z_AXIS];
+    return current_position[Z_AXIS] + zprobe_zoffset;
   }
 
   //
@@ -2291,7 +2287,7 @@ static void clean_up_after_endstop_or_probe_move() {
       SERIAL_PROTOCOLPGM(" Y: ");
       SERIAL_PROTOCOL_F(y, 3);
       SERIAL_PROTOCOLPGM(" Z: ");
-      SERIAL_PROTOCOL_F(measured_z - -zprobe_zoffset + 0.0001, 3);
+      SERIAL_PROTOCOL_F(FIXFLOAT(measured_z), 3);
       SERIAL_EOL;
     }
 
@@ -2569,7 +2565,7 @@ static void clean_up_after_endstop_or_probe_move() {
           ep = ABL_GRID_MAX_POINTS_X - 1;
           ip = ABL_GRID_MAX_POINTS_X - 2;
         }
-        if (y > 0 && y < ABL_TEMP_POINTS_Y - 1)
+        if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
           return LINEAR_EXTRAPOLATION(
             bed_level_grid[ep][y - 1],
             bed_level_grid[ip][y - 1]
@@ -2585,7 +2581,7 @@ static void clean_up_after_endstop_or_probe_move() {
           ep = ABL_GRID_MAX_POINTS_Y - 1;
           ip = ABL_GRID_MAX_POINTS_Y - 2;
         }
-        if (x > 0 && x < ABL_TEMP_POINTS_X - 1)
+        if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
           return LINEAR_EXTRAPOLATION(
             bed_level_grid[x - 1][ep],
             bed_level_grid[x - 1][ip]
@@ -3028,9 +3024,9 @@ bool position_is_reachable(float target[XYZ]
     return HYPOT2(dx, dy) <= sq((float)(DELTA_PRINTABLE_RADIUS));
   #else
     const float dz = RAW_Z_POSITION(target[Z_AXIS]);
-    return dx >= X_MIN_POS - 0.0001 && dx <= X_MAX_POS + 0.0001
-        && dy >= Y_MIN_POS - 0.0001 && dy <= Y_MAX_POS + 0.0001
-        && dz >= Z_MIN_POS - 0.0001 && dz <= Z_MAX_POS + 0.0001;
+    return WITHIN(dx, X_MIN_POS - 0.0001, X_MAX_POS + 0.0001)
+        && WITHIN(dy, Y_MIN_POS - 0.0001, Y_MAX_POS + 0.0001)
+        && WITHIN(dz, Z_MIN_POS - 0.0001, Z_MAX_POS + 0.0001);
   #endif
 }
 
@@ -3788,13 +3784,13 @@ inline void gcode_G28() {
    */
   inline void gcode_G29() {
 
-    static int probe_index = -1;
+    static int mbl_probe_index = -1;
     #if HAS_SOFTWARE_ENDSTOPS
       static bool enable_soft_endstops;
     #endif
 
     const MeshLevelingState state = code_seen('S') ? (MeshLevelingState)code_value_byte() : MeshReport;
-    if (state < 0 || state > 5) {
+    if (!WITHIN(state, 0, 5)) {
       SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
       return;
     }
@@ -3813,17 +3809,17 @@ inline void gcode_G28() {
 
       case MeshStart:
         mbl.reset();
-        probe_index = 0;
+        mbl_probe_index = 0;
         enqueue_and_echo_commands_P(PSTR("G28\nG29 S2"));
         break;
 
       case MeshNext:
-        if (probe_index < 0) {
+        if (mbl_probe_index < 0) {
           SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
           return;
         }
         // For each G29 S2...
-        if (probe_index == 0) {
+        if (mbl_probe_index == 0) {
           #if HAS_SOFTWARE_ENDSTOPS
             // For the initial G29 S2 save software endstop state
             enable_soft_endstops = soft_endstops_enabled;
@@ -3831,14 +3827,14 @@ inline void gcode_G28() {
         }
         else {
           // For G29 S2 after adjusting Z.
-          mbl.set_zigzag_z(probe_index - 1, current_position[Z_AXIS]);
+          mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
           #if HAS_SOFTWARE_ENDSTOPS
             soft_endstops_enabled = enable_soft_endstops;
           #endif
         }
         // If there's another point to sample, move there with optional lift.
-        if (probe_index < (MESH_NUM_X_POINTS) * (MESH_NUM_Y_POINTS)) {
-          mbl.zigzag(probe_index, px, py);
+        if (mbl_probe_index < (MESH_NUM_X_POINTS) * (MESH_NUM_Y_POINTS)) {
+          mbl.zigzag(mbl_probe_index, px, py);
           _mbl_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
 
           #if HAS_SOFTWARE_ENDSTOPS
@@ -3847,7 +3843,7 @@ inline void gcode_G28() {
             soft_endstops_enabled = false;
           #endif
 
-          probe_index++;
+          mbl_probe_index++;
         }
         else {
           // One last "return to the bed" (as originally coded) at completion
@@ -3857,7 +3853,7 @@ inline void gcode_G28() {
 
           // After recording the last point, activate the mbl and home
           SERIAL_PROTOCOLLNPGM("Mesh probing done.");
-          probe_index = -1;
+          mbl_probe_index = -1;
           mbl.set_has_mesh(true);
           mbl.set_reactivate(true);
           enqueue_and_echo_commands_P(PSTR("G28"));
@@ -3869,7 +3865,7 @@ inline void gcode_G28() {
       case MeshSet:
         if (code_seen('X')) {
           px = code_value_int() - 1;
-          if (px < 0 || px >= MESH_NUM_X_POINTS) {
+          if (!WITHIN(px, 0, MESH_NUM_X_POINTS - 1)) {
             SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(MESH_NUM_X_POINTS) ").");
             return;
           }
@@ -3881,7 +3877,7 @@ inline void gcode_G28() {
 
         if (code_seen('Y')) {
           py = code_value_int() - 1;
-          if (py < 0 || py >= MESH_NUM_Y_POINTS) {
+          if (!WITHIN(py, 0, MESH_NUM_Y_POINTS - 1)) {
             SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(MESH_NUM_Y_POINTS) ").");
             return;
           }
@@ -4412,7 +4408,7 @@ inline void gcode_G28() {
         if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
           && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
         ) {
-          float simple_z = current_position[Z_AXIS] - (measured_z - (-zprobe_zoffset));
+          float simple_z = current_position[Z_AXIS] - measured_z;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Z from Probe:", simple_z);
@@ -4503,11 +4499,11 @@ inline void gcode_G28() {
     float measured_z = probe_pt(X_probe_location, Y_probe_location, stow, 1);
 
     SERIAL_PROTOCOLPGM("Bed X: ");
-    SERIAL_PROTOCOL(X_probe_location + 0.0001);
+    SERIAL_PROTOCOL(FIXFLOAT(X_probe_location));
     SERIAL_PROTOCOLPGM(" Y: ");
-    SERIAL_PROTOCOL(Y_probe_location + 0.0001);
+    SERIAL_PROTOCOL(FIXFLOAT(Y_probe_location));
     SERIAL_PROTOCOLPGM(" Z: ");
-    SERIAL_PROTOCOLLN(measured_z - -zprobe_zoffset + 0.0001);
+    SERIAL_PROTOCOLLN(FIXFLOAT(measured_z));
 
     clean_up_after_endstop_or_probe_move();
 
@@ -4971,7 +4967,7 @@ inline void gcode_M42() {
   if (!code_seen('S')) return;
 
   int pin_status = code_value_int();
-  if (pin_status < 0 || pin_status > 255) return;
+  if (!WITHIN(pin_status, 0, 255)) return;
 
   int pin_number = code_seen('P') ? code_value_int() : LED_PIN;
   if (pin_number < 0) return;
@@ -5115,7 +5111,7 @@ inline void gcode_M42() {
     if (axis_unhomed_error(true, true, true)) return;
 
     int8_t verbose_level = code_seen('V') ? code_value_byte() : 1;
-    if (verbose_level < 0 || verbose_level > 4) {
+    if (!WITHIN(verbose_level, 0, 4)) {
       SERIAL_PROTOCOLLNPGM("?Verbose Level not plausible (0-4).");
       return;
     }
@@ -5124,7 +5120,7 @@ inline void gcode_M42() {
       SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
 
     int8_t n_samples = code_seen('P') ? code_value_byte() : 10;
-    if (n_samples < 4 || n_samples > 50) {
+    if (!WITHIN(n_samples, 4, 50)) {
       SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
       return;
     }
@@ -5136,7 +5132,7 @@ inline void gcode_M42() {
 
     float X_probe_location = code_seen('X') ? code_value_axis_units(X_AXIS) : X_current + X_PROBE_OFFSET_FROM_EXTRUDER;
     #if DISABLED(DELTA)
-      if (X_probe_location < LOGICAL_X_POSITION(MIN_PROBE_X) || X_probe_location > LOGICAL_X_POSITION(MAX_PROBE_X)) {
+      if (!WITHIN(X_probe_location, LOGICAL_X_POSITION(MIN_PROBE_X), LOGICAL_X_POSITION(MAX_PROBE_X))) {
         out_of_range_error(PSTR("X"));
         return;
       }
@@ -5144,7 +5140,7 @@ inline void gcode_M42() {
 
     float Y_probe_location = code_seen('Y') ? code_value_axis_units(Y_AXIS) : Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER;
     #if DISABLED(DELTA)
-      if (Y_probe_location < LOGICAL_Y_POSITION(MIN_PROBE_Y) || Y_probe_location > LOGICAL_Y_POSITION(MAX_PROBE_Y)) {
+      if (!WITHIN(Y_probe_location, LOGICAL_Y_POSITION(MIN_PROBE_Y), LOGICAL_Y_POSITION(MAX_PROBE_Y))) {
         out_of_range_error(PSTR("Y"));
         return;
       }
@@ -6795,7 +6791,7 @@ inline void gcode_M226() {
   inline void gcode_M280() {
     if (!code_seen('P')) return;
     int servo_index = code_value_int();
-    if (servo_index >= 0 && servo_index < NUM_SERVOS) {
+    if (WITHIN(servo_index, 0, NUM_SERVOS - 1)) {
       if (code_seen('S'))
         MOVE_SERVO(servo_index, code_value_int());
       else {
@@ -7002,7 +6998,7 @@ inline void gcode_M303() {
 
     float temp = code_seen('S') ? code_value_temp_abs() : (e < 0 ? 70.0 : 150.0);
 
-    if (e >= 0 && e < HOTENDS)
+    if (WITHIN(e, 0, HOTENDS - 1))
       target_extruder = e;
 
     KEEPALIVE_STATE(NOT_BUSY); // don't send "busy: processing" messages during autotune output
@@ -7223,7 +7219,7 @@ void quickstop_stepper() {
       if (code_seen('L')) {
         const int8_t storage_slot = code_has_value() ? code_value_int() : ubl.state.eeprom_storage_slot;
         const int16_t j = (UBL_LAST_EEPROM_INDEX - ubl.eeprom_start) / sizeof(ubl.z_values);
-        if (storage_slot < 0 || storage_slot >= j || ubl.eeprom_start <= 0) {
+        if (!WITHIN(storage_slot, 0, j - 1) || ubl.eeprom_start <= 0) {
           SERIAL_PROTOCOLLNPGM("?EEPROM storage not available for use.\n");
           return;
         }
@@ -7316,7 +7312,7 @@ void quickstop_stepper() {
       }
     }
     else if (hasI && hasJ && hasZ) {
-      if (px >= 0 && px < MESH_NUM_X_POINTS && py >= 0 && py < MESH_NUM_Y_POINTS)
+      if (WITHIN(px, 0, MESH_NUM_X_POINTS - 1) && WITHIN(py, 0, MESH_NUM_Y_POINTS - 1))
         mbl.set_z(px, py, z);
       else {
         SERIAL_ERROR_START;
@@ -7345,7 +7341,7 @@ void quickstop_stepper() {
     if ((hasZ = code_seen('Z'))) z = code_value_axis_units(Z_AXIS);
 
     if (hasI && hasJ && hasZ) {
-      if (px >= 0 && px < ABL_GRID_MAX_POINTS_X && py >= 0 && py < ABL_GRID_MAX_POINTS_X) {
+      if (WITHIN(px, 0, ABL_GRID_MAX_POINTS_X - 1) && WITHIN(py, 0, ABL_GRID_MAX_POINTS_X - 1)) {
         bed_level_grid[px][py] = z;
         #if ENABLED(ABL_BILINEAR_SUBDIVISION)
           bed_level_virt_interpolate();
@@ -7383,7 +7379,7 @@ void quickstop_stepper() {
       if (axis_homed[i]) {
         float base = (current_position[i] > (soft_endstop_min[i] + soft_endstop_max[i]) * 0.5) ? base_home_pos((AxisEnum)i) : 0,
               diff = current_position[i] - LOGICAL_POSITION(base, i);
-        if (diff > -20 && diff < 20) {
+        if (WITHIN(diff, -20, 20)) {
           set_home_offset((AxisEnum)i, home_offset[i] - diff);
         }
         else {
@@ -7457,7 +7453,7 @@ inline void gcode_M503() {
 
     if (code_seen('Z')) {
       float value = code_value_axis_units(Z_AXIS);
-      if (Z_PROBE_OFFSET_RANGE_MIN <= value && value <= Z_PROBE_OFFSET_RANGE_MAX) {
+      if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
         #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
           // Correct bilinear grid for new probe offset
@@ -9905,11 +9901,7 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
       #elif ENABLED(AUTO_BED_LEVELING_UBL)
         if (ubl.state.active) {
 
-//        ubl_line_to_destination(MMS_SCALED(feedrate_mm_s));
-
-          ubl_line_to_destination(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS],
-//                      (feedrate*(1.0/60.0))*(feedrate_percentage*(1.0/100.0) ), active_extruder);
-                      MMS_SCALED(feedrate_mm_s), active_extruder);
+          ubl_line_to_destination(MMS_SCALED(feedrate_mm_s), active_extruder);
 
           return false;
         }
diff --git a/Marlin/SanityCheck.h b/Marlin/SanityCheck.h
index 21c1d8626bb..aa6ac8124f9 100644
--- a/Marlin/SanityCheck.h
+++ b/Marlin/SanityCheck.h
@@ -540,13 +540,13 @@ static_assert(1 >= 0
  * Make sure Z_SAFE_HOMING point is reachable
  */
 #if ENABLED(Z_SAFE_HOMING)
-  #if Z_SAFE_HOMING_X_POINT < MIN_PROBE_X || Z_SAFE_HOMING_X_POINT > MAX_PROBE_X
+  #if !WITHIN(Z_SAFE_HOMING_X_POINT, MIN_PROBE_X, MAX_PROBE_X)
     #if HAS_BED_PROBE
       #error "Z_SAFE_HOMING_X_POINT can't be reached by the Z probe."
     #else
       #error "Z_SAFE_HOMING_X_POINT can't be reached by the nozzle."
     #endif
-  #elif Z_SAFE_HOMING_Y_POINT < MIN_PROBE_Y || Z_SAFE_HOMING_Y_POINT > MAX_PROBE_Y
+  #elif !WITHIN(Z_SAFE_HOMING_Y_POINT, MIN_PROBE_Y, MAX_PROBE_Y)
     #if HAS_BED_PROBE
       #error "Z_SAFE_HOMING_Y_POINT can't be reached by the Z probe."
     #else
@@ -598,33 +598,33 @@ static_assert(1 >= 0
   #elif ENABLED(AUTO_BED_LEVELING_UBL)
     #if DISABLED(EEPROM_SETTINGS)
       #error "AUTO_BED_LEVELING_UBL requires EEPROM_SETTINGS. Please update your configuration."
-    #elif UBL_MESH_NUM_X_POINTS < 3 || UBL_MESH_NUM_X_POINTS > 15 || UBL_MESH_NUM_Y_POINTS < 3 || UBL_MESH_NUM_Y_POINTS > 15
+    #elif !WITHIN(UBL_MESH_NUM_X_POINTS, 3, 15) || !WITHIN(UBL_MESH_NUM_Y_POINTS, 3, 15)
       #error "UBL_MESH_NUM_[XY]_POINTS must be a whole number between 3 and 15."
-    #elif UBL_PROBE_PT_1_X < MIN_PROBE_X || UBL_PROBE_PT_1_X > MAX_PROBE_X
+    #elif !WITHIN(UBL_PROBE_PT_1_X, MIN_PROBE_X, MAX_PROBE_X)
       #error "The given UBL_PROBE_PT_1_X can't be reached by the Z probe."
-    #elif UBL_PROBE_PT_2_X < MIN_PROBE_X || UBL_PROBE_PT_2_X > MAX_PROBE_X
+    #elif !WITHIN(UBL_PROBE_PT_2_X, MIN_PROBE_X, MAX_PROBE_X)
       #error "The given UBL_PROBE_PT_2_X can't be reached by the Z probe."
-    #elif UBL_PROBE_PT_3_X < MIN_PROBE_X || UBL_PROBE_PT_3_X > MAX_PROBE_X
+    #elif !WITHIN(UBL_PROBE_PT_3_X, MIN_PROBE_X, MAX_PROBE_X)
       #error "The given UBL_PROBE_PT_3_X can't be reached by the Z probe."
-    #elif UBL_PROBE_PT_1_Y < MIN_PROBE_Y || UBL_PROBE_PT_1_Y > MAX_PROBE_Y
+    #elif !WITHIN(UBL_PROBE_PT_1_Y, MIN_PROBE_Y, MAX_PROBE_Y)
       #error "The given UBL_PROBE_PT_1_Y can't be reached by the Z probe."
-    #elif UBL_PROBE_PT_2_Y < MIN_PROBE_Y || UBL_PROBE_PT_2_Y > MAX_PROBE_Y
+    #elif !WITHIN(UBL_PROBE_PT_2_Y, MIN_PROBE_Y, MAX_PROBE_Y)
       #error "The given UBL_PROBE_PT_2_Y can't be reached by the Z probe."
-    #elif UBL_PROBE_PT_3_Y < MIN_PROBE_Y || UBL_PROBE_PT_3_Y > MAX_PROBE_Y
+    #elif !WITHIN(UBL_PROBE_PT_3_Y, MIN_PROBE_Y, MAX_PROBE_Y)
       #error "The given UBL_PROBE_PT_3_Y can't be reached by the Z probe."
     #endif
   #else // AUTO_BED_LEVELING_3POINT
-    #if ABL_PROBE_PT_1_X < MIN_PROBE_X || ABL_PROBE_PT_1_X > MAX_PROBE_X
+    #if !WITHIN(ABL_PROBE_PT_1_X, MIN_PROBE_X, MAX_PROBE_X)
       #error "The given ABL_PROBE_PT_1_X can't be reached by the Z probe."
-    #elif ABL_PROBE_PT_2_X < MIN_PROBE_X || ABL_PROBE_PT_2_X > MAX_PROBE_X
+    #elif !WITHIN(ABL_PROBE_PT_2_X, MIN_PROBE_X, MAX_PROBE_X)
       #error "The given ABL_PROBE_PT_2_X can't be reached by the Z probe."
-    #elif ABL_PROBE_PT_3_X < MIN_PROBE_X || ABL_PROBE_PT_3_X > MAX_PROBE_X
+    #elif !WITHIN(ABL_PROBE_PT_3_X, MIN_PROBE_X, MAX_PROBE_X)
       #error "The given ABL_PROBE_PT_3_X can't be reached by the Z probe."
-    #elif ABL_PROBE_PT_1_Y < MIN_PROBE_Y || ABL_PROBE_PT_1_Y > MAX_PROBE_Y
+    #elif !WITHIN(ABL_PROBE_PT_1_Y, MIN_PROBE_Y, MAX_PROBE_Y)
       #error "The given ABL_PROBE_PT_1_Y can't be reached by the Z probe."
-    #elif ABL_PROBE_PT_2_Y < MIN_PROBE_Y || ABL_PROBE_PT_2_Y > MAX_PROBE_Y
+    #elif !WITHIN(ABL_PROBE_PT_2_Y, MIN_PROBE_Y, MAX_PROBE_Y)
       #error "The given ABL_PROBE_PT_2_Y can't be reached by the Z probe."
-    #elif ABL_PROBE_PT_3_Y < MIN_PROBE_Y || ABL_PROBE_PT_3_Y > MAX_PROBE_Y
+    #elif !WITHIN(ABL_PROBE_PT_3_Y, MIN_PROBE_Y, MAX_PROBE_Y)
       #error "The given ABL_PROBE_PT_3_Y can't be reached by the Z probe."
     #endif
   #endif // AUTO_BED_LEVELING_3POINT
@@ -862,11 +862,11 @@ static_assert(1 >= 0
 /**
  * Endstops
  */
-#if DISABLED(USE_XMIN_PLUG) && DISABLED(USE_XMAX_PLUG) && !(ENABLED(Z_DUAL_ENDSTOPS) && Z2_USE_ENDSTOP >= _XMAX_ && Z2_USE_ENDSTOP <= _XMIN_)
+#if DISABLED(USE_XMIN_PLUG) && DISABLED(USE_XMAX_PLUG) && !(ENABLED(Z_DUAL_ENDSTOPS) && WITHIN(Z2_USE_ENDSTOP, _XMAX_, _XMIN_))
  #error "You must enable USE_XMIN_PLUG or USE_XMAX_PLUG."
-#elif DISABLED(USE_YMIN_PLUG) && DISABLED(USE_YMAX_PLUG) && !(ENABLED(Z_DUAL_ENDSTOPS) && Z2_USE_ENDSTOP >= _YMAX_ && Z2_USE_ENDSTOP <= _YMIN_)
+#elif DISABLED(USE_YMIN_PLUG) && DISABLED(USE_YMAX_PLUG) && !(ENABLED(Z_DUAL_ENDSTOPS) && WITHIN(Z2_USE_ENDSTOP, _YMAX_, _YMIN_))
  #error "You must enable USE_YMIN_PLUG or USE_YMAX_PLUG."
-#elif DISABLED(USE_ZMIN_PLUG) && DISABLED(USE_ZMAX_PLUG) && !(ENABLED(Z_DUAL_ENDSTOPS) && Z2_USE_ENDSTOP >= _ZMAX_ && Z2_USE_ENDSTOP <= _ZMIN_)
+#elif DISABLED(USE_ZMIN_PLUG) && DISABLED(USE_ZMAX_PLUG) && !(ENABLED(Z_DUAL_ENDSTOPS) && WITHIN(Z2_USE_ENDSTOP, _ZMAX_, _ZMIN_))
  #error "You must enable USE_ZMIN_PLUG or USE_ZMAX_PLUG."
 #elif ENABLED(Z_DUAL_ENDSTOPS)
   #if !Z2_USE_ENDSTOP
diff --git a/Marlin/UBL.h b/Marlin/UBL.h
index 1d3a91b30da..ea726b45728 100644
--- a/Marlin/UBL.h
+++ b/Marlin/UBL.h
@@ -43,7 +43,7 @@
     bool ubl_lcd_clicked();
     void probe_entire_mesh(const float&, const float&, const bool, const bool, const bool);
     void debug_current_and_destination(char *title);
-    void ubl_line_to_destination(const float&, const float&, const float&, const float&, const float&, uint8_t);
+    void ubl_line_to_destination(const float&, uint8_t);
     void manually_probe_remaining_mesh(const float&, const float&, const float&, const float&, const bool);
     vector_3 tilt_mesh_based_on_3pts(const float&, const float&, const float&);
     float measure_business_card_thickness(const float&);
@@ -169,12 +169,12 @@
 
         static int8_t find_closest_x_index(const float &x) {
           const int8_t px = (x - (UBL_MESH_MIN_X) + (MESH_X_DIST) * 0.5) * (1.0 / (MESH_X_DIST));
-          return (px >= 0 && px < (UBL_MESH_NUM_X_POINTS)) ? px : -1;
+          return WITHIN(px, 0, UBL_MESH_NUM_X_POINTS - 1) ? px : -1;
         }
 
         static int8_t find_closest_y_index(const float &y) {
           const int8_t py = (y - (UBL_MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * (1.0 / (MESH_Y_DIST));
-          return (py >= 0 && py < (UBL_MESH_NUM_Y_POINTS)) ? py : -1;
+          return WITHIN(py, 0, UBL_MESH_NUM_Y_POINTS - 1) ? py : -1;
         }
 
         /**
@@ -193,22 +193,16 @@
          *  multiplications.
          */
         static FORCE_INLINE float calc_z0(const float &a0, const float &a1, const float &z1, const float &a2, const float &z2) {
-          const float delta_z = (z2 - z1),
-                      delta_a = (a0 - a1) / (a2 - a1);
-          return z1 + delta_a * delta_z;
+          return z1 + (z2 - z1) * (a0 - a1) / (a2 - a1);
         }
 
         /**
-         * get_z_correction_at_Y_intercept(float x0, int x1_i, int yi) only takes
-         * three parameters. It assumes the x0 point is on a Mesh line denoted by yi. In theory
-         * we could use get_cell_index_x(float x) to obtain the 2nd parameter x1_i but any code calling
-         * the get_z_correction_along_vertical_mesh_line_at_specific_X routine  will already have
-         * the X index of the x0 intersection available and we don't want to perform any extra floating
-         * point operations.
+         * z_correction_for_x_on_horizontal_mesh_line is an optimization for
+         * the rare occasion when a point lies exactly on a Mesh line (denoted by index yi).
          */
-        static inline float get_z_correction_along_horizontal_mesh_line_at_specific_X(const float &x0, const int x1_i, const int yi) {
-          if (x1_i < 0 || yi < 0 || x1_i >= UBL_MESH_NUM_X_POINTS || yi >= UBL_MESH_NUM_Y_POINTS) {
-            SERIAL_ECHOPAIR("? in get_z_correction_along_horizontal_mesh_line_at_specific_X(x0=", x0);
+        static inline float z_correction_for_x_on_horizontal_mesh_line(const float &lx0, const int x1_i, const int yi) {
+          if (!WITHIN(x1_i, 0, UBL_MESH_NUM_X_POINTS - 1) || !WITHIN(yi, 0, UBL_MESH_NUM_Y_POINTS - 1)) {
+            SERIAL_ECHOPAIR("? in z_correction_for_x_on_horizontal_mesh_line(lx0=", lx0);
             SERIAL_ECHOPAIR(",x1_i=", x1_i);
             SERIAL_ECHOPAIR(",yi=", yi);
             SERIAL_CHAR(')');
@@ -216,20 +210,18 @@
             return NAN;
           }
 
-          const float xratio = (RAW_X_POSITION(x0) - mesh_index_to_xpos[x1_i]) * (1.0 / (MESH_X_DIST)),
-                      z1 = z_values[x1_i][yi],
-                      z2 = z_values[x1_i + 1][yi],
-                      dz = (z2 - z1);
+          const float xratio = (RAW_X_POSITION(lx0) - mesh_index_to_xpos[x1_i]) * (1.0 / (MESH_X_DIST)),
+                      z1 = z_values[x1_i][yi];
 
-          return z1 + xratio * dz;
+          return z1 + xratio * (z_values[x1_i + 1][yi] - z1);
         }
 
         //
-        // See comments above for get_z_correction_along_horizontal_mesh_line_at_specific_X
+        // See comments above for z_correction_for_x_on_horizontal_mesh_line
         //
-        static inline float get_z_correction_along_vertical_mesh_line_at_specific_Y(const float &y0, const int xi, const int y1_i) {
-          if (xi < 0 || y1_i < 0 || xi >= UBL_MESH_NUM_X_POINTS || y1_i >= UBL_MESH_NUM_Y_POINTS) {
-            SERIAL_ECHOPAIR("? in get_z_correction_along_vertical_mesh_line_at_specific_X(y0=", y0);
+        static inline float z_correction_for_y_on_vertical_mesh_line(const float &ly0, const int xi, const int y1_i) {
+          if (!WITHIN(xi, 0, UBL_MESH_NUM_X_POINTS - 1) || !WITHIN(y1_i, 0, UBL_MESH_NUM_Y_POINTS - 1)) {
+            SERIAL_ECHOPAIR("? in get_z_correction_along_vertical_mesh_line_at_specific_x(ly0=", ly0);
             SERIAL_ECHOPAIR(", x1_i=", xi);
             SERIAL_ECHOPAIR(", yi=", y1_i);
             SERIAL_CHAR(')');
@@ -237,12 +229,10 @@
             return NAN;
           }
 
-          const float yratio = (RAW_Y_POSITION(y0) - mesh_index_to_ypos[y1_i]) * (1.0 / (MESH_Y_DIST)),
-                      z1 = z_values[xi][y1_i],
-                      z2 = z_values[xi][y1_i + 1],
-                      dz = (z2 - z1);
+          const float yratio = (RAW_Y_POSITION(ly0) - mesh_index_to_ypos[y1_i]) * (1.0 / (MESH_Y_DIST)),
+                      z1 = z_values[xi][y1_i];
 
-          return z1 + yratio * dz;
+          return z1 + yratio * (z_values[xi][y1_i + 1] - z1);
         }
 
         /**
@@ -251,14 +241,14 @@
          * Z-Height at both ends. Then it does a linear interpolation of these heights based
          * on the Y position within the cell.
          */
-        static float get_z_correction(const float &x0, const float &y0) {
-          const int8_t cx = get_cell_index_x(RAW_X_POSITION(x0)),
-                       cy = get_cell_index_y(RAW_Y_POSITION(y0));
+        static float get_z_correction(const float &lx0, const float &ly0) {
+          const int8_t cx = get_cell_index_x(RAW_X_POSITION(lx0)),
+                       cy = get_cell_index_y(RAW_Y_POSITION(ly0));
 
-          if (cx < 0 || cy < 0 || cx >= UBL_MESH_NUM_X_POINTS || cy >= UBL_MESH_NUM_Y_POINTS) {
+          if (!WITHIN(cx, 0, UBL_MESH_NUM_X_POINTS - 1) || !WITHIN(cy, 0, UBL_MESH_NUM_Y_POINTS - 1)) {
 
-            SERIAL_ECHOPAIR("? in get_z_correction(x0=", x0);
-            SERIAL_ECHOPAIR(", y0=", y0);
+            SERIAL_ECHOPAIR("? in get_z_correction(lx0=", lx0);
+            SERIAL_ECHOPAIR(", ly0=", ly0);
             SERIAL_CHAR(')');
             SERIAL_EOL;
 
@@ -269,21 +259,21 @@
             return 0.0; // this used to return state.z_offset
           }
 
-          const float z1 = calc_z0(RAW_X_POSITION(x0),
+          const float z1 = calc_z0(RAW_X_POSITION(lx0),
                         mesh_index_to_xpos[cx], z_values[cx][cy],
                         mesh_index_to_xpos[cx + 1], z_values[cx + 1][cy]),
-                      z2 = calc_z0(RAW_X_POSITION(x0),
+                      z2 = calc_z0(RAW_X_POSITION(lx0),
                         mesh_index_to_xpos[cx], z_values[cx][cy + 1],
                         mesh_index_to_xpos[cx + 1], z_values[cx + 1][cy + 1]);
-                float z0 = calc_z0(RAW_Y_POSITION(y0),
+                float z0 = calc_z0(RAW_Y_POSITION(ly0),
                     mesh_index_to_ypos[cy], z1,
                     mesh_index_to_ypos[cy + 1], z2);
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(MESH_ADJUST)) {
-              SERIAL_ECHOPAIR(" raw get_z_correction(", x0);
+              SERIAL_ECHOPAIR(" raw get_z_correction(", lx0);
               SERIAL_CHAR(',')
-              SERIAL_ECHO(y0);
+              SERIAL_ECHO(ly0);
               SERIAL_ECHOPGM(") = ");
               SERIAL_ECHO_F(z0, 6);
             }
@@ -305,9 +295,9 @@
 
             #if ENABLED(DEBUG_LEVELING_FEATURE)
               if (DEBUGGING(MESH_ADJUST)) {
-                SERIAL_ECHOPAIR("??? Yikes!  NAN in get_z_correction(", x0);
+                SERIAL_ECHOPAIR("??? Yikes!  NAN in get_z_correction(", lx0);
                 SERIAL_CHAR(',');
-                SERIAL_ECHO(y0);
+                SERIAL_ECHO(ly0);
                 SERIAL_CHAR(')');
                 SERIAL_EOL;
               }
@@ -327,7 +317,7 @@
          */
         #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
 
-          FORCE_INLINE float fade_scaling_factor_for_z(const float &lz) {
+          static FORCE_INLINE float fade_scaling_factor_for_z(const float &lz) {
             const float rz = RAW_Z_POSITION(lz);
             if (last_specified_z != rz) {
               last_specified_z = rz;
diff --git a/Marlin/UBL_Bed_Leveling.cpp b/Marlin/UBL_Bed_Leveling.cpp
index a81a16bc098..e173247fe11 100644
--- a/Marlin/UBL_Bed_Leveling.cpp
+++ b/Marlin/UBL_Bed_Leveling.cpp
@@ -118,7 +118,7 @@
       return;
     }
 
-    if (m < 0 || m >= j || eeprom_start <= 0) {
+    if (!WITHIN(m, 0, j - 1) || eeprom_start <= 0) {
       SERIAL_PROTOCOLLNPGM("?EEPROM storage not available to load mesh.\n");
       return;
     }
@@ -133,7 +133,7 @@
   void unified_bed_leveling::store_mesh(const int16_t m) {
     int16_t j = (UBL_LAST_EEPROM_INDEX - eeprom_start) / sizeof(z_values);
 
-    if (m < 0 || m >= j || eeprom_start <= 0) {
+    if (!WITHIN(m, 0, j - 1) || eeprom_start <= 0) {
       SERIAL_PROTOCOLLNPGM("?EEPROM storage not available to load mesh.\n");
       SERIAL_PROTOCOL(m);
       SERIAL_PROTOCOLLNPGM(" mesh slots available.\n");
@@ -203,7 +203,7 @@
 
         const float f = z_values[i][j];
         if (isnan(f)) {
-          serialprintPGM(map0 ? PSTR("    .    ") : PSTR("NAN"));
+          serialprintPGM(map0 ? PSTR("   .  ") : PSTR("NAN"));
         }
         else {
           // if we don't do this, the columns won't line up nicely
diff --git a/Marlin/UBL_G29.cpp b/Marlin/UBL_G29.cpp
index e1835e74cbd..faf1790e463 100644
--- a/Marlin/UBL_G29.cpp
+++ b/Marlin/UBL_G29.cpp
@@ -49,7 +49,6 @@
   extern bool code_value_bool();
   extern bool code_has_value();
   extern float probe_pt(float x, float y, bool, int);
-  extern float zprobe_zoffset;
   extern bool set_probe_deployed(bool);
   #define DEPLOY_PROBE() set_probe_deployed(true)
   #define STOW_PROBE() set_probe_deployed(false)
@@ -342,7 +341,7 @@
     if (code_seen('Q')) {
 
       const int test_pattern = code_has_value() ? code_value_int() : -1;
-      if (test_pattern < 0 || test_pattern > 2) {
+      if (!WITHIN(test_pattern, 0, 2)) {
         SERIAL_PROTOCOLLNPGM("Invalid test_pattern value. (0-2)\n");
         return;
       }
@@ -375,7 +374,7 @@
     /*
     if (code_seen('U')) {
       unlevel_value = code_value_int();
-      //if (unlevel_value < 0 || unlevel_value > 7) {
+      //if (!WITHIN(unlevel_value, 0, 7)) {
       //  SERIAL_PROTOCOLLNPGM("Invalid Unlevel value. (0-4)\n");
       //  return;
       //}
@@ -384,7 +383,7 @@
 
     if (code_seen('P')) {
       phase_value = code_value_int();
-      if (phase_value < 0 || phase_value > 7) {
+      if (!WITHIN(phase_value, 0, 7)) {
         SERIAL_PROTOCOLLNPGM("Invalid Phase value. (0-4)\n");
         return;
       }
@@ -516,16 +515,23 @@
     }
 
     if (code_seen('T')) {
-      float z1 = probe_pt(ubl_3_point_1_X, ubl_3_point_1_Y, false /*Stow Flag*/, g29_verbose_level) + zprobe_zoffset,
-            z2 = probe_pt(ubl_3_point_2_X, ubl_3_point_2_Y, false /*Stow Flag*/, g29_verbose_level) + zprobe_zoffset,
-            z3 = probe_pt(ubl_3_point_3_X, ubl_3_point_3_Y, true  /*Stow Flag*/, g29_verbose_level) + zprobe_zoffset;
+      const float lx1 = LOGICAL_X_POSITION(ubl_3_point_1_X),
+                  lx2 = LOGICAL_X_POSITION(ubl_3_point_2_X),
+                  lx3 = LOGICAL_X_POSITION(ubl_3_point_3_X),
+                  ly1 = LOGICAL_Y_POSITION(ubl_3_point_1_Y),
+                  ly2 = LOGICAL_Y_POSITION(ubl_3_point_2_Y),
+                  ly3 = LOGICAL_Y_POSITION(ubl_3_point_3_Y);
+
+      float z1 = probe_pt(lx1, ly1, false /*Stow Flag*/, g29_verbose_level),
+            z2 = probe_pt(lx2, ly2, false /*Stow Flag*/, g29_verbose_level),
+            z3 = probe_pt(lx3, ly3, true  /*Stow Flag*/, g29_verbose_level);
 
       //  We need to adjust z1, z2, z3 by the Mesh Height at these points. Just because they are non-zero doesn't mean
       //  the Mesh is tilted!  (We need to compensate each probe point by what the Mesh says that location's height is)
 
-      z1 -= ubl.get_z_correction(ubl_3_point_1_X, ubl_3_point_1_Y);
-      z2 -= ubl.get_z_correction(ubl_3_point_2_X, ubl_3_point_2_Y);
-      z3 -= ubl.get_z_correction(ubl_3_point_3_X, ubl_3_point_3_Y);
+      z1 -= ubl.get_z_correction(lx1, ly1);
+      z2 -= ubl.get_z_correction(lx2, ly2);
+      z3 -= ubl.get_z_correction(lx3, ly3);
 
       do_blocking_move_to_xy((X_MAX_POS - (X_MIN_POS)) / 2.0, (Y_MAX_POS - (Y_MIN_POS)) / 2.0);
       tilt_mesh_based_on_3pts(z1, z2, z3);
@@ -560,7 +566,7 @@
 
       const int16_t j = (UBL_LAST_EEPROM_INDEX - ubl.eeprom_start) / sizeof(ubl.z_values);
 
-      if (storage_slot < 0 || storage_slot >= j || ubl.eeprom_start <= 0) {
+      if (!WITHIN(storage_slot, 0, j - 1) || ubl.eeprom_start <= 0) {
         SERIAL_PROTOCOLLNPGM("?EEPROM storage not available for use.\n");
         return;
       }
@@ -594,7 +600,7 @@
 
       const int16_t j = (UBL_LAST_EEPROM_INDEX - ubl.eeprom_start) / sizeof(ubl.z_values);
 
-      if (storage_slot < 0 || storage_slot >= j || ubl.eeprom_start <= 0) {
+      if (!WITHIN(storage_slot, 0, j - 1) || ubl.eeprom_start <= 0) {
         SERIAL_PROTOCOLLNPGM("?EEPROM storage not available for use.\n");
         SERIAL_PROTOCOLLNPAIR("?Use 0 to ", j - 1);
         goto LEAVE;
@@ -754,14 +760,14 @@
                     rawy = ubl.mesh_index_to_ypos[location.y_index];
 
         // TODO: Change to use `position_is_reachable` (for SCARA-compatibility)
-        if (rawx < (MIN_PROBE_X) || rawx > (MAX_PROBE_X) || rawy < (MIN_PROBE_Y) || rawy > (MAX_PROBE_Y)) {
+        if (!WITHIN(rawx, MIN_PROBE_X, MAX_PROBE_X) || !WITHIN(rawy, MIN_PROBE_Y, MAX_PROBE_Y)) {
           SERIAL_ERROR_START;
           SERIAL_ERRORLNPGM("Attempt to probe off the bed.");
           ubl.has_control_of_lcd_panel = false;
           goto LEAVE;
         }
         const float measured_z = probe_pt(LOGICAL_X_POSITION(rawx), LOGICAL_Y_POSITION(rawy), stow_probe, g29_verbose_level);
-        ubl.z_values[location.x_index][location.y_index] = measured_z + zprobe_zoffset;
+        ubl.z_values[location.x_index][location.y_index] = measured_z;
       }
 
       if (do_ubl_mesh_map) ubl.display_map(map_type);
@@ -779,17 +785,17 @@
     );
   }
 
-  vector_3 tilt_mesh_based_on_3pts(const float &pt1, const float &pt2, const float &pt3) {
+  vector_3 tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3) {
     float c, d, t;
     int i, j;
 
     vector_3 v1 = vector_3( (ubl_3_point_1_X - ubl_3_point_2_X),
                             (ubl_3_point_1_Y - ubl_3_point_2_Y),
-                            (pt1 - pt2) ),
+                            (z1 - z2) ),
 
              v2 = vector_3( (ubl_3_point_3_X - ubl_3_point_2_X),
                             (ubl_3_point_3_Y - ubl_3_point_2_Y),
-                            (pt3 - pt2) ),
+                            (z3 - z2) ),
 
              normal = vector_3::cross(v1, v2);
 
@@ -811,7 +817,7 @@
     // All of 3 of these points should give us the same d constant
     //
     t = normal.x * ubl_3_point_1_X + normal.y * ubl_3_point_1_Y;
-    d = t + normal.z * pt1;
+    d = t + normal.z * z1;
     c = d - t;
     SERIAL_ECHOPGM("d from 1st point: ");
     SERIAL_ECHO_F(d, 6);
@@ -819,7 +825,7 @@
     SERIAL_ECHO_F(c, 6);
     SERIAL_EOL;
     t = normal.x * ubl_3_point_2_X + normal.y * ubl_3_point_2_Y;
-    d = t + normal.z * pt2;
+    d = t + normal.z * z2;
     c = d - t;
     SERIAL_ECHOPGM("d from 2nd point: ");
     SERIAL_ECHO_F(d, 6);
@@ -827,7 +833,7 @@
     SERIAL_ECHO_F(c, 6);
     SERIAL_EOL;
     t = normal.x * ubl_3_point_3_X + normal.y * ubl_3_point_3_Y;
-    d = t + normal.z * pt3;
+    d = t + normal.z * z3;
     c = d - t;
     SERIAL_ECHOPGM("d from 3rd point: ");
     SERIAL_ECHO_F(d, 6);
@@ -904,7 +910,7 @@
                   rawy = ubl.mesh_index_to_ypos[location.y_index];
 
       // TODO: Change to use `position_is_reachable` (for SCARA-compatibility)
-      if (rawx < (X_MIN_POS) || rawx > (X_MAX_POS) || rawy < (Y_MIN_POS) || rawy > (Y_MAX_POS)) {
+      if (!WITHIN(rawx, X_MIN_POS, X_MAX_POS) || !WITHIN(rawy, Y_MIN_POS, Y_MAX_POS)) {
         SERIAL_ERROR_START;
         SERIAL_ERRORLNPGM("Attempt to probe off the bed.");
         ubl.has_control_of_lcd_panel = false;
@@ -976,21 +982,21 @@
     #endif
 
     g29_verbose_level = code_seen('V') ? code_value_int() : 0;
-    if (g29_verbose_level < 0 || g29_verbose_level > 4) {
+    if (!WITHIN(g29_verbose_level, 0, 4)) {
       SERIAL_PROTOCOLLNPGM("Invalid Verbose Level specified. (0-4)\n");
       return UBL_ERR;
     }
 
     x_flag = code_seen('X') && code_has_value();
     x_pos = x_flag ? code_value_float() : current_position[X_AXIS];
-    if (x_pos < LOGICAL_X_POSITION(X_MIN_POS) || x_pos > LOGICAL_X_POSITION(X_MAX_POS)) {
+    if (!WITHIN(RAW_X_POSITION(x_pos), X_MIN_POS, X_MAX_POS)) {
       SERIAL_PROTOCOLLNPGM("Invalid X location specified.\n");
       return UBL_ERR;
     }
 
     y_flag = code_seen('Y') && code_has_value();
     y_pos = y_flag ? code_value_float() : current_position[Y_AXIS];
-    if (y_pos < LOGICAL_Y_POSITION(Y_MIN_POS) || y_pos > LOGICAL_Y_POSITION(Y_MAX_POS)) {
+    if (!WITHIN(RAW_Y_POSITION(y_pos), Y_MIN_POS, Y_MAX_POS)) {
       SERIAL_PROTOCOLLNPGM("Invalid Y location specified.\n");
       return UBL_ERR;
     }
@@ -1018,7 +1024,7 @@
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       if (code_seen('F') && code_has_value()) {
         const float fh = code_value_float();
-        if (fh < 0.0 || fh > 100.0) {
+        if (!WITHIN(fh, 0.0, 100.0)) {
           SERIAL_PROTOCOLLNPGM("?Bed Level Correction Fade Height Not Plausible.\n");
           return UBL_ERR;
         }
@@ -1035,7 +1041,7 @@
     }
 
     map_type = code_seen('O') && code_has_value() ? code_value_int() : 0;
-    if (map_type < 0 || map_type > 1) {
+    if (!WITHIN(map_type, 0, 1)) {
       SERIAL_PROTOCOLLNPGM("Invalid map type.\n");
       return UBL_ERR;
     }
@@ -1043,7 +1049,7 @@
     /*
     if (code_seen('M')) {     // Check if a map type was specified
       map_type = code_has_value() ? code_value_int() : 0; 
-      if (map_type < 0 || map_type > 1) {
+      if (!WITHIN(map_type, 0, 1)) {
         SERIAL_PROTOCOLLNPGM("Invalid map type.\n");
         return UBL_ERR;
       }
@@ -1109,7 +1115,7 @@
     const uint16_t k = E2END - ubl.eeprom_start;
 
     SERIAL_PROTOCOLPGM("Unified Bed Leveling System Version 1.00 ");
-    if (ubl.state.active)  
+    if (ubl.state.active)
       SERIAL_PROTOCOLCHAR('A');
     else
       SERIAL_PROTOCOLPGM("In");
@@ -1243,7 +1249,7 @@
 
     int16_t j = (UBL_LAST_EEPROM_INDEX - ubl.eeprom_start) / sizeof(tmp_z_values);
 
-    if (storage_slot < 0 || storage_slot > j || ubl.eeprom_start <= 0) {
+    if (!WITHIN(storage_slot, 0, j - 1) || ubl.eeprom_start <= 0) {
       SERIAL_PROTOCOLLNPGM("?EEPROM storage not available for use.\n");
       return;
     }
@@ -1290,7 +1296,7 @@
           // Prune them from the list and ignore them till the next Phase (manual nozzle probing).
 
           if (probe_as_reference &&
-            (rawx < (MIN_PROBE_X) || rawx > (MAX_PROBE_X) || rawy < (MIN_PROBE_Y) || rawy > (MAX_PROBE_Y))
+            (!WITHIN(rawx, MIN_PROBE_X, MAX_PROBE_X) || !WITHIN(rawy, MIN_PROBE_Y, MAX_PROBE_Y))
           ) continue;
 
           // Unreachable. Check if it's the closest location to the nozzle.
@@ -1354,7 +1360,7 @@
                   rawy = ubl.mesh_index_to_ypos[location.y_index];
 
       // TODO: Change to use `position_is_reachable` (for SCARA-compatibility)
-      if (rawx < (X_MIN_POS) || rawx > (X_MAX_POS) || rawy < (Y_MIN_POS) || rawy > (Y_MAX_POS)) { // In theory, we don't need this check.
+      if (!WITHIN(rawx, X_MIN_POS, X_MAX_POS) || !WITHIN(rawy, Y_MIN_POS, Y_MAX_POS)) { // In theory, we don't need this check.
         SERIAL_ERROR_START;
         SERIAL_ERRORLNPGM("Attempt to edit off the bed."); // This really can't happen, but do the check for now
         ubl.has_control_of_lcd_panel = false;
@@ -1363,6 +1369,7 @@
 
       do_blocking_move_to_z(Z_CLEARANCE_DEPLOY_PROBE);    // Move the nozzle to where we are going to edit
       do_blocking_move_to_xy(LOGICAL_X_POSITION(rawx), LOGICAL_Y_POSITION(rawy));
+
       float new_z = ubl.z_values[location.x_index][location.y_index];
       
       round_off = (int32_t)(new_z * 1000.0);    // we chop off the last digits just to be clean. We are rounding to the
@@ -1425,4 +1432,4 @@
     SERIAL_ECHOLNPGM("Done Editing Mesh.");
   }
 
-#endif // AUTO_BED_LEVELING_UBL
+#endif // AUTO_BED_LEVELING_UBL
\ No newline at end of file
diff --git a/Marlin/UBL_line_to_destination.cpp b/Marlin/UBL_line_to_destination.cpp
index 7c5e9f4b89c..e110a4288e7 100644
--- a/Marlin/UBL_line_to_destination.cpp
+++ b/Marlin/UBL_line_to_destination.cpp
@@ -31,7 +31,14 @@
 
   extern float destination[XYZE];
   extern void set_current_to_destination();
-  extern float destination[];
+
+  static void debug_echo_axis(const AxisEnum axis) {
+    if (current_position[axis] == destination[axis])
+      SERIAL_ECHOPGM("-------------");
+    else
+      SERIAL_ECHO_F(destination[X_AXIS], 6);
+  }
+
   void debug_current_and_destination(char *title) {
 
     // if the title message starts with a '!' it is so important, we are going to
@@ -67,32 +74,13 @@
     SERIAL_ECHOPGM(", ");
     SERIAL_ECHO_F(current_position[E_AXIS], 6);
     SERIAL_ECHOPGM(" )   destination=( ");
-    if (current_position[X_AXIS] == destination[X_AXIS])
-      SERIAL_ECHOPGM("-------------");
-    else
-      SERIAL_ECHO_F(destination[X_AXIS], 6);
-
+    debug_echo_axis(X_AXIS);
     SERIAL_ECHOPGM(", ");
-
-    if (current_position[Y_AXIS] == destination[Y_AXIS])
-      SERIAL_ECHOPGM("-------------");
-    else
-      SERIAL_ECHO_F(destination[Y_AXIS], 6);
-
+    debug_echo_axis(Y_AXIS);
     SERIAL_ECHOPGM(", ");
-
-    if (current_position[Z_AXIS] == destination[Z_AXIS])
-      SERIAL_ECHOPGM("-------------");
-    else
-      SERIAL_ECHO_F(destination[Z_AXIS], 6);
-
+    debug_echo_axis(Z_AXIS);
     SERIAL_ECHOPGM(", ");
-
-    if (current_position[E_AXIS] == destination[E_AXIS])
-      SERIAL_ECHOPGM("-------------");
-    else
-      SERIAL_ECHO_F(destination[E_AXIS], 6);
-
+    debug_echo_axis(E_AXIS);
     SERIAL_ECHOPGM(" )   ");
     SERIAL_ECHO(title);
     SERIAL_EOL;
@@ -105,32 +93,37 @@
     //}
   }
 
-  void ubl_line_to_destination(const float &x_end, const float &y_end, const float &z_end, const float &e_end, const float &feed_rate, uint8_t extruder) {
+  void ubl_line_to_destination(const float &feed_rate, uint8_t extruder) {
     /**
      * Much of the nozzle movement will be within the same cell. So we will do as little computation
      * as possible to determine if this is the case. If this move is within the same cell, we will
      * just do the required Z-Height correction, call the Planner's buffer_line() routine, and leave
      */
-    const float x_start = current_position[X_AXIS],
-                y_start = current_position[Y_AXIS],
-                z_start = current_position[Z_AXIS],
-                e_start = current_position[E_AXIS];
-
-    const int cell_start_xi = ubl.get_cell_index_x(RAW_X_POSITION(x_start)),
-              cell_start_yi = ubl.get_cell_index_y(RAW_Y_POSITION(y_start)),
-              cell_dest_xi  = ubl.get_cell_index_x(RAW_X_POSITION(x_end)),
-              cell_dest_yi  = ubl.get_cell_index_y(RAW_Y_POSITION(y_end));
+    const float start[XYZE] = {
+                  current_position[X_AXIS],
+                  current_position[Y_AXIS],
+                  current_position[Z_AXIS],
+                  current_position[E_AXIS]
+                },
+                end[XYZE] = {
+                  destination[X_AXIS],
+                  destination[Y_AXIS],
+                  destination[Z_AXIS],
+                  destination[E_AXIS]
+                };
+
+    const int cell_start_xi = ubl.get_cell_index_x(RAW_X_POSITION(start[X_AXIS])),
+              cell_start_yi = ubl.get_cell_index_y(RAW_Y_POSITION(start[Y_AXIS])),
+              cell_dest_xi  = ubl.get_cell_index_x(RAW_X_POSITION(end[X_AXIS])),
+              cell_dest_yi  = ubl.get_cell_index_y(RAW_Y_POSITION(end[Y_AXIS]));
 
     if (ubl.g26_debug_flag) {
-      SERIAL_ECHOPGM(" ubl_line_to_destination(xe=");
-      SERIAL_ECHO(x_end);
-      SERIAL_ECHOPGM(", ye=");
-      SERIAL_ECHO(y_end);
-      SERIAL_ECHOPGM(", ze=");
-      SERIAL_ECHO(z_end);
-      SERIAL_ECHOPGM(", ee=");
-      SERIAL_ECHO(e_end);
-      SERIAL_ECHOLNPGM(")");
+      SERIAL_ECHOPAIR(" ubl_line_to_destination(xe=", end[X_AXIS]);
+      SERIAL_ECHOPAIR(", ye=", end[Y_AXIS]);
+      SERIAL_ECHOPAIR(", ze=", end[Z_AXIS]);
+      SERIAL_ECHOPAIR(", ee=", end[E_AXIS]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL;
       debug_current_and_destination((char*)"Start of ubl_line_to_destination()");
     }
 
@@ -142,12 +135,12 @@
        * But we detect it and isolate it. For now, we just pass along the request.
        */
 
-      if (cell_dest_xi < 0 || cell_dest_yi < 0 || cell_dest_xi >= UBL_MESH_NUM_X_POINTS || cell_dest_yi >= UBL_MESH_NUM_Y_POINTS) {
+      if (!WITHIN(cell_dest_xi, 0, UBL_MESH_NUM_X_POINTS - 1) || !WITHIN(cell_dest_yi, 0, UBL_MESH_NUM_Y_POINTS - 1)) {
 
         // Note: There is no Z Correction in this case. We are off the grid and don't know what
         // a reasonable correction would be.
 
-        planner.buffer_line(x_end, y_end, z_end + ubl.state.z_offset, e_end, feed_rate, extruder);
+        planner.buffer_line(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + ubl.state.z_offset, end[E_AXIS], feed_rate, extruder);
         set_current_to_destination();
 
         if (ubl.g26_debug_flag)
@@ -167,7 +160,7 @@
        * to create a 1-over number for us. That will allow us to do a floating point multiply instead of a floating point divide.
        */
 
-      const float xratio = (RAW_X_POSITION(x_end) - ubl.mesh_index_to_xpos[cell_dest_xi]) * (1.0 / (MESH_X_DIST)),
+      const float xratio = (RAW_X_POSITION(end[X_AXIS]) - ubl.mesh_index_to_xpos[cell_dest_xi]) * (1.0 / (MESH_X_DIST)),
                   z1 = ubl.z_values[cell_dest_xi    ][cell_dest_yi    ] + xratio *
                       (ubl.z_values[cell_dest_xi + 1][cell_dest_yi    ] - ubl.z_values[cell_dest_xi][cell_dest_yi    ]),
                   z2 = ubl.z_values[cell_dest_xi    ][cell_dest_yi + 1] + xratio *
@@ -176,7 +169,7 @@
       // we are done with the fractional X distance into the cell. Now with the two Z-Heights we have calculated, we
       // are going to apply the Y-Distance into the cell to interpolate the final Z correction.
 
-      const float yratio = (RAW_Y_POSITION(y_end) - ubl.mesh_index_to_ypos[cell_dest_yi]) * (1.0 / (MESH_Y_DIST));
+      const float yratio = (RAW_Y_POSITION(end[Y_AXIS]) - ubl.mesh_index_to_ypos[cell_dest_yi]) * (1.0 / (MESH_Y_DIST));
 
       float z0 = z1 + (z2 - z1) * yratio;
 
@@ -186,20 +179,20 @@
        */
       /*
         z_optimized = z0;
-        z0 = ubl.get_z_correction(x_end, y_end);
+        z0 = ubl.get_z_correction(end[X_AXIS], end[Y_AXIS]);
         if (fabs(z_optimized - z0) > .01 || isnan(z0) || isnan(z_optimized)) {
         debug_current_and_destination((char*)"FINAL_MOVE: z_correction()");
         if (isnan(z0)) SERIAL_ECHO(" z0==NAN  ");
         if (isnan(z_optimized)) SERIAL_ECHO(" z_optimized==NAN  ");
-        SERIAL_ECHOPAIR("  x_end=", x_end);
-        SERIAL_ECHOPAIR("  y_end=", y_end);
+        SERIAL_ECHOPAIR("  end[X_AXIS]=", end[X_AXIS]);
+        SERIAL_ECHOPAIR("  end[Y_AXIS]=", end[Y_AXIS]);
         SERIAL_ECHOPAIR("  z0=", z0);
         SERIAL_ECHOPAIR("  z_optimized=", z_optimized);
         SERIAL_ECHOPAIR("  err=",fabs(z_optimized - z0));
         SERIAL_EOL;
         }
       //*/
-      z0 *= ubl.fade_scaling_factor_for_z(z_end);
+      z0 *= ubl.fade_scaling_factor_for_z(end[Z_AXIS]);
 
       /**
        * If part of the Mesh is undefined, it will show up as NAN
@@ -210,7 +203,7 @@
        */
       if (isnan(z0)) z0 = 0.0;
 
-      planner.buffer_line(x_end, y_end, z_end + z0 + ubl.state.z_offset, e_end, feed_rate, extruder);
+      planner.buffer_line(end[X_AXIS], end[Y_AXIS], end[Z_AXIS] + z0 + ubl.state.z_offset, end[E_AXIS], feed_rate, extruder);
 
       if (ubl.g26_debug_flag)
         debug_current_and_destination((char*)"FINAL_MOVE in ubl_line_to_destination()");
@@ -227,8 +220,8 @@
      * blocks of code:
      */
 
-    const float dx = x_end - x_start,
-                dy = y_end - y_start;
+    const float dx = end[X_AXIS] - start[X_AXIS],
+                dy = end[Y_AXIS] - start[Y_AXIS];
 
     const int left_flag = dx < 0.0 ? 1 : 0,
               down_flag = dy < 0.0 ? 1 : 0;
@@ -251,8 +244,8 @@
     const bool use_x_dist = adx > ady;
 
     float on_axis_distance = use_x_dist ? dx : dy,
-          e_position = e_end - e_start,
-          z_position = z_end - z_start;
+          e_position = end[E_AXIS] - start[E_AXIS],
+          z_position = end[Z_AXIS] - start[Z_AXIS];
 
     const float e_normalized_dist = e_position / on_axis_distance,
                 z_normalized_dist = z_position / on_axis_distance;
@@ -260,7 +253,7 @@
     int current_xi = cell_start_xi, current_yi = cell_start_yi;
 
     const float m = dy / dx,
-                c = y_start - m * x_start;
+                c = start[Y_AXIS] - m * start[X_AXIS];
 
     const bool inf_normalized_flag = NEAR_ZERO(on_axis_distance),
                inf_m_flag = NEAR_ZERO(dx);
@@ -281,9 +274,9 @@
          * else, we know the next X is the same so we can recover and continue!
          * Calculate X at the next Y mesh line
          */
-        const float x = inf_m_flag ? x_start : (next_mesh_line_y - c) / m;
+        const float x = inf_m_flag ? start[X_AXIS] : (next_mesh_line_y - c) / m;
 
-        float z0 = ubl.get_z_correction_along_horizontal_mesh_line_at_specific_X(x, current_xi, current_yi);
+        float z0 = ubl.z_correction_for_x_on_horizontal_mesh_line(x, current_xi, current_yi);
 
         /**
          * Debug code to use non-optimized get_z_correction() and to do a sanity check
@@ -305,7 +298,7 @@
           }
         //*/
 
-        z0 *= ubl.fade_scaling_factor_for_z(z_end);
+        z0 *= ubl.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -324,15 +317,15 @@
          * happens, it might be best to remove the check and always 'schedule' the move because
          * the planner.buffer_line() routine will filter it if that happens.
          */
-        if (y != y_start) {
+        if (y != start[Y_AXIS]) {
           if (!inf_normalized_flag) {
-            on_axis_distance = y - y_start;                               // we don't need to check if the extruder position
-            e_position = e_start + on_axis_distance * e_normalized_dist;  // is based on X or Y because this is a vertical move
-            z_position = z_start + on_axis_distance * z_normalized_dist;
+            on_axis_distance = y - start[Y_AXIS];                               // we don't need to check if the extruder position
+            e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;  // is based on X or Y because this is a vertical move
+            z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
           }
           else {
-            e_position = e_start;
-            z_position = z_start;
+            e_position = start[E_AXIS];
+            z_position = start[Z_AXIS];
           }
 
           planner.buffer_line(x, y, z_position + z0 + ubl.state.z_offset, e_position, feed_rate, extruder);
@@ -345,7 +338,7 @@
       //
       // Check if we are at the final destination. Usually, we won't be, but if it is on a Y Mesh Line, we are done.
       //
-      if (current_position[X_AXIS] != x_end || current_position[Y_AXIS] != y_end)
+      if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
         goto FINAL_MOVE;
 
       set_current_to_destination();
@@ -368,7 +361,7 @@
         const float next_mesh_line_x = LOGICAL_X_POSITION(ubl.mesh_index_to_xpos[current_xi]),
                     y = m * next_mesh_line_x + c;   // Calculate X at the next Y mesh line
 
-        float z0 = ubl.get_z_correction_along_vertical_mesh_line_at_specific_Y(y, current_xi, current_yi);
+        float z0 = ubl.z_correction_for_y_on_vertical_mesh_line(y, current_xi, current_yi);
 
         /**
          * Debug code to use non-optimized get_z_correction() and to do a sanity check
@@ -390,7 +383,7 @@
           }
         //*/
 
-        z0 = z0 * ubl.fade_scaling_factor_for_z(z_end);
+        z0 *= ubl.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -409,15 +402,15 @@
          * that happens, it might be best to remove the check and always 'schedule' the move because
          * the planner.buffer_line() routine will filter it if that happens.
          */
-        if (x != x_start) {
+        if (x != start[X_AXIS]) {
           if (!inf_normalized_flag) {
-            on_axis_distance = x - x_start;                               // we don't need to check if the extruder position
-            e_position = e_start + on_axis_distance * e_normalized_dist;  // is based on X or Y because this is a horizontal move
-            z_position = z_start + on_axis_distance * z_normalized_dist;
+            on_axis_distance = x - start[X_AXIS];                               // we don't need to check if the extruder position
+            e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;  // is based on X or Y because this is a horizontal move
+            z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
           }
           else {
-            e_position = e_start;
-            z_position = z_start;
+            e_position = start[E_AXIS];
+            z_position = start[Z_AXIS];
           }
 
           planner.buffer_line(x, y, z_position + z0 + ubl.state.z_offset, e_position, feed_rate, extruder);
@@ -427,7 +420,7 @@
       if (ubl.g26_debug_flag)
         debug_current_and_destination((char*)"horizontal move done in ubl_line_to_destination()");
 
-      if (current_position[X_AXIS] != x_end || current_position[Y_AXIS] != y_end)
+      if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
         goto FINAL_MOVE;
 
       set_current_to_destination();
@@ -454,16 +447,16 @@
       const float next_mesh_line_x = LOGICAL_X_POSITION(ubl.mesh_index_to_xpos[current_xi + dxi]),
                   next_mesh_line_y = LOGICAL_Y_POSITION(ubl.mesh_index_to_ypos[current_yi + dyi]),
                   y = m * next_mesh_line_x + c,   // Calculate Y at the next X mesh line
-                  x = (next_mesh_line_y - c) / m; // Calculate X at the next Y mesh line    (we don't have to worry
-                                                  // about m being equal to 0.0  If this was the case, we would have
-                                                  // detected this as a vertical line move up above and we wouldn't
-                                                  // be down here doing a generic type of move.
+                  x = (next_mesh_line_y - c) / m; // Calculate X at the next Y mesh line
+                                                  // (No need to worry about m being zero.
+                                                  //  If that was the case, it was already detected
+                                                  //  as a vertical line move above.)
 
       if (left_flag == (x > next_mesh_line_x)) { // Check if we hit the Y line first
         //
         // Yes!  Crossing a Y Mesh Line next
         //
-        float z0 = ubl.get_z_correction_along_horizontal_mesh_line_at_specific_X(x, current_xi - left_flag, current_yi + dyi);
+        float z0 = ubl.z_correction_for_x_on_horizontal_mesh_line(x, current_xi - left_flag, current_yi + dyi);
 
         /**
          * Debug code to use non-optimized get_z_correction() and to do a sanity check
@@ -486,7 +479,7 @@
           }
         //*/
 
-        z0 *= ubl.fade_scaling_factor_for_z(z_end);
+        z0 *= ubl.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -498,13 +491,13 @@
         if (isnan(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
-          on_axis_distance = use_x_dist ? x - x_start : next_mesh_line_y - y_start;
-          e_position = e_start + on_axis_distance * e_normalized_dist;
-          z_position = z_start + on_axis_distance * z_normalized_dist;
+          on_axis_distance = use_x_dist ? x - start[X_AXIS] : next_mesh_line_y - start[Y_AXIS];
+          e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;
+          z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
         }
         else {
-          e_position = e_start;
-          z_position = z_start;
+          e_position = start[E_AXIS];
+          z_position = start[Z_AXIS];
         }
         planner.buffer_line(x, next_mesh_line_y, z_position + z0 + ubl.state.z_offset, e_position, feed_rate, extruder);
         current_yi += dyi;
@@ -514,7 +507,7 @@
         //
         // Yes!  Crossing a X Mesh Line next
         //
-        float z0 = ubl.get_z_correction_along_vertical_mesh_line_at_specific_Y(y, current_xi + dxi, current_yi - down_flag);
+        float z0 = ubl.z_correction_for_y_on_vertical_mesh_line(y, current_xi + dxi, current_yi - down_flag);
 
         /**
          * Debug code to use non-optimized get_z_correction() and to do a sanity check
@@ -536,7 +529,7 @@
           }
         //*/
 
-        z0 *= ubl.fade_scaling_factor_for_z(z_end);
+        z0 *= ubl.fade_scaling_factor_for_z(end[Z_AXIS]);
 
         /**
          * If part of the Mesh is undefined, it will show up as NAN
@@ -548,13 +541,13 @@
         if (isnan(z0)) z0 = 0.0;
 
         if (!inf_normalized_flag) {
-          on_axis_distance = use_x_dist ? next_mesh_line_x - x_start : y - y_start;
-          e_position = e_start + on_axis_distance * e_normalized_dist;
-          z_position = z_start + on_axis_distance * z_normalized_dist;
+          on_axis_distance = use_x_dist ? next_mesh_line_x - start[X_AXIS] : y - start[Y_AXIS];
+          e_position = start[E_AXIS] + on_axis_distance * e_normalized_dist;
+          z_position = start[Z_AXIS] + on_axis_distance * z_normalized_dist;
         }
         else {
-          e_position = e_start;
-          z_position = z_start;
+          e_position = start[E_AXIS];
+          z_position = start[Z_AXIS];
         }
 
         planner.buffer_line(next_mesh_line_x, y, z_position + z0 + ubl.state.z_offset, e_position, feed_rate, extruder);
@@ -566,7 +559,7 @@
     if (ubl.g26_debug_flag)
       debug_current_and_destination((char*)"generic move done in ubl_line_to_destination()");
 
-    if (current_position[0] != x_end || current_position[1] != y_end)
+    if (current_position[X_AXIS] != end[X_AXIS] || current_position[Y_AXIS] != end[Y_AXIS])
       goto FINAL_MOVE;
 
     set_current_to_destination();
diff --git a/Marlin/endstop_interrupts.h b/Marlin/endstop_interrupts.h
index 495a758f1d3..642f78a58b9 100644
--- a/Marlin/endstop_interrupts.h
+++ b/Marlin/endstop_interrupts.h
@@ -35,8 +35,10 @@
  * (Located in Marlin/buildroot/share/pin_interrupt_test/pin_interrupt_test.ino)
  */
 
- #ifndef _ENDSTOP_INTERRUPTS_H_
- #define _ENDSTOP_INTERRUPTS_H_
+#ifndef _ENDSTOP_INTERRUPTS_H_
+#define _ENDSTOP_INTERRUPTS_H_
+
+#include "macros.h"
 
 /**
  * Patch for pins_arduino.h (...\Arduino\hardware\arduino\avr\variants\mega\pins_arduino.h)
@@ -47,39 +49,37 @@
  */
 #if defined(ARDUINO_AVR_MEGA2560) || defined(ARDUINO_AVR_MEGA)
   #undef  digitalPinToPCICR
-  #define digitalPinToPCICR(p)    ( (((p) >= 10) && ((p) <= 15)) || \
-                                  (((p) >= 50) && ((p) <= 53)) || \
-                                  (((p) >= 62) && ((p) <= 69)) ? (&PCICR) : ((uint8_t *)0) )
+  #define digitalPinToPCICR(p)    ( WITHIN(p, 10, 15) || \
+                                    WITHIN(p, 50, 53) || \
+                                    WITHIN(p, 62, 69) ? &PCICR : (uint8_t*)0 )
   #undef  digitalPinToPCICRbit
-  #define digitalPinToPCICRbit(p) ( (((p) >= 10) && ((p) <= 13)) || (((p) >= 50) && ((p) <= 53)) ? 0 : \
-                                  ( (((p) >= 14) && ((p) <= 15)) ? 1 : \
-                                  ( (((p) >= 62) && ((p) <= 69)) ? 2 : \
-                                  0 ) ) )
+  #define digitalPinToPCICRbit(p) ( WITHIN(p, 10, 13) || WITHIN(p, 50, 53) ? 0 : \
+                                    WITHIN(p, 14, 15) ? 1 : \
+                                    WITHIN(p, 62, 69) ? 2 : \
+                                    0 )
   #undef  digitalPinToPCMSK
-  #define digitalPinToPCMSK(p)    ( (((p) >= 10) && ((p) <= 13)) || (((p) >= 50) && ((p) <= 53)) ? (&PCMSK0) : \
-                                  ( (((p) >= 14) && ((p) <= 15)) ? (&PCMSK1) : \
-                                  ( (((p) >= 62) && ((p) <= 69)) ? (&PCMSK2) : \
-                                  ((uint8_t *)0) ) ) )
+  #define digitalPinToPCMSK(p)    ( WITHIN(p, 10, 13) || WITHIN(p, 50, 53) ? &PCMSK0 : \
+                                    WITHIN(p, 14, 15) ? &PCMSK1 : \
+                                    WITHIN(p, 62, 69) ? &PCMSK2 : \
+                                    (uint8_t *)0 )
   #undef  digitalPinToPCMSKbit
-  #define digitalPinToPCMSKbit(p) ( (((p) >= 10) && ((p) <= 13)) ? ((p) - 6) : \
-                                  ( ((p) == 14) ? 2 : \
-                                  ( ((p) == 15) ? 1 : \
-                                  ( ((p) == 50) ? 3 : \
-                                  ( ((p) == 51) ? 2 : \
-                                  ( ((p) == 52) ? 1 : \
-                                  ( ((p) == 53) ? 0 : \
-                                  ( (((p) >= 62) && ((p) <= 69)) ? ((p) - 62) : \
-                                  0 ) ) ) ) ) ) ) )
+  #define digitalPinToPCMSKbit(p) ( WITHIN(p, 10, 13) ? ((p) - 6) : \
+                                    (p) == 14 || (p) == 51 ? 2 : \
+                                    (p) == 15 || (p) == 52 ? 1 : \
+                                    (p) == 50 ? 3 : \
+                                    (p) == 53 ? 0 : \
+                                    WITHIN(p, 62, 69) ? ((p) - 62) : \
+                                    0 )
 #endif
 
-volatile uint8_t e_hit = 0; // Different from 0 when the endstops shall be tested in detail.
-                            // Must be reset to 0 by the test function when the tests are finished.
+volatile uint8_t e_hit = 0; // Different from 0 when the endstops should be tested in detail.
+                            // Must be reset to 0 by the test function when finished.
 
 // Install Pin change interrupt for a pin. Can be called multiple times.
 void pciSetup(byte pin) {
-  *digitalPinToPCMSK(pin) |= bit (digitalPinToPCMSKbit(pin));  // enable pin
-  PCIFR  |= bit (digitalPinToPCICRbit(pin)); // clear any outstanding interrupt
-  PCICR  |= bit (digitalPinToPCICRbit(pin)); // enable interrupt for the group
+  SBI(*digitalPinToPCMSK(pin), digitalPinToPCMSKbit(pin));  // enable pin
+  SBI(PCIFR, digitalPinToPCICRbit(pin)); // clear any outstanding interrupt
+  SBI(PCICR, digitalPinToPCICRbit(pin)); // enable interrupt for the group
 }
 
 // This is what is really done inside the interrupts.
diff --git a/Marlin/macros.h b/Marlin/macros.h
index 0ab08c31b8c..18c5364a16b 100644
--- a/Marlin/macros.h
+++ b/Marlin/macros.h
@@ -75,7 +75,8 @@
 #define ENABLED(b) _CAT(SWITCH_ENABLED_, b)
 #define DISABLED(b) (!_CAT(SWITCH_ENABLED_, b))
 
-#define NUMERIC(a) ((a) >= '0' && '9' >= (a))
+#define WITHIN(V,L,H) ((V) >= (L) && (V) <= (H))
+#define NUMERIC(a) WITHIN(a, '0', '9')
 #define NUMERIC_SIGNED(a) (NUMERIC(a) || (a) == '-')
 #define COUNT(a) (sizeof(a)/sizeof(*a))
 #define ZERO(a) memset(a,0,sizeof(a))
@@ -133,9 +134,10 @@
 #define MAX4(a, b, c, d) max(max(a, b), max(c, d))
 
 #define UNEAR_ZERO(x) ((x) < 0.000001)
-#define NEAR_ZERO(x) ((x) > -0.000001 && (x) < 0.000001)
+#define NEAR_ZERO(x) WITHIN(x, -0.000001, 0.000001)
 #define NEAR(x,y) NEAR_ZERO((x)-(y))
 
 #define RECIPROCAL(x) (NEAR_ZERO(x) ? 0.0 : 1.0 / (x))
+#define FIXFLOAT(f) (f + 0.00001)
 
 #endif //__MACROS_H
diff --git a/Marlin/mesh_bed_leveling.h b/Marlin/mesh_bed_leveling.h
index 6a683627b84..3b7de0827be 100644
--- a/Marlin/mesh_bed_leveling.h
+++ b/Marlin/mesh_bed_leveling.h
@@ -88,12 +88,12 @@
 
     static int8_t probe_index_x(const float &x) {
       int8_t px = (x - (MESH_MIN_X) + 0.5 * (MESH_X_DIST)) * (1.0 / (MESH_X_DIST));
-      return (px >= 0 && px < (MESH_NUM_X_POINTS)) ? px : -1;
+      return WITHIN(px, 0, MESH_NUM_X_POINTS - 1) ? px : -1;
     }
 
     static int8_t probe_index_y(const float &y) {
       int8_t py = (y - (MESH_MIN_Y) + 0.5 * (MESH_Y_DIST)) * (1.0 / (MESH_Y_DIST));
-      return (py >= 0 && py < (MESH_NUM_Y_POINTS)) ? py : -1;
+      return WITHIN(py, 0, MESH_NUM_Y_POINTS - 1) ? py : -1;
     }
 
     static float calc_z0(const float &a0, const float &a1, const float &z1, const float &a2, const float &z2) {
diff --git a/Marlin/pinsDebug.h b/Marlin/pinsDebug.h
index e8394807573..8fe48da2a94 100644
--- a/Marlin/pinsDebug.h
+++ b/Marlin/pinsDebug.h
@@ -20,6 +20,8 @@
  *
  */
 
+#include "macros.h"
+
 bool endstop_monitor_flag = false;
 
 #if !defined(TIMER1B)    // working with Teensyduino extension so need to re-define some things
@@ -35,7 +37,7 @@ bool endstop_monitor_flag = false;
 #define _ANALOG_PIN_SAY(NAME) { sprintf(buffer, NAME_FORMAT, NAME); SERIAL_ECHO(buffer); pin_is_analog = true; return true; }
 #define ANALOG_PIN_SAY(NAME) if (pin == analogInputToDigitalPin(NAME)) _ANALOG_PIN_SAY(#NAME);
 
-#define IS_ANALOG(P) ((P) >= analogInputToDigitalPin(0) && ((P) <= analogInputToDigitalPin(15) || (P) <= analogInputToDigitalPin(5)))
+#define IS_ANALOG(P) ( WITHIN(P, analogInputToDigitalPin(0), analogInputToDigitalPin(15)) || (P) <= analogInputToDigitalPin(5) )
 
 int digitalRead_mod(int8_t pin) { // same as digitalRead except the PWM stop section has been removed
   uint8_t port = digitalPinToPort(pin);
diff --git a/Marlin/planner.cpp b/Marlin/planner.cpp
index 5c71faf0875..b252f95ef69 100644
--- a/Marlin/planner.cpp
+++ b/Marlin/planner.cpp
@@ -999,7 +999,7 @@ void Planner::_buffer_line(const float &a, const float &b, const float &c, const
     unsigned long segment_time = lround(1000000.0 / inverse_mm_s);
   #endif
   #if ENABLED(SLOWDOWN)
-    if (moves_queued > 1 && moves_queued < (BLOCK_BUFFER_SIZE) / 2) {
+    if (WITHIN(moves_queued, 2, (BLOCK_BUFFER_SIZE) / 2 - 1)) {
       if (segment_time < min_segment_time) {
         // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
         inverse_mm_s = 1000000.0 / (segment_time + lround(2 * (min_segment_time - segment_time) / moves_queued));
diff --git a/Marlin/temperature.cpp b/Marlin/temperature.cpp
index 139f14e60d5..f3bfc7fa7bf 100644
--- a/Marlin/temperature.cpp
+++ b/Marlin/temperature.cpp
@@ -786,11 +786,11 @@ void Temperature::manage_heater() {
     #if ENABLED(PIDTEMPBED)
       float pid_output = get_pid_output_bed();
 
-      soft_pwm_bed = current_temperature_bed > BED_MINTEMP && current_temperature_bed < BED_MAXTEMP ? (int)pid_output >> 1 : 0;
+      soft_pwm_bed = WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP) ? (int)pid_output >> 1 : 0;
 
     #elif ENABLED(BED_LIMIT_SWITCHING)
       // Check if temperature is within the correct band
-      if (current_temperature_bed > BED_MINTEMP && current_temperature_bed < BED_MAXTEMP) {
+      if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
         if (current_temperature_bed >= target_temperature_bed + BED_HYSTERESIS)
           soft_pwm_bed = 0;
         else if (current_temperature_bed <= target_temperature_bed - (BED_HYSTERESIS))
@@ -802,7 +802,7 @@ void Temperature::manage_heater() {
       }
     #else // !PIDTEMPBED && !BED_LIMIT_SWITCHING
       // Check if temperature is within the correct range
-      if (current_temperature_bed > BED_MINTEMP && current_temperature_bed < BED_MAXTEMP) {
+      if (WITHIN(current_temperature_bed, BED_MINTEMP, BED_MAXTEMP)) {
         soft_pwm_bed = current_temperature_bed < target_temperature_bed ? MAX_BED_POWER >> 1 : 0;
       }
       else {
diff --git a/Marlin/twibus.cpp b/Marlin/twibus.cpp
index c5abdb2a9a6..b621be95243 100644
--- a/Marlin/twibus.cpp
+++ b/Marlin/twibus.cpp
@@ -42,7 +42,7 @@ void TWIBus::reset() {
 }
 
 void TWIBus::address(const uint8_t adr) {
-  if (adr < 8 || adr > 127) {
+  if (!WITHIN(adr, 8, 127)) {
     SERIAL_ECHO_START;
     SERIAL_ECHOLNPGM("Bad I2C address (8-127)");
   }
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index a7ab0324329..551d7879feb 100755
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -30,8 +30,6 @@
 #include "configuration_store.h"
 #include "utility.h"
 
-extern float zprobe_zoffset;
-
 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
   #include "buzzer.h"
 #endif
diff --git a/Marlin/ultralcd_impl_DOGM.h b/Marlin/ultralcd_impl_DOGM.h
index 51bbd6cd8f6..cb06db95a2e 100644
--- a/Marlin/ultralcd_impl_DOGM.h
+++ b/Marlin/ultralcd_impl_DOGM.h
@@ -213,7 +213,7 @@ static void lcd_setFont(const char font_nr) {
 }
 
 void lcd_print(const char c) {
-  if ((c > 0) && (c <= LCD_STR_SPECIAL_MAX)) {
+  if (WITHIN(c, 1, LCD_STR_SPECIAL_MAX)) {
     u8g.setFont(FONT_SPECIAL_NAME);
     u8g.print(c);
     lcd_setFont(currentfont);
@@ -222,7 +222,7 @@ void lcd_print(const char c) {
 }
 
 char lcd_print_and_count(const char c) {
-  if ((c > 0) && (c <= LCD_STR_SPECIAL_MAX)) {
+  if (WITHIN(c, 1, LCD_STR_SPECIAL_MAX)) {
     u8g.setFont(FONT_SPECIAL_NAME);
     u8g.print(c);
     lcd_setFont(currentfont);
@@ -543,7 +543,7 @@ static void lcd_implementation_status_screen() {
   if (page.page == 0) {
     strcpy(xstring, ftostr4sign(current_position[X_AXIS]));
     strcpy(ystring, ftostr4sign(current_position[Y_AXIS]));
-    strcpy(zstring, ftostr52sp(current_position[Z_AXIS] + 0.00001));
+    strcpy(zstring, ftostr52sp(FIXFLOAT(current_position[Z_AXIS])));
     #if ENABLED(FILAMENT_LCD_DISPLAY) && DISABLED(SDSUPPORT)
       strcpy(wstring, ftostr12ns(filament_width_meas));
       strcpy(mstring, itostr3(100.0 * volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]));
diff --git a/Marlin/ultralcd_impl_HD44780.h b/Marlin/ultralcd_impl_HD44780.h
index d81e342442c..6672e4b08cd 100644
--- a/Marlin/ultralcd_impl_HD44780.h
+++ b/Marlin/ultralcd_impl_HD44780.h
@@ -729,7 +729,7 @@ static void lcd_implementation_status_screen() {
 
     lcd.setCursor(LCD_WIDTH - 8, 1);
     _draw_axis_label(Z_AXIS, PSTR(MSG_Z), blink);
-    lcd.print(ftostr52sp(current_position[Z_AXIS] + 0.00001));
+    lcd.print(ftostr52sp(FIXFLOAT(current_position[Z_AXIS])));
 
   #endif // LCD_HEIGHT > 2
 
diff --git a/Marlin/utility.cpp b/Marlin/utility.cpp
index b6b4ddcac46..83e1579b27b 100644
--- a/Marlin/utility.cpp
+++ b/Marlin/utility.cpp
@@ -134,7 +134,7 @@ void safe_delay(millis_t ms) {
     // Convert float to rj string with 1234, _123, -123, _-12, 12.3, _1.2, or -1.2 format
     char *ftostr4sign(const float& fx) {
       int x = fx * 10;
-      if (x <= -100 || x >= 1000) return itostr4sign((int)fx);
+      if (WITHIN(x, -99, 999)) return itostr4sign((int)fx);
       int xx = abs(x);
       conv[0] = x < 0 ? '-' : (xx >= 100 ? DIGIMOD(xx, 100) : ' ');
       conv[1] = DIGIMOD(xx, 10);
