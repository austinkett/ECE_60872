diff --git a/Marlin/Conditionals_post.h b/Marlin/Conditionals_post.h
index 02a1eb0f6b1..6252ac5d3f1 100644
--- a/Marlin/Conditionals_post.h
+++ b/Marlin/Conditionals_post.h
@@ -691,43 +691,20 @@
    * Delta radius/rod trimmers/angle trimmers
    */
   #if ENABLED(DELTA)
-    #ifndef DELTA_ENDSTOP_ADJ
-      #define DELTA_ENDSTOP_ADJ { 0 }
-    #endif
-    #ifndef DELTA_RADIUS_TRIM_TOWER_1
-      #define DELTA_RADIUS_TRIM_TOWER_1 0.0
-    #endif
-    #ifndef DELTA_RADIUS_TRIM_TOWER_2
-      #define DELTA_RADIUS_TRIM_TOWER_2 0.0
-    #endif
-    #ifndef DELTA_RADIUS_TRIM_TOWER_3
-      #define DELTA_RADIUS_TRIM_TOWER_3 0.0
-    #endif
-    #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER_1
-      #define DELTA_DIAGONAL_ROD_TRIM_TOWER_1 0.0
+    #ifndef DELTA_CALIBRATION_RADIUS
+      #define DELTA_CALIBRATION_RADIUS DELTA_PRINTABLE_RADIUS - 10
     #endif
-    #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER_2
-      #define DELTA_DIAGONAL_ROD_TRIM_TOWER_2 0.0
-    #endif
-    #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER_3
-      #define DELTA_DIAGONAL_ROD_TRIM_TOWER_3 0.0
-    #endif
-    #ifndef DELTA_TOWER_ANGLE_TRIM_1
-      #define DELTA_TOWER_ANGLE_TRIM_1 0.0
+    #ifndef DELTA_ENDSTOP_ADJ
+      #define DELTA_ENDSTOP_ADJ { 0.0, 0.0, 0.0 }
     #endif
-    #ifndef DELTA_TOWER_ANGLE_TRIM_2
-      #define DELTA_TOWER_ANGLE_TRIM_2 0.0
+    #ifndef DELTA_TOWER_ANGLE_TRIM
+      #define DELTA_TOWER_ANGLE_TRIM { 0.0, 0.0 } // C always 0.0
     #endif
-    #ifndef DELTA_TOWER_ANGLE_TRIM_3
-      #define DELTA_TOWER_ANGLE_TRIM_3 0.0
+    #ifndef DELTA_RADIUS_TRIM_TOWER
+      #define DELTA_RADIUS_TRIM_TOWER { 0.0, 0.0, 0.0 }
     #endif
-    #if ENABLED(DELTA_AUTO_CALIBRATION)
-      #ifndef H_FACTOR
-        #define H_FACTOR 1.00
-      #endif
-      #ifndef R_FACTOR
-        #define R_FACTOR -2.25
-      #endif
+    #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER
+      #define DELTA_DIAGONAL_ROD_TRIM_TOWER { 0.0, 0.0, 0.0 }
     #endif
   #endif
 
diff --git a/Marlin/Marlin.h b/Marlin/Marlin.h
index 9c85c224a38..bc1d682cdea 100644
--- a/Marlin/Marlin.h
+++ b/Marlin/Marlin.h
@@ -302,9 +302,9 @@ float code_value_temp_diff();
   extern float endstop_adj[ABC],
                delta_radius,
                delta_diagonal_rod,
+               delta_calibration_radius,
                delta_segments_per_second,
-               delta_diagonal_rod_trim[ABC],
-               delta_tower_angle_trim[ABC],
+               delta_tower_angle_trim[2],
                delta_clip_start_height;
   void recalc_delta_settings(float radius, float diagonal_rod);
 #elif IS_SCARA
diff --git a/Marlin/Marlin_main.cpp b/Marlin/Marlin_main.cpp
index a894c63aaca..64ba2940a56 100755
--- a/Marlin/Marlin_main.cpp
+++ b/Marlin/Marlin_main.cpp
@@ -61,7 +61,7 @@
  * G30 - Single Z probe, probes bed at X Y location (defaults to current XY location)
  * G31 - Dock sled (Z_PROBE_SLED only)
  * G32 - Undock sled (Z_PROBE_SLED only)
- * G33 - Delta '4-point' auto calibration iteration
+ * G33 - Delta '4-7-point' auto calibration : "G33 C<points> V<verbose>" (Requires DELTA)
  * G38 - Probe target - similar to G28 except it uses the Z_MIN_PROBE for all three axes
  * G90 - Use Absolute Coordinates
  * G91 - Use Relative Coordinates
@@ -585,10 +585,10 @@ static uint8_t target_extruder;
   // These values are loaded or reset at boot time when setup() calls
   // settings.load(), which calls recalc_delta_settings().
   float delta_radius,
-        delta_tower_angle_trim[ABC],
+        delta_tower_angle_trim[2],
         delta_tower[ABC][2],
         delta_diagonal_rod,
-        delta_diagonal_rod_trim[ABC],
+        delta_calibration_radius,
         delta_diagonal_rod_2_tower[ABC],
         delta_segments_per_second,
         delta_clip_start_height = Z_MAX_POS;
@@ -1830,6 +1830,9 @@ static void clean_up_after_endstop_or_probe_move() {
 
     float z_dest = LOGICAL_Z_POSITION(z_raise);
     if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
+    #if ENABLED(DELTA)
+      z_dest -= home_offset[Z_AXIS];
+    #endif
 
     if (z_dest > current_position[Z_AXIS])
       do_blocking_move_to_z(z_dest);
@@ -1837,7 +1840,8 @@ static void clean_up_after_endstop_or_probe_move() {
 
 #endif //HAS_BED_PROBE
 
-#if ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || HAS_PROBING_PROCEDURE || HOTENDS > 1 || ENABLED(NOZZLE_CLEAN_FEATURE) || ENABLED(NOZZLE_PARK_FEATURE)
+#if HAS_PROBING_PROCEDURE || HOTENDS > 1 || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || ENABLED(NOZZLE_CLEAN_FEATURE) || ENABLED(NOZZLE_PARK_FEATURE) || ENABLED(DELTA_AUTO_CALIBRATION)
+
   bool axis_unhomed_error(const bool x, const bool y, const bool z) {
     const bool xx = x && !axis_homed[X_AXIS],
                yy = y && !axis_homed[Y_AXIS],
@@ -1857,6 +1861,7 @@ static void clean_up_after_endstop_or_probe_move() {
     }
     return false;
   }
+
 #endif
 
 #if ENABLED(Z_PROBE_SLED)
@@ -2308,6 +2313,9 @@ static void clean_up_after_endstop_or_probe_move() {
       // move down quickly before doing the slow probe
       float z = LOGICAL_Z_POSITION(Z_CLEARANCE_BETWEEN_PROBES);
       if (zprobe_zoffset < 0) z -= zprobe_zoffset;
+      #if ENABLED(DELTA)
+        z -= home_offset[Z_AXIS];
+      #endif
       if (z < current_position[Z_AXIS])
         do_blocking_move_to_z(z, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
 
@@ -5009,11 +5017,12 @@ inline void gcode_G28() {
 
   /**
    * G30: Do a single Z probe at the current XY
-   * Usage:
-   *   G30 <X#> <Y#> <S#>
-   *     X = Probe X position (default=current probe position)
-   *     Y = Probe Y position (default=current probe position)
-   *     S = Stows the probe if 1 (default=1)
+   *
+   * Parameters:
+   *
+   *   X   Probe X position (default current X)
+   *   Y   Probe Y position (default current Y)
+   *   S0  Leave the probe deployed
    */
   inline void gcode_G30() {
     const float xpos = code_seen('X') ? code_value_linear_units() : current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER,
@@ -5055,85 +5064,77 @@ inline void gcode_G28() {
   #endif // Z_PROBE_SLED
 
   #if ENABLED(DELTA_AUTO_CALIBRATION)
+
     /**
-     * G33: Delta '4-point' auto calibration iteration
-     *
-     * Usage: G33 <Cn> <Vn>
+     * G33 - Delta Auto Calibration
+     *       Utility to calibrate height, endstop offsets, delta radius, and tower angles.
      *
-     *  C  (default) = Calibrate endstops, height and delta radius
+     * Parameters:
      *
-     *  -2, 1-4: n x n probe points, default 3 x 3
+     *   C0     Calibrate height
+     *   C1     Probe the center to set the Z height
+     *   C-1    same but 1 iteration only
+     *   C2     probe center and towers, set height, endstops, and delta radius
+     *   C-2    same but opposite towers
      *
-     *    1: probe center
-     *       set height only - useful when z_offset is changed
-     *    2: probe center and towers
-     *       solve one '4 point' calibration
-     *   -2: probe center and opposite the towers
-     *       solve one '4 point' calibration
-     *    3: probe 3 center points, towers and opposite-towers
-     *       averages between 2 '4 point' calibrations
-     *    4: probe 4 center points, towers, opposite-towers and itermediate points
-     *       averages between 4 '4 point' calibrations
+     *   C3     probe all points: center, towers and opposite towers / sets all
      *
-     *  V  Verbose level (0-3, default 1)
+     *   C4-C7  probe all points multiple times and average
+     *   C0-C3  same but tower angle calibration disabled
      *
-     *    0: Dry-run mode: no calibration
-     *    1: Settings
-     *    2: Setting + probe results
-     *    3: Expert mode: setting + iteration factors (see Configuration_adv.h)
-     *       This prematurely stops the iteration process when factors are found
+     *   V0     Dry-run mode
+     *   V1     Output settings
+     *   V2     Output setting and probe results
      */
     inline void gcode_G33() {
 
-      stepper.synchronize();
+      if (axis_unhomed_error(true, true, true)) return;
 
-      #if PLANNER_LEVELING
-        set_bed_leveling_enabled(false);
-      #endif
+      const int8_t c_value = code_seen('C') ? code_value_int() : DELTA_CALIBRATION_DEFAULT_POINTS;
+      if (!WITHIN(c_value, -7, 7)) {
+        SERIAL_PROTOCOLLNPGM("?C parameter is implausible (-7 to 7).");
+        return;
+      }
 
-      const int8_t pp = code_seen('C') ? code_value_int() : DELTA_CALIBRATION_DEFAULT_POINTS,
-                   probe_points = (WITHIN(pp, 1, 4) || pp == -2) ? pp : DELTA_CALIBRATION_DEFAULT_POINTS;
+      const int8_t verbose_level = code_seen('V') ? code_value_byte() : 1;
+      if (!WITHIN(verbose_level, 0, 2)) {
+        SERIAL_PROTOCOLLNPGM("?(V)erbose Level is implausible (0-2).");
+        return;
+      }
 
-      int8_t verbose_level = code_seen('V') ? code_value_byte() : 1;
+      stepper.synchronize();
 
-      #if ENABLED(DELTA_CALIBRATE_EXPERT_MODE)
-        #define _MAX_M33_V 3
-        if (verbose_level == 3 && probe_points == 1) verbose_level--; // needs at least 4 points
-      #else
-        #define _MAX_M33_V 2
-        if (verbose_level > 2)
-          SERIAL_PROTOCOLLNPGM("Enable DELTA_CALIBRATE_EXPERT_MODE in Configuration_adv.h");
+      #if PLANNER_LEVELING
+        set_bed_leveling_enabled(false);
       #endif
 
-      if (!WITHIN(verbose_level, 0, _MAX_M33_V)) verbose_level = 1;
+      const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
 
-      float zero_std_dev = verbose_level ? 999.0 : 0.0; // 0.0 in dry-run mode : forced end
+      const uint8_t probe_points = abs(c_value);
 
-      gcode_G28();
+      const bool neg = c_value < 0,
+                 equals4 = probe_points == 4,
+                 over4 = probe_points > 4,
+                 over5 = probe_points > 5;
 
       float e_old[XYZ],
             dr_old = delta_radius,
-            zh_old = home_offset[Z_AXIS];
-      COPY(e_old,endstop_adj);
-      #if ENABLED(DELTA_CALIBRATE_EXPERT_MODE)
-        // expert variables
-        float h_f_old = 1.00, r_f_old = 0.00,
-              h_diff_min = 1.00, r_diff_max = 0.10;
-      #endif
+            zh_old = home_offset[Z_AXIS],
+            alpha_old = delta_tower_angle_trim[A_AXIS],
+            beta_old = delta_tower_angle_trim[B_AXIS];
+
+      COPY(e_old, endstop_adj);
 
       // print settings
 
       SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
       SERIAL_PROTOCOLPGM("Checking... AC");
       if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
-      #if ENABLED(DELTA_CALIBRATE_EXPERT_MODE)
-        if (verbose_level == 3) SERIAL_PROTOCOLPGM(" (EXPERT)");
-      #endif
       SERIAL_EOL;
       LCD_MESSAGEPGM("Checking... AC");
 
-      SERIAL_PROTOCOLPAIR("Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
-      if (abs(probe_points) > 1) {
+      SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
+      if (probe_points > 1) {
         SERIAL_PROTOCOLPGM("    Ex:");
         if (endstop_adj[A_AXIS] >= 0) SERIAL_CHAR('+');
         SERIAL_PROTOCOL_F(endstop_adj[A_AXIS], 2);
@@ -5146,103 +5147,120 @@ inline void gcode_G28() {
         SERIAL_PROTOCOLPAIR("    Radius:", delta_radius);
       }
       SERIAL_EOL;
+      if (c_value > 2) {
+        SERIAL_PROTOCOLPGM(".Tower angle :    Tx:");
+        if (delta_tower_angle_trim[A_AXIS] >= 0) SERIAL_CHAR('+');
+        SERIAL_PROTOCOL_F(delta_tower_angle_trim[A_AXIS], 2);
+        SERIAL_PROTOCOLPGM("  Ty:");
+        if (delta_tower_angle_trim[B_AXIS] >= 0) SERIAL_CHAR('+');
+        SERIAL_PROTOCOL_F(delta_tower_angle_trim[B_AXIS], 2);
+        SERIAL_PROTOCOLPGM("  Tz:+0.00");
+        SERIAL_EOL;
+      }
 
       #if ENABLED(Z_PROBE_SLED)
         DEPLOY_PROBE();
       #endif
 
-      float test_precision;
+      float zero_std_dev = verbose_level ? 999.0 : 0.0, // 0.0 in dry-run mode : forced end
+            test_precision;
       int8_t iterations = 0;
-
-      do { // start iterations
+      do {
 
         setup_for_endstop_or_probe_move();
 
-        test_precision =
-          #if ENABLED(DELTA_CALIBRATE_EXPERT_MODE)
-            // Expert mode : forced end at std_dev < 0.1
-            (verbose_level == 3 && zero_std_dev < 0.1) ? 0.0 :
-          #endif
-          zero_std_dev
-        ;
-
+        test_precision = zero_std_dev;
         float z_at_pt[13] = { 0 };
-
         iterations++;
 
         // probe the points
 
         int16_t center_points = 0;
 
-        if (probe_points != 3) {
+        if (probe_points != 3 && probe_points != 6) {                                       // probe center
           z_at_pt[0] += probe_pt(0.0, 0.0 , true, 1);
           center_points = 1;
         }
 
-        int16_t step_axis = 4;
-        if (probe_points >= 3) {
-          for (int8_t axis = 9; axis > 0; axis -= step_axis) { // uint8_t starts endless loop
+        int16_t step_axis = over4 ? 2 : 4;
+        if (probe_points >= 3) {                                                            // probe extra 3 or 6 center points
+          for (int8_t axis = over4 ? 11 : 9; axis > 0; axis -= step_axis) {
             z_at_pt[0] += probe_pt(
-              0.1 * cos(RADIANS(180 + 30 * axis)) * (DELTA_CALIBRATION_RADIUS),
-              0.1 * sin(RADIANS(180 + 30 * axis)) * (DELTA_CALIBRATION_RADIUS), true, 1);
+              cos(RADIANS(180 + 30 * axis)) * (0.1 * delta_calibration_radius),
+              sin(RADIANS(180 + 30 * axis)) * (0.1 * delta_calibration_radius), true, 1);
           }
-          center_points += 3;
+          center_points += over4 ? 6 : 3;                                       // average center points
           z_at_pt[0] /= center_points;
         }
 
         float S1 = z_at_pt[0], S2 = sq(S1);
 
-        int16_t N = 1, start = (probe_points == -2) ? 3 : 1;
-        step_axis = (abs(probe_points) == 2) ? 4 : (probe_points == 3) ? 2 : 1;
-
-        if (probe_points != 1) {
-          for (uint8_t axis = start; axis < 13; axis += step_axis)
-            z_at_pt[axis] += probe_pt(
-              cos(RADIANS(180 + 30 * axis)) * (DELTA_CALIBRATION_RADIUS),
-              sin(RADIANS(180 + 30 * axis)) * (DELTA_CALIBRATION_RADIUS), true, 1
-            );
-
-          if (probe_points == 4) step_axis = 2;
+        int16_t N = 1, start = (c_value == -2) ? 3 : 1;
+        step_axis = (probe_points == 2) ? 4 : (equals4 || over5) ? 1 : 2;
+
+        if (probe_points > 1) {
+          float start_circles = (probe_points > 6) ? -1.5 : over4 ? -1 : 0, // one or multi radius points
+                  end_circles = -start_circles;
+          bool zig_zag = true;
+          for (uint8_t axis = start; axis < 13; axis += step_axis) {                             // probes 3, 6 or 12 points on the calibration radius
+            for (float circles = start_circles ; circles <= end_circles; circles++)              // one or multi radius points
+              z_at_pt[axis] += probe_pt(
+                cos(RADIANS(180 + 30 * axis)) * ((1 + circles * 0.1 * (zig_zag ? 1 : -1)) * delta_calibration_radius),
+                sin(RADIANS(180 + 30 * axis)) * ((1 + circles * 0.1 * (zig_zag ? 1 : -1)) * delta_calibration_radius), true, 1);
+
+            if (over5) start_circles += zig_zag ? +0.5 : -0.5;            // opposites: one radius point less
+            if (over5) end_circles += zig_zag ? -0.5 : +0.5;
+            zig_zag = !zig_zag;
+            if (over4) z_at_pt[axis] /= (zig_zag ? 3.0 : 2.0);              // average between radius points
+          }
         }
 
-        for (uint8_t axis = start; axis < 13; axis += step_axis) {
-          if (probe_points == 4)
+        if (equals4 || over5) step_axis = 2;
+        for (uint8_t axis = start; axis < 13; axis += step_axis) {                               // average half intermediates to towers and opposites
+          if (equals4 || over5)
             z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
 
           S1 += z_at_pt[axis];
           S2 += sq(z_at_pt[axis]);
           N++;
         }
-        zero_std_dev = round(sqrt(S2 / N) * 1000.0) / 1000.0 + 0.00001; // deviation from zero plane
 
         // Solve matrices
 
+        zero_std_dev = round(sqrt(S2 / N) * 1000.0) / 1000.0 + 0.00001;                          // deviation from zero plane
+
         if (zero_std_dev < test_precision) {
           COPY(e_old, endstop_adj);
           dr_old = delta_radius;
           zh_old = home_offset[Z_AXIS];
+          alpha_old = delta_tower_angle_trim[A_AXIS];
+          beta_old = delta_tower_angle_trim[B_AXIS];
 
-          float e_delta[XYZ] = { 0.0 }, r_delta = 0.0;
+          float e_delta[XYZ] = { 0.0 }, r_delta = 0.0,
+                t_alpha = 0.0, t_beta = 0.0;
 
-          #if ENABLED(DELTA_CALIBRATE_EXPERT_MODE)
-            float h_f_new = 0.0, r_f_new = 0.0 , t_f_new = 0.0,
-                  h_diff = 0.00, r_diff = 0.00;
-          #endif
+          const float r_diff = delta_radius - delta_calibration_radius,
+                      h_factor = 1.00 + r_diff * 0.001,                                          //1.02 for r_diff = 20mm
+                      r_factor = -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),                  //2.25 for r_diff = 20mm
+                      a_factor = 100.0 / delta_calibration_radius;                               //1.25 for cal_rd = 80mm
 
           #define ZP(N,I) ((N) * z_at_pt[I])
           #define Z1000(I) ZP(1.00, I)
-          #define Z1050(I) ZP(H_FACTOR, I)
-          #define Z0700(I) ZP((H_FACTOR) * 2.0 / 3.00, I)
-          #define Z0350(I) ZP((H_FACTOR) / 3.00, I)
-          #define Z0175(I) ZP((H_FACTOR) / 6.00, I)
-          #define Z2250(I) ZP(R_FACTOR, I)
-          #define Z0750(I) ZP((R_FACTOR) / 3.00, I)
-          #define Z0375(I) ZP((R_FACTOR) / 6.00, I)
-
-          switch (probe_points) {
+          #define Z1050(I) ZP(h_factor, I)
+          #define Z0700(I) ZP(h_factor * 2.0 / 3.00, I)
+          #define Z0350(I) ZP(h_factor / 3.00, I)
+          #define Z0175(I) ZP(h_factor / 6.00, I)
+          #define Z2250(I) ZP(r_factor, I)
+          #define Z0750(I) ZP(r_factor / 3.00, I)
+          #define Z0375(I) ZP(r_factor / 6.00, I)
+          #define Z0444(I) ZP(a_factor * 4.0 / 9.0, I)
+          #define Z0888(I) ZP(a_factor * 8.0 / 9.0, I)
+
+          switch (c_value) {
+            case -1:
+              test_precision = 0.00;
             case 1:
               LOOP_XYZ(i) e_delta[i] = Z1000(0);
-              r_delta = 0.00;
               break;
 
             case 2:
@@ -5264,38 +5282,25 @@ inline void gcode_G28() {
               e_delta[Y_AXIS] = Z1050(0) - Z0175(1) + Z0350(5) - Z0175(9) + Z0175(7) - Z0350(11) + Z0175(3);
               e_delta[Z_AXIS] = Z1050(0) - Z0175(1) - Z0175(5) + Z0350(9) + Z0175(7) + Z0175(11) - Z0350(3);
               r_delta         = Z2250(0) - Z0375(1) - Z0375(5) - Z0375(9) - Z0375(7) - Z0375(11) - Z0375(3);
+
+              if (c_value > 0) {                                                            //probe points negative disables tower angles
+                t_alpha = + Z0444(1) - Z0888(5) + Z0444(9) + Z0444(7) - Z0888(11) + Z0444(3);
+                t_beta  = - Z0888(1) + Z0444(5) + Z0444(9) - Z0888(7) + Z0444(11) + Z0444(3);
+              }
               break;
           }
 
-          #if ENABLED(DELTA_CALIBRATE_EXPERT_MODE)
-            // Calculate h & r factors
-            if (verbose_level == 3) {
-              LOOP_XYZ(axis) h_f_new += e_delta[axis] / 3;
-              r_f_new = r_delta;
-              h_diff = (1.0 / H_FACTOR) * (h_f_old - h_f_new) / h_f_old;
-              if (h_diff < h_diff_min && h_diff > 0.9) h_diff_min = h_diff;
-              if (r_f_old != 0)
-                r_diff = (   0.0301 * sq(R_FACTOR) * R_FACTOR
-                           + 0.311  * sq(R_FACTOR)
-                           + 1.1493 * R_FACTOR
-                           + 1.7952
-                         ) * (r_f_old - r_f_new) / r_f_old;
-              if (r_diff > r_diff_max && r_diff < 0.4444) r_diff_max = r_diff;
-              SERIAL_EOL;
-
-              h_f_old = h_f_new;
-              r_f_old = r_f_new;
-            }
-          #endif // DELTA_CALIBRATE_EXPERT_MODE
-
-          // Adjust delta_height and endstops by the max amount
+          // adjust delta_height and endstops by the max amount
           LOOP_XYZ(axis) endstop_adj[axis] += e_delta[axis];
           delta_radius += r_delta;
 
-          const float z_temp = MAX3(endstop_adj[0], endstop_adj[1], endstop_adj[2]);
+          const float z_temp = MAX3(endstop_adj[A_AXIS], endstop_adj[B_AXIS], endstop_adj[C_AXIS]);
           home_offset[Z_AXIS] -= z_temp;
           LOOP_XYZ(i) endstop_adj[i] -= z_temp;
 
+          delta_tower_angle_trim[A_AXIS] += t_alpha;
+          delta_tower_angle_trim[B_AXIS] -= t_beta;
+
           recalc_delta_settings(delta_radius, delta_diagonal_rod);
         }
         else { // !iterate
@@ -5303,28 +5308,18 @@ inline void gcode_G28() {
           COPY(endstop_adj, e_old);
           delta_radius = dr_old;
           home_offset[Z_AXIS] = zh_old;
-
+          delta_tower_angle_trim[A_AXIS] = alpha_old;
+          delta_tower_angle_trim[B_AXIS] = beta_old;
           recalc_delta_settings(delta_radius, delta_diagonal_rod);
         }
 
         // print report
 
-        #if ENABLED(DELTA_CALIBRATE_EXPERT_MODE)
-          if (verbose_level == 3) {
-            const float r_factor =   22.902 * sq(r_diff_max) * r_diff_max
-                                   - 44.988 * sq(r_diff_max)
-                                   + 31.697 * r_diff_max
-                                   - 9.4439;
-            SERIAL_PROTOCOLPAIR("h_factor:", 1.0 / h_diff_min);
-            SERIAL_PROTOCOLPAIR("              r_factor:", r_factor);
-            SERIAL_EOL;
-          }
-        #endif
         if (verbose_level == 2) {
           SERIAL_PROTOCOLPGM(".     c:");
           if (z_at_pt[0] > 0) SERIAL_CHAR('+');
           SERIAL_PROTOCOL_F(z_at_pt[0], 2);
-          if (probe_points > 1) {
+          if (probe_points > 2 || c_value == 2) {
             SERIAL_PROTOCOLPGM("     x:");
             if (z_at_pt[1] >= 0) SERIAL_CHAR('+');
             SERIAL_PROTOCOL_F(z_at_pt[1], 2);
@@ -5335,9 +5330,12 @@ inline void gcode_G28() {
             if (z_at_pt[9] >= 0) SERIAL_CHAR('+');
             SERIAL_PROTOCOL_F(z_at_pt[9], 2);
           }
-          if (probe_points > 0) SERIAL_EOL;
-          if (probe_points > 2 || probe_points == -2) {
-            if (probe_points > 2) SERIAL_PROTOCOLPGM(".            ");
+          if (c_value != -2) SERIAL_EOL;
+          if (probe_points > 2 || c_value == -2) {
+            if (probe_points > 2) {
+              SERIAL_CHAR('.');
+              SERIAL_PROTOCOL_SP(12);
+            }
             SERIAL_PROTOCOLPGM("    yz:");
             if (z_at_pt[7] >= 0) SERIAL_CHAR('+');
             SERIAL_PROTOCOL_F(z_at_pt[7], 2);
@@ -5350,25 +5348,27 @@ inline void gcode_G28() {
             SERIAL_EOL;
           }
         }
-        if (test_precision != 0.0) {            // !forced end
-          if (zero_std_dev >= test_precision) {
+        if (test_precision != 0.0) {                                                             // !forced end
+          if (zero_std_dev >= test_precision) {                                                  // end iterations
             SERIAL_PROTOCOLPGM("Calibration OK");
-            SERIAL_PROTOCOLLNPGM("                                   rolling back 1");
-            LCD_MESSAGEPGM("Calibration OK");
+            SERIAL_PROTOCOL_SP(36);
+            SERIAL_PROTOCOLPGM("rolling back.");
             SERIAL_EOL;
+            LCD_MESSAGEPGM("Calibration OK");
           }
-          else {                                // !end iterations
+          else {                                                                                 // !end iterations
             char mess[15] = "No convergence";
             if (iterations < 31)
               sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
             SERIAL_PROTOCOL(mess);
-            SERIAL_PROTOCOLPGM("                                   std dev:");
+            SERIAL_PROTOCOL_SP(36);
+            SERIAL_PROTOCOLPGM("std dev:");
             SERIAL_PROTOCOL_F(zero_std_dev, 3);
             SERIAL_EOL;
             lcd_setstatus(mess);
           }
-          SERIAL_PROTOCOLPAIR("Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
-          if (abs(probe_points) > 1) {
+          SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
+          if (probe_points > 1) {
             SERIAL_PROTOCOLPGM("    Ex:");
             if (endstop_adj[A_AXIS] >= 0) SERIAL_CHAR('+');
             SERIAL_PROTOCOL_F(endstop_adj[A_AXIS], 2);
@@ -5381,20 +5381,34 @@ inline void gcode_G28() {
             SERIAL_PROTOCOLPAIR("    Radius:", delta_radius);
           }
           SERIAL_EOL;
+          if (c_value > 2) {
+            SERIAL_PROTOCOLPGM(".Tower angle :    Tx:");
+            if (delta_tower_angle_trim[A_AXIS] >= 0) SERIAL_CHAR('+');
+            SERIAL_PROTOCOL_F(delta_tower_angle_trim[A_AXIS], 2);
+            SERIAL_PROTOCOLPGM("  Ty:");
+            if (delta_tower_angle_trim[B_AXIS] >= 0) SERIAL_CHAR('+');
+            SERIAL_PROTOCOL_F(delta_tower_angle_trim[B_AXIS], 2);
+            SERIAL_PROTOCOLPGM("  Tz:+0.00");
+            SERIAL_EOL;
+          }
           if (zero_std_dev >= test_precision)
-            SERIAL_PROTOCOLLNPGM("Save with M500");
+            serialprintPGM(save_message);
         }
-        else {                                  // forced end
-          #if ENABLED(DELTA_CALIBRATE_EXPERT_MODE)
-            if (verbose_level == 3)
-              SERIAL_PROTOCOLLNPGM("Copy to Configuration_adv.h");
-            else
-          #endif
-            {
-              SERIAL_PROTOCOLPGM("End DRY-RUN                                      std dev:");
-              SERIAL_PROTOCOL_F(zero_std_dev, 3);
-              SERIAL_EOL;
-            }
+        else {                                                                                   // forced end
+          if (verbose_level == 0) {
+            SERIAL_PROTOCOLPGM("End DRY-RUN");
+            SERIAL_PROTOCOL_SP(39);
+            SERIAL_PROTOCOLPGM("std dev:");
+            SERIAL_PROTOCOL_F(zero_std_dev, 3);
+            SERIAL_EOL;
+          }
+          else {
+            SERIAL_PROTOCOLLNPGM("Calibration OK");
+            LCD_MESSAGEPGM("Calibration OK");
+            SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
+            SERIAL_EOL;
+            serialprintPGM(save_message);
+          }
         }
 
         clean_up_after_endstop_or_probe_move();
@@ -7620,12 +7634,13 @@ inline void gcode_M205() {
     if (code_seen('L')) delta_diagonal_rod = code_value_linear_units();
     if (code_seen('R')) delta_radius = code_value_linear_units();
     if (code_seen('S')) delta_segments_per_second = code_value_float();
-    if (code_seen('A')) delta_diagonal_rod_trim[A_AXIS] = code_value_linear_units();
-    if (code_seen('B')) delta_diagonal_rod_trim[B_AXIS] = code_value_linear_units();
-    if (code_seen('C')) delta_diagonal_rod_trim[C_AXIS] = code_value_linear_units();
-    if (code_seen('I')) delta_tower_angle_trim[A_AXIS] = code_value_linear_units();
-    if (code_seen('J')) delta_tower_angle_trim[B_AXIS] = code_value_linear_units();
-    if (code_seen('K')) delta_tower_angle_trim[C_AXIS] = code_value_linear_units();
+    if (code_seen('B')) delta_calibration_radius = code_value_float();
+    if (code_seen('X')) delta_tower_angle_trim[A_AXIS] = code_value_linear_units();
+    if (code_seen('Y')) delta_tower_angle_trim[B_AXIS] = code_value_linear_units();
+    if (code_seen('Z')) { // rotate all 3 axis for Z = 0
+      delta_tower_angle_trim[A_AXIS] -= code_value_linear_units();
+      delta_tower_angle_trim[B_AXIS] -= code_value_linear_units();
+    }
     recalc_delta_settings(delta_radius, delta_diagonal_rod);
   }
   /**
@@ -7653,6 +7668,10 @@ inline void gcode_M205() {
         SERIAL_ECHOLNPGM("<<< gcode_M666");
       }
     #endif
+    // normalize endstops so all are <=0; set the residue to delta height
+    const float z_temp = MAX3(endstop_adj[A_AXIS], endstop_adj[B_AXIS], endstop_adj[C_AXIS]);
+    home_offset[Z_AXIS] -= z_temp;
+    LOOP_XYZ(i) endstop_adj[i] -= z_temp;
   }
 
 #elif ENABLED(Z_DUAL_ENDSTOPS) // !DELTA && ENABLED(Z_DUAL_ENDSTOPS)
@@ -8564,7 +8583,7 @@ inline void gcode_M503() {
 
     if (!isnan(last_zoffset)) {
 
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(BABYSTEP_ZPROBE_OFFSET)
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(BABYSTEP_ZPROBE_OFFSET) || ENABLED(DELTA)
         const float diff = zprobe_zoffset - last_zoffset;
       #endif
 
@@ -8586,6 +8605,10 @@ inline void gcode_M503() {
       #else
         UNUSED(no_babystep);
       #endif
+
+      #if ENABLED(DELTA) // correct the delta_height
+        home_offset[Z_AXIS] -= diff;
+      #endif
     }
 
     last_zoffset = zprobe_zoffset;
@@ -10651,15 +10674,17 @@ void ok_to_send() {
    * settings have been changed (e.g., by M665).
    */
   void recalc_delta_settings(float radius, float diagonal_rod) {
-    delta_tower[A_AXIS][X_AXIS] = -sin(RADIANS(60 - delta_tower_angle_trim[A_AXIS])) * (radius + DELTA_RADIUS_TRIM_TOWER_1); // front left tower
-    delta_tower[A_AXIS][Y_AXIS] = -cos(RADIANS(60 - delta_tower_angle_trim[A_AXIS])) * (radius + DELTA_RADIUS_TRIM_TOWER_1);
-    delta_tower[B_AXIS][X_AXIS] =  sin(RADIANS(60 + delta_tower_angle_trim[B_AXIS])) * (radius + DELTA_RADIUS_TRIM_TOWER_2); // front right tower
-    delta_tower[B_AXIS][Y_AXIS] = -cos(RADIANS(60 + delta_tower_angle_trim[B_AXIS])) * (radius + DELTA_RADIUS_TRIM_TOWER_2);
-    delta_tower[C_AXIS][X_AXIS] = -sin(RADIANS(     delta_tower_angle_trim[C_AXIS])) * (radius + DELTA_RADIUS_TRIM_TOWER_3); // back middle tower
-    delta_tower[C_AXIS][Y_AXIS] =  cos(RADIANS(     delta_tower_angle_trim[C_AXIS])) * (radius + DELTA_RADIUS_TRIM_TOWER_3);
-    delta_diagonal_rod_2_tower[A_AXIS] = sq(diagonal_rod + delta_diagonal_rod_trim[A_AXIS]);
-    delta_diagonal_rod_2_tower[B_AXIS] = sq(diagonal_rod + delta_diagonal_rod_trim[B_AXIS]);
-    delta_diagonal_rod_2_tower[C_AXIS] = sq(diagonal_rod + delta_diagonal_rod_trim[C_AXIS]);
+    const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
+                drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
+    delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (radius + trt[A_AXIS]); // front left tower
+    delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (radius + trt[A_AXIS]);
+    delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (radius + trt[B_AXIS]); // front right tower
+    delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (radius + trt[B_AXIS]);
+    delta_tower[C_AXIS][X_AXIS] = 0.0; // back middle tower
+    delta_tower[C_AXIS][Y_AXIS] = (radius + trt[C_AXIS]);
+    delta_diagonal_rod_2_tower[A_AXIS] = sq(diagonal_rod + drt[A_AXIS]);
+    delta_diagonal_rod_2_tower[B_AXIS] = sq(diagonal_rod + drt[B_AXIS]);
+    delta_diagonal_rod_2_tower[C_AXIS] = sq(diagonal_rod + drt[C_AXIS]);
   }
 
   #if ENABLED(DELTA_FAST_SQRT)
diff --git a/Marlin/configuration_store.cpp b/Marlin/configuration_store.cpp
index 61e6e99108d..dfb992d1ba3 100755
--- a/Marlin/configuration_store.cpp
+++ b/Marlin/configuration_store.cpp
@@ -97,12 +97,10 @@
  *  360  M665 R    delta_radius                     (float)
  *  364  M665 L    delta_diagonal_rod               (float)
  *  368  M665 S    delta_segments_per_second        (float)
- *  372  M665 A    delta_diagonal_rod_trim[A]       (float)
- *  376  M665 B    delta_diagonal_rod_trim[B]       (float)
- *  380  M665 C    delta_diagonal_rod_trim[C]       (float)
- *  384  M665 I    delta_tower_angle_trim[A]        (float)
- *  388  M665 J    delta_tower_angle_trim[B]        (float)
- *  392  M665 K    delta_tower_angle_trim[C]        (float)
+ *  372  M665 B    delta_calibration_radius         (float)
+ *  376  M665 X    delta_tower_angle_trim[A]        (float)
+ *  380  M665 Y    delta_tower_angle_trim[B]        (float)
+ *  ---  M665 Z    delta_tower_angle_trim[C]        (float) is always 0.0
  *
  * Z_DUAL_ENDSTOPS:                                 48 bytes
  *  348  M666 Z    z_endstop_adj                    (float)
@@ -428,8 +426,8 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(delta_radius);              // 1 float
       EEPROM_WRITE(delta_diagonal_rod);        // 1 float
       EEPROM_WRITE(delta_segments_per_second); // 1 float
-      EEPROM_WRITE(delta_diagonal_rod_trim);   // 3 floats
-      EEPROM_WRITE(delta_tower_angle_trim);    // 3 floats
+      EEPROM_WRITE(delta_calibration_radius);  // 1 floats
+      EEPROM_WRITE(delta_tower_angle_trim);    // 2 floats
     #elif ENABLED(Z_DUAL_ENDSTOPS)
       EEPROM_WRITE(z_endstop_adj);             // 1 float
       dummy = 0.0f;
@@ -802,8 +800,8 @@ void MarlinSettings::postprocess() {
         EEPROM_READ(delta_radius);              // 1 float
         EEPROM_READ(delta_diagonal_rod);        // 1 float
         EEPROM_READ(delta_segments_per_second); // 1 float
-        EEPROM_READ(delta_diagonal_rod_trim);   // 3 floats
-        EEPROM_READ(delta_tower_angle_trim);    // 3 floats
+        EEPROM_READ(delta_calibration_radius);  // 1 floats
+        EEPROM_READ(delta_tower_angle_trim);    // 2 floats
       #elif ENABLED(Z_DUAL_ENDSTOPS)
         EEPROM_READ(z_endstop_adj);
         dummy = 0.0f;
@@ -1079,14 +1077,14 @@ void MarlinSettings::reset() {
 
   #if ENABLED(DELTA)
     const float adj[ABC] = DELTA_ENDSTOP_ADJ,
-                drt[ABC] = { DELTA_DIAGONAL_ROD_TRIM_TOWER_1, DELTA_DIAGONAL_ROD_TRIM_TOWER_2, DELTA_DIAGONAL_ROD_TRIM_TOWER_3 },
-                dta[ABC] = { DELTA_TOWER_ANGLE_TRIM_1, DELTA_TOWER_ANGLE_TRIM_2, DELTA_TOWER_ANGLE_TRIM_3 };
+                dta[2] = DELTA_TOWER_ANGLE_TRIM;
     COPY(endstop_adj, adj);
     delta_radius = DELTA_RADIUS;
     delta_diagonal_rod = DELTA_DIAGONAL_ROD;
     delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
-    COPY(delta_diagonal_rod_trim, drt);
-    COPY(delta_tower_angle_trim, dta);
+    delta_calibration_radius = DELTA_CALIBRATION_RADIUS;
+    delta_tower_angle_trim[A_AXIS] = dta[A_AXIS] - dta[C_AXIS];
+    delta_tower_angle_trim[B_AXIS] = dta[B_AXIS] - dta[C_AXIS];
     home_offset[Z_AXIS] = 0;
 
   #elif ENABLED(Z_DUAL_ENDSTOPS)
@@ -1488,19 +1486,18 @@ void MarlinSettings::reset() {
       SERIAL_ECHOLNPAIR(" Z", LINEAR_UNIT(endstop_adj[Z_AXIS]));
       if (!forReplay) {
         CONFIG_ECHO_START;
-        SERIAL_ECHOLNPGM("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> ABC<diagonal_rod_[123]_trim>");
+        SERIAL_ECHOLNPGM("Delta settings: L<diagonal_rod> R<radius> H<height> S<segments_per_s> B<calibration radius> XYZ<tower angle corrections>");
       }
       CONFIG_ECHO_START;
       SERIAL_ECHOPAIR("  M665 L", LINEAR_UNIT(delta_diagonal_rod));
       SERIAL_ECHOPAIR(" R", LINEAR_UNIT(delta_radius));
       SERIAL_ECHOPAIR(" H", LINEAR_UNIT(DELTA_HEIGHT + home_offset[Z_AXIS]));
       SERIAL_ECHOPAIR(" S", delta_segments_per_second);
-      SERIAL_ECHOPAIR(" A", LINEAR_UNIT(delta_diagonal_rod_trim[A_AXIS]));
-      SERIAL_ECHOPAIR(" B", LINEAR_UNIT(delta_diagonal_rod_trim[B_AXIS]));
-      SERIAL_ECHOPAIR(" C", LINEAR_UNIT(delta_diagonal_rod_trim[C_AXIS]));
-      SERIAL_ECHOPAIR(" I", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS]));
-      SERIAL_ECHOPAIR(" J", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS]));
-      SERIAL_ECHOLNPAIR(" K", LINEAR_UNIT(delta_tower_angle_trim[C_AXIS]));
+      SERIAL_ECHOPAIR(" B", LINEAR_UNIT(delta_calibration_radius));
+      SERIAL_ECHOPAIR(" X", LINEAR_UNIT(delta_tower_angle_trim[A_AXIS]));
+      SERIAL_ECHOPAIR(" Y", LINEAR_UNIT(delta_tower_angle_trim[B_AXIS]));
+      SERIAL_ECHOPAIR(" Z", 0.00);
+      SERIAL_EOL;
     #elif ENABLED(Z_DUAL_ENDSTOPS)
       if (!forReplay) {
         CONFIG_ECHO_START;
diff --git a/Marlin/example_configurations/delta/FLSUN/auto_calibrate/Configuration.h b/Marlin/example_configurations/delta/FLSUN/auto_calibrate/Configuration.h
index 5e1f3facc6a..188c2d09753 100644
--- a/Marlin/example_configurations/delta/FLSUN/auto_calibrate/Configuration.h
+++ b/Marlin/example_configurations/delta/FLSUN/auto_calibrate/Configuration.h
@@ -1,4 +1,4 @@
-/**
+﻿/**
  * Marlin 3D Printer Firmware
  * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -446,53 +446,56 @@
   // and processor overload (too many expensive sqrt calls).
   #define DELTA_SEGMENTS_PER_SECOND 160
 
+  // NOTE NB all values for DELTA_* values MUST be floating point, so always have a decimal point in them
+
   // Center-to-center distance of the holes in the diagonal push rods.
   #define DELTA_DIAGONAL_ROD 218.0 // mm
-
+/*
   // Horizontal offset from middle of printer to smooth rod center.
-  //#define DELTA_SMOOTH_ROD_OFFSET 150.0 // mm
+  #define DELTA_SMOOTH_ROD_OFFSET 150.0 // mm
 
   // Horizontal offset of the universal joints on the end effector.
-  //#define DELTA_EFFECTOR_OFFSET 24.0 // mm
+  #define DELTA_EFFECTOR_OFFSET 24.0 // mm
 
   // Horizontal offset of the universal joints on the carriages.
-  //#define DELTA_CARRIAGE_OFFSET 22.0 // mm
-
+  #define DELTA_CARRIAGE_OFFSET 22.0 // mm
+*/
   // Horizontal distance bridged by diagonal push rods when effector is centered.
-  #define DELTA_RADIUS 100.59 //mm // get this value from auto calibrate
+  #define DELTA_RADIUS 100.00 //mm // get this value from auto calibrate
 
   // height from z=0.00 to home position
-  #define DELTA_HEIGHT 298.95 // get this value from auto calibrate
+  #define DELTA_HEIGHT 295.00 // get this value from auto calibrate - use G33 C-1 at 1st time calibration
 
   // Print surface diameter/2 minus unreachable space (avoid collisions with vertical towers).
-  #define DELTA_PRINTABLE_RADIUS 90.0
+  #define DELTA_PRINTABLE_RADIUS 85.0
 
   // Delta calibration menu
+  // uncomment to add three points calibration menu option.
   // See http://minow.blogspot.com/index.html#4918805519571907051
   #define DELTA_CALIBRATION_MENU
 
+  // set the radius for the calibration probe points - max 0.8 * DELTA_PRINTABLE_RADIUS if DELTA_AUTO_CALIBRATION enabled
+  #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 17) // mm
+
   // G33 Delta Auto-Calibration (Enable EEPROM_SETTINGS to store results)
   #define DELTA_AUTO_CALIBRATION
   #if ENABLED(DELTA_AUTO_CALIBRATION)
-    #define DELTA_CALIBRATION_DEFAULT_POINTS 3 // set the default number of probe points : n*n (1-4)
-    #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 15) // set the radius for the calibration probe points
+    #define DELTA_CALIBRATION_DEFAULT_POINTS 4 // set the default number of probe points : n*n (-7 -> +7)
   #endif
 
   // After homing move down to a height where XY movement is unconstrained
   #define DELTA_HOME_TO_SAFE_ZONE
 
-  #define DELTA_ENDSTOP_ADJ { -0.05, -0.00, -0.02 } // get these from auto calibrate
+  #define DELTA_ENDSTOP_ADJ { -0.00, -0.00, -0.00 } // get these from auto calibrate
 
   // Trim adjustments for individual towers
-  #define DELTA_RADIUS_TRIM_TOWER_1 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_2 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_3 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_1 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_2 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_3 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_1 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_2 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_3 0.0
+  // tower angle corrections for X and Y tower / rotate XYZ so Z tower angle = 0
+  // measured in degrees anticlockwise looking from above the printer
+  #define DELTA_TOWER_ANGLE_TRIM { 0.00, 0.00 } // get these from auto calibrate
+
+  // delta radius and diaginal rod adjustments measured in mm
+  //#define DELTA_RADIUS_TRIM_TOWER {0.0, 0.0, 0.0}
+  //#define DELTA_DIAGONAL_ROD_TRIM_TOWER {0.0, 0.0, 0.0}
 
 #endif
 
@@ -529,7 +532,7 @@
 // Mechanical endstop with COM to ground and NC to Signal uses "false" here (most common setup).
 #define X_MIN_ENDSTOP_INVERTING false // set to true to invert the logic of the endstop.
 #define Y_MIN_ENDSTOP_INVERTING false // set to true to invert the logic of the endstop.
-#define Z_MIN_ENDSTOP_INVERTING true // set to true to invert the logic of the endstop.
+#define Z_MIN_ENDSTOP_INVERTING true  // set to true to invert the logic of the endstop.
 #define X_MAX_ENDSTOP_INVERTING false // set to true to invert the logic of the endstop.
 #define Y_MAX_ENDSTOP_INVERTING false // set to true to invert the logic of the endstop.
 #define Z_MAX_ENDSTOP_INVERTING false // set to true to invert the logic of the endstop.
@@ -601,7 +604,7 @@
 #define DEFAULT_XJERK                 20.0
 #define DEFAULT_YJERK                 DEFAULT_XJERK
 #define DEFAULT_ZJERK                 DEFAULT_YJERK // Must be same as XY for delta
-#define DEFAULT_EJERK                  5.0
+#define DEFAULT_EJERK                 5.0
 
 
 /**
@@ -668,9 +671,6 @@
  *   is enabled then it also applies to Z_PROBE_SPEED_SLOW.
  */
 
-// A probe that is deployed and stowed with a solenoid pin (SOL1_PIN)
-//#define SOLENOID_PROBE
-
 // Enable if you have a Z probe mounted on a sled like those designed by Charles Bell.
 //#define Z_PROBE_SLED
 //#define SLED_DOCKING_OFFSET 5  // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.
@@ -695,8 +695,8 @@
  *    (0,0)
  */
 #define X_PROBE_OFFSET_FROM_EXTRUDER 0     // X offset: -left  +right  [of the nozzle]
-#define Y_PROBE_OFFSET_FROM_EXTRUDER 0   // Y offset: -front +behind [the nozzle]
-#define Z_PROBE_OFFSET_FROM_EXTRUDER 0.25  // Z offset: -below +above  [the nozzle]
+#define Y_PROBE_OFFSET_FROM_EXTRUDER 0     // Y offset: -front +behind [the nozzle]
+#define Z_PROBE_OFFSET_FROM_EXTRUDER 0.10  // Z offset: -below +above  [the nozzle]
 
 // X and Y axis travel speed (mm/m) between probes
 #define XY_PROBE_SPEED 5000
@@ -705,7 +705,7 @@
 #define Z_PROBE_SPEED_FAST HOMING_FEEDRATE_Z
 
 // Speed for the "accurate" probe of each point
-#define Z_PROBE_SPEED_SLOW (Z_PROBE_SPEED_FAST / 4)
+#define Z_PROBE_SPEED_SLOW (Z_PROBE_SPEED_FAST / 6)
 
 // Use double touch for probing
 //#define PROBE_DOUBLE_TOUCH
@@ -729,7 +729,7 @@
   #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X 0.0
   #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y DELTA_PRINTABLE_RADIUS
   #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z 100.0
-  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE (XY_PROBE_SPEED)/10
+  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE (XY_PROBE_SPEED/10)
 
   #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X Z_PROBE_ALLEN_KEY_DEPLOY_2_X * 0.75
   #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y Z_PROBE_ALLEN_KEY_DEPLOY_2_Y * 0.75
@@ -835,8 +835,8 @@
  * Example: `M851 Z-5` with a CLEARANCE of 4  =>  9mm from bed to nozzle.
  *     But: `M851 Z+1` with a CLEARANCE of 2  =>  2mm from bed to nozzle.
  */
-#define Z_CLEARANCE_DEPLOY_PROBE   10 // Z Clearance for Deploy/Stow
-#define Z_CLEARANCE_BETWEEN_PROBES  3 // Z Clearance between probe points
+#define Z_CLEARANCE_DEPLOY_PROBE    5 // Z Clearance for Deploy/Stow
+#define Z_CLEARANCE_BETWEEN_PROBES  2 // Z Clearance between probe points
 
 // For M851 give a range for adjusting the Z probe offset
 #define Z_PROBE_OFFSET_RANGE_MIN -20
@@ -865,11 +865,11 @@
 // @section machine
 
 // Invert the stepper direction. Change (or reverse the motor connector) if an axis goes the wrong way.
-#define INVERT_X_DIR true
+#define INVERT_X_DIR true // DELTA does not invert
 #define INVERT_Y_DIR true
 #define INVERT_Z_DIR true
 
-// Enable this option for Toshiba stepper drivers
+// Enable this option for Toshiba steppers
 //#define CONFIG_STEPPERS_TOSHIBA
 
 // @section extruder
@@ -967,7 +967,7 @@
  */
 //#define AUTO_BED_LEVELING_3POINT
 //#define AUTO_BED_LEVELING_LINEAR
-#define AUTO_BED_LEVELING_BILINEAR
+//#define AUTO_BED_LEVELING_BILINEAR
 //#define AUTO_BED_LEVELING_UBL
 //#define MESH_BED_LEVELING
 
@@ -988,8 +988,7 @@
 #if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
   // Set the number of grid points per dimension.
-  // Works best with 5 or more points in each dimension.
-  #define GRID_MAX_POINTS_X 9
+  #define GRID_MAX_POINTS_X 7
   #define GRID_MAX_POINTS_Y GRID_MAX_POINTS_X
 
   // Set the boundaries for probing (where the probe can reach).
@@ -1000,12 +999,13 @@
   #define BACK_PROBE_BED_POSITION DELTA_PROBEABLE_RADIUS
 
   // The Z probe minimum outer margin (to validate G29 parameters).
-  #define MIN_PROBE_EDGE 10
+  #define MIN_PROBE_EDGE 20
 
   // Probe along the Y axis, advancing X after each column
   //#define PROBE_Y_FIRST
 
   #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
     //
     // Experimental Subdivision of the grid by Catmull-Rom method.
     // Synthesizes intermediate points to produce a more detailed mesh.
@@ -1155,8 +1155,8 @@
 // @section temperature
 
 // Preheat Constants
-#define PREHEAT_1_TEMP_HOTEND 185
-#define PREHEAT_1_TEMP_BED     70
+#define PREHEAT_1_TEMP_HOTEND 195
+#define PREHEAT_1_TEMP_BED     60
 #define PREHEAT_1_FAN_SPEED     0 // Value from 0 to 255
 
 #define PREHEAT_2_TEMP_HOTEND 240
@@ -1402,6 +1402,7 @@
 //
 // Add individual axis homing items (Home X, Home Y, and Home Z) to the LCD menu.
 //
+// INDIVIDUAL_AXIS_HOMING_MENU is incompatible with DELTA kinematics.
 //#define INDIVIDUAL_AXIS_HOMING_MENU
 
 //
@@ -1730,8 +1731,8 @@
   #define FILAMENT_SENSOR_EXTRUDER_NUM 0    // Index of the extruder that has the filament sensor (0,1,2,3)
   #define MEASUREMENT_DELAY_CM        14    // (cm) The distance from the filament sensor to the melting chamber
 
-  #define MEASURED_UPPER_LIMIT         3.30 // (mm) Upper limit used to validate sensor reading
-  #define MEASURED_LOWER_LIMIT         1.90 // (mm) Lower limit used to validate sensor reading
+  #define MEASURED_UPPER_LIMIT         1.95 // (mm) Upper limit used to validate sensor reading
+  #define MEASURED_LOWER_LIMIT         1.20 // (mm) Lower limit used to validate sensor reading
   #define MAX_MEASUREMENT_DELAY       20    // (bytes) Buffer size for stored measurements (1 byte per cm). Must be larger than MEASUREMENT_DELAY_CM.
 
   #define DEFAULT_MEASURED_FILAMENT_DIA DEFAULT_NOMINAL_FILAMENT_DIA // Set measured to nominal initially
diff --git a/Marlin/example_configurations/delta/FLSUN/auto_calibrate/Configuration_adv.h b/Marlin/example_configurations/delta/FLSUN/auto_calibrate/Configuration_adv.h
index 220bfa47137..166c4b626fc 100644
--- a/Marlin/example_configurations/delta/FLSUN/auto_calibrate/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/FLSUN/auto_calibrate/Configuration_adv.h
@@ -431,25 +431,6 @@
 // Actual motor currents in Amps, need as many here as DIGIPOT_I2C_NUM_CHANNELS
 #define DIGIPOT_I2C_MOTOR_CURRENTS {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}  //  AZTEEG_X3_PRO
 
-//===========================================================================
-//============================== Delta Settings =============================
-//===========================================================================
-
-#if ENABLED(DELTA_AUTO_CALIBRATION)
-  /**
-   * Set the height short (H-10) with M665 Hx.xx.
-   * Set the delta_radius offset (R-5, R-10, R+5, R+10) with M665 Rx.xx.
-   * Run G33 Cx V3 (C2, C-2) with different values for C and R
-   * Take the average for R_FACTOR and maximum for H_FACTOR.
-   * Run the tests with default values!!!
-   */
-  //#define DELTA_CALIBRATE_EXPERT_MODE
-
-  // Remove the comments of the folling 2 lines to overide default values
-  #define H_FACTOR  1.02 //  1.0 < H_FACTOR <  1.11, default  1.00
-  #define R_FACTOR -3.95 // -6.7 < R_FACTOR < -2.25, default -2.25
-#endif
-
 //===========================================================================
 //=============================Additional Features===========================
 //===========================================================================
diff --git a/Marlin/example_configurations/delta/FLSUN/kossel_mini/Configuration.h b/Marlin/example_configurations/delta/FLSUN/kossel_mini/Configuration.h
index 1c468198d0a..02cc7702c9d 100644
--- a/Marlin/example_configurations/delta/FLSUN/kossel_mini/Configuration.h
+++ b/Marlin/example_configurations/delta/FLSUN/kossel_mini/Configuration.h
@@ -448,7 +448,7 @@
 
   // Center-to-center distance of the holes in the diagonal push rods.
   #define DELTA_DIAGONAL_ROD 218.0 // mm
-
+/*
   // Horizontal offset from middle of printer to smooth rod center.
   #define DELTA_SMOOTH_ROD_OFFSET 150.0 // mm
 
@@ -457,12 +457,12 @@
 
   // Horizontal offset of the universal joints on the carriages.
   #define DELTA_CARRIAGE_OFFSET 22.0 // mm
-
+*/
   // Horizontal distance bridged by diagonal push rods when effector is centered.
-  #define DELTA_RADIUS (DELTA_SMOOTH_ROD_OFFSET-(DELTA_EFFECTOR_OFFSET)-(DELTA_CARRIAGE_OFFSET))
+  #define DELTA_RADIUS 104 //mm // get this value from auto calibrate
 
   // height from z=0.00 to home position
-  #define DELTA_HEIGHT 280 // get this value from auto calibrate
+  #define DELTA_HEIGHT 280 // get this value from auto calibrate - use G33 C-1 at 1st time calibration
 
   // Print surface diameter/2 minus unreachable space (avoid collisions with vertical towers).
   #define DELTA_PRINTABLE_RADIUS 85.0
@@ -470,30 +470,30 @@
   // Delta calibration menu
   // uncomment to add three points calibration menu option.
   // See http://minow.blogspot.com/index.html#4918805519571907051
-  //#define DELTA_CALIBRATION_MENU
+  #define DELTA_CALIBRATION_MENU
+
+  // set the radius for the calibration probe points - max 0.8 * DELTA_PRINTABLE_RADIUS if DELTA_AUTO_CALIBRATION enabled
+  #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 17) // mm
 
   // G33 Delta Auto-Calibration (Enable EEPROM_SETTINGS to store results)
-  //#define DELTA_AUTO_CALIBRATION
+  #define DELTA_AUTO_CALIBRATION
   #if ENABLED(DELTA_AUTO_CALIBRATION)
-    #define DELTA_CALIBRATION_DEFAULT_POINTS 3 // set the default number of probe points : n*n (1-4)
-    #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 15) // set the radius for the calibration probe points
+    #define DELTA_CALIBRATION_DEFAULT_POINTS 3 // set the default number of probe points : n*n (-7 -> +7)
   #endif
 
   // After homing move down to a height where XY movement is unconstrained
-  //#define DELTA_HOME_TO_SAFE_ZONE
+  #define DELTA_HOME_TO_SAFE_ZONE
 
-  //#define DELTA_ENDSTOP_ADJ { 0, 0, 0 }
+  #define DELTA_ENDSTOP_ADJ { -0.00, -0.00, -0.00 } // get these from auto calibrate
 
   // Trim adjustments for individual towers
-  #define DELTA_RADIUS_TRIM_TOWER_1 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_2 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_3 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_1 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_2 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_3 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_1 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_2 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_3 0.0
+  // tower angle corrections for X and Y tower / rotate XYZ so Z tower angle = 0
+  // measured in degrees anticlockwise looking from above the printer
+  #define DELTA_TOWER_ANGLE_TRIM { 0.00, 0.00 } // get these from auto calibrate
+
+  // delta radius and diaginal rod adjustments measured in mm
+  //#define DELTA_RADIUS_TRIM_TOWER {0.0, 0.0, 0.0}
+  //#define DELTA_DIAGONAL_ROD_TRIM_TOWER {0.0, 0.0, 0.0}
 
 #endif
 
diff --git a/Marlin/example_configurations/delta/FLSUN/kossel_mini/Configuration_adv.h b/Marlin/example_configurations/delta/FLSUN/kossel_mini/Configuration_adv.h
index eed1171b9ea..b28d8e0d447 100644
--- a/Marlin/example_configurations/delta/FLSUN/kossel_mini/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/FLSUN/kossel_mini/Configuration_adv.h
@@ -1,4 +1,4 @@
-/**
+﻿/**
  * Marlin 3D Printer Firmware
  * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -431,25 +431,6 @@
 // Actual motor currents in Amps, need as many here as DIGIPOT_I2C_NUM_CHANNELS
 #define DIGIPOT_I2C_MOTOR_CURRENTS {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}  //  AZTEEG_X3_PRO
 
-//===========================================================================
-//============================== Delta Settings =============================
-//===========================================================================
-
-#if ENABLED(DELTA_AUTO_CALIBRATION)
-  /**
-   * Set the height short (H-10) with M665 Hx.xx.
-   * Set the delta_radius offset (R-5, R-10, R+5, R+10) with M665 Rx.xx.
-   * Run G33 Cx V3 (C2, C-2) with different values for C and R
-   * Take the average for R_FACTOR and maximum for H_FACTOR.
-   * Run the tests with default values!!!
-   */
-  //#define DELTA_CALIBRATE_EXPERT_MODE
-
-  // Remove the comments of the folling 2 lines to overide default values
-  #define H_FACTOR  1.02 //  1.0 < H_FACTOR <  1.11, default  1.00
-  #define R_FACTOR -3.95 // -6.7 < R_FACTOR < -2.25, default -2.25
-#endif
-
 //===========================================================================
 //=============================Additional Features===========================
 //===========================================================================
diff --git a/Marlin/example_configurations/delta/generic/Configuration.h b/Marlin/example_configurations/delta/generic/Configuration.h
index 3cdda90028e..d9f89ca435a 100644
--- a/Marlin/example_configurations/delta/generic/Configuration.h
+++ b/Marlin/example_configurations/delta/generic/Configuration.h
@@ -438,7 +438,7 @@
 
   // Center-to-center distance of the holes in the diagonal push rods.
   #define DELTA_DIAGONAL_ROD 250.0 // mm
-
+/*
   // Horizontal offset from middle of printer to smooth rod center.
   #define DELTA_SMOOTH_ROD_OFFSET 175.0 // mm
 
@@ -447,42 +447,40 @@
 
   // Horizontal offset of the universal joints on the carriages.
   #define DELTA_CARRIAGE_OFFSET 18.0 // mm
-
+*/
   // Horizontal distance bridged by diagonal push rods when effector is centered.
-  #define DELTA_RADIUS (DELTA_SMOOTH_ROD_OFFSET-(DELTA_EFFECTOR_OFFSET)-(DELTA_CARRIAGE_OFFSET))
-
-  // height from z=0.00 to home position
-  #define DELTA_HEIGHT 250 // get this value from auto calibrate
+  #define DELTA_RADIUS 125 //mm // get this value from auto calibrate  // height from z=0.00 to home position
+  #define DELTA_HEIGHT 250 // get this value from auto calibrate - use G33 C-1 at 1st time calibration
 
   // Print surface diameter/2 minus unreachable space (avoid collisions with vertical towers).
   #define DELTA_PRINTABLE_RADIUS 140.0
 
   // Delta calibration menu
   // See http://minow.blogspot.com/index.html#4918805519571907051
-  //#define DELTA_CALIBRATION_MENU
+  #define DELTA_CALIBRATION_MENU
+
+  // set the radius for the calibration probe points - max 0.8 * DELTA_PRINTABLE_RADIUS if DELTA_AUTO_CALIBRATION enabled
+  #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 28) // mm
 
   // G33 Delta Auto-Calibration (Enable EEPROM_SETTINGS to store results)
-  //#define DELTA_AUTO_CALIBRATION
+  #define DELTA_AUTO_CALIBRATION
   #if ENABLED(DELTA_AUTO_CALIBRATION)
-    #define DELTA_CALIBRATION_DEFAULT_POINTS 3 // set the default number of probe points : n*n (1-4)
-    #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 15) // set the radius for the calibration probe points
+    #define DELTA_CALIBRATION_DEFAULT_POINTS 3 // set the default number of probe points : n*n (-7 -> +7)
   #endif
 
   // After homing move down to a height where XY movement is unconstrained
   #define DELTA_HOME_TO_SAFE_ZONE
 
-  //#define DELTA_ENDSTOP_ADJ { 0, 0, 0 }
+  #define DELTA_ENDSTOP_ADJ { -0.00, -0.00, -0.00 } // get these from auto calibrate
 
   // Trim adjustments for individual towers
-  #define DELTA_RADIUS_TRIM_TOWER_1 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_2 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_3 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_1 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_2 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_3 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_1 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_2 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_3 0.0
+  // tower angle corrections for X and Y tower / rotate XYZ so Z tower angle = 0
+  // measured in degrees anticlockwise looking from above the printer
+  #define DELTA_TOWER_ANGLE_TRIM { 0.00, 0.00 } // get these from auto calibrate
+
+  // delta radius and diaginal rod adjustments measured in mm
+  //#define DELTA_RADIUS_TRIM_TOWER {0.0, 0.0, 0.0}
+  //#define DELTA_DIAGONAL_ROD_TRIM_TOWER {0.0, 0.0, 0.0}
 
 #endif
 
diff --git a/Marlin/example_configurations/delta/generic/Configuration_adv.h b/Marlin/example_configurations/delta/generic/Configuration_adv.h
index 7de00f0806f..d1ebc9a38c5 100644
--- a/Marlin/example_configurations/delta/generic/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/generic/Configuration_adv.h
@@ -1,4 +1,4 @@
-/**
+﻿/**
  * Marlin 3D Printer Firmware
  * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -431,25 +431,6 @@
 // Actual motor currents in Amps, need as many here as DIGIPOT_I2C_NUM_CHANNELS
 #define DIGIPOT_I2C_MOTOR_CURRENTS {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}  //  AZTEEG_X3_PRO
 
-//===========================================================================
-//============================== Delta Settings =============================
-//===========================================================================
-
-#if ENABLED(DELTA_AUTO_CALIBRATION)
-  /**
-   * Set the height short (H-10) with M665 Hx.xx.
-   * Set the delta_radius offset (R-5, R-10, R+5, R+10) with M665 Rx.xx.
-   * Run G33 Cx V3 (C2, C-2) with different values for C and R
-   * Take the average for R_FACTOR and maximum for H_FACTOR.
-   * Run the tests with default values!!!
-   */
-  //#define DELTA_CALIBRATE_EXPERT_MODE
-
-  // Remove the comments of the folling 2 lines to overide default values
-  //#define H_FACTOR  1.02 //  1.0 < H_FACTOR <  1.11, default  1.00
-  //#define R_FACTOR -3.95 // -6.7 < R_FACTOR < -2.25, default -2.25
-#endif
-
 //===========================================================================
 //=============================Additional Features===========================
 //===========================================================================
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration.h b/Marlin/example_configurations/delta/kossel_mini/Configuration.h
index c5f5c5c07bb..bc28e71b9d5 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration.h
@@ -438,7 +438,7 @@
 
   // Center-to-center distance of the holes in the diagonal push rods.
   #define DELTA_DIAGONAL_ROD 215.0 // mm
-
+/*
   // Horizontal offset from middle of printer to smooth rod center.
   #define DELTA_SMOOTH_ROD_OFFSET 145.0 // mm
 
@@ -447,42 +447,42 @@
 
   // Horizontal offset of the universal joints on the carriages.
   #define DELTA_CARRIAGE_OFFSET 19.5 // mm
-
+*/
   // Horizontal distance bridged by diagonal push rods when effector is centered.
-  #define DELTA_RADIUS (DELTA_SMOOTH_ROD_OFFSET-(DELTA_EFFECTOR_OFFSET)-(DELTA_CARRIAGE_OFFSET))
+  #define DELTA_RADIUS 105 //mm // get this value from auto calibrate
 
   // height from z=0.00 to home position
-  #define DELTA_HEIGHT 250 // get this value from auto calibrate
+  #define DELTA_HEIGHT 250 // get this value from auto calibrate - use G33 C-1 at 1st time calibration
 
   // Print surface diameter/2 minus unreachable space (avoid collisions with vertical towers).
   #define DELTA_PRINTABLE_RADIUS 90.0
 
   // Delta calibration menu
   // See http://minow.blogspot.com/index.html#4918805519571907051
-  //#define DELTA_CALIBRATION_MENU
+  #define DELTA_CALIBRATION_MENU
+
+  // set the radius for the calibration probe points - max 0.8 * DELTA_PRINTABLE_RADIUS if DELTA_AUTO_CALIBRATION enabled
+  #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 18) // mm
 
   // G33 Delta Auto-Calibration (Enable EEPROM_SETTINGS to store results)
-  //#define DELTA_AUTO_CALIBRATION
+  #define DELTA_AUTO_CALIBRATION
   #if ENABLED(DELTA_AUTO_CALIBRATION)
-    #define DELTA_CALIBRATION_DEFAULT_POINTS 3 // set the default number of probe points : n*n (1-4)
-    #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 15) // set the radius for the calibration probe points
+    #define DELTA_CALIBRATION_DEFAULT_POINTS 3 // set the default number of probe points : n*n (-7 -> +7)
   #endif
 
   // After homing move down to a height where XY movement is unconstrained
   #define DELTA_HOME_TO_SAFE_ZONE
 
-  //#define DELTA_ENDSTOP_ADJ { 0, 0, 0 }
+  #define DELTA_ENDSTOP_ADJ { -0.00, -0.00, -0.00 } // get these from auto calibrate
 
   // Trim adjustments for individual towers
-  #define DELTA_RADIUS_TRIM_TOWER_1 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_2 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_3 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_1 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_2 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_3 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_1 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_2 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_3 0.0
+  // tower angle corrections for X and Y tower / rotate XYZ so Z tower angle = 0
+  // measured in degrees anticlockwise looking from above the printer
+  #define DELTA_TOWER_ANGLE_TRIM { 0.00, 0.00 } // get these from auto calibrate
+
+  // delta radius and diaginal rod adjustments measured in mm
+  //#define DELTA_RADIUS_TRIM_TOWER {0.0, 0.0, 0.0}
+  //#define DELTA_DIAGONAL_ROD_TRIM_TOWER {0.0, 0.0, 0.0}
 
 #endif
 
diff --git a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
index 7de00f0806f..d1ebc9a38c5 100644
--- a/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_mini/Configuration_adv.h
@@ -1,4 +1,4 @@
-/**
+﻿/**
  * Marlin 3D Printer Firmware
  * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -431,25 +431,6 @@
 // Actual motor currents in Amps, need as many here as DIGIPOT_I2C_NUM_CHANNELS
 #define DIGIPOT_I2C_MOTOR_CURRENTS {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}  //  AZTEEG_X3_PRO
 
-//===========================================================================
-//============================== Delta Settings =============================
-//===========================================================================
-
-#if ENABLED(DELTA_AUTO_CALIBRATION)
-  /**
-   * Set the height short (H-10) with M665 Hx.xx.
-   * Set the delta_radius offset (R-5, R-10, R+5, R+10) with M665 Rx.xx.
-   * Run G33 Cx V3 (C2, C-2) with different values for C and R
-   * Take the average for R_FACTOR and maximum for H_FACTOR.
-   * Run the tests with default values!!!
-   */
-  //#define DELTA_CALIBRATE_EXPERT_MODE
-
-  // Remove the comments of the folling 2 lines to overide default values
-  //#define H_FACTOR  1.02 //  1.0 < H_FACTOR <  1.11, default  1.00
-  //#define R_FACTOR -3.95 // -6.7 < R_FACTOR < -2.25, default -2.25
-#endif
-
 //===========================================================================
 //=============================Additional Features===========================
 //===========================================================================
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration.h b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
index 256f3a9ddf9..59b75f5994e 100644
--- a/Marlin/example_configurations/delta/kossel_pro/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration.h
@@ -425,7 +425,7 @@
 
   // Center-to-center distance of the holes in the diagonal push rods.
   #define DELTA_DIAGONAL_ROD 301.0 // mm
-
+/*
   // Horizontal offset from middle of printer to smooth rod center.
   #define DELTA_SMOOTH_ROD_OFFSET 212.357 // mm
 
@@ -434,42 +434,42 @@
 
   // Horizontal offset of the universal joints on the carriages.
   #define DELTA_CARRIAGE_OFFSET 30.0 // mm
-
+*/
   // Horizontal distance bridged by diagonal push rods when effector is centered.
-  #define DELTA_RADIUS (DELTA_SMOOTH_ROD_OFFSET-(DELTA_EFFECTOR_OFFSET)-(DELTA_CARRIAGE_OFFSET))
+  #define DELTA_RADIUS 150 //mm // get this value from auto calibrate
 
   // height from z=0.00 to home position
-  #define DELTA_HEIGHT 277 // get this value from auto calibrate
+  #define DELTA_HEIGHT 277 // get this value from auto calibrate - use G33 C-1 at 1st time calibration
 
   // Print surface diameter/2 minus unreachable space (avoid collisions with vertical towers).
   #define DELTA_PRINTABLE_RADIUS 127.0
 
   // Delta calibration menu
   // See http://minow.blogspot.com/index.html#4918805519571907051
-  //#define DELTA_CALIBRATION_MENU
+  #define DELTA_CALIBRATION_MENU
+
+  // set the radius for the calibration probe points - max 0.8 * DELTA_PRINTABLE_RADIUS if DELTA_AUTO_CALIBRATION enabled
+  #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 25.4) // mm
 
   // G33 Delta Auto-Calibration (Enable EEPROM_SETTINGS to store results)
-  //#define DELTA_AUTO_CALIBRATION
+  #define DELTA_AUTO_CALIBRATION
   #if ENABLED(DELTA_AUTO_CALIBRATION)
-    #define DELTA_CALIBRATION_DEFAULT_POINTS 3 // set the default number of probe points : n*n (1-4)
-    #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 15) // set the radius for the calibration probe points
+    #define DELTA_CALIBRATION_DEFAULT_POINTS 3 // set the default number of probe points : n*n (-7 -> +7)
   #endif
 
   // After homing move down to a height where XY movement is unconstrained
   #define DELTA_HOME_TO_SAFE_ZONE
 
-  //#define DELTA_ENDSTOP_ADJ { 0, 0, 0 }
+  #define DELTA_ENDSTOP_ADJ { -0.00, -0.00, -0.00 } // get these from auto calibrate
 
   // Trim adjustments for individual towers
-  #define DELTA_RADIUS_TRIM_TOWER_1 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_2 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_3 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_1 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_2 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_3 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_1 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_2 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_3 0.0
+  // tower angle corrections for X and Y tower / rotate XYZ so Z tower angle = 0
+  // measured in degrees anticlockwise looking from above the printer
+  #define DELTA_TOWER_ANGLE_TRIM { 0.00, 0.00 } // get these from auto calibrate
+
+  // delta radius and diaginal rod adjustments measured in mm
+  //#define DELTA_RADIUS_TRIM_TOWER {0.0, 0.0, 0.0}
+  //#define DELTA_DIAGONAL_ROD_TRIM_TOWER {0.0, 0.0, 0.0}
 
 #endif
 
diff --git a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
index 40e7259edb6..3e3ce52d68d 100644
--- a/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_pro/Configuration_adv.h
@@ -1,4 +1,4 @@
-/**
+﻿/**
  * Marlin 3D Printer Firmware
  * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -436,26 +436,6 @@
 // Actual motor currents in Amps, need as many here as DIGIPOT_I2C_NUM_CHANNELS
 #define DIGIPOT_I2C_MOTOR_CURRENTS {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}  //  AZTEEG_X3_PRO
 
-//===========================================================================
-//============================== Delta Settings =============================
-//===========================================================================
-
-#if ENABLED(DELTA_AUTO_CALIBRATION)
-  /**
-   * Set the height short (H-10) with M665 Hx.xx.
-   * Set the delta_radius offset (R-5, R-10, R+5, R+10) with M665 Rx.xx.
-   * Run G33 Cx V3 (C2, C-2) with different values for C and R
-   * Take the average for R_FACTOR and maximum for H_FACTOR.
-   * Run the tests with default values!!!
-   */
-  //#define DELTA_CALIBRATE_EXPERT_MODE
-
-  // Remove the comments of the folling 2 lines to overide default values
-  //#define H_FACTOR  1.02 //  1.0 < H_FACTOR <  1.11, default  1.00
-  //#define R_FACTOR -3.95 // -6.7 < R_FACTOR < -2.25, default -2.25
-#endif
-
-
 //===========================================================================
 //=============================Additional Features===========================
 //===========================================================================
diff --git a/Marlin/example_configurations/delta/kossel_xl/Configuration.h b/Marlin/example_configurations/delta/kossel_xl/Configuration.h
index fd09b22098a..4369479a21c 100644
--- a/Marlin/example_configurations/delta/kossel_xl/Configuration.h
+++ b/Marlin/example_configurations/delta/kossel_xl/Configuration.h
@@ -443,7 +443,7 @@
 
   // Center-to-center distance of the holes in the diagonal push rods.
   #define DELTA_DIAGONAL_ROD 317.3 + 2.5 // mm
-
+/*
   // Horizontal offset from middle of printer to smooth rod center.
   #define DELTA_SMOOTH_ROD_OFFSET 220.1 // mm
 
@@ -452,42 +452,42 @@
 
   // Horizontal offset of the universal joints on the carriages.
   #define DELTA_CARRIAGE_OFFSET 22.0 // mm
-
+*/
   // Horizontal distance bridged by diagonal push rods when effector is centered.
-  #define DELTA_RADIUS (DELTA_SMOOTH_ROD_OFFSET-(DELTA_EFFECTOR_OFFSET)-(DELTA_CARRIAGE_OFFSET) + 1)
+  #define DELTA_RADIUS 175 //mm // get this value from auto calibrate
 
   // height from z=0.00 to home position
-  #define DELTA_HEIGHT 380 // get this value from auto calibrate
+  #define DELTA_HEIGHT 380 // get this value from auto calibrate - use G33 C-1 at 1st time calibration
 
   // Print surface diameter/2 minus unreachable space (avoid collisions with vertical towers).
   #define DELTA_PRINTABLE_RADIUS 140.0
 
   // Delta calibration menu
   // See http://minow.blogspot.com/index.html#4918805519571907051
-  //#define DELTA_CALIBRATION_MENU
+  #define DELTA_CALIBRATION_MENU
+
+  // set the radius for the calibration probe points - max 0.8 * DELTA_PRINTABLE_RADIUS if DELTA_AUTO_CALIBRATION enabled
+  #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 28) // mm
 
   // G33 Delta Auto-Calibration (Enable EEPROM_SETTINGS to store results)
-  //#define DELTA_AUTO_CALIBRATION
+  #define DELTA_AUTO_CALIBRATION
   #if ENABLED(DELTA_AUTO_CALIBRATION)
-    #define DELTA_CALIBRATION_DEFAULT_POINTS 3 // set the default number of probe points : n*n (1-4)
-    #define DELTA_CALIBRATION_RADIUS (DELTA_PRINTABLE_RADIUS - 15) // set the radius for the calibration probe points
+    #define DELTA_CALIBRATION_DEFAULT_POINTS 3 // set the default number of probe points : n*n (-7 -> +7)
   #endif
 
   // After homing move down to a height where XY movement is unconstrained
   #define DELTA_HOME_TO_SAFE_ZONE
 
-  //#define DELTA_ENDSTOP_ADJ { 0, 0, 0 }
+  #define DELTA_ENDSTOP_ADJ { -0.00, -0.00, -0.00 } // get these from auto calibrate
 
   // Trim adjustments for individual towers
-  #define DELTA_RADIUS_TRIM_TOWER_1 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_2 0.0
-  #define DELTA_RADIUS_TRIM_TOWER_3 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_1 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_2 0.0
-  #define DELTA_DIAGONAL_ROD_TRIM_TOWER_3 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_1 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_2 0.0
-  #define DELTA_TOWER_ANGLE_TRIM_3 0.0
+  // tower angle corrections for X and Y tower / rotate XYZ so Z tower angle = 0
+  // measured in degrees anticlockwise looking from above the printer
+  #define DELTA_TOWER_ANGLE_TRIM { 0.00, 0.00 } // get these from auto calibrate
+
+  // delta radius and diaginal rod adjustments measured in mm
+  //#define DELTA_RADIUS_TRIM_TOWER {0.0, 0.0, 0.0}
+  //#define DELTA_DIAGONAL_ROD_TRIM_TOWER {0.0, 0.0, 0.0}
 
 #endif
 
diff --git a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
index 8268e42930e..e4e613d3343 100644
--- a/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
+++ b/Marlin/example_configurations/delta/kossel_xl/Configuration_adv.h
@@ -431,25 +431,6 @@
 // Actual motor currents in Amps, need as many here as DIGIPOT_I2C_NUM_CHANNELS
 #define DIGIPOT_I2C_MOTOR_CURRENTS {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}  //  AZTEEG_X3_PRO
 
-//===========================================================================
-//============================== Delta Settings =============================
-//===========================================================================
-
-#if ENABLED(DELTA_AUTO_CALIBRATION)
-  /**
-   * Set the height short (H-10) with M665 Hx.xx.
-   * Set the delta_radius offset (R-5, R-10, R+5, R+10) with M665 Rx.xx.
-   * Run G33 Cx V3 (C2, C-2) with different values for C and R
-   * Take the average for R_FACTOR and maximum for H_FACTOR.
-   * Run the tests with default values!!!
-   */
-  //#define DELTA_CALIBRATE_EXPERT_MODE
-
-  // Remove the comments of the folling 2 lines to overide default values
-  //#define H_FACTOR  1.02 //  1.0 < H_FACTOR <  1.11, default  1.00
-  //#define R_FACTOR -3.95 // -6.7 < R_FACTOR < -2.25, default -2.25
-#endif
-
 //===========================================================================
 //=============================Additional Features===========================
 //===========================================================================
diff --git a/Marlin/serial.cpp b/Marlin/serial.cpp
index 9b5ae139e4c..797c6107ac0 100644
--- a/Marlin/serial.cpp
+++ b/Marlin/serial.cpp
@@ -32,3 +32,5 @@ void serial_echopair_P(const char* s_P, long v)          { serialprintPGM(s_P);
 void serial_echopair_P(const char* s_P, float v)         { serialprintPGM(s_P); SERIAL_ECHO(v); }
 void serial_echopair_P(const char* s_P, double v)        { serialprintPGM(s_P); SERIAL_ECHO(v); }
 void serial_echopair_P(const char* s_P, unsigned long v) { serialprintPGM(s_P); SERIAL_ECHO(v); }
+
+void serial_spaces(uint8_t count) { while (count--) MYSERIAL.write(' '); }
diff --git a/Marlin/serial.h b/Marlin/serial.h
index b6e7add430d..62e06c98926 100644
--- a/Marlin/serial.h
+++ b/Marlin/serial.h
@@ -84,6 +84,11 @@ FORCE_INLINE void serial_echopair_P(const char* s_P, uint16_t v) { serial_echopa
 FORCE_INLINE void serial_echopair_P(const char* s_P, bool v) { serial_echopair_P(s_P, (int)v); }
 FORCE_INLINE void serial_echopair_P(const char* s_P, void *v) { serial_echopair_P(s_P, (unsigned long)v); }
 
+void serial_spaces(uint8_t count);
+#define SERIAL_ECHO_SP(C)     serial_spaces(C)
+#define SERIAL_ERROR_SP(C)    serial_spaces(C)
+#define SERIAL_PROTOCOL_SP(C) serial_spaces(C)
+
 //
 // Functions for serial printing from PROGMEM. (Saves loads of SRAM.)
 //
diff --git a/Marlin/ultralcd.cpp b/Marlin/ultralcd.cpp
index 608dab5c639..5ec9843d1d8 100755
--- a/Marlin/ultralcd.cpp
+++ b/Marlin/ultralcd.cpp
@@ -1799,20 +1799,14 @@ void kill_screen(const char* lcd_msg) {
       lcd_goto_screen(_lcd_calibrate_homing);
     }
 
-    #if ENABLED(DELTA_AUTO_CALIBRATION)
-      #define _DELTA_TOWER_MOVE_RADIUS DELTA_CALIBRATION_RADIUS
-    #else
-      #define _DELTA_TOWER_MOVE_RADIUS DELTA_PRINTABLE_RADIUS
-    #endif
-
     // Move directly to the tower position with uninterpolated moves
     // If we used interpolated moves it would cause this to become re-entrant
     void _goto_tower_pos(const float &a) {
       current_position[Z_AXIS] = max(Z_HOMING_HEIGHT, Z_CLEARANCE_BETWEEN_PROBES) + (DELTA_PRINTABLE_RADIUS) / 5;
       line_to_current(Z_AXIS);
 
-      current_position[X_AXIS] = a < 0 ? LOGICAL_X_POSITION(X_HOME_POS) : sin(a) * -(_DELTA_TOWER_MOVE_RADIUS);
-      current_position[Y_AXIS] = a < 0 ? LOGICAL_Y_POSITION(Y_HOME_POS) : cos(a) *  (_DELTA_TOWER_MOVE_RADIUS);
+      current_position[X_AXIS] = a < 0 ? LOGICAL_X_POSITION(X_HOME_POS) : cos(RADIANS(a)) * delta_calibration_radius;
+      current_position[Y_AXIS] = a < 0 ? LOGICAL_Y_POSITION(Y_HOME_POS) : sin(RADIANS(a)) * delta_calibration_radius;
       line_to_current(Z_AXIS);
 
       current_position[Z_AXIS] = 4.0;
@@ -1824,17 +1818,17 @@ void kill_screen(const char* lcd_msg) {
       lcd_goto_screen(lcd_move_z);
     }
 
-    void _goto_tower_x() { _goto_tower_pos(RADIANS(120)); }
-    void _goto_tower_y() { _goto_tower_pos(RADIANS(240)); }
-    void _goto_tower_z() { _goto_tower_pos(0); }
+    void _goto_tower_x() { _goto_tower_pos(210); }
+    void _goto_tower_y() { _goto_tower_pos(330); }
+    void _goto_tower_z() { _goto_tower_pos(90); }
     void _goto_center()  { _goto_tower_pos(-1); }
 
     void lcd_delta_calibrate_menu() {
       START_MENU();
       MENU_BACK(MSG_MAIN);
       #if ENABLED(DELTA_AUTO_CALIBRATION)
-        MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33 C"));
-        MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 C1"));
+        MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
+        MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 C-1"));
       #endif
       MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
       if (axis_homed[Z_AXIS]) {
