diff --git a/numpy/core/include/numpy/npy_3kcompat.h b/numpy/core/include/numpy/npy_3kcompat.h
index c0aa1eb2e99..03ef4e49f57 100644
--- a/numpy/core/include/numpy/npy_3kcompat.h
+++ b/numpy/core/include/numpy/npy_3kcompat.h
@@ -45,6 +45,7 @@ static NPY_INLINE int PyInt_Check(PyObject *op) {
 #define PyInt_AsLong PyLong_AsLong
 #define PyInt_AS_LONG PyLong_AsLong
 #define PyInt_AsSsize_t PyLong_AsSsize_t
+#define PyInt_FromSsize_t PyLong_FromSsize_t
 
 /* NOTE:
  *
@@ -191,7 +192,7 @@ npy_PyFile_Dup2(PyObject *file, char *mode, npy_off_t *orig_pos)
     if (ret == NULL) {
         return NULL;
     }
-    fd2 = PyNumber_AsSsize_t(ret, NULL);
+    fd2 = (int) PyNumber_AsSsize_t(ret, NULL);
     Py_DECREF(ret);
 
     /* Convert to FILE* handle */
diff --git a/numpy/core/src/multiarray/_datetime.h b/numpy/core/src/multiarray/_datetime.h
index 3db1254d488..7971843bdc5 100644
--- a/numpy/core/src/multiarray/_datetime.h
+++ b/numpy/core/src/multiarray/_datetime.h
@@ -183,7 +183,7 @@ convert_datetime_metadata_tuple_to_datetime_metadata(PyObject *tuple,
  * the Python datetime.tzinfo object.
  */
 NPY_NO_EXPORT int
-get_tzoffset_from_pytzinfo(PyObject *timezone, npy_datetimestruct *dts);
+get_tzoffset_from_pytzinfo(PyObject *timezone_obj, npy_datetimestruct *dts);
 
 /*
  * Converts an input object into datetime metadata. The input
diff --git a/numpy/core/src/multiarray/arrayobject.c b/numpy/core/src/multiarray/arrayobject.c
index 36d48af9fde..750967cd790 100644
--- a/numpy/core/src/multiarray/arrayobject.c
+++ b/numpy/core/src/multiarray/arrayobject.c
@@ -1018,7 +1018,7 @@ _void_compare(PyArrayObject *self, PyArrayObject *other, int cmp_op)
         PyObject *key, *value, *temp2;
         PyObject *op;
         Py_ssize_t pos = 0;
-        npy_intp result_ndim = PyArray_NDIM(self) > PyArray_NDIM(other) ?
+        int result_ndim = PyArray_NDIM(self) > PyArray_NDIM(other) ?
                             PyArray_NDIM(self) : PyArray_NDIM(other);
 
         op = (cmp_op == Py_EQ ? n_ops.logical_and : n_ops.logical_or);
@@ -1322,7 +1322,7 @@ NPY_NO_EXPORT int
 PyArray_ElementStrides(PyObject *obj)
 {
     PyArrayObject *arr;
-    int itemsize;
+    npy_intp itemsize;
     int i, ndim;
     npy_intp *strides;
 
diff --git a/numpy/core/src/multiarray/arraytypes.c.src b/numpy/core/src/multiarray/arraytypes.c.src
index 43dd101c5ad..6af15d49522 100644
--- a/numpy/core/src/multiarray/arraytypes.c.src
+++ b/numpy/core/src/multiarray/arraytypes.c.src
@@ -452,7 +452,7 @@ UNICODE_setitem(PyObject *op, void *ov, void *vap)
     PyArrayObject *ap = vap;
     PyObject *temp;
     Py_UNICODE *ptr;
-    int datalen;
+    npy_intp datalen;
 #ifndef Py_UNICODE_WIDE
     char *buffer;
 #endif
@@ -654,7 +654,7 @@ VOID_getitem(void *input, void *vap)
     if (PyDataType_HASFIELDS(descr)) {
         PyObject *key;
         PyObject *names;
-        int i, n;
+        npy_intp i, n;
         PyObject *ret;
         PyObject *tup;
         int savedflags;
@@ -784,7 +784,7 @@ NPY_NO_EXPORT int PyArray_CopyObject(PyArrayObject *, PyObject *);
  * WARNING: Clobbers arr's dtype and alignment flag.
  */
 NPY_NO_EXPORT int
-_setup_field(int i, PyArray_Descr *descr, PyArrayObject *arr,
+_setup_field(npy_intp i, PyArray_Descr *descr, PyArrayObject *arr,
             npy_intp *offset_p)
 {
     PyObject *key;
@@ -818,9 +818,9 @@ _copy_and_return_void_setitem(PyArray_Descr *dstdescr, char *dstdata,
                               PyArray_Descr *srcdescr, char *srcdata){
     PyArrayObject_fields dummy_struct;
     PyArrayObject *dummy = (PyArrayObject *)&dummy_struct;
-    npy_int names_size = PyTuple_GET_SIZE(dstdescr->names);
+    npy_intp names_size = PyTuple_GET_SIZE(dstdescr->names);
     npy_intp offset;
-    npy_int i;
+    npy_intp i;
     int ret;
 
     /* Fast path if dtypes are equal */
@@ -1829,7 +1829,7 @@ static int
     @btype@ result;
 
     result = @func@(str, endptr, 10);
-    *(@type@ *)ip = result;
+    *(@type@ *)ip = (@type@) result;
     return 0;
 }
 /**end repeat**/
@@ -1846,7 +1846,7 @@ static int
     double result;
 
     result = NumPyOS_ascii_strtod(str, endptr);
-    *(@type@ *)ip = result;
+    *(@type@ *)ip = (@type@) result;
     return 0;
 }
 /**end repeat**/
@@ -3693,7 +3693,7 @@ static void
 
     delta -= start;
     for (i = 2; i < length; ++i) {
-        buffer[i] = start + i*delta;
+        buffer[i] = (@type@) (start + i*delta);
     }
 }
 /**end repeat**/
diff --git a/numpy/core/src/multiarray/buffer.c b/numpy/core/src/multiarray/buffer.c
index e76d406deeb..0dd49b970e1 100644
--- a/numpy/core/src/multiarray/buffer.c
+++ b/numpy/core/src/multiarray/buffer.c
@@ -194,7 +194,7 @@ _buffer_format_string(PyArray_Descr *descr, _tmp_string_t *str,
         Py_ssize_t total_count = 1;
         Py_ssize_t dim_size;
         char buf[128];
-        int old_offset;
+        Py_ssize_t old_offset;
         int ret;
 
         if (PyTuple_Check(descr->subarray->shape)) {
@@ -228,7 +228,7 @@ _buffer_format_string(PyArray_Descr *descr, _tmp_string_t *str,
         return ret;
     }
     else if (PyDataType_HASFIELDS(descr)) {
-        int base_offset = *offset;
+        Py_ssize_t base_offset = *offset;
 
         _append_str(str, "T{");
         for (k = 0; k < PyTuple_GET_SIZE(descr->names); ++k) {
@@ -236,7 +236,7 @@ _buffer_format_string(PyArray_Descr *descr, _tmp_string_t *str,
             PyArray_Descr *child;
             char *p;
             Py_ssize_t len;
-            int new_offset;
+            Py_ssize_t new_offset;
 
             name = PyTuple_GET_ITEM(descr->names, k);
             item = PyDict_GetItem(descr->fields, name);
diff --git a/numpy/core/src/multiarray/calculation.c b/numpy/core/src/multiarray/calculation.c
index 379e5c3d26c..c0e1e6b2f42 100644
--- a/numpy/core/src/multiarray/calculation.c
+++ b/numpy/core/src/multiarray/calculation.c
@@ -362,7 +362,7 @@ __New_PyArray_Std(PyArrayObject *self, int axis, int rtype, PyArrayObject *out,
     PyArrayObject *arr1 = NULL, *arr2 = NULL, *arrnew = NULL;
     PyObject *ret = NULL, *newshape = NULL;
     int i, n;
-    npy_intp val;
+    npy_intp n_ax;
 
     arrnew = (PyArrayObject *)PyArray_CheckAxis(self, &axis, 0);
     if (arrnew == NULL) {
@@ -383,6 +383,7 @@ __New_PyArray_Std(PyArrayObject *self, int axis, int rtype, PyArrayObject *out,
         return NULL;
     }
     for (i = 0; i < n; i++) {
+        npy_intp val;
         if (i == axis) {
             val = 1;
         }
@@ -458,13 +459,13 @@ __New_PyArray_Std(PyArrayObject *self, int axis, int rtype, PyArrayObject *out,
         Py_DECREF(arrnew);
         return NULL;
     }
-    n = PyArray_DIM(arrnew,axis);
+    n_ax = PyArray_DIM(arrnew,axis);
     Py_DECREF(arrnew);
-    n = (n-num);
-    if (n == 0) {
-        n = 1;
+    n_ax = (n_ax-num);
+    if (n_ax == 0) {
+        n_ax = 1;
     }
-    obj2 = PyFloat_FromDouble(1.0/((double )n));
+    obj2 = PyFloat_FromDouble(1.0/((double )n_ax));
     if (obj2 == NULL) {
         Py_DECREF(obj1);
         return NULL;
diff --git a/numpy/core/src/multiarray/common.c b/numpy/core/src/multiarray/common.c
index 099cc039431..99bb90c5567 100644
--- a/numpy/core/src/multiarray/common.c
+++ b/numpy/core/src/multiarray/common.c
@@ -124,7 +124,7 @@ NPY_NO_EXPORT int
 PyArray_DTypeFromObjectHelper(PyObject *obj, int maxdims,
                               PyArray_Descr **out_dtype, int string_type)
 {
-    int i, size;
+    npy_intp i, size;
     PyArray_Descr *dtype = NULL;
     PyObject *ip;
     Py_buffer buffer_view;
@@ -158,7 +158,7 @@ PyArray_DTypeFromObjectHelper(PyObject *obj, int maxdims,
             }
         }
         else {
-            int itemsize;
+            npy_intp itemsize;
             PyObject *temp;
 
             if (string_type == NPY_STRING) {
@@ -201,7 +201,11 @@ PyArray_DTypeFromObjectHelper(PyObject *obj, int maxdims,
             if (dtype == NULL) {
                 goto fail;
             }
-            dtype->elsize = itemsize;
+            if (itemsize > INT_MAX) {
+                PyErr_SetString(PyExc_ValueError, "String is too large");
+                goto fail;
+            }
+            dtype->elsize = (int) itemsize;
         }
         goto promote_types;
     }
@@ -210,7 +214,7 @@ PyArray_DTypeFromObjectHelper(PyObject *obj, int maxdims,
     dtype = _array_find_python_scalar_type(obj);
     if (dtype != NULL) {
         if (string_type) {
-            int itemsize;
+            npy_intp itemsize;
             PyObject *temp;
 
             if (string_type == NPY_STRING) {
@@ -253,14 +257,18 @@ PyArray_DTypeFromObjectHelper(PyObject *obj, int maxdims,
             if (dtype == NULL) {
                 goto fail;
             }
-            dtype->elsize = itemsize;
+            if (itemsize > INT_MAX) {
+                PyErr_SetString(PyExc_ValueError, "String is too large");
+                goto fail;
+            }
+            dtype->elsize = (int) itemsize;
         }
         goto promote_types;
     }
 
     /* Check if it's an ASCII string */
     if (PyBytes_Check(obj)) {
-        int itemsize = PyString_GET_SIZE(obj);
+        npy_intp itemsize = PyString_GET_SIZE(obj);
 
         /* If it's already a big enough string, don't bother type promoting */
         if (*out_dtype != NULL &&
@@ -272,13 +280,17 @@ PyArray_DTypeFromObjectHelper(PyObject *obj, int maxdims,
         if (dtype == NULL) {
             goto fail;
         }
-        dtype->elsize = itemsize;
+        if (itemsize > INT_MAX) {
+            PyErr_SetString(PyExc_ValueError, "String is too large");
+            goto fail;
+        }
+        dtype->elsize = (int) itemsize;
         goto promote_types;
     }
 
     /* Check if it's a Unicode string */
     if (PyUnicode_Check(obj)) {
-        int itemsize = PyUnicode_GET_DATA_SIZE(obj);
+        npy_intp itemsize = PyUnicode_GET_DATA_SIZE(obj);
 #ifndef Py_UNICODE_WIDE
         itemsize <<= 1;
 #endif
@@ -296,7 +308,11 @@ PyArray_DTypeFromObjectHelper(PyObject *obj, int maxdims,
         if (dtype == NULL) {
             goto fail;
         }
-        dtype->elsize = itemsize;
+        if (itemsize > INT_MAX) {
+            PyErr_SetString(PyExc_ValueError, "String is too large");
+            goto fail;
+        }
+        dtype->elsize = (int) itemsize;
         goto promote_types;
     }
 
@@ -319,7 +335,11 @@ PyArray_DTypeFromObjectHelper(PyObject *obj, int maxdims,
 
             PyErr_Clear();
             dtype = PyArray_DescrNewFromType(NPY_VOID);
-            dtype->elsize = buffer_view.itemsize;
+            if (buffer_view.itemsize > INT_MAX) {
+                PyErr_SetString(PyExc_ValueError, "Buffer is too large");
+                goto fail;
+            }
+            dtype->elsize = (int) buffer_view.itemsize;
             PyBuffer_Release(&buffer_view);
             goto promote_types;
         }
@@ -588,7 +608,7 @@ _zerofill(PyArrayObject *ret)
 NPY_NO_EXPORT int
 _IsAligned(PyArrayObject *ap)
 {
-    unsigned int i;
+    int i;
     npy_uintp aligned;
     npy_uintp alignment = PyArray_DESCR(ap)->alignment;
 
diff --git a/numpy/core/src/multiarray/common.h b/numpy/core/src/multiarray/common.h
index ae9b960c86f..b9bfb84e209 100644
--- a/numpy/core/src/multiarray/common.h
+++ b/numpy/core/src/multiarray/common.h
@@ -266,7 +266,7 @@ blas_stride(npy_intp stride, unsigned itemsize)
     if (stride > 0 && npy_is_aligned((void *)stride, itemsize)) {
         stride /= itemsize;
         if (stride <= INT_MAX) {
-            return stride;
+            return (int) stride;
         }
     }
     return 0;
diff --git a/numpy/core/src/multiarray/compiled_base.c b/numpy/core/src/multiarray/compiled_base.c
index 36ef1d1c438..37b11b34761 100644
--- a/numpy/core/src/multiarray/compiled_base.c
+++ b/numpy/core/src/multiarray/compiled_base.c
@@ -20,7 +20,7 @@
  * and 0 if the array is not monotonic.
  */
 static int
-check_array_monotonic(const double *a, npy_int lena)
+check_array_monotonic(const double *a, npy_intp lena)
 {
     npy_intp i;
     double next;
diff --git a/numpy/core/src/multiarray/conversion_utils.c b/numpy/core/src/multiarray/conversion_utils.c
index 2bb1cbfc1ad..96ec2c18553 100644
--- a/numpy/core/src/multiarray/conversion_utils.c
+++ b/numpy/core/src/multiarray/conversion_utils.c
@@ -126,8 +126,8 @@ PyArray_IntpConverter(PyObject *obj, PyArray_Dims *seq)
             return NPY_FAIL;
         }
     }
-    seq->len = len;
-    nd = PyArray_IntpFromIndexSequence(obj, (npy_intp *)seq->ptr, len);
+    seq->len = (int) len;  /* safe, assuming NPY_MAXDIMS <= MAX_INT */
+    nd = PyArray_IntpFromSequence(obj, (npy_intp *)seq->ptr, seq->len);
     if (nd == -1 || nd != len) {
         npy_free_cache_dim_obj(*seq);
         seq->ptr = NULL;
@@ -248,10 +248,16 @@ PyArray_ConvertMultiAxis(PyObject *axis_in, int ndim, npy_bool *out_axis_flags)
     /* A tuple of which axes */
     else if (PyTuple_Check(axis_in)) {
         int i, naxes;
+        npy_intp naxes_intp;
 
         memset(out_axis_flags, 0, ndim);
 
-        naxes = PyTuple_Size(axis_in);
+        naxes_intp = PyTuple_Size(axis_in);
+        if (naxes_intp > INT_MAX) {
+            PyErr_SetString(PyExc_ValueError, "Too many axes");
+            return NPY_FAIL;
+        }
+        naxes = (int) naxes_intp;
         if (naxes < 0) {
             return NPY_FAIL;
         }
@@ -945,14 +951,20 @@ PyArray_IntpFromIndexSequence(PyObject *seq, npy_intp *vals, npy_intp maxvals)
 }
 
 /*NUMPY_API
- * PyArray_IntpFromSequence
+ * PyArray_IntpFromSequence`
  * Returns the number of integers converted or -1 if an error occurred.
  * vals must be large enough to hold maxvals
  */
 NPY_NO_EXPORT int
 PyArray_IntpFromSequence(PyObject *seq, npy_intp *vals, int maxvals)
 {
-    return PyArray_IntpFromIndexSequence(seq, vals, (npy_intp)maxvals);
+    npy_intp result = PyArray_IntpFromIndexSequence(
+        seq, vals, (npy_intp)maxvals);
+    if (result > INT_MAX) {
+        PyErr_SetString(PyExc_ValueError, "Result too large");
+        return -1;
+    }
+    return (int) result;
 }
 
 
diff --git a/numpy/core/src/multiarray/convert_datatype.c b/numpy/core/src/multiarray/convert_datatype.c
index e495f316020..97cc84a42aa 100644
--- a/numpy/core/src/multiarray/convert_datatype.c
+++ b/numpy/core/src/multiarray/convert_datatype.c
@@ -310,12 +310,17 @@ PyArray_AdaptFlexibleDType(PyObject *data_obj, PyArray_Descr *data_dtype,
                     break;
             }
 
-            if (flex_type_num == NPY_STRING) {
-                (*flex_dtype)->elsize = size;
+            if (flex_type_num == NPY_UNICODE) {
+                size *= 4;
             }
-            else if (flex_type_num == NPY_UNICODE) {
-                (*flex_dtype)->elsize = size * 4;
+
+            if (size > INT_MAX) {
+                PyErr_SetString(PyExc_ValueError,
+                        "Cannot create a dtype that large");
+                return;
             }
+
+            (*flex_dtype)->elsize = (int) size;
         }
         else {
             /*
@@ -2043,14 +2048,20 @@ PyArray_ObjectType(PyObject *op, int minimum_type)
 NPY_NO_EXPORT PyArrayObject **
 PyArray_ConvertToCommonType(PyObject *op, int *retn)
 {
-    int i, n, allscalars = 0;
+    npy_intp i, n;
+    int allscalars = 0;
     PyArrayObject **mps = NULL;
     PyObject *otmp;
     PyArray_Descr *intype = NULL, *stype = NULL;
     PyArray_Descr *newtype = NULL;
     NPY_SCALARKIND scalarkind = NPY_NOSCALAR, intypekind = NPY_NOSCALAR;
 
-    *retn = n = PySequence_Length(op);
+    n = PySequence_Length(op);
+    if (n > INT_MAX) {
+        /* ret should have been an npy_intp to avoid this */
+        PyErr_SetString(PyExc_ValueError, "sequence too long.");
+    }
+    *retn = (int) n;
     if (n == 0) {
         PyErr_SetString(PyExc_ValueError, "0-length sequence.");
     }
diff --git a/numpy/core/src/multiarray/ctors.c b/numpy/core/src/multiarray/ctors.c
index c9b3125aefd..2cc9d138b7d 100644
--- a/numpy/core/src/multiarray/ctors.c
+++ b/numpy/core/src/multiarray/ctors.c
@@ -254,7 +254,8 @@ _update_descr_and_dimensions(PyArray_Descr **des, npy_intp *newdims,
     mydim = newdims + oldnd;
     tuple = PyTuple_Check(old->subarray->shape);
     if (tuple) {
-        numnew = PyTuple_GET_SIZE(old->subarray->shape);
+        /* subarray should always be < NPY_MAXDIMS, so cast is safe */
+        numnew = (int) PyTuple_GET_SIZE(old->subarray->shape);
     }
     else {
         numnew = 1;
@@ -296,7 +297,7 @@ _update_descr_and_dimensions(PyArray_Descr **des, npy_intp *newdims,
 
 NPY_NO_EXPORT void
 _unaligned_strided_byte_copy(char *dst, npy_intp outstrides, char *src,
-                             npy_intp instrides, npy_intp N, int elsize)
+                             npy_intp instrides, npy_intp N, npy_intp elsize)
 {
     npy_intp i;
     char *tout = dst;
@@ -585,7 +586,7 @@ PyArray_AssignFromSequence(PyArrayObject *self, PyObject *v)
  */
 
 static int
-discover_itemsize(PyObject *s, int nd, int *itemsize, int string_type)
+discover_itemsize(PyObject *s, int nd, npy_intp *itemsize, int string_type)
 {
     int r;
     npy_intp n, i;
@@ -666,7 +667,7 @@ discover_dimensions(PyObject *obj, int *maxndim, npy_intp *d, int check_it,
 {
     PyObject *e;
     int r;
-    npy_intp n, i;
+    npy_intp n;
     Py_buffer buffer_view;
     PyObject * seq;
 
@@ -676,6 +677,7 @@ discover_dimensions(PyObject *obj, int *maxndim, npy_intp *d, int check_it,
 
     /* obj is an Array */
     if (PyArray_Check(obj)) {
+        int i;
         PyArrayObject *arr = (PyArrayObject *)obj;
 
         if (PyArray_NDIM(arr) < *maxndim) {
@@ -732,6 +734,7 @@ discover_dimensions(PyObject *obj, int *maxndim, npy_intp *d, int check_it,
         if (PyObject_GetBuffer(obj, &buffer_view, PyBUF_STRIDES) == 0 ||
             PyObject_GetBuffer(obj, &buffer_view, PyBUF_ND) == 0) {
             int nd = buffer_view.ndim;
+            int i;
             if (nd < *maxndim) {
                 *maxndim = nd;
             }
@@ -762,6 +765,7 @@ discover_dimensions(PyObject *obj, int *maxndim, npy_intp *d, int check_it,
             if (inter->two == 2) {
                 nd = inter->nd;
                 if (nd >= 0) {
+                    int i;
                     if (nd < *maxndim) {
                         *maxndim = nd;
                     }
@@ -780,14 +784,15 @@ discover_dimensions(PyObject *obj, int *maxndim, npy_intp *d, int check_it,
     /* obj has the __array_interface__ interface */
     e = PyArray_LookupSpecial_OnInstance(obj, "__array_interface__");
     if (e != NULL) {
-        int nd = -1;
+        npy_intp nd = -1;
         if (PyDict_Check(e)) {
             PyObject *new;
             new = PyDict_GetItemString(e, "shape");
             if (new && PyTuple_Check(new)) {
+                int i;
                 nd = PyTuple_GET_SIZE(new);
                 if (nd < *maxndim) {
-                    *maxndim = nd;
+                    *maxndim = (int) nd;
                 }
                 for (i=0; i<*maxndim; i++) {
                     d[i] = PyInt_AsSsize_t(PyTuple_GET_ITEM(new, i));
@@ -843,6 +848,7 @@ discover_dimensions(PyObject *obj, int *maxndim, npy_intp *d, int check_it,
     else {
         npy_intp dtmp[NPY_MAXDIMS];
         int j, maxndim_m1 = *maxndim - 1;
+        npy_intp i;
         e = PySequence_Fast_GET_ITEM(seq, 0);
 
         r = discover_dimensions(e, &maxndim_m1, d + 1, check_it,
@@ -1312,7 +1318,11 @@ _array_from_buffer_3118(PyObject *obj, PyObject **out)
     }
     else {
         descr = PyArray_DescrNewFromType(NPY_STRING);
-        descr->elsize = view->itemsize;
+        if (view->itemsize > INT_MAX) {
+            PyErr_SetString(PyExc_ValueError, "Buffer too large");
+            goto fail;
+        }
+        descr->elsize = (int) view->itemsize;
     }
 
     nd = view->ndim;
@@ -1619,7 +1629,7 @@ PyArray_GetArrayParamsFromObject(PyObject *op,
         /* If the type is flexible, determine its size */
         if ((*out_dtype)->elsize == 0 &&
                             PyTypeNum_ISEXTENDED((*out_dtype)->type_num)) {
-            int itemsize = 0;
+            npy_intp itemsize = 0;
             int string_type = 0;
             if ((*out_dtype)->type_num == NPY_STRING ||
                     (*out_dtype)->type_num == NPY_UNICODE) {
@@ -1642,10 +1652,14 @@ PyArray_GetArrayParamsFromObject(PyObject *op,
             if ((*out_dtype)->type_num == NPY_UNICODE) {
                 itemsize *= 4;
             }
+            if (itemsize > INT_MAX) {
+                PyErr_SetString(PyExc_ValueError, "Dtype too large");
+                return -1;
+            }
 
             if (itemsize != (*out_dtype)->elsize) {
                 PyArray_DESCR_REPLACE(*out_dtype);
-                (*out_dtype)->elsize = itemsize;
+                (*out_dtype)->elsize = (int) itemsize;
             }
         }
 
@@ -2242,7 +2256,8 @@ PyArray_FromInterface(PyObject *origin)
         /* Assume shape as scalar otherwise */
         else {
             /* NOTE: pointers to data and base should be NULL */
-            n = dims[0] = 0;
+            dims[0] = 0;
+            n = 0;
         }
     }
     /* Make sure 'shape' is a tuple */
@@ -2253,7 +2268,14 @@ PyArray_FromInterface(PyObject *origin)
     }
     /* Get dimensions from shape tuple */
     else {
-        n = PyTuple_GET_SIZE(attr);
+        npy_intp n_intp = PyTuple_GET_SIZE(attr);
+
+        if (n_intp > NPY_MAXDIMS) {
+            PyErr_SetString(PyExc_TypeError,
+                    "shape is too long");
+            goto fail;
+        }
+        n = (int) n_intp;
         for (i = 0; i < n; i++) {
             tmp = PyTuple_GET_ITEM(attr, i);
             dims[i] = PyArray_PyIntAsIntp(tmp);
diff --git a/numpy/core/src/multiarray/ctors.h b/numpy/core/src/multiarray/ctors.h
index e889910cbef..709168ddc0e 100644
--- a/numpy/core/src/multiarray/ctors.h
+++ b/numpy/core/src/multiarray/ctors.h
@@ -63,7 +63,7 @@ _array_fill_strides(npy_intp *strides, npy_intp *dims, int nd, size_t itemsize,
 
 NPY_NO_EXPORT void
 _unaligned_strided_byte_copy(char *dst, npy_intp outstrides, char *src,
-                             npy_intp instrides, npy_intp N, int elsize);
+                             npy_intp instrides, npy_intp N, npy_intp elsize);
 
 NPY_NO_EXPORT void
 _strided_byte_swap(void *p, npy_intp stride, npy_intp n, int size);
diff --git a/numpy/core/src/multiarray/datetime.c b/numpy/core/src/multiarray/datetime.c
index 93babe8bdd1..aef314dffa5 100644
--- a/numpy/core/src/multiarray/datetime.c
+++ b/numpy/core/src/multiarray/datetime.c
@@ -596,9 +596,9 @@ convert_datetime_to_datetimestruct(PyArray_DatetimeMetaData *meta,
                 out->as = (int)((dt % 1000LL) * 1000);
             }
             else {
-                npy_datetime minutes;
+                int minutes;
 
-                minutes = dt / (60*1000000000000000LL);
+                minutes = (int) (dt / (60*1000000000000000LL));
                 dt = dt % (60*1000000000000000LL);
                 if (dt < 0) {
                     dt += (60*1000000000000000LL);
@@ -622,9 +622,9 @@ convert_datetime_to_datetimestruct(PyArray_DatetimeMetaData *meta,
                 out->as = (int)(dt % 1000000LL);
             }
             else {
-                npy_datetime seconds;
+                int seconds;
 
-                seconds = dt / 1000000000000000000LL;
+                seconds = (int) (dt / 1000000000000000000LL);
                 dt = dt % 1000000000000000000LL;
                 if (dt < 0) {
                     dt += 1000000000000000000LL;
@@ -2890,12 +2890,12 @@ convert_datetime_to_pyobject(npy_datetime dt, PyArray_DatetimeMetaData *meta)
 
     /* If the type's precision is greater than days, return a datetime */
     if (meta->base > NPY_FR_D) {
-        ret = PyDateTime_FromDateAndTime(dts.year, dts.month, dts.day,
+        ret = PyDateTime_FromDateAndTime((int) dts.year, dts.month, dts.day,
                                 dts.hour, dts.min, dts.sec, dts.us);
     }
     /* Otherwise return a date */
     else {
-        ret = PyDate_FromDate(dts.year, dts.month, dts.day);
+        ret = PyDate_FromDate((int) dts.year, dts.month, dts.day);
     }
 
     return ret;
diff --git a/numpy/core/src/multiarray/datetime_strings.c b/numpy/core/src/multiarray/datetime_strings.c
index 716453c950d..ba9ca0e8df7 100644
--- a/numpy/core/src/multiarray/datetime_strings.c
+++ b/numpy/core/src/multiarray/datetime_strings.c
@@ -178,7 +178,7 @@ convert_datetimestruct_utc_to_local(npy_datetimestruct *out_dts_local,
     localrawtime += out_dts_local->hour * 60;
     localrawtime += out_dts_local->min;
 
-    *out_timezone_offset = localrawtime - rawtime;
+    *out_timezone_offset = (int)(localrawtime - rawtime);
 
     /* Reapply the year 2038 year correction */
     out_dts_local->year += year_correction;
@@ -885,15 +885,16 @@ lossless_unit_from_datetimestruct(npy_datetimestruct *dts)
  *  string was too short).
  */
 NPY_NO_EXPORT int
-make_iso_8601_datetime(npy_datetimestruct *dts, char *outstr, int outlen,
+make_iso_8601_datetime(npy_datetimestruct *dts, char *outstr, npy_intp outlen,
                     int local, int utc, NPY_DATETIMEUNIT base, int tzoffset,
                     NPY_CASTING casting)
 {
     npy_datetimestruct dts_local;
     int timezone_offset = 0;
 
-    char *substr = outstr, sublen = outlen;
-    int tmplen;
+    char *substr = outstr;
+    npy_intp sublen = outlen;
+    npy_intp tmplen;
 
     /* Handle NaT, and treat a datetime with generic units as NaT */
     if (dts->year == NPY_DATETIME_NAT || base == NPY_FR_GENERIC) {
diff --git a/numpy/core/src/multiarray/datetime_strings.h b/numpy/core/src/multiarray/datetime_strings.h
index d7608565c12..4e60ce9298f 100644
--- a/numpy/core/src/multiarray/datetime_strings.h
+++ b/numpy/core/src/multiarray/datetime_strings.h
@@ -70,7 +70,7 @@ get_datetime_iso_8601_strlen(int local, NPY_DATETIMEUNIT base);
  *  string was too short).
  */
 NPY_NO_EXPORT int
-make_iso_8601_datetime(npy_datetimestruct *dts, char *outstr, int outlen,
+make_iso_8601_datetime(npy_datetimestruct *dts, char *outstr, npy_intp outlen,
                     int local, int utc, NPY_DATETIMEUNIT base, int tzoffset,
                     NPY_CASTING casting);
 
diff --git a/numpy/core/src/multiarray/descriptor.c b/numpy/core/src/multiarray/descriptor.c
index 1ae6e34a6c2..dc6238e8494 100644
--- a/numpy/core/src/multiarray/descriptor.c
+++ b/numpy/core/src/multiarray/descriptor.c
@@ -355,7 +355,7 @@ _convert_from_tuple(PyObject *obj)
             npy_free_cache_dim_obj(shape);
             goto fail;
         }
-        newdescr->elsize = type->elsize * items;
+        newdescr->elsize = type->elsize * (int) items;
         if (newdescr->elsize == -1) {
             npy_free_cache_dim_obj(shape);
             goto fail;
@@ -420,7 +420,8 @@ _convert_from_tuple(PyObject *obj)
 static PyArray_Descr *
 _convert_from_array_descr(PyObject *obj, int align)
 {
-    int n, i, totalsize;
+    npy_intp n, i;
+    int totalsize;
     int ret;
     PyObject *fields, *item, *newobj;
     PyObject *name, *tup, *title;
@@ -617,7 +618,7 @@ _convert_from_array_descr(PyObject *obj, int align)
 static PyArray_Descr *
 _convert_from_list(PyObject *obj, int align)
 {
-    int n, i;
+    npy_intp n, i;
     int totalsize;
     PyObject *fields;
     PyArray_Descr *conv = NULL;
@@ -1019,7 +1020,7 @@ _convert_from_dict(PyObject *obj, int align)
     PyObject *fields = NULL;
     PyObject *names, *offsets, *descrs, *titles, *tmp;
     PyObject *metadata;
-    int n, i;
+    npy_intp n, i;
     int totalsize, itemsize;
     int maxalign = 0;
     /* Types with fields need the Python C API for field access */
@@ -1087,7 +1088,7 @@ _convert_from_dict(PyObject *obj, int align)
         /* Build item to insert (descr, offset, [title])*/
         len = 2;
         title = NULL;
-        ind = PyInt_FromLong(i);
+        ind = PyInt_FromSsize_t(i);
         if (titles) {
             title=PyObject_GetItem(titles, ind);
             if (title && title != Py_None) {
@@ -1861,9 +1862,9 @@ arraydescr_typename_get(PyArray_Descr *self)
     PyTypeObject *typeobj = self->typeobj;
     PyObject *res;
     char *s;
-    int len;
-    int prefix_len;
-    int suffix_len;
+    npy_intp len;
+    npy_intp prefix_len;
+    npy_intp suffix_len;
 
     if (PyTypeNum_ISUSERDEF(self->type_num)) {
         s = strrchr(typeobj->tp_name, '.');
@@ -1963,7 +1964,7 @@ arraydescr_ndim_get(PyArray_Descr *self)
      */
     if (PyTuple_Check(self->subarray->shape)) {
         Py_ssize_t ndim = PyTuple_Size(self->subarray->shape);
-        return PyInt_FromLong(ndim);
+        return PyInt_FromSsize_t(ndim);
     }
     /* consistent with arraydescr_shape_get */
     return PyInt_FromLong(1);
@@ -2119,8 +2120,8 @@ arraydescr_names_get(PyArray_Descr *self)
 static int
 arraydescr_names_set(PyArray_Descr *self, PyObject *val)
 {
-    int N = 0;
-    int i;
+    npy_intp N;
+    npy_intp i;
     PyObject *new_names;
     PyObject *new_fields;
 
@@ -3039,7 +3040,7 @@ PyArray_DescrNewByteorder(PyArray_Descr *self, char newendian)
         PyObject *old;
         PyArray_Descr *newdescr;
         Py_ssize_t pos = 0;
-        int len, i;
+        npy_intp len, i;
 
         newfields = PyDict_New();
         /* make new dictionary with replaced PyArray_Descr Objects */
@@ -3806,9 +3807,9 @@ descr_subscript(PyArray_Descr *self, PyObject *op)
     }
     else if (PyInt_Check(op)) {
         PyObject *name;
-        int size = PyTuple_GET_SIZE(self->names);
-        int value = PyArray_PyIntAsInt(op);
-        int orig_value = value;
+        npy_intp size = PyTuple_GET_SIZE(self->names);
+        npy_intp value = PyArray_PyIntAsIntp(op);
+        npy_intp orig_value = value;
 
         if (PyErr_Occurred()) {
             return NULL;
diff --git a/numpy/core/src/multiarray/dtype_transfer.c b/numpy/core/src/multiarray/dtype_transfer.c
index 9c27255aa52..7d56a712daf 100644
--- a/numpy/core/src/multiarray/dtype_transfer.c
+++ b/numpy/core/src/multiarray/dtype_transfer.c
@@ -2535,7 +2535,7 @@ get_fields_transfer_function(int aligned,
 {
     PyObject *key, *tup, *title;
     PyArray_Descr *src_fld_dtype, *dst_fld_dtype;
-    npy_int i, field_count, structsize;
+    npy_intp i, field_count, structsize;
     int src_offset, dst_offset;
     _field_transfer_data *data;
     _single_field_transfer *fields;
@@ -2747,7 +2747,7 @@ get_decsrcref_fields_transfer_function(int aligned,
 {
     PyObject *names, *key, *tup, *title;
     PyArray_Descr *src_fld_dtype;
-    npy_int i, names_size, field_count, structsize;
+    npy_intp i, names_size, field_count, structsize;
     int src_offset;
     _field_transfer_data *data;
     _single_field_transfer *fields;
@@ -2818,7 +2818,7 @@ get_setdestzero_fields_transfer_function(int aligned,
 {
     PyObject *names, *key, *tup, *title;
     PyArray_Descr *dst_fld_dtype;
-    npy_int i, names_size, field_count, structsize;
+    npy_intp i, names_size, field_count, structsize;
     int dst_offset;
     _field_transfer_data *data;
     _single_field_transfer *fields;
@@ -3805,7 +3805,7 @@ PyArray_PrepareOneRawArrayIter(int ndim, npy_intp *shape,
     /* Sort the axes based on the destination strides */
     PyArray_CreateSortedStridePerm(ndim, strides, strideperm);
     for (i = 0; i < ndim; ++i) {
-        int iperm = strideperm[ndim - i - 1].perm;
+        npy_intp iperm = strideperm[ndim - i - 1].perm;
         out_shape[i] = shape[iperm];
         out_strides[i] = strides[iperm];
     }
@@ -3935,7 +3935,7 @@ PyArray_PrepareTwoRawArrayIter(int ndim, npy_intp *shape,
     /* Sort the axes based on the destination strides */
     PyArray_CreateSortedStridePerm(ndim, stridesA, strideperm);
     for (i = 0; i < ndim; ++i) {
-        int iperm = strideperm[ndim - i - 1].perm;
+        npy_intp iperm = strideperm[ndim - i - 1].perm;
         out_shape[i] = shape[iperm];
         out_stridesA[i] = stridesA[iperm];
         out_stridesB[i] = stridesB[iperm];
@@ -4069,7 +4069,7 @@ PyArray_PrepareThreeRawArrayIter(int ndim, npy_intp *shape,
     /* Sort the axes based on the destination strides */
     PyArray_CreateSortedStridePerm(ndim, stridesA, strideperm);
     for (i = 0; i < ndim; ++i) {
-        int iperm = strideperm[ndim - i - 1].perm;
+        npy_intp iperm = strideperm[ndim - i - 1].perm;
         out_shape[i] = shape[iperm];
         out_stridesA[i] = stridesA[iperm];
         out_stridesB[i] = stridesB[iperm];
diff --git a/numpy/core/src/multiarray/einsum.c.src b/numpy/core/src/multiarray/einsum.c.src
index 943b8aecfd9..57b00e3775c 100644
--- a/numpy/core/src/multiarray/einsum.c.src
+++ b/numpy/core/src/multiarray/einsum.c.src
@@ -602,8 +602,8 @@ finish_after_unrolled_loop:
         while (count >= 8) {
             count -= 8;
 
-            _mm_prefetch(data0 + 512, _MM_HINT_T0);
-            _mm_prefetch(data1 + 512, _MM_HINT_T0);
+            _mm_prefetch((char *) (data0 + 512), _MM_HINT_T0);
+            _mm_prefetch((char *) (data1 + 512), _MM_HINT_T0);
 
 /**begin repeat2
  * #i = 0, 4#
@@ -636,8 +636,8 @@ finish_after_unrolled_loop:
         while (count >= 8) {
             count -= 8;
 
-            _mm_prefetch(data0 + 512, _MM_HINT_T0);
-            _mm_prefetch(data1 + 512, _MM_HINT_T0);
+            _mm_prefetch((char *) (data0 + 512), _MM_HINT_T0);
+            _mm_prefetch((char *) (data1 + 512), _MM_HINT_T0);
 
 /**begin repeat2
  * #i = 0, 2, 4, 6#
@@ -668,8 +668,8 @@ finish_after_unrolled_loop:
         count -= 8;
 
 #if EINSUM_USE_SSE1 && @float32@
-        _mm_prefetch(data0 + 512, _MM_HINT_T0);
-        _mm_prefetch(data1 + 512, _MM_HINT_T0);
+        _mm_prefetch((char *) (data0 + 512), _MM_HINT_T0);
+        _mm_prefetch((char *) (data1 + 512), _MM_HINT_T0);
 
 /**begin repeat2
  * #i = 0, 4#
@@ -682,8 +682,8 @@ finish_after_unrolled_loop:
         accum_sse = _mm_add_ps(accum_sse, a);
 /**end repeat2**/
 #elif EINSUM_USE_SSE2 && @float64@
-        _mm_prefetch(data0 + 512, _MM_HINT_T0);
-        _mm_prefetch(data1 + 512, _MM_HINT_T0);
+        _mm_prefetch((char *) (data0 + 512), _MM_HINT_T0);
+        _mm_prefetch((char *) (data1 + 512), _MM_HINT_T0);
 
 /**begin repeat2
  * #i = 0, 2, 4, 6#
@@ -1075,7 +1075,7 @@ finish_after_unrolled_loop:
         while (count >= 8) {
             count -= 8;
 
-            _mm_prefetch(data0 + 512, _MM_HINT_T0);
+            _mm_prefetch((char *) (data0 + 512), _MM_HINT_T0);
 
 /**begin repeat2
  * #i = 0, 4#
@@ -1106,7 +1106,7 @@ finish_after_unrolled_loop:
         while (count >= 8) {
             count -= 8;
 
-            _mm_prefetch(data0 + 512, _MM_HINT_T0);
+            _mm_prefetch((char *) (data0 + 512), _MM_HINT_T0);
 
 /**begin repeat2
  * #i = 0, 2, 4, 6#
@@ -1135,7 +1135,7 @@ finish_after_unrolled_loop:
         count -= 8;
 
 #if EINSUM_USE_SSE1 && @float32@
-        _mm_prefetch(data0 + 512, _MM_HINT_T0);
+        _mm_prefetch((char *) (data0 + 512), _MM_HINT_T0);
 
 /**begin repeat2
  * #i = 0, 4#
@@ -1147,7 +1147,7 @@ finish_after_unrolled_loop:
         accum_sse = _mm_add_ps(accum_sse, _mm_loadu_ps(data0+@i@));
 /**end repeat2**/
 #elif EINSUM_USE_SSE2 && @float64@
-        _mm_prefetch(data0 + 512, _MM_HINT_T0);
+        _mm_prefetch((char *) (data0 + 512), _MM_HINT_T0);
 
 /**begin repeat2
  * #i = 0, 2, 4, 6#
@@ -2080,7 +2080,7 @@ get_single_op_view(PyArrayObject *op, int  iop, char *labels,
     npy_intp new_strides[NPY_MAXDIMS];
     npy_intp new_dims[NPY_MAXDIMS];
     char *out_label;
-    int label, i, idim, ndim, ibroadcast = 0;
+    int label, idim, ndim, ibroadcast = 0;
 
     ndim = PyArray_NDIM(op);
 
@@ -2119,6 +2119,8 @@ get_single_op_view(PyArrayObject *op, int  iop, char *labels,
             ++ibroadcast;
         }
         else {
+            npy_intp i;
+
             /* Find the position for this dimension in the output */
             out_label = (char *)memchr(output_labels, label,
                                                     ndim_output);
@@ -2319,7 +2321,7 @@ prepare_op_axes(int ndim, int iop, char *labels, int *axes,
             }
             /* Otherwise use it */
             else {
-                axes[i] = match - labels;
+                axes[i] = (int) (match - labels);
             }
         }
     }
@@ -2673,7 +2675,7 @@ PyArray_EinsteinSum(char *subscripts, npy_intp nop,
      */
     ndim_broadcast = 0;
     for (iop = 0; iop < nop; ++iop) {
-        npy_intp count_zeros = 0;
+        int count_zeros = 0;
         int ndim;
         char *labels = op_labels[iop];
 
@@ -2729,7 +2731,8 @@ PyArray_EinsteinSum(char *subscripts, npy_intp nop,
         subscripts += 2;
 
         /* Parse the output subscript string */
-        ndim_output = parse_output_subscripts(subscripts, strlen(subscripts),
+        ndim_output = parse_output_subscripts(subscripts,
+                                        (int) strlen(subscripts),
                                         ndim_broadcast, label_counts,
                                         output_labels);
     }
@@ -2872,7 +2875,7 @@ PyArray_EinsteinSum(char *subscripts, npy_intp nop,
                     NPY_ITER_NO_BROADCAST;
 
     /* Allocate the iterator */
-    iter = NpyIter_AdvancedNew(nop+1, op, NPY_ITER_EXTERNAL_LOOP|
+    iter = NpyIter_AdvancedNew((int)(nop+1), op, NPY_ITER_EXTERNAL_LOOP|
                 ((dtype != NULL) ? 0 : NPY_ITER_COMMON_DTYPE)|
                                        NPY_ITER_BUFFERED|
                                        NPY_ITER_DELAY_BUFALLOC|
@@ -2953,7 +2956,7 @@ PyArray_EinsteinSum(char *subscripts, npy_intp nop,
      * the strides that are fixed for the whole loop.
      */
     NpyIter_GetInnerFixedStrideArray(iter, fixed_strides);
-    sop = get_sum_of_products_function(nop,
+    sop = get_sum_of_products_function((int) nop,
                         NpyIter_GetDescrArray(iter)[0]->type_num,
                         NpyIter_GetDescrArray(iter)[0]->elsize,
                         fixed_strides);
@@ -2989,7 +2992,7 @@ PyArray_EinsteinSum(char *subscripts, npy_intp nop,
         NPY_BEGIN_THREADS_NDITER(iter);
         NPY_EINSUM_DBG_PRINT("Einsum loop\n");
         do {
-            sop(nop, dataptr, stride, *countptr);
+            sop((int) nop, dataptr, stride, *countptr);
         } while(iternext(iter));
         NPY_END_THREADS;
 
diff --git a/numpy/core/src/multiarray/flagsobject.c b/numpy/core/src/multiarray/flagsobject.c
index 7f56ddb038a..4854ba2220d 100644
--- a/numpy/core/src/multiarray/flagsobject.c
+++ b/numpy/core/src/multiarray/flagsobject.c
@@ -416,7 +416,7 @@ arrayflags_getitem(PyArrayFlagsObject *self, PyObject *ind)
 {
     char *key = NULL;
     char buf[16];
-    int n;
+    npy_intp n;
     if (PyUnicode_Check(ind)) {
         PyObject *tmp_str;
         tmp_str = PyUnicode_AsASCIIString(ind);
@@ -534,7 +534,7 @@ arrayflags_setitem(PyArrayFlagsObject *self, PyObject *ind, PyObject *item)
 {
     char *key;
     char buf[16];
-    int n;
+    npy_intp n;
     if (PyUnicode_Check(ind)) {
         PyObject *tmp_str;
         tmp_str = PyUnicode_AsASCIIString(ind);
diff --git a/numpy/core/src/multiarray/getset.c b/numpy/core/src/multiarray/getset.c
index 77d9b8c666e..a6f6d8514b5 100644
--- a/numpy/core/src/multiarray/getset.c
+++ b/numpy/core/src/multiarray/getset.c
@@ -149,7 +149,7 @@ array_strides_set(PyArrayObject *self, PyObject *obj)
     }
 
     /* numbytes == 0 is special here, but the 0-size array case always works */
-    if (!PyArray_CheckStrides(PyArray_ITEMSIZE(self), PyArray_NDIM(self),
+    if (!PyArray_CheckStrides((int) PyArray_ITEMSIZE(self), PyArray_NDIM(self),
                               numbytes, offset,
                               PyArray_DIMS(self), newstrides.ptr)) {
         PyErr_SetString(PyExc_ValueError, "strides is not "\
diff --git a/numpy/core/src/multiarray/item_selection.c b/numpy/core/src/multiarray/item_selection.c
index 21bcd6cadd9..641726a9b76 100644
--- a/numpy/core/src/multiarray/item_selection.c
+++ b/numpy/core/src/multiarray/item_selection.c
@@ -35,7 +35,8 @@ PyArray_TakeFrom(PyArrayObject *self0, PyObject *indices0, int axis,
     PyArray_Descr *dtype;
     PyArray_FastTakeFunc *func;
     PyArrayObject *obj = NULL, *self, *indices;
-    npy_intp nd, i, j, n, m, k, max_item, tmp, chunk, itemsize, nelem;
+    npy_intp i, j, n, m, k, max_item, tmp, chunk, itemsize, nelem;
+    int ax_i, nd;
     npy_intp shape[NPY_MAXDIMS];
     char *src, *dest, *tmp_src;
     int err;
@@ -56,19 +57,19 @@ PyArray_TakeFrom(PyArrayObject *self0, PyObject *indices0, int axis,
 
     n = m = chunk = 1;
     nd = PyArray_NDIM(self) + PyArray_NDIM(indices) - 1;
-    for (i = 0; i < nd; i++) {
-        if (i < axis) {
-            shape[i] = PyArray_DIMS(self)[i];
-            n *= shape[i];
+    for (ax_i = 0; ax_i < nd; ax_i++) {
+        if (ax_i < axis) {
+            shape[ax_i] = PyArray_DIMS(self)[ax_i];
+            n *= shape[ax_i];
         }
         else {
-            if (i < axis+PyArray_NDIM(indices)) {
-                shape[i] = PyArray_DIMS(indices)[i-axis];
-                m *= shape[i];
+            if (ax_i < axis+PyArray_NDIM(indices)) {
+                shape[ax_i] = PyArray_DIMS(indices)[ax_i-axis];
+                m *= shape[ax_i];
             }
             else {
-                shape[i] = PyArray_DIMS(self)[i-PyArray_NDIM(indices)+1];
-                chunk *= shape[i];
+                shape[ax_i] = PyArray_DIMS(self)[ax_i-PyArray_NDIM(indices)+1];
+                chunk *= shape[ax_i];
             }
         }
     }
diff --git a/numpy/core/src/multiarray/iterators.c b/numpy/core/src/multiarray/iterators.c
index b8cf4edf651..b7cf367dccf 100644
--- a/numpy/core/src/multiarray/iterators.c
+++ b/numpy/core/src/multiarray/iterators.c
@@ -91,115 +91,6 @@ parse_index_entry(PyObject *op, npy_intp *step_size,
     return -1;
 }
 
-
-/*
- * Parses an index that has no fancy indexing. Populates
- * out_dimensions, out_strides, and out_offset.
- */
-NPY_NO_EXPORT int
-parse_index(PyArrayObject *self, PyObject *op,
-            npy_intp *out_dimensions,
-            npy_intp *out_strides,
-            npy_intp *out_offset,
-            int check_index)
-{
-    int i, j, n;
-    int nd_old, nd_new, n_add, n_ellipsis;
-    npy_intp n_steps, start, offset, step_size;
-    PyObject *op1 = NULL;
-    int is_slice;
-
-    if (PySlice_Check(op) || op == Py_Ellipsis || op == Py_None) {
-        n = 1;
-        op1 = op;
-        Py_INCREF(op);
-        /* this relies on the fact that n==1 for loop below */
-        is_slice = 1;
-    }
-    else {
-        if (!PySequence_Check(op)) {
-            PyErr_SetString(PyExc_IndexError,
-                            "index must be either an int "
-                            "or a sequence");
-            return -1;
-        }
-        n = PySequence_Length(op);
-        is_slice = 0;
-    }
-
-    nd_old = nd_new = 0;
-
-    offset = 0;
-    for (i = 0; i < n; i++) {
-        if (!is_slice) {
-            op1 = PySequence_GetItem(op, i);
-            if (op1 == NULL) {
-                return -1;
-            }
-        }
-        start = parse_index_entry(op1, &step_size, &n_steps,
-                                  nd_old < PyArray_NDIM(self) ?
-                                  PyArray_DIMS(self)[nd_old] : 0,
-                                  nd_old, check_index ?
-                                  nd_old < PyArray_NDIM(self) : 0);
-        Py_DECREF(op1);
-        if (start == -1) {
-            break;
-        }
-        if (n_steps == NEWAXIS_INDEX) {
-            out_dimensions[nd_new] = 1;
-            out_strides[nd_new] = 0;
-            nd_new++;
-        }
-        else if (n_steps == ELLIPSIS_INDEX) {
-            for (j = i + 1, n_ellipsis = 0; j < n; j++) {
-                op1 = PySequence_GetItem(op, j);
-                if (op1 == Py_None) {
-                    n_ellipsis++;
-                }
-                Py_DECREF(op1);
-            }
-            n_add = PyArray_NDIM(self)-(n-i-n_ellipsis-1+nd_old);
-            if (n_add < 0) {
-                PyErr_SetString(PyExc_IndexError, "too many indices");
-                return -1;
-            }
-            for (j = 0; j < n_add; j++) {
-                out_dimensions[nd_new] = PyArray_DIMS(self)[nd_old];
-                out_strides[nd_new] = PyArray_STRIDES(self)[nd_old];
-                nd_new++; nd_old++;
-            }
-        }
-        else {
-            if (nd_old >= PyArray_NDIM(self)) {
-                PyErr_SetString(PyExc_IndexError, "too many indices");
-                return -1;
-            }
-            offset += PyArray_STRIDES(self)[nd_old]*start;
-            nd_old++;
-            if (n_steps != SINGLE_INDEX) {
-                out_dimensions[nd_new] = n_steps;
-                out_strides[nd_new] = step_size *
-                                            PyArray_STRIDES(self)[nd_old-1];
-                nd_new++;
-            }
-        }
-    }
-    if (i < n) {
-        return -1;
-    }
-    n_add = PyArray_NDIM(self)-nd_old;
-    for (j = 0; j < n_add; j++) {
-        out_dimensions[nd_new] = PyArray_DIMS(self)[nd_old];
-        out_strides[nd_new] = PyArray_STRIDES(self)[nd_old];
-        nd_new++;
-        nd_old++;
-    }
-    *out_offset = offset;
-    return nd_new;
-}
-
-
 /*********************** Element-wise Array Iterator ***********************/
 /*  Aided by Peter J. Verveer's  nd_image package and numpy's arraymap  ****/
 /*         and Python's array iterator                                   ***/
@@ -652,7 +543,7 @@ iter_subscript(PyArrayIterObject *self, PyObject *ind)
         return obj;
     }
     if (PyTuple_Check(ind)) {
-        int len;
+        npy_intp len;
         len = PyTuple_GET_SIZE(ind);
         if (len > 1) {
             goto fail;
@@ -900,7 +791,7 @@ iter_ass_subscript(PyArrayIterObject *self, PyObject *ind, PyObject *val)
     }
 
     if (PyTuple_Check(ind)) {
-        int len;
+        npy_intp len;
         len = PyTuple_GET_SIZE(ind);
         if (len > 1) {
             goto finish;
@@ -1488,7 +1379,7 @@ static PyObject *
 arraymultiter_new(PyTypeObject *NPY_UNUSED(subtype), PyObject *args, PyObject *kwds)
 {
 
-    Py_ssize_t n = 0;
+    int n = 0;
     Py_ssize_t i, j, k;
     PyArrayMultiIterObject *multi;
     PyObject *arr;
diff --git a/numpy/core/src/multiarray/mapping.c b/numpy/core/src/multiarray/mapping.c
index 1a92365c8d8..0fa9248fb51 100644
--- a/numpy/core/src/multiarray/mapping.c
+++ b/numpy/core/src/multiarray/mapping.c
@@ -155,10 +155,11 @@ multi_DECREF(PyObject **objects, npy_intp n)
  * Useful if a tuple is being iterated over multiple times, or for a code path
  * that doesn't always want the overhead of allocating a tuple.
  */
-static NPY_INLINE npy_intp
-unpack_tuple(PyTupleObject *index, PyObject **result, npy_intp result_n)
+static NPY_INLINE int
+unpack_tuple(PyTupleObject *index, PyObject **result, int result_n)
 {
-    npy_intp n, i;
+    npy_intp n;
+    int i;
     n = PyTuple_GET_SIZE(index);
     if (n > result_n) {
         PyErr_SetString(PyExc_IndexError,
@@ -169,12 +170,12 @@ unpack_tuple(PyTupleObject *index, PyObject **result, npy_intp result_n)
         result[i] = PyTuple_GET_ITEM(index, i);
         Py_INCREF(result[i]);
     }
-    return n;
+    return (int) n;
 }
 
 /* Unpack a single scalar index, taking a new reference to match unpack_tuple */
-static NPY_INLINE npy_intp
-unpack_scalar(PyObject *index, PyObject **result, npy_intp result_n)
+static NPY_INLINE int
+unpack_scalar(PyObject *index, PyObject **result, int result_n)
 {
     Py_INCREF(index);
     result[0] = index;
@@ -212,10 +213,11 @@ unpack_scalar(PyObject *index, PyObject **result, npy_intp result_n)
  *                   to NULL, so are not safe to Py_XDECREF. Use multi_DECREF to
  *                   dispose of them.
  */
-NPY_NO_EXPORT npy_intp
-unpack_indices(PyObject *index, PyObject **result, npy_intp result_n)
+NPY_NO_EXPORT int
+unpack_indices(PyObject *index, PyObject **result, int result_n)
 {
-    npy_intp n, i;
+    npy_intp n;
+    int i;
     npy_bool commit_to_unpack;
 
     /* Fast route for passing a tuple */
@@ -243,6 +245,7 @@ unpack_indices(PyObject *index, PyObject **result, npy_intp result_n)
      * allocation, but doesn't need to be a fast path anyway
      */
     if (PyTuple_Check(index)) {
+        int n;
         PyTupleObject *tup = (PyTupleObject *) PySequence_Tuple(index);
         if (tup == NULL) {
             return -1;
@@ -320,7 +323,7 @@ unpack_indices(PyObject *index, PyObject **result, npy_intp result_n)
 
     /* unpacking was the right thing to do, and we already did it */
     if (commit_to_unpack) {
-        return n;
+        return (int) n;
     }
     /* got to the end, never found an indication that we should have unpacked */
     else {
@@ -362,7 +365,6 @@ prepare_index(PyArrayObject *self, PyObject *index,
     int curr_idx, get_idx;
 
     int i;
-    npy_intp n;
 
     PyObject *obj = NULL;
     PyArrayObject *arr;
@@ -527,6 +529,7 @@ prepare_index(PyArrayObject *self, PyObject *index,
 
         /* Check if the array is valid and fill the information */
         if (PyArray_ISBOOL(arr)) {
+            int n;
             /*
              * There are two types of boolean indices (which are equivalent,
              * for the most part though). A single boolean index of matching
@@ -560,6 +563,8 @@ prepare_index(PyArrayObject *self, PyObject *index,
             }
 
             if (PyArray_NDIM(arr) == 0) {
+                npy_intp len;
+
                 /*
                  * This can actually be well defined. A new axis is added,
                  * but at the same time no axis is "used". So if we have True,
@@ -572,13 +577,13 @@ prepare_index(PyArrayObject *self, PyObject *index,
 
                 /* TODO: This can't fail, right? Is there a faster way? */
                 if (PyObject_IsTrue((PyObject *)arr)) {
-                    n = 1;
+                    len = 1;
                 }
                 else {
-                    n = 0;
+                    len = 0;
                 }
-                indices[curr_idx].value = n;
-                indices[curr_idx].object = PyArray_Zeros(1, &n,
+                indices[curr_idx].value = len;
+                indices[curr_idx].object = PyArray_Zeros(1, &len,
                                             PyArray_DescrFromType(NPY_INTP), 0);
                 Py_DECREF(arr);
 
@@ -695,26 +700,26 @@ prepare_index(PyArrayObject *self, PyObject *index,
      * to find the ellipsis value or append an ellipsis if necessary.
      */
     if (used_ndim < PyArray_NDIM(self)) {
-       if (index_type & HAS_ELLIPSIS) {
-           indices[ellipsis_pos].value = PyArray_NDIM(self) - used_ndim;
-           used_ndim = PyArray_NDIM(self);
-           new_ndim += indices[ellipsis_pos].value;
-       }
-       else {
-           /*
-            * There is no ellipsis yet, but it is not a full index
-            * so we append an ellipsis to the end.
-            */
-           index_type |= HAS_ELLIPSIS;
-           indices[curr_idx].object = NULL;
-           indices[curr_idx].type = HAS_ELLIPSIS;
-           indices[curr_idx].value = PyArray_NDIM(self) - used_ndim;
-           ellipsis_pos = curr_idx;
-
-           used_ndim = PyArray_NDIM(self);
-           new_ndim += indices[curr_idx].value;
-           curr_idx += 1;
-       }
+        if (index_type & HAS_ELLIPSIS) {
+            indices[ellipsis_pos].value = PyArray_NDIM(self) - used_ndim;
+            used_ndim = PyArray_NDIM(self);
+            new_ndim += (int) indices[ellipsis_pos].value;
+        }
+        else {
+            /*
+             * There is no ellipsis yet, but it is not a full index
+             * so we append an ellipsis to the end.
+             */
+            index_type |= HAS_ELLIPSIS;
+            indices[curr_idx].object = NULL;
+            indices[curr_idx].type = HAS_ELLIPSIS;
+            indices[curr_idx].value = PyArray_NDIM(self) - used_ndim;
+            ellipsis_pos = curr_idx;
+
+            used_ndim = PyArray_NDIM(self);
+            new_ndim += (int) indices[curr_idx].value;
+            curr_idx += 1;
+        }
     }
     else if (used_ndim > PyArray_NDIM(self)) {
         PyErr_SetString(PyExc_IndexError,
@@ -787,7 +792,7 @@ prepare_index(PyArrayObject *self, PyObject *index,
             }
 
             if (indices[i].type == HAS_ELLIPSIS) {
-                used_ndim += indices[i].value;
+                used_ndim += (int) indices[i].value;
             }
             else if ((indices[i].type == HAS_NEWAXIS) ||
                      (indices[i].type == HAS_0D_BOOL)) {
@@ -1441,7 +1446,7 @@ _get_field_view(PyArrayObject *arr, PyObject *ind, PyArrayObject **view)
     }
     /* next check for a list of field names */
     else if (PySequence_Check(ind) && !PyTuple_Check(ind)) {
-        int seqlen, i;
+        npy_intp seqlen, i;
         PyObject *name = NULL, *tup;
         PyObject *fields, *names;
         PyArray_Descr *view_dtype;
diff --git a/numpy/core/src/multiarray/methods.c b/numpy/core/src/multiarray/methods.c
index efa97dd6515..5e31f2ebb7f 100644
--- a/numpy/core/src/multiarray/methods.c
+++ b/numpy/core/src/multiarray/methods.c
@@ -82,7 +82,7 @@ forward_ndarray_method(PyArrayObject *self, PyObject *args, PyObject *kwds,
                             PyObject *forwarding_callable)
 {
     PyObject *sargs, *ret;
-    int i, n;
+    npy_intp i, n;
 
     /* Combine 'self' and 'args' together into one tuple */
     n = PyTuple_GET_SIZE(args);
@@ -612,7 +612,7 @@ static PyObject *
 array_toscalar(PyArrayObject *self, PyObject *args)
 {
     npy_intp multi_index[NPY_MAXDIMS];
-    int n = PyTuple_GET_SIZE(args);
+    npy_intp n = PyTuple_GET_SIZE(args);
     int idim, ndim = PyArray_NDIM(self);
 
     /* If there is a tuple as a single argument, treat it as the argument */
@@ -678,7 +678,7 @@ static PyObject *
 array_setscalar(PyArrayObject *self, PyObject *args)
 {
     npy_intp multi_index[NPY_MAXDIMS];
-    int n = PyTuple_GET_SIZE(args) - 1;
+    npy_intp n = PyTuple_GET_SIZE(args) - 1;
     int idim, ndim = PyArray_NDIM(self);
     PyObject *obj;
 
diff --git a/numpy/core/src/multiarray/multiarraymodule.c b/numpy/core/src/multiarray/multiarraymodule.c
index 66a076dc6f3..fc1cd2ca018 100644
--- a/numpy/core/src/multiarray/multiarraymodule.c
+++ b/numpy/core/src/multiarray/multiarraymodule.c
@@ -319,10 +319,10 @@ PyArray_Free(PyObject *op, void *ptr)
  * Get the ndarray subclass with the highest priority
  */
 NPY_NO_EXPORT PyTypeObject *
-PyArray_GetSubType(int narrays, PyArrayObject **arrays) {
+PyArray_GetSubType(npy_intp narrays, PyArrayObject **arrays) {
     PyTypeObject *subtype = &PyArray_Type;
     double priority = NPY_PRIORITY;
-    int i;
+    npy_intp i;
 
     /* Get the priority subtype for the array */
     for (i = 0; i < narrays; ++i) {
@@ -343,10 +343,11 @@ PyArray_GetSubType(int narrays, PyArrayObject **arrays) {
  * Concatenates a list of ndarrays.
  */
 NPY_NO_EXPORT PyArrayObject *
-PyArray_ConcatenateArrays(int narrays, PyArrayObject **arrays, int axis,
+PyArray_ConcatenateArrays(npy_intp narrays, PyArrayObject **arrays, int axis,
                           PyArrayObject* ret)
 {
-    int iarrays, idim, ndim;
+    npy_intp iarrays;
+    int idim, ndim;
     npy_intp shape[NPY_MAXDIMS];
     PyArrayObject_fields *sliding_view = NULL;
 
@@ -490,10 +491,10 @@ PyArray_ConcatenateArrays(int narrays, PyArrayObject **arrays, int axis,
  * Concatenates a list of ndarrays, flattening each in the specified order.
  */
 NPY_NO_EXPORT PyArrayObject *
-PyArray_ConcatenateFlattenedArrays(int narrays, PyArrayObject **arrays,
+PyArray_ConcatenateFlattenedArrays(npy_intp narrays, PyArrayObject **arrays,
                                     NPY_ORDER order, PyArrayObject *ret)
 {
-    int iarrays;
+    npy_intp iarrays;
     npy_intp shape = 0;
     PyArrayObject_fields *sliding_view = NULL;
 
@@ -594,7 +595,7 @@ PyArray_ConcatenateFlattenedArrays(int narrays, PyArrayObject **arrays,
 NPY_NO_EXPORT PyObject *
 PyArray_ConcatenateInto(PyObject *op, int axis, PyArrayObject *ret)
 {
-    int iarrays, narrays;
+    npy_intp iarrays, narrays;
     PyArrayObject **arrays;
 
     if (!PySequence_Check(op)) {
@@ -2519,16 +2520,19 @@ einsum_sub_op_from_str(PyObject *args, PyObject **str_obj, char **subscripts,
     int i, nop;
     PyObject *subscripts_str;
 
-    nop = PyTuple_GET_SIZE(args) - 1;
-    if (nop <= 0) {
-        PyErr_SetString(PyExc_ValueError,
-                        "must specify the einstein sum subscripts string "
-                        "and at least one operand");
-        return -1;
-    }
-    else if (nop >= NPY_MAXARGS) {
-        PyErr_SetString(PyExc_ValueError, "too many operands");
-        return -1;
+    {
+        npy_intp nop_intp = PyTuple_GET_SIZE(args) - 1;
+        if (nop_intp <= 0) {
+            PyErr_SetString(PyExc_ValueError,
+                            "must specify the einstein sum subscripts string "
+                            "and at least one operand");
+            return -1;
+        }
+        else if (nop_intp >= NPY_MAXARGS) {
+            PyErr_SetString(PyExc_ValueError, "too many operands");
+            return -1;
+        }
+        nop = (int) nop_intp;
     }
 
     /* Get the subscripts string */
@@ -2626,10 +2630,10 @@ einsum_list_to_subscripts(PyObject *obj, char *subscripts, int subsize)
                 return -1;
             }
             if (s < 26) {
-                subscripts[subindex++] = 'A' + s;
+                subscripts[subindex++] = 'A' + (char) s;
             }
             else {
-                subscripts[subindex++] = 'a' + s;
+                subscripts[subindex++] = 'a' + (char) s;
             }
             if (subindex >= subsize) {
                 PyErr_SetString(PyExc_ValueError,
@@ -2664,18 +2668,20 @@ einsum_sub_op_from_lists(PyObject *args,
                 char *subscripts, int subsize, PyArrayObject **op)
 {
     int subindex = 0;
-    npy_intp i, nop;
-
-    nop = PyTuple_Size(args)/2;
+    int i, nop;
 
-    if (nop == 0) {
-        PyErr_SetString(PyExc_ValueError, "must provide at least an "
-                        "operand and a subscripts list to einsum");
-        return -1;
-    }
-    else if(nop >= NPY_MAXARGS) {
-        PyErr_SetString(PyExc_ValueError, "too many operands");
-        return -1;
+    {
+        npy_intp nop_intp = PyTuple_Size(args)/2;
+        if (nop_intp == 0) {
+            PyErr_SetString(PyExc_ValueError, "must provide at least an "
+                            "operand and a subscripts list to einsum");
+            return -1;
+        }
+        else if(nop_intp >= NPY_MAXARGS) {
+            PyErr_SetString(PyExc_ValueError, "too many operands");
+            return -1;
+        }
+        nop = (int) nop_intp;
     }
 
     /* Set the operands to NULL */
@@ -3703,7 +3709,7 @@ _vec_string_with_args(PyArrayObject* char_array, PyArray_Descr* type,
         Py_DECREF(item);
     }
     in_iter = (PyArrayMultiIterObject*)PyArray_MultiIterFromObjects
-        (broadcast_args, nargs, 0);
+        (broadcast_args, (int) nargs, 0);
     if (in_iter == NULL) {
         goto err;
     }
diff --git a/numpy/core/src/multiarray/shape.c b/numpy/core/src/multiarray/shape.c
index 07ab9b626ef..938abc43009 100644
--- a/numpy/core/src/multiarray/shape.c
+++ b/numpy/core/src/multiarray/shape.c
@@ -834,10 +834,11 @@ s_intp_abs(npy_intp x)
  * every array in the arrays list.
  */
 NPY_NO_EXPORT void
-PyArray_CreateMultiSortedStridePerm(int narrays, PyArrayObject **arrays,
+PyArray_CreateMultiSortedStridePerm(npy_intp narrays, PyArrayObject **arrays,
                         int ndim, int *out_strideperm)
 {
-    int i0, i1, ipos, ax_j0, ax_j1, iarrays;
+    int i0, i1, ipos, ax_j0, ax_j1;
+    npy_intp iarrays;
 
     /* Initialize the strideperm values to the identity. */
     for (i0 = 0; i0 < ndim; ++i0) {
diff --git a/numpy/core/src/multiarray/shape.h b/numpy/core/src/multiarray/shape.h
index 0451a463e5f..fcd2a4addf7 100644
--- a/numpy/core/src/multiarray/shape.h
+++ b/numpy/core/src/multiarray/shape.h
@@ -18,7 +18,7 @@ build_shape_string(npy_intp n, npy_intp *vals);
  * every array in the arrays list.
  */
 NPY_NO_EXPORT void
-PyArray_CreateMultiSortedStridePerm(int narrays, PyArrayObject **arrays,
+PyArray_CreateMultiSortedStridePerm(npy_intp narrays, PyArrayObject **arrays,
                         int ndim, int *out_strideperm);
 
 /*
diff --git a/numpy/core/src/multiarray/ucsnarrow.c b/numpy/core/src/multiarray/ucsnarrow.c
index 8e293e9f2d9..ba7e9aaa376 100644
--- a/numpy/core/src/multiarray/ucsnarrow.c
+++ b/numpy/core/src/multiarray/ucsnarrow.c
@@ -30,11 +30,11 @@
  *
  * Values above 0xffff are converted to surrogate pairs.
  */
-NPY_NO_EXPORT int
-PyUCS2Buffer_FromUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, int ucs4length)
+NPY_NO_EXPORT Py_ssize_t
+PyUCS2Buffer_FromUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, Py_ssize_t ucs4length)
 {
-    int i;
-    int numucs2 = 0;
+    Py_ssize_t i;
+    Py_ssize_t numucs2 = 0;
     npy_ucs4 chr;
     for (i = 0; i < ucs4length; i++) {
         chr = *ucs4++;
@@ -62,13 +62,13 @@ PyUCS2Buffer_FromUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, int ucs4length)
  *
  * The return value is the actual size of the used part of the ucs4 buffer.
  */
-NPY_NO_EXPORT int
-PyUCS2Buffer_AsUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, int ucs2len, int ucs4len)
+NPY_NO_EXPORT Py_ssize_t
+PyUCS2Buffer_AsUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, Py_ssize_t ucs2len, Py_ssize_t ucs4len)
 {
-    int i;
+    Py_ssize_t i;
     npy_ucs4 chr;
     Py_UNICODE ch;
-    int numchars=0;
+    Py_ssize_t numchars = 0;
 
     for (i = 0; (i < ucs2len) && (numchars < ucs4len); i++) {
         ch = *ucs2++;
diff --git a/numpy/core/src/multiarray/ucsnarrow.h b/numpy/core/src/multiarray/ucsnarrow.h
index fe31a5e25b4..5194df54318 100644
--- a/numpy/core/src/multiarray/ucsnarrow.h
+++ b/numpy/core/src/multiarray/ucsnarrow.h
@@ -5,7 +5,7 @@ NPY_NO_EXPORT int
 PyUCS2Buffer_FromUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, int ucs4length);
 
 NPY_NO_EXPORT int
-PyUCS2Buffer_AsUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, int ucs2len, int ucs4len);
+PyUCS2Buffer_AsUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, Py_ssize_t ucs2len, Py_ssize_t ucs4len);
 
 NPY_NO_EXPORT PyUnicodeObject *
 PyUnicode_FromUCS4(char *src, Py_ssize_t size, int swap, int align);
diff --git a/numpy/core/src/npymath/npy_math_internal.h.src b/numpy/core/src/npymath/npy_math_internal.h.src
index 44d6f915f17..093e51b2dcd 100644
--- a/numpy/core/src/npymath/npy_math_internal.h.src
+++ b/numpy/core/src/npymath/npy_math_internal.h.src
@@ -659,7 +659,7 @@ npy_divmod@c@(@type@ a, @type@ b, @type@ *modulus)
 
     /* snap quotient to nearest integral value */
     if (div) {
-        floordiv = npy_floor(div);
+        floordiv = npy_floor@c@(div);
         if (div - floordiv > 0.5@c@)
             floordiv += 1.0@c@;
     }
diff --git a/numpy/core/src/private/mem_overlap.c b/numpy/core/src/private/mem_overlap.c
index 2145791e180..d3aa006434d 100644
--- a/numpy/core/src/private/mem_overlap.c
+++ b/numpy/core/src/private/mem_overlap.c
@@ -654,7 +654,7 @@ diophantine_simplify(unsigned int *n, diophantine_term_t *E, npy_int64 b)
 
 /* Gets a half-open range [start, end) of offsets from the data pointer */
 NPY_VISIBILITY_HIDDEN void
-offset_bounds_from_strides(const int itemsize, const int nd,
+offset_bounds_from_strides(const npy_intp itemsize, const int nd,
                            const npy_intp *dims, const npy_intp *strides,
                            npy_intp *lower_offset, npy_intp *upper_offset)
 {
diff --git a/numpy/core/src/private/mem_overlap.h b/numpy/core/src/private/mem_overlap.h
index 8044f166319..88d936508e1 100644
--- a/numpy/core/src/private/mem_overlap.h
+++ b/numpy/core/src/private/mem_overlap.h
@@ -42,7 +42,7 @@ NPY_VISIBILITY_HIDDEN mem_overlap_t
 solve_may_have_internal_overlap(PyArrayObject *a, Py_ssize_t max_work);
 
 NPY_VISIBILITY_HIDDEN void
-offset_bounds_from_strides(const int itemsize, const int nd,
+offset_bounds_from_strides(const npy_intp itemsize, const int nd,
                            const npy_intp *dims, const npy_intp *strides,
                            npy_intp *lower_offset, npy_intp *upper_offset);
 
