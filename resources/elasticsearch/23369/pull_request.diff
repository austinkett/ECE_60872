diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerCaster.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerCaster.java
index dbefd548cd23..8d91aa2b94a3 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerCaster.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/AnalyzerCaster.java
@@ -19,32 +19,41 @@
 
 package org.elasticsearch.painless;
 
-import org.elasticsearch.painless.Definition.Cast;
 import org.elasticsearch.painless.Definition.Sort;
 import org.elasticsearch.painless.Definition.Type;
 
 import java.util.Objects;
 
-import static org.elasticsearch.painless.Definition.BOOLEAN_OBJ_TYPE;
 import static org.elasticsearch.painless.Definition.BOOLEAN_TYPE;
-import static org.elasticsearch.painless.Definition.BYTE_OBJ_TYPE;
 import static org.elasticsearch.painless.Definition.BYTE_TYPE;
-import static org.elasticsearch.painless.Definition.CHAR_OBJ_TYPE;
 import static org.elasticsearch.painless.Definition.CHAR_TYPE;
 import static org.elasticsearch.painless.Definition.DEF_TYPE;
-import static org.elasticsearch.painless.Definition.DOUBLE_OBJ_TYPE;
 import static org.elasticsearch.painless.Definition.DOUBLE_TYPE;
-import static org.elasticsearch.painless.Definition.FLOAT_OBJ_TYPE;
 import static org.elasticsearch.painless.Definition.FLOAT_TYPE;
-import static org.elasticsearch.painless.Definition.INT_OBJ_TYPE;
 import static org.elasticsearch.painless.Definition.INT_TYPE;
-import static org.elasticsearch.painless.Definition.LONG_OBJ_TYPE;
 import static org.elasticsearch.painless.Definition.LONG_TYPE;
-import static org.elasticsearch.painless.Definition.NUMBER_TYPE;
 import static org.elasticsearch.painless.Definition.OBJECT_TYPE;
-import static org.elasticsearch.painless.Definition.SHORT_OBJ_TYPE;
 import static org.elasticsearch.painless.Definition.SHORT_TYPE;
 import static org.elasticsearch.painless.Definition.STRING_TYPE;
+import static org.elasticsearch.painless.WriterConstants.CHAR_TO_STRING;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_BOOLEAN;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_BYTE_EXPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_BYTE_IMPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_CHAR_EXPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_CHAR_IMPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_DOUBLE_EXPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_DOUBLE_IMPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_FLOAT_EXPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_FLOAT_IMPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_INT_EXPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_INT_IMPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_LONG_EXPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_LONG_IMPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_SHORT_EXPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_TO_SHORT_IMPLICIT;
+import static org.elasticsearch.painless.WriterConstants.DEF_UTIL_TYPE;
+import static org.elasticsearch.painless.WriterConstants.STRING_TO_CHAR;
+import static org.elasticsearch.painless.WriterConstants.UTILITY_TYPE;
 
 /**
  * Used during the analysis phase to collect legal type casts and promotions
@@ -52,29 +61,27 @@
  */
 public final class AnalyzerCaster {
 
+    @SuppressWarnings("incomplete-switch") // Missing arms mean the cast is not supported
     public static Cast getLegalCast(Location location, Type actual, Type expected, boolean explicit, boolean internal) {
         Objects.requireNonNull(actual);
         Objects.requireNonNull(expected);
 
         if (actual.equals(expected)) {
-            return null;
+            return Cast.NOOP;
         }
 
         switch (actual.sort) {
             case BOOL:
                 switch (expected.sort) {
                     case DEF:
-                        return new Cast(BOOLEAN_OBJ_TYPE, DEF_TYPE, explicit, null, null, BOOLEAN_TYPE, null);
+                        return new Cast.Box(BOOLEAN_TYPE);
                     case OBJECT:
-                        if (OBJECT_TYPE.equals(expected) && internal)
-                            return new Cast(BOOLEAN_OBJ_TYPE, OBJECT_TYPE, explicit, null, null, BOOLEAN_TYPE, null);
-
+                        if (OBJECT_TYPE.equals(expected) && internal) return new Cast.Box(BOOLEAN_TYPE);
                         break;
                     case BOOL_OBJ:
-                        if (internal)
-                            return new Cast(BOOLEAN_TYPE, BOOLEAN_TYPE, explicit, null, null, null, BOOLEAN_TYPE);
+                        if (internal) return new Cast.Box(BOOLEAN_TYPE);
+                        break;
                 }
-
                 break;
             case BYTE:
                 switch (expected.sort) {
@@ -83,375 +90,249 @@ public static Cast getLegalCast(Location location, Type actual, Type expected, b
                     case LONG:
                     case FLOAT:
                     case DOUBLE:
-                        return new Cast(BYTE_TYPE, expected, explicit);
+                        return new Cast.Numeric(BYTE_TYPE, expected);
                     case CHAR:
-                        if (explicit)
-                            return new Cast(BYTE_TYPE, CHAR_TYPE, true);
-
+                        if (explicit) return new Cast.Numeric(BYTE_TYPE, expected);
                         break;
                     case DEF:
-                        return new Cast(BYTE_OBJ_TYPE, DEF_TYPE, explicit, null, null, BYTE_TYPE, null);
+                        return new Cast.Box(BYTE_TYPE);
                     case OBJECT:
-                        if (OBJECT_TYPE.equals(expected) && internal)
-                            return new Cast(BYTE_OBJ_TYPE, OBJECT_TYPE, explicit, null, null, BYTE_TYPE, null);
-
+                        if (OBJECT_TYPE.equals(expected) && internal) return new Cast.Box(BYTE_TYPE);
                         break;
                     case NUMBER:
-                        if (internal)
-                            return new Cast(BYTE_OBJ_TYPE, NUMBER_TYPE, explicit, null, null, BYTE_TYPE, null);
-
+                        if (internal) return new Cast.Box(BYTE_TYPE);
                         break;
                     case BYTE_OBJ:
-                        if (internal)
-                            return new Cast(BYTE_TYPE, BYTE_TYPE, explicit, null, null, null, BYTE_TYPE);
-
+                        if (internal) return new Cast.Box(BYTE_TYPE);
                         break;
                     case SHORT_OBJ:
-                        if (internal)
-                            return new Cast(BYTE_TYPE, SHORT_TYPE, explicit, null, null, null, SHORT_TYPE);
-
+                        if (internal) return new Cast.Numeric(BYTE_TYPE, SHORT_TYPE, new Cast.Box(SHORT_TYPE));
                         break;
                     case INT_OBJ:
-                        if (internal)
-                            return new Cast(BYTE_TYPE, INT_TYPE, explicit, null, null, null, INT_TYPE);
-
+                        if (internal) return new Cast.Numeric(BYTE_TYPE, INT_TYPE, new Cast.Box(INT_TYPE));
                         break;
                     case LONG_OBJ:
-                        if (internal)
-                            return new Cast(BYTE_TYPE, LONG_TYPE, explicit, null, null, null, LONG_TYPE);
-
+                        if (internal) return new Cast.Numeric(BYTE_TYPE, LONG_TYPE, new Cast.Box(LONG_TYPE));
                         break;
                     case FLOAT_OBJ:
-                        if (internal)
-                            return new Cast(BYTE_TYPE, FLOAT_TYPE, explicit, null, null, null, FLOAT_TYPE);
-
+                        if (internal) return new Cast.Numeric(BYTE_TYPE, FLOAT_TYPE, new Cast.Box(FLOAT_TYPE));
                         break;
                     case DOUBLE_OBJ:
-                        if (internal)
-                            return new Cast(BYTE_TYPE, DOUBLE_TYPE, explicit, null, null, null, DOUBLE_TYPE);
-
+                        if (internal) return new Cast.Numeric(BYTE_TYPE, DOUBLE_TYPE, new Cast.Box(DOUBLE_TYPE));
                         break;
                     case CHAR_OBJ:
-                        if (explicit && internal)
-                            return new Cast(BYTE_TYPE, CHAR_TYPE, true, null, null, null, CHAR_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(BYTE_TYPE, CHAR_TYPE, new Cast.Box(CHAR_TYPE));
                         break;
                 }
-
                 break;
             case SHORT:
                 switch (expected.sort) {
+                    case BYTE:
+                        if (explicit) return new Cast.Numeric(SHORT_TYPE, expected);
+                        break;
                     case INT:
                     case LONG:
                     case FLOAT:
                     case DOUBLE:
-                        return new Cast(SHORT_TYPE, expected, explicit);
-                    case BYTE:
+                        return new Cast.Numeric(SHORT_TYPE, expected);
                     case CHAR:
-                        if (explicit)
-                            return new Cast(SHORT_TYPE, expected, true);
-
+                        if (explicit) return new Cast.Numeric(SHORT_TYPE, expected);
                         break;
                     case DEF:
-                        return new Cast(SHORT_OBJ_TYPE, DEF_TYPE, explicit, null, null, SHORT_TYPE, null);
+                        return new Cast.Box(SHORT_TYPE);
                     case OBJECT:
-                        if (OBJECT_TYPE.equals(expected) && internal)
-                            return new Cast(SHORT_OBJ_TYPE, OBJECT_TYPE, explicit, null, null, SHORT_TYPE, null);
-
+                        if (OBJECT_TYPE.equals(expected) && internal) return new Cast.Box(SHORT_TYPE);
                         break;
                     case NUMBER:
-                        if (internal)
-                            return new Cast(SHORT_OBJ_TYPE, NUMBER_TYPE, explicit, null, null, SHORT_TYPE, null);
-
+                        if (internal) return new Cast.Box(SHORT_TYPE);
+                        break;
+                    case BYTE_OBJ:
+                        if (explicit && internal) return new Cast.Numeric(SHORT_TYPE, BYTE_TYPE, new Cast.Box(BYTE_TYPE));
+                        break;
+                    case CHAR_OBJ:
+                        if (explicit && internal) return new Cast.Numeric(SHORT_TYPE, CHAR_TYPE, new Cast.Box(CHAR_TYPE));
                         break;
                     case SHORT_OBJ:
-                        if (internal)
-                            return new Cast(SHORT_TYPE, SHORT_TYPE, explicit, null, null, null, SHORT_TYPE);
-
+                        if (internal) return new Cast.Box(SHORT_TYPE);
                         break;
                     case INT_OBJ:
-                        if (internal)
-                            return new Cast(SHORT_TYPE, INT_TYPE, explicit, null, null, null, INT_TYPE);
-
+                        if (internal) return new Cast.Numeric(SHORT_TYPE, INT_TYPE, new Cast.Box(INT_TYPE));
                         break;
                     case LONG_OBJ:
-                        if (internal)
-                            return new Cast(SHORT_TYPE, LONG_TYPE, explicit, null, null, null, LONG_TYPE);
-
+                        if (internal) return new Cast.Numeric(SHORT_TYPE, LONG_TYPE, new Cast.Box(LONG_TYPE));
                         break;
                     case FLOAT_OBJ:
-                        if (internal)
-                            return new Cast(SHORT_TYPE, FLOAT_TYPE, explicit, null, null, null, FLOAT_TYPE);
-
+                        if (internal) return new Cast.Numeric(SHORT_TYPE, FLOAT_TYPE, new Cast.Box(FLOAT_TYPE));
                         break;
                     case DOUBLE_OBJ:
-                        if (internal)
-                            return new Cast(SHORT_TYPE, DOUBLE_TYPE, explicit, null, null, null, DOUBLE_TYPE);
-
-                        break;
-                    case BYTE_OBJ:
-                        if (explicit && internal)
-                            return new Cast(SHORT_TYPE, BYTE_TYPE, true, null, null, null, BYTE_TYPE);
-
-                        break;
-                    case CHAR_OBJ:
-                        if (explicit && internal)
-                            return new Cast(SHORT_TYPE, CHAR_TYPE, true, null, null, null, CHAR_TYPE);
-
+                        if (internal) return new Cast.Numeric(SHORT_TYPE, DOUBLE_TYPE, new Cast.Box(DOUBLE_TYPE));
                         break;
                 }
-
                 break;
             case CHAR:
                 switch (expected.sort) {
+                    case BYTE:
+                    case SHORT:
+                        if (explicit) return new Cast.Numeric(CHAR_TYPE, expected);
+                        break;
                     case INT:
                     case LONG:
                     case FLOAT:
                     case DOUBLE:
-                        return new Cast(CHAR_TYPE, expected, explicit);
-                    case BYTE:
-                    case SHORT:
-                        if (explicit)
-                            return new Cast(actual, expected, true);
-
-                        break;
+                        return new Cast.Numeric(CHAR_TYPE, expected);
                     case DEF:
-                        return new Cast(CHAR_OBJ_TYPE, DEF_TYPE, explicit, null, null, CHAR_TYPE, null);
+                        return new Cast.Box(CHAR_TYPE);
                     case OBJECT:
-                        if (OBJECT_TYPE.equals(expected) && internal)
-                            return new Cast(CHAR_OBJ_TYPE, OBJECT_TYPE, explicit, null, null, CHAR_TYPE, null);
-
-                        break;
-                    case NUMBER:
-                        if (internal)
-                            return new Cast(CHAR_OBJ_TYPE, NUMBER_TYPE, explicit, null, null, CHAR_TYPE, null);
-
+                        if (OBJECT_TYPE.equals(expected) && internal) return new Cast.Box(CHAR_TYPE);
                         break;
                     case CHAR_OBJ:
-                        if (internal)
-                            return new Cast(CHAR_TYPE, CHAR_TYPE, explicit, null, null, null, CHAR_TYPE);
-
+                        if (internal) return new Cast.Box(CHAR_TYPE);
                         break;
                     case STRING:
-                        return new Cast(CHAR_TYPE, STRING_TYPE, explicit);
+                        return new Cast.InvokeStatic(UTILITY_TYPE, CHAR_TO_STRING, c -> Utility.charToString((Character) c));
+                    case BYTE_OBJ:
+                        if (explicit && internal) return new Cast.Numeric(CHAR_TYPE, BYTE_TYPE, new Cast.Box(BYTE_TYPE));
+                        break;
+                    case SHORT_OBJ:
+                        if (explicit && internal) return new Cast.Numeric(CHAR_TYPE, SHORT_TYPE, new Cast.Box(SHORT_TYPE));
+                        break;
                     case INT_OBJ:
-                        if (internal)
-                            return new Cast(CHAR_TYPE, INT_TYPE, explicit, null, null, null, INT_TYPE);
-
+                        if (internal) return new Cast.Numeric(CHAR_TYPE, INT_TYPE, new Cast.Box(INT_TYPE));
                         break;
                     case LONG_OBJ:
-                        if (internal)
-                            return new Cast(CHAR_TYPE, LONG_TYPE, explicit, null, null, null, LONG_TYPE);
-
+                        if (internal) return new Cast.Numeric(CHAR_TYPE, LONG_TYPE, new Cast.Box(LONG_TYPE));
                         break;
                     case FLOAT_OBJ:
-                        if (internal)
-                            return new Cast(CHAR_TYPE, FLOAT_TYPE, explicit, null, null, null, FLOAT_TYPE);
-
+                        if (internal) return new Cast.Numeric(CHAR_TYPE, FLOAT_TYPE, new Cast.Box(FLOAT_TYPE));
                         break;
                     case DOUBLE_OBJ:
-                        if (internal)
-                            return new Cast(CHAR_TYPE, DOUBLE_TYPE, explicit, null, null, null, DOUBLE_TYPE);
-
-                        break;
-                    case BYTE_OBJ:
-                        if (explicit && internal)
-                            return new Cast(CHAR_TYPE, BYTE_TYPE, true, null, null, null, BYTE_TYPE);
-
-                        break;
-                    case SHORT_OBJ:
-                        if (explicit && internal)
-                            return new Cast(CHAR_TYPE, SHORT_TYPE, true, null, null, null, SHORT_TYPE);
-
+                        if (internal) return new Cast.Numeric(CHAR_TYPE, DOUBLE_TYPE, new Cast.Box(DOUBLE_TYPE));
                         break;
                 }
-
                 break;
             case INT:
                 switch (expected.sort) {
-                    case LONG:
-                    case FLOAT:
-                    case DOUBLE:
-                        return new Cast(INT_TYPE, expected, explicit);
                     case BYTE:
                     case SHORT:
                     case CHAR:
-                        if (explicit)
-                            return new Cast(INT_TYPE, expected, true);
-
+                        if (explicit) return new Cast.Numeric(INT_TYPE, expected);
                         break;
+                    case LONG:
+                    case FLOAT:
+                    case DOUBLE:
+                        return new Cast.Numeric(INT_TYPE, expected);
                     case DEF:
-                        return new Cast(INT_OBJ_TYPE, DEF_TYPE, explicit, null, null, INT_TYPE, null);
+                        return new Cast.Box(INT_TYPE);
                     case OBJECT:
-                        if (OBJECT_TYPE.equals(expected) && internal)
-                            return new Cast(INT_OBJ_TYPE, OBJECT_TYPE, explicit, null, null, INT_TYPE, null);
-
+                        if (OBJECT_TYPE.equals(expected) && internal) return new Cast.Box(INT_TYPE);
                         break;
                     case NUMBER:
-                        if (internal)
-                            return new Cast(INT_OBJ_TYPE, NUMBER_TYPE, explicit, null, null, INT_TYPE, null);
-
+                        if (internal) return new Cast.Box(INT_TYPE);
+                        break;
+                    case BYTE_OBJ:
+                        if (explicit && internal) return new Cast.Numeric(INT_TYPE, BYTE_TYPE, new Cast.Box(BYTE_TYPE));
+                        break;
+                    case SHORT_OBJ:
+                        if (explicit && internal) return new Cast.Numeric(INT_TYPE, SHORT_TYPE, new Cast.Box(SHORT_TYPE));
+                        break;
+                    case CHAR_OBJ:
+                        if (explicit && internal) return new Cast.Numeric(INT_TYPE, CHAR_TYPE, new Cast.Box(CHAR_TYPE));
                         break;
                     case INT_OBJ:
-                        if (internal)
-                            return new Cast(INT_TYPE, INT_TYPE, explicit, null, null, null, INT_TYPE);
-
+                        if (internal) return new Cast.Box(INT_TYPE);
                         break;
                     case LONG_OBJ:
-                        if (internal)
-                            return new Cast(INT_TYPE, LONG_TYPE, explicit, null, null, null, LONG_TYPE);
-
+                        if (internal) return new Cast.Numeric(INT_TYPE, LONG_TYPE, new Cast.Box(LONG_TYPE));
                         break;
                     case FLOAT_OBJ:
-                        if (internal)
-                            return new Cast(INT_TYPE, FLOAT_TYPE, explicit, null, null, null, FLOAT_TYPE);
-
+                        if (internal) return new Cast.Numeric(INT_TYPE, FLOAT_TYPE, new Cast.Box(FLOAT_TYPE));
                         break;
                     case DOUBLE_OBJ:
-                        if (internal)
-                            return new Cast(INT_TYPE, DOUBLE_TYPE, explicit, null, null, null, DOUBLE_TYPE);
-
-                        break;
-                    case BYTE_OBJ:
-                        if (explicit && internal)
-                            return new Cast(INT_TYPE, BYTE_TYPE, true, null, null, null, BYTE_TYPE);
-
-                        break;
-                    case SHORT_OBJ:
-                        if (explicit && internal)
-                            return new Cast(INT_TYPE, SHORT_TYPE, true, null, null, null, SHORT_TYPE);
-
-                        break;
-                    case CHAR_OBJ:
-                        if (explicit && internal)
-                            return new Cast(INT_TYPE, CHAR_TYPE, true, null, null, null, CHAR_TYPE);
-
+                        if (internal) return new Cast.Numeric(INT_TYPE, DOUBLE_TYPE, new Cast.Box(DOUBLE_TYPE));
                         break;
                 }
-
                 break;
             case LONG:
-                switch (expected.sort) {
-                    case FLOAT:
-                    case DOUBLE:
-                        return new Cast(LONG_TYPE, expected, explicit);
+                    switch (expected.sort) {
                     case BYTE:
                     case SHORT:
                     case CHAR:
                     case INT:
-                        if (explicit)
-                            return new Cast(actual, expected, true);
-
+                        if (explicit) return new Cast.Numeric(LONG_TYPE, expected);
                         break;
+                    case FLOAT:
+                    case DOUBLE:
+                        return new Cast.Numeric(LONG_TYPE, expected);
                     case DEF:
-                        return new Cast(LONG_TYPE, DEF_TYPE, explicit, null, null, LONG_TYPE, null);
+                        return new Cast.Box(LONG_TYPE);
                     case OBJECT:
-                        if (OBJECT_TYPE.equals(expected) && internal)
-                            return new Cast(LONG_TYPE, actual, explicit, null, null, LONG_TYPE, null);
-
+                        if (OBJECT_TYPE.equals(expected) && internal) return new Cast.Box(LONG_TYPE);
                         break;
                     case NUMBER:
-                        if (internal)
-                            return new Cast(LONG_OBJ_TYPE, NUMBER_TYPE, explicit, null, null, LONG_TYPE, null);
-
-                        break;
-                    case LONG_OBJ:
-                        if (internal)
-                            return new Cast(LONG_TYPE, LONG_TYPE, explicit, null, null, null, LONG_TYPE);
-
-                        break;
-                    case FLOAT_OBJ:
-                        if (internal)
-                            return new Cast(LONG_TYPE, FLOAT_TYPE, explicit, null, null, null, FLOAT_TYPE);
-
-                        break;
-                    case DOUBLE_OBJ:
-                        if (internal)
-                            return new Cast(LONG_TYPE, DOUBLE_TYPE, explicit, null, null, null, DOUBLE_TYPE);
-
+                        if (internal) return new Cast.Box(LONG_TYPE);
                         break;
                     case BYTE_OBJ:
-                        if (explicit && internal)
-                            return new Cast(LONG_TYPE, BYTE_TYPE, true, null, null, null, BYTE_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(LONG_TYPE, BYTE_TYPE, new Cast.Box(BYTE_TYPE));
                         break;
                     case SHORT_OBJ:
-                        if (explicit && internal)
-                            return new Cast(LONG_TYPE, SHORT_TYPE, true, null, null, null, SHORT_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(LONG_TYPE, SHORT_TYPE, new Cast.Box(SHORT_TYPE));
                         break;
                     case CHAR_OBJ:
-                        if (explicit && internal)
-                            return new Cast(LONG_TYPE, CHAR_TYPE, true, null, null, null, CHAR_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(LONG_TYPE, CHAR_TYPE, new Cast.Box(CHAR_TYPE));
                         break;
                     case INT_OBJ:
-                        if (explicit && internal)
-                            return new Cast(LONG_TYPE, INT_TYPE, true, null, null, null, INT_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(LONG_TYPE, INT_TYPE, new Cast.Box(INT_TYPE));
+                        break;
+                    case LONG_OBJ:
+                        if (internal) return new Cast.Box(LONG_TYPE);
+                        break;
+                    case FLOAT_OBJ:
+                        if (internal) return new Cast.Numeric(LONG_TYPE, FLOAT_TYPE, new Cast.Box(FLOAT_TYPE));
+                        break;
+                    case DOUBLE_OBJ:
+                        if (internal) return new Cast.Numeric(LONG_TYPE, DOUBLE_TYPE, new Cast.Box(DOUBLE_TYPE));
                         break;
                 }
-
                 break;
             case FLOAT:
                 switch (expected.sort) {
-                    case DOUBLE:
-                        return new Cast(actual, expected, explicit);
                     case BYTE:
                     case SHORT:
                     case CHAR:
                     case INT:
-                    case FLOAT:
-                        if (explicit)
-                            return new Cast(actual, expected, true);
-
+                    case LONG:
+                        if (explicit) return new Cast.Numeric(FLOAT_TYPE, expected);
                         break;
+                    case DOUBLE:
+                        return new Cast.Numeric(FLOAT_TYPE, expected);
                     case DEF:
-                        return new Cast(FLOAT_OBJ_TYPE, DEF_TYPE, explicit, null, null, FLOAT_TYPE, null);
+                        return new Cast.Box(FLOAT_TYPE);
                     case OBJECT:
-                        if (OBJECT_TYPE.equals(expected) && internal)
-                            return new Cast(FLOAT_OBJ_TYPE, OBJECT_TYPE, explicit, null, null, FLOAT_TYPE, null);
-
+                        if (OBJECT_TYPE.equals(expected) && internal) return new Cast.Box(FLOAT_TYPE);
                         break;
                     case NUMBER:
-                        if (internal)
-                            return new Cast(FLOAT_OBJ_TYPE, NUMBER_TYPE, explicit, null, null, FLOAT_TYPE, null);
-
-                        break;
-                    case FLOAT_OBJ:
-                        if (internal)
-                            return new Cast(FLOAT_TYPE, FLOAT_TYPE, explicit, null, null, null, FLOAT_TYPE);
-
-                        break;
-                    case DOUBLE_OBJ:
-                        if (internal)
-                            return new Cast(FLOAT_TYPE, DOUBLE_TYPE, explicit, null, null, null, DOUBLE_TYPE);
-
+                        if (internal) return new Cast.Box(FLOAT_TYPE);
                         break;
                     case BYTE_OBJ:
-                        if (explicit && internal)
-                            return new Cast(FLOAT_TYPE, BYTE_TYPE, true, null, null, null, BYTE_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(FLOAT_TYPE, BYTE_TYPE, new Cast.Box(BYTE_TYPE));
                         break;
                     case SHORT_OBJ:
-                        if (explicit && internal)
-                            return new Cast(FLOAT_TYPE, SHORT_TYPE, true, null, null, null, SHORT_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(FLOAT_TYPE, SHORT_TYPE, new Cast.Box(SHORT_TYPE));
                         break;
                     case CHAR_OBJ:
-                        if (explicit && internal)
-                            return new Cast(FLOAT_TYPE, CHAR_TYPE, true, null, null, null, CHAR_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(FLOAT_TYPE, CHAR_TYPE, new Cast.Box(CHAR_TYPE));
                         break;
                     case INT_OBJ:
-                        if (explicit && internal)
-                            return new Cast(FLOAT_TYPE, INT_TYPE, true, null, null, null, INT_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(FLOAT_TYPE, INT_TYPE, new Cast.Box(INT_TYPE));
                         break;
                     case LONG_OBJ:
-                        if (explicit && internal)
-                            return new Cast(FLOAT_TYPE, LONG_TYPE, true, null, null, null, LONG_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(FLOAT_TYPE, LONG_TYPE, new Cast.Box(LONG_TYPE));
+                        break;
+                    case FLOAT_OBJ:
+                        if (internal) return new Cast.Box(FLOAT_TYPE);
+                        break;
+                    case DOUBLE_OBJ:
+                        if (internal) return new Cast.Numeric(FLOAT_TYPE, DOUBLE_TYPE, new Cast.Box(DOUBLE_TYPE));
                         break;
                 }
 
@@ -462,369 +343,264 @@ public static Cast getLegalCast(Location location, Type actual, Type expected, b
                     case SHORT:
                     case CHAR:
                     case INT:
+                    case LONG:
                     case FLOAT:
-                        if (explicit)
-                            return new Cast(DOUBLE_TYPE, expected, true);
-
+                        if (explicit) return new Cast.Numeric(DOUBLE_TYPE, expected);
                         break;
                     case DEF:
-                        return new Cast(DOUBLE_OBJ_TYPE, DEF_TYPE, explicit, null, null, DOUBLE_TYPE, null);
+                        return new Cast.Box(DOUBLE_TYPE);
                     case OBJECT:
-                        if (OBJECT_TYPE.equals(expected) && internal)
-                            return new Cast(DOUBLE_OBJ_TYPE, OBJECT_TYPE, explicit, null, null, DOUBLE_TYPE, null);
-
+                        if (OBJECT_TYPE.equals(expected) && internal) return new Cast.Box(DOUBLE_TYPE);
                         break;
                     case NUMBER:
-                        if (internal)
-                            return new Cast(DOUBLE_OBJ_TYPE, NUMBER_TYPE, explicit, null, null, DOUBLE_TYPE, null);
-
-                        break;
-                    case DOUBLE_OBJ:
-                        if (internal)
-                            return new Cast(DOUBLE_TYPE, DOUBLE_TYPE, explicit, null, null, null, DOUBLE_TYPE);
-
+                        if (internal) return new Cast.Box(DOUBLE_TYPE);
                         break;
                     case BYTE_OBJ:
-                        if (explicit && internal)
-                            return new Cast(DOUBLE_TYPE, BYTE_TYPE, true, null, null, null, BYTE_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(DOUBLE_TYPE, BYTE_TYPE, new Cast.Box(BYTE_TYPE));
                         break;
                     case SHORT_OBJ:
-                        if (explicit && internal)
-                            return new Cast(DOUBLE_TYPE, SHORT_TYPE, true, null, null, null, SHORT_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(DOUBLE_TYPE, SHORT_TYPE, new Cast.Box(SHORT_TYPE));
                         break;
                     case CHAR_OBJ:
-                        if (explicit && internal)
-                            return new Cast(DOUBLE_TYPE, CHAR_TYPE, true, null, null, null, CHAR_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(DOUBLE_TYPE, CHAR_TYPE, new Cast.Box(CHAR_TYPE));
                         break;
                     case INT_OBJ:
-                        if (explicit && internal)
-                            return new Cast(DOUBLE_TYPE, INT_TYPE, true, null, null, null, INT_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(DOUBLE_TYPE, INT_TYPE, new Cast.Box(INT_TYPE));
                         break;
                     case LONG_OBJ:
-                        if (explicit && internal)
-                            return new Cast(DOUBLE_TYPE, LONG_TYPE, true, null, null, null, LONG_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(DOUBLE_TYPE, LONG_TYPE, new Cast.Box(LONG_TYPE));
                         break;
                     case FLOAT_OBJ:
-                        if (explicit && internal)
-                            return new Cast(DOUBLE_TYPE, FLOAT_TYPE, true, null, null, null, FLOAT_TYPE);
-
+                        if (explicit && internal) return new Cast.Numeric(DOUBLE_TYPE, FLOAT_TYPE, new Cast.Box(FLOAT_TYPE));
+                        break;
+                    case DOUBLE_OBJ:
+                        if (internal) return new Cast.Box(DOUBLE_TYPE);
                         break;
                 }
-
                 break;
             case OBJECT:
                 if (OBJECT_TYPE.equals(actual))
                     switch (expected.sort) {
                         case BYTE:
-                            if (internal && explicit)
-                                return new Cast(OBJECT_TYPE, BYTE_OBJ_TYPE, true, null, BYTE_TYPE, null, null);
-
+                            if (internal && explicit) return new Cast.Unbox(BYTE_TYPE);
                             break;
                         case SHORT:
-                            if (internal && explicit)
-                                return new Cast(OBJECT_TYPE, SHORT_OBJ_TYPE, true, null, SHORT_TYPE, null, null);
-
+                            if (internal && explicit) return new Cast.Unbox(SHORT_TYPE);
                             break;
                         case CHAR:
-                            if (internal && explicit)
-                                return new Cast(OBJECT_TYPE, CHAR_OBJ_TYPE, true, null, CHAR_TYPE, null, null);
-
+                            if (internal && explicit) return new Cast.Unbox(CHAR_TYPE);
                             break;
                         case INT:
-                            if (internal && explicit)
-                                return new Cast(OBJECT_TYPE, INT_OBJ_TYPE, true, null, INT_TYPE, null, null);
-
+                            if (internal && explicit) return new Cast.Unbox(INT_TYPE);
                             break;
                         case LONG:
-                            if (internal && explicit)
-                                return new Cast(OBJECT_TYPE, LONG_OBJ_TYPE, true, null, LONG_TYPE, null, null);
-
+                            if (internal && explicit) return new Cast.Unbox(LONG_TYPE);
                             break;
                         case FLOAT:
-                            if (internal && explicit)
-                                return new Cast(OBJECT_TYPE, FLOAT_OBJ_TYPE, true, null, FLOAT_TYPE, null, null);
-
+                            if (internal && explicit) return new Cast.Unbox(FLOAT_TYPE);
                             break;
                         case DOUBLE:
-                            if (internal && explicit)
-                                return new Cast(OBJECT_TYPE, DOUBLE_OBJ_TYPE, true, null, DOUBLE_TYPE, null, null);
-
+                            if (internal && explicit) return new Cast.Unbox(DOUBLE_TYPE);
                             break;
-                    }
+                }
                 break;
             case NUMBER:
                 switch (expected.sort) {
                     case BYTE:
-                        if (internal && explicit)
-                            return new Cast(NUMBER_TYPE, BYTE_OBJ_TYPE, true, null, BYTE_TYPE, null, null);
-
+                        if (internal && explicit) return new Cast.Unbox(BYTE_TYPE);
                         break;
                     case SHORT:
-                        if (internal && explicit)
-                            return new Cast(NUMBER_TYPE, SHORT_OBJ_TYPE, true, null, SHORT_TYPE, null, null);
-
+                        if (internal && explicit) return new Cast.Unbox(SHORT_TYPE);
                         break;
                     case CHAR:
-                        if (internal && explicit)
-                            return new Cast(NUMBER_TYPE, CHAR_OBJ_TYPE, true, null, CHAR_TYPE, null, null);
-
+                        if (internal && explicit) return new Cast.Unbox(CHAR_TYPE);
                         break;
                     case INT:
-                        if (internal && explicit)
-                            return new Cast(NUMBER_TYPE, INT_OBJ_TYPE, true, null, INT_TYPE, null, null);
-
+                        if (internal && explicit) return new Cast.Unbox(INT_TYPE);
                         break;
                     case LONG:
-                        if (internal && explicit)
-                            return new Cast(NUMBER_TYPE, LONG_OBJ_TYPE, true, null, LONG_TYPE, null, null);
-
+                        if (internal && explicit) return new Cast.Unbox(LONG_TYPE);
                         break;
                     case FLOAT:
-                        if (internal && explicit)
-                            return new Cast(NUMBER_TYPE, FLOAT_OBJ_TYPE, true, null, FLOAT_TYPE, null, null);
-
+                        if (internal && explicit) return new Cast.Unbox(FLOAT_TYPE);
                         break;
                     case DOUBLE:
-                        if (internal && explicit)
-                            return new Cast(NUMBER_TYPE, DOUBLE_OBJ_TYPE, true, null, DOUBLE_TYPE, null, null);
-
+                        if (internal && explicit) return new Cast.Unbox(DOUBLE_TYPE);
                         break;
                 }
-
                 break;
             case BOOL_OBJ:
                 switch (expected.sort) {
                     case BOOL:
-                        if (internal)
-                            return new Cast(BOOLEAN_TYPE, BOOLEAN_TYPE, explicit, BOOLEAN_TYPE, null, null, null);
-
+                        if (internal) return new Cast.Unbox(BOOLEAN_TYPE);
                         break;
                 }
-
                 break;
             case BYTE_OBJ:
                 switch (expected.sort) {
                     case BYTE:
                     case SHORT:
+                        if (internal) return new Cast.Unbox(expected);
+                        break;
+                    case CHAR:
+                        if (internal && explicit) return new Cast.Unbox(BYTE_TYPE, new Cast.Numeric(BYTE_TYPE, CHAR_TYPE));
+                        break;
                     case INT:
                     case LONG:
                     case FLOAT:
                     case DOUBLE:
-                        if (internal)
-                            return new Cast(BYTE_TYPE, expected, explicit, BYTE_TYPE, null, null, null);
-
-                        break;
-                    case CHAR:
-                        if (internal && explicit)
-                            return new Cast(BYTE_TYPE, expected, true, BYTE_TYPE, null, null, null);
-
+                        if (internal) return new Cast.Unbox(expected);
                         break;
                 }
-
                 break;
             case SHORT_OBJ:
                 switch (expected.sort) {
+                    case BYTE:
+                        if (internal && explicit) return new Cast.Unbox(expected);
+                        break;
                     case SHORT:
+                        if (internal) return new Cast.Unbox(expected);
+                        break;
+                    case CHAR:
+                        if (internal && explicit) return new Cast.Unbox(SHORT_TYPE, new Cast.Numeric(SHORT_TYPE, CHAR_TYPE));
+                        break;
                     case INT:
                     case LONG:
                     case FLOAT:
                     case DOUBLE:
-                        if (internal)
-                            return new Cast(SHORT_TYPE, expected, explicit, SHORT_TYPE, null, null, null);
-
-                        break;
-                    case BYTE:
-                    case CHAR:
-                        if (internal && explicit)
-                            return new Cast(SHORT_TYPE, expected, true, SHORT_TYPE, null, null, null);
-
+                        if (internal) return new Cast.Unbox(expected);
                         break;
                 }
-
                 break;
             case CHAR_OBJ:
                 switch (expected.sort) {
+                    case BYTE:
+                    case SHORT:
+                        if (internal && explicit) return new Cast.Unbox(CHAR_TYPE, new Cast.Numeric(CHAR_TYPE, expected));
+                        break;
                     case CHAR:
+                        if (internal) return new Cast.Unbox(CHAR_TYPE);
+                        break;
                     case INT:
                     case LONG:
                     case FLOAT:
                     case DOUBLE:
-                        if (internal)
-                            return new Cast(CHAR_TYPE, expected, explicit, CHAR_TYPE, null, null, null);
-
-                        break;
-                    case BYTE:
-                    case SHORT:
-                        if (internal && explicit)
-                            return new Cast(CHAR_TYPE, expected, true, CHAR_TYPE, null, null, null);
-
+                        if (internal) return new Cast.Unbox(CHAR_TYPE, new Cast.Numeric(CHAR_TYPE, expected));
                         break;
                 }
-
                 break;
             case INT_OBJ:
                 switch (expected.sort) {
+                    case BYTE:
+                    case SHORT:
+                        if (internal && explicit) return new Cast.Unbox(expected);
+                        break;
+                    case CHAR:
+                        if (internal && explicit) return new Cast.Unbox(INT_TYPE, new Cast.Numeric(INT_TYPE, CHAR_TYPE));
+                        break;
                     case INT:
                     case LONG:
                     case FLOAT:
                     case DOUBLE:
-                        if (internal)
-                            return new Cast(INT_TYPE, expected, explicit, INT_TYPE, null, null, null);
-
-                        break;
-                    case BYTE:
-                    case SHORT:
-                    case CHAR:
-                        if (internal && explicit)
-                            return new Cast(INT_TYPE, expected, true, INT_TYPE, null, null, null);
-
+                        if (internal) return new Cast.Unbox(expected);
                         break;
                 }
-
                 break;
             case LONG_OBJ:
                 switch (expected.sort) {
-                    case LONG:
-                    case FLOAT:
-                    case DOUBLE:
-                        if (internal)
-                            return new Cast(LONG_TYPE, expected, explicit, LONG_TYPE, null, null, null);
-
-                        break;
                     case BYTE:
                     case SHORT:
                     case CHAR:
                     case INT:
-                        if (internal && explicit)
-                            return new Cast(LONG_TYPE, expected, true, LONG_TYPE, null, null, null);
-
+                        if (internal && explicit) return new Cast.Unbox(LONG_TYPE, new Cast.Numeric(LONG_TYPE, expected));
+                        break;
+                    case LONG:
+                        if (internal) return new Cast.Unbox(LONG_TYPE);
+                        break;
+                    case FLOAT:
+                    case DOUBLE:
+                        if (internal) return new Cast.Unbox(LONG_TYPE, new Cast.Numeric(LONG_TYPE, expected));
                         break;
                 }
-
                 break;
             case FLOAT_OBJ:
                 switch (expected.sort) {
-                    case FLOAT:
-                    case DOUBLE:
-                        if (internal)
-                            return new Cast(FLOAT_TYPE, expected, explicit, FLOAT_TYPE, null, null, null);
-
-                        break;
                     case BYTE:
                     case SHORT:
                     case CHAR:
                     case INT:
                     case LONG:
-                        if (internal && explicit)
-                            return new Cast(FLOAT_TYPE, expected, true, FLOAT_TYPE, null, null, null);
-
+                        if (internal && explicit) return new Cast.Unbox(FLOAT_TYPE, new Cast.Numeric(FLOAT_TYPE, expected));
+                        break;
+                    case FLOAT:
+                        if (internal) return new Cast.Unbox(FLOAT_TYPE);
+                        break;
+                    case DOUBLE:
+                        if (internal) return new Cast.Unbox(FLOAT_TYPE, new Cast.Numeric(FLOAT_TYPE, DOUBLE_TYPE));
                         break;
                 }
-
                 break;
             case DOUBLE_OBJ:
                 switch (expected.sort) {
-                    case DOUBLE:
-                        if (internal)
-                            return new Cast(DOUBLE_TYPE, expected, explicit, DOUBLE_TYPE, null, null, null);
-
-                        break;
                     case BYTE:
                     case SHORT:
                     case CHAR:
                     case INT:
                     case LONG:
                     case FLOAT:
-                        if (internal && explicit)
-                            return new Cast(DOUBLE_TYPE, expected, true, DOUBLE_TYPE, null, null, null);
-
+                        if (internal && explicit) return new Cast.Unbox(DOUBLE_TYPE, new Cast.Numeric(DOUBLE_TYPE, expected));
+                        break;
+                    case DOUBLE:
+                        if (internal) return new Cast.Unbox(DOUBLE_TYPE);
                         break;
                 }
-
                 break;
             case DEF:
                 switch (expected.sort) {
                     case BOOL:
-                        return new Cast(DEF_TYPE, BOOLEAN_OBJ_TYPE, explicit, null, BOOLEAN_TYPE, null, null);
+                        return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_BOOLEAN, Def::DefToboolean);
                     case BYTE:
-                        return new Cast(DEF_TYPE, BYTE_OBJ_TYPE, explicit, null, BYTE_TYPE, null, null);
+                        if (explicit) return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_BYTE_EXPLICIT, Def::DefTobyteExplicit);
+                        return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_BYTE_IMPLICIT, Def::DefTobyteImplicit);
                     case SHORT:
-                        return new Cast(DEF_TYPE, SHORT_OBJ_TYPE, explicit, null, SHORT_TYPE, null, null);
+                        if (explicit) return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_SHORT_EXPLICIT, Def::DefToshortExplicit);
+                        return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_SHORT_IMPLICIT, Def::DefToshortImplicit);
                     case CHAR:
-                        return new Cast(DEF_TYPE, CHAR_OBJ_TYPE, explicit, null, CHAR_TYPE, null, null);
+                        if (explicit) return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_CHAR_EXPLICIT, Def::DefTocharExplicit);
+                        return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_CHAR_IMPLICIT, Def::DefTocharImplicit);
                     case INT:
-                        return new Cast(DEF_TYPE, INT_OBJ_TYPE, explicit, null, INT_TYPE, null, null);
+                        if (explicit) return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_INT_EXPLICIT, Def::DefTointExplicit);
+                        return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_INT_IMPLICIT, Def::DefTointImplicit);
                     case LONG:
-                        return new Cast(DEF_TYPE, LONG_OBJ_TYPE, explicit, null, LONG_TYPE, null, null);
+                        if (explicit) return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_LONG_EXPLICIT, Def::DefTolongExplicit);
+                        return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_LONG_IMPLICIT, Def::DefTolongImplicit);
                     case FLOAT:
-                        return new Cast(DEF_TYPE, FLOAT_OBJ_TYPE, explicit, null, FLOAT_TYPE, null, null);
+                        if (explicit) return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_FLOAT_EXPLICIT, Def::DefTofloatExplicit);
+                        return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_FLOAT_IMPLICIT, Def::DefTofloatImplicit);
                     case DOUBLE:
-                            return new Cast(DEF_TYPE, DOUBLE_OBJ_TYPE, explicit, null, DOUBLE_TYPE, null, null);
+                        if (explicit) return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_DOUBLE_EXPLICIT, Def::DefTodoubleExplicit);
+                        return new Cast.InvokeStatic(DEF_UTIL_TYPE, DEF_TO_DOUBLE_IMPLICIT, Def::DefTodoubleImplicit);
                 }
-
                 break;
             case STRING:
                 switch (expected.sort) {
                     case CHAR:
-                        if (explicit)
-                            return new Cast(STRING_TYPE, CHAR_TYPE, true);
-
+                        if (explicit) return new Cast.InvokeStatic(UTILITY_TYPE, STRING_TO_CHAR, c -> Utility.StringTochar((String) c));
                         break;
                 }
-
                 break;
         }
 
-        if (       actual.sort == Sort.DEF
-                || (actual.sort != Sort.VOID && expected.sort == Sort.DEF)
-                || expected.clazz.isAssignableFrom(actual.clazz)
-                || (explicit && actual.clazz.isAssignableFrom(expected.clazz))) {
-            return new Cast(actual, expected, explicit);
-        } else {
-            throw location.createError(new ClassCastException("Cannot cast from [" + actual.name + "] to [" + expected.name + "]."));
+        if (expected.clazz.isAssignableFrom(actual.clazz)) {
+            return Cast.NOOP;
         }
-    }
-
-    public static Object constCast(Location location, final Object constant, final Cast cast) {
-        final Sort fsort = cast.from.sort;
-        final Sort tsort = cast.to.sort;
-
-        if (fsort == tsort) {
-            return constant;
-        } else if (fsort == Sort.STRING && tsort == Sort.CHAR) {
-            return Utility.StringTochar((String)constant);
-        } else if (fsort == Sort.CHAR && tsort == Sort.STRING) {
-            return Utility.charToString((char)constant);
-        } else if (fsort.numeric && tsort.numeric) {
-            final Number number;
-
-            if (fsort == Sort.CHAR) {
-                number = (int)(char)constant;
-            } else {
-                number = (Number)constant;
-            }
-
-            switch (tsort) {
-                case BYTE:   return number.byteValue();
-                case SHORT:  return number.shortValue();
-                case CHAR:   return (char)number.intValue();
-                case INT:    return number.intValue();
-                case LONG:   return number.longValue();
-                case FLOAT:  return number.floatValue();
-                case DOUBLE: return number.doubleValue();
-                default:
-                    throw location.createError(new IllegalStateException("Cannot cast from " +
-                        "[" + cast.from.clazz.getCanonicalName() + "] to [" + cast.to.clazz.getCanonicalName() + "]."));
-            }
-        } else {
-            throw location.createError(new IllegalStateException("Cannot cast from " +
-                "[" + cast.from.clazz.getCanonicalName() + "] to [" + cast.to.clazz.getCanonicalName() + "]."));
+        if (explicit && actual.clazz.isAssignableFrom(expected.clazz)) {
+            return new Cast.CheckedCast(expected);
+        }
+        if (actual.sort == Sort.DEF) {
+            return new Cast.CheckedCast(expected);
         }
+        throw location.createError(new ClassCastException("Cannot cast from [" + actual.name + "] to [" + expected.name + "]."));
     }
 
     public static Type promoteNumeric(Type from, boolean decimal) {
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/Cast.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Cast.java
new file mode 100644
index 000000000000..b579ff90a631
--- /dev/null
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Cast.java
@@ -0,0 +1,292 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.painless;
+
+import org.elasticsearch.painless.Definition.Sort;
+import org.elasticsearch.painless.Definition.Type;
+
+import java.util.function.Function;
+
+/**
+ * Casting strategies. Many, but not all, casting strategies support a "next" strategy to allow building compound strategies like "unbox and
+ * then convert from char to int". These are always read from "outside inwards", meaning that a strategy is first executed and then the
+ * "next" strategy is executed.
+ */
+public abstract class Cast {
+    private Cast() {}
+
+    public abstract boolean castRequired();
+    public abstract void write(MethodWriter writer);
+    public abstract Object castConstant(Location location, Object constant);
+    public abstract String toString();
+
+    /**
+     * Cast that doesn't do anything. Used when you don't need to cast at all.
+     */
+    static final Cast NOOP = new Cast() {
+        @Override
+        public void write(MethodWriter writer) {
+        }
+
+        @Override
+        public boolean castRequired() {
+            return false;
+        }
+
+        @Override
+        public Object castConstant(Location location, Object constant) {
+            return constant;
+        }
+
+        @Override
+        public String toString() {
+            return "noop";
+        }
+    };
+
+    /**
+     * Promote or demote a numeric.
+     */
+    public static class Numeric extends Cast {
+        private final Type from;
+        private final Type to;
+        private final Cast next;
+
+        public Numeric(Type from, Type to, Cast next) {
+            if (from.equals(to)) {
+                throw new IllegalArgumentException("From and to must not be equal but were [" + from + "].");
+            }
+            if (to.clazz.isAssignableFrom(from.clazz)) {
+                throw new IllegalArgumentException("Promote isn't needed for to [" + to + "] is assignable to from [" + from + "]");
+            }
+            if (false == from.sort.numeric && from.sort.primitive) {
+                throw new IllegalArgumentException("From [" + from + "] must be primitive and numeric.");
+            }
+            if (false == to.sort.numeric && to.sort.primitive) {
+                throw new IllegalArgumentException("To [" + to + "] must be primitive and numeric.");
+            }
+            if (next == null) {
+                throw new IllegalArgumentException("Next must not be null.");
+            }
+            this.from = from;
+            this.to = to;
+            this.next = next;
+        }
+
+        public Numeric(Type from, Type to) {
+            this(from, to, Cast.NOOP);
+        }
+
+        @Override
+        public boolean castRequired() {
+            return true;
+        }
+
+        @Override
+        public void write(MethodWriter writer) {
+            writer.cast(from.type, to.type);
+            next.write(writer);
+        }
+
+        @Override
+        public Object castConstant(Location location, Object constant) {
+            return next.castConstant(location, internalCastConstant(location, constant));
+        }
+
+        private Object internalCastConstant(Location location, Object constant) {
+            Number number = from.sort == Sort.CHAR ? (int)(char)constant : (Number)constant;
+            switch (to.sort) {
+            case BYTE:   return number.byteValue();
+            case SHORT:  return number.shortValue();
+            case CHAR:   return (char)number.intValue();
+            case INT:    return number.intValue();
+            case LONG:   return number.longValue();
+            case FLOAT:  return number.floatValue();
+            case DOUBLE: return number.doubleValue();
+            default:
+                throw location.createError(new IllegalStateException("Cannot cast from " +
+                    "[" + from.clazz.getCanonicalName() + "] to [" + to.clazz.getCanonicalName() + "]."));
+            }
+        }
+
+        @Override
+        public String toString() {
+            if (next == Cast.NOOP) {
+                return "(Numeric " + from + " " + to + ")";
+            } else {
+                return "(Numeric " + from + " " + to + " " + next + ")";
+            }
+        }
+    }
+
+    /**
+     * Box some boxable type.
+     */
+    public static class Box extends Cast {
+        private final Type from;
+
+        public Box(Type from) {
+            if (from.sort.boxed == null) {
+                throw new IllegalArgumentException("From must be a boxable type but was [" + from + "]");
+            }
+            this.from = from;
+        }
+
+        @Override
+        public boolean castRequired() {
+            return true;
+        }
+
+        @Override
+        public void write(MethodWriter writer) {
+            writer.box(from.type);
+        }
+
+        @Override
+        public Object castConstant(Location location, Object constant) {
+            throw new UnsupportedOperationException("Boxed values can't be written as constants");
+        }
+
+        @Override
+        public String toString() {
+            return "(Box " + from + ")";
+        }
+    }
+
+    /**
+     * Unbox some boxable type.
+     */
+    public static class Unbox extends Cast {
+        private final Type to;
+        private final Cast next;
+
+        public Unbox(Type to, Cast next) {
+            if (to.sort.boxed == null) {
+                throw new IllegalArgumentException("To must be a boxable type but was [" + to + "]");
+            }
+            if (next == null) {
+                throw new IllegalArgumentException("Next must not be null");
+            }
+            this.to = to;
+            this.next = next;
+        }
+
+        public Unbox(Type to) {
+            this(to, Cast.NOOP);
+        }
+
+        @Override
+        public boolean castRequired() {
+            return true;
+        }
+
+        @Override
+        public void write(MethodWriter writer) {
+            writer.unbox(to.type);
+            next.write(writer);
+        }
+
+        @Override
+        public Object castConstant(Location location, Object constant) {
+            // Constants are always boxed inside the compiler. We unbox them when writing instead.
+            return next.castConstant(location, constant);
+        }
+
+        @Override
+        public String toString() {
+            if (next == Cast.NOOP) {
+                return "(Unbox " + to + ")";
+            } else {
+                return "(Unbox " + to + " " + next + ")";
+            }
+        }
+    }
+
+    /**
+     * Performs a checked cast to narrow from a wider type to a more specific one. For example
+     * {@code Number n = Integer.valueOf(5); Integer i = (Integer) n}.
+     */
+    public static class CheckedCast extends Cast {
+        private final Type to;
+
+        public CheckedCast(Type to) {
+            this.to = to;
+        }
+
+        @Override
+        public boolean castRequired() {
+            return true;
+        }
+
+        @Override
+        public void write(MethodWriter writer) {
+            writer.checkCast(to.type);
+        }
+
+        @Override
+        public Object castConstant(Location location, Object constant) {
+            return to.clazz.cast(constant);
+        }
+
+        @Override
+        public String toString() {
+            return "(CheckedCast " + to + ")";
+        }
+    }
+
+    /**
+     * Invoke a static method to do the cast. Used for {@code char c = 'c'}
+     */
+    public static class InvokeStatic extends Cast {
+        private final org.objectweb.asm.Type owner;
+        private final org.objectweb.asm.commons.Method method;
+        private final Function<Object, Object> castConstant;
+
+        public InvokeStatic(org.objectweb.asm.Type owner, org.objectweb.asm.commons.Method method, Function<Object, Object> castConstant) {
+            this.owner = owner;
+            this.method = method;
+            this.castConstant = castConstant;
+        }
+
+        @Override
+        public boolean castRequired() {
+            return true;
+        }
+
+        @Override
+        public void write(MethodWriter writer) {
+            writer.invokeStatic(owner, method);
+        }
+
+        @Override
+        public Object castConstant(Location location, Object constant) {
+            try {
+                return castConstant.apply(constant);
+            } catch (Throwable e) {
+                throw location.createError(new IllegalArgumentException("Failed to cast constant: " + e.getMessage(), e));
+            }
+        }
+
+        @Override
+        public String toString() {
+            return "(InvokeStatic " + owner.getClassName() + "#" + method.getName() + ")";
+        }
+    }
+}
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java
index 16f0339677e3..90cd88612674 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java
@@ -431,38 +431,6 @@ public Method getFunctionalMethod() {
         }
     }
 
-    public static class Cast {
-        public final Type from;
-        public final Type to;
-        public final boolean explicit;
-        public final Type unboxFrom;
-        public final Type unboxTo;
-        public final Type boxFrom;
-        public final Type boxTo;
-
-        public Cast(final Type from, final Type to, final boolean explicit) {
-            this.from = from;
-            this.to = to;
-            this.explicit = explicit;
-            this.unboxFrom = null;
-            this.unboxTo = null;
-            this.boxFrom = null;
-            this.boxTo = null;
-        }
-
-        public Cast(final Type from, final Type to, final boolean explicit,
-                    final Type unboxFrom, final Type unboxTo, final Type boxFrom, final Type boxTo) {
-            this.from = from;
-            this.to = to;
-            this.explicit = explicit;
-            this.unboxFrom = unboxFrom;
-            this.unboxTo = unboxTo;
-            this.boxFrom = boxFrom;
-            this.boxTo = boxTo;
-        }
-
-    }
-
     public static final class RuntimeClass {
         private final Struct struct;
         public final Map<MethodKey, Method> methods;
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/MethodWriter.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/MethodWriter.java
index ac902ee134e1..b336ec98ef20 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/MethodWriter.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/MethodWriter.java
@@ -19,7 +19,6 @@
 
 package org.elasticsearch.painless;
 
-import org.elasticsearch.painless.Definition.Cast;
 import org.elasticsearch.painless.Definition.Sort;
 import org.elasticsearch.painless.Definition.Type;
 import org.objectweb.asm.ClassVisitor;
@@ -34,24 +33,7 @@
 import java.util.Deque;
 import java.util.List;
 
-import static org.elasticsearch.painless.WriterConstants.CHAR_TO_STRING;
 import static org.elasticsearch.painless.WriterConstants.DEF_BOOTSTRAP_HANDLE;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_BOOLEAN;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_BYTE_EXPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_BYTE_IMPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_CHAR_EXPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_CHAR_IMPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_DOUBLE_EXPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_DOUBLE_IMPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_FLOAT_EXPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_FLOAT_IMPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_INT_EXPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_INT_IMPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_LONG_EXPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_LONG_IMPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_SHORT_EXPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_TO_SHORT_IMPLICIT;
-import static org.elasticsearch.painless.WriterConstants.DEF_UTIL_TYPE;
 import static org.elasticsearch.painless.WriterConstants.INDY_STRING_CONCAT_BOOTSTRAP_HANDLE;
 import static org.elasticsearch.painless.WriterConstants.MAX_INDY_STRING_CONCAT_ARGS;
 import static org.elasticsearch.painless.WriterConstants.PAINLESS_ERROR_TYPE;
@@ -66,9 +48,7 @@
 import static org.elasticsearch.painless.WriterConstants.STRINGBUILDER_CONSTRUCTOR;
 import static org.elasticsearch.painless.WriterConstants.STRINGBUILDER_TOSTRING;
 import static org.elasticsearch.painless.WriterConstants.STRINGBUILDER_TYPE;
-import static org.elasticsearch.painless.WriterConstants.STRING_TO_CHAR;
 import static org.elasticsearch.painless.WriterConstants.STRING_TYPE;
-import static org.elasticsearch.painless.WriterConstants.UTILITY_TYPE;
 
 /**
  * Extension of {@link GeneratorAdapter} with some utility methods.
@@ -129,68 +109,6 @@ public void writeLoopCounter(int slot, int count, Location location) {
         mark(end);
     }
 
-    public void writeCast(final Cast cast) {
-        if (cast != null) {
-            if (cast.from.sort == Sort.CHAR && cast.to.sort == Sort.STRING) {
-                invokeStatic(UTILITY_TYPE, CHAR_TO_STRING);
-            } else if (cast.from.sort == Sort.STRING && cast.to.sort == Sort.CHAR) {
-                invokeStatic(UTILITY_TYPE, STRING_TO_CHAR);
-            } else if (cast.unboxFrom != null) {
-                unbox(cast.unboxFrom.type);
-                writeCast(cast.from, cast.to);
-            } else if (cast.unboxTo != null) {
-                if (cast.from.sort == Sort.DEF) {
-                    if (cast.explicit) {
-                        if (cast.to.sort == Sort.BOOL_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_BOOLEAN);
-                        else if (cast.to.sort == Sort.BYTE_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_BYTE_EXPLICIT);
-                        else if (cast.to.sort == Sort.SHORT_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_SHORT_EXPLICIT);
-                        else if (cast.to.sort == Sort.CHAR_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_CHAR_EXPLICIT);
-                        else if (cast.to.sort == Sort.INT_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_INT_EXPLICIT);
-                        else if (cast.to.sort == Sort.LONG_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_LONG_EXPLICIT);
-                        else if (cast.to.sort == Sort.FLOAT_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_FLOAT_EXPLICIT);
-                        else if (cast.to.sort == Sort.DOUBLE_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_DOUBLE_EXPLICIT);
-                        else throw new IllegalStateException("Illegal tree structure.");
-                    } else {
-                        if (cast.to.sort == Sort.BOOL_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_BOOLEAN);
-                        else if (cast.to.sort == Sort.BYTE_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_BYTE_IMPLICIT);
-                        else if (cast.to.sort == Sort.SHORT_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_SHORT_IMPLICIT);
-                        else if (cast.to.sort == Sort.CHAR_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_CHAR_IMPLICIT);
-                        else if (cast.to.sort == Sort.INT_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_INT_IMPLICIT);
-                        else if (cast.to.sort == Sort.LONG_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_LONG_IMPLICIT);
-                        else if (cast.to.sort == Sort.FLOAT_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_FLOAT_IMPLICIT);
-                        else if (cast.to.sort == Sort.DOUBLE_OBJ) invokeStatic(DEF_UTIL_TYPE, DEF_TO_DOUBLE_IMPLICIT);
-                        else throw new IllegalStateException("Illegal tree structure.");
-                    }
-                } else {
-                    writeCast(cast.from, cast.to);
-                    unbox(cast.unboxTo.type);
-                }
-            } else if (cast.boxFrom != null) {
-                box(cast.boxFrom.type);
-                writeCast(cast.from, cast.to);
-            } else if (cast.boxTo != null) {
-                writeCast(cast.from, cast.to);
-                box(cast.boxTo.type);
-            } else {
-                writeCast(cast.from, cast.to);
-            }
-        }
-    }
-
-    private void writeCast(final Type from, final Type to) {
-        if (from.equals(to)) {
-            return;
-        }
-
-        if (from.sort.numeric && from.sort.primitive && to.sort.numeric && to.sort.primitive) {
-            cast(from.type, to.type);
-        } else {
-            if (!to.clazz.isAssignableFrom(from.clazz)) {
-                checkCast(to.type);
-            }
-        }
-    }
-
     /**
      * Proxy the box method to use valueOf instead to ensure that the modern boxing methods are used.
      */
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java
index 739e3de6d213..a21fa7eab704 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java
@@ -20,10 +20,10 @@
 package org.elasticsearch.painless.node;
 
 import org.elasticsearch.painless.AnalyzerCaster;
-import org.elasticsearch.painless.Definition.Cast;
 import org.elasticsearch.painless.Definition.Type;
 import org.elasticsearch.painless.Locals;
 import org.elasticsearch.painless.Location;
+import org.elasticsearch.painless.Cast;
 
 import java.util.Objects;
 
@@ -120,7 +120,7 @@
     AExpression cast(Locals locals) {
         Cast cast = AnalyzerCaster.getLegalCast(location, actual, expected, explicit, internal);
 
-        if (cast == null) {
+        if (false == cast.castRequired()) {
             if (constant == null || this instanceof EConstant) {
                 // For the case where a cast is not required and a constant is not set
                 // or the node is already an EConstant no changes are required to the tree.
@@ -137,7 +137,10 @@ AExpression cast(Locals locals) {
                 EConstant econstant = new EConstant(location, constant);
                 econstant.analyze(locals);
 
-                if (!expected.equals(econstant.actual)) {
+                /* If we can't assign the constant to this node then we've failed to cast. The
+                 * types don't have to be exactly equal because a cast isn't required when a
+                 * narrower type is assigned to a wider type. */
+                if (!expected.clazz.isAssignableFrom(econstant.actual.clazz)) {
                     throw createError(new IllegalStateException("Illegal tree structure."));
                 }
 
@@ -166,7 +169,7 @@ AExpression cast(Locals locals) {
                     // from this node because the output data for the EConstant
                     // will already be the same.
 
-                    constant = AnalyzerCaster.constCast(location, constant, cast);
+                    constant = cast.castConstant(location, constant);
 
                     EConstant econstant = new EConstant(location, constant);
                     econstant.analyze(locals);
@@ -193,7 +196,7 @@ AExpression cast(Locals locals) {
                     // For the case where a cast is required, a constant is set,
                     // the constant cannot be immediately cast to the expected type,
                     // and this node is not an EConstant.  Replace this node with
-                    // an Econstant node copying the constant from this node.
+                    // an EConstant node copying the constant from this node.
                     // Modify the tree to add an ECast between the EConstant node
                     // and its parent.  Note that for constants output data does not
                     // need to be copied from this node because the output data for
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EAssignment.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EAssignment.java
index de2e9fc0535b..ffa85d1403ba 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EAssignment.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EAssignment.java
@@ -22,13 +22,13 @@
 import org.elasticsearch.painless.AnalyzerCaster;
 import org.elasticsearch.painless.DefBootstrap;
 import org.elasticsearch.painless.Definition;
-import org.elasticsearch.painless.Definition.Cast;
 import org.elasticsearch.painless.Definition.Sort;
 import org.elasticsearch.painless.Definition.Type;
 import org.elasticsearch.painless.Globals;
 import org.elasticsearch.painless.Locals;
 import org.elasticsearch.painless.Location;
 import org.elasticsearch.painless.MethodWriter;
+import org.elasticsearch.painless.Cast;
 import org.elasticsearch.painless.Operation;
 
 import java.util.ArrayList;
@@ -269,7 +269,7 @@ void write(MethodWriter writer, Globals globals) {
             }
 
             writer.writeToStrings(); // put the value for string concat onto the stack
-            writer.writeCast(back);  // if necessary, cast the String to the lhs actual type
+            back.write(writer);      // if necessary, cast the String to the lhs actual type
 
             if (lhs.read) {
                 writer.writeDup(lhs.actual.sort.size, lhs.accessElementCount()); // if this lhs is also read
@@ -290,11 +290,11 @@ void write(MethodWriter writer, Globals globals) {
                                                                                  // read from and is a post increment
             }
 
-            writer.writeCast(there);    // if necessary cast the current lhs's value
+            there.write(writer);        // if necessary cast the current lhs's value
                                         // to the promotion type between the lhs and rhs types
             rhs.write(writer, globals); // write the bytecode for the rhs
 
-        // XXX: fix these types, but first we need def compound assignment tests.
+        // TODO: fix these types, but first we need def compound assignment tests.
         // its tricky here as there are possibly explicit casts, too.
         // write the operation instruction for compound assignment
             if (promote.sort == Sort.DEF) {
@@ -304,7 +304,7 @@ void write(MethodWriter writer, Globals globals) {
                 writer.writeBinaryInstruction(location, promote, operation);
             }
 
-            writer.writeCast(back); // if necessary cast the promotion type value back to the lhs's type
+            back.write(writer);         // if necessary cast the promotion type value back to the lhs's type
 
             if (lhs.read && !post) {
                 writer.writeDup(lhs.actual.sort.size, lhs.accessElementCount()); // dup the value if the lhs is also
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECast.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECast.java
index 5c2a14987613..87c708b69866 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECast.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECast.java
@@ -19,15 +19,14 @@
 
 package org.elasticsearch.painless.node;
 
-import org.elasticsearch.painless.Definition.Cast;
-
-import java.util.Objects;
-import java.util.Set;
-
-import org.elasticsearch.painless.Location;
 import org.elasticsearch.painless.Globals;
 import org.elasticsearch.painless.Locals;
+import org.elasticsearch.painless.Location;
 import org.elasticsearch.painless.MethodWriter;
+import org.elasticsearch.painless.Cast;
+
+import java.util.Objects;
+import java.util.Set;
 
 /**
  * Represents a cast that is inserted into the tree replacing other casts.  (Internal only.)
@@ -58,11 +57,11 @@ void analyze(Locals locals) {
     void write(MethodWriter writer, Globals globals) {
         child.write(writer, globals);
         writer.writeDebugInfo(location);
-        writer.writeCast(cast);
+        cast.write(writer);
     }
 
     @Override
     public String toString() {
-        return singleLineToString(cast.to, child);
+        return singleLineToString(cast.toString(), child);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSubEachArray.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSubEachArray.java
index c153eacbf927..440ef25a5dfe 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSubEachArray.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSubEachArray.java
@@ -21,13 +21,13 @@
 
 import org.elasticsearch.painless.AnalyzerCaster;
 import org.elasticsearch.painless.Definition;
-import org.elasticsearch.painless.Definition.Cast;
 import org.elasticsearch.painless.Definition.Type;
 import org.elasticsearch.painless.Globals;
 import org.elasticsearch.painless.Locals;
 import org.elasticsearch.painless.Locals.Variable;
 import org.elasticsearch.painless.Location;
 import org.elasticsearch.painless.MethodWriter;
+import org.elasticsearch.painless.Cast;
 import org.objectweb.asm.Label;
 import org.objectweb.asm.Opcodes;
 
@@ -93,7 +93,7 @@ void write(MethodWriter writer, Globals globals) {
         writer.visitVarInsn(array.type.type.getOpcode(Opcodes.ILOAD), array.getSlot());
         writer.visitVarInsn(index.type.type.getOpcode(Opcodes.ILOAD), index.getSlot());
         writer.arrayLoad(indexed.type);
-        writer.writeCast(cast);
+        cast.write(writer);
         writer.visitVarInsn(variable.type.type.getOpcode(Opcodes.ISTORE), variable.getSlot());
 
         if (loopCounter != null) {
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSubEachIterable.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSubEachIterable.java
index 845cc264530e..f80a9e31865c 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSubEachIterable.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSubEachIterable.java
@@ -22,7 +22,6 @@
 import org.elasticsearch.painless.AnalyzerCaster;
 import org.elasticsearch.painless.DefBootstrap;
 import org.elasticsearch.painless.Definition;
-import org.elasticsearch.painless.Definition.Cast;
 import org.elasticsearch.painless.Definition.Method;
 import org.elasticsearch.painless.Definition.MethodKey;
 import org.elasticsearch.painless.Definition.Sort;
@@ -32,6 +31,7 @@
 import org.elasticsearch.painless.Locals.Variable;
 import org.elasticsearch.painless.Location;
 import org.elasticsearch.painless.MethodWriter;
+import org.elasticsearch.painless.Cast;
 import org.objectweb.asm.Label;
 import org.objectweb.asm.Opcodes;
 
@@ -115,7 +115,7 @@ void write(MethodWriter writer, Globals globals) {
 
         writer.visitVarInsn(iterator.type.type.getOpcode(Opcodes.ILOAD), iterator.getSlot());
         writer.invokeInterface(ITERATOR_TYPE, ITERATOR_NEXT);
-        writer.writeCast(cast);
+        cast.write(writer);
         writer.visitVarInsn(variable.type.type.getOpcode(Opcodes.ISTORE), variable.getSlot());
 
         if (loopCounter != null) {
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/BasicStatementTests.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/BasicStatementTests.java
index fc2fffb6441a..59376a7e583b 100644
--- a/modules/lang-painless/src/test/java/org/elasticsearch/painless/BasicStatementTests.java
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/BasicStatementTests.java
@@ -129,70 +129,6 @@ public void testForStatement() {
         }
     }
 
-    public void testIterableForEachStatement() {
-        assertEquals(6, exec("List l = new ArrayList(); l.add(1); l.add(2); l.add(3); int total = 0;" +
-            " for (int x : l) total += x; return total"));
-        assertEquals(6, exec("List l = new ArrayList(); l.add(1); l.add(2); l.add(3); int total = 0;" +
-            " for (x in l) total += x; return total"));
-        assertEquals("123", exec("List l = new ArrayList(); l.add('1'); l.add('2'); l.add('3'); String cat = '';" +
-            " for (String x : l) cat += x; return cat"));
-        assertEquals("123", exec("List l = new ArrayList(); l.add('1'); l.add('2'); l.add('3'); String cat = '';" +
-            " for (x in l) cat += x; return cat"));
-        assertEquals("1236", exec("Map m = new HashMap(); m.put('1', 1); m.put('2', 2); m.put('3', 3);" +
-            " String cat = ''; int total = 0;" +
-            " for (Map.Entry e : m.entrySet()) { cat += e.getKey(); total += e.getValue(); } return cat + total"));
-        assertEquals("1236", exec("Map m = new HashMap(); m.put('1', 1); m.put('2', 2); m.put('3', 3);" +
-                " String cat = ''; int total = 0;" +
-                " for (e in m.entrySet()) { cat += e.getKey(); total += e.getValue(); } return cat + total"));
-    }
-
-    public void testIterableForEachStatementDef() {
-        assertEquals(6, exec("def l = new ArrayList(); l.add(1); l.add(2); l.add(3); int total = 0;" +
-            " for (int x : l) total += x; return total"));
-        assertEquals(6, exec("def l = new ArrayList(); l.add(1); l.add(2); l.add(3); int total = 0;" +
-            " for (x in l) total += x; return total"));
-        assertEquals("123", exec("def l = new ArrayList(); l.add('1'); l.add('2'); l.add('3'); String cat = '';" +
-            " for (String x : l) cat += x; return cat"));
-        assertEquals("123", exec("def l = new ArrayList(); l.add('1'); l.add('2'); l.add('3'); String cat = '';" +
-            " for (x in l) cat += x; return cat"));
-        assertEquals("1236", exec("def m = new HashMap(); m.put('1', 1); m.put('2', 2); m.put('3', 3);" +
-            " String cat = ''; int total = 0;" +
-            " for (Map.Entry e : m.entrySet()) { cat += e.getKey(); total += e.getValue(); } return cat + total"));
-        assertEquals("1236", exec("def m = new HashMap(); m.put('1', 1); m.put('2', 2); m.put('3', 3);" +
-            " String cat = ''; int total = 0;" +
-            " for (e in m.entrySet()) { cat += e.getKey(); total += e.getValue(); } return cat + total"));
-    }
-
-    public void testArrayForEachStatement() {
-        assertEquals(6, exec("int[] a = new int[3]; a[0] = 1; a[1] = 2; a[2] = 3; int total = 0;" +
-            " for (int x : a) total += x; return total"));
-        assertEquals(6, exec("int[] a = new int[3]; a[0] = 1; a[1] = 2; a[2] = 3; int total = 0;" +
-            " for (x in a) total += x; return total"));
-        assertEquals("123", exec("String[] a = new String[3]; a[0] = '1'; a[1] = '2'; a[2] = '3'; def total = '';" +
-            " for (String x : a) total += x; return total"));
-        assertEquals("123", exec("String[] a = new String[3]; a[0] = '1'; a[1] = '2'; a[2] = '3'; def total = '';" +
-            " for (x in a) total += x; return total"));
-        assertEquals(6, exec("int[][] i = new int[3][1]; i[0][0] = 1; i[1][0] = 2; i[2][0] = 3; int total = 0;" +
-            " for (int[] j : i) total += j[0]; return total"));
-        assertEquals(6, exec("int[][] i = new int[3][1]; i[0][0] = 1; i[1][0] = 2; i[2][0] = 3; int total = 0;" +
-            " for (j in i) total += j[0]; return total"));
-    }
-
-    public void testArrayForEachStatementDef() {
-        assertEquals(6, exec("def a = new int[3]; a[0] = 1; a[1] = 2; a[2] = 3; int total = 0;" +
-            " for (int x : a) total += x; return total"));
-        assertEquals(6, exec("def a = new int[3]; a[0] = 1; a[1] = 2; a[2] = 3; int total = 0;" +
-            " for (x in a) total += x; return total"));
-        assertEquals("123", exec("def a = new String[3]; a[0] = '1'; a[1] = '2'; a[2] = '3'; def total = '';" +
-            " for (String x : a) total += x; return total"));
-        assertEquals("123", exec("def a = new String[3]; a[0] = '1'; a[1] = '2'; a[2] = '3'; def total = '';" +
-            " for (x in a) total += x; return total"));
-        assertEquals(6, exec("def i = new int[3][1]; i[0][0] = 1; i[1][0] = 2; i[2][0] = 3; int total = 0;" +
-            " for (int[] j : i) total += j[0]; return total"));
-        assertEquals(6, exec("def i = new int[3][1]; i[0][0] = 1; i[1][0] = 2; i[2][0] = 3; int total = 0;" +
-            " for (j in i) total += j[0]; return total"));
-    }
-
     public void testDeclarationStatement() {
         assertEquals((byte)2, exec("byte a = 2; return a;"));
         assertEquals((short)2, exec("short a = 2; return a;"));
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/CastTests.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/CastTests.java
index 0ca72f993e52..3b9a5801a8b2 100644
--- a/modules/lang-painless/src/test/java/org/elasticsearch/painless/CastTests.java
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/CastTests.java
@@ -19,98 +19,19 @@
 
 package org.elasticsearch.painless;
 
-/** Tests for explicit casts */
+/**
+ * Tests casts not interacting with operators.
+ */
 public class CastTests extends ScriptTestCase {
-
-    /**
-     * Unary operator with explicit cast
-     */
-    public void testUnaryOperator() {
-        assertEquals((byte)5, exec("long x = 5L; return (byte) (+x);"));
-        assertEquals((short)5, exec("long x = 5L; return (short) (+x);"));
-        assertEquals((char)5, exec("long x = 5L; return (char) (+x);"));
-        assertEquals(5, exec("long x = 5L; return (int) (+x);"));
-        assertEquals(5F, exec("long x = 5L; return (float) (+x);"));
-        assertEquals(5L, exec("long x = 5L; return (long) (+x);"));
-        assertEquals(5D, exec("long x = 5L; return (double) (+x);"));
-    }
-
-    /**
-     * Binary operators with explicit cast
-     */
-    public void testBinaryOperator() {
-        assertEquals((byte)6, exec("long x = 5L; return (byte) (x + 1);"));
-        assertEquals((short)6, exec("long x = 5L; return (short) (x + 1);"));
-        assertEquals((char)6, exec("long x = 5L; return (char) (x + 1);"));
-        assertEquals(6, exec("long x = 5L; return (int) (x + 1);"));
-        assertEquals(6F, exec("long x = 5L; return (float) (x + 1);"));
-        assertEquals(6L, exec("long x = 5L; return (long) (x + 1);"));
-        assertEquals(6D, exec("long x = 5L; return (double) (x + 1);"));
-    }
-
-    /**
-     * Binary compound assignment with explicit cast
-     */
-    public void testBinaryCompoundAssignment() {
-        assertEquals((byte)6, exec("long x = 5L; return (byte) (x += 1);"));
-        assertEquals((short)6, exec("long x = 5L; return (short) (x += 1);"));
-        assertEquals((char)6, exec("long x = 5L; return (char) (x += 1);"));
-        assertEquals(6, exec("long x = 5L; return (int) (x += 1);"));
-        assertEquals(6F, exec("long x = 5L; return (float) (x += 1);"));
-        assertEquals(6L, exec("long x = 5L; return (long) (x += 1);"));
-        assertEquals(6D, exec("long x = 5L; return (double) (x += 1);"));
-    }
-
-    /**
-     * Binary compound prefix with explicit cast
-     */
-    public void testBinaryPrefix() {
-        assertEquals((byte)6, exec("long x = 5L; return (byte) (++x);"));
-        assertEquals((short)6, exec("long x = 5L; return (short) (++x);"));
-        assertEquals((char)6, exec("long x = 5L; return (char) (++x);"));
-        assertEquals(6, exec("long x = 5L; return (int) (++x);"));
-        assertEquals(6F, exec("long x = 5L; return (float) (++x);"));
-        assertEquals(6L, exec("long x = 5L; return (long) (++x);"));
-        assertEquals(6D, exec("long x = 5L; return (double) (++x);"));
-    }
-
-    /**
-     * Binary compound postifx with explicit cast
-     */
-    public void testBinaryPostfix() {
-        assertEquals((byte)5, exec("long x = 5L; return (byte) (x++);"));
-        assertEquals((short)5, exec("long x = 5L; return (short) (x++);"));
-        assertEquals((char)5, exec("long x = 5L; return (char) (x++);"));
-        assertEquals(5, exec("long x = 5L; return (int) (x++);"));
-        assertEquals(5F, exec("long x = 5L; return (float) (x++);"));
-        assertEquals(5L, exec("long x = 5L; return (long) (x++);"));
-        assertEquals(5D, exec("long x = 5L; return (double) (x++);"));
-    }
-
     /**
-     * Shift operators with explicit cast
+     * Currently these do not adopt the return value, we issue a separate cast!
      */
-    public void testShiftOperator() {
-        assertEquals((byte)10, exec("long x = 5L; return (byte) (x << 1);"));
-        assertEquals((short)10, exec("long x = 5L; return (short) (x << 1);"));
-        assertEquals((char)10, exec("long x = 5L; return (char) (x << 1);"));
-        assertEquals(10, exec("long x = 5L; return (int) (x << 1);"));
-        assertEquals(10F, exec("long x = 5L; return (float) (x << 1);"));
-        assertEquals(10L, exec("long x = 5L; return (long) (x << 1);"));
-        assertEquals(10D, exec("long x = 5L; return (double) (x << 1);"));
+    public void testMethodCallDef() {
+        assertEquals(5, exec("def x = 5; return (int)x.longValue();"));
     }
 
-    /**
-     * Shift compound assignment with explicit cast
-     */
-    public void testShiftCompoundAssignment() {
-        assertEquals((byte)10, exec("long x = 5L; return (byte) (x <<= 1);"));
-        assertEquals((short)10, exec("long x = 5L; return (short) (x <<= 1);"));
-        assertEquals((char)10, exec("long x = 5L; return (char) (x <<= 1);"));
-        assertEquals(10, exec("long x = 5L; return (int) (x <<= 1);"));
-        assertEquals(10F, exec("long x = 5L; return (float) (x <<= 1);"));
-        assertEquals(10L, exec("long x = 5L; return (long) (x <<= 1);"));
-        assertEquals(10D, exec("long x = 5L; return (double) (x <<= 1);"));
+    public void testUnboxMethodParameters() {
+        assertEquals('a', exec("'a'.charAt(Integer.valueOf(0))"));
     }
 
     /**
@@ -155,113 +76,6 @@ public void testIllegalExplicitConversions() {
         });
     }
 
-    /**
-     * Currently these do not adopt the return value, we issue a separate cast!
-     */
-    public void testMethodCallDef() {
-        assertEquals(5, exec("def x = 5; return (int)x.longValue();"));
-    }
-
-    /**
-     * Currently these do not adopt the argument value, we issue a separate cast!
-     */
-    public void testArgumentsDef() {
-        assertEquals(5, exec("def x = 5L; return (+(int)x);"));
-        assertEquals(6, exec("def x = 5; def y = 1L; return x + (int)y"));
-        assertEquals('b', exec("def x = 'abcdeg'; def y = 1L; x.charAt((int)y)"));
-    }
-
-    /**
-     * Unary operators adopt the return value
-     */
-    public void testUnaryOperatorDef() {
-        assertEquals((byte)5, exec("def x = 5L; return (byte) (+x);"));
-        assertEquals((short)5, exec("def x = 5L; return (short) (+x);"));
-        assertEquals((char)5, exec("def x = 5L; return (char) (+x);"));
-        assertEquals(5, exec("def x = 5L; return (int) (+x);"));
-        assertEquals(5F, exec("def x = 5L; return (float) (+x);"));
-        assertEquals(5L, exec("def x = 5L; return (long) (+x);"));
-        assertEquals(5D, exec("def x = 5L; return (double) (+x);"));
-    }
-
-    /**
-     * Binary operators adopt the return value
-     */
-    public void testBinaryOperatorDef() {
-        assertEquals((byte)6, exec("def x = 5L; return (byte) (x + 1);"));
-        assertEquals((short)6, exec("def x = 5L; return (short) (x + 1);"));
-        assertEquals((char)6, exec("def x = 5L; return (char) (x + 1);"));
-        assertEquals(6, exec("def x = 5L; return (int) (x + 1);"));
-        assertEquals(6F, exec("def x = 5L; return (float) (x + 1);"));
-        assertEquals(6L, exec("def x = 5L; return (long) (x + 1);"));
-        assertEquals(6D, exec("def x = 5L; return (double) (x + 1);"));
-    }
-
-    /**
-     * Binary operators don't yet adopt the return value with compound assignment
-     */
-    public void testBinaryCompoundAssignmentDef() {
-        assertEquals((byte)6, exec("def x = 5L; return (byte) (x += 1);"));
-        assertEquals((short)6, exec("def x = 5L; return (short) (x += 1);"));
-        assertEquals((char)6, exec("def x = 5L; return (char) (x += 1);"));
-        assertEquals(6, exec("def x = 5L; return (int) (x += 1);"));
-        assertEquals(6F, exec("def x = 5L; return (float) (x += 1);"));
-        assertEquals(6L, exec("def x = 5L; return (long) (x += 1);"));
-        assertEquals(6D, exec("def x = 5L; return (double) (x += 1);"));
-    }
-
-    /**
-     * Binary operators don't yet adopt the return value with compound assignment
-     */
-    public void testBinaryCompoundAssignmentPrefix() {
-        assertEquals((byte)6, exec("def x = 5L; return (byte) (++x);"));
-        assertEquals((short)6, exec("def x = 5L; return (short) (++x);"));
-        assertEquals((char)6, exec("def x = 5L; return (char) (++x);"));
-        assertEquals(6, exec("def x = 5L; return (int) (++x);"));
-        assertEquals(6F, exec("def x = 5L; return (float) (++x);"));
-        assertEquals(6L, exec("def x = 5L; return (long) (++x);"));
-        assertEquals(6D, exec("def x = 5L; return (double) (++x);"));
-    }
-
-    /**
-     * Binary operators don't yet adopt the return value with compound assignment
-     */
-    public void testBinaryCompoundAssignmentPostfix() {
-        assertEquals((byte)5, exec("def x = 5L; return (byte) (x++);"));
-        assertEquals((short)5, exec("def x = 5L; return (short) (x++);"));
-        assertEquals((char)5, exec("def x = 5L; return (char) (x++);"));
-        assertEquals(5, exec("def x = 5L; return (int) (x++);"));
-        assertEquals(5F, exec("def x = 5L; return (float) (x++);"));
-        assertEquals(5L, exec("def x = 5L; return (long) (x++);"));
-        assertEquals(5D, exec("def x = 5L; return (double) (x++);"));
-    }
-
-    /**
-     * Shift operators adopt the return value
-     */
-    public void testShiftOperatorDef() {
-        assertEquals((byte)10, exec("def x = 5L; return (byte) (x << 1);"));
-        assertEquals((short)10, exec("def x = 5L; return (short) (x << 1);"));
-        assertEquals((char)10, exec("def x = 5L; return (char) (x << 1);"));
-        assertEquals(10, exec("def x = 5L; return (int) (x << 1);"));
-        assertEquals(10F, exec("def x = 5L; return (float) (x << 1);"));
-        assertEquals(10L, exec("def x = 5L; return (long) (x << 1);"));
-        assertEquals(10D, exec("def x = 5L; return (double) (x << 1);"));
-    }
-
-    /**
-     * Shift operators don't yet adopt the return value with compound assignment
-     */
-    public void testShiftCompoundAssignmentDef() {
-        assertEquals((byte)10, exec("def x = 5L; return (byte) (x <<= 1);"));
-        assertEquals((short)10, exec("def x = 5L; return (short) (x <<= 1);"));
-        assertEquals((char)10, exec("def x = 5L; return (char) (x <<= 1);"));
-        assertEquals(10, exec("def x = 5L; return (int) (x <<= 1);"));
-        assertEquals(10F, exec("def x = 5L; return (float) (x <<= 1);"));
-        assertEquals(10L, exec("def x = 5L; return (long) (x <<= 1);"));
-        assertEquals(10D, exec("def x = 5L; return (double) (x <<= 1);"));
-    }
-
     /**
      * Test that without a cast, we fail when conversions would narrow.
      */
@@ -286,10 +100,6 @@ public void testIllegalConversionsDef() {
         });
     }
 
-    public void testUnboxMethodParameters() {
-        assertEquals('a', exec("'a'.charAt(Integer.valueOf(0))"));
-    }
-
     public void testIllegalCastInMethodArgument() {
         assertEquals('a', exec("'a'.charAt(0)"));
         Exception e = expectScriptThrows(ClassCastException.class, () -> exec("'a'.charAt(0L)"));
@@ -318,4 +128,53 @@ public void testIllegalExplicitConversionsDef() {
             exec("def x = 5L; boolean y = (boolean) (x + x); return y");
         });
     }
+
+    public void testWideningCastOK() {
+        assertEquals(5, exec("Integer i = Integer.valueOf(5); Number n = i; n"));
+    }
+
+    public void testNarrowingCastRequiresExplicit() {
+        assertEquals(5, exec("Number n = Integer.valueOf(5); Integer i = (Integer) n; i"));
+        Exception e = expectScriptThrows(ClassCastException.class, () -> exec("Number n = Integer.valueOf(5); Integer i = n; i"));
+        assertEquals("Cannot cast from [Number] to [Integer].", e.getMessage());
+    }
+
+    public void testDefToNumericExplicitCasts() {
+        assertEquals(true, exec("     def d = true;       (boolean) d"));
+        assertEquals((byte) 5, exec(" def d = 5;          (byte) d"));
+        assertEquals((short) 5, exec("def d = 5;          (short) d"));
+        assertEquals('c', exec("      def d = (char) 'c'; (char) d"));
+        assertEquals(5, exec("        def d = 5;          (int) d"));
+        assertEquals(5L, exec("       def d = 5;          (long) d"));
+        assertEquals(5.0f, exec("     def d = 5;          (float) d"));
+        assertEquals(5.0d, exec("     def d = 5;          (double) d"));
+    }
+
+    public void testDefToNumericImplicitCasts() {
+        assertEquals(true, exec("     def d = true;      boolean b = d; b"));
+        assertEquals((byte) 5, exec(" def d = (byte) 5;  byte b = d;    b"));
+        assertEquals((short) 5, exec("def d = (short) 5; short s = d;   s"));
+        assertEquals('c', exec("def d = (char) 'c';      char c = d;    c"));
+        assertEquals(5, exec("        def d = 5;         int i = d;     i"));
+        assertEquals(5, exec("        def d = (short)5;  int i = d;     i"));
+        assertEquals(5L, exec("       def d = 5L;        long l = d;    l"));
+        assertEquals(5L, exec("       def d = 5;         long l = d;    l"));
+        assertEquals(5.0f, exec("     def d = 5f;        float f = d;   f"));
+        assertEquals(5.0f, exec("     def d = 5;         float f = d;   f"));
+        assertEquals(5.0f, exec("     def d = 5L;        float f = d;   f"));
+        assertEquals(5.0d, exec("     def d = 5d;        double n = d;  n"));
+        assertEquals(5.0d, exec("     def d = 5;         double n = d;  n"));
+        assertEquals(5.0d, exec("     def d = 5L;        double n = d;  n"));
+
+        expectScriptThrows(ClassCastException.class, () -> exec("def d = 5;    byte b = d;   b"));
+        expectScriptThrows(ClassCastException.class, () -> exec("def d = 5;    short s = d;  s"));
+        expectScriptThrows(ClassCastException.class, () -> exec("def d = 5L;   int i = d;    i"));
+        expectScriptThrows(ClassCastException.class, () -> exec("def d = 5.0f; long l = d;   l"));
+        expectScriptThrows(ClassCastException.class, () -> exec("def d = 5.0d; float f = d;  f"));
+    }
+
+    public void testDefToOtherCasts() {
+        assertEquals("test", exec("def d = new StringBuilder('test'); (StringBuilder) d").toString());
+        assertEquals("test", exec("def d = new StringBuilder('test'); StringBuilder sb = d; sb").toString());
+    }
 }
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/ForEachTests.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/ForEachTests.java
new file mode 100644
index 000000000000..594ca8e34369
--- /dev/null
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/ForEachTests.java
@@ -0,0 +1,157 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.painless;
+
+/**
+ * Tests iterating in foreach loops. Much of it is testing the rather expansive casting rules we allow in this context.
+ */
+public class ForEachTests extends ScriptTestCase {
+    public void testIterableForEachStatement() {
+        assertEquals(6, exec("List l = new ArrayList(); l.add(1); l.add(2); l.add(3); int total = 0;" +
+            " for (int x : l) total += x; return total"));
+        assertEquals(6, exec("List l = new ArrayList(); l.add(1); l.add(2); l.add(3); int total = 0;" +
+            " for (x in l) total += x; return total"));
+        assertEquals("123", exec("List l = new ArrayList(); l.add('1'); l.add('2'); l.add('3'); String cat = '';" +
+            " for (String x : l) cat += x; return cat"));
+        assertEquals("123", exec("List l = new ArrayList(); l.add('1'); l.add('2'); l.add('3'); String cat = '';" +
+            " for (x in l) cat += x; return cat"));
+        assertEquals("1236", exec("Map m = new HashMap(); m.put('1', 1); m.put('2', 2); m.put('3', 3);" +
+            " String cat = ''; int total = 0;" +
+            " for (Map.Entry e : m.entrySet()) { cat += e.getKey(); total += e.getValue(); } return cat + total"));
+        assertEquals("1236", exec("Map m = new HashMap(); m.put('1', 1); m.put('2', 2); m.put('3', 3);" +
+                " String cat = ''; int total = 0;" +
+                " for (e in m.entrySet()) { cat += e.getKey(); total += e.getValue(); } return cat + total"));
+    }
+
+    public void testIterableForEachStatementDef() {
+        assertEquals(6, exec("def l = new ArrayList(); l.add(1); l.add(2); l.add(3); int total = 0;" +
+            " for (int x : l) total += x; return total"));
+        assertEquals(6, exec("def l = new ArrayList(); l.add(1); l.add(2); l.add(3); int total = 0;" +
+            " for (x in l) total += x; return total"));
+        assertEquals("123", exec("def l = new ArrayList(); l.add('1'); l.add('2'); l.add('3'); String cat = '';" +
+            " for (String x : l) cat += x; return cat"));
+        assertEquals("123", exec("def l = new ArrayList(); l.add('1'); l.add('2'); l.add('3'); String cat = '';" +
+            " for (x in l) cat += x; return cat"));
+        assertEquals("1236", exec("def m = new HashMap(); m.put('1', 1); m.put('2', 2); m.put('3', 3);" +
+            " String cat = ''; int total = 0;" +
+            " for (Map.Entry e : m.entrySet()) { cat += e.getKey(); total += e.getValue(); } return cat + total"));
+        assertEquals("1236", exec("def m = new HashMap(); m.put('1', 1); m.put('2', 2); m.put('3', 3);" +
+            " String cat = ''; int total = 0;" +
+            " for (e in m.entrySet()) { cat += e.getKey(); total += e.getValue(); } return cat + total"));
+    }
+
+    public void testArrayForEachStatement() {
+        assertEquals(6, exec("int[] a = new int[3]; a[0] = 1; a[1] = 2; a[2] = 3; int total = 0;" +
+            " for (int x : a) total += x; return total"));
+        assertEquals(6, exec("int[] a = new int[3]; a[0] = 1; a[1] = 2; a[2] = 3; int total = 0;" +
+            " for (x in a) total += x; return total"));
+        assertEquals("123", exec("String[] a = new String[3]; a[0] = '1'; a[1] = '2'; a[2] = '3'; def total = '';" +
+            " for (String x : a) total += x; return total"));
+        assertEquals("123", exec("String[] a = new String[3]; a[0] = '1'; a[1] = '2'; a[2] = '3'; def total = '';" +
+            " for (x in a) total += x; return total"));
+        assertEquals(6, exec("int[][] i = new int[3][1]; i[0][0] = 1; i[1][0] = 2; i[2][0] = 3; int total = 0;" +
+            " for (int[] j : i) total += j[0]; return total"));
+        assertEquals(6, exec("int[][] i = new int[3][1]; i[0][0] = 1; i[1][0] = 2; i[2][0] = 3; int total = 0;" +
+            " for (j in i) total += j[0]; return total"));
+    }
+
+    public void testArrayForEachStatementDef() {
+        assertEquals(6, exec("def a = new int[3]; a[0] = 1; a[1] = 2; a[2] = 3; int total = 0;" +
+            " for (int x : a) total += x; return total"));
+        assertEquals(6, exec("def a = new int[3]; a[0] = 1; a[1] = 2; a[2] = 3; int total = 0;" +
+            " for (x in a) total += x; return total"));
+        assertEquals("123", exec("def a = new String[3]; a[0] = '1'; a[1] = '2'; a[2] = '3'; def total = '';" +
+            " for (String x : a) total += x; return total"));
+        assertEquals("123", exec("def a = new String[3]; a[0] = '1'; a[1] = '2'; a[2] = '3'; def total = '';" +
+            " for (x in a) total += x; return total"));
+        assertEquals(6, exec("def i = new int[3][1]; i[0][0] = 1; i[1][0] = 2; i[2][0] = 3; int total = 0;" +
+            " for (int[] j : i) total += j[0]; return total"));
+        assertEquals(6, exec("def i = new int[3][1]; i[0][0] = 1; i[1][0] = 2; i[2][0] = 3; int total = 0;" +
+            " for (j in i) total += j[0]; return total"));
+    }
+
+    public void testCastToByte() {
+        castTestCase((byte) 1, "byte", true);
+        castTestCase((byte) 1, "Byte", false);
+    }
+
+    public void testCastToShort() {
+        castTestCase((short) 1, "short", true);
+        castTestCase((short) 1, "Short", false);
+    }
+
+    public void testCastToChar() {
+        castTestCase((char) 1, "char", true);
+        castTestCase((char) 1, "Character", false);
+    }
+
+    public void testCastToInt() {
+        castTestCase(1, "int", true);
+        castTestCase(1, "Integer", false);
+    }
+
+    public void testCastToLong() {
+        castTestCase((long) 1, "long", true);
+        castTestCase((long) 1, "Long", false);
+    }
+
+    public void testCastToFloat() {
+        castTestCase((float) 1, "float", true);
+        castTestCase((float) 1, "Float", false);
+    }
+
+    public void testCastToDouble() {
+        castTestCase((double) 1, "double", true);
+        castTestCase((double) 1, "Double", false);
+    }
+
+    private void castTestCase(Object expected, String returnType, boolean canCastFromObject) {
+        castTestCase(expected, returnType, "byte",   "(byte) 1");
+        castTestCase(expected, returnType, "short",  "(short) 1");
+        castTestCase(expected, returnType, "char",   "(char) 1");
+        castTestCase(expected, returnType, "int",    "1");
+        castTestCase(expected, returnType, "long",   "1L");
+        castTestCase(expected, returnType, "float",  "1f");
+        castTestCase(expected, returnType, "double", "1d");
+        if (canCastFromObject) {
+            castTestCase(expected, returnType, "Byte", "Byte.valueOf(1)");
+            castTestCase(expected, returnType, "Short", "Short.valueOf(1)");
+            castTestCase(expected, returnType, "Character", "Character.valueOf(1)");
+            castTestCase(expected, returnType, "Integer", "Integer.valueOf(1)");
+            castTestCase(expected, returnType, "Long", "Long.valueOf(1L)");
+            castTestCase(expected, returnType, "Float", "Float.valueOf(1f)");
+            castTestCase(expected, returnType, "Double", "Double.valueOf(1d)");
+            if (false == returnType.equals("char")) {
+                castTestCase(expected, returnType, "Number", "Double.valueOf(1d)");
+                castTestCase(expected, returnType, "Object", "Double.valueOf(1d)");
+            }
+        }
+    }
+
+    private void castTestCase(Object expected, String returnType, String arrayType, String arrayValue) {
+        String script =
+                  arrayType + "[] a = new " + arrayType + "[1];\n"
+                + "a[0] = " + arrayValue +";\n"
+                + "def r;\n"
+                + "for (" + returnType + " i : a) {r = i}\n"
+                + "return r";
+        assertEquals(expected, exec(script));
+    }
+}
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/FunctionReturnTests.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/FunctionReturnTests.java
new file mode 100644
index 000000000000..debeda902e27
--- /dev/null
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/FunctionReturnTests.java
@@ -0,0 +1,183 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.painless;
+
+/**
+ * Tests casting behavior around function return values. This amounts to tests of implicit casting.
+ */
+public class FunctionReturnTests extends ScriptTestCase {
+    public void testReturnsAreUnboxedIfNeeded() {
+        assertEquals((byte) 5, exec(   "byte get() {Byte.valueOf(5)} get()"));
+        assertEquals((short) 5, exec( "short get() {Byte.valueOf(5)} get()"));
+        assertEquals(5, exec(           "int get() {Byte.valueOf(5)} get()"));
+        assertEquals((short) 5, exec( "short get() {Short.valueOf(5)} get()"));
+        assertEquals(5, exec(           "int get() {Integer.valueOf(5)} get()"));
+        assertEquals(5.0f, exec(      "float get() {Float.valueOf(5)} get()"));
+        assertEquals(5.0d, exec(     "double get() {Float.valueOf(5)} get()"));
+        assertEquals(5.0d, exec(     "double get() {Double.valueOf(5)} get()"));
+        assertEquals(true, exec(    "boolean get() {Boolean.TRUE} get()"));
+    }
+
+    public void testReturnBoolean() {
+        // Constants
+        assertEquals(true, exec( "Boolean get() {true } get()"));
+        assertEquals(false, exec("Boolean get() {false} get()"));
+        assertEquals(true, exec( "Object  get() {true } get()"));
+        assertEquals(false, exec("Object  get() {false} get()"));
+        assertEquals(true, exec( "def     get() {true } get()"));
+        assertEquals(false, exec("def     get() {false} get()"));
+        Exception e = expectScriptThrows(ClassCastException.class, () -> exec("Number get() {false} get()"));
+        assertEquals("Cannot cast from [boolean] to [Number].", e.getMessage());
+        e = expectScriptThrows(ClassCastException.class, () -> exec("String get() {false} get()"));
+        assertEquals("Cannot cast from [boolean] to [String].", e.getMessage());
+        e = expectScriptThrows(ClassCastException.class, () -> exec("CharSequence get() {false} get()"));
+        assertEquals("Cannot cast from [boolean] to [CharSequence].", e.getMessage());
+
+        // Non-constants
+        assertEquals(true, exec( "Boolean get(boolean b) {b} get(true)"));
+        assertEquals(false, exec("Boolean get(boolean b) {b} get(false)"));
+        assertEquals(true, exec( "Object  get(boolean b) {b} get(true)"));
+        assertEquals(false, exec("Object  get(boolean b) {b} get(false)"));
+        assertEquals(true, exec( "def     get(boolean b) {b} get(true)"));
+        assertEquals(false, exec("def     get(boolean b) {b} get(false)"));
+        e = expectScriptThrows(ClassCastException.class, () -> exec("Number get(boolean b) {b} get(false)"));
+        assertEquals("Cannot cast from [boolean] to [Number].", e.getMessage());
+        e = expectScriptThrows(ClassCastException.class, () -> exec("String get(boolean b) {b} get(false)"));
+        assertEquals("Cannot cast from [boolean] to [String].", e.getMessage());
+        e = expectScriptThrows(ClassCastException.class, () -> exec("CharSequence get(boolean b) {b} get(false)"));
+        assertEquals("Cannot cast from [boolean] to [CharSequence].", e.getMessage());
+    }
+
+    public void testReturnByte() {
+        returnByteOk("byte");
+    }
+
+    public void testReturnShort() {
+        returnShortOk("short");
+    }
+
+    public void testReturnChar() {
+        returnCharOk("char");
+    }
+
+    public void testReturnInt() {
+        returnIntOk("int");
+    }
+
+    public void testReturnLong() {
+        returnLongOk("long");
+    }
+
+    public void testReturnFloat() {
+        returnFloatOk("float");
+    }
+
+    public void testReturnDouble() {
+        returnDoubleOk("double");
+    }
+
+    private void returnByteOk(String type) {
+        assertEquals((byte) 5, exec(     "byte get() {(" + type + ") 5} get()"));
+        assertEquals((byte) 5, exec(     "Byte get() {(" + type + ") 5} get()"));
+        assertEquals((byte) 5, exec(     "byte get(" + type + " b) {        b} get(5)"));
+        assertEquals((byte) 5, exec(     "Byte get(" + type + " b) {        b} get(5)"));
+        returnShortOk(type);
+    }
+
+    private void returnShortOk(String type) {
+        assertEquals((short) 5, exec(   "short get() {(" + type + ") 5} get()"));
+        assertEquals((short) 5, exec(   "Short get() {(" + type + ") 5} get()"));
+        assertEquals((short) 5, exec(   "short get(" + type + " b) {        b} get(5)"));
+        assertEquals((short) 5, exec(   "Short get(" + type + " b) {        b} get(5)"));
+        returnCharOk(type);
+    }
+
+    private void returnCharOk(String type) {
+        assertEquals((char) 5, exec(     "char get() {(char)(" + type + ") 5} get()"));
+        assertEquals((char) 5, exec("Character get() {(char)(" + type + ") 5} get()"));
+        assertEquals((char) 5, exec(     "char get(" + type + " b) { (char) b} get(5)"));
+        assertEquals((char) 5, exec("Character get(" + type + " b) { (char) b} get(5)"));
+        returnIntOk(type);
+    }
+
+    private void returnIntOk(String type) {
+        assertEquals(5, exec(             "int get() {(" + type + ") 5} get()"));
+        assertEquals(5, exec(         "Integer get() {(" + type + ") 5} get()"));
+        assertEquals(5, exec(             "int get(" + type + " b) {        b} get(5)"));
+        assertEquals(5, exec(         "Integer get(" + type + " b) {        b} get(5)"));
+        returnLongOk(type);
+    }
+
+    private void returnLongOk(String type) {
+        assertEquals(5L, exec(           "long get() {(" + type + ") 5} get()"));
+        assertEquals(5L, exec(           "Long get() {(" + type + ") 5} get()"));
+        assertEquals(5L, exec(           "long get(" + type + " b) {        b} get(5)"));
+        assertEquals(5L, exec(           "Long get(" + type + " b) {        b} get(5)"));
+        returnFloatOk(type);
+    }
+
+    private void returnFloatOk(String type) {
+        assertEquals(5f, exec(          "float get() {(" + type + ") 5} get()"));
+        assertEquals(5f, exec(          "Float get() {(" + type + ") 5} get()"));
+        assertEquals(5f, exec(          "float get(" + type + " b) {        b} get(5)"));
+        assertEquals(5f, exec(          "Float get(" + type + " b) {        b} get(5)"));
+        returnDoubleOk(type);
+    }
+
+    private void returnDoubleOk(String type) {
+        // Constants
+        assertEquals(5d, exec(           "double get() {(" + type + ") 5} get()"));
+        assertEquals(5d, exec(           "Double get() {(" + type + ") 5} get()"));
+        if (false == type.equals("char")) {
+            // Chars are funny. They can cast to primitive numbers but not Number....
+            assertEquals(5,  exec(       "Number get() {(" + type + ") 5} get().intValue()"));
+            assertEquals(5,  exec(       "Object get() {(" + type + ") 5} ((Number) get()).intValue()"));
+            assertEquals(5,  exec(          "def get() {(" + type + ") 5} get().intValue()"));
+        } else {
+            assertEquals((char) 5,  exec("Object get() {(" + type + ") 5} get()"));
+            assertEquals((char) 5,  exec(   "def get() {(" + type + ") 5} get()"));
+        }
+
+        // Non-constants
+        assertEquals((byte) 5, exec(      "byte get(" + type + " b) { (byte) b} get(5)"));
+        assertEquals((short) 5, exec(    "short get(" + type + " b) {(short) b} get(5)"));
+        assertEquals((char) 5, exec(      "char get(" + type + " b) { (char) b} get(5)"));
+        assertEquals(5, exec(              "int get(" + type + " b) {  (int) b} get(5)"));
+        assertEquals(5L, exec(            "long get(" + type + " b) { (long) b} get(5)"));
+        assertEquals(5f, exec(           "float get(" + type + " b) {(float) b} get(5)"));
+        assertEquals(5d, exec(          "double get(" + type + " b) {        b} get(5)"));
+        assertEquals((byte) 5, exec(      "Byte get(" + type + " b) { (byte) b} get(5)"));
+        assertEquals((short) 5, exec(    "Short get(" + type + " b) {(short) b} get(5)"));
+        assertEquals((char) 5, exec( "Character get(" + type + " b) { (char) b} get(5)"));
+        assertEquals(5, exec(          "Integer get(" + type + " b) {  (int) b} get(5)"));
+        assertEquals(5L, exec(            "Long get(" + type + " b) { (long) b} get(5)"));
+        assertEquals(5f, exec(           "Float get(" + type + " b) {(float) b} get(5)"));
+        assertEquals(5d, exec(          "Double get(" + type + " b) {        b} get(5)"));
+        if (false == type.equals("char")) {
+            // Chars are funny. They can cast to primitive numbers but not Number....
+            assertEquals(5,  exec(      "Number get(" + type + " b) {        b} get(5).intValue()"));
+            assertEquals(5,  exec(      "Object get(" + type + " b) {        b} ((Number) get(5)).intValue()"));
+            assertEquals(5,  exec(         "def get(" + type + " b) {        b} get(5).intValue()"));
+        } else {
+            assertEquals((char) 5, exec("Object get(" + type + " b) {        b} ((Character) get(5))"));
+            assertEquals((char) 5, exec(   "def get(" + type + " b) {        b} get(5)"));
+        }
+    }
+}
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/FunctionTests.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/FunctionTests.java
index 8f9505d09c96..8c4d7735a332 100644
--- a/modules/lang-painless/src/test/java/org/elasticsearch/painless/FunctionTests.java
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/FunctionTests.java
@@ -54,18 +54,6 @@ public void testEmpty() {
         assertThat(expected.getMessage(), containsString("Cannot generate an empty function"));
     }
 
-    public void testReturnsAreUnboxedIfNeeded() {
-        assertEquals((byte) 5, exec("byte get() {Byte.valueOf(5)} get()"));
-        assertEquals((short) 5, exec("short get() {Byte.valueOf(5)} get()"));
-        assertEquals(5, exec("int get() {Byte.valueOf(5)} get()"));
-        assertEquals((short) 5, exec("short get() {Short.valueOf(5)} get()"));
-        assertEquals(5, exec("int get() {Integer.valueOf(5)} get()"));
-        assertEquals(5.0f, exec("float get() {Float.valueOf(5)} get()"));
-        assertEquals(5.0d, exec("double get() {Float.valueOf(5)} get()"));
-        assertEquals(5.0d, exec("double get() {Double.valueOf(5)} get()"));
-        assertEquals(true, exec("boolean get() {Boolean.TRUE} get()"));
-    }
-
     public void testDuplicates() {
         Exception expected = expectScriptThrows(IllegalArgumentException.class, () -> {
             exec("void test(int x) {x = 2;} void test(def y) {y = 3;} test()");
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/OperatorCastTests.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/OperatorCastTests.java
new file mode 100644
index 000000000000..05c2b3a831f9
--- /dev/null
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/OperatorCastTests.java
@@ -0,0 +1,216 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.painless;
+
+/**
+ * Tests the interactions between casts and operators.
+ */
+public class OperatorCastTests extends ScriptTestCase {
+    /**
+     * Unary operator with explicit cast
+     */
+    public void testUnaryOperator() {
+        assertEquals((byte)5, exec("long x = 5L; return (byte) (+x);"));
+        assertEquals((short)5, exec("long x = 5L; return (short) (+x);"));
+        assertEquals((char)5, exec("long x = 5L; return (char) (+x);"));
+        assertEquals(5, exec("long x = 5L; return (int) (+x);"));
+        assertEquals(5F, exec("long x = 5L; return (float) (+x);"));
+        assertEquals(5L, exec("long x = 5L; return (long) (+x);"));
+        assertEquals(5D, exec("long x = 5L; return (double) (+x);"));
+    }
+
+    /**
+     * Binary operators with explicit cast
+     */
+    public void testBinaryOperator() {
+        assertEquals((byte)6, exec("long x = 5L; return (byte) (x + 1);"));
+        assertEquals((short)6, exec("long x = 5L; return (short) (x + 1);"));
+        assertEquals((char)6, exec("long x = 5L; return (char) (x + 1);"));
+        assertEquals(6, exec("long x = 5L; return (int) (x + 1);"));
+        assertEquals(6F, exec("long x = 5L; return (float) (x + 1);"));
+        assertEquals(6L, exec("long x = 5L; return (long) (x + 1);"));
+        assertEquals(6D, exec("long x = 5L; return (double) (x + 1);"));
+    }
+
+    /**
+     * Binary compound assignment with explicit cast
+     */
+    public void testBinaryCompoundAssignment() {
+        assertEquals((byte)6, exec("long x = 5L; return (byte) (x += 1);"));
+        assertEquals((short)6, exec("long x = 5L; return (short) (x += 1);"));
+        assertEquals((char)6, exec("long x = 5L; return (char) (x += 1);"));
+        assertEquals(6, exec("long x = 5L; return (int) (x += 1);"));
+        assertEquals(6F, exec("long x = 5L; return (float) (x += 1);"));
+        assertEquals(6L, exec("long x = 5L; return (long) (x += 1);"));
+        assertEquals(6D, exec("long x = 5L; return (double) (x += 1);"));
+    }
+
+    /**
+     * Binary compound prefix with explicit cast
+     */
+    public void testBinaryPrefix() {
+        assertEquals((byte)6, exec("long x = 5L; return (byte) (++x);"));
+        assertEquals((short)6, exec("long x = 5L; return (short) (++x);"));
+        assertEquals((char)6, exec("long x = 5L; return (char) (++x);"));
+        assertEquals(6, exec("long x = 5L; return (int) (++x);"));
+        assertEquals(6F, exec("long x = 5L; return (float) (++x);"));
+        assertEquals(6L, exec("long x = 5L; return (long) (++x);"));
+        assertEquals(6D, exec("long x = 5L; return (double) (++x);"));
+    }
+
+    /**
+     * Binary compound postifx with explicit cast
+     */
+    public void testBinaryPostfix() {
+        assertEquals((byte)5, exec("long x = 5L; return (byte) (x++);"));
+        assertEquals((short)5, exec("long x = 5L; return (short) (x++);"));
+        assertEquals((char)5, exec("long x = 5L; return (char) (x++);"));
+        assertEquals(5, exec("long x = 5L; return (int) (x++);"));
+        assertEquals(5F, exec("long x = 5L; return (float) (x++);"));
+        assertEquals(5L, exec("long x = 5L; return (long) (x++);"));
+        assertEquals(5D, exec("long x = 5L; return (double) (x++);"));
+    }
+
+    /**
+     * Shift operators with explicit cast
+     */
+    public void testShiftOperator() {
+        assertEquals((byte)10, exec("long x = 5L; return (byte) (x << 1);"));
+        assertEquals((short)10, exec("long x = 5L; return (short) (x << 1);"));
+        assertEquals((char)10, exec("long x = 5L; return (char) (x << 1);"));
+        assertEquals(10, exec("long x = 5L; return (int) (x << 1);"));
+        assertEquals(10F, exec("long x = 5L; return (float) (x << 1);"));
+        assertEquals(10L, exec("long x = 5L; return (long) (x << 1);"));
+        assertEquals(10D, exec("long x = 5L; return (double) (x << 1);"));
+    }
+
+    /**
+     * Shift compound assignment with explicit cast
+     */
+    public void testShiftCompoundAssignment() {
+        assertEquals((byte)10, exec("long x = 5L; return (byte) (x <<= 1);"));
+        assertEquals((short)10, exec("long x = 5L; return (short) (x <<= 1);"));
+        assertEquals((char)10, exec("long x = 5L; return (char) (x <<= 1);"));
+        assertEquals(10, exec("long x = 5L; return (int) (x <<= 1);"));
+        assertEquals(10F, exec("long x = 5L; return (float) (x <<= 1);"));
+        assertEquals(10L, exec("long x = 5L; return (long) (x <<= 1);"));
+        assertEquals(10D, exec("long x = 5L; return (double) (x <<= 1);"));
+    }
+
+    /**
+     * Currently these do not adopt the argument value, we issue a separate cast!
+     */
+    public void testArgumentsDef() {
+        assertEquals(5, exec("def x = 5L; return (+(int)x);"));
+        assertEquals(6, exec("def x = 5; def y = 1L; return x + (int)y"));
+        assertEquals('b', exec("def x = 'abcdeg'; def y = 1L; x.charAt((int)y)"));
+    }
+
+    /**
+     * Unary operators adopt the return value
+     */
+    public void testUnaryOperatorDef() {
+        assertEquals((byte)5, exec("def x = 5L; return (byte) (+x);"));
+        assertEquals((short)5, exec("def x = 5L; return (short) (+x);"));
+        assertEquals((char)5, exec("def x = 5L; return (char) (+x);"));
+        assertEquals(5, exec("def x = 5L; return (int) (+x);"));
+        assertEquals(5F, exec("def x = 5L; return (float) (+x);"));
+        assertEquals(5L, exec("def x = 5L; return (long) (+x);"));
+        assertEquals(5D, exec("def x = 5L; return (double) (+x);"));
+    }
+
+    /**
+     * Binary operators adopt the return value
+     */
+    public void testBinaryOperatorDef() {
+        assertEquals((byte)6, exec("def x = 5L; return (byte) (x + 1);"));
+        assertEquals((short)6, exec("def x = 5L; return (short) (x + 1);"));
+        assertEquals((char)6, exec("def x = 5L; return (char) (x + 1);"));
+        assertEquals(6, exec("def x = 5L; return (int) (x + 1);"));
+        assertEquals(6F, exec("def x = 5L; return (float) (x + 1);"));
+        assertEquals(6L, exec("def x = 5L; return (long) (x + 1);"));
+        assertEquals(6D, exec("def x = 5L; return (double) (x + 1);"));
+    }
+
+    /**
+     * Binary operators don't yet adopt the return value with compound assignment
+     */
+    public void testBinaryCompoundAssignmentDef() {
+        assertEquals((byte)6, exec("def x = 5L; return (byte) (x += 1);"));
+        assertEquals((short)6, exec("def x = 5L; return (short) (x += 1);"));
+        assertEquals((char)6, exec("def x = 5L; return (char) (x += 1);"));
+        assertEquals(6, exec("def x = 5L; return (int) (x += 1);"));
+        assertEquals(6F, exec("def x = 5L; return (float) (x += 1);"));
+        assertEquals(6L, exec("def x = 5L; return (long) (x += 1);"));
+        assertEquals(6D, exec("def x = 5L; return (double) (x += 1);"));
+    }
+
+    /**
+     * Binary operators don't yet adopt the return value with compound assignment
+     */
+    public void testBinaryCompoundAssignmentPrefix() {
+        assertEquals((byte)6, exec("def x = 5L; return (byte) (++x);"));
+        assertEquals((short)6, exec("def x = 5L; return (short) (++x);"));
+        assertEquals((char)6, exec("def x = 5L; return (char) (++x);"));
+        assertEquals(6, exec("def x = 5L; return (int) (++x);"));
+        assertEquals(6F, exec("def x = 5L; return (float) (++x);"));
+        assertEquals(6L, exec("def x = 5L; return (long) (++x);"));
+        assertEquals(6D, exec("def x = 5L; return (double) (++x);"));
+    }
+
+    /**
+     * Binary operators don't yet adopt the return value with compound assignment
+     */
+    public void testBinaryCompoundAssignmentPostfix() {
+        assertEquals((byte)5, exec("def x = 5L; return (byte) (x++);"));
+        assertEquals((short)5, exec("def x = 5L; return (short) (x++);"));
+        assertEquals((char)5, exec("def x = 5L; return (char) (x++);"));
+        assertEquals(5, exec("def x = 5L; return (int) (x++);"));
+        assertEquals(5F, exec("def x = 5L; return (float) (x++);"));
+        assertEquals(5L, exec("def x = 5L; return (long) (x++);"));
+        assertEquals(5D, exec("def x = 5L; return (double) (x++);"));
+    }
+
+    /**
+     * Shift operators adopt the return value
+     */
+    public void testShiftOperatorDef() {
+        assertEquals((byte)10, exec("def x = 5L; return (byte) (x << 1);"));
+        assertEquals((short)10, exec("def x = 5L; return (short) (x << 1);"));
+        assertEquals((char)10, exec("def x = 5L; return (char) (x << 1);"));
+        assertEquals(10, exec("def x = 5L; return (int) (x << 1);"));
+        assertEquals(10F, exec("def x = 5L; return (float) (x << 1);"));
+        assertEquals(10L, exec("def x = 5L; return (long) (x << 1);"));
+        assertEquals(10D, exec("def x = 5L; return (double) (x << 1);"));
+    }
+
+    /**
+     * Shift operators don't yet adopt the return value with compound assignment
+     */
+    public void testShiftCompoundAssignmentDef() {
+        assertEquals((byte)10, exec("def x = 5L; return (byte) (x <<= 1);"));
+        assertEquals((short)10, exec("def x = 5L; return (short) (x <<= 1);"));
+        assertEquals((char)10, exec("def x = 5L; return (char) (x <<= 1);"));
+        assertEquals(10, exec("def x = 5L; return (int) (x <<= 1);"));
+        assertEquals(10F, exec("def x = 5L; return (float) (x <<= 1);"));
+        assertEquals(10L, exec("def x = 5L; return (long) (x <<= 1);"));
+        assertEquals(10D, exec("def x = 5L; return (double) (x <<= 1);"));
+    }
+}
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/StringTests.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/StringTests.java
index da4558a693a0..44999b799390 100644
--- a/modules/lang-painless/src/test/java/org/elasticsearch/painless/StringTests.java
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/StringTests.java
@@ -164,16 +164,19 @@ public void testStringAndCharacter() {
 
         assertEquals('c', exec("String s = \"c\"; (char)s"));
         assertEquals('c', exec("String s = 'c'; (char)s"));
+        assertEquals("c", exec("char s = (char)'c'; (String)s"));
 
-        ClassCastException expected = expectScriptThrows(ClassCastException.class, () -> {
+        Exception expected = expectScriptThrows(IllegalArgumentException.class, () -> {
             assertEquals("cc", exec("return (String)(char)\"cc\""));
         });
-        assertTrue(expected.getMessage().contains("Cannot cast [String] with length greater than one to [char]."));
+        assertTrue(expected.getMessage().contains("Failed to cast constant: Cannot cast [String] with length greater than one to [char]."));
+        assertTrue(expected.getCause().getMessage().contains("Cannot cast [String] with length greater than one to [char]."));
 
-        expected = expectScriptThrows(ClassCastException.class, () -> {
+        expected = expectScriptThrows(IllegalArgumentException.class, () -> {
             assertEquals("cc", exec("return (String)(char)'cc'"));
         });
-        assertTrue(expected.getMessage().contains("Cannot cast [String] with length greater than one to [char]."));
+        assertTrue(expected.getMessage().contains("Failed to cast constant: Cannot cast [String] with length greater than one to [char]."));
+        assertTrue(expected.getCause().getMessage().contains("Cannot cast [String] with length greater than one to [char]."));
 
         expected = expectScriptThrows(ClassCastException.class, () -> {
             assertEquals('c', exec("String s = \"cc\"; (char)s"));
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/node/NodeToStringTests.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/node/NodeToStringTests.java
index a4530823c9ed..07ee87c6e4c2 100644
--- a/modules/lang-painless/src/test/java/org/elasticsearch/painless/node/NodeToStringTests.java
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/node/NodeToStringTests.java
@@ -21,7 +21,6 @@
 
 import org.elasticsearch.painless.CompilerSettings;
 import org.elasticsearch.painless.Definition;
-import org.elasticsearch.painless.Definition.Cast;
 import org.elasticsearch.painless.Definition.Field;
 import org.elasticsearch.painless.Definition.Method;
 import org.elasticsearch.painless.Definition.MethodKey;
@@ -31,8 +30,10 @@
 import org.elasticsearch.painless.GenericElasticsearchScript;
 import org.elasticsearch.painless.Locals.Variable;
 import org.elasticsearch.painless.Location;
-import org.elasticsearch.painless.ScriptInterface;
+import org.elasticsearch.painless.Cast;
 import org.elasticsearch.painless.Operation;
+import org.elasticsearch.painless.ScriptInterface;
+import org.elasticsearch.painless.Utility;
 import org.elasticsearch.painless.antlr.Walker;
 import org.elasticsearch.test.ESTestCase;
 
@@ -42,6 +43,12 @@
 
 import static java.util.Collections.emptyList;
 import static java.util.Collections.singletonList;
+import static org.elasticsearch.painless.Definition.DOUBLE_TYPE;
+import static org.elasticsearch.painless.Definition.FLOAT_TYPE;
+import static org.elasticsearch.painless.Definition.INT_TYPE;
+import static org.elasticsearch.painless.Definition.SHORT_TYPE;
+import static org.elasticsearch.painless.WriterConstants.CHAR_TO_STRING;
+import static org.elasticsearch.painless.WriterConstants.UTILITY_TYPE;
 
 /**
  * Tests {@link Object#toString} implementations on all extensions of {@link ANode}.
@@ -157,14 +164,32 @@ public void testECapturingFunctionRef() {
 
     public void testECast() {
         Location l = new Location(getTestName(), 0);
-        AExpression child = new EConstant(l, "test");
-        Cast cast = new Cast(Definition.STRING_TYPE, Definition.INT_OBJ_TYPE, true);
-        assertEquals("(ECast Integer (EConstant String 'test'))", new ECast(l, child, cast).toString());
+        AExpression child = new EConstant(l, 1.0f);
+        Cast cast = new Cast.Numeric(FLOAT_TYPE, SHORT_TYPE);
+        assertEquals("(ECast (Numeric float short) (EConstant Float 1.0))", new ECast(l, child, cast).toString());
 
         l = new Location(getTestName(), 1);
-        child = new EBinary(l, Operation.ADD, new EConstant(l, "test"), new EConstant(l, 12));
-        cast = new Cast(Definition.INT_OBJ_TYPE, Definition.BOOLEAN_OBJ_TYPE, true);
-        assertEquals("(ECast Boolean (EBinary (EConstant String 'test') + (EConstant Integer 12)))", new ECast(l, child, cast).toString());
+        child = new EBinary(l, Operation.ADD, new EConstant(l, 1.0f), new EConstant(l, 12));
+        cast = new Cast.Numeric(DOUBLE_TYPE, INT_TYPE, new Cast.Box(INT_TYPE));
+        assertEquals("(ECast (Numeric double int (Box int)) (EBinary (EConstant Float 1.0) + (EConstant Integer 12)))",
+                new ECast(l, child, cast).toString());
+
+        child = new EConstant(l, 1.0f);
+        cast = new Cast.Unbox(FLOAT_TYPE);
+        assertEquals("(ECast (Unbox float) (EConstant Float 1.0))", new ECast(l, child, cast).toString());
+
+        child = new EConstant(l, 1.0f);
+        cast = new Cast.Unbox(FLOAT_TYPE, new Cast.Numeric(FLOAT_TYPE, INT_TYPE));
+        assertEquals("(ECast (Unbox float (Numeric float int)) (EConstant Float 1.0))", new ECast(l, child, cast).toString());
+
+        child = new EConstant(l, "test");
+        cast = new Cast.CheckedCast(Definition.getType("StringBuilder"));
+        assertEquals("(ECast (CheckedCast StringBuilder) (EConstant String 'test'))", new ECast(l, child, cast).toString());
+
+        child = new EConstant(l, "test");
+        cast = new Cast.InvokeStatic(UTILITY_TYPE, CHAR_TO_STRING, c -> Utility.charToString((Character) c));
+        assertEquals("(ECast (InvokeStatic " + Utility.class.getName() + "#charToString) (EConstant String 'test'))",
+                new ECast(l, child, cast).toString());
     }
 
     public void testEComp() {
