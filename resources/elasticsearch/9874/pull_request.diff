diff --git a/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java b/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java
index b3b9de519859..ce9a236655ed 100644
--- a/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java
+++ b/src/main/java/org/elasticsearch/index/mapper/DocumentMapper.java
@@ -675,6 +675,10 @@ public CompressedString refreshSource() throws ElasticsearchGenerationException
         }
     }
 
+    public boolean mappingsModified() {
+        return cache.get().mappingsModified();
+    }
+
     public void close() {
         cache.close();
         rootObjectMapper.close();
diff --git a/src/main/java/org/elasticsearch/index/shard/IndexShard.java b/src/main/java/org/elasticsearch/index/shard/IndexShard.java
index 57e3f3df52d6..cf3b7266c4c5 100644
--- a/src/main/java/org/elasticsearch/index/shard/IndexShard.java
+++ b/src/main/java/org/elasticsearch/index/shard/IndexShard.java
@@ -433,7 +433,7 @@ private IndexShardState changeState(IndexShardState newState, String reason) {
             ParsedDocument doc = docMapper.v1().parse(source).setMappingsModified(docMapper);
             return new Engine.Create(docMapper.v1(), docMapper.v1().uidMapper().term(doc.uid().stringValue()), doc, version, versionType, origin, startTime, state != IndexShardState.STARTED || canHaveDuplicates, autoGeneratedId);
         } catch (Throwable t) {
-            if (docMapper.v2()) {
+            if (docMapper.v2() || docMapper.v1().mappingsModified()) {
                 throw new WriteFailureException(t, docMapper.v1().type());
             } else {
                 throw t;
@@ -466,7 +466,7 @@ public ParsedDocument create(Engine.Create create) throws ElasticsearchException
             ParsedDocument doc = docMapper.v1().parse(source).setMappingsModified(docMapper);
             return new Engine.Index(docMapper.v1(), docMapper.v1().uidMapper().term(doc.uid().stringValue()), doc, version, versionType, origin, startTime, state != IndexShardState.STARTED || canHaveDuplicates);
         } catch (Throwable t) {
-            if (docMapper.v2()) {
+            if (docMapper.v2() || docMapper.v1().mappingsModified()) {
                 throw new WriteFailureException(t, docMapper.v1().type());
             } else {
                 throw t;
diff --git a/src/test/java/org/elasticsearch/index/mapper/dynamic/DynamicMappingTests.java b/src/test/java/org/elasticsearch/index/mapper/dynamic/DynamicMappingTests.java
index a1fa2c62e17c..47c739d4a12d 100644
--- a/src/test/java/org/elasticsearch/index/mapper/dynamic/DynamicMappingTests.java
+++ b/src/test/java/org/elasticsearch/index/mapper/dynamic/DynamicMappingTests.java
@@ -20,18 +20,18 @@
 
 import com.google.common.base.Predicate;
 import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsResponse;
+import org.elasticsearch.action.index.IndexRequestBuilder;
 import org.elasticsearch.common.settings.ImmutableSettings;
 import org.elasticsearch.common.xcontent.XContentBuilder;
 import org.elasticsearch.common.xcontent.XContentFactory;
-import org.elasticsearch.index.mapper.DocumentMapper;
-import org.elasticsearch.index.mapper.FieldMappers;
-import org.elasticsearch.index.mapper.ParsedDocument;
-import org.elasticsearch.index.mapper.StrictDynamicMappingException;
+import org.elasticsearch.index.mapper.*;
 import org.elasticsearch.index.IndexService;
 import org.elasticsearch.test.ElasticsearchSingleNodeTest;
 import org.junit.Test;
 
 import java.io.IOException;
+import java.util.LinkedHashMap;
+import java.util.Map;
 
 import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;
 import static org.hamcrest.Matchers.equalTo;
@@ -242,4 +242,49 @@ public boolean apply(java.lang.Object input) {
         getMappingsResponse = client().admin().indices().prepareGetMappings("test").get();
         assertNotNull(getMappingsResponse.getMappings().get("test").get("type"));
     }
+
+    @Test
+    public void testFieldsCreatedWithPartialParsing() throws IOException, InterruptedException {
+        XContentBuilder mapping = jsonBuilder().startObject().startObject("doc")
+                .startObject("properties")
+                .startObject("z")
+                .field("type", "long")
+                .endObject()
+                .endObject()
+                .endObject().endObject();
+
+        IndexService indexService = createIndex("test", ImmutableSettings.EMPTY, "doc", mapping);
+        boolean create = randomBoolean();
+        if (create == false) {
+            // we want to test sometimes create and sometimes index so sometimes add the document before and sometimes not
+            client().prepareIndex().setIndex("test").setType("doc").setId("1").setSource(jsonBuilder().startObject().field("z", 0).endObject()).get();
+        }
+        try {
+            IndexRequestBuilder indexRequest = client().prepareIndex().setIndex("test").setType("doc").setId("1").setSource(jsonBuilder().startObject().field("a", "string").field("z", "string").endObject());
+            indexRequest.setCreate(create);
+            indexRequest.get();
+            fail();
+        } catch (MapperParsingException e) {
+            // this should fail because the field z is of type long
+        }
+        //type should be in mapping
+        GetMappingsResponse getMappingsResponse = client().admin().indices().prepareGetMappings("test").get();
+        assertNotNull(getMappingsResponse.getMappings().get("test").get("doc"));
+
+        client().prepareIndex().setIndex("test").setType("doc").setId("1").setSource(jsonBuilder().startObject().field("a", "string").field("z", 0).endObject()).get();
+        client().admin().indices().prepareRefresh("test").get();
+        assertThat(client().prepareSearch("test").get().getHits().getTotalHits(), equalTo(1l));
+
+        // both fields should be in local mapper
+        DocumentMapper mapper = indexService.mapperService().documentMapper("doc");
+        assertNotNull(mapper.mappers().name("a"));
+        assertNotNull(mapper.mappers().name("z"));
+
+        // both fields should be in the cluster state
+        getMappingsResponse = client().admin().indices().prepareGetMappings("test").get();
+        assertNotNull(getMappingsResponse.getMappings().get("test").get("doc"));
+        Map<String, Object> mappings = getMappingsResponse.getMappings().get("test").get("doc").getSourceAsMap();
+        assertNotNull(((LinkedHashMap) mappings.get("properties")).get("a"));
+        assertNotNull(((LinkedHashMap) mappings.get("properties")).get("z"));
+    }
 }
\ No newline at end of file
