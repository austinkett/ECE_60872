diff --git a/src/main/java/org/elasticsearch/action/ActionModule.java b/src/main/java/org/elasticsearch/action/ActionModule.java
index 28753d7c39b4..8ef29d61ef40 100644
--- a/src/main/java/org/elasticsearch/action/ActionModule.java
+++ b/src/main/java/org/elasticsearch/action/ActionModule.java
@@ -84,10 +84,7 @@
 import org.elasticsearch.action.admin.indices.gateway.snapshot.TransportGatewaySnapshotAction;
 import org.elasticsearch.action.admin.indices.mapping.delete.DeleteMappingAction;
 import org.elasticsearch.action.admin.indices.mapping.delete.TransportDeleteMappingAction;
-import org.elasticsearch.action.admin.indices.mapping.get.GetFieldMappingsAction;
-import org.elasticsearch.action.admin.indices.mapping.get.GetMappingsAction;
-import org.elasticsearch.action.admin.indices.mapping.get.TransportGetFieldMappingsAction;
-import org.elasticsearch.action.admin.indices.mapping.get.TransportGetMappingsAction;
+import org.elasticsearch.action.admin.indices.mapping.get.*;
 import org.elasticsearch.action.admin.indices.mapping.put.PutMappingAction;
 import org.elasticsearch.action.admin.indices.mapping.put.TransportPutMappingAction;
 import org.elasticsearch.action.admin.indices.open.OpenIndexAction;
@@ -228,7 +225,7 @@ protected void configure() {
         registerAction(IndicesExistsAction.INSTANCE, TransportIndicesExistsAction.class);
         registerAction(TypesExistsAction.INSTANCE, TransportTypesExistsAction.class);
         registerAction(GetMappingsAction.INSTANCE, TransportGetMappingsAction.class);
-        registerAction(GetFieldMappingsAction.INSTANCE, TransportGetFieldMappingsAction.class);
+        registerAction(GetFieldMappingsAction.INSTANCE, TransportGetFieldMappingsAction.class, TransportGetFieldMappingsIndexAction.class);
         registerAction(PutMappingAction.INSTANCE, TransportPutMappingAction.class);
         registerAction(DeleteMappingAction.INSTANCE, TransportDeleteMappingAction.class);
         registerAction(IndicesAliasesAction.INSTANCE, TransportIndicesAliasesAction.class);
diff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsIndexRequest.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsIndexRequest.java
new file mode 100644
index 000000000000..d9974f734370
--- /dev/null
+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsIndexRequest.java
@@ -0,0 +1,101 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.action.admin.indices.mapping.get;
+
+import org.elasticsearch.action.ActionRequestValidationException;
+import org.elasticsearch.action.support.single.custom.SingleCustomOperationRequest;
+import org.elasticsearch.common.Strings;
+import org.elasticsearch.common.io.stream.StreamInput;
+import org.elasticsearch.common.io.stream.StreamOutput;
+
+import java.io.IOException;
+
+class GetFieldMappingsIndexRequest extends SingleCustomOperationRequest<GetFieldMappingsIndexRequest> {
+
+    private String index;
+
+    private boolean probablySingleFieldRequest;
+    private boolean includeDefaults;
+    private String[] fields = Strings.EMPTY_ARRAY;
+    private String[] types = Strings.EMPTY_ARRAY;
+
+    GetFieldMappingsIndexRequest() {
+    }
+
+    GetFieldMappingsIndexRequest(GetFieldMappingsRequest other, String index, boolean probablySingleFieldRequest) {
+        this.preferLocal(other.local);
+        this.probablySingleFieldRequest = probablySingleFieldRequest;
+        this.includeDefaults = other.includeDefaults();
+        this.types = other.types();
+        this.fields = other.fields();
+        this.index = index;
+    }
+
+    public String index() {
+        return index;
+    }
+
+    public String[] types() {
+        return types;
+    }
+
+    public String[] fields() {
+        return fields;
+    }
+
+    public boolean probablySingleFieldRequest() {
+        return probablySingleFieldRequest;
+    }
+
+    public boolean includeDefaults() {
+        return includeDefaults;
+    }
+
+    /** Indicates whether default mapping settings should be returned */
+    public GetFieldMappingsIndexRequest includeDefaults(boolean includeDefaults) {
+        this.includeDefaults = includeDefaults;
+        return this;
+    }
+
+    @Override
+    public ActionRequestValidationException validate() {
+        return null;
+    }
+
+    @Override
+    public void writeTo(StreamOutput out) throws IOException {
+        super.writeTo(out);
+        out.writeString(index);
+        out.writeStringArray(types);
+        out.writeStringArray(fields);
+        out.writeBoolean(includeDefaults);
+        out.writeBoolean(probablySingleFieldRequest);
+    }
+
+    @Override
+    public void readFrom(StreamInput in) throws IOException {
+        super.readFrom(in);
+        index = in.readString();
+        types = in.readStringArray();
+        fields = in.readStringArray();
+        includeDefaults = in.readBoolean();
+        probablySingleFieldRequest = in.readBoolean();
+    }
+}
diff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsRequest.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsRequest.java
index 63cafa680432..fd0ce4f32983 100644
--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsRequest.java
+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsRequest.java
@@ -19,21 +19,85 @@
 
 package org.elasticsearch.action.admin.indices.mapping.get;
 
+import org.elasticsearch.Version;
+import org.elasticsearch.action.ActionRequest;
 import org.elasticsearch.action.ActionRequestValidationException;
-import org.elasticsearch.action.support.master.info.ClusterInfoRequest;
+import org.elasticsearch.action.support.IndicesOptions;
+import org.elasticsearch.action.support.master.MasterNodeOperationRequest;
 import org.elasticsearch.common.Strings;
 import org.elasticsearch.common.io.stream.StreamInput;
 import org.elasticsearch.common.io.stream.StreamOutput;
+import org.elasticsearch.common.unit.TimeValue;
 
 import java.io.IOException;
 
 /** Request the mappings of specific fields */
-public class GetFieldMappingsRequest extends ClusterInfoRequest<GetFieldMappingsRequest> {
+public class GetFieldMappingsRequest extends ActionRequest<GetFieldMappingsRequest> {
+
+    protected boolean local = false;
 
     private String[] fields = Strings.EMPTY_ARRAY;
 
     private boolean includeDefaults = false;
 
+    private String[] indices = Strings.EMPTY_ARRAY;
+    private String[] types = Strings.EMPTY_ARRAY;
+
+    private IndicesOptions indicesOptions = IndicesOptions.strict();
+
+    public GetFieldMappingsRequest() {
+
+    }
+
+    public GetFieldMappingsRequest(GetFieldMappingsRequest other) {
+        this.local = other.local;
+        this.includeDefaults = other.includeDefaults;
+        this.indices = other.indices;
+        this.types = other.types;
+        this.indicesOptions = other.indicesOptions;
+        this.fields = other.fields;
+    }
+
+    /**
+     * Indicate whether the receiving node should operate based on local index information or forward requests,
+     * where needed, to other nodes. If running locally, request will not raise errors if running locally & missing indices.
+     */
+    public GetFieldMappingsRequest local(boolean local) {
+        this.local = local;
+        return this;
+    }
+
+    public boolean local() {
+        return local;
+    }
+
+    public GetFieldMappingsRequest indices(String... indices) {
+        this.indices = indices;
+        return this;
+    }
+
+    public GetFieldMappingsRequest types(String... types) {
+        this.types = types;
+        return this;
+    }
+
+    public GetFieldMappingsRequest indicesOptions(IndicesOptions indicesOptions) {
+        this.indicesOptions = indicesOptions;
+        return this;
+    }
+
+    public String[] indices() {
+        return indices;
+    }
+
+    public String[] types() {
+        return types;
+    }
+
+    public IndicesOptions indicesOptions() {
+        return indicesOptions;
+    }
+
     /** @param fields a list of fields to retrieve the mapping for */
     public GetFieldMappingsRequest fields(String... fields) {
         this.fields = fields;
@@ -62,6 +126,14 @@ public ActionRequestValidationException validate() {
     @Override
     public void writeTo(StreamOutput out) throws IOException {
         super.writeTo(out);
+        if (out.getVersion().onOrBefore(Version.V_1_0_0)) {
+            // This request used to inherit from MasterNodeOperationRequest
+            MasterNodeOperationRequest.DEFAULT_MASTER_NODE_TIMEOUT.writeTo(out);
+        }
+        out.writeStringArray(indices);
+        out.writeStringArray(types);
+        indicesOptions.writeIndicesOptions(out);
+        out.writeBoolean(local);
         out.writeStringArray(fields);
         out.writeBoolean(includeDefaults);
     }
@@ -69,6 +141,14 @@ public void writeTo(StreamOutput out) throws IOException {
     @Override
     public void readFrom(StreamInput in) throws IOException {
         super.readFrom(in);
+        if (in.getVersion().onOrBefore(Version.V_1_0_0)) {
+            // This request used to inherit from MasterNodeOperationRequest
+            TimeValue.readTimeValue(in);
+        }
+        indices = in.readStringArray();
+        types = in.readStringArray();
+        indicesOptions = IndicesOptions.readIndicesOptions(in);
+        local = in.readBoolean();
         fields = in.readStringArray();
         includeDefaults = in.readBoolean();
     }
diff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsRequestBuilder.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsRequestBuilder.java
index 3b831ac7513b..955a98437073 100644
--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsRequestBuilder.java
+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/GetFieldMappingsRequestBuilder.java
@@ -19,18 +19,45 @@
 
 package org.elasticsearch.action.admin.indices.mapping.get;
 
+import com.google.common.collect.ObjectArrays;
 import org.elasticsearch.action.ActionListener;
-import org.elasticsearch.action.support.master.info.ClusterInfoRequestBuilder;
+import org.elasticsearch.action.ActionRequestBuilder;
+import org.elasticsearch.action.support.IndicesOptions;
 import org.elasticsearch.client.IndicesAdminClient;
 import org.elasticsearch.client.internal.InternalGenericClient;
 
 /** A helper class to build {@link GetFieldMappingsRequest} objects */
-public class GetFieldMappingsRequestBuilder extends ClusterInfoRequestBuilder<GetFieldMappingsRequest, GetFieldMappingsResponse, GetFieldMappingsRequestBuilder> {
+public class GetFieldMappingsRequestBuilder extends ActionRequestBuilder<GetFieldMappingsRequest, GetFieldMappingsResponse, GetFieldMappingsRequestBuilder> {
 
     public GetFieldMappingsRequestBuilder(InternalGenericClient client, String... indices) {
         super(client, new GetFieldMappingsRequest().indices(indices));
     }
 
+    public GetFieldMappingsRequestBuilder setIndices(String... indices) {
+        request.indices(indices);
+        return this;
+    }
+
+    public GetFieldMappingsRequestBuilder addIndices(String... indices) {
+        request.indices(ObjectArrays.concat(request.indices(), indices, String.class));
+        return this;
+    }
+
+    public GetFieldMappingsRequestBuilder setTypes(String... types) {
+        request.types(types);
+        return this;
+    }
+
+    public GetFieldMappingsRequestBuilder addTypes(String... types) {
+        request.types(ObjectArrays.concat(request.types(), types, String.class));
+        return this;
+    }
+
+    public GetFieldMappingsRequestBuilder setIndicesOptions(IndicesOptions indicesOptions) {
+        request.indicesOptions(indicesOptions);
+        return this;
+    }
+
 
     /** Sets the fields to retrieve. */
     public GetFieldMappingsRequestBuilder setFields(String... fields) {
diff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsAction.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsAction.java
index f52d5f50e9bf..a0d30791dc6f 100644
--- a/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsAction.java
+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsAction.java
@@ -19,225 +19,124 @@
 
 package org.elasticsearch.action.admin.indices.mapping.get;
 
-import com.google.common.base.Predicate;
-import com.google.common.collect.Collections2;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Sets;
-import org.elasticsearch.ElasticsearchException;
 import org.elasticsearch.action.ActionListener;
-import org.elasticsearch.action.admin.indices.mapping.get.GetFieldMappingsResponse.FieldMappingMetaData;
-import org.elasticsearch.action.support.master.info.TransportClusterInfoAction;
+import org.elasticsearch.action.support.TransportAction;
 import org.elasticsearch.cluster.ClusterService;
 import org.elasticsearch.cluster.ClusterState;
 import org.elasticsearch.common.collect.MapBuilder;
 import org.elasticsearch.common.inject.Inject;
-import org.elasticsearch.common.regex.Regex;
 import org.elasticsearch.common.settings.Settings;
-import org.elasticsearch.common.xcontent.ToXContent;
-import org.elasticsearch.common.xcontent.XContentBuilder;
-import org.elasticsearch.common.xcontent.XContentFactory;
-import org.elasticsearch.common.xcontent.XContentType;
-import org.elasticsearch.index.mapper.DocumentMapper;
-import org.elasticsearch.index.mapper.FieldMapper;
-import org.elasticsearch.index.service.IndexService;
-import org.elasticsearch.indices.IndicesService;
 import org.elasticsearch.threadpool.ThreadPool;
+import org.elasticsearch.transport.BaseTransportRequestHandler;
+import org.elasticsearch.transport.TransportChannel;
 import org.elasticsearch.transport.TransportService;
 
-import java.io.IOException;
-import java.util.Collection;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReferenceArray;
 
 /**
  */
-public class TransportGetFieldMappingsAction extends TransportClusterInfoAction<GetFieldMappingsRequest, GetFieldMappingsResponse> {
+public class TransportGetFieldMappingsAction extends TransportAction<GetFieldMappingsRequest, GetFieldMappingsResponse> {
 
-    private final IndicesService indicesService;
+    private final ClusterService clusterService;
+    private final TransportGetFieldMappingsIndexAction shardAction;
+    private final String transportAction;
 
     @Inject
-    public TransportGetFieldMappingsAction(Settings settings, TransportService transportService, ClusterService clusterService,
-                                           IndicesService indicesService, ThreadPool threadPool) {
-        super(settings, transportService, clusterService, threadPool);
-        this.indicesService = indicesService;
+    public TransportGetFieldMappingsAction(Settings settings, TransportService transportService, ClusterService clusterService, ThreadPool threadPool, TransportGetFieldMappingsIndexAction shardAction) {
+        super(settings, threadPool);
+        this.clusterService = clusterService;
+        this.shardAction = shardAction;
+        this.transportAction = GetFieldMappingsAction.NAME;
+        transportService.registerHandler(transportAction, new TransportHandler());
     }
 
     @Override
-    protected String transportAction() {
-        return GetFieldMappingsAction.NAME;
-    }
-
-    @Override
-    protected GetFieldMappingsRequest newRequest() {
-        return new GetFieldMappingsRequest();
-    }
-
-    @Override
-    protected GetFieldMappingsResponse newResponse() {
-        return new GetFieldMappingsResponse();
-    }
-
-    @Override
-    protected void doMasterOperation(final GetFieldMappingsRequest request, final ClusterState state, final ActionListener<GetFieldMappingsResponse> listener) throws ElasticsearchException {
-
-        listener.onResponse(new GetFieldMappingsResponse(findMappings(request.indices(), request.types(), request.fields(), request.includeDefaults())));
-    }
-
-    private ImmutableMap<String, ImmutableMap<String, ImmutableMap<String, FieldMappingMetaData>>> findMappings(String[] concreteIndices,
-                                                                                                                final String[] types,
-                                                                                                                final String[] fields,
-                                                                                                                boolean includeDefaults) {
-        assert types != null;
-        assert concreteIndices != null;
-        if (concreteIndices.length == 0) {
-            return ImmutableMap.of();
-        }
-
-        boolean isProbablySingleFieldRequest = concreteIndices.length == 1 && types.length == 1 && fields.length == 1;
-        ImmutableMap.Builder<String, ImmutableMap<String, ImmutableMap<String, FieldMappingMetaData>>> indexMapBuilder = ImmutableMap.builder();
-        Sets.SetView<String> intersection = Sets.intersection(Sets.newHashSet(concreteIndices), indicesService.indices());
-        for (String index : intersection) {
-            IndexService indexService = indicesService.indexService(index);
-            Collection<String> typeIntersection;
-            if (types.length == 0) {
-                typeIntersection = indexService.mapperService().types();
-
-            } else {
-                typeIntersection = Collections2.filter(indexService.mapperService().types(), new Predicate<String>() {
-
+    protected void doExecute(GetFieldMappingsRequest request, final ActionListener<GetFieldMappingsResponse> listener) {
+        ClusterState clusterState = clusterService.state();
+        String[] concreteIndices = clusterState.metaData().concreteIndices(request.indices(), request.indicesOptions());
+        final AtomicInteger indexCounter = new AtomicInteger();
+        final AtomicInteger completionCounter = new AtomicInteger(concreteIndices.length);
+        final AtomicReferenceArray<Object> indexResponses = new AtomicReferenceArray<Object>(concreteIndices.length);
+
+        if (concreteIndices == null || concreteIndices.length == 0) {
+            listener.onResponse(new GetFieldMappingsResponse());
+        } else {
+            boolean probablySingleFieldRequest = concreteIndices.length == 1 && request.types().length == 1 && request.fields().length == 1;
+            for (final String index : concreteIndices) {
+                GetFieldMappingsIndexRequest shardRequest = new GetFieldMappingsIndexRequest(request, index, probablySingleFieldRequest);
+                // no threading needed, all is done on the index replication one
+                shardRequest.listenerThreaded(false);
+                shardAction.execute(shardRequest, new ActionListener<GetFieldMappingsResponse>() {
                     @Override
-                    public boolean apply(String type) {
-                        return Regex.simpleMatch(types, type);
+                    public void onResponse(GetFieldMappingsResponse result) {
+                        indexResponses.set(indexCounter.getAndIncrement(), result);
+                        if (completionCounter.decrementAndGet() == 0) {
+                            listener.onResponse(merge(indexResponses));
+                        }
                     }
 
+                    @Override
+                    public void onFailure(Throwable e) {
+                        int index = indexCounter.getAndIncrement();
+                        indexResponses.set(index, e);
+                        if (completionCounter.decrementAndGet() == 0) {
+                            listener.onResponse(merge(indexResponses));
+                        }
+                    }
                 });
             }
+        }
+    }
 
-            MapBuilder<String, ImmutableMap<String, FieldMappingMetaData>> typeMappings = new MapBuilder<String, ImmutableMap<String, FieldMappingMetaData>>();
-            for (String type : typeIntersection) {
-                DocumentMapper documentMapper = indexService.mapperService().documentMapper(type);
-                ImmutableMap<String, FieldMappingMetaData> fieldMapping = findFieldMappingsByType(documentMapper, fields, includeDefaults, isProbablySingleFieldRequest);
-                if (!fieldMapping.isEmpty()) {
-                    typeMappings.put(type, fieldMapping);
-                }
-            }
-
-            if (!typeMappings.isEmpty()) {
-                indexMapBuilder.put(index, typeMappings.immutableMap());
+    private GetFieldMappingsResponse merge(AtomicReferenceArray<Object> indexResponses) {
+        MapBuilder<String, ImmutableMap<String, ImmutableMap<String, GetFieldMappingsResponse.FieldMappingMetaData>>> mergedResponses = MapBuilder.newMapBuilder();
+        for (int i = 0; i < indexResponses.length(); i++) {
+            Object element = indexResponses.get(i);
+            if (element instanceof GetFieldMappingsResponse) {
+                GetFieldMappingsResponse response = (GetFieldMappingsResponse) element;
+                mergedResponses.putAll(response.mappings());
             }
         }
-
-        return indexMapBuilder.build();
+        return new GetFieldMappingsResponse(mergedResponses.immutableMap());
     }
 
-    private static final ToXContent.Params includeDefaultsParams = new ToXContent.Params() {
-
-        final static String INCLUDE_DEFAULTS = "include_defaults";
+    private class TransportHandler extends BaseTransportRequestHandler<GetFieldMappingsRequest> {
 
         @Override
-        public String param(String key) {
-            if (INCLUDE_DEFAULTS.equals(key)) {
-                return "true";
-            }
-            return null;
+        public GetFieldMappingsRequest newInstance() {
+            return new GetFieldMappingsRequest();
         }
 
         @Override
-        public String param(String key, String defaultValue) {
-            if (INCLUDE_DEFAULTS.equals(key)) {
-                return "true";
-            }
-            return defaultValue;
+        public String executor() {
+            return ThreadPool.Names.SAME;
         }
 
         @Override
-        public boolean paramAsBoolean(String key, boolean defaultValue) {
-            if (INCLUDE_DEFAULTS.equals(key)) {
-                return true;
-            }
-            return defaultValue;
-        }
-
-        public Boolean paramAsBoolean(String key, Boolean defaultValue) {
-            if (INCLUDE_DEFAULTS.equals(key)) {
-                return true;
-            }
-            return defaultValue;
-        }
-
-        @Override @Deprecated
-        public Boolean paramAsBooleanOptional(String key, Boolean defaultValue) {
-            return paramAsBoolean(key, defaultValue);
-        }
-    };
-
-    private ImmutableMap<String, FieldMappingMetaData> findFieldMappingsByType(DocumentMapper documentMapper, String[] fields,
-                                                                               boolean includeDefaults, boolean isProbablySingleFieldRequest) throws ElasticsearchException {
-        MapBuilder<String, FieldMappingMetaData> fieldMappings = new MapBuilder<String, FieldMappingMetaData>();
-        ImmutableList<FieldMapper> allFieldMappers = documentMapper.mappers().mappers();
-        for (String field : fields) {
-            if (Regex.isMatchAllPattern(field)) {
-                for (FieldMapper fieldMapper : allFieldMappers) {
-                    addFieldMapper(fieldMapper.names().fullName(), fieldMapper, fieldMappings, includeDefaults);
-                }
-            } else if (Regex.isSimpleMatchPattern(field)) {
-                // go through the field mappers 3 times, to make sure we give preference to the resolve order: full name, index name, name.
-                // also make sure we only store each mapper once.
-                boolean[] resolved = new boolean[allFieldMappers.size()];
-                for (int i = 0; i < allFieldMappers.size(); i++) {
-                    FieldMapper fieldMapper = allFieldMappers.get(i);
-                    if (Regex.simpleMatch(field, fieldMapper.names().fullName())) {
-                        addFieldMapper(fieldMapper.names().fullName(), fieldMapper, fieldMappings, includeDefaults);
-                        resolved[i] = true;
-                    }
-                }
-                for (int i = 0; i < allFieldMappers.size(); i++) {
-                    if (resolved[i]) {
-                        continue;
-                    }
-                    FieldMapper fieldMapper = allFieldMappers.get(i);
-                    if (Regex.simpleMatch(field, fieldMapper.names().indexName())) {
-                        addFieldMapper(fieldMapper.names().indexName(), fieldMapper, fieldMappings, includeDefaults);
-                        resolved[i] = true;
-                    }
-                }
-                for (int i = 0; i < allFieldMappers.size(); i++) {
-                    if (resolved[i]) {
-                        continue;
-                    }
-                    FieldMapper fieldMapper = allFieldMappers.get(i);
-                    if (Regex.simpleMatch(field, fieldMapper.names().name())) {
-                        addFieldMapper(fieldMapper.names().name(), fieldMapper, fieldMappings, includeDefaults);
-                        resolved[i] = true;
+        public void messageReceived(final GetFieldMappingsRequest request, final TransportChannel channel) throws Exception {
+            // no need for a threaded listener, since we just send a response
+            request.listenerThreaded(false);
+            execute(request, new ActionListener<GetFieldMappingsResponse>() {
+                @Override
+                public void onResponse(GetFieldMappingsResponse result) {
+                    try {
+                        channel.sendResponse(result);
+                    } catch (Throwable e) {
+                        onFailure(e);
                     }
                 }
 
-            } else {
-                // not a pattern
-                FieldMapper fieldMapper = documentMapper.mappers().smartNameFieldMapper(field);
-                if (fieldMapper != null) {
-                    addFieldMapper(field, fieldMapper, fieldMappings, includeDefaults);
-                } else if (isProbablySingleFieldRequest) {
-                    fieldMappings.put(field, FieldMappingMetaData.NULL);
+                @Override
+                public void onFailure(Throwable e) {
+                    try {
+                        channel.sendResponse(e);
+                    } catch (Exception e1) {
+                        logger.warn("Failed to send error response for action [" + transportAction + "] and request [" + request + "]", e1);
+                    }
                 }
-            }
+            });
         }
-        return fieldMappings.immutableMap();
     }
-
-    private void addFieldMapper(String field, FieldMapper fieldMapper, MapBuilder<String, FieldMappingMetaData> fieldMappings, boolean includeDefaults) {
-        if (fieldMappings.containsKey(field)) {
-            return;
-        }
-        try {
-            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);
-            builder.startObject();
-            fieldMapper.toXContent(builder, includeDefaults ? includeDefaultsParams : ToXContent.EMPTY_PARAMS);
-            builder.endObject();
-            fieldMappings.put(field, new FieldMappingMetaData(fieldMapper.names().fullName(), builder.bytes()));
-        } catch (IOException e) {
-            throw new ElasticsearchException("failed to serialize XContent of field [" + field + "]", e);
-        }
-    }
-
-
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java
new file mode 100644
index 000000000000..e256b7447556
--- /dev/null
+++ b/src/main/java/org/elasticsearch/action/admin/indices/mapping/get/TransportGetFieldMappingsIndexAction.java
@@ -0,0 +1,250 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.action.admin.indices.mapping.get;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.Collections2;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import org.elasticsearch.ElasticsearchException;
+import org.elasticsearch.action.admin.indices.mapping.get.GetFieldMappingsResponse.FieldMappingMetaData;
+import org.elasticsearch.action.support.single.custom.TransportSingleCustomOperationAction;
+import org.elasticsearch.cluster.ClusterService;
+import org.elasticsearch.cluster.ClusterState;
+import org.elasticsearch.cluster.block.ClusterBlockException;
+import org.elasticsearch.cluster.block.ClusterBlockLevel;
+import org.elasticsearch.cluster.routing.ShardsIterator;
+import org.elasticsearch.common.collect.MapBuilder;
+import org.elasticsearch.common.inject.Inject;
+import org.elasticsearch.common.regex.Regex;
+import org.elasticsearch.common.settings.Settings;
+import org.elasticsearch.common.xcontent.ToXContent;
+import org.elasticsearch.common.xcontent.XContentBuilder;
+import org.elasticsearch.common.xcontent.XContentFactory;
+import org.elasticsearch.common.xcontent.XContentType;
+import org.elasticsearch.index.Index;
+import org.elasticsearch.index.mapper.DocumentMapper;
+import org.elasticsearch.index.mapper.FieldMapper;
+import org.elasticsearch.index.service.IndexService;
+import org.elasticsearch.indices.IndicesService;
+import org.elasticsearch.indices.TypeMissingException;
+import org.elasticsearch.threadpool.ThreadPool;
+import org.elasticsearch.transport.TransportService;
+
+import java.io.IOException;
+import java.util.Collection;
+
+/**
+ */
+public class TransportGetFieldMappingsIndexAction extends TransportSingleCustomOperationAction<GetFieldMappingsIndexRequest, GetFieldMappingsResponse> {
+
+    protected final ClusterService clusterService;
+    private final IndicesService indicesService;
+
+    @Inject
+    public TransportGetFieldMappingsIndexAction(Settings settings, ClusterService clusterService,
+                                                TransportService transportService,
+                                                IndicesService indicesService,
+                                                ThreadPool threadPool) {
+        super(settings, threadPool, clusterService, transportService);
+        this.clusterService = clusterService;
+        this.indicesService = indicesService;
+    }
+
+    @Override
+    protected String transportAction() {
+        return GetFieldMappingsAction.NAME + "/shard";
+    }
+
+    @Override
+    protected String executor() {
+        return ThreadPool.Names.MANAGEMENT;
+    }
+
+    @Override
+    protected ShardsIterator shards(ClusterState state, GetFieldMappingsIndexRequest request) {
+        // Will balance requests between shards
+        return state.routingTable().index(request.index()).randomAllActiveShardsIt();
+    }
+
+    @Override
+    protected GetFieldMappingsResponse shardOperation(final GetFieldMappingsIndexRequest request, int shardId) throws ElasticsearchException {
+        IndexService indexService = indicesService.indexServiceSafe(request.index());
+        Collection<String> typeIntersection;
+        if (request.types().length == 0) {
+            typeIntersection = indexService.mapperService().types();
+
+        } else {
+            typeIntersection = Collections2.filter(indexService.mapperService().types(), new Predicate<String>() {
+
+                @Override
+                public boolean apply(String type) {
+                    return Regex.simpleMatch(request.types(), type);
+                }
+
+            });
+            if (typeIntersection.isEmpty()) {
+                throw new TypeMissingException(new Index(request.index()), request.types());
+            }
+        }
+
+        MapBuilder<String, ImmutableMap<String, FieldMappingMetaData>> typeMappings = new MapBuilder<String, ImmutableMap<String, FieldMappingMetaData>>();
+        for (String type : typeIntersection) {
+            DocumentMapper documentMapper = indexService.mapperService().documentMapper(type);
+            ImmutableMap<String, FieldMappingMetaData> fieldMapping = findFieldMappingsByType(documentMapper, request);
+            if (!fieldMapping.isEmpty()) {
+                typeMappings.put(type, fieldMapping);
+            }
+        }
+
+        return new GetFieldMappingsResponse(ImmutableMap.of(request.index(), typeMappings.immutableMap()));
+    }
+
+    @Override
+    protected GetFieldMappingsIndexRequest newRequest() {
+        return new GetFieldMappingsIndexRequest();
+    }
+
+    @Override
+    protected GetFieldMappingsResponse newResponse() {
+        return new GetFieldMappingsResponse();
+    }
+
+    @Override
+    protected ClusterBlockException checkGlobalBlock(ClusterState state, GetFieldMappingsIndexRequest request) {
+        return state.blocks().globalBlockedException(ClusterBlockLevel.READ);
+    }
+
+    @Override
+    protected ClusterBlockException checkRequestBlock(ClusterState state, GetFieldMappingsIndexRequest request) {
+        return state.blocks().indexBlockedException(ClusterBlockLevel.READ, request.index());
+    }
+
+    private static final ToXContent.Params includeDefaultsParams = new ToXContent.Params() {
+
+        final static String INCLUDE_DEFAULTS = "include_defaults";
+
+        @Override
+        public String param(String key) {
+            if (INCLUDE_DEFAULTS.equals(key)) {
+                return "true";
+            }
+            return null;
+        }
+
+        @Override
+        public String param(String key, String defaultValue) {
+            if (INCLUDE_DEFAULTS.equals(key)) {
+                return "true";
+            }
+            return defaultValue;
+        }
+
+        @Override
+        public boolean paramAsBoolean(String key, boolean defaultValue) {
+            if (INCLUDE_DEFAULTS.equals(key)) {
+                return true;
+            }
+            return defaultValue;
+        }
+
+        public Boolean paramAsBoolean(String key, Boolean defaultValue) {
+            if (INCLUDE_DEFAULTS.equals(key)) {
+                return true;
+            }
+            return defaultValue;
+        }
+
+        @Override
+        @Deprecated
+        public Boolean paramAsBooleanOptional(String key, Boolean defaultValue) {
+            return paramAsBoolean(key, defaultValue);
+        }
+    };
+
+    private ImmutableMap<String, FieldMappingMetaData> findFieldMappingsByType(DocumentMapper documentMapper, GetFieldMappingsIndexRequest request) throws ElasticsearchException {
+        MapBuilder<String, FieldMappingMetaData> fieldMappings = new MapBuilder<String, FieldMappingMetaData>();
+        ImmutableList<FieldMapper> allFieldMappers = documentMapper.mappers().mappers();
+        for (String field : request.fields()) {
+            if (Regex.isMatchAllPattern(field)) {
+                for (FieldMapper fieldMapper : allFieldMappers) {
+                    addFieldMapper(fieldMapper.names().fullName(), fieldMapper, fieldMappings, request.includeDefaults());
+                }
+            } else if (Regex.isSimpleMatchPattern(field)) {
+                // go through the field mappers 3 times, to make sure we give preference to the resolve order: full name, index name, name.
+                // also make sure we only store each mapper once.
+                boolean[] resolved = new boolean[allFieldMappers.size()];
+                for (int i = 0; i < allFieldMappers.size(); i++) {
+                    FieldMapper fieldMapper = allFieldMappers.get(i);
+                    if (Regex.simpleMatch(field, fieldMapper.names().fullName())) {
+                        addFieldMapper(fieldMapper.names().fullName(), fieldMapper, fieldMappings, request.includeDefaults());
+                        resolved[i] = true;
+                    }
+                }
+                for (int i = 0; i < allFieldMappers.size(); i++) {
+                    if (resolved[i]) {
+                        continue;
+                    }
+                    FieldMapper fieldMapper = allFieldMappers.get(i);
+                    if (Regex.simpleMatch(field, fieldMapper.names().indexName())) {
+                        addFieldMapper(fieldMapper.names().indexName(), fieldMapper, fieldMappings, request.includeDefaults());
+                        resolved[i] = true;
+                    }
+                }
+                for (int i = 0; i < allFieldMappers.size(); i++) {
+                    if (resolved[i]) {
+                        continue;
+                    }
+                    FieldMapper fieldMapper = allFieldMappers.get(i);
+                    if (Regex.simpleMatch(field, fieldMapper.names().name())) {
+                        addFieldMapper(fieldMapper.names().name(), fieldMapper, fieldMappings, request.includeDefaults());
+                        resolved[i] = true;
+                    }
+                }
+
+            } else {
+                // not a pattern
+                FieldMapper fieldMapper = documentMapper.mappers().smartNameFieldMapper(field);
+                if (fieldMapper != null) {
+                    addFieldMapper(field, fieldMapper, fieldMappings, request.includeDefaults());
+                } else if (request.probablySingleFieldRequest()) {
+                    fieldMappings.put(field, FieldMappingMetaData.NULL);
+                }
+            }
+        }
+        return fieldMappings.immutableMap();
+    }
+
+    private void addFieldMapper(String field, FieldMapper fieldMapper, MapBuilder<String, FieldMappingMetaData> fieldMappings, boolean includeDefaults) {
+        if (fieldMappings.containsKey(field)) {
+            return;
+        }
+        try {
+            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);
+            builder.startObject();
+            fieldMapper.toXContent(builder, includeDefaults ? includeDefaultsParams : ToXContent.EMPTY_PARAMS);
+            builder.endObject();
+            fieldMappings.put(field, new FieldMappingMetaData(fieldMapper.names().fullName(), builder.bytes()));
+        } catch (IOException e) {
+            throw new ElasticsearchException("failed to serialize XContent of field [" + field + "]", e);
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/elasticsearch/indices/mapping/DedicatedMasterGetFieldMappingTests.java b/src/test/java/org/elasticsearch/indices/mapping/DedicatedMasterGetFieldMappingTests.java
new file mode 100644
index 000000000000..bdac39d132cd
--- /dev/null
+++ b/src/test/java/org/elasticsearch/indices/mapping/DedicatedMasterGetFieldMappingTests.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.indices.mapping;
+
+import org.apache.lucene.util.LuceneTestCase;
+import org.elasticsearch.common.settings.ImmutableSettings;
+import org.elasticsearch.common.settings.Settings;
+import org.elasticsearch.test.ElasticsearchIntegrationTest;
+import org.junit.Before;
+
+import static org.elasticsearch.common.settings.ImmutableSettings.settingsBuilder;
+
+/**
+ */
+@LuceneTestCase.Slow
+@ElasticsearchIntegrationTest.ClusterScope(scope = ElasticsearchIntegrationTest.Scope.TEST, numNodes = 0)
+public class DedicatedMasterGetFieldMappingTests extends SimpleGetFieldMappingsTests {
+
+    @Before
+    public void before1() {
+        Settings settings = settingsBuilder()
+                .put("node.data", false)
+                .build();
+        cluster().startNode(settings);
+        cluster().startNode(ImmutableSettings.EMPTY);
+    }
+
+}
diff --git a/src/test/java/org/elasticsearch/indices/mapping/SimpleGetFieldMappingsTests.java b/src/test/java/org/elasticsearch/indices/mapping/SimpleGetFieldMappingsTests.java
index e0cc9d12ab8b..8b25ee958885 100644
--- a/src/test/java/org/elasticsearch/indices/mapping/SimpleGetFieldMappingsTests.java
+++ b/src/test/java/org/elasticsearch/indices/mapping/SimpleGetFieldMappingsTests.java
@@ -22,6 +22,8 @@
 import com.google.common.base.Predicate;
 import org.elasticsearch.action.admin.indices.mapping.get.GetFieldMappingsResponse;
 import org.elasticsearch.common.Nullable;
+import org.elasticsearch.common.settings.ImmutableSettings;
+import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.xcontent.XContentBuilder;
 import org.elasticsearch.test.ElasticsearchIntegrationTest;
 import org.hamcrest.Matchers;
@@ -41,8 +43,10 @@
     @Test
     public void getMappingsWhereThereAreNone() {
         createIndex("index");
+        ensureYellow();
         GetFieldMappingsResponse response = client().admin().indices().prepareGetFieldMappings().get();
-        assertThat(response.mappings().size(), equalTo(0));
+        assertThat(response.mappings().size(), equalTo(1));
+        assertThat(response.mappings().get("index").size(), equalTo(0));
 
         assertThat(response.fieldMappings("index", "type", "field"), Matchers.nullValue());
     }
@@ -57,16 +61,22 @@ private XContentBuilder getMappingForType(String type) throws IOException {
     @Test
     public void simpleGetFieldMappings() throws Exception {
 
-
+        Settings.Builder settings = ImmutableSettings.settingsBuilder()
+                .put("number_of_shards", randomIntBetween(1, 3), "number_of_replicas", randomIntBetween(0, 1));
+        
         assertTrue(client().admin().indices().prepareCreate("indexa")
                 .addMapping("typeA", getMappingForType("typeA"))
                 .addMapping("typeB", getMappingForType("typeB"))
+                .setSettings(settings)
                 .get().isAcknowledged());
         assertTrue(client().admin().indices().prepareCreate("indexb")
                 .addMapping("typeA", getMappingForType("typeA"))
                 .addMapping("typeB", getMappingForType("typeB"))
+                .setSettings(settings)
                 .get().isAcknowledged());
 
+        ensureYellow();
+
         // Get mappings by full name
         GetFieldMappingsResponse response = client().admin().indices().prepareGetFieldMappings("indexa").setTypes("typeA").setFields("field1", "obj.subfield").get();
         assertThat(response.fieldMappings("indexa", "typeA", "field1").fullName(), equalTo("field1"));
