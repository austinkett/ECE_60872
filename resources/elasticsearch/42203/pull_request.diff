diff --git a/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpResponse.java b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpResponse.java
index 68c1d3127809..b6f16ef63e60 100644
--- a/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpResponse.java
+++ b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpResponse.java
@@ -27,15 +27,24 @@
 import org.elasticsearch.rest.RestStatus;
 import org.elasticsearch.transport.netty4.Netty4Utils;
 
+import java.util.List;
+
 public class Netty4HttpResponse extends DefaultFullHttpResponse implements HttpResponse, HttpPipelinedMessage {
 
     private final int sequence;
     private final Netty4HttpRequest request;
+    private final RestStatus status;
 
     Netty4HttpResponse(Netty4HttpRequest request, RestStatus status, BytesReference content) {
         super(request.nettyRequest().protocolVersion(), HttpResponseStatus.valueOf(status.getStatus()), Netty4Utils.toByteBuf(content));
         this.sequence = request.sequence();
         this.request = request;
+        this.status = status;
+    }
+
+    @Override
+    public RestStatus getRestStatus() {
+        return status;
     }
 
     @Override
@@ -43,6 +52,11 @@ public void addHeader(String name, String value) {
         headers().add(name, value);
     }
 
+    @Override
+    public List<String> getAllHeaders(String name) {
+        return headers().getAll(name);
+    }
+
     @Override
     public boolean containsHeader(String name) {
         return headers().contains(name);
diff --git a/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java
index 5602aaba912d..17450be49c9a 100644
--- a/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java
+++ b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/Netty4HttpServerTransport.java
@@ -34,7 +34,6 @@
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.http.HttpContentCompressor;
 import io.netty.handler.codec.http.HttpContentDecompressor;
-import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpObjectAggregator;
 import io.netty.handler.codec.http.HttpRequestDecoder;
 import io.netty.handler.codec.http.HttpResponseEncoder;
@@ -44,12 +43,10 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.elasticsearch.ExceptionsHelper;
-import org.elasticsearch.common.Strings;
 import org.elasticsearch.common.network.NetworkService;
 import org.elasticsearch.common.settings.Setting;
 import org.elasticsearch.common.settings.Setting.Property;
 import org.elasticsearch.common.settings.Settings;
-import org.elasticsearch.common.settings.SettingsException;
 import org.elasticsearch.common.unit.ByteSizeUnit;
 import org.elasticsearch.common.unit.ByteSizeValue;
 import org.elasticsearch.common.util.BigArrays;
@@ -60,26 +57,13 @@
 import org.elasticsearch.http.HttpHandlingSettings;
 import org.elasticsearch.http.HttpReadTimeoutException;
 import org.elasticsearch.http.HttpServerChannel;
-import org.elasticsearch.http.netty4.cors.Netty4CorsConfig;
-import org.elasticsearch.http.netty4.cors.Netty4CorsConfigBuilder;
-import org.elasticsearch.http.netty4.cors.Netty4CorsHandler;
-import org.elasticsearch.rest.RestUtils;
 import org.elasticsearch.threadpool.ThreadPool;
 import org.elasticsearch.transport.netty4.Netty4Utils;
 
 import java.net.InetSocketAddress;
-import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
-import java.util.regex.Pattern;
-import java.util.regex.PatternSyntaxException;
 
 import static org.elasticsearch.common.util.concurrent.EsExecutors.daemonThreadFactory;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_CREDENTIALS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_HEADERS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_METHODS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_ORIGIN;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ENABLED;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_MAX_AGE;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_MAX_CHUNK_SIZE;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_MAX_CONTENT_LENGTH;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_MAX_HEADER_SIZE;
@@ -91,7 +75,6 @@
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_TCP_REUSE_ADDRESS;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_TCP_SEND_BUFFER_SIZE;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_PIPELINING_MAX_EVENTS;
-import static org.elasticsearch.http.netty4.cors.Netty4CorsHandler.ANY_ORIGIN;
 
 public class Netty4HttpServerTransport extends AbstractHttpServerTransport {
     private static final Logger logger = LogManager.getLogger(Netty4HttpServerTransport.class);
@@ -156,8 +139,6 @@
 
     protected volatile ServerBootstrap serverBootstrap;
 
-    private final Netty4CorsConfig corsConfig;
-
     public Netty4HttpServerTransport(Settings settings, NetworkService networkService, BigArrays bigArrays, ThreadPool threadPool,
                                      NamedXContentRegistry xContentRegistry, Dispatcher dispatcher) {
         super(settings, networkService, bigArrays, threadPool, xContentRegistry, dispatcher);
@@ -176,8 +157,6 @@ public Netty4HttpServerTransport(Settings settings, NetworkService networkServic
         ByteSizeValue receivePredictor = SETTING_HTTP_NETTY_RECEIVE_PREDICTOR_SIZE.get(settings);
         recvByteBufAllocator = new FixedRecvByteBufAllocator(receivePredictor.bytesAsInt());
 
-        this.corsConfig = buildCorsConfig(settings);
-
         logger.debug("using max_chunk_size[{}], max_header_size[{}], max_initial_line_length[{}], max_content_length[{}], " +
                 "receive_predictor[{}], max_composite_buffer_components[{}], pipelining_max_events[{}]",
             maxChunkSize, maxHeaderSize, maxInitialLineLength, maxContentLength, receivePredictor, maxCompositeBufferComponents,
@@ -230,43 +209,6 @@ protected void doStart() {
         }
     }
 
-    // package private for testing
-    static Netty4CorsConfig buildCorsConfig(Settings settings) {
-        if (SETTING_CORS_ENABLED.get(settings) == false) {
-            return Netty4CorsConfigBuilder.forOrigins().disable().build();
-        }
-        String origin = SETTING_CORS_ALLOW_ORIGIN.get(settings);
-        final Netty4CorsConfigBuilder builder;
-        if (Strings.isNullOrEmpty(origin)) {
-            builder = Netty4CorsConfigBuilder.forOrigins();
-        } else if (origin.equals(ANY_ORIGIN)) {
-            builder = Netty4CorsConfigBuilder.forAnyOrigin();
-        } else {
-            try {
-                Pattern p = RestUtils.checkCorsSettingForRegex(origin);
-                if (p == null) {
-                    builder = Netty4CorsConfigBuilder.forOrigins(RestUtils.corsSettingAsArray(origin));
-                } else {
-                    builder = Netty4CorsConfigBuilder.forPattern(p);
-                }
-            } catch (PatternSyntaxException e) {
-                throw new SettingsException("Bad regex in [" + SETTING_CORS_ALLOW_ORIGIN.getKey() + "]: [" + origin + "]", e);
-            }
-        }
-        if (SETTING_CORS_ALLOW_CREDENTIALS.get(settings)) {
-            builder.allowCredentials();
-        }
-        String[] strMethods = Strings.tokenizeToStringArray(SETTING_CORS_ALLOW_METHODS.get(settings), ",");
-        HttpMethod[] methods = Arrays.stream(strMethods)
-            .map(HttpMethod::valueOf)
-            .toArray(HttpMethod[]::new);
-        return builder.allowedRequestMethods(methods)
-            .maxAge(SETTING_CORS_MAX_AGE.get(settings))
-            .allowedRequestHeaders(Strings.tokenizeToStringArray(SETTING_CORS_ALLOW_HEADERS.get(settings), ","))
-            .shortCircuit()
-            .build();
-    }
-
     @Override
     protected HttpServerChannel bind(InetSocketAddress socketAddress) throws Exception {
         ChannelFuture future = serverBootstrap.bind(socketAddress).sync();
@@ -331,9 +273,6 @@ protected void initChannel(Channel ch) throws Exception {
             if (handlingSettings.isCompression()) {
                 ch.pipeline().addLast("encoder_compress", new HttpContentCompressor(handlingSettings.getCompressionLevel()));
             }
-            if (handlingSettings.isCorsEnabled()) {
-                ch.pipeline().addLast("cors", new Netty4CorsHandler(transport.corsConfig));
-            }
             ch.pipeline().addLast("pipelining", new Netty4HttpPipeliningHandler(logger, transport.pipeliningMaxEvents));
             ch.pipeline().addLast("handler", requestHandler);
             transport.serverAcceptedChannel(nettyHttpChannel);
diff --git a/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/cors/Netty4CorsConfig.java b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/cors/Netty4CorsConfig.java
deleted file mode 100644
index 17e21ce468b4..000000000000
--- a/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/cors/Netty4CorsConfig.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- * Licensed to Elasticsearch under one or more contributor
- * license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright
- * ownership. Elasticsearch licenses this file to you under
- * the Apache License, Version 2.0 (the "License"); you may
- * not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.elasticsearch.http.netty4.cors;
-
-import io.netty.handler.codec.http.DefaultHttpHeaders;
-import io.netty.handler.codec.http.EmptyHttpHeaders;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.regex.Pattern;
-
-/**
- * Configuration for Cross-Origin Resource Sharing (CORS).
- *
- * This class was lifted from the Netty project:
- *  https://github.com/netty/netty
- */
-public final class Netty4CorsConfig {
-
-    private final Optional<Set<String>> origins;
-    private final Optional<Pattern> pattern;
-    private final boolean anyOrigin;
-    private final boolean enabled;
-    private final boolean allowCredentials;
-    private final long maxAge;
-    private final Set<HttpMethod> allowedRequestMethods;
-    private final Set<String> allowedRequestHeaders;
-    private final Map<CharSequence, Callable<?>> preflightHeaders;
-    private final boolean shortCircuit;
-
-    Netty4CorsConfig(final Netty4CorsConfigBuilder builder) {
-        origins = builder.origins.map(s -> new LinkedHashSet<>(s));
-        pattern = builder.pattern;
-        anyOrigin = builder.anyOrigin;
-        enabled = builder.enabled;
-        allowCredentials = builder.allowCredentials;
-        maxAge = builder.maxAge;
-        allowedRequestMethods = builder.requestMethods;
-        allowedRequestHeaders = builder.requestHeaders;
-        preflightHeaders = builder.preflightHeaders;
-        shortCircuit = builder.shortCircuit;
-    }
-
-    /**
-     * Determines if support for CORS is enabled.
-     *
-     * @return {@code true} if support for CORS is enabled, false otherwise.
-     */
-    public boolean isCorsSupportEnabled() {
-        return enabled;
-    }
-
-    /**
-     * Determines whether a wildcard origin, '*', is supported. This also means that null origins are
-     * supported.
-     *
-     * @return {@code boolean} true if any origin is allowed.
-     */
-    public boolean isAnyOriginSupported() {
-        return anyOrigin;
-    }
-
-    /**
-     * Returns the set of allowed origins.
-     *
-     * @return {@code Set} the allowed origins.
-     */
-    public Optional<Set<String>> origins() {
-        return origins;
-    }
-
-    /**
-     * Returns whether the input origin is allowed by this configuration.
-     *
-     * @return {@code true} if the origin is allowed, otherwise {@code false}
-     */
-    public boolean isOriginAllowed(final String origin) {
-        if (origins.isPresent()) {
-            return origins.get().contains(origin);
-        } else if (pattern.isPresent()) {
-            return pattern.get().matcher(origin).matches();
-        }
-        return false;
-    }
-
-    /**
-     * Determines if credentials are supported for CORS requests.
-     *
-     * By default credentials are not included in CORS requests but if isCredentialsAllowed returns
-     * true credentials will be added to CORS requests. Setting this value to true will set the
-     * CORS 'Access-Control-Allow-Credentials' response header to true.
-     *
-     * Please note that credentials support needs to be enabled on the client side as well.
-     * The client needs to opt-in to send credentials by calling:
-     * <pre>
-     * xhr.withCredentials = true;
-     * </pre>
-     * The default value for 'withCredentials' is false in which case no credentials are sent.
-     * Setting this to true will included credentials in cross origin requests.
-     *
-     * @return {@code true} if credentials are supported.
-     */
-    public boolean isCredentialsAllowed() {
-        return allowCredentials;
-    }
-
-    /**
-     * Gets the maxAge setting.
-     *
-     * When making a preflight request the client has to perform two request with can be inefficient.
-     * This setting will set the CORS 'Access-Control-Max-Age' response header and enables the
-     * caching of the preflight response for the specified time. During this time no preflight
-     * request will be made.
-     *
-     * @return {@code long} the time in seconds that a preflight request may be cached.
-     */
-    public long maxAge() {
-        return maxAge;
-    }
-
-    /**
-     * Returns the allowed set of Request Methods. The Http methods that should be returned in the
-     * CORS 'Access-Control-Request-Method' response header.
-     *
-     * @return {@code Set} of {@link HttpMethod}s that represent the allowed Request Methods.
-     */
-    public Set<HttpMethod> allowedRequestMethods() {
-        return Collections.unmodifiableSet(allowedRequestMethods);
-    }
-
-    /**
-     * Returns the allowed set of Request Headers.
-     *
-     * The header names returned from this method will be used to set the CORS
-     * 'Access-Control-Allow-Headers' response header.
-     *
-     * @return {@code Set<String>} of strings that represent the allowed Request Headers.
-     */
-    public Set<String> allowedRequestHeaders() {
-        return Collections.unmodifiableSet(allowedRequestHeaders);
-    }
-
-    /**
-     * Returns HTTP response headers that should be added to a CORS preflight response.
-     *
-     * @return {@link HttpHeaders} the HTTP response headers to be added.
-     */
-    public HttpHeaders preflightResponseHeaders() {
-        if (preflightHeaders.isEmpty()) {
-            return EmptyHttpHeaders.INSTANCE;
-        }
-        final HttpHeaders preflightHeaders = new DefaultHttpHeaders();
-        for (Map.Entry<CharSequence, Callable<?>> entry : this.preflightHeaders.entrySet()) {
-            final Object value = getValue(entry.getValue());
-            if (value instanceof Iterable) {
-                preflightHeaders.add(entry.getKey().toString(), (Iterable<?>) value);
-            } else {
-                preflightHeaders.add(entry.getKey().toString(), value);
-            }
-        }
-        return preflightHeaders;
-    }
-
-    /**
-     * Determines whether a CORS request should be rejected if it's invalid before being
-     * further processing.
-     *
-     * CORS headers are set after a request is processed. This may not always be desired
-     * and this setting will check that the Origin is valid and if it is not valid no
-     * further processing will take place, and a error will be returned to the calling client.
-     *
-     * @return {@code true} if a CORS request should short-circuit upon receiving an invalid Origin header.
-     */
-    public boolean isShortCircuit() {
-        return shortCircuit;
-    }
-
-    private static <T> T getValue(final Callable<T> callable) {
-        try {
-            return callable.call();
-        } catch (final Exception e) {
-            throw new IllegalStateException("Could not generate value for callable [" + callable + ']', e);
-        }
-    }
-
-    @Override
-    public String toString() {
-        return  "CorsConfig[enabled=" + enabled +
-            ", origins=" + origins +
-            ", anyOrigin=" + anyOrigin +
-            ", isCredentialsAllowed=" + allowCredentials +
-            ", maxAge=" + maxAge +
-            ", allowedRequestMethods=" + allowedRequestMethods +
-            ", allowedRequestHeaders=" + allowedRequestHeaders +
-            ", preflightHeaders=" + preflightHeaders + ']';
-    }
-
-}
diff --git a/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/cors/Netty4CorsConfigBuilder.java b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/cors/Netty4CorsConfigBuilder.java
deleted file mode 100644
index 3e87d948dabf..000000000000
--- a/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/cors/Netty4CorsConfigBuilder.java
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
- * Licensed to Elasticsearch under one or more contributor
- * license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright
- * ownership. Elasticsearch licenses this file to you under
- * the Apache License, Version 2.0 (the "License"); you may
- * not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.elasticsearch.http.netty4.cors;
-
-import io.netty.handler.codec.http.HttpMethod;
-
-import java.util.Arrays;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.regex.Pattern;
-
-/**
- * Builder used to configure and build a {@link Netty4CorsConfig} instance.
- *
- * This class was lifted from the Netty project:
- *  https://github.com/netty/netty
- */
-public final class Netty4CorsConfigBuilder {
-
-    /**
-     * Creates a Builder instance with it's origin set to '*'.
-     *
-     * @return Builder to support method chaining.
-     */
-    public static Netty4CorsConfigBuilder forAnyOrigin() {
-        return new Netty4CorsConfigBuilder();
-    }
-
-    /**
-     * Create a {@link Netty4CorsConfigBuilder} instance with the specified pattern origin.
-     *
-     * @param pattern the regular expression pattern to match incoming origins on.
-     * @return {@link Netty4CorsConfigBuilder} with the configured origin pattern.
-     */
-    public static Netty4CorsConfigBuilder forPattern(final Pattern pattern) {
-        if (pattern == null) {
-            throw new IllegalArgumentException("CORS pattern cannot be null");
-        }
-        return new Netty4CorsConfigBuilder(pattern);
-    }
-
-    /**
-     * Creates a {@link Netty4CorsConfigBuilder} instance with the specified origins.
-     *
-     * @return {@link Netty4CorsConfigBuilder} to support method chaining.
-     */
-    public static Netty4CorsConfigBuilder forOrigins(final String... origins) {
-        return new Netty4CorsConfigBuilder(origins);
-    }
-
-    Optional<Set<String>> origins;
-    Optional<Pattern> pattern;
-    final boolean anyOrigin;
-    boolean enabled = true;
-    boolean allowCredentials;
-    long maxAge;
-    final Set<HttpMethod> requestMethods = new HashSet<>();
-    final Set<String> requestHeaders = new HashSet<>();
-    final Map<CharSequence, Callable<?>> preflightHeaders = new HashMap<>();
-    boolean shortCircuit;
-
-    /**
-     * Creates a new Builder instance with the origin passed in.
-     *
-     * @param origins the origin to be used for this builder.
-     */
-    Netty4CorsConfigBuilder(final String... origins) {
-        this.origins = Optional.of(new LinkedHashSet<>(Arrays.asList(origins)));
-        pattern = Optional.empty();
-        anyOrigin = false;
-    }
-
-    /**
-     * Creates a new Builder instance allowing any origin, "*" which is the
-     * wildcard origin.
-     *
-     */
-    Netty4CorsConfigBuilder() {
-        anyOrigin = true;
-        origins = Optional.empty();
-        pattern = Optional.empty();
-    }
-
-    /**
-     * Creates a new Builder instance allowing any origin that matches the pattern.
-     *
-     * @param pattern the pattern to match against for incoming origins.
-     */
-    Netty4CorsConfigBuilder(final Pattern pattern) {
-        this.pattern = Optional.of(pattern);
-        origins = Optional.empty();
-        anyOrigin = false;
-    }
-
-    /**
-     * Disables CORS support.
-     *
-     * @return {@link Netty4CorsConfigBuilder} to support method chaining.
-     */
-    public Netty4CorsConfigBuilder disable() {
-        enabled = false;
-        return this;
-    }
-
-    /**
-     * By default cookies are not included in CORS requests, but this method will enable cookies to
-     * be added to CORS requests. Calling this method will set the CORS 'Access-Control-Allow-Credentials'
-     * response header to true.
-     *
-     * Please note, that cookie support needs to be enabled on the client side as well.
-     * The client needs to opt-in to send cookies by calling:
-     * <pre>
-     * xhr.withCredentials = true;
-     * </pre>
-     * The default value for 'withCredentials' is false in which case no cookies are sent.
-     * Setting this to true will included cookies in cross origin requests.
-     *
-     * @return {@link Netty4CorsConfigBuilder} to support method chaining.
-     */
-    public Netty4CorsConfigBuilder allowCredentials() {
-        allowCredentials = true;
-        return this;
-    }
-
-    /**
-     * When making a preflight request the client has to perform two request with can be inefficient.
-     * This setting will set the CORS 'Access-Control-Max-Age' response header and enables the
-     * caching of the preflight response for the specified time. During this time no preflight
-     * request will be made.
-     *
-     * @param max the maximum time, in seconds, that the preflight response may be cached.
-     * @return {@link Netty4CorsConfigBuilder} to support method chaining.
-     */
-    public Netty4CorsConfigBuilder maxAge(final long max) {
-        maxAge = max;
-        return this;
-    }
-
-    /**
-     * Specifies the allowed set of HTTP Request Methods that should be returned in the
-     * CORS 'Access-Control-Request-Method' response header.
-     *
-     * @param methods the {@link HttpMethod}s that should be allowed.
-     * @return {@link Netty4CorsConfigBuilder} to support method chaining.
-     */
-    public Netty4CorsConfigBuilder allowedRequestMethods(final HttpMethod... methods) {
-        requestMethods.addAll(Arrays.asList(methods));
-        return this;
-    }
-
-    /**
-     * Specifies the if headers that should be returned in the CORS 'Access-Control-Allow-Headers'
-     * response header.
-     *
-     * If a client specifies headers on the request, for example by calling:
-     * <pre>
-     * xhr.setRequestHeader('My-Custom-Header', "SomeValue");
-     * </pre>
-     * the server will receive the above header name in the 'Access-Control-Request-Headers' of the
-     * preflight request. The server will then decide if it allows this header to be sent for the
-     * real request (remember that a preflight is not the real request but a request asking the server
-     * if it allow a request).
-     *
-     * @param headers the headers to be added to the preflight 'Access-Control-Allow-Headers' response header.
-     * @return {@link Netty4CorsConfigBuilder} to support method chaining.
-     */
-    public Netty4CorsConfigBuilder allowedRequestHeaders(final String... headers) {
-        requestHeaders.addAll(Arrays.asList(headers));
-        return this;
-    }
-
-    /**
-     * Specifies that a CORS request should be rejected if it's invalid before being
-     * further processing.
-     *
-     * CORS headers are set after a request is processed. This may not always be desired
-     * and this setting will check that the Origin is valid and if it is not valid no
-     * further processing will take place, and a error will be returned to the calling client.
-     *
-     * @return {@link Netty4CorsConfigBuilder} to support method chaining.
-     */
-    public Netty4CorsConfigBuilder shortCircuit() {
-        shortCircuit = true;
-        return this;
-    }
-
-    /**
-     * Builds a {@link Netty4CorsConfig} with settings specified by previous method calls.
-     *
-     * @return {@link Netty4CorsConfig} the configured CorsConfig instance.
-     */
-    public Netty4CorsConfig build() {
-        if (preflightHeaders.isEmpty()) {
-            preflightHeaders.put("date", DateValueGenerator.INSTANCE);
-            preflightHeaders.put("content-length", new ConstantValueGenerator("0"));
-        }
-        return new Netty4CorsConfig(this);
-    }
-
-    /**
-     * This class is used for preflight HTTP response values that do not need to be
-     * generated, but instead the value is "static" in that the same value will be returned
-     * for each call.
-     */
-    private static final class ConstantValueGenerator implements Callable<Object> {
-
-        private final Object value;
-
-        /**
-         * Sole constructor.
-         *
-         * @param value the value that will be returned when the call method is invoked.
-         */
-        private ConstantValueGenerator(final Object value) {
-            if (value == null) {
-                throw new IllegalArgumentException("value must not be null");
-            }
-            this.value = value;
-        }
-
-        @Override
-        public Object call() {
-            return value;
-        }
-    }
-
-    /**
-     * This callable is used for the DATE preflight HTTP response HTTP header.
-     * It's value must be generated when the response is generated, hence will be
-     * different for every call.
-     */
-    private static final class DateValueGenerator implements Callable<Date> {
-
-        static final DateValueGenerator INSTANCE = new DateValueGenerator();
-
-        @Override
-        public Date call() throws Exception {
-            return new Date();
-        }
-    }
-
-}
diff --git a/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/cors/Netty4CorsHandler.java b/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/cors/Netty4CorsHandler.java
deleted file mode 100644
index 5f7baffc86aa..000000000000
--- a/modules/transport-netty4/src/main/java/org/elasticsearch/http/netty4/cors/Netty4CorsHandler.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * Licensed to Elasticsearch under one or more contributor
- * license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright
- * ownership. Elasticsearch licenses this file to you under
- * the Apache License, Version 2.0 (the "License"); you may
- * not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.elasticsearch.http.netty4.cors;
-
-import io.netty.channel.ChannelDuplexHandler;
-import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.http.DefaultFullHttpResponse;
-import io.netty.handler.codec.http.FullHttpRequest;
-import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpResponseStatus;
-import org.elasticsearch.common.Strings;
-import org.elasticsearch.http.netty4.Netty4HttpResponse;
-
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
-
-/**
- * Handles <a href="http://www.w3.org/TR/cors/">Cross Origin Resource Sharing</a> (CORS) requests.
- * <p>
- * This handler can be configured using a {@link Netty4CorsConfig}, please
- * refer to this class for details about the configuration options available.
- *
- * This code was borrowed from Netty 4 and refactored to work for Elasticsearch's Netty 3 setup.
- */
-public class Netty4CorsHandler extends ChannelDuplexHandler {
-
-    public static final String ANY_ORIGIN = "*";
-    private static Pattern SCHEME_PATTERN = Pattern.compile("^https?://");
-
-    private final Netty4CorsConfig config;
-    private FullHttpRequest request;
-
-    /**
-     * Creates a new instance with the specified {@link Netty4CorsConfig}.
-     */
-    public Netty4CorsHandler(final Netty4CorsConfig config) {
-        if (config == null) {
-            throw new NullPointerException();
-        }
-        this.config = config;
-    }
-
-    @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-        assert msg instanceof FullHttpRequest : "Invalid message type: " + msg.getClass();
-        if (config.isCorsSupportEnabled()) {
-            request = (FullHttpRequest) msg;
-            if (isPreflightRequest(request)) {
-                try {
-                    handlePreflight(ctx, request);
-                    return;
-                } finally {
-                    releaseRequest();
-                }
-            }
-            if (config.isShortCircuit() && !validateOrigin()) {
-                try {
-                    forbidden(ctx, request);
-                    return;
-                } finally {
-                    releaseRequest();
-                }
-            }
-        }
-        ctx.fireChannelRead(msg);
-    }
-
-    @Override
-    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
-        assert msg instanceof Netty4HttpResponse : "Invalid message type: " + msg.getClass();
-        Netty4HttpResponse response = (Netty4HttpResponse) msg;
-        setCorsResponseHeaders(response.getRequest().nettyRequest(), response, config);
-        ctx.write(response, promise);
-    }
-
-    public static void setCorsResponseHeaders(HttpRequest request, HttpResponse resp, Netty4CorsConfig config) {
-        if (!config.isCorsSupportEnabled()) {
-            return;
-        }
-        String originHeader = request.headers().get(HttpHeaderNames.ORIGIN);
-        if (!Strings.isNullOrEmpty(originHeader)) {
-            final String originHeaderVal;
-            if (config.isAnyOriginSupported()) {
-                originHeaderVal = ANY_ORIGIN;
-            } else if (config.isOriginAllowed(originHeader) || isSameOrigin(originHeader, request.headers().get(HttpHeaderNames.HOST))) {
-                originHeaderVal = originHeader;
-            } else {
-                originHeaderVal = null;
-            }
-            if (originHeaderVal != null) {
-                resp.headers().add(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, originHeaderVal);
-            }
-        }
-        if (config.isCredentialsAllowed()) {
-            resp.headers().add(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
-        }
-    }
-
-    private void handlePreflight(final ChannelHandlerContext ctx, final HttpRequest request) {
-        final HttpResponse response = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK, true, true);
-        if (setOrigin(response)) {
-            setAllowMethods(response);
-            setAllowHeaders(response);
-            setAllowCredentials(response);
-            setMaxAge(response);
-            setPreflightHeaders(response);
-            ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
-        } else {
-            forbidden(ctx, request);
-        }
-    }
-
-    private void releaseRequest() {
-        request.release();
-        request = null;
-    }
-
-    private static void forbidden(final ChannelHandlerContext ctx, final HttpRequest request) {
-        ctx.writeAndFlush(new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.FORBIDDEN))
-            .addListener(ChannelFutureListener.CLOSE);
-    }
-
-    private static boolean isSameOrigin(final String origin, final String host) {
-        if (Strings.isNullOrEmpty(host) == false) {
-            // strip protocol from origin
-            final String originDomain = SCHEME_PATTERN.matcher(origin).replaceFirst("");
-            if (host.equals(originDomain)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * This is a non CORS specification feature which enables the setting of preflight
-     * response headers that might be required by intermediaries.
-     *
-     * @param response the HttpResponse to which the preflight response headers should be added.
-     */
-    private void setPreflightHeaders(final HttpResponse response) {
-        response.headers().add(config.preflightResponseHeaders());
-    }
-
-    private boolean setOrigin(final HttpResponse response) {
-        final String origin = request.headers().get(HttpHeaderNames.ORIGIN);
-        if (!Strings.isNullOrEmpty(origin)) {
-            if (config.isAnyOriginSupported()) {
-                if (config.isCredentialsAllowed()) {
-                    echoRequestOrigin(response);
-                    setVaryHeader(response);
-                } else {
-                    setAnyOrigin(response);
-                }
-                return true;
-            }
-            if (config.isOriginAllowed(origin)) {
-                setOrigin(response, origin);
-                setVaryHeader(response);
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private boolean validateOrigin() {
-        if (config.isAnyOriginSupported()) {
-            return true;
-        }
-
-        final String origin = request.headers().get(HttpHeaderNames.ORIGIN);
-        if (Strings.isNullOrEmpty(origin)) {
-            // Not a CORS request so we cannot validate it. It may be a non CORS request.
-            return true;
-        }
-
-        // if the origin is the same as the host of the request, then allow
-        if (isSameOrigin(origin, request.headers().get(HttpHeaderNames.HOST))) {
-            return true;
-        }
-
-        return config.isOriginAllowed(origin);
-    }
-
-    private void echoRequestOrigin(final HttpResponse response) {
-        setOrigin(response, request.headers().get(HttpHeaderNames.ORIGIN));
-    }
-
-    private static void setVaryHeader(final HttpResponse response) {
-        response.headers().set(HttpHeaderNames.VARY, HttpHeaderNames.ORIGIN);
-    }
-
-    private static void setAnyOrigin(final HttpResponse response) {
-        setOrigin(response, ANY_ORIGIN);
-    }
-
-    private static void setOrigin(final HttpResponse response, final String origin) {
-        response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, origin);
-    }
-
-    private void setAllowCredentials(final HttpResponse response) {
-        if (config.isCredentialsAllowed()
-            && !response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN).equals(ANY_ORIGIN)) {
-            response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
-        }
-    }
-
-    private static boolean isPreflightRequest(final HttpRequest request) {
-        final HttpHeaders headers = request.headers();
-        return request.method().equals(HttpMethod.OPTIONS) &&
-            headers.contains(HttpHeaderNames.ORIGIN) &&
-            headers.contains(HttpHeaderNames.ACCESS_CONTROL_REQUEST_METHOD);
-    }
-
-    private void setAllowMethods(final HttpResponse response) {
-        response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, config.allowedRequestMethods().stream()
-            .map(m -> m.name().trim())
-            .collect(Collectors.toList()));
-    }
-
-    private void setAllowHeaders(final HttpResponse response) {
-        response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, config.allowedRequestHeaders());
-    }
-
-    private void setMaxAge(final HttpResponse response) {
-        response.headers().set(HttpHeaderNames.ACCESS_CONTROL_MAX_AGE, config.maxAge());
-    }
-
-}
diff --git a/modules/transport-netty4/src/test/java/org/elasticsearch/http/netty4/Netty4CorsTests.java b/modules/transport-netty4/src/test/java/org/elasticsearch/http/netty4/Netty4CorsTests.java
deleted file mode 100644
index 115e6735eb27..000000000000
--- a/modules/transport-netty4/src/test/java/org/elasticsearch/http/netty4/Netty4CorsTests.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Licensed to Elasticsearch under one or more contributor
- * license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright
- * ownership. Elasticsearch licenses this file to you under
- * the Apache License, Version 2.0 (the "License"); you may
- * not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.elasticsearch.http.netty4;
-
-import io.netty.channel.embedded.EmbeddedChannel;
-import io.netty.handler.codec.http.DefaultFullHttpRequest;
-import io.netty.handler.codec.http.FullHttpRequest;
-import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpVersion;
-import org.elasticsearch.common.bytes.BytesArray;
-import org.elasticsearch.common.settings.Settings;
-import org.elasticsearch.http.HttpTransportSettings;
-import org.elasticsearch.http.netty4.cors.Netty4CorsHandler;
-import org.elasticsearch.rest.RestStatus;
-import org.elasticsearch.test.ESTestCase;
-
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_CREDENTIALS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_METHODS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_ORIGIN;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ENABLED;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.notNullValue;
-import static org.hamcrest.Matchers.nullValue;
-
-public class Netty4CorsTests extends ESTestCase {
-
-    public void testCorsEnabledWithoutAllowOrigins() {
-        // Set up an HTTP transport with only the CORS enabled setting
-        Settings settings = Settings.builder()
-            .put(HttpTransportSettings.SETTING_CORS_ENABLED.getKey(), true)
-            .build();
-        HttpResponse response = executeRequest(settings, "remote-host", "request-host");
-        // inspect response and validate
-        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), nullValue());
-    }
-
-    public void testCorsEnabledWithAllowOrigins() {
-        final String originValue = "remote-host";
-        // create an HTTP transport with CORS enabled and allow origin configured
-        Settings settings = Settings.builder()
-            .put(SETTING_CORS_ENABLED.getKey(), true)
-            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue)
-            .build();
-        HttpResponse response = executeRequest(settings, originValue, "request-host");
-        // inspect response and validate
-        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-        String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-        assertThat(allowedOrigins, is(originValue));
-    }
-
-    public void testCorsAllowOriginWithSameHost() {
-        String originValue = "remote-host";
-        String host = "remote-host";
-        // create an HTTP transport with CORS enabled
-        Settings settings = Settings.builder()
-            .put(SETTING_CORS_ENABLED.getKey(), true)
-            .build();
-        HttpResponse response = executeRequest(settings, originValue, host);
-        // inspect response and validate
-        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-        String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-        assertThat(allowedOrigins, is(originValue));
-
-        originValue = "http://" + originValue;
-        response = executeRequest(settings, originValue, host);
-        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-        allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-        assertThat(allowedOrigins, is(originValue));
-
-        originValue = originValue + ":5555";
-        host = host + ":5555";
-        response = executeRequest(settings, originValue, host);
-        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-        allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-        assertThat(allowedOrigins, is(originValue));
-
-        originValue = originValue.replace("http", "https");
-        response = executeRequest(settings, originValue, host);
-        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-        allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-        assertThat(allowedOrigins, is(originValue));
-    }
-
-    public void testThatStringLiteralWorksOnMatch() {
-        final String originValue = "remote-host";
-        Settings settings = Settings.builder()
-            .put(SETTING_CORS_ENABLED.getKey(), true)
-            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue)
-            .put(SETTING_CORS_ALLOW_METHODS.getKey(), "get, options, post")
-            .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true)
-            .build();
-        HttpResponse response = executeRequest(settings, originValue, "request-host");
-        // inspect response and validate
-        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-        String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-        assertThat(allowedOrigins, is(originValue));
-        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS), equalTo("true"));
-    }
-
-    public void testThatAnyOriginWorks() {
-        final String originValue = Netty4CorsHandler.ANY_ORIGIN;
-        Settings settings = Settings.builder()
-            .put(SETTING_CORS_ENABLED.getKey(), true)
-            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue)
-            .build();
-        HttpResponse response = executeRequest(settings, originValue, "request-host");
-        // inspect response and validate
-        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-        String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-        assertThat(allowedOrigins, is(originValue));
-        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS), nullValue());
-    }
-
-    private FullHttpResponse executeRequest(final Settings settings, final String originValue, final String host) {
-        // construct request and send it over the transport layer
-        final FullHttpRequest httpRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");
-        if (originValue != null) {
-            httpRequest.headers().add(HttpHeaderNames.ORIGIN, originValue);
-        }
-        httpRequest.headers().add(HttpHeaderNames.HOST, host);
-        EmbeddedChannel embeddedChannel = new EmbeddedChannel();
-        embeddedChannel.pipeline().addLast(new Netty4CorsHandler(Netty4HttpServerTransport.buildCorsConfig(settings)));
-        Netty4HttpRequest nettyRequest = new Netty4HttpRequest(httpRequest, 0);
-        embeddedChannel.writeOutbound(nettyRequest.createResponse(RestStatus.OK, new BytesArray("content")));
-        return embeddedChannel.readOutbound();
-    }
-}
diff --git a/modules/transport-netty4/src/test/java/org/elasticsearch/http/netty4/Netty4HttpServerTransportTests.java b/modules/transport-netty4/src/test/java/org/elasticsearch/http/netty4/Netty4HttpServerTransportTests.java
index bc4ebe5672ec..4c04c51ec835 100644
--- a/modules/transport-netty4/src/test/java/org/elasticsearch/http/netty4/Netty4HttpServerTransportTests.java
+++ b/modules/transport-netty4/src/test/java/org/elasticsearch/http/netty4/Netty4HttpServerTransportTests.java
@@ -39,12 +39,10 @@
 import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpVersion;
 import org.elasticsearch.ElasticsearchException;
-import org.elasticsearch.common.Strings;
 import org.elasticsearch.common.bytes.BytesArray;
 import org.elasticsearch.common.network.NetworkService;
 import org.elasticsearch.common.settings.Setting;
 import org.elasticsearch.common.settings.Settings;
-import org.elasticsearch.common.settings.SettingsException;
 import org.elasticsearch.common.transport.TransportAddress;
 import org.elasticsearch.common.unit.ByteSizeValue;
 import org.elasticsearch.common.unit.TimeValue;
@@ -52,10 +50,10 @@
 import org.elasticsearch.common.util.MockPageCacheRecycler;
 import org.elasticsearch.common.util.concurrent.ThreadContext;
 import org.elasticsearch.http.BindHttpException;
+import org.elasticsearch.http.CorsHandler;
 import org.elasticsearch.http.HttpServerTransport;
 import org.elasticsearch.http.HttpTransportSettings;
 import org.elasticsearch.http.NullDispatcher;
-import org.elasticsearch.http.netty4.cors.Netty4CorsConfig;
 import org.elasticsearch.indices.breaker.NoneCircuitBreakerService;
 import org.elasticsearch.rest.BytesRestResponse;
 import org.elasticsearch.rest.RestChannel;
@@ -69,23 +67,13 @@
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
-import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashSet;
-import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.regex.PatternSyntaxException;
-import java.util.stream.Collectors;
 
-import static org.elasticsearch.common.Strings.collectionToDelimitedString;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_CREDENTIALS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_HEADERS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_METHODS;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_ORIGIN;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ENABLED;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_MAX_AGE;
 import static org.elasticsearch.rest.RestStatus.BAD_REQUEST;
 import static org.elasticsearch.rest.RestStatus.OK;
 import static org.hamcrest.Matchers.containsString;
@@ -119,48 +107,6 @@ public void shutdown() throws Exception {
         bigArrays = null;
     }
 
-    public void testCorsConfig() {
-        final Set<String> methods = new HashSet<>(Arrays.asList("get", "options", "post"));
-        final Set<String> headers = new HashSet<>(Arrays.asList("Content-Type", "Content-Length"));
-        final String prefix = randomBoolean() ? " " : ""; // sometimes have a leading whitespace between comma delimited elements
-        final Settings settings = Settings.builder()
-                                      .put(SETTING_CORS_ENABLED.getKey(), true)
-                                      .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "*")
-                                      .put(SETTING_CORS_ALLOW_METHODS.getKey(), collectionToDelimitedString(methods, ",", prefix, ""))
-                                      .put(SETTING_CORS_ALLOW_HEADERS.getKey(), collectionToDelimitedString(headers, ",", prefix, ""))
-                                      .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true)
-                                      .build();
-        final Netty4CorsConfig corsConfig = Netty4HttpServerTransport.buildCorsConfig(settings);
-        assertTrue(corsConfig.isAnyOriginSupported());
-        assertEquals(headers, corsConfig.allowedRequestHeaders());
-        assertEquals(methods, corsConfig.allowedRequestMethods().stream().map(HttpMethod::name).collect(Collectors.toSet()));
-    }
-
-    public void testCorsConfigWithDefaults() {
-        final Set<String> methods = Strings.commaDelimitedListToSet(SETTING_CORS_ALLOW_METHODS.getDefault(Settings.EMPTY));
-        final Set<String> headers = Strings.commaDelimitedListToSet(SETTING_CORS_ALLOW_HEADERS.getDefault(Settings.EMPTY));
-        final long maxAge = SETTING_CORS_MAX_AGE.getDefault(Settings.EMPTY);
-        final Settings settings = Settings.builder().put(SETTING_CORS_ENABLED.getKey(), true).build();
-        final Netty4CorsConfig corsConfig = Netty4HttpServerTransport.buildCorsConfig(settings);
-        assertFalse(corsConfig.isAnyOriginSupported());
-        assertEquals(Collections.emptySet(), corsConfig.origins().get());
-        assertEquals(headers, corsConfig.allowedRequestHeaders());
-        assertEquals(methods, corsConfig.allowedRequestMethods().stream().map(HttpMethod::name).collect(Collectors.toSet()));
-        assertEquals(maxAge, corsConfig.maxAge());
-        assertFalse(corsConfig.isCredentialsAllowed());
-    }
-
-    public void testCorsConfigWithBadRegex() {
-        final Settings settings = Settings.builder()
-            .put(SETTING_CORS_ENABLED.getKey(), true)
-            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "/[*/")
-            .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true)
-            .build();
-        SettingsException e = expectThrows(SettingsException.class, () -> Netty4HttpServerTransport.buildCorsConfig(settings));
-        assertThat(e.getMessage(), containsString("Bad regex in [http.cors.allow-origin]: [/[*/]"));
-        assertThat(e.getCause(), instanceOf(PatternSyntaxException.class));
-    }
-
     /**
      * Test that {@link Netty4HttpServerTransport} supports the "Expect: 100-continue" HTTP header
      * @throws InterruptedException if the client communication with the server is interrupted
@@ -250,7 +196,7 @@ public void testBindUnavailableAddress() {
             Settings settings = Settings.builder().put("http.port", remoteAddress.getPort()).build();
             try (Netty4HttpServerTransport otherTransport = new Netty4HttpServerTransport(settings, networkService, bigArrays, threadPool,
                     xContentRegistry(), new NullDispatcher())) {
-                BindHttpException bindHttpException = expectThrows(BindHttpException.class, () -> otherTransport.start());
+                BindHttpException bindHttpException = expectThrows(BindHttpException.class, otherTransport::start);
                 assertEquals("Failed to bind to [" + remoteAddress.getPort() + "]", bindHttpException.getMessage());
             }
         }
@@ -317,6 +263,65 @@ public void dispatchBadRequest(final RestRequest request,
         assertThat(causeReference.get(), instanceOf(TooLongFrameException.class));
     }
 
+    public void testCorsRequest() throws InterruptedException {
+        final HttpServerTransport.Dispatcher dispatcher = new HttpServerTransport.Dispatcher() {
+
+            @Override
+            public void dispatchRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void dispatchBadRequest(final RestRequest request,
+                                           final RestChannel channel,
+                                           final ThreadContext threadContext,
+                                           final Throwable cause) {
+                throw new AssertionError();
+            }
+
+        };
+
+        final Settings settings = Settings.builder()
+            .put(SETTING_CORS_ENABLED.getKey(), true)
+            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "elastic.co").build();
+
+        try (Netty4HttpServerTransport transport =
+                 new Netty4HttpServerTransport(settings, networkService, bigArrays, threadPool, xContentRegistry(), dispatcher)) {
+            transport.start();
+            final TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses());
+
+            // Test pre-flight request
+            try (Netty4HttpClient client = new Netty4HttpClient()) {
+                final FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.OPTIONS, "/");
+                request.headers().add(CorsHandler.ORIGIN, "elastic.co");
+                request.headers().add(CorsHandler.ACCESS_CONTROL_REQUEST_METHOD, "POST");
+
+                final FullHttpResponse response = client.post(remoteAddress.address(), request);
+                try {
+                    assertThat(response.status(), equalTo(HttpResponseStatus.OK));
+                    assertThat(response.headers().get(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN), equalTo("elastic.co"));
+                    assertThat(response.headers().get(CorsHandler.VARY), equalTo(CorsHandler.ORIGIN));
+                    assertTrue(response.headers().contains(CorsHandler.DATE));
+                } finally {
+                    response.release();
+                }
+            }
+
+            // Test short-circuited request
+            try (Netty4HttpClient client = new Netty4HttpClient()) {
+                final FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");
+                request.headers().add(CorsHandler.ORIGIN, "elastic2.co");
+
+                final FullHttpResponse response = client.post(remoteAddress.address(), request);
+                try {
+                    assertThat(response.status(), equalTo(HttpResponseStatus.FORBIDDEN));
+                } finally {
+                    response.release();
+                }
+            }
+        }
+    }
+
     public void testReadTimeout() throws Exception {
         final HttpServerTransport.Dispatcher dispatcher = new HttpServerTransport.Dispatcher() {
 
diff --git a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/HttpReadWriteHandler.java b/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/HttpReadWriteHandler.java
index c603e20ffc93..acd4ba8b4ac4 100644
--- a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/HttpReadWriteHandler.java
+++ b/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/HttpReadWriteHandler.java
@@ -34,8 +34,6 @@
 import org.elasticsearch.http.HttpHandlingSettings;
 import org.elasticsearch.http.HttpPipelinedRequest;
 import org.elasticsearch.http.HttpReadTimeoutException;
-import org.elasticsearch.http.nio.cors.NioCorsConfig;
-import org.elasticsearch.http.nio.cors.NioCorsHandler;
 import org.elasticsearch.nio.FlushOperation;
 import org.elasticsearch.nio.InboundChannelBuffer;
 import org.elasticsearch.nio.NioChannelHandler;
@@ -63,7 +61,7 @@
     private int inFlightRequests = 0;
 
     public HttpReadWriteHandler(NioHttpChannel nioHttpChannel, NioHttpServerTransport transport, HttpHandlingSettings settings,
-                                NioCorsConfig corsConfig, TaskScheduler taskScheduler, LongSupplier nanoClock) {
+                                TaskScheduler taskScheduler, LongSupplier nanoClock) {
         this.nioHttpChannel = nioHttpChannel;
         this.transport = transport;
         this.taskScheduler = taskScheduler;
@@ -81,9 +79,6 @@ public HttpReadWriteHandler(NioHttpChannel nioHttpChannel, NioHttpServerTranspor
         if (settings.isCompression()) {
             handlers.add(new HttpContentCompressor(settings.getCompressionLevel()));
         }
-        if (settings.isCorsEnabled()) {
-            handlers.add(new NioCorsHandler(corsConfig));
-        }
         handlers.add(new NioHttpPipeliningHandler(transport.getLogger(), settings.getPipeliningMaxEvents()));
 
         adaptor = new NettyAdaptor(handlers.toArray(new ChannelHandler[0]));
diff --git a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/NioHttpResponse.java b/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/NioHttpResponse.java
index d67494667384..2f79f2211ff1 100644
--- a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/NioHttpResponse.java
+++ b/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/NioHttpResponse.java
@@ -26,15 +26,24 @@
 import org.elasticsearch.http.HttpResponse;
 import org.elasticsearch.rest.RestStatus;
 
+import java.util.List;
+
 public class NioHttpResponse extends DefaultFullHttpResponse implements HttpResponse, HttpPipelinedMessage {
 
     private final int sequence;
     private final NioHttpRequest request;
+    private final RestStatus status;
 
     NioHttpResponse(NioHttpRequest request, RestStatus status, BytesReference content) {
         super(request.nettyRequest().protocolVersion(), HttpResponseStatus.valueOf(status.getStatus()), ByteBufUtils.toByteBuf(content));
         this.sequence = request.sequence();
         this.request = request;
+        this.status = status;
+    }
+
+    @Override
+    public RestStatus getRestStatus() {
+        return status;
     }
 
     @Override
@@ -42,6 +51,11 @@ public void addHeader(String name, String value) {
         headers().add(name, value);
     }
 
+    @Override
+    public List<String> getAllHeaders(String name) {
+        return headers().getAll(name);
+    }
+
     @Override
     public boolean containsHeader(String name) {
         return headers().contains(name);
diff --git a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/NioHttpServerTransport.java b/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/NioHttpServerTransport.java
index fa0f3e9572c9..c8a3673c9619 100644
--- a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/NioHttpServerTransport.java
+++ b/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/NioHttpServerTransport.java
@@ -19,14 +19,11 @@
 
 package org.elasticsearch.http.nio;
 
-import io.netty.handler.codec.http.HttpMethod;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.elasticsearch.ElasticsearchException;
-import org.elasticsearch.common.Strings;
 import org.elasticsearch.common.network.NetworkService;
 import org.elasticsearch.common.settings.Settings;
-import org.elasticsearch.common.settings.SettingsException;
 import org.elasticsearch.common.unit.ByteSizeValue;
 import org.elasticsearch.common.util.BigArrays;
 import org.elasticsearch.common.util.PageCacheRecycler;
@@ -34,8 +31,6 @@
 import org.elasticsearch.http.AbstractHttpServerTransport;
 import org.elasticsearch.http.HttpChannel;
 import org.elasticsearch.http.HttpServerChannel;
-import org.elasticsearch.http.nio.cors.NioCorsConfig;
-import org.elasticsearch.http.nio.cors.NioCorsConfigBuilder;
 import org.elasticsearch.nio.BytesChannelContext;
 import org.elasticsearch.nio.ChannelFactory;
 import org.elasticsearch.nio.InboundChannelBuffer;
@@ -44,7 +39,6 @@
 import org.elasticsearch.nio.NioSocketChannel;
 import org.elasticsearch.nio.ServerChannelContext;
 import org.elasticsearch.nio.SocketChannelContext;
-import org.elasticsearch.rest.RestUtils;
 import org.elasticsearch.threadpool.ThreadPool;
 import org.elasticsearch.transport.nio.NioGroupFactory;
 import org.elasticsearch.transport.nio.PageAllocator;
@@ -53,17 +47,8 @@
 import java.net.InetSocketAddress;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
-import java.util.Arrays;
 import java.util.function.Consumer;
-import java.util.regex.Pattern;
-import java.util.regex.PatternSyntaxException;
-
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_CREDENTIALS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_HEADERS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_METHODS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_ORIGIN;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ENABLED;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_MAX_AGE;
+
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_MAX_CHUNK_SIZE;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_MAX_HEADER_SIZE;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_MAX_INITIAL_LINE_LENGTH;
@@ -73,12 +58,10 @@
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_TCP_REUSE_ADDRESS;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_TCP_SEND_BUFFER_SIZE;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_PIPELINING_MAX_EVENTS;
-import static org.elasticsearch.http.nio.cors.NioCorsHandler.ANY_ORIGIN;
 
 public class NioHttpServerTransport extends AbstractHttpServerTransport {
     private static final Logger logger = LogManager.getLogger(NioHttpServerTransport.class);
 
-    protected final NioCorsConfig corsConfig;
     protected final PageAllocator pageAllocator;
     private final NioGroupFactory nioGroupFactory;
 
@@ -102,7 +85,6 @@ public NioHttpServerTransport(Settings settings, NetworkService networkService,
         ByteSizeValue maxHeaderSize = SETTING_HTTP_MAX_HEADER_SIZE.get(settings);
         ByteSizeValue maxInitialLineLength = SETTING_HTTP_MAX_INITIAL_LINE_LENGTH.get(settings);
         int pipeliningMaxEvents = SETTING_PIPELINING_MAX_EVENTS.get(settings);
-        this.corsConfig = buildCorsConfig(settings);
 
         this.tcpNoDelay = SETTING_HTTP_TCP_NO_DELAY.get(settings);
         this.tcpKeepAlive = SETTING_HTTP_TCP_KEEP_ALIVE.get(settings);
@@ -155,42 +137,6 @@ protected HttpServerChannel bind(InetSocketAddress socketAddress) throws IOExcep
         return new HttpChannelFactory();
     }
 
-    static NioCorsConfig buildCorsConfig(Settings settings) {
-        if (SETTING_CORS_ENABLED.get(settings) == false) {
-            return NioCorsConfigBuilder.forOrigins().disable().build();
-        }
-        String origin = SETTING_CORS_ALLOW_ORIGIN.get(settings);
-        final NioCorsConfigBuilder builder;
-        if (Strings.isNullOrEmpty(origin)) {
-            builder = NioCorsConfigBuilder.forOrigins();
-        } else if (origin.equals(ANY_ORIGIN)) {
-            builder = NioCorsConfigBuilder.forAnyOrigin();
-        } else {
-            try {
-                Pattern p = RestUtils.checkCorsSettingForRegex(origin);
-                if (p == null) {
-                    builder = NioCorsConfigBuilder.forOrigins(RestUtils.corsSettingAsArray(origin));
-                } else {
-                    builder = NioCorsConfigBuilder.forPattern(p);
-                }
-            } catch (PatternSyntaxException e) {
-                throw new SettingsException("Bad regex in [" + SETTING_CORS_ALLOW_ORIGIN.getKey() + "]: [" + origin + "]", e);
-            }
-        }
-        if (SETTING_CORS_ALLOW_CREDENTIALS.get(settings)) {
-            builder.allowCredentials();
-        }
-        String[] strMethods = Strings.tokenizeToStringArray(SETTING_CORS_ALLOW_METHODS.get(settings), ",");
-        HttpMethod[] methods = Arrays.stream(strMethods)
-            .map(HttpMethod::valueOf)
-            .toArray(HttpMethod[]::new);
-        return builder.allowedRequestMethods(methods)
-            .maxAge(SETTING_CORS_MAX_AGE.get(settings))
-            .allowedRequestHeaders(Strings.tokenizeToStringArray(SETTING_CORS_ALLOW_HEADERS.get(settings), ","))
-            .shortCircuit()
-            .build();
-    }
-
     protected void acceptChannel(NioSocketChannel socketChannel) {
         super.serverAcceptedChannel((HttpChannel) socketChannel);
     }
@@ -205,7 +151,7 @@ private HttpChannelFactory() {
         public NioHttpChannel createChannel(NioSelector selector, SocketChannel channel) throws IOException {
             NioHttpChannel httpChannel = new NioHttpChannel(channel);
             HttpReadWriteHandler httpReadWritePipeline = new HttpReadWriteHandler(httpChannel,NioHttpServerTransport.this,
-                handlingSettings, corsConfig, selector.getTaskScheduler(), threadPool::relativeTimeInMillis);
+                handlingSettings, selector.getTaskScheduler(), threadPool::relativeTimeInMillis);
             Consumer<Exception> exceptionHandler = (e) -> onException(httpChannel, e);
             SocketChannelContext context = new BytesChannelContext(httpChannel, selector, exceptionHandler, httpReadWritePipeline,
                 new InboundChannelBuffer(pageAllocator));
diff --git a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/cors/NioCorsConfig.java b/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/cors/NioCorsConfig.java
deleted file mode 100644
index 1ffffdf0d315..000000000000
--- a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/cors/NioCorsConfig.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- * Licensed to Elasticsearch under one or more contributor
- * license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright
- * ownership. Elasticsearch licenses this file to you under
- * the Apache License, Version 2.0 (the "License"); you may
- * not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.elasticsearch.http.nio.cors;
-
-import io.netty.handler.codec.http.DefaultHttpHeaders;
-import io.netty.handler.codec.http.EmptyHttpHeaders;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.regex.Pattern;
-
-/**
- * Configuration for Cross-Origin Resource Sharing (CORS).
- *
- * This class was lifted from the Netty project:
- *  https://github.com/netty/netty
- */
-public final class NioCorsConfig {
-
-    private final Optional<Set<String>> origins;
-    private final Optional<Pattern> pattern;
-    private final boolean anyOrigin;
-    private final boolean enabled;
-    private final boolean allowCredentials;
-    private final long maxAge;
-    private final Set<HttpMethod> allowedRequestMethods;
-    private final Set<String> allowedRequestHeaders;
-    private final Map<CharSequence, Callable<?>> preflightHeaders;
-    private final boolean shortCircuit;
-
-    NioCorsConfig(final NioCorsConfigBuilder builder) {
-        origins = builder.origins.map(s -> new LinkedHashSet<>(s));
-        pattern = builder.pattern;
-        anyOrigin = builder.anyOrigin;
-        enabled = builder.enabled;
-        allowCredentials = builder.allowCredentials;
-        maxAge = builder.maxAge;
-        allowedRequestMethods = builder.requestMethods;
-        allowedRequestHeaders = builder.requestHeaders;
-        preflightHeaders = builder.preflightHeaders;
-        shortCircuit = builder.shortCircuit;
-    }
-
-    /**
-     * Determines if support for CORS is enabled.
-     *
-     * @return {@code true} if support for CORS is enabled, false otherwise.
-     */
-    public boolean isCorsSupportEnabled() {
-        return enabled;
-    }
-
-    /**
-     * Determines whether a wildcard origin, '*', is supported. This also means that null origins are
-     * supported.
-     *
-     * @return {@code boolean} true if any origin is allowed.
-     */
-    public boolean isAnyOriginSupported() {
-        return anyOrigin;
-    }
-
-    /**
-     * Returns the set of allowed origins.
-     *
-     * @return {@code Set} the allowed origins.
-     */
-    public Optional<Set<String>> origins() {
-        return origins;
-    }
-
-    /**
-     * Returns whether the input origin is allowed by this configuration.
-     *
-     * @return {@code true} if the origin is allowed, otherwise {@code false}
-     */
-    public boolean isOriginAllowed(final String origin) {
-        if (origins.isPresent()) {
-            return origins.get().contains(origin);
-        } else if (pattern.isPresent()) {
-            return pattern.get().matcher(origin).matches();
-        }
-        return false;
-    }
-
-    /**
-     * Determines if credentials are supported for CORS requests.
-     *
-     * By default credentials are not included in CORS requests but if isCredentialsAllowed returns
-     * true credentials will be added to CORS requests. Setting this value to true will set the
-     * CORS 'Access-Control-Allow-Credentials' response header to true.
-     *
-     * Please note that credentials support needs to be enabled on the client side as well.
-     * The client needs to opt-in to send credentials by calling:
-     * <pre>
-     * xhr.withCredentials = true;
-     * </pre>
-     * The default value for 'withCredentials' is false in which case no credentials are sent.
-     * Setting this to true will included cookies in cross origin requests.
-     *
-     * @return {@code true} if credentials are supported.
-     */
-    public boolean isCredentialsAllowed() {
-        return allowCredentials;
-    }
-
-    /**
-     * Gets the maxAge setting.
-     *
-     * When making a preflight request the client has to perform two request with can be inefficient.
-     * This setting will set the CORS 'Access-Control-Max-Age' response header and enables the
-     * caching of the preflight response for the specified time. During this time no preflight
-     * request will be made.
-     *
-     * @return {@code long} the time in seconds that a preflight request may be cached.
-     */
-    public long maxAge() {
-        return maxAge;
-    }
-
-    /**
-     * Returns the allowed set of Request Methods. The Http methods that should be returned in the
-     * CORS 'Access-Control-Request-Method' response header.
-     *
-     * @return {@code Set} of {@link HttpMethod}s that represent the allowed Request Methods.
-     */
-    public Set<HttpMethod> allowedRequestMethods() {
-        return Collections.unmodifiableSet(allowedRequestMethods);
-    }
-
-    /**
-     * Returns the allowed set of Request Headers.
-     *
-     * The header names returned from this method will be used to set the CORS
-     * 'Access-Control-Allow-Headers' response header.
-     *
-     * @return {@code Set<String>} of strings that represent the allowed Request Headers.
-     */
-    public Set<String> allowedRequestHeaders() {
-        return Collections.unmodifiableSet(allowedRequestHeaders);
-    }
-
-    /**
-     * Returns HTTP response headers that should be added to a CORS preflight response.
-     *
-     * @return {@link HttpHeaders} the HTTP response headers to be added.
-     */
-    public HttpHeaders preflightResponseHeaders() {
-        if (preflightHeaders.isEmpty()) {
-            return EmptyHttpHeaders.INSTANCE;
-        }
-        final HttpHeaders preflightHeaders = new DefaultHttpHeaders();
-        for (Map.Entry<CharSequence, Callable<?>> entry : this.preflightHeaders.entrySet()) {
-            final Object value = getValue(entry.getValue());
-            if (value instanceof Iterable) {
-                preflightHeaders.add(entry.getKey().toString(), (Iterable<?>) value);
-            } else {
-                preflightHeaders.add(entry.getKey().toString(), value);
-            }
-        }
-        return preflightHeaders;
-    }
-
-    /**
-     * Determines whether a CORS request should be rejected if it's invalid before being
-     * further processing.
-     *
-     * CORS headers are set after a request is processed. This may not always be desired
-     * and this setting will check that the Origin is valid and if it is not valid no
-     * further processing will take place, and a error will be returned to the calling client.
-     *
-     * @return {@code true} if a CORS request should short-circuit upon receiving an invalid Origin header.
-     */
-    public boolean isShortCircuit() {
-        return shortCircuit;
-    }
-
-    private static <T> T getValue(final Callable<T> callable) {
-        try {
-            return callable.call();
-        } catch (final Exception e) {
-            throw new IllegalStateException("Could not generate value for callable [" + callable + ']', e);
-        }
-    }
-
-    @Override
-    public String toString() {
-        return  "CorsConfig[enabled=" + enabled +
-            ", origins=" + origins +
-            ", anyOrigin=" + anyOrigin +
-            ", isCredentialsAllowed=" + allowCredentials +
-            ", maxAge=" + maxAge +
-            ", allowedRequestMethods=" + allowedRequestMethods +
-            ", allowedRequestHeaders=" + allowedRequestHeaders +
-            ", preflightHeaders=" + preflightHeaders + ']';
-    }
-
-}
diff --git a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/cors/NioCorsConfigBuilder.java b/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/cors/NioCorsConfigBuilder.java
deleted file mode 100644
index 62eda913b0ac..000000000000
--- a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/cors/NioCorsConfigBuilder.java
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
- * Licensed to Elasticsearch under one or more contributor
- * license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright
- * ownership. Elasticsearch licenses this file to you under
- * the Apache License, Version 2.0 (the "License"); you may
- * not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.elasticsearch.http.nio.cors;
-
-import io.netty.handler.codec.http.HttpMethod;
-
-import java.util.Arrays;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.regex.Pattern;
-
-/**
- * Builder used to configure and build a {@link NioCorsConfig} instance.
- *
- * This class was lifted from the Netty project:
- *  https://github.com/netty/netty
- */
-public final class NioCorsConfigBuilder {
-
-    /**
-     * Creates a Builder instance with it's origin set to '*'.
-     *
-     * @return Builder to support method chaining.
-     */
-    public static NioCorsConfigBuilder forAnyOrigin() {
-        return new NioCorsConfigBuilder();
-    }
-
-    /**
-     * Create a {@link NioCorsConfigBuilder} instance with the specified pattern origin.
-     *
-     * @param pattern the regular expression pattern to match incoming origins on.
-     * @return {@link NioCorsConfigBuilder} with the configured origin pattern.
-     */
-    public static NioCorsConfigBuilder forPattern(final Pattern pattern) {
-        if (pattern == null) {
-            throw new IllegalArgumentException("CORS pattern cannot be null");
-        }
-        return new NioCorsConfigBuilder(pattern);
-    }
-
-    /**
-     * Creates a {@link NioCorsConfigBuilder} instance with the specified origins.
-     *
-     * @return {@link NioCorsConfigBuilder} to support method chaining.
-     */
-    public static NioCorsConfigBuilder forOrigins(final String... origins) {
-        return new NioCorsConfigBuilder(origins);
-    }
-
-    Optional<Set<String>> origins;
-    Optional<Pattern> pattern;
-    final boolean anyOrigin;
-    boolean enabled = true;
-    boolean allowCredentials;
-    long maxAge;
-    final Set<HttpMethod> requestMethods = new HashSet<>();
-    final Set<String> requestHeaders = new HashSet<>();
-    final Map<CharSequence, Callable<?>> preflightHeaders = new HashMap<>();
-    boolean shortCircuit;
-
-    /**
-     * Creates a new Builder instance with the origin passed in.
-     *
-     * @param origins the origin to be used for this builder.
-     */
-    NioCorsConfigBuilder(final String... origins) {
-        this.origins = Optional.of(new LinkedHashSet<>(Arrays.asList(origins)));
-        pattern = Optional.empty();
-        anyOrigin = false;
-    }
-
-    /**
-     * Creates a new Builder instance allowing any origin, "*" which is the
-     * wildcard origin.
-     *
-     */
-    NioCorsConfigBuilder() {
-        anyOrigin = true;
-        origins = Optional.empty();
-        pattern = Optional.empty();
-    }
-
-    /**
-     * Creates a new Builder instance allowing any origin that matches the pattern.
-     *
-     * @param pattern the pattern to match against for incoming origins.
-     */
-    NioCorsConfigBuilder(final Pattern pattern) {
-        this.pattern = Optional.of(pattern);
-        origins = Optional.empty();
-        anyOrigin = false;
-    }
-
-    /**
-     * Disables CORS support.
-     *
-     * @return {@link NioCorsConfigBuilder} to support method chaining.
-     */
-    public NioCorsConfigBuilder disable() {
-        enabled = false;
-        return this;
-    }
-
-    /**
-     * By default cookies are not included in CORS requests, but this method will enable cookies to
-     * be added to CORS requests. Calling this method will set the CORS 'Access-Control-Allow-Credentials'
-     * response header to true.
-     *
-     * Please note, that cookie support needs to be enabled on the client side as well.
-     * The client needs to opt-in to send cookies by calling:
-     * <pre>
-     * xhr.withCredentials = true;
-     * </pre>
-     * The default value for 'withCredentials' is false in which case no cookies are sent.
-     * Setting this to true will included cookies in cross origin requests.
-     *
-     * @return {@link NioCorsConfigBuilder} to support method chaining.
-     */
-    public NioCorsConfigBuilder allowCredentials() {
-        allowCredentials = true;
-        return this;
-    }
-
-    /**
-     * When making a preflight request the client has to perform two request with can be inefficient.
-     * This setting will set the CORS 'Access-Control-Max-Age' response header and enables the
-     * caching of the preflight response for the specified time. During this time no preflight
-     * request will be made.
-     *
-     * @param max the maximum time, in seconds, that the preflight response may be cached.
-     * @return {@link NioCorsConfigBuilder} to support method chaining.
-     */
-    public NioCorsConfigBuilder maxAge(final long max) {
-        maxAge = max;
-        return this;
-    }
-
-    /**
-     * Specifies the allowed set of HTTP Request Methods that should be returned in the
-     * CORS 'Access-Control-Request-Method' response header.
-     *
-     * @param methods the {@link HttpMethod}s that should be allowed.
-     * @return {@link NioCorsConfigBuilder} to support method chaining.
-     */
-    public NioCorsConfigBuilder allowedRequestMethods(final HttpMethod... methods) {
-        requestMethods.addAll(Arrays.asList(methods));
-        return this;
-    }
-
-    /**
-     * Specifies the if headers that should be returned in the CORS 'Access-Control-Allow-Headers'
-     * response header.
-     *
-     * If a client specifies headers on the request, for example by calling:
-     * <pre>
-     * xhr.setRequestHeader('My-Custom-Header', "SomeValue");
-     * </pre>
-     * the server will receive the above header name in the 'Access-Control-Request-Headers' of the
-     * preflight request. The server will then decide if it allows this header to be sent for the
-     * real request (remember that a preflight is not the real request but a request asking the server
-     * if it allow a request).
-     *
-     * @param headers the headers to be added to the preflight 'Access-Control-Allow-Headers' response header.
-     * @return {@link NioCorsConfigBuilder} to support method chaining.
-     */
-    public NioCorsConfigBuilder allowedRequestHeaders(final String... headers) {
-        requestHeaders.addAll(Arrays.asList(headers));
-        return this;
-    }
-
-    /**
-     * Specifies that a CORS request should be rejected if it's invalid before being
-     * further processing.
-     *
-     * CORS headers are set after a request is processed. This may not always be desired
-     * and this setting will check that the Origin is valid and if it is not valid no
-     * further processing will take place, and a error will be returned to the calling client.
-     *
-     * @return {@link NioCorsConfigBuilder} to support method chaining.
-     */
-    public NioCorsConfigBuilder shortCircuit() {
-        shortCircuit = true;
-        return this;
-    }
-
-    /**
-     * Builds a {@link NioCorsConfig} with settings specified by previous method calls.
-     *
-     * @return {@link NioCorsConfig} the configured CorsConfig instance.
-     */
-    public NioCorsConfig build() {
-        if (preflightHeaders.isEmpty()) {
-            preflightHeaders.put("date", DateValueGenerator.INSTANCE);
-            preflightHeaders.put("content-length", new ConstantValueGenerator("0"));
-        }
-        return new NioCorsConfig(this);
-    }
-
-    /**
-     * This class is used for preflight HTTP response values that do not need to be
-     * generated, but instead the value is "static" in that the same value will be returned
-     * for each call.
-     */
-    private static final class ConstantValueGenerator implements Callable<Object> {
-
-        private final Object value;
-
-        /**
-         * Sole constructor.
-         *
-         * @param value the value that will be returned when the call method is invoked.
-         */
-        private ConstantValueGenerator(final Object value) {
-            if (value == null) {
-                throw new IllegalArgumentException("value must not be null");
-            }
-            this.value = value;
-        }
-
-        @Override
-        public Object call() {
-            return value;
-        }
-    }
-
-    /**
-     * This callable is used for the DATE preflight HTTP response HTTP header.
-     * It's value must be generated when the response is generated, hence will be
-     * different for every call.
-     */
-    private static final class DateValueGenerator implements Callable<Date> {
-
-        static final DateValueGenerator INSTANCE = new DateValueGenerator();
-
-        @Override
-        public Date call() throws Exception {
-            return new Date();
-        }
-    }
-
-}
diff --git a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/cors/NioCorsHandler.java b/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/cors/NioCorsHandler.java
deleted file mode 100644
index dfb531992f8e..000000000000
--- a/plugins/transport-nio/src/main/java/org/elasticsearch/http/nio/cors/NioCorsHandler.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * Licensed to Elasticsearch under one or more contributor
- * license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright
- * ownership. Elasticsearch licenses this file to you under
- * the Apache License, Version 2.0 (the "License"); you may
- * not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.elasticsearch.http.nio.cors;
-
-import io.netty.channel.ChannelDuplexHandler;
-import io.netty.channel.ChannelFutureListener;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelPromise;
-import io.netty.handler.codec.http.DefaultFullHttpResponse;
-import io.netty.handler.codec.http.FullHttpRequest;
-import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpResponseStatus;
-import org.elasticsearch.common.Strings;
-import org.elasticsearch.http.nio.NioHttpResponse;
-
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
-
-/**
- * Handles <a href="http://www.w3.org/TR/cors/">Cross Origin Resource Sharing</a> (CORS) requests.
- * <p>
- * This handler can be configured using a {@link NioCorsConfig}, please
- * refer to this class for details about the configuration options available.
- *
- * This code was borrowed from Netty 4 and refactored to work for Elasticsearch's Netty 3 setup.
- */
-public class NioCorsHandler extends ChannelDuplexHandler {
-
-    public static final String ANY_ORIGIN = "*";
-    private static Pattern SCHEME_PATTERN = Pattern.compile("^https?://");
-
-    private final NioCorsConfig config;
-    private FullHttpRequest request;
-
-    /**
-     * Creates a new instance with the specified {@link NioCorsConfig}.
-     */
-    public NioCorsHandler(final NioCorsConfig config) {
-        if (config == null) {
-            throw new NullPointerException();
-        }
-        this.config = config;
-    }
-
-    @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-        assert msg instanceof FullHttpRequest : "Invalid message type: " + msg.getClass();
-        if (config.isCorsSupportEnabled()) {
-            request = (FullHttpRequest) msg;
-            if (isPreflightRequest(request)) {
-                try {
-                    handlePreflight(ctx, request);
-                    return;
-                } finally {
-                    releaseRequest();
-                }
-            }
-            if (config.isShortCircuit() && !validateOrigin()) {
-                try {
-                    forbidden(ctx, request);
-                    return;
-                } finally {
-                    releaseRequest();
-                }
-            }
-        }
-        ctx.fireChannelRead(msg);
-    }
-
-    @Override
-    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
-        assert msg instanceof NioHttpResponse : "Invalid message type: " + msg.getClass();
-        NioHttpResponse response = (NioHttpResponse) msg;
-        setCorsResponseHeaders(response.getRequest().nettyRequest(), response, config);
-        ctx.write(response, promise);
-    }
-
-    public static void setCorsResponseHeaders(HttpRequest request, HttpResponse resp, NioCorsConfig config) {
-        if (!config.isCorsSupportEnabled()) {
-            return;
-        }
-        String originHeader = request.headers().get(HttpHeaderNames.ORIGIN);
-        if (!Strings.isNullOrEmpty(originHeader)) {
-            final String originHeaderVal;
-            if (config.isAnyOriginSupported()) {
-                originHeaderVal = ANY_ORIGIN;
-            } else if (config.isOriginAllowed(originHeader) || isSameOrigin(originHeader, request.headers().get(HttpHeaderNames.HOST))) {
-                originHeaderVal = originHeader;
-            } else {
-                originHeaderVal = null;
-            }
-            if (originHeaderVal != null) {
-                resp.headers().add(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, originHeaderVal);
-            }
-        }
-        if (config.isCredentialsAllowed()) {
-            resp.headers().add(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
-        }
-    }
-
-    private void releaseRequest() {
-        request.release();
-        request = null;
-    }
-
-    private void handlePreflight(final ChannelHandlerContext ctx, final HttpRequest request) {
-        final HttpResponse response = new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.OK, true, true);
-        if (setOrigin(response)) {
-            setAllowMethods(response);
-            setAllowHeaders(response);
-            setAllowCredentials(response);
-            setMaxAge(response);
-            setPreflightHeaders(response);
-            ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
-        } else {
-            forbidden(ctx, request);
-        }
-    }
-
-    private static void forbidden(final ChannelHandlerContext ctx, final HttpRequest request) {
-        ctx.writeAndFlush(new DefaultFullHttpResponse(request.protocolVersion(), HttpResponseStatus.FORBIDDEN))
-            .addListener(ChannelFutureListener.CLOSE);
-    }
-
-    private static boolean isSameOrigin(final String origin, final String host) {
-        if (Strings.isNullOrEmpty(host) == false) {
-            // strip protocol from origin
-            final String originDomain = SCHEME_PATTERN.matcher(origin).replaceFirst("");
-            if (host.equals(originDomain)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * This is a non CORS specification feature which enables the setting of preflight
-     * response headers that might be required by intermediaries.
-     *
-     * @param response the HttpResponse to which the preflight response headers should be added.
-     */
-    private void setPreflightHeaders(final HttpResponse response) {
-        response.headers().add(config.preflightResponseHeaders());
-    }
-
-    private boolean setOrigin(final HttpResponse response) {
-        final String origin = request.headers().get(HttpHeaderNames.ORIGIN);
-        if (!Strings.isNullOrEmpty(origin)) {
-            if (config.isAnyOriginSupported()) {
-                if (config.isCredentialsAllowed()) {
-                    echoRequestOrigin(response);
-                    setVaryHeader(response);
-                } else {
-                    setAnyOrigin(response);
-                }
-                return true;
-            }
-            if (config.isOriginAllowed(origin)) {
-                setOrigin(response, origin);
-                setVaryHeader(response);
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private boolean validateOrigin() {
-        if (config.isAnyOriginSupported()) {
-            return true;
-        }
-
-        final String origin = request.headers().get(HttpHeaderNames.ORIGIN);
-        if (Strings.isNullOrEmpty(origin)) {
-            // Not a CORS request so we cannot validate it. It may be a non CORS request.
-            return true;
-        }
-
-        // if the origin is the same as the host of the request, then allow
-        if (isSameOrigin(origin, request.headers().get(HttpHeaderNames.HOST))) {
-            return true;
-        }
-
-        return config.isOriginAllowed(origin);
-    }
-
-    private void echoRequestOrigin(final HttpResponse response) {
-        setOrigin(response, request.headers().get(HttpHeaderNames.ORIGIN));
-    }
-
-    private static void setVaryHeader(final HttpResponse response) {
-        response.headers().set(HttpHeaderNames.VARY, HttpHeaderNames.ORIGIN);
-    }
-
-    private static void setAnyOrigin(final HttpResponse response) {
-        setOrigin(response, ANY_ORIGIN);
-    }
-
-    private static void setOrigin(final HttpResponse response, final String origin) {
-        response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, origin);
-    }
-
-    private void setAllowCredentials(final HttpResponse response) {
-        if (config.isCredentialsAllowed()
-            && !response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN).equals(ANY_ORIGIN)) {
-            response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
-        }
-    }
-
-    private static boolean isPreflightRequest(final HttpRequest request) {
-        final HttpHeaders headers = request.headers();
-        return request.method().equals(HttpMethod.OPTIONS) &&
-            headers.contains(HttpHeaderNames.ORIGIN) &&
-            headers.contains(HttpHeaderNames.ACCESS_CONTROL_REQUEST_METHOD);
-    }
-
-    private void setAllowMethods(final HttpResponse response) {
-        response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_METHODS, config.allowedRequestMethods().stream()
-            .map(m -> m.name().trim())
-            .collect(Collectors.toList()));
-    }
-
-    private void setAllowHeaders(final HttpResponse response) {
-        response.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, config.allowedRequestHeaders());
-    }
-
-    private void setMaxAge(final HttpResponse response) {
-        response.headers().set(HttpHeaderNames.ACCESS_CONTROL_MAX_AGE, config.maxAge());
-    }
-
-}
diff --git a/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/HttpReadWriteHandlerTests.java b/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/HttpReadWriteHandlerTests.java
index 93a846ea90f8..ebf5e07ff444 100644
--- a/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/HttpReadWriteHandlerTests.java
+++ b/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/HttpReadWriteHandlerTests.java
@@ -41,11 +41,6 @@
 import org.elasticsearch.http.HttpHandlingSettings;
 import org.elasticsearch.http.HttpReadTimeoutException;
 import org.elasticsearch.http.HttpRequest;
-import org.elasticsearch.http.HttpResponse;
-import org.elasticsearch.http.HttpTransportSettings;
-import org.elasticsearch.http.nio.cors.NioCorsConfig;
-import org.elasticsearch.http.nio.cors.NioCorsConfigBuilder;
-import org.elasticsearch.http.nio.cors.NioCorsHandler;
 import org.elasticsearch.nio.FlushOperation;
 import org.elasticsearch.nio.InboundChannelBuffer;
 import org.elasticsearch.nio.SocketChannelContext;
@@ -63,16 +58,8 @@
 import java.util.List;
 import java.util.function.BiConsumer;
 
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_CREDENTIALS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_METHODS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_ORIGIN;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ENABLED;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_MAX_CONTENT_LENGTH;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_HTTP_READ_TIMEOUT;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.is;
-import static org.hamcrest.Matchers.notNullValue;
-import static org.hamcrest.Matchers.nullValue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.atLeastOnce;
@@ -98,8 +85,7 @@ public void setMocks() {
         channel = mock(NioHttpChannel.class);
         taskScheduler = mock(TaskScheduler.class);
 
-        NioCorsConfig corsConfig = NioCorsConfigBuilder.forAnyOrigin().build();
-        handler = new HttpReadWriteHandler(channel, transport, httpHandlingSettings, corsConfig, taskScheduler, System::nanoTime);
+        handler = new HttpReadWriteHandler(channel, transport, httpHandlingSettings, taskScheduler, System::nanoTime);
         handler.channelRegistered();
     }
 
@@ -205,135 +191,16 @@ public void testEncodeHttpResponse() throws IOException {
         }
     }
 
-    public void testCorsEnabledWithoutAllowOrigins() throws IOException {
-        // Set up an HTTP transport with only the CORS enabled setting
-        Settings settings = Settings.builder()
-            .put(HttpTransportSettings.SETTING_CORS_ENABLED.getKey(), true)
-            .build();
-        FullHttpResponse response = executeCorsRequest(settings, "remote-host", "request-host");
-        try {
-            // inspect response and validate
-            assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), nullValue());
-        } finally {
-            response.release();
-        }
-    }
-
-    public void testCorsEnabledWithAllowOrigins() throws IOException {
-        final String originValue = "remote-host";
-        // create an HTTP transport with CORS enabled and allow origin configured
-        Settings settings = Settings.builder()
-            .put(SETTING_CORS_ENABLED.getKey(), true)
-            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue)
-            .build();
-        FullHttpResponse response = executeCorsRequest(settings, originValue, "request-host");
-        try {
-            // inspect response and validate
-            assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-            String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-            assertThat(allowedOrigins, is(originValue));
-        } finally {
-            response.release();
-        }
-    }
-
-    public void testCorsAllowOriginWithSameHost() throws IOException {
-        String originValue = "remote-host";
-        String host = "remote-host";
-        // create an HTTP transport with CORS enabled
-        Settings settings = Settings.builder()
-            .put(SETTING_CORS_ENABLED.getKey(), true)
-            .build();
-        FullHttpResponse response = executeCorsRequest(settings, originValue, host);
-        String allowedOrigins;
-        try {
-            // inspect response and validate
-            assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-            allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-            assertThat(allowedOrigins, is(originValue));
-        } finally {
-            response.release();
-        }
-        originValue = "http://" + originValue;
-        response = executeCorsRequest(settings, originValue, host);
-        try {
-            assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-            allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-            assertThat(allowedOrigins, is(originValue));
-        } finally {
-            response.release();
-        }
-
-        originValue = originValue + ":5555";
-        host = host + ":5555";
-        response = executeCorsRequest(settings, originValue, host);
-        try {
-            assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-            allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-            assertThat(allowedOrigins, is(originValue));
-        } finally {
-            response.release();
-        }
-        originValue = originValue.replace("http", "https");
-        response = executeCorsRequest(settings, originValue, host);
-        try {
-            assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-            allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-            assertThat(allowedOrigins, is(originValue));
-        } finally {
-            response.release();
-        }
-    }
-
-    public void testThatStringLiteralWorksOnMatch() throws IOException {
-        final String originValue = "remote-host";
-        Settings settings = Settings.builder()
-            .put(SETTING_CORS_ENABLED.getKey(), true)
-            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue)
-            .put(SETTING_CORS_ALLOW_METHODS.getKey(), "get, options, post")
-            .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true)
-            .build();
-        FullHttpResponse response = executeCorsRequest(settings, originValue, "request-host");
-        try {
-            // inspect response and validate
-            assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-            String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-            assertThat(allowedOrigins, is(originValue));
-            assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS), equalTo("true"));
-        } finally {
-            response.release();
-        }
-    }
-
-    public void testThatAnyOriginWorks() throws IOException {
-        final String originValue = NioCorsHandler.ANY_ORIGIN;
-        Settings settings = Settings.builder()
-            .put(SETTING_CORS_ENABLED.getKey(), true)
-            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue)
-            .build();
-        FullHttpResponse response = executeCorsRequest(settings, originValue, "request-host");
-        try {
-            // inspect response and validate
-            assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-            String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-            assertThat(allowedOrigins, is(originValue));
-            assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS), nullValue());
-        } finally {
-            response.release();
-        }
-    }
-
     @SuppressWarnings("unchecked")
     public void testReadTimeout() throws IOException {
         TimeValue timeValue = TimeValue.timeValueMillis(500);
         Settings settings = Settings.builder().put(SETTING_HTTP_READ_TIMEOUT.getKey(), timeValue).build();
         HttpHandlingSettings httpHandlingSettings = HttpHandlingSettings.fromSettings(settings);
 
-        NioCorsConfig corsConfig = NioCorsConfigBuilder.forAnyOrigin().build();
         TaskScheduler taskScheduler = new TaskScheduler();
 
         Iterator<Integer> timeValues = Arrays.asList(0, 2, 4, 6, 8).iterator();
-        handler = new HttpReadWriteHandler(channel, transport, httpHandlingSettings, corsConfig, taskScheduler, timeValues::next);
+        handler = new HttpReadWriteHandler(channel, transport, httpHandlingSettings, taskScheduler, timeValues::next);
         handler.channelRegistered();
 
         prepareHandlerForResponse(handler);
@@ -376,33 +243,6 @@ private static NioHttpResponse emptyGetResponse(int sequenceNumber) {
         return httpResponse;
     }
 
-    private FullHttpResponse executeCorsRequest(final Settings settings, final String originValue, final String host) throws IOException {
-        HttpHandlingSettings httpSettings = HttpHandlingSettings.fromSettings(settings);
-        NioCorsConfig corsConfig = NioHttpServerTransport.buildCorsConfig(settings);
-        HttpReadWriteHandler handler = new HttpReadWriteHandler(channel, transport, httpSettings, corsConfig, taskScheduler,
-            System::nanoTime);
-        handler.channelRegistered();
-        prepareHandlerForResponse(handler);
-        DefaultFullHttpRequest httpRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");
-        if (originValue != null) {
-            httpRequest.headers().add(HttpHeaderNames.ORIGIN, originValue);
-        }
-        httpRequest.headers().add(HttpHeaderNames.HOST, host);
-        NioHttpRequest nioHttpRequest = new NioHttpRequest(httpRequest, 0);
-        BytesArray content = new BytesArray("content");
-        HttpResponse response = nioHttpRequest.createResponse(RestStatus.OK, content);
-        response.addHeader("Content-Length", Integer.toString(content.length()));
-
-        SocketChannelContext context = mock(SocketChannelContext.class);
-        List<FlushOperation> flushOperations = handler.writeToBytes(handler.createWriteOperation(context, response, (v, e) -> {}));
-        handler.close();
-        FlushOperation flushOperation = flushOperations.get(0);
-        ((ChannelPromise) flushOperation.getListener()).setSuccess();
-        return responseDecoder.decode(Unpooled.wrappedBuffer(flushOperation.getBuffersToWrite()));
-    }
-
-
-
     private void prepareHandlerForResponse(HttpReadWriteHandler handler) throws IOException {
         HttpMethod method = randomBoolean() ? HttpMethod.GET : HttpMethod.HEAD;
         HttpVersion version = randomBoolean() ? HttpVersion.HTTP_1_0 : HttpVersion.HTTP_1_1;
diff --git a/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/NioHttpClient.java b/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/NioHttpClient.java
index ed55007f3ba6..cabbac0342c8 100644
--- a/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/NioHttpClient.java
+++ b/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/NioHttpClient.java
@@ -110,7 +110,7 @@
         return sendRequests(remoteAddress, requests);
     }
 
-    public final FullHttpResponse post(InetSocketAddress remoteAddress, FullHttpRequest httpRequest) throws InterruptedException {
+    public final FullHttpResponse send(InetSocketAddress remoteAddress, FullHttpRequest httpRequest) throws InterruptedException {
         Collection<FullHttpResponse> responses = sendRequests(remoteAddress, Collections.singleton(httpRequest));
         assert responses.size() == 1 : "expected 1 and only 1 http response";
         return responses.iterator().next();
@@ -271,7 +271,7 @@ public int consumeReads(InboundChannelBuffer channelBuffer) throws IOException {
             int bytesConsumed = adaptor.read(channelBuffer.sliceAndRetainPagesTo(channelBuffer.getIndex()));
             Object message;
             while ((message = adaptor.pollInboundMessage()) != null) {
-                handleRequest(message);
+                handleResponse(message);
             }
 
             return bytesConsumed;
@@ -291,7 +291,7 @@ public void close() throws IOException {
             }
         }
 
-        private void handleRequest(Object message) {
+        private void handleResponse(Object message) {
             final FullHttpResponse response = (FullHttpResponse) message;
             DefaultFullHttpResponse newResponse = new DefaultFullHttpResponse(response.protocolVersion(),
                 response.status(),
diff --git a/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/NioHttpServerTransportTests.java b/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/NioHttpServerTransportTests.java
index 0b470fda00a6..2d92f4db60cc 100644
--- a/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/NioHttpServerTransportTests.java
+++ b/plugins/transport-nio/src/test/java/org/elasticsearch/http/nio/NioHttpServerTransportTests.java
@@ -32,12 +32,10 @@
 import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http.HttpVersion;
 import org.elasticsearch.ElasticsearchException;
-import org.elasticsearch.common.Strings;
 import org.elasticsearch.common.bytes.BytesArray;
 import org.elasticsearch.common.network.NetworkService;
 import org.elasticsearch.common.settings.Setting;
 import org.elasticsearch.common.settings.Settings;
-import org.elasticsearch.common.settings.SettingsException;
 import org.elasticsearch.common.transport.TransportAddress;
 import org.elasticsearch.common.unit.ByteSizeValue;
 import org.elasticsearch.common.unit.TimeValue;
@@ -45,10 +43,10 @@
 import org.elasticsearch.common.util.MockPageCacheRecycler;
 import org.elasticsearch.common.util.concurrent.ThreadContext;
 import org.elasticsearch.http.BindHttpException;
+import org.elasticsearch.http.CorsHandler;
 import org.elasticsearch.http.HttpServerTransport;
 import org.elasticsearch.http.HttpTransportSettings;
 import org.elasticsearch.http.NullDispatcher;
-import org.elasticsearch.http.nio.cors.NioCorsConfig;
 import org.elasticsearch.indices.breaker.NoneCircuitBreakerService;
 import org.elasticsearch.nio.NioSocketChannel;
 import org.elasticsearch.rest.BytesRestResponse;
@@ -64,22 +62,13 @@
 import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
-import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashSet;
-import java.util.Set;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.regex.PatternSyntaxException;
-import java.util.stream.Collectors;
 
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_CREDENTIALS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_HEADERS;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_METHODS;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_ORIGIN;
 import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ENABLED;
-import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_MAX_AGE;
 import static org.elasticsearch.rest.RestStatus.BAD_REQUEST;
 import static org.elasticsearch.rest.RestStatus.OK;
 import static org.hamcrest.Matchers.containsString;
@@ -115,48 +104,6 @@ public void shutdown() throws Exception {
         bigArrays = null;
     }
 
-    public void testCorsConfig() {
-        final Set<String> methods = new HashSet<>(Arrays.asList("get", "options", "post"));
-        final Set<String> headers = new HashSet<>(Arrays.asList("Content-Type", "Content-Length"));
-        final String prefix = randomBoolean() ? " " : ""; // sometimes have a leading whitespace between comma delimited elements
-        final Settings settings = Settings.builder()
-            .put(SETTING_CORS_ENABLED.getKey(), true)
-            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "*")
-            .put(SETTING_CORS_ALLOW_METHODS.getKey(), Strings.collectionToDelimitedString(methods, ",", prefix, ""))
-            .put(SETTING_CORS_ALLOW_HEADERS.getKey(), Strings.collectionToDelimitedString(headers, ",", prefix, ""))
-            .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true)
-            .build();
-        final NioCorsConfig corsConfig = NioHttpServerTransport.buildCorsConfig(settings);
-        assertTrue(corsConfig.isAnyOriginSupported());
-        assertEquals(headers, corsConfig.allowedRequestHeaders());
-        assertEquals(methods, corsConfig.allowedRequestMethods().stream().map(HttpMethod::name).collect(Collectors.toSet()));
-    }
-
-    public void testCorsConfigWithDefaults() {
-        final Set<String> methods = Strings.commaDelimitedListToSet(SETTING_CORS_ALLOW_METHODS.getDefault(Settings.EMPTY));
-        final Set<String> headers = Strings.commaDelimitedListToSet(SETTING_CORS_ALLOW_HEADERS.getDefault(Settings.EMPTY));
-        final long maxAge = SETTING_CORS_MAX_AGE.getDefault(Settings.EMPTY);
-        final Settings settings = Settings.builder().put(SETTING_CORS_ENABLED.getKey(), true).build();
-        final NioCorsConfig corsConfig = NioHttpServerTransport.buildCorsConfig(settings);
-        assertFalse(corsConfig.isAnyOriginSupported());
-        assertEquals(Collections.emptySet(), corsConfig.origins().get());
-        assertEquals(headers, corsConfig.allowedRequestHeaders());
-        assertEquals(methods, corsConfig.allowedRequestMethods().stream().map(HttpMethod::name).collect(Collectors.toSet()));
-        assertEquals(maxAge, corsConfig.maxAge());
-        assertFalse(corsConfig.isCredentialsAllowed());
-    }
-
-    public void testCorsConfigWithBadRegex() {
-        final Settings settings = Settings.builder()
-            .put(SETTING_CORS_ENABLED.getKey(), true)
-            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "/[*/")
-            .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true)
-            .build();
-        SettingsException e = expectThrows(SettingsException.class, () -> NioHttpServerTransport.buildCorsConfig(settings));
-        assertThat(e.getMessage(), containsString("Bad regex in [http.cors.allow-origin]: [/[*/]"));
-        assertThat(e.getCause(), instanceOf(PatternSyntaxException.class));
-    }
-
     /**
      * Test that {@link NioHttpServerTransport} supports the "Expect: 100-continue" HTTP header
      * @throws InterruptedException if the client communication with the server is interrupted
@@ -215,13 +162,13 @@ public void dispatchBadRequest(RestRequest request, RestChannel channel, ThreadC
                 request.headers().set(HttpHeaderNames.EXPECT, expectation);
                 HttpUtil.setContentLength(request, contentLength);
 
-                final FullHttpResponse response = client.post(remoteAddress.address(), request);
+                final FullHttpResponse response = client.send(remoteAddress.address(), request);
                 try {
                     assertThat(response.status(), equalTo(expectedStatus));
                     if (expectedStatus.equals(HttpResponseStatus.CONTINUE)) {
                         final FullHttpRequest continuationRequest =
                             new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/", Unpooled.EMPTY_BUFFER);
-                        final FullHttpResponse continuationResponse = client.post(remoteAddress.address(), continuationRequest);
+                        final FullHttpResponse continuationResponse = client.send(remoteAddress.address(), continuationRequest);
                         try {
                             assertThat(continuationResponse.status(), is(HttpResponseStatus.OK));
                             assertThat(
@@ -246,12 +193,71 @@ public void testBindUnavailableAddress() {
             Settings settings = Settings.builder().put("http.port", remoteAddress.getPort()).build();
             try (NioHttpServerTransport otherTransport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler,
                 threadPool, xContentRegistry(), new NullDispatcher(), new NioGroupFactory(Settings.EMPTY, logger))) {
-                BindHttpException bindHttpException = expectThrows(BindHttpException.class, () -> otherTransport.start());
+                BindHttpException bindHttpException = expectThrows(BindHttpException.class, otherTransport::start);
                 assertEquals("Failed to bind to [" + remoteAddress.getPort() + "]", bindHttpException.getMessage());
             }
         }
     }
 
+    public void testCorsRequest() throws InterruptedException {
+        final HttpServerTransport.Dispatcher dispatcher = new HttpServerTransport.Dispatcher() {
+
+            @Override
+            public void dispatchRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) {
+                throw new AssertionError();
+            }
+
+            @Override
+            public void dispatchBadRequest(final RestRequest request,
+                                           final RestChannel channel,
+                                           final ThreadContext threadContext,
+                                           final Throwable cause) {
+                throw new AssertionError();
+            }
+
+        };
+
+        final Settings settings = Settings.builder()
+            .put(SETTING_CORS_ENABLED.getKey(), true)
+            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "elastic.co").build();
+
+        try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler,
+            threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger))) {
+            transport.start();
+            final TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses());
+
+            // Test pre-flight request
+            try (NioHttpClient client = new NioHttpClient()) {
+                final FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.OPTIONS, "/");
+                request.headers().add(CorsHandler.ORIGIN, "elastic.co");
+                request.headers().add(CorsHandler.ACCESS_CONTROL_REQUEST_METHOD, "POST");
+
+                final FullHttpResponse response = client.send(remoteAddress.address(), request);
+                try {
+                    assertThat(response.status(), equalTo(HttpResponseStatus.OK));
+                    assertThat(response.headers().get(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN), equalTo("elastic.co"));
+                    assertThat(response.headers().get(CorsHandler.VARY), equalTo(CorsHandler.ORIGIN));
+                    assertTrue(response.headers().contains(CorsHandler.DATE));
+                } finally {
+                    response.release();
+                }
+            }
+
+            // Test short-circuited request
+            try (NioHttpClient client = new NioHttpClient()) {
+                final FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");
+                request.headers().add(CorsHandler.ORIGIN, "elastic2.co");
+
+                final FullHttpResponse response = client.send(remoteAddress.address(), request);
+                try {
+                    assertThat(response.status(), equalTo(HttpResponseStatus.FORBIDDEN));
+                } finally {
+                    response.release();
+                }
+            }
+        }
+    }
+
     public void testBadRequest() throws InterruptedException {
         final AtomicReference<Throwable> causeReference = new AtomicReference<>();
         final HttpServerTransport.Dispatcher dispatcher = new HttpServerTransport.Dispatcher() {
@@ -297,7 +303,7 @@ public void dispatchBadRequest(final RestRequest request,
                 final String url = "/" + new String(new byte[maxInitialLineLength], Charset.forName("UTF-8"));
                 final FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, url);
 
-                final FullHttpResponse response = client.post(remoteAddress.address(), request);
+                final FullHttpResponse response = client.send(remoteAddress.address(), request);
                 try {
                     assertThat(response.status(), equalTo(HttpResponseStatus.BAD_REQUEST));
                     assertThat(
diff --git a/server/src/main/java/org/elasticsearch/action/ActionListener.java b/server/src/main/java/org/elasticsearch/action/ActionListener.java
index c21aa3b9d4b8..2c7d7d2c54f9 100644
--- a/server/src/main/java/org/elasticsearch/action/ActionListener.java
+++ b/server/src/main/java/org/elasticsearch/action/ActionListener.java
@@ -55,7 +55,7 @@
      */
     static <Response> ActionListener<Response> wrap(CheckedConsumer<Response, ? extends Exception> onResponse,
             Consumer<Exception> onFailure) {
-        return new ActionListener<Response>() {
+        return new ActionListener<>() {
             @Override
             public void onResponse(Response response) {
                 try {
@@ -105,7 +105,7 @@ public void onFailure(Exception e) {
      * @return Delegating listener
      */
     static <T, R> ActionListener<T> delegateFailure(ActionListener<R> delegate, BiConsumer<ActionListener<R>, T> bc) {
-        return new ActionListener<T>() {
+        return new ActionListener<>() {
 
             @Override
             public void onResponse(T r) {
@@ -205,7 +205,7 @@ public void onFailure(Exception e) {
      * callback when the listener is notified via either {@code #onResponse} or {@code #onFailure}.
      */
     static <Response> ActionListener<Response> runAfter(ActionListener<Response> delegate, Runnable runAfter) {
-        return new ActionListener<Response>() {
+        return new ActionListener<>() {
             @Override
             public void onResponse(Response response) {
                 try {
@@ -231,7 +231,7 @@ public void onFailure(Exception e) {
      * and {@link #onFailure(Exception)} of the provided listener will be called at most once.
      */
     static <Response> ActionListener<Response> notifyOnce(ActionListener<Response> delegate) {
-        return new NotifyOnceListener<Response>() {
+        return new NotifyOnceListener<>() {
             @Override
             protected void innerOnResponse(Response response) {
                 delegate.onResponse(response);
diff --git a/server/src/main/java/org/elasticsearch/http/AbstractHttpServerTransport.java b/server/src/main/java/org/elasticsearch/http/AbstractHttpServerTransport.java
index ab6168cad522..0d4cdc16520a 100644
--- a/server/src/main/java/org/elasticsearch/http/AbstractHttpServerTransport.java
+++ b/server/src/main/java/org/elasticsearch/http/AbstractHttpServerTransport.java
@@ -42,6 +42,7 @@
 import org.elasticsearch.common.xcontent.NamedXContentRegistry;
 import org.elasticsearch.rest.RestChannel;
 import org.elasticsearch.rest.RestRequest;
+import org.elasticsearch.rest.RestStatus;
 import org.elasticsearch.threadpool.ThreadPool;
 import org.elasticsearch.transport.BindTransportException;
 
@@ -74,6 +75,7 @@
     protected final ThreadPool threadPool;
     protected final Dispatcher dispatcher;
     private final NamedXContentRegistry xContentRegistry;
+    private final CorsHandler corsHandler;
 
     protected final PortsRange port;
     protected final ByteSizeValue maxContentLength;
@@ -94,6 +96,7 @@ protected AbstractHttpServerTransport(Settings settings, NetworkService networkS
         this.xContentRegistry = xContentRegistry;
         this.dispatcher = dispatcher;
         this.handlingSettings = HttpHandlingSettings.fromSettings(settings);
+        this.corsHandler = CorsHandler.fromSettings(settings);
 
         // we can't make the network.bind_host a fallback since we already fall back to http.host hence the extra conditional here
         List<String> httpBindHost = SETTING_HTTP_BIND_HOST.get(settings);
@@ -296,6 +299,7 @@ protected void serverAcceptedChannel(HttpChannel httpChannel) {
      * @param httpChannel that received the http request
      */
     public void incomingRequest(final HttpRequest httpRequest, final HttpChannel httpChannel) {
+
         handleIncomingRequest(httpRequest, httpChannel, null);
     }
 
@@ -325,8 +329,25 @@ void dispatchRequest(final RestRequest restRequest, final RestChannel channel, f
     private void handleIncomingRequest(final HttpRequest httpRequest, final HttpChannel httpChannel, final Exception exception) {
         Exception badRequestCause = exception;
 
+        HttpResponse httpResponse = corsHandler.handleRequest(httpRequest);
+        /*
+         * If the CorsHandler returns a response, we must immediately send that response and abandon all
+         * other handling. The only header we need to set is the connection header.
+         */
+        if (httpResponse != null) {
+            if (httpResponse.getRestStatus().equals(RestStatus.FORBIDDEN) || HttpUtils.isCloseConnection(httpRequest)) {
+                httpResponse.addHeader(DefaultRestChannel.CONNECTION, DefaultRestChannel.CLOSE);
+                httpChannel.sendResponse(httpResponse, ActionListener.wrap(httpChannel::close));
+            } else {
+                httpResponse.addHeader(DefaultRestChannel.CONNECTION, DefaultRestChannel.KEEP_ALIVE);
+                httpChannel.sendResponse(httpResponse, ActionListener.wrap(() -> {}));
+            }
+            return;
+        }
+
+
         /*
-         * We want to create a REST request from the incoming request from Netty. However, creating this request could fail if there
+         * We want to create a REST request from the incoming http request. However, creating this request could fail if there
          * are incorrectly encoded parameters, or the Content-Type header is invalid. If one of these specific failures occurs, we
          * attempt to create a REST request again without the input that caused the exception (e.g., we remove the Content-Type header,
          * or skip decoding the parameters). Once we have a request in hand, we then dispatch the request as a bad request with the
@@ -358,11 +379,13 @@ private void handleIncomingRequest(final HttpRequest httpRequest, final HttpChan
             RestChannel innerChannel;
             ThreadContext threadContext = threadPool.getThreadContext();
             try {
-                innerChannel = new DefaultRestChannel(httpChannel, httpRequest, restRequest, bigArrays, handlingSettings, threadContext);
+                innerChannel = new DefaultRestChannel(httpChannel, httpRequest, restRequest, bigArrays, handlingSettings, corsHandler,
+                    threadContext);
             } catch (final IllegalArgumentException e) {
                 badRequestCause = ExceptionsHelper.useOrSuppress(badRequestCause, e);
                 final RestRequest innerRequest = RestRequest.requestWithoutParameters(xContentRegistry, httpRequest, httpChannel);
-                innerChannel = new DefaultRestChannel(httpChannel, httpRequest, innerRequest, bigArrays, handlingSettings, threadContext);
+                innerChannel = new DefaultRestChannel(httpChannel, httpRequest, innerRequest, bigArrays, handlingSettings, corsHandler,
+                    threadContext);
             }
             channel = innerChannel;
         }
diff --git a/server/src/main/java/org/elasticsearch/http/CorsHandler.java b/server/src/main/java/org/elasticsearch/http/CorsHandler.java
new file mode 100644
index 000000000000..d7902890be58
--- /dev/null
+++ b/server/src/main/java/org/elasticsearch/http/CorsHandler.java
@@ -0,0 +1,367 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+/*
+ * Copyright 2013 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version
+ * 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package org.elasticsearch.http;
+
+import org.elasticsearch.common.Strings;
+import org.elasticsearch.common.bytes.BytesArray;
+import org.elasticsearch.common.settings.Settings;
+import org.elasticsearch.common.settings.SettingsException;
+import org.elasticsearch.rest.RestRequest;
+import org.elasticsearch.rest.RestStatus;
+import org.elasticsearch.rest.RestUtils;
+
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
+
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_CREDENTIALS;
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_HEADERS;
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_METHODS;
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_ORIGIN;
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ENABLED;
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_MAX_AGE;
+
+/**
+ * This file is forked from the https://netty.io project. In particular it combines the following three
+ * files: io.netty.handler.codec.http.cors.CorsHandler, io.netty.handler.codec.http.cors.CorsConfig, and
+ * io.netty.handler.codec.http.cors.CorsConfigBuilder.
+ *
+ * It modifies the original netty code to operation on Elasticsearch http request/response abstractions.
+ * Additionally, it removes CORS features that are not used by Elasticsearch.
+ */
+public class CorsHandler {
+
+    public static final String ANY_ORIGIN = "*";
+    public static final String ORIGIN = "origin";
+    public static final String DATE = "date";
+    public static final String VARY = "vary";
+    public static final String ACCESS_CONTROL_REQUEST_METHOD = "access-control-request-method";
+    public static final String ACCESS_CONTROL_ALLOW_ORIGIN = "access-control-allow-origin";
+    public static final String ACCESS_CONTROL_ALLOW_METHODS = "access-control-allow-methods";
+    public static final String ACCESS_CONTROL_ALLOW_HEADERS = "access-control-allow-headers";
+    public static final String ACCESS_CONTROL_MAX_AGE = "access-control-max-age";
+    public static final String ACCESS_CONTROL_ALLOW_CREDENTIALS = "access-control-allow-credentials";
+
+    private static final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("EEE, dd MMM yyyy HH:mm:ss O", Locale.ENGLISH);
+    private final Config config;
+
+    public CorsHandler(final Config config) {
+        if (config == null) {
+            throw new NullPointerException();
+        }
+        this.config = config;
+    }
+
+    public HttpResponse handleRequest(HttpRequest request) {
+        if (config.isCorsSupportEnabled()) {
+            if (isPreflightRequest(request)) {
+                return createPreflightResponse(request);
+            }
+
+            // If there is no origin, this is not a CORS request.
+            final String origin = getOrigin(request);
+            if (Strings.isNullOrEmpty(origin) == false && originAllowed(origin) == false) {
+                HttpResponse response = request.createResponse(RestStatus.FORBIDDEN, BytesArray.EMPTY);
+                response.addHeader(DefaultRestChannel.CONTENT_LENGTH, "0");
+                return response;
+            }
+        }
+
+        return null;
+    }
+
+    public void setCorsResponseHeaders(HttpRequest request, HttpResponse resp) {
+        if (config.isCorsSupportEnabled()) {
+            String originHeader = getOrigin(request);
+            if (setOrigin(resp, originHeader)) {
+                if (config.isCredentialsAllowed()) {
+                    resp.addHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
+                }
+            }
+        }
+    }
+
+    private boolean originAllowed(String origin) {
+        if (config.isAnyOriginSupported()) {
+            return true;
+        }
+
+        return config.isOriginAllowed(origin);
+    }
+
+    private HttpResponse createPreflightResponse(HttpRequest request) {
+        final String origin = getOrigin(request);
+        if (Strings.isNullOrEmpty(origin) == false) {
+            HttpResponse response = request.createResponse(RestStatus.OK, BytesArray.EMPTY);
+            if (setOrigin(response, origin)) {
+                setAllowMethods(response);
+                setAllowHeaders(response);
+                setAllowCredentials(response);
+                setMaxAge(response);
+            }
+            response.addHeader(DefaultRestChannel.CONTENT_LENGTH, "0");
+            response.addHeader(DATE, dateTimeFormatter.format(ZonedDateTime.now(ZoneOffset.UTC)));
+            return response;
+        } else {
+            HttpResponse response = request.createResponse(RestStatus.FORBIDDEN, BytesArray.EMPTY);
+            response.addHeader(DefaultRestChannel.CONTENT_LENGTH, "0");
+            return response;
+        }
+    }
+
+    private boolean setOrigin(final HttpResponse response, final String origin) {
+        // If there is no origin, this is not a CORS request.
+        if (Strings.isNullOrEmpty(origin) == false) {
+            if (config.isAnyOriginSupported()) {
+                if (config.isCredentialsAllowed()) {
+                    response.addHeader(ACCESS_CONTROL_ALLOW_ORIGIN, origin);
+                    response.addHeader(VARY, ORIGIN);
+                    return true;
+                } else {
+                    response.addHeader(ACCESS_CONTROL_ALLOW_ORIGIN, ANY_ORIGIN);
+                    return true;
+                }
+            } else if (config.isOriginAllowed(origin)) {
+                response.addHeader(ACCESS_CONTROL_ALLOW_ORIGIN, origin);
+                response.addHeader(VARY, ORIGIN);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void setAllowMethods(final HttpResponse response) {
+        for (RestRequest.Method method : config.allowedRequestMethods) {
+            response.addHeader(ACCESS_CONTROL_ALLOW_METHODS, method.name().trim());
+        }
+    }
+
+    private void setAllowHeaders(final HttpResponse response) {
+        for (String header : config.allowedRequestHeaders) {
+            response.addHeader(ACCESS_CONTROL_ALLOW_HEADERS, header);
+        }
+    }
+
+    private void setAllowCredentials(final HttpResponse response) {
+        if (config.isCredentialsAllowed()) {
+            response.addHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
+        }
+    }
+
+    private void setMaxAge(final HttpResponse response) {
+        response.addHeader(ACCESS_CONTROL_MAX_AGE, Long.toString(config.maxAge));
+    }
+
+    private static boolean isPreflightRequest(final HttpRequest request) {
+        Map<String, List<String>> headers = request.getHeaders();
+        return request.method().equals(RestRequest.Method.OPTIONS) &&
+            headers.containsKey(ORIGIN) &&
+            headers.containsKey(ACCESS_CONTROL_REQUEST_METHOD);
+    }
+
+    private static String getOrigin(HttpRequest request) {
+        List<String> headers = request.getHeaders().get(ORIGIN);
+        if (headers == null || headers.isEmpty()) {
+            return null;
+        } else {
+            return headers.get(0);
+        }
+    }
+
+    public static class Config {
+
+        private final boolean enabled;
+        private final Optional<Set<String>> origins;
+        private final Optional<Pattern> pattern;
+        private final boolean anyOrigin;
+        private final boolean credentialsAllowed;
+        private final Set<RestRequest.Method> allowedRequestMethods;
+        private final Set<String> allowedRequestHeaders;
+        private final long maxAge;
+
+        public Config(Builder builder) {
+            this.enabled = builder.enabled;
+            origins = builder.origins.map(HashSet::new);
+            pattern = builder.pattern;
+            anyOrigin = builder.anyOrigin;
+            this.credentialsAllowed = builder.allowCredentials;
+            this.allowedRequestMethods = Collections.unmodifiableSet(builder.requestMethods);
+            this.allowedRequestHeaders = Collections.unmodifiableSet(builder.requestHeaders);
+            this.maxAge = builder.maxAge;
+        }
+
+        boolean isCorsSupportEnabled() {
+            return enabled;
+        }
+
+        boolean isAnyOriginSupported() {
+            return anyOrigin;
+        }
+
+        boolean isOriginAllowed(String origin) {
+            if (origins.isPresent()) {
+                return origins.get().contains(origin);
+            } else if (pattern.isPresent()) {
+                return pattern.get().matcher(origin).matches();
+            }
+            return false;
+        }
+
+        boolean isCredentialsAllowed() {
+            return credentialsAllowed;
+        }
+
+        private static class Builder {
+
+            private boolean enabled = true;
+            private Optional<Set<String>> origins;
+            private Optional<Pattern> pattern;
+            private final boolean anyOrigin;
+            private boolean allowCredentials = false;
+            long maxAge;
+            private final Set<RestRequest.Method> requestMethods = new HashSet<>();
+            private final Set<String> requestHeaders = new HashSet<>();
+
+            private Builder() {
+                anyOrigin = true;
+                origins = Optional.empty();
+                pattern = Optional.empty();
+            }
+
+            private Builder(final String... origins) {
+                this.origins = Optional.of(new LinkedHashSet<>(Arrays.asList(origins)));
+                pattern = Optional.empty();
+                anyOrigin = false;
+            }
+
+            private Builder(final Pattern pattern) {
+                this.pattern = Optional.of(pattern);
+                origins = Optional.empty();
+                anyOrigin = false;
+            }
+
+            static Builder forOrigins(final String... origins) {
+                return new Builder(origins);
+            }
+
+            static Builder forAnyOrigin() {
+                return new Builder();
+            }
+
+            static Builder forPattern(Pattern pattern) {
+                return new Builder(pattern);
+            }
+
+            Builder allowCredentials() {
+                this.allowCredentials = true;
+                return this;
+            }
+
+
+            public Builder allowedRequestMethods(RestRequest.Method[] methods) {
+                requestMethods.addAll(Arrays.asList(methods));
+                return this;
+            }
+
+            public Builder maxAge(int maxAge) {
+                this.maxAge = maxAge;
+                return this;
+            }
+
+            public Builder allowedRequestHeaders(String[] headers) {
+                requestHeaders.addAll(Arrays.asList(headers));
+                return this;
+            }
+
+            public Config build() {
+                return new Config(this);
+            }
+        }
+    }
+
+    public static CorsHandler disabled() {
+        Config.Builder builder = new Config.Builder();
+        builder.enabled = false;
+        return new CorsHandler(new Config(builder));
+    }
+
+    public static CorsHandler fromSettings(Settings settings) {
+        if (SETTING_CORS_ENABLED.get(settings) == false) {
+            return disabled();
+        }
+        String origin = SETTING_CORS_ALLOW_ORIGIN.get(settings);
+        final CorsHandler.Config.Builder builder;
+        if (Strings.isNullOrEmpty(origin)) {
+            builder = CorsHandler.Config.Builder.forOrigins();
+        } else if (origin.equals(CorsHandler.ANY_ORIGIN)) {
+            builder = CorsHandler.Config.Builder.forAnyOrigin();
+        } else {
+            try {
+                Pattern p = RestUtils.checkCorsSettingForRegex(origin);
+                if (p == null) {
+                    builder = CorsHandler.Config.Builder.forOrigins(RestUtils.corsSettingAsArray(origin));
+                } else {
+                    builder = CorsHandler.Config.Builder.forPattern(p);
+                }
+            } catch (PatternSyntaxException e) {
+                throw new SettingsException("Bad regex in [" + SETTING_CORS_ALLOW_ORIGIN.getKey() + "]: [" + origin + "]", e);
+            }
+        }
+        if (SETTING_CORS_ALLOW_CREDENTIALS.get(settings)) {
+            builder.allowCredentials();
+        }
+        String[] strMethods = Strings.tokenizeToStringArray(SETTING_CORS_ALLOW_METHODS.get(settings), ",");
+        RestRequest.Method[] methods = Arrays.stream(strMethods)
+            .map(s -> s.toUpperCase(Locale.ENGLISH))
+            .map(RestRequest.Method::valueOf)
+            .toArray(RestRequest.Method[]::new);
+        Config config = builder.allowedRequestMethods(methods)
+            .maxAge(SETTING_CORS_MAX_AGE.get(settings))
+            .allowedRequestHeaders(Strings.tokenizeToStringArray(SETTING_CORS_ALLOW_HEADERS.get(settings), ","))
+            .build();
+        return new CorsHandler(config);
+    }
+}
diff --git a/server/src/main/java/org/elasticsearch/http/DefaultRestChannel.java b/server/src/main/java/org/elasticsearch/http/DefaultRestChannel.java
index 5191a8d85cef..99cc9d3c2004 100644
--- a/server/src/main/java/org/elasticsearch/http/DefaultRestChannel.java
+++ b/server/src/main/java/org/elasticsearch/http/DefaultRestChannel.java
@@ -57,16 +57,18 @@
     private final HttpRequest httpRequest;
     private final BigArrays bigArrays;
     private final HttpHandlingSettings settings;
+    private final CorsHandler corsHandler;
     private final ThreadContext threadContext;
     private final HttpChannel httpChannel;
 
     DefaultRestChannel(HttpChannel httpChannel, HttpRequest httpRequest, RestRequest request, BigArrays bigArrays,
-                       HttpHandlingSettings settings, ThreadContext threadContext) {
+                       HttpHandlingSettings settings, CorsHandler corsHandler, ThreadContext threadContext) {
         super(request, settings.getDetailedErrorsEnabled());
         this.httpChannel = httpChannel;
         this.httpRequest = httpRequest;
         this.bigArrays = bigArrays;
         this.settings = settings;
+        this.corsHandler = corsHandler;
         this.threadContext = threadContext;
     }
 
@@ -101,8 +103,7 @@ public void sendResponse(RestResponse restResponse) {
 
             final HttpResponse httpResponse = httpRequest.createResponse(restResponse.status(), finalContent);
 
-            // TODO: Ideally we should move the setting of Cors headers into :server
-            // NioCorsHandler.setCorsResponseHeaders(nettyRequest, resp, corsConfig);
+             corsHandler.setCorsResponseHeaders(httpRequest, httpResponse);
 
             String opaque = request.header(X_OPAQUE_ID);
             if (opaque != null) {
diff --git a/server/src/main/java/org/elasticsearch/http/HttpResponse.java b/server/src/main/java/org/elasticsearch/http/HttpResponse.java
index 2d363f663c3e..0204680f90d1 100644
--- a/server/src/main/java/org/elasticsearch/http/HttpResponse.java
+++ b/server/src/main/java/org/elasticsearch/http/HttpResponse.java
@@ -19,14 +19,22 @@
 
 package org.elasticsearch.http;
 
+import org.elasticsearch.rest.RestStatus;
+
+import java.util.List;
+
 /**
  * A basic http response abstraction. Http modules must implement this interface as the server package rest
  * handling needs to set http headers for a response.
  */
 public interface HttpResponse {
 
+    RestStatus getRestStatus();
+
     void addHeader(String name, String value);
 
     boolean containsHeader(String name);
 
+    List<String> getAllHeaders(String name);
+
 }
diff --git a/server/src/main/java/org/elasticsearch/http/HttpUtils.java b/server/src/main/java/org/elasticsearch/http/HttpUtils.java
new file mode 100644
index 000000000000..55de97264c84
--- /dev/null
+++ b/server/src/main/java/org/elasticsearch/http/HttpUtils.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.elasticsearch.http;
+
+import java.util.List;
+
+class HttpUtils {
+
+    /**
+     * Returns if the request connection should be closed on completion.
+     */
+    static boolean isCloseConnection(HttpRequest request) {
+        final boolean http10 = isHttp10(request);
+        String connectionHeader = getHeader(request, DefaultRestChannel.CONNECTION);
+        return DefaultRestChannel.CLOSE.equalsIgnoreCase(connectionHeader) ||
+            (http10 && !DefaultRestChannel.KEEP_ALIVE.equalsIgnoreCase(connectionHeader));
+    }
+
+    // Determine if the request protocol version is HTTP 1.0
+    private static boolean isHttp10(HttpRequest request) {
+        return request.protocolVersion() == HttpRequest.HttpVersion.HTTP_1_0;
+    }
+
+    private static String getHeader(HttpRequest request, String header) {
+        List<String> values = request.getHeaders().get(header);
+        if (values != null && values.isEmpty() == false) {
+            return values.get(0);
+        }
+        return null;
+    }
+}
diff --git a/server/src/main/java/org/elasticsearch/rest/RestController.java b/server/src/main/java/org/elasticsearch/rest/RestController.java
index 3f32d281918a..d96e20bc283a 100644
--- a/server/src/main/java/org/elasticsearch/rest/RestController.java
+++ b/server/src/main/java/org/elasticsearch/rest/RestController.java
@@ -292,8 +292,7 @@ private void sendContentTypeErrorMessage(RestRequest restRequest, RestChannel ch
         if (contentTypeHeader == null) {
             errorMessage = "Content-Type header is missing";
         } else {
-            errorMessage = "Content-Type header [" +
-                Strings.collectionToCommaDelimitedString(restRequest.getAllHeaderValues("Content-Type")) + "] is not supported";
+            errorMessage = "Content-Type header [" + Strings.collectionToCommaDelimitedString(contentTypeHeader) + "] is not supported";
         }
 
         channel.sendResponse(BytesRestResponse.createSimpleErrorResponse(channel, NOT_ACCEPTABLE, errorMessage));
diff --git a/server/src/test/java/org/elasticsearch/http/CorsHandlerTests.java b/server/src/test/java/org/elasticsearch/http/CorsHandlerTests.java
new file mode 100644
index 000000000000..a4aa3e75022d
--- /dev/null
+++ b/server/src/test/java/org/elasticsearch/http/CorsHandlerTests.java
@@ -0,0 +1,305 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.http;
+
+import org.elasticsearch.common.Strings;
+import org.elasticsearch.common.bytes.BytesArray;
+import org.elasticsearch.common.bytes.BytesReference;
+import org.elasticsearch.common.settings.Settings;
+import org.elasticsearch.common.settings.SettingsException;
+import org.elasticsearch.rest.RestRequest;
+import org.elasticsearch.rest.RestStatus;
+import org.elasticsearch.test.ESTestCase;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.PatternSyntaxException;
+import java.util.stream.Collectors;
+
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_CREDENTIALS;
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_HEADERS;
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_METHODS;
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ALLOW_ORIGIN;
+import static org.elasticsearch.http.HttpTransportSettings.SETTING_CORS_ENABLED;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.instanceOf;
+
+public class CorsHandlerTests extends ESTestCase {
+
+    public void testAnyOriginPreflight() {
+        final Set<String> methods = new HashSet<>(Arrays.asList("get", "options", "post"));
+        final Set<String> headers = new HashSet<>(Arrays.asList("Content-Type", "Content-Length"));
+        final String prefix = randomBoolean() ? " " : ""; // sometimes have a leading whitespace between comma delimited elements
+        final boolean allowCredentials = randomBoolean();
+        final Settings settings = Settings.builder()
+            .put(SETTING_CORS_ENABLED.getKey(), true)
+            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "*")
+            .put(SETTING_CORS_ALLOW_METHODS.getKey(), Strings.collectionToDelimitedString(methods, ",", prefix, ""))
+            .put(SETTING_CORS_ALLOW_HEADERS.getKey(), Strings.collectionToDelimitedString(headers, ",", prefix, ""))
+            .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), allowCredentials)
+            .build();
+        final CorsHandler corsHandler = CorsHandler.fromSettings(settings);
+
+        HttpResponse httpResponse = corsHandler.handleRequest(new TestRequest("elastic.co", RestRequest.Method.OPTIONS));
+        assertNotNull(httpResponse);
+        assertEquals(RestStatus.OK, httpResponse.getRestStatus());
+        assertEquals(methods.stream().map(s -> s.toUpperCase(Locale.ENGLISH)).collect(Collectors.toSet()),
+            new HashSet<>(httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_METHODS)));
+        assertEquals(headers, new HashSet<>(httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_HEADERS)));
+        assertEquals("1728000", httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_MAX_AGE).get(0));
+        if (allowCredentials) {
+            // Origin is set to vary when any origin and credentials are allowed
+            assertEquals(CorsHandler.ORIGIN, httpResponse.getAllHeaders(CorsHandler.VARY).get(0));
+            assertEquals("elastic.co", httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN).get(0));
+            assertEquals("true", httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_CREDENTIALS).get(0));
+        } else {
+            assertEquals("*", httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN).get(0));
+            assertNull(httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_CREDENTIALS));
+        }
+    }
+
+    public void testSpecificOriginPreflight() {
+        final Set<String> methods = new HashSet<>(Arrays.asList("get", "options", "post"));
+        final Set<String> headers = new HashSet<>(Arrays.asList("Content-Type", "Content-Length"));
+        final String prefix = randomBoolean() ? " " : ""; // sometimes have a leading whitespace between comma delimited elements
+        final boolean allowCredentials = randomBoolean();
+        Settings.Builder builder = Settings.builder()
+            .put(SETTING_CORS_ENABLED.getKey(), true)
+            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "elastic.co")
+            .put(SETTING_CORS_ALLOW_METHODS.getKey(), Strings.collectionToDelimitedString(methods, ",", prefix, ""))
+            .put(SETTING_CORS_ALLOW_HEADERS.getKey(), Strings.collectionToDelimitedString(headers, ",", prefix, ""))
+            .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), allowCredentials);
+        if (randomBoolean()) {
+            builder.put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "elastic.co");
+        } else {
+            builder.put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "/elast.+/");
+        }
+        final CorsHandler corsHandler = CorsHandler.fromSettings(builder.build());
+
+        HttpResponse httpResponse = corsHandler.handleRequest(new TestRequest("elastic.co", RestRequest.Method.OPTIONS));
+        assertNotNull(httpResponse);
+        assertEquals(RestStatus.OK, httpResponse.getRestStatus());
+        assertEquals(methods.stream().map(s -> s.toUpperCase(Locale.ENGLISH)).collect(Collectors.toSet()),
+            new HashSet<>(httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_METHODS)));
+        assertEquals(headers, new HashSet<>(httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_HEADERS)));
+        assertEquals("1728000", httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_MAX_AGE).get(0));
+        assertEquals(CorsHandler.ORIGIN, httpResponse.getAllHeaders(CorsHandler.VARY).get(0));
+        assertEquals("elastic.co", httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN).get(0));
+        if (allowCredentials) {
+            assertEquals("true", httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_CREDENTIALS).get(0));
+        } else {
+            assertNull(httpResponse.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_CREDENTIALS));
+        }
+
+        HttpResponse httpResponse2 = corsHandler.handleRequest(new TestRequest("invalid_elastic.co", RestRequest.Method.OPTIONS));
+        assertNotNull(httpResponse2);
+        assertEquals(RestStatus.OK, httpResponse2.getRestStatus());
+        // invalid_elastic.co is not allowed so these headers are null
+        assertNull(httpResponse2.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN));
+        assertNull(httpResponse2.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_METHODS));
+        assertNull(httpResponse2.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_HEADERS));
+        assertNull(httpResponse2.getAllHeaders(CorsHandler.ACCESS_CONTROL_MAX_AGE));
+        assertNull(httpResponse2.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_CREDENTIALS));
+    }
+
+    public void testCorsPreflightDisabled() {
+        final Settings settings = Settings.builder().put(SETTING_CORS_ENABLED.getKey(), false).build();
+        final CorsHandler corsHandler = CorsHandler.fromSettings(settings);
+        assertNull(corsHandler.handleRequest(new TestRequest("elastic.co", RestRequest.Method.OPTIONS)));
+    }
+
+    public void testShortCircuit() {
+        Settings settings = Settings.builder()
+            .put(SETTING_CORS_ENABLED.getKey(), true)
+            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "elastic.co")
+            .build();
+
+        final CorsHandler corsHandler = CorsHandler.fromSettings(settings);
+        HttpResponse httpResponse = corsHandler.handleRequest(new TestRequest("invalid_elastic.co", RestRequest.Method.GET));
+        assertEquals(RestStatus.FORBIDDEN, httpResponse.getRestStatus());
+    }
+
+    public void testSetCorsHeadersWithSpecificOrigin() {
+        boolean allowCredentials = randomBoolean();
+        Settings.Builder builder = Settings.builder().put(SETTING_CORS_ENABLED.getKey(), true);
+        builder.put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), allowCredentials);
+        if (randomBoolean()) {
+            builder.put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "elastic.co");
+        } else {
+            builder.put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "/elast.+/");
+        }
+        final CorsHandler corsHandler = CorsHandler.fromSettings(builder.build());
+
+        TestRequest request = new TestRequest("elastic.co", RestRequest.Method.GET);
+        HttpResponse response = request.createResponse(RestStatus.OK, BytesArray.EMPTY);
+        corsHandler.setCorsResponseHeaders(request, response);
+        assertEquals("elastic.co", response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN).get(0));
+        if (allowCredentials) {
+            assertEquals("true", response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_CREDENTIALS).get(0));
+        } else {
+            assertNull(response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_CREDENTIALS));
+        }
+    }
+
+    public void testSetCorsHeadersWithAnyOrigin() {
+        boolean allowCredentials = randomBoolean();
+        Settings.Builder builder = Settings.builder()
+            .put(SETTING_CORS_ENABLED.getKey(), true)
+            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "*")
+            .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), allowCredentials);
+
+        final CorsHandler corsHandler = CorsHandler.fromSettings(builder.build());
+
+        TestRequest request = new TestRequest("elastic.co", RestRequest.Method.GET);
+        HttpResponse response = request.createResponse(RestStatus.OK, BytesArray.EMPTY);
+        corsHandler.setCorsResponseHeaders(request, response);
+        if (allowCredentials) {
+            assertEquals("elastic.co", response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN).get(0));
+            assertEquals(CorsHandler.ORIGIN, response.getAllHeaders(CorsHandler.VARY).get(0));
+            assertEquals("true", response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_CREDENTIALS).get(0));
+        } else {
+            assertEquals("*", response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN).get(0));
+            assertNull(response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_CREDENTIALS));
+        }
+    }
+
+    public void testSetCorsHeadersWithNonCorsRequest() {
+        Settings.Builder builder = Settings.builder()
+            .put(SETTING_CORS_ENABLED.getKey(), true)
+            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "*");
+
+        final CorsHandler corsHandler = CorsHandler.fromSettings(builder.build());
+
+        TestRequest request = new TestRequest("elastic.co", RestRequest.Method.GET, false);
+        HttpResponse response = request.createResponse(RestStatus.OK, BytesArray.EMPTY);
+        corsHandler.setCorsResponseHeaders(request, response);
+        assertNull(response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN));
+    }
+
+    public void testCorsSetHeadersDisabled() {
+        final Settings settings = Settings.builder().put(SETTING_CORS_ENABLED.getKey(), false).build();
+        final CorsHandler corsHandler = CorsHandler.fromSettings(settings);
+        TestRequest request = new TestRequest("elastic.co", RestRequest.Method.OPTIONS);
+        HttpResponse response = request.createResponse(RestStatus.OK, BytesArray.EMPTY);
+        corsHandler.setCorsResponseHeaders(request, response);
+        assertNull(response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN));
+    }
+
+    public void testCorsConfigWithBadRegex() {
+        final Settings settings = Settings.builder()
+            .put(SETTING_CORS_ENABLED.getKey(), true)
+            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), "/[*/")
+            .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true)
+            .build();
+        SettingsException e = expectThrows(SettingsException.class, () -> CorsHandler.fromSettings(settings));
+        assertThat(e.getMessage(), containsString("Bad regex in [http.cors.allow-origin]: [/[*/]"));
+        assertThat(e.getCause(), instanceOf(PatternSyntaxException.class));
+    }
+
+    private static class TestRequest implements HttpRequest {
+
+        private final RestRequest.Method method;
+        private final Map<String, List<String>> headers = new HashMap<>();
+
+        private TestRequest(String origin, RestRequest.Method method) {
+            this(origin, method, true);
+        }
+
+        private TestRequest(String origin, RestRequest.Method method, boolean isCors) {
+            this.method = method;
+            if (isCors) {
+                headers.put(CorsHandler.ORIGIN, Collections.singletonList(origin));
+                if (method == RestRequest.Method.OPTIONS) {
+                    headers.put(CorsHandler.ACCESS_CONTROL_REQUEST_METHOD, Collections.singletonList("POST"));
+                }
+            }
+        }
+
+        @Override
+        public RestRequest.Method method() {
+            return method;
+        }
+
+        @Override
+        public String uri() {
+            return "localhost:9300";
+        }
+
+        @Override
+        public BytesReference content() {
+            return BytesArray.EMPTY;
+        }
+
+        @Override
+        public Map<String, List<String>> getHeaders() {
+            return headers;
+        }
+
+        @Override
+        public List<String> strictCookies() {
+            return Collections.emptyList();
+        }
+
+        @Override
+        public HttpVersion protocolVersion() {
+            return HttpVersion.HTTP_1_1;
+        }
+
+        @Override
+        public HttpRequest removeHeader(String header) {
+            throw new UnsupportedOperationException("Unsupported");
+        }
+
+        @Override
+        public HttpResponse createResponse(RestStatus status, BytesReference content) {
+            Map<String, List<String>> headers = new HashMap<>();
+
+            return new HttpResponse() {
+                @Override
+                public RestStatus getRestStatus() {
+                    return status;
+                }
+
+                @Override
+                public void addHeader(String name, String value) {
+                    headers.putIfAbsent(name, new ArrayList<>());
+                    headers.get(name).add(value);
+                }
+
+                @Override
+                public boolean containsHeader(String name) {
+                    return headers.containsKey(name);
+                }
+
+                @Override
+                public List<String> getAllHeaders(String name) {
+                    return headers.get(name);
+                }
+            };
+        }
+    }
+}
diff --git a/server/src/test/java/org/elasticsearch/http/DefaultRestChannelTests.java b/server/src/test/java/org/elasticsearch/http/DefaultRestChannelTests.java
index c58ec6a4becb..59c64c60683d 100644
--- a/server/src/test/java/org/elasticsearch/http/DefaultRestChannelTests.java
+++ b/server/src/test/java/org/elasticsearch/http/DefaultRestChannelTests.java
@@ -89,98 +89,61 @@ public void shutdown() {
     }
 
     public void testResponse() {
-        final TestResponse response = executeRequest(Settings.EMPTY, "request-host");
+        final TestResponse response = executeRequest(Settings.EMPTY);
         assertThat(response.content(), equalTo(new TestRestResponse().content()));
     }
 
-    // TODO: Enable these Cors tests when the Cors logic lives in :server
-
-//    public void testCorsEnabledWithoutAllowOrigins() {
-//        // Set up an HTTP transport with only the CORS enabled setting
-//        Settings settings = Settings.builder()
-//            .put(HttpTransportSettings.SETTING_CORS_ENABLED.getKey(), true)
-//            .build();
-//        HttpResponse response = executeRequest(settings, "remote-host", "request-host");
-//        // inspect response and validate
-//        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), nullValue());
-//    }
-//
-//    public void testCorsEnabledWithAllowOrigins() {
-//        final String originValue = "remote-host";
-//        // create an HTTP transport with CORS enabled and allow origin configured
-//        Settings settings = Settings.builder()
-//            .put(SETTING_CORS_ENABLED.getKey(), true)
-//            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue)
-//            .build();
-//        HttpResponse response = executeRequest(settings, originValue, "request-host");
-//        // inspect response and validate
-//        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-//        String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-//        assertThat(allowedOrigins, is(originValue));
-//    }
-//
-//    public void testCorsAllowOriginWithSameHost() {
-//        String originValue = "remote-host";
-//        String host = "remote-host";
-//        // create an HTTP transport with CORS enabled
-//        Settings settings = Settings.builder()
-//            .put(SETTING_CORS_ENABLED.getKey(), true)
-//            .build();
-//        HttpResponse response = executeRequest(settings, originValue, host);
-//        // inspect response and validate
-//        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-//        String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-//        assertThat(allowedOrigins, is(originValue));
-//
-//        originValue = "http://" + originValue;
-//        response = executeRequest(settings, originValue, host);
-//        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-//        allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-//        assertThat(allowedOrigins, is(originValue));
-//
-//        originValue = originValue + ":5555";
-//        host = host + ":5555";
-//        response = executeRequest(settings, originValue, host);
-//        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-//        allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-//        assertThat(allowedOrigins, is(originValue));
-//
-//        originValue = originValue.replace("http", "https");
-//        response = executeRequest(settings, originValue, host);
-//        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-//        allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-//        assertThat(allowedOrigins, is(originValue));
-//    }
-//
-//    public void testThatStringLiteralWorksOnMatch() {
-//        final String originValue = "remote-host";
-//        Settings settings = Settings.builder()
-//            .put(SETTING_CORS_ENABLED.getKey(), true)
-//            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue)
-//            .put(SETTING_CORS_ALLOW_METHODS.getKey(), "get, options, post")
-//            .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true)
-//            .build();
-//        HttpResponse response = executeRequest(settings, originValue, "request-host");
-//        // inspect response and validate
-//        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-//        String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-//        assertThat(allowedOrigins, is(originValue));
-//        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS), equalTo("true"));
-//    }
-//
-//    public void testThatAnyOriginWorks() {
-//        final String originValue = NioCorsHandler.ANY_ORIGIN;
-//        Settings settings = Settings.builder()
-//            .put(SETTING_CORS_ENABLED.getKey(), true)
-//            .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue)
-//            .build();
-//        HttpResponse response = executeRequest(settings, originValue, "request-host");
-//        // inspect response and validate
-//        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue());
-//        String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN);
-//        assertThat(allowedOrigins, is(originValue));
-//        assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS), nullValue());
-//    }
+    public void testCorsEnabledWithoutAllowOrigins() {
+        // Set up an HTTP transport with only the CORS enabled setting
+        Settings settings = Settings.builder()
+            .put(HttpTransportSettings.SETTING_CORS_ENABLED.getKey(), true)
+            .build();
+        HttpResponse response = executeRequest(settings, "remote-host");
+        assertEquals(0, response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN).size());
+    }
+
+    public void testCorsEnabledWithAllowOrigins() {
+        final String originValue = "remote-hos*";
+        final String pattern;
+        if (randomBoolean()) {
+            pattern = originValue;
+        } else {
+            pattern = "remote-hos*";
+        }
+        // create an HTTP transport with CORS enabled and allow origin configured
+        Settings settings = Settings.builder()
+            .put(HttpTransportSettings.SETTING_CORS_ENABLED.getKey(), true)
+            .put(HttpTransportSettings.SETTING_CORS_ALLOW_ORIGIN.getKey(), pattern)
+            .build();
+        HttpResponse response = executeRequest(settings, originValue);
+        assertEquals(originValue, response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN).get(0));
+        assertEquals(CorsHandler.ORIGIN, response.getAllHeaders(CorsHandler.VARY).get(0));
+    }
+
+    public void testCorsEnabledWithAllowOriginsAndAllowCredentials() {
+        final String originValue = "remote-host";
+        // create an HTTP transport with CORS enabled and allow origin configured
+        Settings settings = Settings.builder()
+            .put(HttpTransportSettings.SETTING_CORS_ENABLED.getKey(), true)
+            .put(HttpTransportSettings.SETTING_CORS_ALLOW_ORIGIN.getKey(), CorsHandler.ANY_ORIGIN)
+            .put(HttpTransportSettings.SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true)
+            .build();
+        HttpResponse response = executeRequest(settings, originValue);
+        assertEquals(originValue, response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN).get(0));
+        assertEquals(CorsHandler.ORIGIN, response.getAllHeaders(CorsHandler.VARY).get(0));
+        assertEquals("true", response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_CREDENTIALS).get(0));
+    }
+
+    public void testThatAnyOriginWorks() {
+        final String originValue = CorsHandler.ANY_ORIGIN;
+        Settings settings = Settings.builder()
+            .put(HttpTransportSettings.SETTING_CORS_ENABLED.getKey(), true)
+            .put(HttpTransportSettings.SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue)
+            .build();
+        HttpResponse response = executeRequest(settings, originValue);
+        assertEquals(originValue, response.getAllHeaders(CorsHandler.ACCESS_CONTROL_ALLOW_ORIGIN).get(0));
+        assertEquals(0, response.getAllHeaders(CorsHandler.VARY).size());
+    }
 
     public void testHeadersSet() {
         Settings settings = Settings.builder().build();
@@ -191,7 +154,7 @@ public void testHeadersSet() {
 
         // send a response
         DefaultRestChannel channel = new DefaultRestChannel(httpChannel, httpRequest, request, bigArrays, handlingSettings,
-            threadPool.getThreadContext());
+            CorsHandler.disabled(), threadPool.getThreadContext());
         TestRestResponse resp = new TestRestResponse();
         final String customHeader = "custom-header";
         final String customHeaderValue = "xyz";
@@ -219,7 +182,7 @@ public void testCookiesSet() {
 
         // send a response
         DefaultRestChannel channel = new DefaultRestChannel(httpChannel, httpRequest, request, bigArrays, handlingSettings,
-            threadPool.getThreadContext());
+            CorsHandler.disabled(), threadPool.getThreadContext());
         channel.sendResponse(new TestRestResponse());
 
         // inspect what was written
@@ -239,7 +202,7 @@ public void testReleaseInListener() throws IOException {
         HttpHandlingSettings handlingSettings = HttpHandlingSettings.fromSettings(settings);
 
         DefaultRestChannel channel = new DefaultRestChannel(httpChannel, httpRequest, request, bigArrays, handlingSettings,
-            threadPool.getThreadContext());
+            CorsHandler.disabled(), threadPool.getThreadContext());
         final BytesRestResponse response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR,
             JsonXContent.contentBuilder().startObject().endObject());
         assertThat(response.content(), not(instanceOf(Releasable.class)));
@@ -289,7 +252,7 @@ public void testConnectionClose() throws Exception {
         HttpHandlingSettings handlingSettings = HttpHandlingSettings.fromSettings(settings);
 
         DefaultRestChannel channel = new DefaultRestChannel(httpChannel, httpRequest, request, bigArrays, handlingSettings,
-            threadPool.getThreadContext());
+            CorsHandler.disabled(), threadPool.getThreadContext());
         channel.sendResponse(new TestRestResponse());
         Class<ActionListener<Void>> listenerClass = (Class<ActionListener<Void>>) (Class) ActionListener.class;
         ArgumentCaptor<ActionListener<Void>> listenerCaptor = ArgumentCaptor.forClass(listenerClass);
@@ -320,7 +283,7 @@ public void testUnsupportedHttpMethod() {
         request.getHttpRequest().getHeaders().put(DefaultRestChannel.CONNECTION, Collections.singletonList(httpConnectionHeaderValue));
 
         DefaultRestChannel channel = new DefaultRestChannel(httpChannel, request.getHttpRequest(), request, bigArrays,
-            HttpHandlingSettings.fromSettings(Settings.EMPTY), threadPool.getThreadContext());
+            HttpHandlingSettings.fromSettings(Settings.EMPTY), CorsHandler.disabled(), threadPool.getThreadContext());
 
         // ESTestCase#after will invoke ensureAllArraysAreReleased which will fail if the response content was not released
         final BigArrays bigArrays = new MockBigArrays(new MockPageCacheRecycler(Settings.EMPTY), new NoneCircuitBreakerService());
@@ -357,7 +320,7 @@ public HttpResponse createResponse(RestStatus status, BytesReference content) {
         request.getHttpRequest().getHeaders().put(DefaultRestChannel.CONNECTION, Collections.singletonList(httpConnectionHeaderValue));
 
         DefaultRestChannel channel = new DefaultRestChannel(httpChannel, request.getHttpRequest(), request, bigArrays,
-            HttpHandlingSettings.fromSettings(Settings.EMPTY), threadPool.getThreadContext());
+            HttpHandlingSettings.fromSettings(Settings.EMPTY), CorsHandler.disabled(), threadPool.getThreadContext());
 
         // ESTestCase#after will invoke ensureAllArraysAreReleased which will fail if the response content was not released
         final BigArrays bigArrays = new MockBigArrays(new MockPageCacheRecycler(Settings.EMPTY), new NoneCircuitBreakerService());
@@ -373,22 +336,21 @@ public HttpResponse createResponse(RestStatus status, BytesReference content) {
         }
     }
 
-    private TestResponse executeRequest(final Settings settings, final String host) {
-        return executeRequest(settings, null, host);
+    private TestResponse executeRequest(final Settings settings) {
+        return executeRequest(settings, null);
     }
 
-    private TestResponse executeRequest(final Settings settings, final String originValue, final String host) {
+    private TestResponse executeRequest(final Settings settings, final String originValue) {
         HttpRequest httpRequest = new TestRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/");
         // TODO: These exist for the Cors tests
-//        if (originValue != null) {
-//            httpRequest.headers().add(HttpHeaderNames.ORIGIN, originValue);
-//        }
-//        httpRequest.headers().add(HttpHeaderNames.HOST, host);
+        if (originValue != null) {
+            httpRequest.getHeaders().put("origin", Collections.singletonList(originValue));
+        }
         final RestRequest request = RestRequest.request(xContentRegistry(), httpRequest, httpChannel);
 
         HttpHandlingSettings httpHandlingSettings = HttpHandlingSettings.fromSettings(settings);
         RestChannel channel = new DefaultRestChannel(httpChannel, httpRequest, request, bigArrays, httpHandlingSettings,
-            threadPool.getThreadContext());
+            CorsHandler.fromSettings(settings), threadPool.getThreadContext());
         channel.sendResponse(new TestRestResponse());
 
         // get the response
@@ -471,7 +433,8 @@ public BytesReference content() {
             return content;
         }
 
-        public RestStatus status() {
+        @Override
+        public RestStatus getRestStatus() {
             return status;
         }
 
@@ -486,6 +449,15 @@ public void addHeader(String name, String value) {
             }
         }
 
+        @Override
+        public List<String> getAllHeaders(String name) {
+            if (headers.containsKey(name)) {
+                return headers.get(name);
+            } else {
+                return Collections.emptyList();
+            }
+        }
+
         @Override
         public boolean containsHeader(String name) {
             return headers.containsKey(name);
diff --git a/test/framework/src/main/java/org/elasticsearch/test/rest/FakeRestRequest.java b/test/framework/src/main/java/org/elasticsearch/test/rest/FakeRestRequest.java
index a659d6af5c6a..58d31922f65a 100644
--- a/test/framework/src/main/java/org/elasticsearch/test/rest/FakeRestRequest.java
+++ b/test/framework/src/main/java/org/elasticsearch/test/rest/FakeRestRequest.java
@@ -102,6 +102,12 @@ public HttpRequest removeHeader(String header) {
         public HttpResponse createResponse(RestStatus status, BytesReference content) {
             Map<String, String> headers = new HashMap<>();
             return new HttpResponse() {
+
+                @Override
+                public RestStatus getRestStatus() {
+                    return status;
+                }
+
                 @Override
                 public void addHeader(String name, String value) {
                     headers.put(name, value);
@@ -111,6 +117,11 @@ public void addHeader(String name, String value) {
                 public boolean containsHeader(String name) {
                     return headers.containsKey(name);
                 }
+
+                @Override
+                public List<String> getAllHeaders(String name) {
+                    return Collections.singletonList(headers.get(name));
+                }
             };
         }
     }
diff --git a/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/transport/nio/SecurityNioHttpServerTransport.java b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/transport/nio/SecurityNioHttpServerTransport.java
index bf476e5b7346..d36ef74b2122 100644
--- a/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/transport/nio/SecurityNioHttpServerTransport.java
+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/transport/nio/SecurityNioHttpServerTransport.java
@@ -89,7 +89,8 @@ private SecurityHttpChannelFactory() {
         public NioHttpChannel createChannel(NioSelector selector, SocketChannel channel) throws IOException {
             NioHttpChannel httpChannel = new NioHttpChannel(channel);
             HttpReadWriteHandler httpHandler = new HttpReadWriteHandler(httpChannel,SecurityNioHttpServerTransport.this,
-                handlingSettings, corsConfig, selector.getTaskScheduler(), threadPool::relativeTimeInNanos);
+                handlingSettings, selector.getTaskScheduler(), threadPool::relativeTimeInNanos);
+
             final NioChannelHandler handler;
             if (ipFilter != null) {
                 handler = new NioIPFilter(httpHandler, httpChannel.getRemoteAddress(), ipFilter, IPFilter.HTTP_PROFILE_NAME);
