diff --git a/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java
index fcf88cc31af5..01508d3770f3 100644
--- a/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java
+++ b/core/src/main/java/org/elasticsearch/common/settings/AbstractScopedSettings.java
@@ -86,7 +86,7 @@ protected AbstractScopedSettings(Settings settings, Set<Setting<?>> settingsSet,
 
     protected void validateSettingKey(Setting setting) {
         if (isValidKey(setting.getKey()) == false && (setting.isGroupSetting() && isValidGroupKey(setting.getKey())
-            || isValidAffixKey(setting.getKey())) == false) {
+            || isValidAffixKey(setting.getKey())) == false || setting.getKey().endsWith(".0")) {
             throw new IllegalArgumentException("illegal settings key: [" + setting.getKey() + "]");
         }
     }
diff --git a/core/src/main/java/org/elasticsearch/common/settings/Setting.java b/core/src/main/java/org/elasticsearch/common/settings/Setting.java
index 1f807dbc0f20..a6a2e867e0d1 100644
--- a/core/src/main/java/org/elasticsearch/common/settings/Setting.java
+++ b/core/src/main/java/org/elasticsearch/common/settings/Setting.java
@@ -19,7 +19,6 @@
 package org.elasticsearch.common.settings;
 
 import org.apache.logging.log4j.Logger;
-import org.elasticsearch.ElasticsearchException;
 import org.elasticsearch.ElasticsearchParseException;
 import org.elasticsearch.common.Booleans;
 import org.elasticsearch.common.Nullable;
@@ -29,15 +28,11 @@
 import org.elasticsearch.common.unit.ByteSizeValue;
 import org.elasticsearch.common.unit.MemorySizeValue;
 import org.elasticsearch.common.unit.TimeValue;
-import org.elasticsearch.common.xcontent.NamedXContentRegistry;
 import org.elasticsearch.common.xcontent.ToXContentObject;
 import org.elasticsearch.common.xcontent.XContentBuilder;
 import org.elasticsearch.common.xcontent.XContentFactory;
-import org.elasticsearch.common.xcontent.XContentParser;
-import org.elasticsearch.common.xcontent.XContentType;
 
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
@@ -755,7 +750,7 @@ public String toString() {
 
         private ListSetting(String key, Function<Settings, List<String>> defaultStringValue, Function<String, List<T>> parser,
                             Property... properties) {
-            super(new ListKey(key), (s) -> Setting.arrayToParsableString(defaultStringValue.apply(s).toArray(Strings.EMPTY_ARRAY)), parser,
+            super(new ListKey(key), (s) -> Settings.encodeList(defaultStringValue.apply(s)), parser,
                 properties);
             this.defaultStringValue = defaultStringValue;
         }
@@ -763,18 +758,7 @@ private ListSetting(String key, Function<Settings, List<String>> defaultStringVa
         @Override
         public String getRaw(Settings settings) {
             String[] array = settings.getAsArray(getKey(), null);
-            return array == null ? defaultValue.apply(settings) : arrayToParsableString(array);
-        }
-
-        @Override
-        boolean hasComplexMatcher() {
-            return true;
-        }
-
-        @Override
-        public boolean exists(Settings settings) {
-            boolean exists = super.exists(settings);
-            return exists || settings.get(getKey() + ".0") != null;
+            return array == null ? defaultValue.apply(settings) : Settings.encodeList(Arrays.asList(array));
         }
 
         @Override
@@ -1006,7 +990,7 @@ public static ByteSizeValue parseByteSize(String s, ByteSizeValue minValue, Byte
     // TODO this one's two argument get is still broken
     public static <T> Setting<List<T>> listSetting(String key, Setting<List<T>> fallbackSetting, Function<String, T> singleValueParser,
                                                    Property... properties) {
-        return listSetting(key, (s) -> parseableStringToList(fallbackSetting.getRaw(s)), singleValueParser, properties);
+        return listSetting(key, (s) -> Settings.decodeList(fallbackSetting.getRaw(s)), singleValueParser, properties);
     }
 
     public static <T> Setting<List<T>> listSetting(String key, Function<Settings, List<String>> defaultStringValue,
@@ -1015,44 +999,11 @@ public static ByteSizeValue parseByteSize(String s, ByteSizeValue minValue, Byte
             throw new IllegalArgumentException("default value function must not return null");
         }
         Function<String, List<T>> parser = (s) ->
-                parseableStringToList(s).stream().map(singleValueParser).collect(Collectors.toList());
+                Settings.decodeList(s).stream().map(singleValueParser).collect(Collectors.toList());
 
         return new ListSetting<>(key, defaultStringValue, parser, properties);
     }
 
-    private static List<String> parseableStringToList(String parsableString) {
-        // EMPTY is safe here because we never call namedObject
-        try (XContentParser xContentParser = XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY, parsableString)) {
-            XContentParser.Token token = xContentParser.nextToken();
-            if (token != XContentParser.Token.START_ARRAY) {
-                throw new IllegalArgumentException("expected START_ARRAY but got " + token);
-            }
-            ArrayList<String> list = new ArrayList<>();
-            while ((token = xContentParser.nextToken()) != XContentParser.Token.END_ARRAY) {
-                if (token != XContentParser.Token.VALUE_STRING) {
-                    throw new IllegalArgumentException("expected VALUE_STRING but got " + token);
-                }
-                list.add(xContentParser.text());
-            }
-            return list;
-        } catch (IOException e) {
-            throw new IllegalArgumentException("failed to parse array", e);
-        }
-    }
-
-    private static String arrayToParsableString(String[] array) {
-        try {
-            XContentBuilder builder = XContentBuilder.builder(XContentType.JSON.xContent());
-            builder.startArray();
-            for (String element : array) {
-                builder.value(element);
-            }
-            builder.endArray();
-            return builder.string();
-        } catch (IOException ex) {
-            throw new ElasticsearchException(ex);
-        }
-    }
 
     public static Setting<Settings> groupSetting(String key, Property... properties) {
         return groupSetting(key, (s) -> {}, properties);
diff --git a/core/src/main/java/org/elasticsearch/common/settings/Settings.java b/core/src/main/java/org/elasticsearch/common/settings/Settings.java
index 2ff77cba351b..6dc9c3995c72 100644
--- a/core/src/main/java/org/elasticsearch/common/settings/Settings.java
+++ b/core/src/main/java/org/elasticsearch/common/settings/Settings.java
@@ -20,6 +20,7 @@
 package org.elasticsearch.common.settings;
 
 import org.apache.lucene.util.SetOnce;
+import org.elasticsearch.ElasticsearchException;
 import org.elasticsearch.Version;
 import org.elasticsearch.common.Booleans;
 import org.elasticsearch.common.Strings;
@@ -37,9 +38,10 @@
 import org.elasticsearch.common.unit.RatioValue;
 import org.elasticsearch.common.unit.SizeValue;
 import org.elasticsearch.common.unit.TimeValue;
-import org.elasticsearch.common.xcontent.ToXContent.Params;
+import org.elasticsearch.common.xcontent.NamedXContentRegistry;
 import org.elasticsearch.common.xcontent.ToXContentFragment;
 import org.elasticsearch.common.xcontent.XContentBuilder;
+import org.elasticsearch.common.xcontent.XContentParser;
 import org.elasticsearch.common.xcontent.XContentType;
 
 import java.io.IOException;
@@ -69,8 +71,6 @@
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.UnaryOperator;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -84,8 +84,7 @@
 public final class Settings implements ToXContentFragment {
 
     public static final Settings EMPTY = new Builder().build();
-    private static final Pattern ARRAY_PATTERN = Pattern.compile("(.*)\\.\\d+$");
-
+    private static final char INTERNAL_LIST_MARKER = '\uFEFF';
     /** The raw settings from the full key to raw string value. */
     private final Map<String, String> settings;
 
@@ -94,6 +93,7 @@
 
     /** The first level of setting names. This is constructed lazily in {@link #names()}. */
     private final SetOnce<Set<String>> firstLevelNames = new SetOnce<>();
+    private final Set<String> listKeys = new HashSet<>();
 
     /**
      * Setting names found in this Settings for both string and secure settings.
@@ -132,13 +132,6 @@ SecureSettings getSecureSettings() {
         for (Map.Entry<String, String> entry : settings.entrySet()) {
             processSetting(map, "", entry.getKey(), entry.getValue());
         }
-        for (Map.Entry<String, Object> entry : map.entrySet()) {
-            if (entry.getValue() instanceof Map) {
-                @SuppressWarnings("unchecked") Map<String, Object> valMap = (Map<String, Object>) entry.getValue();
-                entry.setValue(convertMapsToArrays(valMap));
-            }
-        }
-
         return map;
     }
 
@@ -152,7 +145,11 @@ private void processSetting(Map<String, Object> map, String prefix, String setti
                     map.put(prefix + setting + "." + entry.getKey(), entry.getValue());
                 }
             }
-            map.put(prefix + setting, value);
+            Object oValue = value;
+            if (isInternalList(value)) {
+                oValue = decodeList(value);
+            }
+            map.put(prefix + setting, oValue);
         } else {
             String key = setting.substring(0, prefixLength);
             String rest = setting.substring(prefixLength + 1);
@@ -176,46 +173,6 @@ private void processSetting(Map<String, Object> map, String prefix, String setti
         }
     }
 
-    private Object convertMapsToArrays(Map<String, Object> map) {
-        if (map.isEmpty()) {
-            return map;
-        }
-        boolean isArray = true;
-        int maxIndex = -1;
-        for (Map.Entry<String, Object> entry : map.entrySet()) {
-            if (isArray) {
-                try {
-                    int index = Integer.parseInt(entry.getKey());
-                    if (index >= 0) {
-                        maxIndex = Math.max(maxIndex, index);
-                    } else {
-                        isArray = false;
-                    }
-                } catch (NumberFormatException ex) {
-                    isArray = false;
-                }
-            }
-            if (entry.getValue() instanceof Map) {
-                @SuppressWarnings("unchecked") Map<String, Object> valMap = (Map<String, Object>) entry.getValue();
-                entry.setValue(convertMapsToArrays(valMap));
-            }
-        }
-        if (isArray && (maxIndex + 1) == map.size()) {
-            ArrayList<Object> newValue = new ArrayList<>(maxIndex + 1);
-            for (int i = 0; i <= maxIndex; i++) {
-                Object obj = map.get(Integer.toString(i));
-                if (obj == null) {
-                    // Something went wrong. Different format?
-                    // Bailout!
-                    return map;
-                }
-                newValue.add(obj);
-            }
-            return newValue;
-        }
-        return map;
-    }
-
     /**
      * A settings that are filtered (and key is removed) with the specified prefix.
      */
@@ -246,7 +203,11 @@ public Settings getAsSettings(String setting) {
      * @return The setting value, <tt>null</tt> if it does not exists.
      */
     public String get(String setting) {
-        return settings.get(setting);
+        String s = settings.get(setting);
+        if (isInternalList(s)) {
+            return stripListMarker(s);
+        }
+        return s;
     }
 
     /**
@@ -382,90 +343,93 @@ public SizeValue getAsSize(String setting, SizeValue defaultValue) throws Settin
     }
 
     /**
-     * The values associated with a setting prefix as an array. The settings array is in the format of:
-     * <tt>settingPrefix.[index]</tt>.
+     * The values associated with a setting prefix as an array.
      * <p>
      * It will also automatically load a comma separated list under the settingPrefix and merge with
      * the numbered format.
      *
-     * @param settingPrefix The setting prefix to load the array by
+     * @param key The setting key to load the array by
      * @return The setting array values
      */
-    public String[] getAsArray(String settingPrefix) throws SettingsException {
-        return getAsArray(settingPrefix, Strings.EMPTY_ARRAY, true);
+    public String[] getAsArray(String key) throws SettingsException {
+        return getAsArray(key, Strings.EMPTY_ARRAY, true);
     }
 
     /**
-     * The values associated with a setting prefix as an array. The settings array is in the format of:
-     * <tt>settingPrefix.[index]</tt>.
+     * The values associated with a setting prefix as an array.
      * <p>
      * If commaDelimited is true, it will automatically load a comma separated list under the settingPrefix and merge with
      * the numbered format.
      *
-     * @param settingPrefix The setting prefix to load the array by
+     * @param key The setting key to load the array by
      * @return The setting array values
      */
-    public String[] getAsArray(String settingPrefix, String[] defaultArray) throws SettingsException {
-        return getAsArray(settingPrefix, defaultArray, true);
+    public String[] getAsArray(String key, String[] defaultArray) throws SettingsException {
+        return getAsArray(key, defaultArray, true);
     }
 
     /**
-     * The values associated with a setting prefix as an array. The settings array is in the format of:
-     * <tt>settingPrefix.[index]</tt>.
+     * The values associated with a setting prefix as an array.
      * <p>
      * It will also automatically load a comma separated list under the settingPrefix and merge with
      * the numbered format.
      *
-     * @param settingPrefix  The setting prefix to load the array by
+     * @param setting  The setting to load the array by
      * @param defaultArray   The default array to use if no value is specified
      * @param commaDelimited Whether to try to parse a string as a comma-delimited value
      * @return The setting array values
      */
-    public String[] getAsArray(String settingPrefix, String[] defaultArray, Boolean commaDelimited) throws SettingsException {
-        List<String> result = new ArrayList<>();
-
-        final String valueFromPrefix = get(settingPrefix);
-        final String valueFromPreifx0 = get(settingPrefix + ".0");
+    public String[] getAsArray(String setting, String[] defaultArray, Boolean commaDelimited) throws SettingsException {
 
-        if (valueFromPrefix != null && valueFromPreifx0 != null) {
+        final String value = settings.get(setting);
+        final String valueFromPreifx0 = settings.get(setting + ".0");
+        if (value != null && valueFromPreifx0 != null) {
             final String message = String.format(
-                    Locale.ROOT,
-                    "settings object contains values for [%s=%s] and [%s=%s]",
-                    settingPrefix,
-                    valueFromPrefix,
-                    settingPrefix + ".0",
-                    valueFromPreifx0);
+                Locale.ROOT,
+                "settings object contains values for [%s=%s] and [%s=%s]",
+                setting,
+                value,
+                setting + ".0",
+                valueFromPreifx0);
             throw new IllegalStateException(message);
         }
-
-        if (get(settingPrefix) != null) {
-            if (commaDelimited) {
-                String[] strings = Strings.splitStringByCommaToArray(get(settingPrefix));
+        final String[] array;
+        if (value != null) {
+            if (isInternalList(value)) {
+                List<String> strings = decodeList(value);
+                array = strings.toArray(new String[strings.size()]);
+            } else if (commaDelimited) {
+                List<String> result = new ArrayList<>();
+                String[] strings = Strings.splitStringByCommaToArray(get(setting));
                 if (strings.length > 0) {
                     for (String string : strings) {
                         result.add(string.trim());
                     }
                 }
-            } else {
-                result.add(get(settingPrefix).trim());
-            }
-        }
-
-        int counter = 0;
-        while (true) {
-            String value = get(settingPrefix + '.' + (counter++));
-            if (value == null) {
-                break;
+                array = result.toArray(new String[result.size()]);
+            }  else {
+                array = new String[] {value}; // single value
             }
-            result.add(value.trim());
+        } else {
+            array = Strings.EMPTY_ARRAY;
         }
-        if (result.isEmpty()) {
+        if (array.length == 0) {
             return defaultArray;
         }
-        return result.toArray(new String[result.size()]);
+        return array;
     }
 
+    private static boolean isInternalList(String value) {
+        return value != null
+            && value.length() >= 4
+            && value.charAt(0) == INTERNAL_LIST_MARKER
+            && value.charAt(value.length()-1) ==  INTERNAL_LIST_MARKER;
+    }
 
+    private static String stripListMarker(String value) {
+        assert isInternalList(value) : "can't strip markers off: " + value;
+        return value.substring(1, value.length()-1);
+    }
 
     /**
      * Returns group settings for the given setting prefix.
@@ -593,6 +557,23 @@ public static Settings readSettingsFromStream(StreamInput in) throws IOException
     public static void writeSettingsToStream(Settings settings, StreamOutput out) throws IOException {
         // pull getAsMap() to exclude secure settings in size()
         Set<Map.Entry<String, String>> entries = settings.getAsMap().entrySet();
+        if (out.getVersion().onOrAfter(Version.V_7_0_0_alpha1)) {
+            entries = settings.getAsMap().entrySet();
+        } else {
+            Map<String, String> legacyEntries = new TreeMap<>();
+            for (Map.Entry<String, String> entry : settings.getAsMap().entrySet()) {
+                String value = entry.getValue();
+                List<String> optional = maybeGetList(value);
+                if (optional != null) {
+                    for (int i = 0; i < optional.size(); i++) {
+                        legacyEntries.put(entry.getKey() + "." + i, optional.get(i));
+                    }
+                } else {
+                    legacyEntries.put(entry.getKey(), value);
+                }
+            }
+            entries = legacyEntries.entrySet();
+        }
         out.writeVInt(entries.size());
         for (Map.Entry<String, String> entry : entries) {
             out.writeString(entry.getKey());
@@ -610,18 +591,43 @@ public static Builder builder() {
     @Override
     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
         Settings settings = SettingsFilter.filterSettings(params, this);
-        if (!params.paramAsBoolean("flat_settings", false)) {
+        if (params.paramAsBoolean("flat_settings", false) == false) {
             for (Map.Entry<String, Object> entry : settings.getAsStructuredMap().entrySet()) {
-                builder.field(entry.getKey(), entry.getValue());
+                Object value = entry.getValue();
+                if (value instanceof String) {
+                    maybeWriteAsList(builder, entry.getKey(), (String) value);
+                } else {
+                    builder.field(entry.getKey(), value);
+                }
             }
         } else {
             for (Map.Entry<String, String> entry : settings.getAsMap().entrySet()) {
-                builder.field(entry.getKey(), entry.getValue());
+                maybeWriteAsList(builder, entry.getKey(), entry.getValue());
             }
         }
         return builder;
     }
 
+    private static List<String>  maybeGetList( String value) throws IOException {
+        if (value != null && isInternalList(value)) { // we try to write it as a list if it is a list
+            return decodeList(value);
+        }
+        return null;
+    }
+
+    private static void maybeWriteAsList(XContentBuilder builder, String key, String value) throws IOException {
+        List<String> values = maybeGetList(value);
+        if (values != null) { // we try to write it as a list if it is a list
+            builder.startArray(key);
+            for (String v : values) {
+                builder.value(v);
+            }
+            builder.endArray();
+        } else {
+            builder.field(key, value);
+        }
+    }
+
     public static final Set<String> FORMAT_PARAMS =
         Collections.unmodifiableSet(new HashSet<>(Arrays.asList("settings_filter", "flat_settings")));
 
@@ -739,6 +745,14 @@ public Builder put(Object... settings) {
          * @return The builder
          */
         public Builder put(String key, String value) {
+            if (key.endsWith(".0")) {
+                map.remove(key.substring(0, key.lastIndexOf('.')));
+            } else if (map.containsKey(key + ".0")) {
+                int counter = 0;
+                while (map.remove(key + '.' + counter) != null) {
+                    counter++;
+                }
+            }
             map.put(key, value);
             return this;
         }
@@ -755,7 +769,7 @@ public Builder putNull(String key) {
          * @return The builder
          */
         public Builder put(String key, Class clazz) {
-            map.put(key, clazz.getName());
+            put(key, clazz.getName());
             return this;
         }
 
@@ -875,37 +889,7 @@ public Builder putArray(String setting, String... values) {
          * @return The builder
          */
         public Builder putArray(String setting, List<String> values) {
-            remove(setting);
-            int counter = 0;
-            while (true) {
-                String value = map.remove(setting + '.' + (counter++));
-                if (value == null) {
-                    break;
-                }
-            }
-            for (int i = 0; i < values.size(); i++) {
-                put(setting + "." + i, values.get(i));
-            }
-            return this;
-        }
-
-        /**
-         * Sets the setting as an array of values, but keeps existing elements for the key.
-         */
-        public Builder extendArray(String setting, String... values) {
-            // check for a singular (non array) value
-            String oldSingle = remove(setting);
-            // find the highest array index
-            int counter = 0;
-            while (map.containsKey(setting + '.' + counter)) {
-                ++counter;
-            }
-            if (oldSingle != null) {
-                put(setting + '.' + counter++, oldSingle);
-            }
-            for (String value : values) {
-                put(setting + '.' + counter++, value);
-            }
+            put(setting, encodeList(values));
             return this;
         }
 
@@ -929,7 +913,6 @@ public Builder put(String settingPrefix, String groupName, String[] settings, St
          * Sets all the provided settings.
          */
         public Builder put(Settings settings) {
-            removeNonArraysFieldsIfNewSettingsContainsFieldAsArray(settings.getAsMap());
             map.putAll(settings.getAsMap());
             if (settings.getSecureSettings() != null) {
                 setSecureSettings(settings.getSecureSettings());
@@ -941,42 +924,12 @@ public Builder put(Settings settings) {
          * Sets all the provided settings.
          */
         public Builder put(Map<String, String> settings) {
-            removeNonArraysFieldsIfNewSettingsContainsFieldAsArray(settings);
+            settings = new HashMap<>(settings);
+            processLegacyLists(settings);
             map.putAll(settings);
             return this;
         }
 
-        /**
-         * Removes non array values from the existing map, if settings contains an array value instead
-         *
-         * Example:
-         *   Existing map contains: {key:value}
-         *   New map contains: {key:[value1,value2]} (which has been flattened to {}key.0:value1,key.1:value2})
-         *
-         *   This ensure that that the 'key' field gets removed from the map in order to override all the
-         *   data instead of merging
-         */
-        private void removeNonArraysFieldsIfNewSettingsContainsFieldAsArray(Map<String, String> settings) {
-            List<String> prefixesToRemove = new ArrayList<>();
-            for (final Map.Entry<String, String> entry : settings.entrySet()) {
-                final Matcher matcher = ARRAY_PATTERN.matcher(entry.getKey());
-                if (matcher.matches()) {
-                    prefixesToRemove.add(matcher.group(1));
-                } else if (map.keySet().stream().anyMatch(key -> key.startsWith(entry.getKey() + "."))) {
-                    prefixesToRemove.add(entry.getKey());
-                }
-            }
-            for (String prefix : prefixesToRemove) {
-                Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();
-                while (iterator.hasNext()) {
-                    Map.Entry<String, String> entry = iterator.next();
-                    if (entry.getKey().startsWith(prefix + ".") || entry.getKey().equals(prefix)) {
-                        iterator.remove();
-                    }
-                }
-            }
-        }
-
         /**
          * Sets all the provided settings.
          */
@@ -1131,8 +1084,31 @@ public Builder normalizePrefix(String prefix) {
          * set on this builder.
          */
         public Settings build() {
+            processLegacyLists(map);
             return new Settings(map, secureSettings.get());
         }
+
+        private void processLegacyLists(Map<String, String> map) {
+            String[] array = map.keySet().toArray(new String[map.size()]);
+            for (String key : array) {
+                if (key.endsWith(".0")) { // let's only look at the head of the list and convert in order starting there.
+                    int counter = 0;
+                    String prefix = key.substring(0, key.lastIndexOf('.'));
+                    List<String> values = new ArrayList<>();
+                    while (true) {
+                        String listKey = prefix + '.' + (counter++);
+                        String value = get(listKey);
+                        if (value == null) {
+                            map.put(prefix, encodeList(values));
+                            break;
+                        } else {
+                            values.add(value);
+                            map.remove(listKey);
+                        }
+                    }
+                }
+            }
+        }
     }
 
     // TODO We could use an FST internally to make things even faster and more compact
@@ -1298,4 +1274,42 @@ public void close() throws IOException {
             delegate.close();
         }
     }
+
+
+    static String encodeList(List<String> values) {
+        try {
+            XContentBuilder builder = XContentBuilder.builder(XContentType.JSON.xContent());
+            builder.startArray();
+            for (String element : values) {
+                builder.value(element);
+            }
+            builder.endArray();
+            return INTERNAL_LIST_MARKER + builder.string() + INTERNAL_LIST_MARKER;
+        } catch (IOException ex) {
+            throw new ElasticsearchException(ex);
+        }
+    }
+
+    static List<String> decodeList(String value) {
+        if (isInternalList(value)) {
+            value = stripListMarker(value);
+        }
+        // EMPTY is safe here because we never call namedObject
+        try (XContentParser xContentParser = XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY, value)) {
+            XContentParser.Token token = xContentParser.nextToken();
+            if (token != XContentParser.Token.START_ARRAY) {
+                throw new IllegalArgumentException("expected START_ARRAY but got " + token);
+            }
+            ArrayList<String> list = new ArrayList<>();
+            while ((token = xContentParser.nextToken()) != XContentParser.Token.END_ARRAY) {
+                if (token != XContentParser.Token.VALUE_STRING) {
+                    throw new IllegalArgumentException("expected VALUE_STRING but got " + token);
+                }
+                list.add(xContentParser.text());
+            }
+            return list;
+        } catch (IOException e) {
+            throw new IllegalArgumentException("failed to parse array", e);
+        }
+    }
 }
diff --git a/core/src/main/java/org/elasticsearch/index/analysis/Analysis.java b/core/src/main/java/org/elasticsearch/index/analysis/Analysis.java
index f53b245e14c3..c6d957ebff57 100644
--- a/core/src/main/java/org/elasticsearch/index/analysis/Analysis.java
+++ b/core/src/main/java/org/elasticsearch/index/analysis/Analysis.java
@@ -70,6 +70,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -106,7 +107,7 @@ public static CharArraySet parseStemExclusion(Settings settings, CharArraySet de
                 return CharArraySet.EMPTY_SET;
             } else {
                 // LUCENE 4 UPGRADE: Should be settings.getAsBoolean("stem_exclusion_case", false)?
-                return new CharArraySet(Strings.commaDelimitedListToSet(value), false);
+                return new CharArraySet(new HashSet<>(Arrays.asList(settings.getAsArray("stem_exclusion"))), false);
             }
         }
         String[] stemExclusion = settings.getAsArray("stem_exclusion", null);
@@ -164,7 +165,7 @@ public static CharArraySet parseWords(Environment env, Settings settings, String
             if ("_none_".equals(value)) {
                 return CharArraySet.EMPTY_SET;
             } else {
-                return resolveNamedWords(Strings.commaDelimitedListToSet(value), namedWords, ignoreCase);
+                return resolveNamedWords(new HashSet<>(Arrays.asList(settings.getAsArray(name))), namedWords, ignoreCase);
             }
         }
         List<String> pathLoadedWords = getWordList(env, settings, name);
diff --git a/core/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java b/core/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java
index c00055d2897a..043a534e1fe6 100644
--- a/core/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java
+++ b/core/src/test/java/org/elasticsearch/common/settings/ScopedSettingsTests.java
@@ -356,8 +356,8 @@ public void testGet() {
         assertEquals(setting, ShardsLimitAllocationDecider.CLUSTER_TOTAL_SHARDS_PER_NODE_SETTING);
 
         // array settings - complex matcher
-        assertNotNull(settings.get("transport.tracer.include." + randomIntBetween(1, 100)));
-        assertSame(TransportService.TRACE_LOG_INCLUDE_SETTING, settings.get("transport.tracer.include." + randomIntBetween(1, 100)));
+        assertNotNull(settings.get("transport.tracer.include"));
+        assertSame(TransportService.TRACE_LOG_INCLUDE_SETTING, settings.get("transport.tracer.include"));
 
         // array settings - complex matcher - only accepts numbers
         assertNull(settings.get("transport.tracer.include.FOO"));
@@ -372,7 +372,7 @@ public void testIsDynamic(){
         assertTrue(settings.isDynamicSetting("foo.bar"));
         assertNotNull(settings.get("foo.bar.baz"));
         settings = new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS);
-        assertTrue(settings.isDynamicSetting("transport.tracer.include." + randomIntBetween(1, 100)));
+        assertFalse(settings.isDynamicSetting("transport.tracer.include." + randomIntBetween(1, 100)));
         assertFalse(settings.isDynamicSetting("transport.tracer.include.BOOM"));
         assertTrue(settings.isDynamicSetting("cluster.routing.allocation.require.value"));
     }
@@ -407,21 +407,21 @@ public void testDiff() throws IOException {
         ClusterSettings settings = new ClusterSettings(Settings.EMPTY, new HashSet<>(Arrays.asList(fooBar, fooBarBaz, foorBarQuux,
             someGroup, someAffix)));
         Settings diff = settings.diff(Settings.builder().put("foo.bar", 5).build(), Settings.EMPTY);
-        assertEquals(4, diff.size()); // 4 since foo.bar.quux has 3 values essentially
+        assertEquals(2, diff.size()); // 4 since foo.bar.quux has 3 values essentially
         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(1));
         assertArrayEquals(diff.getAsArray("foo.bar.quux", null), new String[] {"a", "b", "c"});
 
         diff = settings.diff(
                 Settings.builder().put("foo.bar", 5).build(),
                 Settings.builder().put("foo.bar.baz", 17).putArray("foo.bar.quux", "d", "e", "f").build());
-        assertEquals(4, diff.size()); // 4 since foo.bar.quux has 3 values essentially
+        assertEquals(2, diff.size()); // 4 since foo.bar.quux has 3 values essentially
         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(17));
         assertArrayEquals(diff.getAsArray("foo.bar.quux", null), new String[] {"d", "e", "f"});
 
         diff = settings.diff(
             Settings.builder().put("some.group.foo", 5).build(),
             Settings.builder().put("some.group.foobar", 17, "some.group.foo", 25).build());
-        assertEquals(6, diff.size()); // 6 since foo.bar.quux has 3 values essentially
+        assertEquals(4, diff.size()); // 6 since foo.bar.quux has 3 values essentially
         assertThat(diff.getAsInt("some.group.foobar", null), equalTo(17));
         assertNull(diff.get("some.group.foo"));
         assertArrayEquals(diff.getAsArray("foo.bar.quux", null), new String[] {"a", "b", "c"});
@@ -432,7 +432,7 @@ public void testDiff() throws IOException {
             Settings.builder().put("some.prefix.foo.somekey", 5).build(),
             Settings.builder().put("some.prefix.foobar.somekey", 17,
                 "some.prefix.foo.somekey", 18).build());
-        assertEquals(6, diff.size()); // 6 since foo.bar.quux has 3 values essentially
+        assertEquals(4, diff.size()); // 6 since foo.bar.quux has 3 values essentially
         assertThat(diff.getAsInt("some.prefix.foobar.somekey", null), equalTo(17));
         assertNull(diff.get("some.prefix.foo.somekey"));
         assertArrayEquals(diff.getAsArray("foo.bar.quux", null), new String[] {"a", "b", "c"});
@@ -458,7 +458,7 @@ public void testDiffWithAffixAndComplexMatcher() {
         diff = settings.diff(
             Settings.builder().put("foo.bar", 5).build(),
             Settings.builder().put("foo.bar.baz", 17).putArray("foo.bar.quux", "d", "e", "f").build());
-        assertEquals(4, diff.size());
+        assertEquals(2, diff.size());
         assertThat(diff.getAsInt("foo.bar.baz", null), equalTo(17));
         assertArrayEquals(diff.getAsArray("foo.bar.quux", null), new String[] {"d", "e", "f"});
 
@@ -490,7 +490,7 @@ public void testDiffWithAffixAndComplexMatcher() {
             .putArray("foo.bar.quux", "x", "y", "z")
             .putArray("foo.baz.quux", "d", "e", "f")
                 .build());
-        assertEquals(9, diff.size());
+        assertEquals(5, diff.size());
         assertThat(diff.getAsInt("some.prefix.foobar.somekey", null), equalTo(17));
         assertNull(diff.get("some.prefix.foo.somekey"));
         assertArrayEquals(diff.getAsArray("foo.bar.quux", null), new String[] {"x", "y", "z"});
@@ -700,19 +700,19 @@ public void testOverlappingComplexMatchSettings() {
         Set<Setting<?>> settings = new LinkedHashSet<>(2);
         final boolean groupFirst = randomBoolean();
         final Setting<?> groupSetting = Setting.groupSetting("foo.", Property.NodeScope);
-        final Setting<?> listSetting =
-            Setting.listSetting("foo.bar", Collections.emptyList(), Function.identity(), Property.NodeScope);
-        settings.add(groupFirst ? groupSetting : listSetting);
-        settings.add(groupFirst ? listSetting : groupSetting);
+        final Setting<?> otherGroup =
+            Setting.groupSetting("foo.bar.", Property.NodeScope);
+        settings.add(groupFirst ? groupSetting : otherGroup);
+        settings.add(groupFirst ? otherGroup : groupSetting);
 
         try {
             new ClusterSettings(Settings.EMPTY, settings);
             fail("an exception should have been thrown because settings overlap");
         } catch (IllegalArgumentException e) {
             if (groupFirst) {
-                assertEquals("complex setting key: [foo.bar] overlaps existing setting key: [foo.]", e.getMessage());
+                assertEquals("complex setting key: [foo.bar.] overlaps existing setting key: [foo.]", e.getMessage());
             } else {
-                assertEquals("complex setting key: [foo.] overlaps existing setting key: [foo.bar]", e.getMessage());
+                assertEquals("complex setting key: [foo.] overlaps existing setting key: [foo.bar.]", e.getMessage());
             }
         }
     }
diff --git a/core/src/test/java/org/elasticsearch/common/settings/SettingTests.java b/core/src/test/java/org/elasticsearch/common/settings/SettingTests.java
index 5a5f1c86c5f3..f2b6cbc1a541 100644
--- a/core/src/test/java/org/elasticsearch/common/settings/SettingTests.java
+++ b/core/src/test/java/org/elasticsearch/common/settings/SettingTests.java
@@ -602,7 +602,7 @@ public void testAffixSettingsFailOnGet() {
         expectThrows(UnsupportedOperationException.class, () -> listAffixSetting.get(Settings.EMPTY));
         expectThrows(UnsupportedOperationException.class, () -> listAffixSetting.getRaw(Settings.EMPTY));
         assertEquals(Collections.singletonList("testelement"), listAffixSetting.getDefault(Settings.EMPTY));
-        assertEquals("[\"testelement\"]", listAffixSetting.getDefaultRaw(Settings.EMPTY));
+        assertEquals(Arrays.asList("testelement"), Settings.decodeList(listAffixSetting.getDefaultRaw(Settings.EMPTY)));
     }
 
     public void testMinMaxInt() {
diff --git a/core/src/test/java/org/elasticsearch/common/settings/SettingsTests.java b/core/src/test/java/org/elasticsearch/common/settings/SettingsTests.java
index 5419bb5124c3..98da88fe1ae4 100644
--- a/core/src/test/java/org/elasticsearch/common/settings/SettingsTests.java
+++ b/core/src/test/java/org/elasticsearch/common/settings/SettingsTests.java
@@ -21,16 +21,25 @@
 
 import org.elasticsearch.Version;
 import org.elasticsearch.common.Booleans;
+import org.elasticsearch.common.bytes.BytesReference;
 import org.elasticsearch.common.io.stream.BytesStreamOutput;
 import org.elasticsearch.common.io.stream.StreamInput;
+import org.elasticsearch.common.io.stream.StreamOutput;
 import org.elasticsearch.common.logging.DeprecationLogger;
 import org.elasticsearch.common.logging.ESLoggerFactory;
 import org.elasticsearch.common.settings.loader.YamlSettingsLoader;
+import org.elasticsearch.common.xcontent.ToXContent;
+import org.elasticsearch.common.xcontent.XContentBuilder;
+import org.elasticsearch.common.xcontent.XContentType;
 import org.elasticsearch.test.ESTestCase;
+import org.elasticsearch.test.VersionUtils;
 import org.hamcrest.Matchers;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -304,7 +313,7 @@ public void testThatArraysAreOverriddenCorrectly() throws IOException {
                 .put(Settings.builder().put("value.data", "1").build())
                 .build();
         assertThat(settings.get("value.data"), is("1"));
-        assertThat(settings.get("value"), is(nullValue()));
+        assertThat(settings.getAsArray("value"), is(new String[] {"4", "5"}));
     }
 
     public void testPrefixNormalization() {
@@ -551,15 +560,94 @@ public void testSecureSettingConflict() {
         assertTrue(e.getMessage().contains("must be stored inside the Elasticsearch keystore"));
     }
 
-    public void testGetAsArrayFailsOnDuplicates() {
+    public void testConcreteWillOverrideLegacyArray() {
         final Settings settings =
                 Settings.builder()
                         .put("foobar.0", "bar")
                         .put("foobar.1", "baz")
                         .put("foobar", "foo")
                         .build();
-        final IllegalStateException e = expectThrows(IllegalStateException.class, () -> settings.getAsArray("foobar"));
-        assertThat(e, hasToString(containsString("settings object contains values for [foobar=foo] and [foobar.0=bar]")));
+        assertEquals(1, settings.size());
+        assertEquals(settings.get("foobar"), "foo");
+    }
+
+    public void testLegacyArrayOverrideConcrete() {
+        final Settings settings =
+            Settings.builder()
+                .put("foobar", "foo")
+                .put("foobar.0", "bar")
+                .put("foobar.1", "baz")
+                .build();
+        assertEquals(1, settings.size());
+        assertArrayEquals(settings.getAsArray("foobar"), new String[] {"bar", "baz"});
+    }
+
+    public void testToXContent() throws IOException {
+        Settings test = Settings.builder().putArray("foo.bar", "1", "2", "3").put("foo.bar.baz", "test").build();
+        XContentBuilder builder = XContentBuilder.builder(XContentType.JSON.xContent());
+        builder.startObject();
+        test.toXContent(builder, new ToXContent.MapParams(Collections.emptyMap()));
+        builder.endObject();
+        assertEquals("{\"foo\":{\"bar.baz\":\"test\",\"bar\":[\"1\",\"2\",\"3\"]}}", builder.string());
+
+        builder = XContentBuilder.builder(XContentType.JSON.xContent());
+        builder.startObject();
+        test.toXContent(builder, new ToXContent.MapParams(Collections.singletonMap("flat_settings", "true")));
+        builder.endObject();
+        assertEquals("{\"foo.bar\":[\"1\",\"2\",\"3\"],\"foo.bar.baz\":\"test\"}", builder.string());
+    }
+
+    public void testReadLegacyFromStream() throws IOException {
+        BytesStreamOutput output = new BytesStreamOutput();
+        output.writeVInt(5);
+        output.writeString("foo.bar.1");
+        output.writeOptionalString("1");
+        output.writeString("foo.bar.0");
+        output.writeOptionalString("0");
+        output.writeString("foo.bar.2");
+        output.writeOptionalString("2");
+        output.writeString("foo.bar.3");
+        output.writeOptionalString("3");
+        output.writeString("foo.bar.baz");
+        output.writeOptionalString("baz");
+        Settings settings = Settings.readSettingsFromStream(StreamInput.wrap(BytesReference.toBytes(output.bytes())));
+        assertEquals(2, settings.size());
+        assertArrayEquals(new String[]{"0", "1", "2", "3"}, settings.getAsArray("foo.bar"));
+        assertEquals("baz", settings.get("foo.bar.baz"));
+    }
+
+    public void testWriteLegacyOutput() throws IOException {
+        BytesStreamOutput output = new BytesStreamOutput();
+        output.setVersion(VersionUtils.getPreviousVersion(Version.CURRENT));
+        Settings settings = Settings.builder().putArray("foo.bar", "0", "1", "2", "3").put("foo.bar.baz", "baz").build();
+        Settings.writeSettingsToStream(settings, output);
+        StreamInput in = StreamInput.wrap(BytesReference.toBytes(output.bytes()));
+        assertEquals(5, in.readVInt());
+        Map<String, String> keyValues = new HashMap<>();
+        for (int i = 0; i < 5; i++){
+            keyValues.put(in.readString(), in.readOptionalString());
+        }
+        assertEquals(keyValues.get("foo.bar.0"), "0");
+        assertEquals(keyValues.get("foo.bar.1"), "1");
+        assertEquals(keyValues.get("foo.bar.2"), "2");
+        assertEquals(keyValues.get("foo.bar.3"), "3");
+        assertEquals(keyValues.get("foo.bar.baz"), "baz");
+    }
+
+    public void testReadWriteArray() throws IOException {
+        BytesStreamOutput output = new BytesStreamOutput();
+        output.setVersion(Version.CURRENT);
+        Settings settings = Settings.builder().putArray("foo.bar", "0", "1", "2", "3").put("foo.bar.baz", "baz").build();
+        Settings.writeSettingsToStream(settings, output);
+        StreamInput in = StreamInput.wrap(BytesReference.toBytes(output.bytes()));
+        assertEquals(2, in.readVInt());
+        Map<String, String> keyValues = new HashMap<>();
+        for (int i = 0; i < 2; i++){
+            keyValues.put(in.readString(), in.readOptionalString());
+        }
+        Settings build = Settings.builder().put(keyValues).build();
+        assertEquals(build.getAsArray("foo.bar"), new String[] {"0", "1", "2", "3"});
+        assertEquals(build.get("foo.bar.baz"), "baz");
     }
 
 }
diff --git a/core/src/test/java/org/elasticsearch/common/settings/loader/JsonSettingsLoaderTests.java b/core/src/test/java/org/elasticsearch/common/settings/loader/JsonSettingsLoaderTests.java
index fc1300d94138..2818356f8f39 100644
--- a/core/src/test/java/org/elasticsearch/common/settings/loader/JsonSettingsLoaderTests.java
+++ b/core/src/test/java/org/elasticsearch/common/settings/loader/JsonSettingsLoaderTests.java
@@ -42,8 +42,7 @@ public void testSimpleJsonSettings() throws Exception {
         assertThat(settings.getAsInt("test1.test2.value3", -1), equalTo(2));
 
         // check array
-        assertThat(settings.get("test1.test3.0"), equalTo("test3-1"));
-        assertThat(settings.get("test1.test3.1"), equalTo("test3-2"));
+        assertThat(settings.get("test1.test3"), equalTo("[\"test3-1\",\"test3-2\"]"));
         assertThat(settings.getAsArray("test1.test3").length, equalTo(2));
         assertThat(settings.getAsArray("test1.test3")[0], equalTo("test3-1"));
         assertThat(settings.getAsArray("test1.test3")[1], equalTo("test3-2"));
diff --git a/core/src/test/java/org/elasticsearch/common/settings/loader/YamlSettingsLoaderTests.java b/core/src/test/java/org/elasticsearch/common/settings/loader/YamlSettingsLoaderTests.java
index e4b4de0ceb61..ad9dc5759dff 100644
--- a/core/src/test/java/org/elasticsearch/common/settings/loader/YamlSettingsLoaderTests.java
+++ b/core/src/test/java/org/elasticsearch/common/settings/loader/YamlSettingsLoaderTests.java
@@ -46,8 +46,7 @@ public void testSimpleYamlSettings() throws Exception {
         assertThat(settings.getAsInt("test1.test2.value3", -1), equalTo(2));
 
         // check array
-        assertThat(settings.get("test1.test3.0"), equalTo("test3-1"));
-        assertThat(settings.get("test1.test3.1"), equalTo("test3-2"));
+        assertThat(settings.get("test1.test3"), equalTo("[\"test3-1\",\"test3-2\"]"));
         assertThat(settings.getAsArray("test1.test3").length, equalTo(2));
         assertThat(settings.getAsArray("test1.test3")[0], equalTo("test3-1"));
         assertThat(settings.getAsArray("test1.test3")[1], equalTo("test3-2"));
diff --git a/modules/analysis-common/src/test/java/org/elasticsearch/analysis/common/MassiveWordListTests.java b/modules/analysis-common/src/test/java/org/elasticsearch/analysis/common/MassiveWordListTests.java
new file mode 100644
index 000000000000..081580a6ae93
--- /dev/null
+++ b/modules/analysis-common/src/test/java/org/elasticsearch/analysis/common/MassiveWordListTests.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.analysis.common;
+
+import org.elasticsearch.common.settings.Settings;
+import org.elasticsearch.plugins.Plugin;
+import org.elasticsearch.test.ESSingleNodeTestCase;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class MassiveWordListTests extends ESSingleNodeTestCase {
+
+    @Override
+    protected Collection<Class<? extends Plugin>> getPlugins() {
+        return Collections.singleton(CommonAnalysisPlugin.class);
+    }
+
+    public void testCreateIndexWithMassiveWordList() {
+        String[] wordList = new String[100000];
+        for (int i = 0; i < wordList.length; i++) {
+            wordList[i] = "hello world";
+        }
+        client().admin().indices().prepareCreate("test").setSettings(Settings.builder()
+            .put("index.number_of_shards", 1)
+            .put("analysis.analyzer.test_analyzer.type", "custom")
+            .put("analysis.analyzer.test_analyzer.tokenizer", "standard")
+            .putArray("analysis.analyzer.test_analyzer.filter", "dictionary_decompounder", "lowercase")
+            .put("analysis.filter.dictionary_decompounder.type", "dictionary_decompounder")
+            .putArray("analysis.filter.dictionary_decompounder.word_list", wordList)
+        ).get();
+    }
+}
diff --git a/plugins/discovery-ec2/src/main/java/org/elasticsearch/discovery/ec2/AwsEc2Service.java b/plugins/discovery-ec2/src/main/java/org/elasticsearch/discovery/ec2/AwsEc2Service.java
index 8733fb7ac9c5..a17150f37be6 100644
--- a/plugins/discovery-ec2/src/main/java/org/elasticsearch/discovery/ec2/AwsEc2Service.java
+++ b/plugins/discovery-ec2/src/main/java/org/elasticsearch/discovery/ec2/AwsEc2Service.java
@@ -115,7 +115,9 @@
      * instances with a tag key set to stage, and a value of dev. Several tags set will require all of those tags to be set for the
      * instance to be included.
      */
-    Setting<Settings> TAG_SETTING = Setting.groupSetting("discovery.ec2.tag.", Property.NodeScope);
+    Setting.AffixSetting<List<String>> TAG_SETTING =
+        Setting.prefixKeySetting("discovery.ec2.tag.",
+            key -> Setting.listSetting(key, Collections.emptyList(), Function.identity(), Property.NodeScope));
 
     AmazonEC2 client();
 }
diff --git a/plugins/discovery-ec2/src/main/java/org/elasticsearch/discovery/ec2/AwsEc2UnicastHostsProvider.java b/plugins/discovery-ec2/src/main/java/org/elasticsearch/discovery/ec2/AwsEc2UnicastHostsProvider.java
index 91713ce2177f..a70fb2fd2686 100644
--- a/plugins/discovery-ec2/src/main/java/org/elasticsearch/discovery/ec2/AwsEc2UnicastHostsProvider.java
+++ b/plugins/discovery-ec2/src/main/java/org/elasticsearch/discovery/ec2/AwsEc2UnicastHostsProvider.java
@@ -33,6 +33,7 @@
 import org.elasticsearch.Version;
 import org.elasticsearch.cluster.node.DiscoveryNode;
 import org.elasticsearch.common.component.AbstractComponent;
+import org.elasticsearch.common.settings.Setting;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.transport.TransportAddress;
 import org.elasticsearch.common.unit.TimeValue;
@@ -41,10 +42,13 @@
 import org.elasticsearch.transport.TransportService;
 
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.stream.Stream;
 
 import static java.util.Collections.disjoint;
 import static java.util.Collections.emptyMap;
@@ -65,7 +69,7 @@
 
     private final Set<String> groups;
 
-    private final Map<String, String> tags;
+    private final Map<String, String[]> tags;
 
     private final Set<String> availabilityZones;
 
@@ -84,12 +88,14 @@
         this.bindAnyGroup = AwsEc2Service.ANY_GROUP_SETTING.get(settings);
         this.groups = new HashSet<>();
         this.groups.addAll(AwsEc2Service.GROUPS_SETTING.get(settings));
-
-        this.tags = AwsEc2Service.TAG_SETTING.get(settings).getAsMap();
-
         this.availabilityZones = new HashSet<>();
         availabilityZones.addAll(AwsEc2Service.AVAILABILITY_ZONES_SETTING.get(settings));
-
+        HashMap<String, String[]> tags = new HashMap<>();
+        Stream<Setting<List<String>>> allConcreteSettings = AwsEc2Service.TAG_SETTING.getAllConcreteSettings(settings);
+        allConcreteSettings.forEach(setting -> {
+            tags.put(AwsEc2Service.TAG_SETTING.getNamespace(setting), setting.get(settings).toArray(new String[0]));
+        });
+        this.tags = Collections.unmodifiableMap(tags);
         if (logger.isDebugEnabled()) {
             logger.debug("using host_type [{}], tags [{}], groups [{}] with any_group [{}], availability_zones [{}]", hostType, tags,
                     groups, bindAnyGroup, availabilityZones);
@@ -205,11 +211,10 @@ private DescribeInstancesRequest buildDescribeInstancesRequest() {
             .withFilters(
                 new Filter("instance-state-name").withValues("running", "pending")
             );
-
-        for (Map.Entry<String, String> tagFilter : tags.entrySet()) {
+        for (Map.Entry<String, String[]> tag : tags.entrySet()) {
             // for a given tag key, OR relationship for multiple different values
             describeInstancesRequest.withFilters(
-                new Filter("tag:" + tagFilter.getKey()).withValues(tagFilter.getValue())
+                new Filter("tag:" + tag.getKey()).withValues(tag.getValue())
             );
         }
 
