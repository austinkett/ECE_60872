diff --git a/docs/reference/docs/get.asciidoc b/docs/reference/docs/get.asciidoc
index 59d91112ea67..53e335910766 100644
--- a/docs/reference/docs/get.asciidoc
+++ b/docs/reference/docs/get.asciidoc
@@ -124,6 +124,15 @@ Field values fetched from the document it self are always returned as an array.
 Also only leaf fields can be returned via the `field` option. So object fields can't be returned and such requests
 will fail.
 
+[float]
+[[generated-fields]]
+=== Generated fields
+added[1.4.0]
+
+If no refresh occurred between indexing and refresh, GET will access the transaction log to fetch the document. However, some fields are generated only when indexing. 
+If you try to access a field that is only generated when indexing, you will get an exception (default). You can choose to ignore field that are generated if the transaction log is accessed by setting `ignore_errors_on_generated_fields=true`.
+
+
 [float]
 [[_source]]
 === Getting the _source directly
@@ -223,4 +232,5 @@ it's current version is equal to the specified one. This behavior is the same
 for all version types with the exception of version type `FORCE` which always
 retrieves the document.
 
-Note that Elasticsearch do not store older versions of documents. Only the current version can be retrieved.
\ No newline at end of file
+Note that Elasticsearch do not store older versions of documents. Only the current version can be retrieved.
+
diff --git a/docs/reference/docs/multi-get.asciidoc b/docs/reference/docs/multi-get.asciidoc
index 74be948cbc99..1feb4410ab0b 100644
--- a/docs/reference/docs/multi-get.asciidoc
+++ b/docs/reference/docs/multi-get.asciidoc
@@ -180,6 +180,14 @@ curl 'localhost:9200/_mget' -d '{
 }'
 --------------------------------------------------
 
+[float]
+[[generated-fields]]
+=== Generated fields
+
+added[1.4.0]
+
+See <<generated-fields>> for fields are generated only when indexing. 
+
 [float]
 [[mget-routing]]
 === Routing
diff --git a/src/main/java/org/elasticsearch/action/explain/TransportExplainAction.java b/src/main/java/org/elasticsearch/action/explain/TransportExplainAction.java
index 81ff09d893f7..7ea7925f68cb 100644
--- a/src/main/java/org/elasticsearch/action/explain/TransportExplainAction.java
+++ b/src/main/java/org/elasticsearch/action/explain/TransportExplainAction.java
@@ -138,7 +138,7 @@ protected ExplainResponse shardOperation(ExplainRequest request, int shardId) th
                 // Advantage is that we're not opening a second searcher to retrieve the _source. Also
                 // because we are working in the same searcher in engineGetResult we can be sure that a
                 // doc isn't deleted between the initial get and this call.
-                GetResult getResult = indexShard.getService().get(result, request.id(), request.type(), request.fields(), request.fetchSourceContext());
+                GetResult getResult = indexShard.getService().get(result, request.id(), request.type(), request.fields(), request.fetchSourceContext(), false);
                 return new ExplainResponse(true, explanation, getResult);
             } else {
                 return new ExplainResponse(true, explanation);
diff --git a/src/main/java/org/elasticsearch/action/get/GetRequest.java b/src/main/java/org/elasticsearch/action/get/GetRequest.java
index baa846a846cb..8ed7ae5ca8b7 100644
--- a/src/main/java/org/elasticsearch/action/get/GetRequest.java
+++ b/src/main/java/org/elasticsearch/action/get/GetRequest.java
@@ -19,6 +19,7 @@
 
 package org.elasticsearch.action.get;
 
+import org.elasticsearch.Version;
 import org.elasticsearch.action.ActionRequestValidationException;
 import org.elasticsearch.action.ValidateActions;
 import org.elasticsearch.action.support.single.shard.SingleShardOperationRequest;
@@ -59,6 +60,7 @@
 
     private VersionType versionType = VersionType.INTERNAL;
     private long version = Versions.MATCH_ANY;
+    private boolean ignoreErrorsOnGeneratedFields;
 
     GetRequest() {
         type = "_all";
@@ -240,10 +242,19 @@ public GetRequest versionType(VersionType versionType) {
         return this;
     }
 
+    public GetRequest ignoreErrorsOnGeneratedFields(boolean ignoreErrorsOnGeneratedFields) {
+        this.ignoreErrorsOnGeneratedFields = ignoreErrorsOnGeneratedFields;
+        return this;
+    }
+
     public VersionType versionType() {
         return this.versionType;
     }
 
+    public boolean ignoreErrorsOnGeneratedFields() {
+        return ignoreErrorsOnGeneratedFields;
+    }
+
     @Override
     public void readFrom(StreamInput in) throws IOException {
         super.readFrom(in);
@@ -265,6 +276,9 @@ public void readFrom(StreamInput in) throws IOException {
         } else if (realtime == 1) {
             this.realtime = true;
         }
+        if(in.getVersion().onOrAfter(Version.V_1_4_0)) {
+            this.ignoreErrorsOnGeneratedFields = in.readBoolean();
+        }
 
         this.versionType = VersionType.fromValue(in.readByte());
         this.version = Versions.readVersionWithVLongForBW(in);
@@ -296,7 +310,9 @@ public void writeTo(StreamOutput out) throws IOException {
         } else {
             out.writeByte((byte) 1);
         }
-
+        if(out.getVersion().onOrAfter(Version.V_1_4_0)) {
+            out.writeBoolean(ignoreErrorsOnGeneratedFields);
+        }
         out.writeByte(versionType.getValue());
         Versions.writeVersionWithVLongForBW(version, out);
 
@@ -307,4 +323,5 @@ public void writeTo(StreamOutput out) throws IOException {
     public String toString() {
         return "get [" + index + "][" + type + "][" + id + "]: routing [" + routing + "]";
     }
+
 }
diff --git a/src/main/java/org/elasticsearch/action/get/GetRequestBuilder.java b/src/main/java/org/elasticsearch/action/get/GetRequestBuilder.java
index 47687b59f9e3..f305630608c9 100644
--- a/src/main/java/org/elasticsearch/action/get/GetRequestBuilder.java
+++ b/src/main/java/org/elasticsearch/action/get/GetRequestBuilder.java
@@ -174,6 +174,11 @@ public GetRequestBuilder setRealtime(Boolean realtime) {
         return this;
     }
 
+    public GetRequestBuilder setIgnoreErrorsOnGeneratedFields(Boolean ignoreErrorsOnGeneratedFields) {
+        request.ignoreErrorsOnGeneratedFields(ignoreErrorsOnGeneratedFields);
+        return this;
+    }
+
     /**
      * Sets the version, which will cause the get operation to only be performed if a matching
      * version exists and no changes happened on the doc since then.
diff --git a/src/main/java/org/elasticsearch/action/get/MultiGetRequest.java b/src/main/java/org/elasticsearch/action/get/MultiGetRequest.java
index ad0418082778..c9279a79b39b 100644
--- a/src/main/java/org/elasticsearch/action/get/MultiGetRequest.java
+++ b/src/main/java/org/elasticsearch/action/get/MultiGetRequest.java
@@ -22,6 +22,7 @@
 import com.google.common.collect.Iterators;
 import org.elasticsearch.ElasticsearchIllegalArgumentException;
 import org.elasticsearch.ElasticsearchParseException;
+import org.elasticsearch.Version;
 import org.elasticsearch.action.ActionRequest;
 import org.elasticsearch.action.ActionRequestValidationException;
 import org.elasticsearch.action.ValidateActions;
@@ -241,6 +242,7 @@ public int hashCode() {
     String preference;
     Boolean realtime;
     boolean refresh;
+    public boolean ignoreErrorsOnGeneratedFields = false;
 
     List<Item> items = new ArrayList<>();
 
@@ -309,6 +311,12 @@ public MultiGetRequest refresh(boolean refresh) {
         return this;
     }
 
+
+    public MultiGetRequest ignoreErrorsOnGeneratedFields(boolean ignoreErrorsOnGeneratedFields) {
+        this.ignoreErrorsOnGeneratedFields = ignoreErrorsOnGeneratedFields;
+        return this;
+    }
+
     public MultiGetRequest add(@Nullable String defaultIndex, @Nullable String defaultType, @Nullable String[] defaultFields, @Nullable FetchSourceContext defaultFetchSource, byte[] data, int from, int length) throws Exception {
         return add(defaultIndex, defaultType, defaultFields, defaultFetchSource, new BytesArray(data, from, length), true);
     }
@@ -481,6 +489,9 @@ public void readFrom(StreamInput in) throws IOException {
         } else if (realtime == 1) {
             this.realtime = true;
         }
+        if(in.getVersion().onOrAfter(Version.V_1_4_0)) {
+            ignoreErrorsOnGeneratedFields = in.readBoolean();
+        }
 
         int size = in.readVInt();
         items = new ArrayList<>(size);
@@ -501,6 +512,9 @@ public void writeTo(StreamOutput out) throws IOException {
         } else {
             out.writeByte((byte) 1);
         }
+        if(out.getVersion().onOrAfter(Version.V_1_4_0)) {
+            out.writeBoolean(ignoreErrorsOnGeneratedFields);
+        }
 
         out.writeVInt(items.size());
         for (Item item : items) {
diff --git a/src/main/java/org/elasticsearch/action/get/MultiGetRequestBuilder.java b/src/main/java/org/elasticsearch/action/get/MultiGetRequestBuilder.java
index 9aac19162f17..cc8389d8d0da 100644
--- a/src/main/java/org/elasticsearch/action/get/MultiGetRequestBuilder.java
+++ b/src/main/java/org/elasticsearch/action/get/MultiGetRequestBuilder.java
@@ -82,6 +82,11 @@ public MultiGetRequestBuilder setRealtime(Boolean realtime) {
         return this;
     }
 
+    public MultiGetRequestBuilder setIgnoreErrorsOnGeneratedFields(boolean ignoreErrorsOnGeneratedFields) {
+        request.ignoreErrorsOnGeneratedFields(ignoreErrorsOnGeneratedFields);
+        return this;
+    }
+
     @Override
     protected void doExecute(ActionListener<MultiGetResponse> listener) {
         client.multiGet(request, listener);
diff --git a/src/main/java/org/elasticsearch/action/get/MultiGetShardRequest.java b/src/main/java/org/elasticsearch/action/get/MultiGetShardRequest.java
index 454dd0517297..cb1853600b8b 100644
--- a/src/main/java/org/elasticsearch/action/get/MultiGetShardRequest.java
+++ b/src/main/java/org/elasticsearch/action/get/MultiGetShardRequest.java
@@ -21,6 +21,7 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.LongArrayList;
+import org.elasticsearch.Version;
 import org.elasticsearch.action.support.single.shard.SingleShardOperationRequest;
 import org.elasticsearch.common.Nullable;
 import org.elasticsearch.common.io.stream.StreamInput;
@@ -39,6 +40,7 @@
     private String preference;
     Boolean realtime;
     boolean refresh;
+    boolean ignoreErrorsOnGeneratedFields = false;
 
     IntArrayList locations;
     List<String> types;
@@ -91,6 +93,11 @@ public MultiGetShardRequest realtime(Boolean realtime) {
         return this;
     }
 
+    public MultiGetShardRequest ignoreErrorsOnGeneratedFields(Boolean ignoreErrorsOnGeneratedFields) {
+        this.ignoreErrorsOnGeneratedFields = ignoreErrorsOnGeneratedFields;
+        return this;
+    }
+
     public boolean refresh() {
         return this.refresh;
     }
@@ -153,6 +160,9 @@ public void readFrom(StreamInput in) throws IOException {
         } else if (realtime == 1) {
             this.realtime = true;
         }
+        if(in.getVersion().onOrAfter(Version.V_1_4_0)) {
+            ignoreErrorsOnGeneratedFields = in.readBoolean();
+        }
     }
 
     @Override
@@ -191,7 +201,13 @@ public void writeTo(StreamOutput out) throws IOException {
         } else {
             out.writeByte((byte) 1);
         }
+        if(out.getVersion().onOrAfter(Version.V_1_4_0)) {
+            out.writeBoolean(ignoreErrorsOnGeneratedFields);
+        }
 
+    }
 
+    public boolean ignoreErrorsOnGeneratedFields() {
+        return ignoreErrorsOnGeneratedFields;
     }
 }
diff --git a/src/main/java/org/elasticsearch/action/get/TransportGetAction.java b/src/main/java/org/elasticsearch/action/get/TransportGetAction.java
index fdd5df91411c..2f84dec87ad3 100644
--- a/src/main/java/org/elasticsearch/action/get/TransportGetAction.java
+++ b/src/main/java/org/elasticsearch/action/get/TransportGetAction.java
@@ -103,7 +103,7 @@ protected GetResponse shardOperation(GetRequest request, int shardId) throws Ela
         }
 
         GetResult result = indexShard.getService().get(request.type(), request.id(), request.fields(),
-                request.realtime(), request.version(), request.versionType(), request.fetchSourceContext());
+                request.realtime(), request.version(), request.versionType(), request.fetchSourceContext(), request.ignoreErrorsOnGeneratedFields());
         return new GetResponse(result);
     }
 
diff --git a/src/main/java/org/elasticsearch/action/get/TransportMultiGetAction.java b/src/main/java/org/elasticsearch/action/get/TransportMultiGetAction.java
index 72a71e131bc0..00567483ba1f 100644
--- a/src/main/java/org/elasticsearch/action/get/TransportMultiGetAction.java
+++ b/src/main/java/org/elasticsearch/action/get/TransportMultiGetAction.java
@@ -84,6 +84,7 @@ protected void doExecute(final MultiGetRequest request, final ActionListener<Mul
                 shardRequest.preference(request.preference);
                 shardRequest.realtime(request.realtime);
                 shardRequest.refresh(request.refresh);
+                shardRequest.ignoreErrorsOnGeneratedFields(request.ignoreErrorsOnGeneratedFields);
 
                 shardRequests.put(shardId, shardRequest);
             }
diff --git a/src/main/java/org/elasticsearch/action/get/TransportShardMultiGetAction.java b/src/main/java/org/elasticsearch/action/get/TransportShardMultiGetAction.java
index 787235f66012..148ad018a00f 100644
--- a/src/main/java/org/elasticsearch/action/get/TransportShardMultiGetAction.java
+++ b/src/main/java/org/elasticsearch/action/get/TransportShardMultiGetAction.java
@@ -121,7 +121,7 @@ protected MultiGetShardResponse shardOperation(MultiGetShardRequest request, int
 
             FetchSourceContext fetchSourceContext = request.fetchSourceContexts.get(i);
             try {
-                GetResult getResult = indexShard.getService().get(type, id, fields, request.realtime(), version, versionType, fetchSourceContext);
+                GetResult getResult = indexShard.getService().get(type, id, fields, request.realtime(), version, versionType, fetchSourceContext, request.ignoreErrorsOnGeneratedFields());
                 response.add(request.locations.get(i), new GetResponse(getResult));
             } catch (Throwable t) {
                 if (TransportActions.isShardNotAvailableException(t)) {
diff --git a/src/main/java/org/elasticsearch/action/update/UpdateHelper.java b/src/main/java/org/elasticsearch/action/update/UpdateHelper.java
index d15a1b5bd451..0b177e2d7ff5 100644
--- a/src/main/java/org/elasticsearch/action/update/UpdateHelper.java
+++ b/src/main/java/org/elasticsearch/action/update/UpdateHelper.java
@@ -84,7 +84,7 @@ public Result prepare(UpdateRequest request, IndexShard indexShard) {
         long getDate = System.currentTimeMillis();
         final GetResult getResult = indexShard.getService().get(request.type(), request.id(),
                 new String[]{RoutingFieldMapper.NAME, ParentFieldMapper.NAME, TTLFieldMapper.NAME},
-                true, request.version(), request.versionType(), FetchSourceContext.FETCH_SOURCE);
+                true, request.version(), request.versionType(), FetchSourceContext.FETCH_SOURCE, false);
 
         if (!getResult.isExists()) {
             if (request.upsertRequest() == null && !request.docAsUpsert()) {
diff --git a/src/main/java/org/elasticsearch/index/get/ShardGetService.java b/src/main/java/org/elasticsearch/index/get/ShardGetService.java
index 080afa27c28e..1f7568a0d83b 100644
--- a/src/main/java/org/elasticsearch/index/get/ShardGetService.java
+++ b/src/main/java/org/elasticsearch/index/get/ShardGetService.java
@@ -96,12 +96,12 @@ public ShardGetService setIndexShard(IndexShard indexShard) {
         return this;
     }
 
-    public GetResult get(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext)
+    public GetResult get(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields)
             throws ElasticsearchException {
         currentMetric.inc();
         try {
             long now = System.nanoTime();
-            GetResult getResult = innerGet(type, id, gFields, realtime, version, versionType, fetchSourceContext);
+            GetResult getResult = innerGet(type, id, gFields, realtime, version, versionType, fetchSourceContext, ignoreErrorsOnGeneratedFields);
 
             if (getResult.isExists()) {
                 existsMetric.inc(System.nanoTime() - now);
@@ -121,7 +121,7 @@ public GetResult get(String type, String id, String[] gFields, boolean realtime,
      * <p/>
      * Note: Call <b>must</b> release engine searcher associated with engineGetResult!
      */
-    public GetResult get(Engine.GetResult engineGetResult, String id, String type, String[] fields, FetchSourceContext fetchSourceContext) {
+    public GetResult get(Engine.GetResult engineGetResult, String id, String type, String[] fields, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) {
         if (!engineGetResult.exists()) {
             return new GetResult(shardId.index().name(), type, id, -1, false, null, null);
         }
@@ -135,7 +135,7 @@ public GetResult get(Engine.GetResult engineGetResult, String id, String type, S
                 return new GetResult(shardId.index().name(), type, id, -1, false, null, null);
             }
             fetchSourceContext = normalizeFetchSourceContent(fetchSourceContext, fields);
-            GetResult getResult = innerGetLoadFromStoredFields(type, id, fields, fetchSourceContext, engineGetResult, docMapper);
+            GetResult getResult = innerGetLoadFromStoredFields(type, id, fields, fetchSourceContext, engineGetResult, docMapper, ignoreErrorsOnGeneratedFields);
             if (getResult.isExists()) {
                 existsMetric.inc(System.nanoTime() - now);
             } else {
@@ -165,7 +165,7 @@ protected FetchSourceContext normalizeFetchSourceContent(@Nullable FetchSourceCo
         return FetchSourceContext.DO_NOT_FETCH_SOURCE;
     }
 
-    public GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext) throws ElasticsearchException {
+    public GetResult innerGet(String type, String id, String[] gFields, boolean realtime, long version, VersionType versionType, FetchSourceContext fetchSourceContext, boolean ignoreErrorsOnGeneratedFields) throws ElasticsearchException {
         fetchSourceContext = normalizeFetchSourceContent(fetchSourceContext, gFields);
 
         boolean loadSource = (gFields != null && gFields.length > 0) || fetchSourceContext.fetchSource();
@@ -207,7 +207,7 @@ public GetResult innerGet(String type, String id, String[] gFields, boolean real
         try {
             // break between having loaded it from translog (so we only have _source), and having a document to load
             if (get.docIdAndVersion() != null) {
-                return innerGetLoadFromStoredFields(type, id, gFields, fetchSourceContext, get, docMapper);
+                return innerGetLoadFromStoredFields(type, id, gFields, fetchSourceContext, get, docMapper, ignoreErrorsOnGeneratedFields);
             } else {
                 Translog.Source source = get.source();
 
@@ -241,20 +241,21 @@ public GetResult innerGet(String type, String id, String[] gFields, boolean real
                                 searchLookup.source().setNextSource(source.source);
                             }
 
-                            FieldMapper<?> x = docMapper.mappers().smartNameFieldMapper(field);
-                            if (x == null) {
+                            FieldMapper<?> fieldMapper = docMapper.mappers().smartNameFieldMapper(field);
+                            if (fieldMapper == null) {
                                 if (docMapper.objectMappers().get(field) != null) {
                                     // Only fail if we know it is a object field, missing paths / fields shouldn't fail.
                                     throw new ElasticsearchIllegalArgumentException("field [" + field + "] isn't a leaf field");
                                 }
-                            } else if (docMapper.sourceMapper().enabled() || x.fieldType().stored()) {
+                            } else if (shouldGetFromSource(ignoreErrorsOnGeneratedFields, docMapper, fieldMapper)) {
                                 List<Object> values = searchLookup.source().extractRawValues(field);
                                 if (!values.isEmpty()) {
                                     for (int i = 0; i < values.size(); i++) {
-                                        values.set(i, x.valueForSearch(values.get(i)));
+                                        values.set(i, fieldMapper.valueForSearch(values.get(i)));
                                     }
                                     value = values;
                                 }
+
                             }
                         }
                         if (value != null) {
@@ -312,7 +313,27 @@ public GetResult innerGet(String type, String id, String[] gFields, boolean real
         }
     }
 
-    private GetResult innerGetLoadFromStoredFields(String type, String id, String[] gFields, FetchSourceContext fetchSourceContext, Engine.GetResult get, DocumentMapper docMapper) {
+    protected boolean shouldGetFromSource(boolean ignoreErrorsOnGeneratedFields, DocumentMapper docMapper, FieldMapper<?> fieldMapper) {
+        if (!fieldMapper.isGenerated()) {
+            //if the field is always there we check if either source mapper is enabled, in which case we get the field
+            // from source, or, if the field is stored, in which case we have to get if from source here also (we are in the translog phase, doc not indexed yet, we annot access the stored fields)
+            return docMapper.sourceMapper().enabled() || fieldMapper.fieldType().stored();
+        } else {
+            if (!fieldMapper.fieldType().stored()) {
+                //if it is not stored, user will not get the generated field back
+                return false;
+            } else {
+                if (ignoreErrorsOnGeneratedFields) {
+                    return false;
+                } else {
+                    throw new ElasticsearchException("Cannot access field " + fieldMapper.name() + " from transaction log. You can only get this field after refresh() has been called.");
+                }
+            }
+
+        }
+    }
+
+    private GetResult innerGetLoadFromStoredFields(String type, String id, String[] gFields, FetchSourceContext fetchSourceContext, Engine.GetResult get, DocumentMapper docMapper, boolean ignoreErrorsOnGeneratedFields) {
         Map<String, GetField> fields = null;
         BytesReference source = null;
         Versions.DocIdAndVersion docIdAndVersion = get.docIdAndVersion();
@@ -335,17 +356,18 @@ private GetResult innerGetLoadFromStoredFields(String type, String id, String[]
         }
 
         // now, go and do the script thingy if needed
+
         if (gFields != null && gFields.length > 0) {
             SearchLookup searchLookup = null;
             for (String field : gFields) {
                 Object value = null;
-                FieldMappers x = docMapper.mappers().smartName(field);
-                if (x == null) {
+                FieldMappers fieldMapper = docMapper.mappers().smartName(field);
+                if (fieldMapper == null) {
                     if (docMapper.objectMappers().get(field) != null) {
                         // Only fail if we know it is a object field, missing paths / fields shouldn't fail.
                         throw new ElasticsearchIllegalArgumentException("field [" + field + "] isn't a leaf field");
                     }
-                } else if (!x.mapper().fieldType().stored()) {
+                } else if (!fieldMapper.mapper().fieldType().stored() && !fieldMapper.mapper().isGenerated()) {
                     if (searchLookup == null) {
                         searchLookup = new SearchLookup(mapperService, fieldDataService, new String[]{type});
                         searchLookup.setNextReader(docIdAndVersion.context);
@@ -356,7 +378,7 @@ private GetResult innerGetLoadFromStoredFields(String type, String id, String[]
                     List<Object> values = searchLookup.source().extractRawValues(field);
                     if (!values.isEmpty()) {
                         for (int i = 0; i < values.size(); i++) {
-                            values.set(i, x.mapper().valueForSearch(values.get(i)));
+                            values.set(i, fieldMapper.mapper().valueForSearch(values.get(i)));
                         }
                         value = values;
                     }
diff --git a/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java
index d72eca7e7ecf..aec138674692 100644
--- a/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java
+++ b/src/main/java/org/elasticsearch/index/mapper/FieldMapper.java
@@ -290,4 +290,12 @@ public static Loading parse(String loading, Loading defaultValue) {
 
     Loading normsLoading(Loading defaultLoading);
 
+    /**
+     * Fields might not be available before indexing, for example _all, token_count,...
+     * When get is called and these fields are requested, this case needs special treatment.
+     *
+     * @return If the field is available before indexing or not.
+     * */
+    public boolean isGenerated();
+
 }
diff --git a/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java
index 00f94fa9bf9e..a7820d7e9832 100644
--- a/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java
+++ b/src/main/java/org/elasticsearch/index/mapper/core/AbstractFieldMapper.java
@@ -1115,4 +1115,11 @@ public void parse(String field, ParseContext context) throws IOException {
 
     }
 
+    /**
+     * Returns if this field is only generated when indexing. For example, the field of type token_count
+     */
+    public boolean isGenerated() {
+        return false;
+    }
+
 }
diff --git a/src/main/java/org/elasticsearch/index/mapper/core/Murmur3FieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/core/Murmur3FieldMapper.java
index acaca4505ca8..53c24095634e 100644
--- a/src/main/java/org/elasticsearch/index/mapper/core/Murmur3FieldMapper.java
+++ b/src/main/java/org/elasticsearch/index/mapper/core/Murmur3FieldMapper.java
@@ -108,4 +108,9 @@ protected void innerParseCreateField(ParseContext context, List<Field> fields) t
 
     }
 
+    @Override
+    public boolean isGenerated() {
+        return true;
+    }
+
 }
diff --git a/src/main/java/org/elasticsearch/index/mapper/core/TokenCountFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/core/TokenCountFieldMapper.java
index 9d57c7bf92ed..7beff6ffee93 100644
--- a/src/main/java/org/elasticsearch/index/mapper/core/TokenCountFieldMapper.java
+++ b/src/main/java/org/elasticsearch/index/mapper/core/TokenCountFieldMapper.java
@@ -197,4 +197,10 @@ protected void doXContentBody(XContentBuilder builder, boolean includeDefaults,
 
         builder.field("analyzer", analyzer());
     }
+
+    @Override
+    public boolean isGenerated() {
+        return true;
+    }
+
 }
diff --git a/src/main/java/org/elasticsearch/index/mapper/internal/AllFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/internal/AllFieldMapper.java
index ca62dce9e998..9e3f824c577f 100644
--- a/src/main/java/org/elasticsearch/index/mapper/internal/AllFieldMapper.java
+++ b/src/main/java/org/elasticsearch/index/mapper/internal/AllFieldMapper.java
@@ -351,4 +351,9 @@ public void merge(Mapper mergeWith, MergeContext mergeContext) throws MergeMappi
     public boolean hasDocValues() {
         return false;
     }
+
+    @Override
+    public boolean isGenerated() {
+        return true;
+    }
 }
diff --git a/src/main/java/org/elasticsearch/index/mapper/internal/FieldNamesFieldMapper.java b/src/main/java/org/elasticsearch/index/mapper/internal/FieldNamesFieldMapper.java
index 804105201a77..c795e0c7dcc3 100644
--- a/src/main/java/org/elasticsearch/index/mapper/internal/FieldNamesFieldMapper.java
+++ b/src/main/java/org/elasticsearch/index/mapper/internal/FieldNamesFieldMapper.java
@@ -249,4 +249,9 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws
         }
         return super.toXContent(builder, params);
     }
+
+    @Override
+    public boolean isGenerated() {
+        return true;
+    }
 }
diff --git a/src/main/java/org/elasticsearch/index/termvectors/ShardTermVectorService.java b/src/main/java/org/elasticsearch/index/termvectors/ShardTermVectorService.java
index 2ed0c88e72b1..ade47ca9846e 100644
--- a/src/main/java/org/elasticsearch/index/termvectors/ShardTermVectorService.java
+++ b/src/main/java/org/elasticsearch/index/termvectors/ShardTermVectorService.java
@@ -118,7 +118,7 @@ private Fields generateTermVectorsIfNeeded(Fields termVectorsByField, TermVector
             }
             // TODO: support for fetchSourceContext?
             GetResult getResult = indexShard.getService().get(
-                    get, request.id(), request.type(), validFields.toArray(Strings.EMPTY_ARRAY), null);
+                    get, request.id(), request.type(), validFields.toArray(Strings.EMPTY_ARRAY), null, false);
             generatedTermVectors = generateTermVectors(getResult.getFields().values(), request.offsets());
         } finally {
             get.release();
diff --git a/src/main/java/org/elasticsearch/rest/action/get/RestGetAction.java b/src/main/java/org/elasticsearch/rest/action/get/RestGetAction.java
index 8a4808b98230..88b72b6e270e 100644
--- a/src/main/java/org/elasticsearch/rest/action/get/RestGetAction.java
+++ b/src/main/java/org/elasticsearch/rest/action/get/RestGetAction.java
@@ -57,6 +57,7 @@ public void handleRequest(final RestRequest request, final RestChannel channel,
         getRequest.parent(request.param("parent"));
         getRequest.preference(request.param("preference"));
         getRequest.realtime(request.paramAsBoolean("realtime", null));
+        getRequest.ignoreErrorsOnGeneratedFields(request.paramAsBoolean("ignore_errors_on_generated_fields", false));
 
         String sField = request.param("fields");
         if (sField != null) {
diff --git a/src/main/java/org/elasticsearch/rest/action/get/RestMultiGetAction.java b/src/main/java/org/elasticsearch/rest/action/get/RestMultiGetAction.java
index 81128e5692ec..a8cb7f667fbc 100644
--- a/src/main/java/org/elasticsearch/rest/action/get/RestMultiGetAction.java
+++ b/src/main/java/org/elasticsearch/rest/action/get/RestMultiGetAction.java
@@ -57,6 +57,7 @@ public void handleRequest(final RestRequest request, final RestChannel channel,
         multiGetRequest.refresh(request.paramAsBoolean("refresh", multiGetRequest.refresh()));
         multiGetRequest.preference(request.param("preference"));
         multiGetRequest.realtime(request.paramAsBoolean("realtime", null));
+        multiGetRequest.ignoreErrorsOnGeneratedFields(request.paramAsBoolean("ignore_errors_on_generated_fields", false));
 
         String[] sFields = null;
         String sField = request.param("fields");
diff --git a/src/test/java/org/elasticsearch/get/GetActionTests.java b/src/test/java/org/elasticsearch/get/GetActionTests.java
index a2780a9decdb..b28c07fc255c 100644
--- a/src/test/java/org/elasticsearch/get/GetActionTests.java
+++ b/src/test/java/org/elasticsearch/get/GetActionTests.java
@@ -19,16 +19,16 @@
 
 package org.elasticsearch.get;
 
+import org.elasticsearch.ElasticsearchException;
 import org.elasticsearch.ElasticsearchIllegalArgumentException;
 import org.elasticsearch.action.ShardOperationFailedException;
 import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;
 import org.elasticsearch.action.admin.cluster.health.ClusterHealthStatus;
 import org.elasticsearch.action.admin.indices.flush.FlushResponse;
 import org.elasticsearch.action.delete.DeleteResponse;
-import org.elasticsearch.action.get.GetResponse;
-import org.elasticsearch.action.get.MultiGetRequest;
-import org.elasticsearch.action.get.MultiGetResponse;
+import org.elasticsearch.action.get.*;
 import org.elasticsearch.common.Base64;
+import org.elasticsearch.common.Nullable;
 import org.elasticsearch.common.Strings;
 import org.elasticsearch.common.bytes.BytesArray;
 import org.elasticsearch.common.bytes.BytesReference;
@@ -39,10 +39,12 @@
 import org.elasticsearch.test.junit.annotations.TestLogging;
 import org.junit.Test;
 
+import java.io.IOException;
 import java.util.Map;
 
 import static org.elasticsearch.client.Requests.clusterHealthRequest;
 import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;
+import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;
 import static org.hamcrest.Matchers.*;
 
 public class GetActionTests extends ElasticsearchIntegrationTest {
@@ -909,4 +911,445 @@ public void testGet_allField() throws Exception {
         assertNotNull(getResponse.getField("_all").getValue());
         assertThat(getResponse.getField("_all").getValue().toString(), equalTo("some text" + " "));
     }
+
+    @Test
+    public void testUngeneratedFieldsThatAreNeverStored() throws IOException {
+        String createIndexSource = "{\n" +
+                "  \"settings\": {\n" +
+                "    \"index.translog.disable_flush\": true,\n" +
+                "    \"refresh_interval\": \"-1\"\n" +
+                "  },\n" +
+                "  \"mappings\": {\n" +
+                "    \"doc\": {\n" +
+                "      \"_source\": {\n" +
+                "        \"enabled\": \"" + randomBoolean() + "\"\n" +
+                "      },\n" +
+                "      \"properties\": {\n" +
+                "        \"suggest\": {\n" +
+                "          \"type\": \"completion\"\n" +
+                "        }\n" +
+                "      }\n" +
+                "    }\n" +
+                "  }\n" +
+                "}";
+        assertAcked(prepareCreate("testidx").setSource(createIndexSource));
+        ensureGreen();
+        String doc = "{\n" +
+                "  \"suggest\": {\n" +
+                "    \"input\": [\n" +
+                "      \"Nevermind\",\n" +
+                "      \"Nirvana\"\n" +
+                "    ],\n" +
+                "    \"output\": \"Nirvana - Nevermind\"\n" +
+                "  }\n" +
+                "}";
+
+        index("testidx", "doc", "1", doc);
+        String[] fieldsList = {"suggest"};
+        // before refresh - document is only in translog
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+        refresh();
+        //after refresh - document is in translog and also indexed
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+        flush();
+        //after flush - document is in not anymore translog - only indexed
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+    }
+
+    @Test
+    public void testUngeneratedFieldsThatAreAlwaysStored() throws IOException {
+        String storedString = randomBoolean() ? "yes" : "no";
+        String createIndexSource = "{\n" +
+                "  \"settings\": {\n" +
+                "    \"index.translog.disable_flush\": true,\n" +
+                "    \"refresh_interval\": \"-1\"\n" +
+                "  },\n" +
+                "  \"mappings\": {\n" +
+                "    \"parentdoc\": {},\n" +
+                "    \"doc\": {\n" +
+                "      \"_source\": {\n" +
+                "        \"enabled\": " + randomBoolean() + "\n" +
+                "      },\n" +
+                "      \"_parent\": {\n" +
+                "        \"type\": \"parentdoc\",\n" +
+                "        \"store\": \"" + storedString + "\"\n" +
+                "      },\n" +
+                "      \"_ttl\": {\n" +
+                "        \"enabled\": true,\n" +
+                "        \"store\": \"" + storedString + "\"\n" +
+                "      }\n" +
+                "    }\n" +
+                "  }\n" +
+                "}";
+        assertAcked(prepareCreate("testidx").setSource(createIndexSource));
+        ensureGreen();
+        String doc = "{\n" +
+                "  \"_ttl\": \"1h\"\n" +
+                "}";
+
+        client().prepareIndex("testidx", "doc").setId("1").setSource(doc).setParent("1").execute().actionGet();
+
+        String[] fieldsList = {"_ttl", "_parent"};
+        // before refresh - document is only in translog
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList, "1");
+        refresh();
+        //after refresh - document is in translog and also indexed
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList, "1");
+        flush();
+        //after flush - document is in not anymore translog - only indexed
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList, "1");
+    }
+
+    @Test
+    public void testUngeneratedFieldsPartOfSourceUnstoredSourceDisabled() throws IOException {
+        indexSingleDocumentWithUngeneratedFieldsThatArePartOf_source(false, false);
+        String[] fieldsList = {"my_boost"};
+        // before refresh - document is only in translog
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+        refresh();
+        //after refresh - document is in translog and also indexed
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+        flush();
+        //after flush - document is in not anymore translog - only indexed
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+    }
+
+    @Test
+    public void testUngeneratedFieldsPartOfSourceEitherStoredOrSourceEnabled() throws IOException {
+        boolean stored = randomBoolean();
+        boolean sourceEnabled = true;
+        if (stored) {
+            sourceEnabled = randomBoolean();
+        }
+        indexSingleDocumentWithUngeneratedFieldsThatArePartOf_source(stored, sourceEnabled);
+        String[] fieldsList = {"my_boost"};
+        // before refresh - document is only in translog
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList);
+        refresh();
+        //after refresh - document is in translog and also indexed
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList);
+        flush();
+        //after flush - document is in not anymore translog - only indexed
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList);
+    }
+
+    void indexSingleDocumentWithUngeneratedFieldsThatArePartOf_source(boolean stored, boolean sourceEnabled) {
+        String storedString = stored ? "yes" : "no";
+        String createIndexSource = "{\n" +
+                "  \"settings\": {\n" +
+                "    \"index.translog.disable_flush\": true,\n" +
+                "    \"refresh_interval\": \"-1\"\n" +
+                "  },\n" +
+                "  \"mappings\": {\n" +
+                "    \"doc\": {\n" +
+                "      \"_source\": {\n" +
+                "        \"enabled\": " + sourceEnabled + "\n" +
+                "      },\n" +
+                "      \"_boost\": {\n" +
+                "        \"name\": \"my_boost\",\n" +
+                "        \"null_value\": 1,\n" +
+                "        \"store\": \"" + storedString + "\"\n" +
+                "      }\n" +
+                "    }\n" +
+                "  }\n" +
+                "}";
+        assertAcked(prepareCreate("testidx").setSource(createIndexSource));
+        ensureGreen();
+        String doc = "{\n" +
+                "  \"my_boost\": 5.0,\n" +
+                "  \"_ttl\": \"1h\"\n" +
+                "}\n";
+
+        client().prepareIndex("testidx", "doc").setId("1").setSource(doc).setRouting("1").execute().actionGet();
+    }
+
+
+    @Test
+    public void testUngeneratedFieldsNotPartOfSourceUnstored() throws IOException {
+        indexSingleDocumentWithUngeneratedFieldsThatAreNeverPartOf_source(false, randomBoolean());
+        String[] fieldsList = {"_timestamp", "_size", "_routing"};
+        // before refresh - document is only in translog
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList, "1");
+        refresh();
+        //after refresh - document is in translog and also indexed
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList, "1");
+        flush();
+        //after flush - document is in not anymore translog - only indexed
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList, "1");
+    }
+
+    @Test
+    public void testUngeneratedFieldsNotPartOfSourceStored() throws IOException {
+        indexSingleDocumentWithUngeneratedFieldsThatAreNeverPartOf_source(true, randomBoolean());
+        String[] fieldsList = {"_timestamp", "_size", "_routing"};
+        // before refresh - document is only in translog
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList, "1");
+        refresh();
+        //after refresh - document is in translog and also indexed
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList, "1");
+        flush();
+        //after flush - document is in not anymore translog - only indexed
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList, "1");
+    }
+
+    void indexSingleDocumentWithUngeneratedFieldsThatAreNeverPartOf_source(boolean stored, boolean sourceEnabled) {
+        String storedString = stored ? "yes" : "no";
+        String createIndexSource = "{\n" +
+                "  \"settings\": {\n" +
+                "    \"index.translog.disable_flush\": true,\n" +
+                "    \"refresh_interval\": \"-1\"\n" +
+                "  },\n" +
+                "  \"mappings\": {\n" +
+                "    \"parentdoc\": {},\n" +
+                "    \"doc\": {\n" +
+                "      \"_timestamp\": {\n" +
+                "        \"store\": \"" + storedString + "\",\n" +
+                "        \"enabled\": true\n" +
+                "      },\n" +
+                "      \"_routing\": {\n" +
+                "        \"store\": \"" + storedString + "\"\n" +
+                "      },\n" +
+                "      \"_size\": {\n" +
+                "        \"store\": \"" + storedString + "\",\n" +
+                "        \"enabled\": true\n" +
+                "      }\n" +
+                "    }\n" +
+                "  }\n" +
+                "}";
+
+        assertAcked(prepareCreate("testidx").setSource(createIndexSource));
+        ensureGreen();
+        String doc = "{\n" +
+                "  \"text\": \"some text.\"\n" +
+                "}\n";
+        client().prepareIndex("testidx", "doc").setId("1").setSource(doc).setRouting("1").execute().actionGet();
+    }
+
+
+    @Test
+    public void testGeneratedStringFieldsUnstored() throws IOException {
+        indexSingleDocumentWithStringFieldsGeneratedFromText(false, randomBoolean());
+        String[] fieldsList = {"_all", "_field_names"};
+        // before refresh - document is only in translog
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+        refresh();
+        //after refresh - document is in translog and also indexed
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+        flush();
+        //after flush - document is in not anymore translog - only indexed
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+    }
+
+    @Test
+    public void testGeneratedStringFieldsStored() throws IOException {
+        indexSingleDocumentWithStringFieldsGeneratedFromText(true, randomBoolean());
+        String[] fieldsList = {"_all", "_field_names"};
+        // before refresh - document is only in translog
+        assertGetFieldsNull("testidx", "doc", "1", fieldsList);
+        assertGetFieldsException("testidx", "doc", "1", fieldsList);
+        refresh();
+        //after refresh - document is in translog and also indexed
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList);
+        flush();
+        //after flush - document is in not anymore translog - only indexed
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList);
+    }
+
+    void indexSingleDocumentWithStringFieldsGeneratedFromText(boolean stored, boolean sourceEnabled) {
+
+        String storedString = stored ? "yes" : "no";
+        String createIndexSource = "{\n" +
+                "  \"settings\": {\n" +
+                "    \"index.translog.disable_flush\": true,\n" +
+                "    \"refresh_interval\": \"-1\"\n" +
+                "  },\n" +
+                "  \"mappings\": {\n" +
+                "    \"doc\": {\n" +
+                "      \"_source\" : {\"enabled\" : " + sourceEnabled + "}," +
+                "      \"_all\" : {\"enabled\" : true, \"store\":\"" + storedString + "\" }," +
+                "      \"_field_names\" : {\"store\":\"" + storedString + "\" }" +
+                "    }\n" +
+                "  }\n" +
+                "}";
+
+        assertAcked(prepareCreate("testidx").setSource(createIndexSource));
+        ensureGreen();
+        String doc = "{\n" +
+                "  \"text1\": \"some text.\"\n," +
+                "  \"text2\": \"more text.\"\n" +
+                "}\n";
+        index("testidx", "doc", "1", doc);
+    }
+
+
+    @Test
+    public void testGeneratedNumberFieldsUnstored() throws IOException {
+        indexSingleDocumentWithNumericFieldsGeneratedFromText(false, randomBoolean());
+        String[] fieldsList = {"token_count", "text.token_count", "murmur", "text.murmur"};
+        // before refresh - document is only in translog
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+        refresh();
+        //after refresh - document is in translog and also indexed
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+        flush();
+        //after flush - document is in not anymore translog - only indexed
+        assertGetFieldsAlwaysNull("testidx", "doc", "1", fieldsList);
+    }
+
+    @Test
+    public void testGeneratedNumberFieldsStored() throws IOException {
+        indexSingleDocumentWithNumericFieldsGeneratedFromText(true, randomBoolean());
+        String[] fieldsList = {"token_count", "text.token_count", "murmur", "text.murmur"};
+        // before refresh - document is only in translog
+        assertGetFieldsNull("testidx", "doc", "1", fieldsList);
+        assertGetFieldsException("testidx", "doc", "1", fieldsList);
+        refresh();
+        //after refresh - document is in translog and also indexed
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList);
+        flush();
+        //after flush - document is in not anymore translog - only indexed
+        assertGetFieldsAlwaysWorks("testidx", "doc", "1", fieldsList);
+    }
+
+    void indexSingleDocumentWithNumericFieldsGeneratedFromText(boolean stored, boolean sourceEnabled) {
+        String storedString = stored ? "yes" : "no";
+        String createIndexSource = "{\n" +
+                "  \"settings\": {\n" +
+                "    \"index.translog.disable_flush\": true,\n" +
+                "    \"refresh_interval\": \"-1\"\n" +
+                "  },\n" +
+                "  \"mappings\": {\n" +
+                "    \"doc\": {\n" +
+                "      \"_source\" : {\"enabled\" : " + sourceEnabled + "}," +
+                "      \"properties\": {\n" +
+                "        \"token_count\": {\n" +
+                "          \"type\": \"token_count\",\n" +
+                "          \"analyzer\": \"standard\",\n" +
+                "          \"store\": \"" + storedString + "\"" +
+                "        },\n" +
+                "        \"murmur\": {\n" +
+                "          \"type\": \"murmur3\",\n" +
+                "          \"store\": \"" + storedString + "\"" +
+                "        },\n" +
+                "        \"text\": {\n" +
+                "          \"type\": \"string\",\n" +
+                "          \"fields\": {\n" +
+                "            \"token_count\": {\n" +
+                "              \"type\": \"token_count\",\n" +
+                "              \"analyzer\": \"standard\",\n" +
+                "              \"store\": \"" + storedString + "\"" +
+                "            },\n" +
+                "            \"murmur\": {\n" +
+                "              \"type\": \"murmur3\",\n" +
+                "              \"store\": \"" + storedString + "\"" +
+                "            }\n" +
+                "          }\n" +
+                "        }" +
+                "      }\n" +
+                "    }\n" +
+                "  }\n" +
+                "}";
+
+        assertAcked(prepareCreate("testidx").setSource(createIndexSource));
+        ensureGreen();
+        String doc = "{\n" +
+                "  \"murmur\": \"Some value that can be hashed\",\n" +
+                "  \"token_count\": \"A text with five words.\",\n" +
+                "  \"text\": \"A text with five words.\"\n" +
+                "}\n";
+        index("testidx", "doc", "1", doc);
+    }
+
+    private void assertGetFieldsAlwaysWorks(String index, String type, String docId, String[] fields) {
+        assertGetFieldsAlwaysWorks(index, type, docId, fields, null);
+    }
+
+    private void assertGetFieldsAlwaysWorks(String index, String type, String docId, String[] fields, @Nullable String routing) {
+        for (String field : fields) {
+            assertGetFieldWorks(index, type, docId, field, false, routing);
+            assertGetFieldWorks(index, type, docId, field, true, routing);
+        }
+    }
+
+    private void assertGetFieldWorks(String index, String type, String docId, String field, boolean ignoreErrors, @Nullable String routing) {
+        GetResponse response = getDocument(index, type, docId, field, ignoreErrors, routing);
+        assertThat(response.getId(), equalTo(docId));
+        assertTrue(response.isExists());
+        assertNotNull(response.getField(field));
+        response = multiGetDocument(index, type, docId, field, ignoreErrors, routing);
+        assertThat(response.getId(), equalTo(docId));
+        assertTrue(response.isExists());
+        assertNotNull(response.getField(field));
+    }
+
+    protected void assertGetFieldsException(String index, String type, String docId, String[] fields) {
+        for (String field : fields) {
+            assertGetFieldException(index, type, docId, field);
+        }
+    }
+
+    private void assertGetFieldException(String index, String type, String docId, String field) {
+        try {
+            client().prepareGet().setIndex(index).setType(type).setId(docId).setFields(field).setIgnoreErrorsOnGeneratedFields(false).get();
+            fail();
+        } catch (ElasticsearchException e) {
+            assertTrue(e.getMessage().contains("You can only get this field after refresh() has been called."));
+        }
+        MultiGetResponse multiGetResponse = client().prepareMultiGet().add(new MultiGetRequest.Item(index, type, docId).fields(field)).setIgnoreErrorsOnGeneratedFields(false).get();
+        assertNull(multiGetResponse.getResponses()[0].getResponse());
+        assertTrue(multiGetResponse.getResponses()[0].getFailure().getMessage().contains("You can only get this field after refresh() has been called."));
+    }
+
+    protected void assertGetFieldsNull(String index, String type, String docId, String[] fields) {
+        assertGetFieldsNull(index, type, docId, fields, null);
+    }
+
+    protected void assertGetFieldsNull(String index, String type, String docId, String[] fields, @Nullable String routing) {
+        for (String field : fields) {
+            assertGetFieldNull(index, type, docId, field, true, routing);
+        }
+    }
+
+    protected void assertGetFieldsAlwaysNull(String index, String type, String docId, String[] fields) {
+        assertGetFieldsAlwaysNull(index, type, docId, fields, null);
+    }
+
+    protected void assertGetFieldsAlwaysNull(String index, String type, String docId, String[] fields, @Nullable String routing) {
+        for (String field : fields) {
+            assertGetFieldNull(index, type, docId, field, true, routing);
+            assertGetFieldNull(index, type, docId, field, false, routing);
+        }
+    }
+
+    protected void assertGetFieldNull(String index, String type, String docId, String field, boolean ignoreErrors, @Nullable String routing) {
+        //for get
+        GetResponse response = getDocument(index, type, docId, field, ignoreErrors, routing);
+        assertTrue(response.isExists());
+        assertNull(response.getField(field));
+        assertThat(response.getId(), equalTo(docId));
+        //same for multi get
+        response = multiGetDocument(index, type, docId, field, ignoreErrors, routing);
+        assertNull(response.getField(field));
+        assertThat(response.getId(), equalTo(docId));
+        assertTrue(response.isExists());
+    }
+
+    private GetResponse multiGetDocument(String index, String type, String docId, String field, boolean ignoreErrors, @Nullable String routing) {
+        MultiGetRequest.Item getItem = new MultiGetRequest.Item(index, type, docId).fields(field);
+        if (routing != null) {
+            getItem.routing(routing);
+        }
+        MultiGetRequestBuilder multiGetRequestBuilder = client().prepareMultiGet().add(getItem).setIgnoreErrorsOnGeneratedFields(ignoreErrors);
+        MultiGetResponse multiGetResponse = multiGetRequestBuilder.get();
+        assertThat(multiGetResponse.getResponses().length, equalTo(1));
+        return multiGetResponse.getResponses()[0].getResponse();
+    }
+
+    private GetResponse getDocument(String index, String type, String docId, String field, boolean ignoreErrors, @Nullable String routing) {
+        GetRequestBuilder getRequestBuilder = client().prepareGet().setIndex(index).setType(type).setId(docId).setFields(field).setIgnoreErrorsOnGeneratedFields(ignoreErrors);
+        if (routing != null) {
+            getRequestBuilder.setRouting(routing);
+        }
+        return getRequestBuilder.get();
+    }
 }
diff --git a/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java
index 9f4cc7a3ccc9..07f1026efc34 100644
--- a/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java
+++ b/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java
@@ -1040,6 +1040,19 @@ protected final IndexResponse index(String index, String type, String id, Object
         return client().prepareIndex(index, type, id).setSource(source).execute().actionGet();
     }
 
+    /**
+     * Syntactic sugar for:
+     *
+     * <pre>
+     *   return client().prepareIndex(index, type, id).setSource(source).execute().actionGet();
+     * </pre>
+     *
+     * where source is a String.
+     */
+    protected final IndexResponse index(String index, String type, String id, String source) {
+        return client().prepareIndex(index, type, id).setSource(source).execute().actionGet();
+    }
+
     /**
      * Waits for relocations and refreshes all indices in the cluster.
      *
