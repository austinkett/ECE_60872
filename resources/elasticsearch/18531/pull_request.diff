diff --git a/modules/lang-painless/ant.xml b/modules/lang-painless/ant.xml
index 1d2bdb678e8f..9d3cf9ece91c 100644
--- a/modules/lang-painless/ant.xml
+++ b/modules/lang-painless/ant.xml
@@ -42,10 +42,16 @@
   <macrodef name="regen-delete">
     <attribute name="grammar" />
     <sequential>
+      <local name="grammar.path"/>
+      <property name="grammar.path" location="src/main/antlr"/>
+      <!-- delete token files so files will be generated -->
+      <delete dir="${grammar.path}" includes="@{grammar}*.tokens"/>
       <local name="output.path"/>
       <patternset id="grammar.@{grammar}.patternset">
         <include name="@{grammar}Lexer.java" />
         <include name="@{grammar}Parser.java" />
+        <include name="@{grammar}Lexer.tokens" />
+        <include name="@{grammar}Parser.tokens" />
         <include name="@{grammar}ParserVisitor.java" />
         <include name="@{grammar}ParserBaseVisitor.java" />
       </patternset>
@@ -70,6 +76,7 @@
         <sysproperty key="user.language" value="en"/>
         <sysproperty key="user.country" value="US"/>
         <sysproperty key="user.variant" value=""/>
+        <arg value="-Werror"/>
         <arg value="-package"/>
         <arg value="org.elasticsearch.painless.antlr"/>
         <arg value="-o"/>
@@ -92,6 +99,7 @@
         <sysproperty key="user.language" value="en"/>
         <sysproperty key="user.country" value="US"/>
         <sysproperty key="user.variant" value=""/>
+        <arg value="-Werror"/>
         <arg value="-package"/>
         <arg value="org.elasticsearch.painless.antlr"/>
         <arg value="-no-listener"/>
@@ -121,9 +129,9 @@
       <fileset id="grammar.fileset" dir="${output.path}">
         <patternset refid="grammar.@{grammar}.patternset"/>
       </fileset>
-      <!-- remove files that are not needed to compile or at runtime -->
-      <delete dir="${grammar.path}" includes="@{grammar}*.tokens"/>
-      <delete dir="${output.path}" includes="@{grammar}*.tokens"/>
+      <!-- moves token files to grammar directory for use with IDE's -->
+      <move file="${output.path}/@{grammar}Lexer.tokens" todir="${grammar.path}"/>
+      <move file="${output.path}/@{grammar}Parser.tokens" todir="${grammar.path}"/>
       <!-- make the generated classes package private -->
       <replaceregexp match="public ((interface|class) \Q@{grammar}\E\w+)" replace="\1" encoding="UTF-8">
         <fileset refid="grammar.fileset"/>
diff --git a/modules/lang-painless/src/main/antlr/PainlessLexer.g4 b/modules/lang-painless/src/main/antlr/PainlessLexer.g4
index 97c798450439..2588a646dcbf 100644
--- a/modules/lang-painless/src/main/antlr/PainlessLexer.g4
+++ b/modules/lang-painless/src/main/antlr/PainlessLexer.g4
@@ -19,6 +19,10 @@
 
 lexer grammar PainlessLexer;
 
+@header {
+import org.elasticsearch.painless.Definition;
+}
+
 WS: [ \t\n\r]+ -> skip;
 COMMENT: ( '//' .*? [\n\r] | '/*' .*? '*/' ) -> skip;
 
@@ -28,7 +32,7 @@ LBRACE:    '[';
 RBRACE:    ']';
 LP:        '(';
 RP:        ')';
-DOT:       '.' -> mode(EXT);
+DOT:       '.' -> mode(AFTER_DOT);
 COMMA:     ',';
 SEMICOLON: ';';
 IF:        'if';
@@ -88,7 +92,7 @@ AUSH:   '>>>=';
 OCTAL: '0' [0-7]+ [lL]?;
 HEX: '0' [xX] [0-9a-fA-F]+ [lL]?;
 INTEGER: ( '0' | [1-9] [0-9]* ) [lLfFdD]?;
-DECIMAL: ( '0' | [1-9] [0-9]* ) DOT [0-9]* ( [eE] [+\-]? [0-9]+ )? [fF]?;
+DECIMAL: ( '0' | [1-9] [0-9]* ) (DOT [0-9]+)? ( [eE] [+\-]? [0-9]+ )? [fF]?;
 
 STRING: ( '"' ( '\\"' | '\\\\' | ~[\\"] )*? '"' ) | ( '\'' ( '\\\'' | '\\\\' | ~[\\"] )*? '\'' );
 
@@ -97,8 +101,16 @@ FALSE: 'false';
 
 NULL: 'null';
 
+// The predicate here allows us to remove ambiguities when
+// dealing with types versus identifiers.  We check against
+// the current whitelist to determine whether a token is a type
+// or not.  Note this works by processing one character at a time
+// and the rule is added or removed as this happens.  This is also known
+// as "the lexer hack."  See (https://en.wikipedia.org/wiki/The_lexer_hack).
+TYPE: ID ( DOT ID )* { Definition.isSimpleType(getText()) }?;
 ID: [_a-zA-Z] [_a-zA-Z0-9]*;
 
-mode EXT;
-EXTINTEGER: ( '0' | [1-9] [0-9]* ) -> mode(DEFAULT_MODE);
-EXTID: [_a-zA-Z] [_a-zA-Z0-9]* -> mode(DEFAULT_MODE);
+mode AFTER_DOT;
+
+DOTINTEGER: ( '0' | [1-9] [0-9]* )                        -> mode(DEFAULT_MODE);
+DOTID: [_a-z] [_a-zA-Z0-9]*                               -> mode(DEFAULT_MODE);
diff --git a/modules/lang-painless/src/main/antlr/PainlessLexer.tokens b/modules/lang-painless/src/main/antlr/PainlessLexer.tokens
new file mode 100644
index 000000000000..d42e157e9644
--- /dev/null
+++ b/modules/lang-painless/src/main/antlr/PainlessLexer.tokens
@@ -0,0 +1,137 @@
+WS=1
+COMMENT=2
+LBRACK=3
+RBRACK=4
+LBRACE=5
+RBRACE=6
+LP=7
+RP=8
+DOT=9
+COMMA=10
+SEMICOLON=11
+IF=12
+ELSE=13
+WHILE=14
+DO=15
+FOR=16
+CONTINUE=17
+BREAK=18
+RETURN=19
+NEW=20
+TRY=21
+CATCH=22
+THROW=23
+BOOLNOT=24
+BWNOT=25
+MUL=26
+DIV=27
+REM=28
+ADD=29
+SUB=30
+LSH=31
+RSH=32
+USH=33
+LT=34
+LTE=35
+GT=36
+GTE=37
+EQ=38
+EQR=39
+NE=40
+NER=41
+BWAND=42
+XOR=43
+BWOR=44
+BOOLAND=45
+BOOLOR=46
+COND=47
+COLON=48
+INCR=49
+DECR=50
+ASSIGN=51
+AADD=52
+ASUB=53
+AMUL=54
+ADIV=55
+AREM=56
+AAND=57
+AXOR=58
+AOR=59
+ALSH=60
+ARSH=61
+AUSH=62
+OCTAL=63
+HEX=64
+INTEGER=65
+DECIMAL=66
+STRING=67
+TRUE=68
+FALSE=69
+NULL=70
+TYPE=71
+ID=72
+DOTINTEGER=73
+DOTID=74
+'{'=3
+'}'=4
+'['=5
+']'=6
+'('=7
+')'=8
+'.'=9
+','=10
+';'=11
+'if'=12
+'else'=13
+'while'=14
+'do'=15
+'for'=16
+'continue'=17
+'break'=18
+'return'=19
+'new'=20
+'try'=21
+'catch'=22
+'throw'=23
+'!'=24
+'~'=25
+'*'=26
+'/'=27
+'%'=28
+'+'=29
+'-'=30
+'<<'=31
+'>>'=32
+'>>>'=33
+'<'=34
+'<='=35
+'>'=36
+'>='=37
+'=='=38
+'==='=39
+'!='=40
+'!=='=41
+'&'=42
+'^'=43
+'|'=44
+'&&'=45
+'||'=46
+'?'=47
+':'=48
+'++'=49
+'--'=50
+'='=51
+'+='=52
+'-='=53
+'*='=54
+'/='=55
+'%='=56
+'&='=57
+'^='=58
+'|='=59
+'<<='=60
+'>>='=61
+'>>>='=62
+'true'=68
+'false'=69
+'null'=70
diff --git a/modules/lang-painless/src/main/antlr/PainlessParser.g4 b/modules/lang-painless/src/main/antlr/PainlessParser.g4
index b36dec5afbb9..12de27cefd3d 100644
--- a/modules/lang-painless/src/main/antlr/PainlessParser.g4
+++ b/modules/lang-painless/src/main/antlr/PainlessParser.g4
@@ -22,35 +22,37 @@ parser grammar PainlessParser;
 options { tokenVocab=PainlessLexer; }
 
 source
-    : statement+ EOF
+    : statement* EOF
     ;
 
+// Note we use a predicate on the if/else case here to prevent the
+// "dangling-else" ambiguity by forcing the 'else' token to be consumed
+// as soon as one is found.  See (https://en.wikipedia.org/wiki/Dangling_else).
 statement
-    : IF LP expression RP block ( ELSE block )?                                              # if
-    | WHILE LP expression RP ( block | empty )                                               # while
-    | DO block WHILE LP expression RP ( SEMICOLON | EOF )                                    # do
-    | FOR LP initializer? SEMICOLON expression? SEMICOLON afterthought? RP ( block | empty ) # for
-    | declaration ( SEMICOLON | EOF )                                                        # decl
-    | CONTINUE ( SEMICOLON | EOF )                                                           # continue
-    | BREAK ( SEMICOLON | EOF )                                                              # break
-    | RETURN expression ( SEMICOLON | EOF )                                                  # return
-    | TRY block trap+                                                                        # try
-    | THROW expression ( SEMICOLON | EOF )                                                   # throw
-    | expression ( SEMICOLON | EOF )                                                         # expr
+    : IF LP expression RP trailer ( ELSE trailer | { _input.LA(1) != ELSE }? )                 # if
+    | WHILE LP expression RP ( trailer | empty )                                               # while
+    | DO block WHILE LP expression RP delimiter                                                # do
+    | FOR LP initializer? SEMICOLON expression? SEMICOLON afterthought? RP ( trailer | empty ) # for
+    | declaration delimiter                                                                    # decl
+    | CONTINUE delimiter                                                                       # continue
+    | BREAK delimiter                                                                          # break
+    | RETURN expression delimiter                                                              # return
+    | TRY block trap+                                                                          # try
+    | THROW expression delimiter                                                               # throw
+    | expression delimiter                                                                     # expr
     ;
 
-block
-    : LBRACK statement+ RBRACK # multiple
-    | statement                # single
+trailer
+    : block
+    | statement
     ;
 
-empty
-    : emptyscope
-    | SEMICOLON
+block
+    : LBRACK statement* RBRACK
     ;
 
-emptyscope
-    : LBRACK RBRACK
+empty
+    : SEMICOLON
     ;
 
 initializer
@@ -63,75 +65,96 @@ afterthought
     ;
 
 declaration
-    : decltype declvar ( COMMA declvar )*
+    : decltype declvar (COMMA declvar)*
     ;
 
 decltype
-    : identifier (LBRACE RBRACE)*
+    : TYPE (LBRACE RBRACE)*
     ;
 
 declvar
-    : identifier ( ASSIGN expression )?
+    : ID ( ASSIGN expression )?
     ;
 
 trap
-    : CATCH LP ( identifier identifier ) RP ( block | emptyscope )
-    ;
-
-identifier
-    : ID generic?
-    ;
-
-generic
-    : LT identifier ( COMMA identifier )* GT
-    ;
-
-expression
-    :               LP expression RP                                    # precedence
-    |               ( OCTAL | HEX | INTEGER | DECIMAL )                 # numeric
-    |               TRUE                                                # true
-    |               FALSE                                               # false
-    |               NULL                                                # null
-    | <assoc=right> chain ( INCR | DECR )                               # postinc
-    | <assoc=right> ( INCR | DECR ) chain                               # preinc
-    |               chain                                               # read
-    | <assoc=right> ( BOOLNOT | BWNOT | ADD | SUB ) expression          # unary
-    | <assoc=right> LP decltype RP expression                           # cast
-    |               expression ( MUL | DIV | REM ) expression           # binary
-    |               expression ( ADD | SUB ) expression                 # binary
-    |               expression ( LSH | RSH | USH ) expression           # binary
-    |               expression ( LT | LTE | GT | GTE ) expression       # comp
-    |               expression ( EQ | EQR | NE | NER ) expression       # comp
-    |               expression BWAND expression                         # binary
-    |               expression XOR expression                           # binary
-    |               expression BWOR expression                          # binary
-    |               expression BOOLAND expression                       # bool
-    |               expression BOOLOR expression                        # bool
-    | <assoc=right> expression COND expression COLON expression         # conditional
-    | <assoc=right> chain ( ASSIGN | AADD | ASUB | AMUL | ADIV
-                                      | AREM | AAND | AXOR | AOR
-                                      | ALSH | ARSH | AUSH ) expression # assignment
-    ;
-
-chain
-    : linkprec
-    | linkcast
-    | linkvar
-    | linknew
-    | linkstring
-    ;
-
-linkprec:   LP ( linkprec | linkcast | linkvar | linknew | linkstring ) RP ( linkdot | linkbrace )?;
-linkcast:   LP decltype RP ( linkprec | linkcast | linkvar | linknew | linkstring );
-linkbrace:  LBRACE expression RBRACE ( linkdot | linkbrace )?;
-linkdot:    DOT ( linkcall | linkfield );
-linkcall:   EXTID arguments ( linkdot | linkbrace )?;
-linkvar:    identifier ( linkdot | linkbrace )?;
-linkfield:  ( EXTID | EXTINTEGER ) ( linkdot | linkbrace )?;
-linknew:    NEW identifier ( ( arguments linkdot? ) | ( ( LBRACE expression RBRACE )+ linkdot? ) );
-linkstring: STRING (linkdot | linkbrace )?;
+    : CATCH LP TYPE ID RP block
+    ;
+
+delimiter
+    : SEMICOLON
+    | EOF
+    ;
+
+// Note we return the boolean s.  This is returned as true
+// if secondaries (postfixes) are allowed, otherwise, false.
+// This prevents illegal secondaries from being appended to
+// expressions using precedence that aren't variable/method chains.
+expression returns [boolean s = true]
+    :               u = unary[false]                                       { $s = $u.s; }           # single
+    |               expression ( MUL | DIV | REM ) expression              { $s = false; }          # binary
+    |               expression ( ADD | SUB ) expression                    { $s = false; }          # binary
+    |               expression ( LSH | RSH | USH ) expression              { $s = false; }          # binary
+    |               expression ( LT | LTE | GT | GTE ) expression          { $s = false; }          # comp
+    |               expression ( EQ | EQR | NE | NER ) expression          { $s = false; }          # comp
+    |               expression BWAND expression                            { $s = false; }          # binary
+    |               expression XOR expression                              { $s = false; }          # binary
+    |               expression BWOR expression                             { $s = false; }          # binary
+    |               expression BOOLAND expression                          { $s = false; }          # bool
+    |               expression BOOLOR expression                           { $s = false; }          # bool
+    | <assoc=right> expression COND e0 = expression COLON e1 = expression  { $s = $e0.s && $e1.s; } # conditional
+    // TODO: Should we allow crazy syntax like (x = 5).call()?
+    //       Other crazy syntaxes work, but this one requires
+    //       a complete restructure of the rules as EChain isn't
+    //       designed to handle more postfixes after an assignment.
+    | <assoc=right> chain[true] ( ASSIGN | AADD | ASUB | AMUL |
+                                  ADIV   | AREM | AAND | AXOR |
+                                  AOR    | ALSH | ARSH | AUSH ) expression { $s = false; }         # assignment
+    ;
+
+// Note we take in the boolean c.  This is used to indicate
+// whether or not this rule was called when we are already
+// processing a variable/method chain.  This prevents the chain
+// from being applied to rules where it wouldn't be allowed.
+unary[boolean c] returns [boolean s = true]
+    : { !$c }? ( INCR | DECR ) chain[true]                                  # pre
+    | { !$c }? chain[true] (INCR | DECR )                                   # post
+    | { !$c }? chain[false]                                                 # read
+    | { !$c }? ( OCTAL | HEX | INTEGER | DECIMAL )          { $s = false; } # numeric
+    | { !$c }? TRUE                                         { $s = false; } # true
+    | { !$c }? FALSE                                        { $s = false; } # false
+    | { !$c }? NULL                                         { $s = false; } # null
+    | { !$c }? ( BOOLNOT | BWNOT | ADD | SUB ) unary[false]                 # operator
+    |          LP decltype RP unary[$c]                                     # cast
+    ;
+
+chain[boolean c]
+    : p = primary[$c] secondary[$p.s]*                             # dynamic
+    | decltype dot secondary[true]*                                # static
+    | NEW TYPE (LBRACE expression RBRACE)+ (dot secondary[true]*)? # newarray
+    ;
+
+primary[boolean c] returns [boolean s = true]
+    : { !$c }? LP e = expression RP { $s = $e.s; } # exprprec
+    | { $c }?  LP unary[true] RP                   # chainprec
+    |          STRING                              # string
+    |          ID                                  # variable
+    |          NEW TYPE arguments                  # newobject
+    ;
+
+secondary[boolean s]
+    : { $s }? dot
+    | { $s }? brace
+    ;
+
+dot
+    : DOT DOTID arguments        # callinvoke
+    | DOT ( DOTID | DOTINTEGER ) # fieldaccess
+    ;
+
+brace
+    : LBRACE expression RBRACE # braceaccess
+    ;
 
 arguments
     : ( LP ( expression ( COMMA expression )* )? RP )
     ;
-
diff --git a/modules/lang-painless/src/main/antlr/PainlessParser.tokens b/modules/lang-painless/src/main/antlr/PainlessParser.tokens
new file mode 100644
index 000000000000..d42e157e9644
--- /dev/null
+++ b/modules/lang-painless/src/main/antlr/PainlessParser.tokens
@@ -0,0 +1,137 @@
+WS=1
+COMMENT=2
+LBRACK=3
+RBRACK=4
+LBRACE=5
+RBRACE=6
+LP=7
+RP=8
+DOT=9
+COMMA=10
+SEMICOLON=11
+IF=12
+ELSE=13
+WHILE=14
+DO=15
+FOR=16
+CONTINUE=17
+BREAK=18
+RETURN=19
+NEW=20
+TRY=21
+CATCH=22
+THROW=23
+BOOLNOT=24
+BWNOT=25
+MUL=26
+DIV=27
+REM=28
+ADD=29
+SUB=30
+LSH=31
+RSH=32
+USH=33
+LT=34
+LTE=35
+GT=36
+GTE=37
+EQ=38
+EQR=39
+NE=40
+NER=41
+BWAND=42
+XOR=43
+BWOR=44
+BOOLAND=45
+BOOLOR=46
+COND=47
+COLON=48
+INCR=49
+DECR=50
+ASSIGN=51
+AADD=52
+ASUB=53
+AMUL=54
+ADIV=55
+AREM=56
+AAND=57
+AXOR=58
+AOR=59
+ALSH=60
+ARSH=61
+AUSH=62
+OCTAL=63
+HEX=64
+INTEGER=65
+DECIMAL=66
+STRING=67
+TRUE=68
+FALSE=69
+NULL=70
+TYPE=71
+ID=72
+DOTINTEGER=73
+DOTID=74
+'{'=3
+'}'=4
+'['=5
+']'=6
+'('=7
+')'=8
+'.'=9
+','=10
+';'=11
+'if'=12
+'else'=13
+'while'=14
+'do'=15
+'for'=16
+'continue'=17
+'break'=18
+'return'=19
+'new'=20
+'try'=21
+'catch'=22
+'throw'=23
+'!'=24
+'~'=25
+'*'=26
+'/'=27
+'%'=28
+'+'=29
+'-'=30
+'<<'=31
+'>>'=32
+'>>>'=33
+'<'=34
+'<='=35
+'>'=36
+'>='=37
+'=='=38
+'==='=39
+'!='=40
+'!=='=41
+'&'=42
+'^'=43
+'|'=44
+'&&'=45
+'||'=46
+'?'=47
+':'=48
+'++'=49
+'--'=50
+'='=51
+'+='=52
+'-='=53
+'*='=54
+'/='=55
+'%='=56
+'&='=57
+'^='=58
+'|='=59
+'<<='=60
+'>>='=61
+'>>>='=62
+'true'=68
+'false'=69
+'null'=70
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/Analyzer.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Analyzer.java
index e81e828c8755..a06bcdf98408 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/Analyzer.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Analyzer.java
@@ -26,9 +26,8 @@
  * Runs the analysis phase of compilation using the Painless AST.
  */
 final class Analyzer {
-    static Variables analyze(final CompilerSettings settings,
-                                    final Reserved shortcut, final SSource root) {
-        final Variables variables = new Variables(settings, shortcut);
+    static Variables analyze(Reserved shortcut, SSource root) {
+        Variables variables = new Variables(shortcut);
         root.analyze(variables);
 
         return variables;
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java
index 16ad355177f5..666f28bb4061 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Compiler.java
@@ -57,7 +57,7 @@
         try {
             // Setup the code privileges.
             CODESOURCE = new CodeSource(new URL("file:" + BootstrapInfo.UNTRUSTED_CODEBASE), (Certificate[]) null);
-        } catch (final MalformedURLException impossible) {
+        } catch (MalformedURLException impossible) {
             throw new RuntimeException(impossible);
         }
     }
@@ -69,7 +69,7 @@
         /**
          * @param parent The parent ClassLoader.
          */
-        Loader(final ClassLoader parent) {
+        Loader(ClassLoader parent) {
             super(parent);
         }
 
@@ -79,7 +79,7 @@
          * @param bytes The generated byte code.
          * @return A Class object extending {@link Executable}.
          */
-        Class<? extends Executable> define(final String name, final byte[] bytes) {
+        Class<? extends Executable> define(String name, byte[] bytes) {
             return defineClass(name, bytes, 0, bytes.length, CODESOURCE).asSubclass(Executable.class);
         }
     }
@@ -92,7 +92,7 @@
      * @param settings The CompilerSettings to be used during the compilation.
      * @return An {@link Executable} Painless script.
      */
-    static Executable compile(final Loader loader, final String name, final String source, final CompilerSettings settings) {
+    static Executable compile(Loader loader, String name, String source, CompilerSettings settings) {
         byte[] bytes = compile(name, source, settings);
 
         return createExecutable(loader, name, source, bytes);
@@ -111,9 +111,9 @@ static Executable compile(final Loader loader, final String name, final String s
                 " plugin if a script longer than this length is a requirement.");
         }
 
-        final Reserved reserved = new Reserved();
-        final SSource root = Walker.buildPainlessTree(source, reserved, settings);
-        final Variables variables = Analyzer.analyze(settings, reserved, root);
+        Reserved reserved = new Reserved();
+        SSource root = Walker.buildPainlessTree(source, reserved, settings);
+        Variables variables = Analyzer.analyze(reserved, root);
 
         return Writer.write(settings, name, source, variables, root);
     }
@@ -126,13 +126,13 @@ static Executable compile(final Loader loader, final String name, final String s
      * @param bytes The ASM generated byte code to define the class with.
      * @return A Painless {@link Executable} script.
      */
-    private static Executable createExecutable(final Loader loader, final String name, final String source, final byte[] bytes) {
+    private static Executable createExecutable(Loader loader, String name, String source, byte[] bytes) {
         try {
-            final Class<? extends Executable> clazz = loader.define(CLASS_NAME, bytes);
-            final java.lang.reflect.Constructor<? extends Executable> constructor = clazz.getConstructor(String.class, String.class);
+            Class<? extends Executable> clazz = loader.define(CLASS_NAME, bytes);
+            java.lang.reflect.Constructor<? extends Executable> constructor = clazz.getConstructor(String.class, String.class);
 
             return constructor.newInstance(name, source);
-        } catch (final Exception exception) { // Catch everything to let the user know this is something caused internally.
+        } catch (Exception exception) { // Catch everything to let the user know this is something caused internally.
             throw new IllegalStateException(
                     "An internal error occurred attempting to define the script [" + name + "].", exception);
         }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/CompilerSettings.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/CompilerSettings.java
index 4cafe32bb56c..79b75b32b985 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/CompilerSettings.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/CompilerSettings.java
@@ -29,11 +29,22 @@
      */
     public static final String MAX_LOOP_COUNTER = "max_loop_counter";
 
+    /**
+     * Constant to be used for enabling additional internal compilation checks (slower).
+     */
+    public static final String PICKY = "picky";
+
     /**
      * The maximum number of statements allowed to be run in a loop.
      */
     private int maxLoopCounter = 10000;
 
+    /**
+     * Whether to throw exception on ambiguity or other internal parsing issues. This option
+     * makes things slower too, it is only for debugging.
+     */
+    private boolean picky = false;
+
     /**
      * Returns the value for the cumulative total number of statements that can be made in all loops
      * in a script before an exception is thrown.  This attempts to prevent infinite loops.  Note if
@@ -50,4 +61,21 @@ public final int getMaxLoopCounter() {
     public final void setMaxLoopCounter(int max) {
         this.maxLoopCounter = max;
     }
+
+    /**
+     * Returns true if the compiler should be picky. This means it runs slower and enables additional
+     * runtime checks, throwing an exception if there are ambiguities in the grammar or other low level
+     * parsing problems.
+     */
+    public boolean isPicky() {
+      return picky;
+    }
+
+    /**
+     * Set to true if compilation should be picky.
+     * @see #isPicky
+     */
+    public void setPicky(boolean picky) {
+      this.picky = picky;
+    }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java
index 05c12c302392..1aa8d1997611 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Definition.java
@@ -37,11 +37,11 @@
  * methods and fields during at both compile-time and runtime.
  */
 public final class Definition {
-    
+
     private static final String DEFINITION_FILE = "definition.txt";
 
     private static final Definition INSTANCE = new Definition();
-    
+
     /** Some native types as constants: */
     public static final Type VOID_TYPE = getType("void");
     public static final Type BOOLEAN_TYPE = getType("boolean");
@@ -290,7 +290,7 @@ private Struct(final String name, final Class<?> clazz, final org.objectweb.asm.
             staticMembers = new HashMap<>();
             members = new HashMap<>();
         }
-        
+
         private Struct(final Struct struct) {
             name = struct.name;
             clazz = struct.clazz;
@@ -374,6 +374,22 @@ private RuntimeClass(final Map<MethodKey, Method> methods,
         }
     }
 
+    /** Returns whether or not a non-array type exists. */
+    public static boolean isSimpleType(final String name) {
+        return INSTANCE.structsMap.containsKey(name);
+    }
+
+    /** Returns whether or not a type exists without an exception. */
+    public static boolean isType(final String name) {
+        try {
+            INSTANCE.getTypeInternal(name);
+
+            return true;
+        } catch (IllegalArgumentException exception) {
+            return false;
+        }
+    }
+
     /** Gets the type given by its name */
     public static Type getType(final String name) {
         return INSTANCE.getTypeInternal(name);
@@ -383,13 +399,13 @@ public static Type getType(final String name) {
     public static Type getType(final Struct struct, final int dimensions) {
         return INSTANCE.getTypeInternal(struct, dimensions);
     }
-    
+
     public static RuntimeClass getRuntimeClass(Class<?> clazz) {
         return INSTANCE.runtimeMap.get(clazz);
     }
-    
+
     // INTERNAL IMPLEMENTATION:
-    
+
     private final Map<Class<?>, RuntimeClass> runtimeMap;
     private final Map<String, Struct> structsMap;
     private final Map<String, Type> simpleTypesMap;
@@ -898,15 +914,17 @@ private void addRuntimeClass(final Struct struct) {
         runtimeMap.put(struct.clazz, new RuntimeClass(methods, getters, setters));
     }
 
-    private Type getTypeInternal(final String name) {
+    private Type getTypeInternal(String name) {
         // simple types (e.g. 0 array dimensions) are a simple hash lookup for speed
         Type simple = simpleTypesMap.get(name);
+
         if (simple != null) {
             return simple;
         }
-        final int dimensions = getDimensions(name);
-        final String structstr = dimensions == 0 ? name : name.substring(0, name.indexOf('['));
-        final Struct struct = structsMap.get(structstr);
+
+        int dimensions = getDimensions(name);
+        String structstr = dimensions == 0 ? name : name.substring(0, name.indexOf('['));
+        Struct struct = structsMap.get(structstr);
 
         if (struct == null) {
             throw new IllegalArgumentException("The struct with name [" + name + "] has not been defined.");
@@ -915,29 +933,29 @@ private Type getTypeInternal(final String name) {
         return getTypeInternal(struct, dimensions);
     }
 
-    private Type getTypeInternal(final Struct struct, final int dimensions) {
+    private Type getTypeInternal(Struct struct, int dimensions) {
         String name = struct.name;
         org.objectweb.asm.Type type = struct.type;
         Class<?> clazz = struct.clazz;
         Sort sort;
 
         if (dimensions > 0) {
-            final StringBuilder builder = new StringBuilder(name);
-            final char[] brackets = new char[dimensions];
+            StringBuilder builder = new StringBuilder(name);
+            char[] brackets = new char[dimensions];
 
             for (int count = 0; count < dimensions; ++count) {
                 builder.append("[]");
                 brackets[count] = '[';
             }
 
-            final String descriptor = new String(brackets) + struct.type.getDescriptor();
+            String descriptor = new String(brackets) + struct.type.getDescriptor();
 
             name = builder.toString();
             type = org.objectweb.asm.Type.getType(descriptor);
 
             try {
                 clazz = Class.forName(type.getInternalName().replace('/', '.'));
-            } catch (final ClassNotFoundException exception) {
+            } catch (ClassNotFoundException exception) {
                 throw new IllegalArgumentException("The class [" + type.getInternalName() + "]" +
                     " could not be found to create type [" + name + "].");
             }
@@ -948,7 +966,7 @@ private Type getTypeInternal(final Struct struct, final int dimensions) {
         } else {
             sort = Sort.OBJECT;
 
-            for (final Sort value : Sort.values()) {
+            for (Sort value : Sort.values()) {
                 if (value.clazz == null) {
                     continue;
                 }
@@ -964,12 +982,12 @@ private Type getTypeInternal(final Struct struct, final int dimensions) {
         return new Type(name, dimensions, struct, clazz, type, sort);
     }
 
-    private int getDimensions(final String name) {
+    private int getDimensions(String name) {
         int dimensions = 0;
         int index = name.indexOf('[');
 
         if (index != -1) {
-            final int length = name.length();
+            int length = name.length();
 
             while (index < length) {
                 if (name.charAt(index) == '[' && ++index < length && name.charAt(index++) == ']') {
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessScriptEngineService.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessScriptEngineService.java
index 72a657cd7f03..f9ee949e3d46 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessScriptEngineService.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/PainlessScriptEngineService.java
@@ -121,6 +121,12 @@ public Object compile(String scriptName, final String scriptSource, final Map<St
                 compilerSettings.setMaxLoopCounter(Integer.parseInt(value));
             }
 
+            value = copy.remove(CompilerSettings.PICKY);
+
+            if (value != null) {
+                compilerSettings.setPicky(Boolean.parseBoolean(value));
+            }
+
             if (!copy.isEmpty()) {
                 throw new IllegalArgumentException("Unrecognized compile-time parameter(s): " + copy);
             }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/Variables.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Variables.java
index 28a7416d8007..4443b1dc0f84 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/Variables.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/Variables.java
@@ -50,7 +50,7 @@
         boolean ctx = false;
         boolean loop = false;
 
-        public void markReserved(final String name) {
+        public void markReserved(String name) {
             if (SCORE.equals(name)) {
                 score = true;
             } else if (CTX.equals(name)) {
@@ -58,7 +58,7 @@ public void markReserved(final String name) {
             }
         }
 
-        public boolean isReserved(final String name) {
+        public boolean isReserved(String name) {
             return name.equals(THIS) || name.equals(PARAMS) || name.equals(SCORER) || name.equals(DOC) ||
                 name.equals(VALUE) || name.equals(SCORE) || name.equals(CTX) || name.equals(LOOP);
          }
@@ -77,7 +77,7 @@ public void usesLoop() {
 
         public boolean read = false;
 
-        private Variable(final String location, final String name, final Type type, final int slot, final boolean readonly) {
+        private Variable(String location, String name, Type type, int slot, boolean readonly) {
             this.location = location;
             this.name = name;
             this.type = type;
@@ -91,7 +91,7 @@ private Variable(final String location, final String name, final Type type, fina
     private final Deque<Integer> scopes = new ArrayDeque<>();
     private final Deque<Variable> variables = new ArrayDeque<>();
 
-    public Variables(final CompilerSettings settings, final Reserved reserved) {
+    public Variables(Reserved reserved) {
         this.reserved = reserved;
 
         incrementScope();
@@ -99,35 +99,35 @@ public Variables(final CompilerSettings settings, final Reserved reserved) {
         // Method variables.
 
         // This reference.  Internal use only.
-        addVariable("[" + Reserved.THIS + "]"  , "Executable", Reserved.THIS  , true, true);
+        addVariable("[" + Reserved.THIS + "]", Definition.getType("Executable"), Reserved.THIS, true, true);
 
-        // Input map of variables passed to the script.  TODO: Rename to 'params' since that will be its use.
-        addVariable("[" + Reserved.PARAMS + "]", "Map", Reserved.PARAMS, true, true);
+        // Input map of variables passed to the script.
+        addVariable("[" + Reserved.PARAMS + "]", Definition.getType("Map"), Reserved.PARAMS, true, true);
 
         // Scorer parameter passed to the script.  Internal use only.
-        addVariable("[" + Reserved.SCORER + "]", "def", Reserved.SCORER, true, true);
+        addVariable("[" + Reserved.SCORER + "]", Definition.DEF_TYPE, Reserved.SCORER, true, true);
 
         // Doc parameter passed to the script. TODO: Currently working as a Map, we can do better?
-        addVariable("[" + Reserved.DOC + "]"   , "Map", Reserved.DOC   , true, true);
+        addVariable("[" + Reserved.DOC + "]", Definition.getType("Map"), Reserved.DOC, true, true);
 
         // Aggregation _value parameter passed to the script.
-        addVariable("[" + Reserved.VALUE + "]" , "def", Reserved.VALUE , true, true);
+        addVariable("[" + Reserved.VALUE + "]", Definition.DEF_TYPE, Reserved.VALUE, true, true);
 
         // Shortcut variables.
 
         // Document's score as a read-only double.
         if (reserved.score) {
-            addVariable("[" + Reserved.SCORE + "]", "double", Reserved.SCORE, true, true);
+            addVariable("[" + Reserved.SCORE + "]", Definition.DOUBLE_TYPE, Reserved.SCORE, true, true);
         }
 
         // The ctx map set by executable scripts as a read-only map.
         if (reserved.ctx) {
-            addVariable("[" + Reserved.CTX + "]", "Map", Reserved.CTX, true, true);
+            addVariable("[" + Reserved.CTX + "]", Definition.getType("Map"), Reserved.CTX, true, true);
         }
 
         // Loop counter to catch infinite loops.  Internal use only.
-        if (reserved.loop && settings.getMaxLoopCounter() > 0) {
-            addVariable("[" + Reserved.LOOP + "]", "int", Reserved.LOOP, true, true);
+        if (reserved.loop) {
+            addVariable("[" + Reserved.LOOP + "]", Definition.INT_TYPE, Reserved.LOOP, true, true);
         }
     }
 
@@ -139,7 +139,7 @@ public void decrementScope() {
         int remove = scopes.pop();
 
         while (remove > 0) {
-            final Variable variable = variables.pop();
+             Variable variable = variables.pop();
 
             if (variable.read) {
                 throw new IllegalArgumentException("Error [" + variable.location + "]: Variable [" + variable.name + "] never used.");
@@ -149,11 +149,11 @@ public void decrementScope() {
         }
     }
 
-    public Variable getVariable(final String location, final String name) {
-        final Iterator<Variable> itr = variables.iterator();
+    public Variable getVariable(String location, String name) {
+         Iterator<Variable> itr = variables.iterator();
 
         while (itr.hasNext()) {
-            final Variable variable = itr.next();
+             Variable variable = itr.next();
 
             if (variable.name.equals(name)) {
                 return variable;
@@ -167,8 +167,7 @@ public Variable getVariable(final String location, final String name) {
         return null;
     }
 
-    public Variable addVariable(final String location, final String typestr, final String name,
-                                final boolean readonly, final boolean reserved) {
+    public Variable addVariable(String location, Type type, String name, boolean readonly, boolean reserved) {
         if (!reserved && this.reserved.isReserved(name)) {
             throw new IllegalArgumentException("Error " + location + ": Variable name [" + name + "] is reserved.");
         }
@@ -177,38 +176,23 @@ public Variable addVariable(final String location, final String typestr, final S
             throw new IllegalArgumentException("Error " + location + ": Variable name [" + name + "] already defined.");
         }
 
-        final Type type;
-
-        try {
-            type = Definition.getType(typestr);
-        } catch (final IllegalArgumentException exception) {
-            throw new IllegalArgumentException("Error " + location + ": Not a type [" + typestr + "].");
-        }
-
-        boolean legal = !name.contains("<");
-
         try {
             Definition.getType(name);
-            legal = false;
-        } catch (final IllegalArgumentException exception) {
+        } catch (IllegalArgumentException exception) {
             // Do nothing.
         }
 
-        if (!legal) {
-            throw new IllegalArgumentException("Error " + location + ": Variable name [" + name + "] cannot be a type.");
-        }
-
-        final Variable previous = variables.peekFirst();
+        Variable previous = variables.peekFirst();
         int slot = 0;
 
         if (previous != null) {
             slot = previous.slot + previous.type.type.getSize();
         }
 
-        final Variable variable = new Variable(location, name, type, slot, readonly);
+        Variable variable = new Variable(location, name, type, slot, readonly);
         variables.push(variable);
 
-        final int update = scopes.pop() + 1;
+        int update = scopes.pop() + 1;
         scopes.push(update);
 
         return variable;
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessLexer.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessLexer.java
index 8cb9a6058683..b85217f94903 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessLexer.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessLexer.java
@@ -1,5 +1,8 @@
 // ANTLR GENERATED CODE: DO NOT EDIT
 package org.elasticsearch.painless.antlr;
+
+import org.elasticsearch.painless.Definition;
+
 import org.antlr.v4.runtime.Lexer;
 import org.antlr.v4.runtime.CharStream;
 import org.antlr.v4.runtime.Token;
@@ -25,10 +28,10 @@
     BWOR=44, BOOLAND=45, BOOLOR=46, COND=47, COLON=48, INCR=49, DECR=50, ASSIGN=51, 
     AADD=52, ASUB=53, AMUL=54, ADIV=55, AREM=56, AAND=57, AXOR=58, AOR=59, 
     ALSH=60, ARSH=61, AUSH=62, OCTAL=63, HEX=64, INTEGER=65, DECIMAL=66, STRING=67, 
-    TRUE=68, FALSE=69, NULL=70, ID=71, EXTINTEGER=72, EXTID=73;
-  public static final int EXT = 1;
+    TRUE=68, FALSE=69, NULL=70, TYPE=71, ID=72, DOTINTEGER=73, DOTID=74;
+  public static final int AFTER_DOT = 1;
   public static String[] modeNames = {
-    "DEFAULT_MODE", "EXT"
+    "DEFAULT_MODE", "AFTER_DOT"
   };
 
   public static final String[] ruleNames = {
@@ -39,8 +42,8 @@
     "GTE", "EQ", "EQR", "NE", "NER", "BWAND", "XOR", "BWOR", "BOOLAND", "BOOLOR", 
     "COND", "COLON", "INCR", "DECR", "ASSIGN", "AADD", "ASUB", "AMUL", "ADIV", 
     "AREM", "AAND", "AXOR", "AOR", "ALSH", "ARSH", "AUSH", "OCTAL", "HEX", 
-    "INTEGER", "DECIMAL", "STRING", "TRUE", "FALSE", "NULL", "ID", "EXTINTEGER", 
-    "EXTID"
+    "INTEGER", "DECIMAL", "STRING", "TRUE", "FALSE", "NULL", "TYPE", "ID", 
+    "DOTINTEGER", "DOTID"
   };
 
   private static final String[] _LITERAL_NAMES = {
@@ -61,8 +64,8 @@
     "GTE", "EQ", "EQR", "NE", "NER", "BWAND", "XOR", "BWOR", "BOOLAND", "BOOLOR", 
     "COND", "COLON", "INCR", "DECR", "ASSIGN", "AADD", "ASUB", "AMUL", "ADIV", 
     "AREM", "AAND", "AXOR", "AOR", "ALSH", "ARSH", "AUSH", "OCTAL", "HEX", 
-    "INTEGER", "DECIMAL", "STRING", "TRUE", "FALSE", "NULL", "ID", "EXTINTEGER", 
-    "EXTID"
+    "INTEGER", "DECIMAL", "STRING", "TRUE", "FALSE", "NULL", "TYPE", "ID", 
+    "DOTINTEGER", "DOTID"
   };
   public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);
 
@@ -118,8 +121,24 @@ public PainlessLexer(CharStream input) {
   @Override
   public ATN getATN() { return _ATN; }
 
+  @Override
+  public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
+    switch (ruleIndex) {
+    case 70:
+      return TYPE_sempred((RuleContext)_localctx, predIndex);
+    }
+    return true;
+  }
+  private boolean TYPE_sempred(RuleContext _localctx, int predIndex) {
+    switch (predIndex) {
+    case 0:
+      return  Definition.isSimpleType(getText()) ;
+    }
+    return true;
+  }
+
   public static final String _serializedATN =
-    "\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\2K\u01fb\b\1\b\1\4"+
+    "\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\2L\u0209\b\1\b\1\4"+
     "\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t\b\4\t\t\t\4\n\t\n"+
     "\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22"+
     "\t\22\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31"+
@@ -128,172 +147,178 @@ public PainlessLexer(CharStream input) {
     "+\4,\t,\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64"+
     "\t\64\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t;\4<\t<\4=\t"+
     "=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\tD\4E\tE\4F\tF\4G\tG\4H\tH\4"+
-    "I\tI\4J\tJ\3\2\6\2\u0098\n\2\r\2\16\2\u0099\3\2\3\2\3\3\3\3\3\3\3\3\7"+
-    "\3\u00a2\n\3\f\3\16\3\u00a5\13\3\3\3\3\3\3\3\3\3\3\3\7\3\u00ac\n\3\f\3"+
-    "\16\3\u00af\13\3\3\3\3\3\5\3\u00b3\n\3\3\3\3\3\3\4\3\4\3\5\3\5\3\6\3\6"+
-    "\3\7\3\7\3\b\3\b\3\t\3\t\3\n\3\n\3\n\3\n\3\13\3\13\3\f\3\f\3\r\3\r\3\r"+
-    "\3\16\3\16\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\17\3\17\3\20\3\20\3\20"+
-    "\3\21\3\21\3\21\3\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\23"+
-    "\3\23\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\25\3\25"+
-    "\3\25\3\25\3\26\3\26\3\26\3\26\3\27\3\27\3\27\3\27\3\27\3\27\3\30\3\30"+
-    "\3\30\3\30\3\30\3\30\3\31\3\31\3\32\3\32\3\33\3\33\3\34\3\34\3\35\3\35"+
-    "\3\36\3\36\3\37\3\37\3 \3 \3 \3!\3!\3!\3\"\3\"\3\"\3\"\3#\3#\3$\3$\3$"+
-    "\3%\3%\3&\3&\3&\3\'\3\'\3\'\3(\3(\3(\3(\3)\3)\3)\3*\3*\3*\3*\3+\3+\3,"+
-    "\3,\3-\3-\3.\3.\3.\3/\3/\3/\3\60\3\60\3\61\3\61\3\62\3\62\3\62\3\63\3"+
-    "\63\3\63\3\64\3\64\3\65\3\65\3\65\3\66\3\66\3\66\3\67\3\67\3\67\38\38"+
-    "\38\39\39\39\3:\3:\3:\3;\3;\3;\3<\3<\3<\3=\3=\3=\3=\3>\3>\3>\3>\3?\3?"+
-    "\3?\3?\3?\3@\3@\6@\u0179\n@\r@\16@\u017a\3@\5@\u017e\n@\3A\3A\3A\6A\u0183"+
-    "\nA\rA\16A\u0184\3A\5A\u0188\nA\3B\3B\3B\7B\u018d\nB\fB\16B\u0190\13B"+
-    "\5B\u0192\nB\3B\5B\u0195\nB\3C\3C\3C\7C\u019a\nC\fC\16C\u019d\13C\5C\u019f"+
-    "\nC\3C\3C\7C\u01a3\nC\fC\16C\u01a6\13C\3C\3C\5C\u01aa\nC\3C\6C\u01ad\n"+
-    "C\rC\16C\u01ae\5C\u01b1\nC\3C\5C\u01b4\nC\3D\3D\3D\3D\3D\3D\7D\u01bc\n"+
-    "D\fD\16D\u01bf\13D\3D\3D\3D\3D\3D\3D\3D\7D\u01c8\nD\fD\16D\u01cb\13D\3"+
-    "D\5D\u01ce\nD\3E\3E\3E\3E\3E\3F\3F\3F\3F\3F\3F\3G\3G\3G\3G\3G\3H\3H\7"+
-    "H\u01e2\nH\fH\16H\u01e5\13H\3I\3I\3I\7I\u01ea\nI\fI\16I\u01ed\13I\5I\u01ef"+
-    "\nI\3I\3I\3J\3J\7J\u01f5\nJ\fJ\16J\u01f8\13J\3J\3J\6\u00a3\u00ad\u01bd"+
-    "\u01c9\2K\4\3\6\4\b\5\n\6\f\7\16\b\20\t\22\n\24\13\26\f\30\r\32\16\34"+
-    "\17\36\20 \21\"\22$\23&\24(\25*\26,\27.\30\60\31\62\32\64\33\66\348\35"+
-    ":\36<\37> @!B\"D#F$H%J&L\'N(P)R*T+V,X-Z.\\/^\60`\61b\62d\63f\64h\65j\66"+
-    "l\67n8p9r:t;v<x=z>|?~@\u0080A\u0082B\u0084C\u0086D\u0088E\u008aF\u008c"+
-    "G\u008eH\u0090I\u0092J\u0094K\4\2\3\21\5\2\13\f\17\17\"\"\4\2\f\f\17\17"+
-    "\3\2\629\4\2NNnn\4\2ZZzz\5\2\62;CHch\3\2\63;\3\2\62;\b\2FFHHNNffhhnn\4"+
-    "\2GGgg\4\2--//\4\2HHhh\4\2$$^^\5\2C\\aac|\6\2\62;C\\aac|\u0216\2\4\3\2"+
-    "\2\2\2\6\3\2\2\2\2\b\3\2\2\2\2\n\3\2\2\2\2\f\3\2\2\2\2\16\3\2\2\2\2\20"+
-    "\3\2\2\2\2\22\3\2\2\2\2\24\3\2\2\2\2\26\3\2\2\2\2\30\3\2\2\2\2\32\3\2"+
-    "\2\2\2\34\3\2\2\2\2\36\3\2\2\2\2 \3\2\2\2\2\"\3\2\2\2\2$\3\2\2\2\2&\3"+
-    "\2\2\2\2(\3\2\2\2\2*\3\2\2\2\2,\3\2\2\2\2.\3\2\2\2\2\60\3\2\2\2\2\62\3"+
-    "\2\2\2\2\64\3\2\2\2\2\66\3\2\2\2\28\3\2\2\2\2:\3\2\2\2\2<\3\2\2\2\2>\3"+
-    "\2\2\2\2@\3\2\2\2\2B\3\2\2\2\2D\3\2\2\2\2F\3\2\2\2\2H\3\2\2\2\2J\3\2\2"+
-    "\2\2L\3\2\2\2\2N\3\2\2\2\2P\3\2\2\2\2R\3\2\2\2\2T\3\2\2\2\2V\3\2\2\2\2"+
-    "X\3\2\2\2\2Z\3\2\2\2\2\\\3\2\2\2\2^\3\2\2\2\2`\3\2\2\2\2b\3\2\2\2\2d\3"+
-    "\2\2\2\2f\3\2\2\2\2h\3\2\2\2\2j\3\2\2\2\2l\3\2\2\2\2n\3\2\2\2\2p\3\2\2"+
-    "\2\2r\3\2\2\2\2t\3\2\2\2\2v\3\2\2\2\2x\3\2\2\2\2z\3\2\2\2\2|\3\2\2\2\2"+
-    "~\3\2\2\2\2\u0080\3\2\2\2\2\u0082\3\2\2\2\2\u0084\3\2\2\2\2\u0086\3\2"+
-    "\2\2\2\u0088\3\2\2\2\2\u008a\3\2\2\2\2\u008c\3\2\2\2\2\u008e\3\2\2\2\2"+
-    "\u0090\3\2\2\2\3\u0092\3\2\2\2\3\u0094\3\2\2\2\4\u0097\3\2\2\2\6\u00b2"+
-    "\3\2\2\2\b\u00b6\3\2\2\2\n\u00b8\3\2\2\2\f\u00ba\3\2\2\2\16\u00bc\3\2"+
-    "\2\2\20\u00be\3\2\2\2\22\u00c0\3\2\2\2\24\u00c2\3\2\2\2\26\u00c6\3\2\2"+
-    "\2\30\u00c8\3\2\2\2\32\u00ca\3\2\2\2\34\u00cd\3\2\2\2\36\u00d2\3\2\2\2"+
-    " \u00d8\3\2\2\2\"\u00db\3\2\2\2$\u00df\3\2\2\2&\u00e8\3\2\2\2(\u00ee\3"+
-    "\2\2\2*\u00f5\3\2\2\2,\u00f9\3\2\2\2.\u00fd\3\2\2\2\60\u0103\3\2\2\2\62"+
-    "\u0109\3\2\2\2\64\u010b\3\2\2\2\66\u010d\3\2\2\28\u010f\3\2\2\2:\u0111"+
-    "\3\2\2\2<\u0113\3\2\2\2>\u0115\3\2\2\2@\u0117\3\2\2\2B\u011a\3\2\2\2D"+
-    "\u011d\3\2\2\2F\u0121\3\2\2\2H\u0123\3\2\2\2J\u0126\3\2\2\2L\u0128\3\2"+
-    "\2\2N\u012b\3\2\2\2P\u012e\3\2\2\2R\u0132\3\2\2\2T\u0135\3\2\2\2V\u0139"+
-    "\3\2\2\2X\u013b\3\2\2\2Z\u013d\3\2\2\2\\\u013f\3\2\2\2^\u0142\3\2\2\2"+
-    "`\u0145\3\2\2\2b\u0147\3\2\2\2d\u0149\3\2\2\2f\u014c\3\2\2\2h\u014f\3"+
-    "\2\2\2j\u0151\3\2\2\2l\u0154\3\2\2\2n\u0157\3\2\2\2p\u015a\3\2\2\2r\u015d"+
-    "\3\2\2\2t\u0160\3\2\2\2v\u0163\3\2\2\2x\u0166\3\2\2\2z\u0169\3\2\2\2|"+
-    "\u016d\3\2\2\2~\u0171\3\2\2\2\u0080\u0176\3\2\2\2\u0082\u017f\3\2\2\2"+
-    "\u0084\u0191\3\2\2\2\u0086\u019e\3\2\2\2\u0088\u01cd\3\2\2\2\u008a\u01cf"+
-    "\3\2\2\2\u008c\u01d4\3\2\2\2\u008e\u01da\3\2\2\2\u0090\u01df\3\2\2\2\u0092"+
-    "\u01ee\3\2\2\2\u0094\u01f2\3\2\2\2\u0096\u0098\t\2\2\2\u0097\u0096\3\2"+
-    "\2\2\u0098\u0099\3\2\2\2\u0099\u0097\3\2\2\2\u0099\u009a\3\2\2\2\u009a"+
-    "\u009b\3\2\2\2\u009b\u009c\b\2\2\2\u009c\5\3\2\2\2\u009d\u009e\7\61\2"+
-    "\2\u009e\u009f\7\61\2\2\u009f\u00a3\3\2\2\2\u00a0\u00a2\13\2\2\2\u00a1"+
-    "\u00a0\3\2\2\2\u00a2\u00a5\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a3\u00a1\3\2"+
-    "\2\2\u00a4\u00a6\3\2\2\2\u00a5\u00a3\3\2\2\2\u00a6\u00b3\t\3\2\2\u00a7"+
-    "\u00a8\7\61\2\2\u00a8\u00a9\7,\2\2\u00a9\u00ad\3\2\2\2\u00aa\u00ac\13"+
-    "\2\2\2\u00ab\u00aa\3\2\2\2\u00ac\u00af\3\2\2\2\u00ad\u00ae\3\2\2\2\u00ad"+
-    "\u00ab\3\2\2\2\u00ae\u00b0\3\2\2\2\u00af\u00ad\3\2\2\2\u00b0\u00b1\7,"+
-    "\2\2\u00b1\u00b3\7\61\2\2\u00b2\u009d\3\2\2\2\u00b2\u00a7\3\2\2\2\u00b3"+
-    "\u00b4\3\2\2\2\u00b4\u00b5\b\3\2\2\u00b5\7\3\2\2\2\u00b6\u00b7\7}\2\2"+
-    "\u00b7\t\3\2\2\2\u00b8\u00b9\7\177\2\2\u00b9\13\3\2\2\2\u00ba\u00bb\7"+
-    "]\2\2\u00bb\r\3\2\2\2\u00bc\u00bd\7_\2\2\u00bd\17\3\2\2\2\u00be\u00bf"+
-    "\7*\2\2\u00bf\21\3\2\2\2\u00c0\u00c1\7+\2\2\u00c1\23\3\2\2\2\u00c2\u00c3"+
-    "\7\60\2\2\u00c3\u00c4\3\2\2\2\u00c4\u00c5\b\n\3\2\u00c5\25\3\2\2\2\u00c6"+
-    "\u00c7\7.\2\2\u00c7\27\3\2\2\2\u00c8\u00c9\7=\2\2\u00c9\31\3\2\2\2\u00ca"+
-    "\u00cb\7k\2\2\u00cb\u00cc\7h\2\2\u00cc\33\3\2\2\2\u00cd\u00ce\7g\2\2\u00ce"+
-    "\u00cf\7n\2\2\u00cf\u00d0\7u\2\2\u00d0\u00d1\7g\2\2\u00d1\35\3\2\2\2\u00d2"+
-    "\u00d3\7y\2\2\u00d3\u00d4\7j\2\2\u00d4\u00d5\7k\2\2\u00d5\u00d6\7n\2\2"+
-    "\u00d6\u00d7\7g\2\2\u00d7\37\3\2\2\2\u00d8\u00d9\7f\2\2\u00d9\u00da\7"+
-    "q\2\2\u00da!\3\2\2\2\u00db\u00dc\7h\2\2\u00dc\u00dd\7q\2\2\u00dd\u00de"+
-    "\7t\2\2\u00de#\3\2\2\2\u00df\u00e0\7e\2\2\u00e0\u00e1\7q\2\2\u00e1\u00e2"+
-    "\7p\2\2\u00e2\u00e3\7v\2\2\u00e3\u00e4\7k\2\2\u00e4\u00e5\7p\2\2\u00e5"+
-    "\u00e6\7w\2\2\u00e6\u00e7\7g\2\2\u00e7%\3\2\2\2\u00e8\u00e9\7d\2\2\u00e9"+
-    "\u00ea\7t\2\2\u00ea\u00eb\7g\2\2\u00eb\u00ec\7c\2\2\u00ec\u00ed\7m\2\2"+
-    "\u00ed\'\3\2\2\2\u00ee\u00ef\7t\2\2\u00ef\u00f0\7g\2\2\u00f0\u00f1\7v"+
-    "\2\2\u00f1\u00f2\7w\2\2\u00f2\u00f3\7t\2\2\u00f3\u00f4\7p\2\2\u00f4)\3"+
-    "\2\2\2\u00f5\u00f6\7p\2\2\u00f6\u00f7\7g\2\2\u00f7\u00f8\7y\2\2\u00f8"+
-    "+\3\2\2\2\u00f9\u00fa\7v\2\2\u00fa\u00fb\7t\2\2\u00fb\u00fc\7{\2\2\u00fc"+
-    "-\3\2\2\2\u00fd\u00fe\7e\2\2\u00fe\u00ff\7c\2\2\u00ff\u0100\7v\2\2\u0100"+
-    "\u0101\7e\2\2\u0101\u0102\7j\2\2\u0102/\3\2\2\2\u0103\u0104\7v\2\2\u0104"+
-    "\u0105\7j\2\2\u0105\u0106\7t\2\2\u0106\u0107\7q\2\2\u0107\u0108\7y\2\2"+
-    "\u0108\61\3\2\2\2\u0109\u010a\7#\2\2\u010a\63\3\2\2\2\u010b\u010c\7\u0080"+
-    "\2\2\u010c\65\3\2\2\2\u010d\u010e\7,\2\2\u010e\67\3\2\2\2\u010f\u0110"+
-    "\7\61\2\2\u01109\3\2\2\2\u0111\u0112\7\'\2\2\u0112;\3\2\2\2\u0113\u0114"+
-    "\7-\2\2\u0114=\3\2\2\2\u0115\u0116\7/\2\2\u0116?\3\2\2\2\u0117\u0118\7"+
-    ">\2\2\u0118\u0119\7>\2\2\u0119A\3\2\2\2\u011a\u011b\7@\2\2\u011b\u011c"+
-    "\7@\2\2\u011cC\3\2\2\2\u011d\u011e\7@\2\2\u011e\u011f\7@\2\2\u011f\u0120"+
-    "\7@\2\2\u0120E\3\2\2\2\u0121\u0122\7>\2\2\u0122G\3\2\2\2\u0123\u0124\7"+
-    ">\2\2\u0124\u0125\7?\2\2\u0125I\3\2\2\2\u0126\u0127\7@\2\2\u0127K\3\2"+
-    "\2\2\u0128\u0129\7@\2\2\u0129\u012a\7?\2\2\u012aM\3\2\2\2\u012b\u012c"+
-    "\7?\2\2\u012c\u012d\7?\2\2\u012dO\3\2\2\2\u012e\u012f\7?\2\2\u012f\u0130"+
-    "\7?\2\2\u0130\u0131\7?\2\2\u0131Q\3\2\2\2\u0132\u0133\7#\2\2\u0133\u0134"+
-    "\7?\2\2\u0134S\3\2\2\2\u0135\u0136\7#\2\2\u0136\u0137\7?\2\2\u0137\u0138"+
-    "\7?\2\2\u0138U\3\2\2\2\u0139\u013a\7(\2\2\u013aW\3\2\2\2\u013b\u013c\7"+
-    "`\2\2\u013cY\3\2\2\2\u013d\u013e\7~\2\2\u013e[\3\2\2\2\u013f\u0140\7("+
-    "\2\2\u0140\u0141\7(\2\2\u0141]\3\2\2\2\u0142\u0143\7~\2\2\u0143\u0144"+
-    "\7~\2\2\u0144_\3\2\2\2\u0145\u0146\7A\2\2\u0146a\3\2\2\2\u0147\u0148\7"+
-    "<\2\2\u0148c\3\2\2\2\u0149\u014a\7-\2\2\u014a\u014b\7-\2\2\u014be\3\2"+
-    "\2\2\u014c\u014d\7/\2\2\u014d\u014e\7/\2\2\u014eg\3\2\2\2\u014f\u0150"+
-    "\7?\2\2\u0150i\3\2\2\2\u0151\u0152\7-\2\2\u0152\u0153\7?\2\2\u0153k\3"+
-    "\2\2\2\u0154\u0155\7/\2\2\u0155\u0156\7?\2\2\u0156m\3\2\2\2\u0157\u0158"+
-    "\7,\2\2\u0158\u0159\7?\2\2\u0159o\3\2\2\2\u015a\u015b\7\61\2\2\u015b\u015c"+
-    "\7?\2\2\u015cq\3\2\2\2\u015d\u015e\7\'\2\2\u015e\u015f\7?\2\2\u015fs\3"+
-    "\2\2\2\u0160\u0161\7(\2\2\u0161\u0162\7?\2\2\u0162u\3\2\2\2\u0163\u0164"+
-    "\7`\2\2\u0164\u0165\7?\2\2\u0165w\3\2\2\2\u0166\u0167\7~\2\2\u0167\u0168"+
-    "\7?\2\2\u0168y\3\2\2\2\u0169\u016a\7>\2\2\u016a\u016b\7>\2\2\u016b\u016c"+
-    "\7?\2\2\u016c{\3\2\2\2\u016d\u016e\7@\2\2\u016e\u016f\7@\2\2\u016f\u0170"+
-    "\7?\2\2\u0170}\3\2\2\2\u0171\u0172\7@\2\2\u0172\u0173\7@\2\2\u0173\u0174"+
-    "\7@\2\2\u0174\u0175\7?\2\2\u0175\177\3\2\2\2\u0176\u0178\7\62\2\2\u0177"+
-    "\u0179\t\4\2\2\u0178\u0177\3\2\2\2\u0179\u017a\3\2\2\2\u017a\u0178\3\2"+
-    "\2\2\u017a\u017b\3\2\2\2\u017b\u017d\3\2\2\2\u017c\u017e\t\5\2\2\u017d"+
-    "\u017c\3\2\2\2\u017d\u017e\3\2\2\2\u017e\u0081\3\2\2\2\u017f\u0180\7\62"+
-    "\2\2\u0180\u0182\t\6\2\2\u0181\u0183\t\7\2\2\u0182\u0181\3\2\2\2\u0183"+
-    "\u0184\3\2\2\2\u0184\u0182\3\2\2\2\u0184\u0185\3\2\2\2\u0185\u0187\3\2"+
-    "\2\2\u0186\u0188\t\5\2\2\u0187\u0186\3\2\2\2\u0187\u0188\3\2\2\2\u0188"+
-    "\u0083\3\2\2\2\u0189\u0192\7\62\2\2\u018a\u018e\t\b\2\2\u018b\u018d\t"+
-    "\t\2\2\u018c\u018b\3\2\2\2\u018d\u0190\3\2\2\2\u018e\u018c\3\2\2\2\u018e"+
-    "\u018f\3\2\2\2\u018f\u0192\3\2\2\2\u0190\u018e\3\2\2\2\u0191\u0189\3\2"+
-    "\2\2\u0191\u018a\3\2\2\2\u0192\u0194\3\2\2\2\u0193\u0195\t\n\2\2\u0194"+
-    "\u0193\3\2\2\2\u0194\u0195\3\2\2\2\u0195\u0085\3\2\2\2\u0196\u019f\7\62"+
-    "\2\2\u0197\u019b\t\b\2\2\u0198\u019a\t\t\2\2\u0199\u0198\3\2\2\2\u019a"+
-    "\u019d\3\2\2\2\u019b\u0199\3\2\2\2\u019b\u019c\3\2\2\2\u019c\u019f\3\2"+
-    "\2\2\u019d\u019b\3\2\2\2\u019e\u0196\3\2\2\2\u019e\u0197\3\2\2\2\u019f"+
-    "\u01a0\3\2\2\2\u01a0\u01a4\5\24\n\2\u01a1\u01a3\t\t\2\2\u01a2\u01a1\3"+
-    "\2\2\2\u01a3\u01a6\3\2\2\2\u01a4\u01a2\3\2\2\2\u01a4\u01a5\3\2\2\2\u01a5"+
-    "\u01b0\3\2\2\2\u01a6\u01a4\3\2\2\2\u01a7\u01a9\t\13\2\2\u01a8\u01aa\t"+
-    "\f\2\2\u01a9\u01a8\3\2\2\2\u01a9\u01aa\3\2\2\2\u01aa\u01ac\3\2\2\2\u01ab"+
-    "\u01ad\t\t\2\2\u01ac\u01ab\3\2\2\2\u01ad\u01ae\3\2\2\2\u01ae\u01ac\3\2"+
-    "\2\2\u01ae\u01af\3\2\2\2\u01af\u01b1\3\2\2\2\u01b0\u01a7\3\2\2\2\u01b0"+
-    "\u01b1\3\2\2\2\u01b1\u01b3\3\2\2\2\u01b2\u01b4\t\r\2\2\u01b3\u01b2\3\2"+
-    "\2\2\u01b3\u01b4\3\2\2\2\u01b4\u0087\3\2\2\2\u01b5\u01bd\7$\2\2\u01b6"+
-    "\u01b7\7^\2\2\u01b7\u01bc\7$\2\2\u01b8\u01b9\7^\2\2\u01b9\u01bc\7^\2\2"+
-    "\u01ba\u01bc\n\16\2\2\u01bb\u01b6\3\2\2\2\u01bb\u01b8\3\2\2\2\u01bb\u01ba"+
-    "\3\2\2\2\u01bc\u01bf\3\2\2\2\u01bd\u01be\3\2\2\2\u01bd\u01bb\3\2\2\2\u01be"+
-    "\u01c0\3\2\2\2\u01bf\u01bd\3\2\2\2\u01c0\u01ce\7$\2\2\u01c1\u01c9\7)\2"+
-    "\2\u01c2\u01c3\7^\2\2\u01c3\u01c8\7)\2\2\u01c4\u01c5\7^\2\2\u01c5\u01c8"+
-    "\7^\2\2\u01c6\u01c8\n\16\2\2\u01c7\u01c2\3\2\2\2\u01c7\u01c4\3\2\2\2\u01c7"+
-    "\u01c6\3\2\2\2\u01c8\u01cb\3\2\2\2\u01c9\u01ca\3\2\2\2\u01c9\u01c7\3\2"+
-    "\2\2\u01ca\u01cc\3\2\2\2\u01cb\u01c9\3\2\2\2\u01cc\u01ce\7)\2\2\u01cd"+
-    "\u01b5\3\2\2\2\u01cd\u01c1\3\2\2\2\u01ce\u0089\3\2\2\2\u01cf\u01d0\7v"+
-    "\2\2\u01d0\u01d1\7t\2\2\u01d1\u01d2\7w\2\2\u01d2\u01d3\7g\2\2\u01d3\u008b"+
-    "\3\2\2\2\u01d4\u01d5\7h\2\2\u01d5\u01d6\7c\2\2\u01d6\u01d7\7n\2\2\u01d7"+
-    "\u01d8\7u\2\2\u01d8\u01d9\7g\2\2\u01d9\u008d\3\2\2\2\u01da\u01db\7p\2"+
-    "\2\u01db\u01dc\7w\2\2\u01dc\u01dd\7n\2\2\u01dd\u01de\7n\2\2\u01de\u008f"+
-    "\3\2\2\2\u01df\u01e3\t\17\2\2\u01e0\u01e2\t\20\2\2\u01e1\u01e0\3\2\2\2"+
-    "\u01e2\u01e5\3\2\2\2\u01e3\u01e1\3\2\2\2\u01e3\u01e4\3\2\2\2\u01e4\u0091"+
-    "\3\2\2\2\u01e5\u01e3\3\2\2\2\u01e6\u01ef\7\62\2\2\u01e7\u01eb\t\b\2\2"+
-    "\u01e8\u01ea\t\t\2\2\u01e9\u01e8\3\2\2\2\u01ea\u01ed\3\2\2\2\u01eb\u01e9"+
-    "\3\2\2\2\u01eb\u01ec\3\2\2\2\u01ec\u01ef\3\2\2\2\u01ed\u01eb\3\2\2\2\u01ee"+
-    "\u01e6\3\2\2\2\u01ee\u01e7\3\2\2\2\u01ef\u01f0\3\2\2\2\u01f0\u01f1\bI"+
-    "\4\2\u01f1\u0093\3\2\2\2\u01f2\u01f6\t\17\2\2\u01f3\u01f5\t\20\2\2\u01f4"+
-    "\u01f3\3\2\2\2\u01f5\u01f8\3\2\2\2\u01f6\u01f4\3\2\2\2\u01f6\u01f7\3\2"+
-    "\2\2\u01f7\u01f9\3\2\2\2\u01f8\u01f6\3\2\2\2\u01f9\u01fa\bJ\4\2\u01fa"+
-    "\u0095\3\2\2\2\37\2\3\u0099\u00a3\u00ad\u00b2\u017a\u017d\u0184\u0187"+
-    "\u018e\u0191\u0194\u019b\u019e\u01a4\u01a9\u01ae\u01b0\u01b3\u01bb\u01bd"+
-    "\u01c7\u01c9\u01cd\u01e3\u01eb\u01ee\u01f6\5\b\2\2\4\3\2\4\2\2";
+    "I\tI\4J\tJ\4K\tK\3\2\6\2\u009a\n\2\r\2\16\2\u009b\3\2\3\2\3\3\3\3\3\3"+
+    "\3\3\7\3\u00a4\n\3\f\3\16\3\u00a7\13\3\3\3\3\3\3\3\3\3\3\3\7\3\u00ae\n"+
+    "\3\f\3\16\3\u00b1\13\3\3\3\3\3\5\3\u00b5\n\3\3\3\3\3\3\4\3\4\3\5\3\5\3"+
+    "\6\3\6\3\7\3\7\3\b\3\b\3\t\3\t\3\n\3\n\3\n\3\n\3\13\3\13\3\f\3\f\3\r\3"+
+    "\r\3\r\3\16\3\16\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\17\3\17\3\20\3\20"+
+    "\3\20\3\21\3\21\3\21\3\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22"+
+    "\3\23\3\23\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\25"+
+    "\3\25\3\25\3\25\3\26\3\26\3\26\3\26\3\27\3\27\3\27\3\27\3\27\3\27\3\30"+
+    "\3\30\3\30\3\30\3\30\3\30\3\31\3\31\3\32\3\32\3\33\3\33\3\34\3\34\3\35"+
+    "\3\35\3\36\3\36\3\37\3\37\3 \3 \3 \3!\3!\3!\3\"\3\"\3\"\3\"\3#\3#\3$\3"+
+    "$\3$\3%\3%\3&\3&\3&\3\'\3\'\3\'\3(\3(\3(\3(\3)\3)\3)\3*\3*\3*\3*\3+\3"+
+    "+\3,\3,\3-\3-\3.\3.\3.\3/\3/\3/\3\60\3\60\3\61\3\61\3\62\3\62\3\62\3\63"+
+    "\3\63\3\63\3\64\3\64\3\65\3\65\3\65\3\66\3\66\3\66\3\67\3\67\3\67\38\3"+
+    "8\38\39\39\39\3:\3:\3:\3;\3;\3;\3<\3<\3<\3=\3=\3=\3=\3>\3>\3>\3>\3?\3"+
+    "?\3?\3?\3?\3@\3@\6@\u017b\n@\r@\16@\u017c\3@\5@\u0180\n@\3A\3A\3A\6A\u0185"+
+    "\nA\rA\16A\u0186\3A\5A\u018a\nA\3B\3B\3B\7B\u018f\nB\fB\16B\u0192\13B"+
+    "\5B\u0194\nB\3B\5B\u0197\nB\3C\3C\3C\7C\u019c\nC\fC\16C\u019f\13C\5C\u01a1"+
+    "\nC\3C\3C\6C\u01a5\nC\rC\16C\u01a6\5C\u01a9\nC\3C\3C\5C\u01ad\nC\3C\6"+
+    "C\u01b0\nC\rC\16C\u01b1\5C\u01b4\nC\3C\5C\u01b7\nC\3D\3D\3D\3D\3D\3D\7"+
+    "D\u01bf\nD\fD\16D\u01c2\13D\3D\3D\3D\3D\3D\3D\3D\7D\u01cb\nD\fD\16D\u01ce"+
+    "\13D\3D\5D\u01d1\nD\3E\3E\3E\3E\3E\3F\3F\3F\3F\3F\3F\3G\3G\3G\3G\3G\3"+
+    "H\3H\3H\3H\7H\u01e7\nH\fH\16H\u01ea\13H\3H\3H\3I\3I\7I\u01f0\nI\fI\16"+
+    "I\u01f3\13I\3J\3J\3J\7J\u01f8\nJ\fJ\16J\u01fb\13J\5J\u01fd\nJ\3J\3J\3"+
+    "K\3K\7K\u0203\nK\fK\16K\u0206\13K\3K\3K\6\u00a5\u00af\u01c0\u01cc\2L\4"+
+    "\3\6\4\b\5\n\6\f\7\16\b\20\t\22\n\24\13\26\f\30\r\32\16\34\17\36\20 \21"+
+    "\"\22$\23&\24(\25*\26,\27.\30\60\31\62\32\64\33\66\348\35:\36<\37> @!"+
+    "B\"D#F$H%J&L\'N(P)R*T+V,X-Z.\\/^\60`\61b\62d\63f\64h\65j\66l\67n8p9r:"+
+    "t;v<x=z>|?~@\u0080A\u0082B\u0084C\u0086D\u0088E\u008aF\u008cG\u008eH\u0090"+
+    "I\u0092J\u0094K\u0096L\4\2\3\22\5\2\13\f\17\17\"\"\4\2\f\f\17\17\3\2\62"+
+    "9\4\2NNnn\4\2ZZzz\5\2\62;CHch\3\2\63;\3\2\62;\b\2FFHHNNffhhnn\4\2GGgg"+
+    "\4\2--//\4\2HHhh\4\2$$^^\5\2C\\aac|\6\2\62;C\\aac|\4\2aac|\u0226\2\4\3"+
+    "\2\2\2\2\6\3\2\2\2\2\b\3\2\2\2\2\n\3\2\2\2\2\f\3\2\2\2\2\16\3\2\2\2\2"+
+    "\20\3\2\2\2\2\22\3\2\2\2\2\24\3\2\2\2\2\26\3\2\2\2\2\30\3\2\2\2\2\32\3"+
+    "\2\2\2\2\34\3\2\2\2\2\36\3\2\2\2\2 \3\2\2\2\2\"\3\2\2\2\2$\3\2\2\2\2&"+
+    "\3\2\2\2\2(\3\2\2\2\2*\3\2\2\2\2,\3\2\2\2\2.\3\2\2\2\2\60\3\2\2\2\2\62"+
+    "\3\2\2\2\2\64\3\2\2\2\2\66\3\2\2\2\28\3\2\2\2\2:\3\2\2\2\2<\3\2\2\2\2"+
+    ">\3\2\2\2\2@\3\2\2\2\2B\3\2\2\2\2D\3\2\2\2\2F\3\2\2\2\2H\3\2\2\2\2J\3"+
+    "\2\2\2\2L\3\2\2\2\2N\3\2\2\2\2P\3\2\2\2\2R\3\2\2\2\2T\3\2\2\2\2V\3\2\2"+
+    "\2\2X\3\2\2\2\2Z\3\2\2\2\2\\\3\2\2\2\2^\3\2\2\2\2`\3\2\2\2\2b\3\2\2\2"+
+    "\2d\3\2\2\2\2f\3\2\2\2\2h\3\2\2\2\2j\3\2\2\2\2l\3\2\2\2\2n\3\2\2\2\2p"+
+    "\3\2\2\2\2r\3\2\2\2\2t\3\2\2\2\2v\3\2\2\2\2x\3\2\2\2\2z\3\2\2\2\2|\3\2"+
+    "\2\2\2~\3\2\2\2\2\u0080\3\2\2\2\2\u0082\3\2\2\2\2\u0084\3\2\2\2\2\u0086"+
+    "\3\2\2\2\2\u0088\3\2\2\2\2\u008a\3\2\2\2\2\u008c\3\2\2\2\2\u008e\3\2\2"+
+    "\2\2\u0090\3\2\2\2\2\u0092\3\2\2\2\3\u0094\3\2\2\2\3\u0096\3\2\2\2\4\u0099"+
+    "\3\2\2\2\6\u00b4\3\2\2\2\b\u00b8\3\2\2\2\n\u00ba\3\2\2\2\f\u00bc\3\2\2"+
+    "\2\16\u00be\3\2\2\2\20\u00c0\3\2\2\2\22\u00c2\3\2\2\2\24\u00c4\3\2\2\2"+
+    "\26\u00c8\3\2\2\2\30\u00ca\3\2\2\2\32\u00cc\3\2\2\2\34\u00cf\3\2\2\2\36"+
+    "\u00d4\3\2\2\2 \u00da\3\2\2\2\"\u00dd\3\2\2\2$\u00e1\3\2\2\2&\u00ea\3"+
+    "\2\2\2(\u00f0\3\2\2\2*\u00f7\3\2\2\2,\u00fb\3\2\2\2.\u00ff\3\2\2\2\60"+
+    "\u0105\3\2\2\2\62\u010b\3\2\2\2\64\u010d\3\2\2\2\66\u010f\3\2\2\28\u0111"+
+    "\3\2\2\2:\u0113\3\2\2\2<\u0115\3\2\2\2>\u0117\3\2\2\2@\u0119\3\2\2\2B"+
+    "\u011c\3\2\2\2D\u011f\3\2\2\2F\u0123\3\2\2\2H\u0125\3\2\2\2J\u0128\3\2"+
+    "\2\2L\u012a\3\2\2\2N\u012d\3\2\2\2P\u0130\3\2\2\2R\u0134\3\2\2\2T\u0137"+
+    "\3\2\2\2V\u013b\3\2\2\2X\u013d\3\2\2\2Z\u013f\3\2\2\2\\\u0141\3\2\2\2"+
+    "^\u0144\3\2\2\2`\u0147\3\2\2\2b\u0149\3\2\2\2d\u014b\3\2\2\2f\u014e\3"+
+    "\2\2\2h\u0151\3\2\2\2j\u0153\3\2\2\2l\u0156\3\2\2\2n\u0159\3\2\2\2p\u015c"+
+    "\3\2\2\2r\u015f\3\2\2\2t\u0162\3\2\2\2v\u0165\3\2\2\2x\u0168\3\2\2\2z"+
+    "\u016b\3\2\2\2|\u016f\3\2\2\2~\u0173\3\2\2\2\u0080\u0178\3\2\2\2\u0082"+
+    "\u0181\3\2\2\2\u0084\u0193\3\2\2\2\u0086\u01a0\3\2\2\2\u0088\u01d0\3\2"+
+    "\2\2\u008a\u01d2\3\2\2\2\u008c\u01d7\3\2\2\2\u008e\u01dd\3\2\2\2\u0090"+
+    "\u01e2\3\2\2\2\u0092\u01ed\3\2\2\2\u0094\u01fc\3\2\2\2\u0096\u0200\3\2"+
+    "\2\2\u0098\u009a\t\2\2\2\u0099\u0098\3\2\2\2\u009a\u009b\3\2\2\2\u009b"+
+    "\u0099\3\2\2\2\u009b\u009c\3\2\2\2\u009c\u009d\3\2\2\2\u009d\u009e\b\2"+
+    "\2\2\u009e\5\3\2\2\2\u009f\u00a0\7\61\2\2\u00a0\u00a1\7\61\2\2\u00a1\u00a5"+
+    "\3\2\2\2\u00a2\u00a4\13\2\2\2\u00a3\u00a2\3\2\2\2\u00a4\u00a7\3\2\2\2"+
+    "\u00a5\u00a6\3\2\2\2\u00a5\u00a3\3\2\2\2\u00a6\u00a8\3\2\2\2\u00a7\u00a5"+
+    "\3\2\2\2\u00a8\u00b5\t\3\2\2\u00a9\u00aa\7\61\2\2\u00aa\u00ab\7,\2\2\u00ab"+
+    "\u00af\3\2\2\2\u00ac\u00ae\13\2\2\2\u00ad\u00ac\3\2\2\2\u00ae\u00b1\3"+
+    "\2\2\2\u00af\u00b0\3\2\2\2\u00af\u00ad\3\2\2\2\u00b0\u00b2\3\2\2\2\u00b1"+
+    "\u00af\3\2\2\2\u00b2\u00b3\7,\2\2\u00b3\u00b5\7\61\2\2\u00b4\u009f\3\2"+
+    "\2\2\u00b4\u00a9\3\2\2\2\u00b5\u00b6\3\2\2\2\u00b6\u00b7\b\3\2\2\u00b7"+
+    "\7\3\2\2\2\u00b8\u00b9\7}\2\2\u00b9\t\3\2\2\2\u00ba\u00bb\7\177\2\2\u00bb"+
+    "\13\3\2\2\2\u00bc\u00bd\7]\2\2\u00bd\r\3\2\2\2\u00be\u00bf\7_\2\2\u00bf"+
+    "\17\3\2\2\2\u00c0\u00c1\7*\2\2\u00c1\21\3\2\2\2\u00c2\u00c3\7+\2\2\u00c3"+
+    "\23\3\2\2\2\u00c4\u00c5\7\60\2\2\u00c5\u00c6\3\2\2\2\u00c6\u00c7\b\n\3"+
+    "\2\u00c7\25\3\2\2\2\u00c8\u00c9\7.\2\2\u00c9\27\3\2\2\2\u00ca\u00cb\7"+
+    "=\2\2\u00cb\31\3\2\2\2\u00cc\u00cd\7k\2\2\u00cd\u00ce\7h\2\2\u00ce\33"+
+    "\3\2\2\2\u00cf\u00d0\7g\2\2\u00d0\u00d1\7n\2\2\u00d1\u00d2\7u\2\2\u00d2"+
+    "\u00d3\7g\2\2\u00d3\35\3\2\2\2\u00d4\u00d5\7y\2\2\u00d5\u00d6\7j\2\2\u00d6"+
+    "\u00d7\7k\2\2\u00d7\u00d8\7n\2\2\u00d8\u00d9\7g\2\2\u00d9\37\3\2\2\2\u00da"+
+    "\u00db\7f\2\2\u00db\u00dc\7q\2\2\u00dc!\3\2\2\2\u00dd\u00de\7h\2\2\u00de"+
+    "\u00df\7q\2\2\u00df\u00e0\7t\2\2\u00e0#\3\2\2\2\u00e1\u00e2\7e\2\2\u00e2"+
+    "\u00e3\7q\2\2\u00e3\u00e4\7p\2\2\u00e4\u00e5\7v\2\2\u00e5\u00e6\7k\2\2"+
+    "\u00e6\u00e7\7p\2\2\u00e7\u00e8\7w\2\2\u00e8\u00e9\7g\2\2\u00e9%\3\2\2"+
+    "\2\u00ea\u00eb\7d\2\2\u00eb\u00ec\7t\2\2\u00ec\u00ed\7g\2\2\u00ed\u00ee"+
+    "\7c\2\2\u00ee\u00ef\7m\2\2\u00ef\'\3\2\2\2\u00f0\u00f1\7t\2\2\u00f1\u00f2"+
+    "\7g\2\2\u00f2\u00f3\7v\2\2\u00f3\u00f4\7w\2\2\u00f4\u00f5\7t\2\2\u00f5"+
+    "\u00f6\7p\2\2\u00f6)\3\2\2\2\u00f7\u00f8\7p\2\2\u00f8\u00f9\7g\2\2\u00f9"+
+    "\u00fa\7y\2\2\u00fa+\3\2\2\2\u00fb\u00fc\7v\2\2\u00fc\u00fd\7t\2\2\u00fd"+
+    "\u00fe\7{\2\2\u00fe-\3\2\2\2\u00ff\u0100\7e\2\2\u0100\u0101\7c\2\2\u0101"+
+    "\u0102\7v\2\2\u0102\u0103\7e\2\2\u0103\u0104\7j\2\2\u0104/\3\2\2\2\u0105"+
+    "\u0106\7v\2\2\u0106\u0107\7j\2\2\u0107\u0108\7t\2\2\u0108\u0109\7q\2\2"+
+    "\u0109\u010a\7y\2\2\u010a\61\3\2\2\2\u010b\u010c\7#\2\2\u010c\63\3\2\2"+
+    "\2\u010d\u010e\7\u0080\2\2\u010e\65\3\2\2\2\u010f\u0110\7,\2\2\u0110\67"+
+    "\3\2\2\2\u0111\u0112\7\61\2\2\u01129\3\2\2\2\u0113\u0114\7\'\2\2\u0114"+
+    ";\3\2\2\2\u0115\u0116\7-\2\2\u0116=\3\2\2\2\u0117\u0118\7/\2\2\u0118?"+
+    "\3\2\2\2\u0119\u011a\7>\2\2\u011a\u011b\7>\2\2\u011bA\3\2\2\2\u011c\u011d"+
+    "\7@\2\2\u011d\u011e\7@\2\2\u011eC\3\2\2\2\u011f\u0120\7@\2\2\u0120\u0121"+
+    "\7@\2\2\u0121\u0122\7@\2\2\u0122E\3\2\2\2\u0123\u0124\7>\2\2\u0124G\3"+
+    "\2\2\2\u0125\u0126\7>\2\2\u0126\u0127\7?\2\2\u0127I\3\2\2\2\u0128\u0129"+
+    "\7@\2\2\u0129K\3\2\2\2\u012a\u012b\7@\2\2\u012b\u012c\7?\2\2\u012cM\3"+
+    "\2\2\2\u012d\u012e\7?\2\2\u012e\u012f\7?\2\2\u012fO\3\2\2\2\u0130\u0131"+
+    "\7?\2\2\u0131\u0132\7?\2\2\u0132\u0133\7?\2\2\u0133Q\3\2\2\2\u0134\u0135"+
+    "\7#\2\2\u0135\u0136\7?\2\2\u0136S\3\2\2\2\u0137\u0138\7#\2\2\u0138\u0139"+
+    "\7?\2\2\u0139\u013a\7?\2\2\u013aU\3\2\2\2\u013b\u013c\7(\2\2\u013cW\3"+
+    "\2\2\2\u013d\u013e\7`\2\2\u013eY\3\2\2\2\u013f\u0140\7~\2\2\u0140[\3\2"+
+    "\2\2\u0141\u0142\7(\2\2\u0142\u0143\7(\2\2\u0143]\3\2\2\2\u0144\u0145"+
+    "\7~\2\2\u0145\u0146\7~\2\2\u0146_\3\2\2\2\u0147\u0148\7A\2\2\u0148a\3"+
+    "\2\2\2\u0149\u014a\7<\2\2\u014ac\3\2\2\2\u014b\u014c\7-\2\2\u014c\u014d"+
+    "\7-\2\2\u014de\3\2\2\2\u014e\u014f\7/\2\2\u014f\u0150\7/\2\2\u0150g\3"+
+    "\2\2\2\u0151\u0152\7?\2\2\u0152i\3\2\2\2\u0153\u0154\7-\2\2\u0154\u0155"+
+    "\7?\2\2\u0155k\3\2\2\2\u0156\u0157\7/\2\2\u0157\u0158\7?\2\2\u0158m\3"+
+    "\2\2\2\u0159\u015a\7,\2\2\u015a\u015b\7?\2\2\u015bo\3\2\2\2\u015c\u015d"+
+    "\7\61\2\2\u015d\u015e\7?\2\2\u015eq\3\2\2\2\u015f\u0160\7\'\2\2\u0160"+
+    "\u0161\7?\2\2\u0161s\3\2\2\2\u0162\u0163\7(\2\2\u0163\u0164\7?\2\2\u0164"+
+    "u\3\2\2\2\u0165\u0166\7`\2\2\u0166\u0167\7?\2\2\u0167w\3\2\2\2\u0168\u0169"+
+    "\7~\2\2\u0169\u016a\7?\2\2\u016ay\3\2\2\2\u016b\u016c\7>\2\2\u016c\u016d"+
+    "\7>\2\2\u016d\u016e\7?\2\2\u016e{\3\2\2\2\u016f\u0170\7@\2\2\u0170\u0171"+
+    "\7@\2\2\u0171\u0172\7?\2\2\u0172}\3\2\2\2\u0173\u0174\7@\2\2\u0174\u0175"+
+    "\7@\2\2\u0175\u0176\7@\2\2\u0176\u0177\7?\2\2\u0177\177\3\2\2\2\u0178"+
+    "\u017a\7\62\2\2\u0179\u017b\t\4\2\2\u017a\u0179\3\2\2\2\u017b\u017c\3"+
+    "\2\2\2\u017c\u017a\3\2\2\2\u017c\u017d\3\2\2\2\u017d\u017f\3\2\2\2\u017e"+
+    "\u0180\t\5\2\2\u017f\u017e\3\2\2\2\u017f\u0180\3\2\2\2\u0180\u0081\3\2"+
+    "\2\2\u0181\u0182\7\62\2\2\u0182\u0184\t\6\2\2\u0183\u0185\t\7\2\2\u0184"+
+    "\u0183\3\2\2\2\u0185\u0186\3\2\2\2\u0186\u0184\3\2\2\2\u0186\u0187\3\2"+
+    "\2\2\u0187\u0189\3\2\2\2\u0188\u018a\t\5\2\2\u0189\u0188\3\2\2\2\u0189"+
+    "\u018a\3\2\2\2\u018a\u0083\3\2\2\2\u018b\u0194\7\62\2\2\u018c\u0190\t"+
+    "\b\2\2\u018d\u018f\t\t\2\2\u018e\u018d\3\2\2\2\u018f\u0192\3\2\2\2\u0190"+
+    "\u018e\3\2\2\2\u0190\u0191\3\2\2\2\u0191\u0194\3\2\2\2\u0192\u0190\3\2"+
+    "\2\2\u0193\u018b\3\2\2\2\u0193\u018c\3\2\2\2\u0194\u0196\3\2\2\2\u0195"+
+    "\u0197\t\n\2\2\u0196\u0195\3\2\2\2\u0196\u0197\3\2\2\2\u0197\u0085\3\2"+
+    "\2\2\u0198\u01a1\7\62\2\2\u0199\u019d\t\b\2\2\u019a\u019c\t\t\2\2\u019b"+
+    "\u019a\3\2\2\2\u019c\u019f\3\2\2\2\u019d\u019b\3\2\2\2\u019d\u019e\3\2"+
+    "\2\2\u019e\u01a1\3\2\2\2\u019f\u019d\3\2\2\2\u01a0\u0198\3\2\2\2\u01a0"+
+    "\u0199\3\2\2\2\u01a1\u01a8\3\2\2\2\u01a2\u01a4\5\24\n\2\u01a3\u01a5\t"+
+    "\t\2\2\u01a4\u01a3\3\2\2\2\u01a5\u01a6\3\2\2\2\u01a6\u01a4\3\2\2\2\u01a6"+
+    "\u01a7\3\2\2\2\u01a7\u01a9\3\2\2\2\u01a8\u01a2\3\2\2\2\u01a8\u01a9\3\2"+
+    "\2\2\u01a9\u01b3\3\2\2\2\u01aa\u01ac\t\13\2\2\u01ab\u01ad\t\f\2\2\u01ac"+
+    "\u01ab\3\2\2\2\u01ac\u01ad\3\2\2\2\u01ad\u01af\3\2\2\2\u01ae\u01b0\t\t"+
+    "\2\2\u01af\u01ae\3\2\2\2\u01b0\u01b1\3\2\2\2\u01b1\u01af\3\2\2\2\u01b1"+
+    "\u01b2\3\2\2\2\u01b2\u01b4\3\2\2\2\u01b3\u01aa\3\2\2\2\u01b3\u01b4\3\2"+
+    "\2\2\u01b4\u01b6\3\2\2\2\u01b5\u01b7\t\r\2\2\u01b6\u01b5\3\2\2\2\u01b6"+
+    "\u01b7\3\2\2\2\u01b7\u0087\3\2\2\2\u01b8\u01c0\7$\2\2\u01b9\u01ba\7^\2"+
+    "\2\u01ba\u01bf\7$\2\2\u01bb\u01bc\7^\2\2\u01bc\u01bf\7^\2\2\u01bd\u01bf"+
+    "\n\16\2\2\u01be\u01b9\3\2\2\2\u01be\u01bb\3\2\2\2\u01be\u01bd\3\2\2\2"+
+    "\u01bf\u01c2\3\2\2\2\u01c0\u01c1\3\2\2\2\u01c0\u01be\3\2\2\2\u01c1\u01c3"+
+    "\3\2\2\2\u01c2\u01c0\3\2\2\2\u01c3\u01d1\7$\2\2\u01c4\u01cc\7)\2\2\u01c5"+
+    "\u01c6\7^\2\2\u01c6\u01cb\7)\2\2\u01c7\u01c8\7^\2\2\u01c8\u01cb\7^\2\2"+
+    "\u01c9\u01cb\n\16\2\2\u01ca\u01c5\3\2\2\2\u01ca\u01c7\3\2\2\2\u01ca\u01c9"+
+    "\3\2\2\2\u01cb\u01ce\3\2\2\2\u01cc\u01cd\3\2\2\2\u01cc\u01ca\3\2\2\2\u01cd"+
+    "\u01cf\3\2\2\2\u01ce\u01cc\3\2\2\2\u01cf\u01d1\7)\2\2\u01d0\u01b8\3\2"+
+    "\2\2\u01d0\u01c4\3\2\2\2\u01d1\u0089\3\2\2\2\u01d2\u01d3\7v\2\2\u01d3"+
+    "\u01d4\7t\2\2\u01d4\u01d5\7w\2\2\u01d5\u01d6\7g\2\2\u01d6\u008b\3\2\2"+
+    "\2\u01d7\u01d8\7h\2\2\u01d8\u01d9\7c\2\2\u01d9\u01da\7n\2\2\u01da\u01db"+
+    "\7u\2\2\u01db\u01dc\7g\2\2\u01dc\u008d\3\2\2\2\u01dd\u01de\7p\2\2\u01de"+
+    "\u01df\7w\2\2\u01df\u01e0\7n\2\2\u01e0\u01e1\7n\2\2\u01e1\u008f\3\2\2"+
+    "\2\u01e2\u01e8\5\u0092I\2\u01e3\u01e4\5\24\n\2\u01e4\u01e5\5\u0092I\2"+
+    "\u01e5\u01e7\3\2\2\2\u01e6\u01e3\3\2\2\2\u01e7\u01ea\3\2\2\2\u01e8\u01e6"+
+    "\3\2\2\2\u01e8\u01e9\3\2\2\2\u01e9\u01eb\3\2\2\2\u01ea\u01e8\3\2\2\2\u01eb"+
+    "\u01ec\6H\2\2\u01ec\u0091\3\2\2\2\u01ed\u01f1\t\17\2\2\u01ee\u01f0\t\20"+
+    "\2\2\u01ef\u01ee\3\2\2\2\u01f0\u01f3\3\2\2\2\u01f1\u01ef\3\2\2\2\u01f1"+
+    "\u01f2\3\2\2\2\u01f2\u0093\3\2\2\2\u01f3\u01f1\3\2\2\2\u01f4\u01fd\7\62"+
+    "\2\2\u01f5\u01f9\t\b\2\2\u01f6\u01f8\t\t\2\2\u01f7\u01f6\3\2\2\2\u01f8"+
+    "\u01fb\3\2\2\2\u01f9\u01f7\3\2\2\2\u01f9\u01fa\3\2\2\2\u01fa\u01fd\3\2"+
+    "\2\2\u01fb\u01f9\3\2\2\2\u01fc\u01f4\3\2\2\2\u01fc\u01f5\3\2\2\2\u01fd"+
+    "\u01fe\3\2\2\2\u01fe\u01ff\bJ\4\2\u01ff\u0095\3\2\2\2\u0200\u0204\t\21"+
+    "\2\2\u0201\u0203\t\20\2\2\u0202\u0201\3\2\2\2\u0203\u0206\3\2\2\2\u0204"+
+    "\u0202\3\2\2\2\u0204\u0205\3\2\2\2\u0205\u0207\3\2\2\2\u0206\u0204\3\2"+
+    "\2\2\u0207\u0208\bK\4\2\u0208\u0097\3\2\2\2!\2\3\u009b\u00a5\u00af\u00b4"+
+    "\u017c\u017f\u0186\u0189\u0190\u0193\u0196\u019d\u01a0\u01a6\u01a8\u01ac"+
+    "\u01b1\u01b3\u01b6\u01be\u01c0\u01ca\u01cc\u01d0\u01e8\u01f1\u01f9\u01fc"+
+    "\u0204\5\b\2\2\4\3\2\4\2\2";
   public static final ATN _ATN =
     new ATNDeserializer().deserialize(_serializedATN.toCharArray());
   static {
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java
index c8e76ee4bd9e..11b38dc9742e 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java
@@ -25,20 +25,17 @@
     BWOR=44, BOOLAND=45, BOOLOR=46, COND=47, COLON=48, INCR=49, DECR=50, ASSIGN=51, 
     AADD=52, ASUB=53, AMUL=54, ADIV=55, AREM=56, AAND=57, AXOR=58, AOR=59, 
     ALSH=60, ARSH=61, AUSH=62, OCTAL=63, HEX=64, INTEGER=65, DECIMAL=66, STRING=67, 
-    TRUE=68, FALSE=69, NULL=70, ID=71, EXTINTEGER=72, EXTID=73;
+    TRUE=68, FALSE=69, NULL=70, TYPE=71, ID=72, DOTINTEGER=73, DOTID=74;
   public static final int
-    RULE_source = 0, RULE_statement = 1, RULE_block = 2, RULE_empty = 3, RULE_emptyscope = 4, 
-    RULE_initializer = 5, RULE_afterthought = 6, RULE_declaration = 7, RULE_decltype = 8, 
-    RULE_declvar = 9, RULE_trap = 10, RULE_identifier = 11, RULE_generic = 12, 
-    RULE_expression = 13, RULE_chain = 14, RULE_linkprec = 15, RULE_linkcast = 16, 
-    RULE_linkbrace = 17, RULE_linkdot = 18, RULE_linkcall = 19, RULE_linkvar = 20, 
-    RULE_linkfield = 21, RULE_linknew = 22, RULE_linkstring = 23, RULE_arguments = 24;
+    RULE_source = 0, RULE_statement = 1, RULE_trailer = 2, RULE_block = 3, 
+    RULE_empty = 4, RULE_initializer = 5, RULE_afterthought = 6, RULE_declaration = 7, 
+    RULE_decltype = 8, RULE_declvar = 9, RULE_trap = 10, RULE_delimiter = 11, 
+    RULE_expression = 12, RULE_unary = 13, RULE_chain = 14, RULE_primary = 15, 
+    RULE_secondary = 16, RULE_dot = 17, RULE_brace = 18, RULE_arguments = 19;
   public static final String[] ruleNames = {
-    "source", "statement", "block", "empty", "emptyscope", "initializer", 
-    "afterthought", "declaration", "decltype", "declvar", "trap", "identifier", 
-    "generic", "expression", "chain", "linkprec", "linkcast", "linkbrace", 
-    "linkdot", "linkcall", "linkvar", "linkfield", "linknew", "linkstring", 
-    "arguments"
+    "source", "statement", "trailer", "block", "empty", "initializer", "afterthought", 
+    "declaration", "decltype", "declvar", "trap", "delimiter", "expression", 
+    "unary", "chain", "primary", "secondary", "dot", "brace", "arguments"
   };
 
   private static final String[] _LITERAL_NAMES = {
@@ -59,8 +56,8 @@
     "GTE", "EQ", "EQR", "NE", "NER", "BWAND", "XOR", "BWOR", "BOOLAND", "BOOLOR", 
     "COND", "COLON", "INCR", "DECR", "ASSIGN", "AADD", "ASUB", "AMUL", "ADIV", 
     "AREM", "AAND", "AXOR", "AOR", "ALSH", "ARSH", "AUSH", "OCTAL", "HEX", 
-    "INTEGER", "DECIMAL", "STRING", "TRUE", "FALSE", "NULL", "ID", "EXTINTEGER", 
-    "EXTID"
+    "INTEGER", "DECIMAL", "STRING", "TRUE", "FALSE", "NULL", "TYPE", "ID", 
+    "DOTINTEGER", "DOTID"
   };
   public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);
 
@@ -133,25 +130,27 @@ public SourceContext(ParserRuleContext parent, int invokingState) {
   public final SourceContext source() throws RecognitionException {
     SourceContext _localctx = new SourceContext(_ctx, getState());
     enterRule(_localctx, 0, RULE_source);
-    int _la;
     try {
+      int _alt;
       enterOuterAlt(_localctx, 1);
       {
-      setState(51); 
+      setState(43);
       _errHandler.sync(this);
-      _la = _input.LA(1);
-      do {
-        {
-        {
-        setState(50);
-        statement();
-        }
+      _alt = getInterpreter().adaptivePredict(_input,0,_ctx);
+      while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
+        if ( _alt==1 ) {
+          {
+          {
+          setState(40);
+          statement();
+          }
+          } 
         }
-        setState(53); 
+        setState(45);
         _errHandler.sync(this);
-        _la = _input.LA(1);
-      } while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LP) | (1L << IF) | (1L << WHILE) | (1L << DO) | (1L << FOR) | (1L << CONTINUE) | (1L << BREAK) | (1L << RETURN) | (1L << NEW) | (1L << TRY) | (1L << THROW) | (1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB) | (1L << INCR) | (1L << DECR) | (1L << OCTAL))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (HEX - 64)) | (1L << (INTEGER - 64)) | (1L << (DECIMAL - 64)) | (1L << (STRING - 64)) | (1L << (TRUE - 64)) | (1L << (FALSE - 64)) | (1L << (NULL - 64)) | (1L << (ID - 64)))) != 0) );
-      setState(55);
+        _alt = getInterpreter().adaptivePredict(_input,0,_ctx);
+      }
+      setState(46);
       match(EOF);
       }
     }
@@ -181,8 +180,9 @@ public void copyFrom(StatementContext ctx) {
     public DeclarationContext declaration() {
       return getRuleContext(DeclarationContext.class,0);
     }
-    public TerminalNode SEMICOLON() { return getToken(PainlessParser.SEMICOLON, 0); }
-    public TerminalNode EOF() { return getToken(PainlessParser.EOF, 0); }
+    public DelimiterContext delimiter() {
+      return getRuleContext(DelimiterContext.class,0);
+    }
     public DeclContext(StatementContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
@@ -192,8 +192,9 @@ public DeclarationContext declaration() {
   }
   public static class BreakContext extends StatementContext {
     public TerminalNode BREAK() { return getToken(PainlessParser.BREAK, 0); }
-    public TerminalNode SEMICOLON() { return getToken(PainlessParser.SEMICOLON, 0); }
-    public TerminalNode EOF() { return getToken(PainlessParser.EOF, 0); }
+    public DelimiterContext delimiter() {
+      return getRuleContext(DelimiterContext.class,0);
+    }
     public BreakContext(StatementContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
@@ -206,8 +207,9 @@ public DeclarationContext declaration() {
     public ExpressionContext expression() {
       return getRuleContext(ExpressionContext.class,0);
     }
-    public TerminalNode SEMICOLON() { return getToken(PainlessParser.SEMICOLON, 0); }
-    public TerminalNode EOF() { return getToken(PainlessParser.EOF, 0); }
+    public DelimiterContext delimiter() {
+      return getRuleContext(DelimiterContext.class,0);
+    }
     public ThrowContext(StatementContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
@@ -217,8 +219,9 @@ public ExpressionContext expression() {
   }
   public static class ContinueContext extends StatementContext {
     public TerminalNode CONTINUE() { return getToken(PainlessParser.CONTINUE, 0); }
-    public TerminalNode SEMICOLON() { return getToken(PainlessParser.SEMICOLON, 0); }
-    public TerminalNode EOF() { return getToken(PainlessParser.EOF, 0); }
+    public DelimiterContext delimiter() {
+      return getRuleContext(DelimiterContext.class,0);
+    }
     public ContinueContext(StatementContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
@@ -234,8 +237,8 @@ public TerminalNode SEMICOLON(int i) {
       return getToken(PainlessParser.SEMICOLON, i);
     }
     public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
-    public BlockContext block() {
-      return getRuleContext(BlockContext.class,0);
+    public TrailerContext trailer() {
+      return getRuleContext(TrailerContext.class,0);
     }
     public EmptyContext empty() {
       return getRuleContext(EmptyContext.class,0);
@@ -278,8 +281,9 @@ public TrapContext trap(int i) {
     public ExpressionContext expression() {
       return getRuleContext(ExpressionContext.class,0);
     }
-    public TerminalNode SEMICOLON() { return getToken(PainlessParser.SEMICOLON, 0); }
-    public TerminalNode EOF() { return getToken(PainlessParser.EOF, 0); }
+    public DelimiterContext delimiter() {
+      return getRuleContext(DelimiterContext.class,0);
+    }
     public ExprContext(StatementContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
@@ -298,8 +302,9 @@ public ExpressionContext expression() {
       return getRuleContext(ExpressionContext.class,0);
     }
     public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
-    public TerminalNode SEMICOLON() { return getToken(PainlessParser.SEMICOLON, 0); }
-    public TerminalNode EOF() { return getToken(PainlessParser.EOF, 0); }
+    public DelimiterContext delimiter() {
+      return getRuleContext(DelimiterContext.class,0);
+    }
     public DoContext(StatementContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
@@ -314,8 +319,8 @@ public ExpressionContext expression() {
       return getRuleContext(ExpressionContext.class,0);
     }
     public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
-    public BlockContext block() {
-      return getRuleContext(BlockContext.class,0);
+    public TrailerContext trailer() {
+      return getRuleContext(TrailerContext.class,0);
     }
     public EmptyContext empty() {
       return getRuleContext(EmptyContext.class,0);
@@ -334,11 +339,11 @@ public ExpressionContext expression() {
       return getRuleContext(ExpressionContext.class,0);
     }
     public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
-    public List<BlockContext> block() {
-      return getRuleContexts(BlockContext.class);
+    public List<TrailerContext> trailer() {
+      return getRuleContexts(TrailerContext.class);
     }
-    public BlockContext block(int i) {
-      return getRuleContext(BlockContext.class,i);
+    public TrailerContext trailer(int i) {
+      return getRuleContext(TrailerContext.class,i);
     }
     public TerminalNode ELSE() { return getToken(PainlessParser.ELSE, 0); }
     public IfContext(StatementContext ctx) { copyFrom(ctx); }
@@ -353,8 +358,9 @@ public BlockContext block(int i) {
     public ExpressionContext expression() {
       return getRuleContext(ExpressionContext.class,0);
     }
-    public TerminalNode SEMICOLON() { return getToken(PainlessParser.SEMICOLON, 0); }
-    public TerminalNode EOF() { return getToken(PainlessParser.EOF, 0); }
+    public DelimiterContext delimiter() {
+      return getRuleContext(DelimiterContext.class,0);
+    }
     public ReturnContext(StatementContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
@@ -366,33 +372,38 @@ public ExpressionContext expression() {
   public final StatementContext statement() throws RecognitionException {
     StatementContext _localctx = new StatementContext(_ctx, getState());
     enterRule(_localctx, 2, RULE_statement);
-    int _la;
     try {
       int _alt;
-      setState(125);
+      setState(117);
       switch ( getInterpreter().adaptivePredict(_input,8,_ctx) ) {
       case 1:
         _localctx = new IfContext(_localctx);
         enterOuterAlt(_localctx, 1);
         {
-        setState(57);
+        setState(48);
         match(IF);
-        setState(58);
+        setState(49);
         match(LP);
-        setState(59);
+        setState(50);
         expression(0);
-        setState(60);
+        setState(51);
         match(RP);
-        setState(61);
-        block();
-        setState(64);
+        setState(52);
+        trailer();
+        setState(56);
         switch ( getInterpreter().adaptivePredict(_input,1,_ctx) ) {
         case 1:
           {
-          setState(62);
+          setState(53);
           match(ELSE);
-          setState(63);
-          block();
+          setState(54);
+          trailer();
+          }
+          break;
+        case 2:
+          {
+          setState(55);
+          if (!( _input.LA(1) != ELSE )) throw new FailedPredicateException(this, " _input.LA(1) != ELSE ");
           }
           break;
         }
@@ -402,25 +413,25 @@ public final StatementContext statement() throws RecognitionException {
         _localctx = new WhileContext(_localctx);
         enterOuterAlt(_localctx, 2);
         {
-        setState(66);
+        setState(58);
         match(WHILE);
-        setState(67);
+        setState(59);
         match(LP);
-        setState(68);
+        setState(60);
         expression(0);
-        setState(69);
+        setState(61);
         match(RP);
-        setState(72);
+        setState(64);
         switch ( getInterpreter().adaptivePredict(_input,2,_ctx) ) {
         case 1:
           {
-          setState(70);
-          block();
+          setState(62);
+          trailer();
           }
           break;
         case 2:
           {
-          setState(71);
+          setState(63);
           empty();
           }
           break;
@@ -431,79 +442,74 @@ public final StatementContext statement() throws RecognitionException {
         _localctx = new DoContext(_localctx);
         enterOuterAlt(_localctx, 3);
         {
-        setState(74);
+        setState(66);
         match(DO);
-        setState(75);
+        setState(67);
         block();
-        setState(76);
+        setState(68);
         match(WHILE);
-        setState(77);
+        setState(69);
         match(LP);
-        setState(78);
+        setState(70);
         expression(0);
-        setState(79);
+        setState(71);
         match(RP);
-        setState(80);
-        _la = _input.LA(1);
-        if ( !(_la==EOF || _la==SEMICOLON) ) {
-        _errHandler.recoverInline(this);
-        } else {
-          consume();
-        }
+        setState(72);
+        delimiter();
         }
         break;
       case 4:
         _localctx = new ForContext(_localctx);
         enterOuterAlt(_localctx, 4);
         {
-        setState(82);
+        setState(74);
         match(FOR);
-        setState(83);
+        setState(75);
         match(LP);
-        setState(85);
-        _la = _input.LA(1);
-        if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LP) | (1L << NEW) | (1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB) | (1L << INCR) | (1L << DECR) | (1L << OCTAL))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (HEX - 64)) | (1L << (INTEGER - 64)) | (1L << (DECIMAL - 64)) | (1L << (STRING - 64)) | (1L << (TRUE - 64)) | (1L << (FALSE - 64)) | (1L << (NULL - 64)) | (1L << (ID - 64)))) != 0)) {
+        setState(77);
+        switch ( getInterpreter().adaptivePredict(_input,3,_ctx) ) {
+        case 1:
           {
-          setState(84);
+          setState(76);
           initializer();
           }
+          break;
         }
-
-        setState(87);
+        setState(79);
         match(SEMICOLON);
-        setState(89);
-        _la = _input.LA(1);
-        if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LP) | (1L << NEW) | (1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB) | (1L << INCR) | (1L << DECR) | (1L << OCTAL))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (HEX - 64)) | (1L << (INTEGER - 64)) | (1L << (DECIMAL - 64)) | (1L << (STRING - 64)) | (1L << (TRUE - 64)) | (1L << (FALSE - 64)) | (1L << (NULL - 64)) | (1L << (ID - 64)))) != 0)) {
+        setState(81);
+        switch ( getInterpreter().adaptivePredict(_input,4,_ctx) ) {
+        case 1:
           {
-          setState(88);
+          setState(80);
           expression(0);
           }
+          break;
         }
-
-        setState(91);
+        setState(83);
         match(SEMICOLON);
-        setState(93);
-        _la = _input.LA(1);
-        if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LP) | (1L << NEW) | (1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB) | (1L << INCR) | (1L << DECR) | (1L << OCTAL))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (HEX - 64)) | (1L << (INTEGER - 64)) | (1L << (DECIMAL - 64)) | (1L << (STRING - 64)) | (1L << (TRUE - 64)) | (1L << (FALSE - 64)) | (1L << (NULL - 64)) | (1L << (ID - 64)))) != 0)) {
+        setState(85);
+        switch ( getInterpreter().adaptivePredict(_input,5,_ctx) ) {
+        case 1:
           {
-          setState(92);
+          setState(84);
           afterthought();
           }
+          break;
         }
-
-        setState(95);
+        setState(87);
         match(RP);
-        setState(98);
+        setState(90);
         switch ( getInterpreter().adaptivePredict(_input,6,_ctx) ) {
         case 1:
           {
-          setState(96);
-          block();
+          setState(88);
+          trailer();
           }
           break;
         case 2:
           {
-          setState(97);
+          setState(89);
           empty();
           }
           break;
@@ -514,73 +520,53 @@ public final StatementContext statement() throws RecognitionException {
         _localctx = new DeclContext(_localctx);
         enterOuterAlt(_localctx, 5);
         {
-        setState(100);
+        setState(92);
         declaration();
-        setState(101);
-        _la = _input.LA(1);
-        if ( !(_la==EOF || _la==SEMICOLON) ) {
-        _errHandler.recoverInline(this);
-        } else {
-          consume();
-        }
+        setState(93);
+        delimiter();
         }
         break;
       case 6:
         _localctx = new ContinueContext(_localctx);
         enterOuterAlt(_localctx, 6);
         {
-        setState(103);
+        setState(95);
         match(CONTINUE);
-        setState(104);
-        _la = _input.LA(1);
-        if ( !(_la==EOF || _la==SEMICOLON) ) {
-        _errHandler.recoverInline(this);
-        } else {
-          consume();
-        }
+        setState(96);
+        delimiter();
         }
         break;
       case 7:
         _localctx = new BreakContext(_localctx);
         enterOuterAlt(_localctx, 7);
         {
-        setState(105);
+        setState(97);
         match(BREAK);
-        setState(106);
-        _la = _input.LA(1);
-        if ( !(_la==EOF || _la==SEMICOLON) ) {
-        _errHandler.recoverInline(this);
-        } else {
-          consume();
-        }
+        setState(98);
+        delimiter();
         }
         break;
       case 8:
         _localctx = new ReturnContext(_localctx);
         enterOuterAlt(_localctx, 8);
         {
-        setState(107);
+        setState(99);
         match(RETURN);
-        setState(108);
+        setState(100);
         expression(0);
-        setState(109);
-        _la = _input.LA(1);
-        if ( !(_la==EOF || _la==SEMICOLON) ) {
-        _errHandler.recoverInline(this);
-        } else {
-          consume();
-        }
+        setState(101);
+        delimiter();
         }
         break;
       case 9:
         _localctx = new TryContext(_localctx);
         enterOuterAlt(_localctx, 9);
         {
-        setState(111);
+        setState(103);
         match(TRY);
-        setState(112);
+        setState(104);
         block();
-        setState(114); 
+        setState(106); 
         _errHandler.sync(this);
         _alt = 1;
         do {
@@ -588,7 +574,7 @@ public final StatementContext statement() throws RecognitionException {
           case 1:
             {
             {
-            setState(113);
+            setState(105);
             trap();
             }
             }
@@ -596,7 +582,7 @@ public final StatementContext statement() throws RecognitionException {
           default:
             throw new NoViableAltException(this);
           }
-          setState(116); 
+          setState(108); 
           _errHandler.sync(this);
           _alt = getInterpreter().adaptivePredict(_input,7,_ctx);
         } while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );
@@ -606,32 +592,22 @@ public final StatementContext statement() throws RecognitionException {
         _localctx = new ThrowContext(_localctx);
         enterOuterAlt(_localctx, 10);
         {
-        setState(118);
+        setState(110);
         match(THROW);
-        setState(119);
+        setState(111);
         expression(0);
-        setState(120);
-        _la = _input.LA(1);
-        if ( !(_la==EOF || _la==SEMICOLON) ) {
-        _errHandler.recoverInline(this);
-        } else {
-          consume();
-        }
+        setState(112);
+        delimiter();
         }
         break;
       case 11:
         _localctx = new ExprContext(_localctx);
         enterOuterAlt(_localctx, 11);
         {
-        setState(122);
+        setState(114);
         expression(0);
-        setState(123);
-        _la = _input.LA(1);
-        if ( !(_la==EOF || _la==SEMICOLON) ) {
-        _errHandler.recoverInline(this);
-        } else {
-          consume();
-        }
+        setState(115);
+        delimiter();
         }
         break;
       }
@@ -647,29 +623,58 @@ public final StatementContext statement() throws RecognitionException {
     return _localctx;
   }
 
-  public static class BlockContext extends ParserRuleContext {
-    public BlockContext(ParserRuleContext parent, int invokingState) {
-      super(parent, invokingState);
-    }
-    @Override public int getRuleIndex() { return RULE_block; }
-   
-    public BlockContext() { }
-    public void copyFrom(BlockContext ctx) {
-      super.copyFrom(ctx);
+  public static class TrailerContext extends ParserRuleContext {
+    public BlockContext block() {
+      return getRuleContext(BlockContext.class,0);
     }
-  }
-  public static class SingleContext extends BlockContext {
     public StatementContext statement() {
       return getRuleContext(StatementContext.class,0);
     }
-    public SingleContext(BlockContext ctx) { copyFrom(ctx); }
+    public TrailerContext(ParserRuleContext parent, int invokingState) {
+      super(parent, invokingState);
+    }
+    @Override public int getRuleIndex() { return RULE_trailer; }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitSingle(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitTrailer(this);
       else return visitor.visitChildren(this);
     }
   }
-  public static class MultipleContext extends BlockContext {
+
+  public final TrailerContext trailer() throws RecognitionException {
+    TrailerContext _localctx = new TrailerContext(_ctx, getState());
+    enterRule(_localctx, 4, RULE_trailer);
+    try {
+      setState(121);
+      switch ( getInterpreter().adaptivePredict(_input,9,_ctx) ) {
+      case 1:
+        enterOuterAlt(_localctx, 1);
+        {
+        setState(119);
+        block();
+        }
+        break;
+      case 2:
+        enterOuterAlt(_localctx, 2);
+        {
+        setState(120);
+        statement();
+        }
+        break;
+      }
+    }
+    catch (RecognitionException re) {
+      _localctx.exception = re;
+      _errHandler.reportError(this, re);
+      _errHandler.recover(this, re);
+    }
+    finally {
+      exitRule();
+    }
+    return _localctx;
+  }
+
+  public static class BlockContext extends ParserRuleContext {
     public TerminalNode LBRACK() { return getToken(PainlessParser.LBRACK, 0); }
     public TerminalNode RBRACK() { return getToken(PainlessParser.RBRACK, 0); }
     public List<StatementContext> statement() {
@@ -678,80 +683,44 @@ public StatementContext statement() {
     public StatementContext statement(int i) {
       return getRuleContext(StatementContext.class,i);
     }
-    public MultipleContext(BlockContext ctx) { copyFrom(ctx); }
+    public BlockContext(ParserRuleContext parent, int invokingState) {
+      super(parent, invokingState);
+    }
+    @Override public int getRuleIndex() { return RULE_block; }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitMultiple(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitBlock(this);
       else return visitor.visitChildren(this);
     }
   }
 
   public final BlockContext block() throws RecognitionException {
     BlockContext _localctx = new BlockContext(_ctx, getState());
-    enterRule(_localctx, 4, RULE_block);
-    int _la;
+    enterRule(_localctx, 6, RULE_block);
     try {
-      setState(136);
-      switch (_input.LA(1)) {
-      case LBRACK:
-        _localctx = new MultipleContext(_localctx);
-        enterOuterAlt(_localctx, 1);
-        {
-        setState(127);
-        match(LBRACK);
-        setState(129); 
-        _errHandler.sync(this);
-        _la = _input.LA(1);
-        do {
+      int _alt;
+      enterOuterAlt(_localctx, 1);
+      {
+      setState(123);
+      match(LBRACK);
+      setState(127);
+      _errHandler.sync(this);
+      _alt = getInterpreter().adaptivePredict(_input,10,_ctx);
+      while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
+        if ( _alt==1 ) {
           {
           {
-          setState(128);
+          setState(124);
           statement();
           }
-          }
-          setState(131); 
-          _errHandler.sync(this);
-          _la = _input.LA(1);
-        } while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LP) | (1L << IF) | (1L << WHILE) | (1L << DO) | (1L << FOR) | (1L << CONTINUE) | (1L << BREAK) | (1L << RETURN) | (1L << NEW) | (1L << TRY) | (1L << THROW) | (1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB) | (1L << INCR) | (1L << DECR) | (1L << OCTAL))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (HEX - 64)) | (1L << (INTEGER - 64)) | (1L << (DECIMAL - 64)) | (1L << (STRING - 64)) | (1L << (TRUE - 64)) | (1L << (FALSE - 64)) | (1L << (NULL - 64)) | (1L << (ID - 64)))) != 0) );
-        setState(133);
-        match(RBRACK);
-        }
-        break;
-      case LP:
-      case IF:
-      case WHILE:
-      case DO:
-      case FOR:
-      case CONTINUE:
-      case BREAK:
-      case RETURN:
-      case NEW:
-      case TRY:
-      case THROW:
-      case BOOLNOT:
-      case BWNOT:
-      case ADD:
-      case SUB:
-      case INCR:
-      case DECR:
-      case OCTAL:
-      case HEX:
-      case INTEGER:
-      case DECIMAL:
-      case STRING:
-      case TRUE:
-      case FALSE:
-      case NULL:
-      case ID:
-        _localctx = new SingleContext(_localctx);
-        enterOuterAlt(_localctx, 2);
-        {
-        setState(135);
-        statement();
+          } 
         }
-        break;
-      default:
-        throw new NoViableAltException(this);
+        setState(129);
+        _errHandler.sync(this);
+        _alt = getInterpreter().adaptivePredict(_input,10,_ctx);
+      }
+      setState(130);
+      match(RBRACK);
       }
     }
     catch (RecognitionException re) {
@@ -766,9 +735,6 @@ public final BlockContext block() throws RecognitionException {
   }
 
   public static class EmptyContext extends ParserRuleContext {
-    public EmptyscopeContext emptyscope() {
-      return getRuleContext(EmptyscopeContext.class,0);
-    }
     public TerminalNode SEMICOLON() { return getToken(PainlessParser.SEMICOLON, 0); }
     public EmptyContext(ParserRuleContext parent, int invokingState) {
       super(parent, invokingState);
@@ -783,26 +749,12 @@ public EmptyContext(ParserRuleContext parent, int invokingState) {
 
   public final EmptyContext empty() throws RecognitionException {
     EmptyContext _localctx = new EmptyContext(_ctx, getState());
-    enterRule(_localctx, 6, RULE_empty);
+    enterRule(_localctx, 8, RULE_empty);
     try {
-      setState(140);
-      switch (_input.LA(1)) {
-      case LBRACK:
-        enterOuterAlt(_localctx, 1);
-        {
-        setState(138);
-        emptyscope();
-        }
-        break;
-      case SEMICOLON:
-        enterOuterAlt(_localctx, 2);
-        {
-        setState(139);
-        match(SEMICOLON);
-        }
-        break;
-      default:
-        throw new NoViableAltException(this);
+      enterOuterAlt(_localctx, 1);
+      {
+      setState(132);
+      match(SEMICOLON);
       }
     }
     catch (RecognitionException re) {
@@ -816,46 +768,9 @@ public final EmptyContext empty() throws RecognitionException {
     return _localctx;
   }
 
-  public static class EmptyscopeContext extends ParserRuleContext {
-    public TerminalNode LBRACK() { return getToken(PainlessParser.LBRACK, 0); }
-    public TerminalNode RBRACK() { return getToken(PainlessParser.RBRACK, 0); }
-    public EmptyscopeContext(ParserRuleContext parent, int invokingState) {
-      super(parent, invokingState);
-    }
-    @Override public int getRuleIndex() { return RULE_emptyscope; }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitEmptyscope(this);
-      else return visitor.visitChildren(this);
-    }
-  }
-
-  public final EmptyscopeContext emptyscope() throws RecognitionException {
-    EmptyscopeContext _localctx = new EmptyscopeContext(_ctx, getState());
-    enterRule(_localctx, 8, RULE_emptyscope);
-    try {
-      enterOuterAlt(_localctx, 1);
-      {
-      setState(142);
-      match(LBRACK);
-      setState(143);
-      match(RBRACK);
-      }
-    }
-    catch (RecognitionException re) {
-      _localctx.exception = re;
-      _errHandler.reportError(this, re);
-      _errHandler.recover(this, re);
-    }
-    finally {
-      exitRule();
-    }
-    return _localctx;
-  }
-
-  public static class InitializerContext extends ParserRuleContext {
-    public DeclarationContext declaration() {
-      return getRuleContext(DeclarationContext.class,0);
+  public static class InitializerContext extends ParserRuleContext {
+    public DeclarationContext declaration() {
+      return getRuleContext(DeclarationContext.class,0);
     }
     public ExpressionContext expression() {
       return getRuleContext(ExpressionContext.class,0);
@@ -875,19 +790,19 @@ public final InitializerContext initializer() throws RecognitionException {
     InitializerContext _localctx = new InitializerContext(_ctx, getState());
     enterRule(_localctx, 10, RULE_initializer);
     try {
-      setState(147);
-      switch ( getInterpreter().adaptivePredict(_input,12,_ctx) ) {
+      setState(136);
+      switch ( getInterpreter().adaptivePredict(_input,11,_ctx) ) {
       case 1:
         enterOuterAlt(_localctx, 1);
         {
-        setState(145);
+        setState(134);
         declaration();
         }
         break;
       case 2:
         enterOuterAlt(_localctx, 2);
         {
-        setState(146);
+        setState(135);
         expression(0);
         }
         break;
@@ -925,7 +840,7 @@ public final AfterthoughtContext afterthought() throws RecognitionException {
     try {
       enterOuterAlt(_localctx, 1);
       {
-      setState(149);
+      setState(138);
       expression(0);
       }
     }
@@ -972,23 +887,23 @@ public final DeclarationContext declaration() throws RecognitionException {
     try {
       enterOuterAlt(_localctx, 1);
       {
-      setState(151);
+      setState(140);
       decltype();
-      setState(152);
+      setState(141);
       declvar();
-      setState(157);
+      setState(146);
       _errHandler.sync(this);
       _la = _input.LA(1);
       while (_la==COMMA) {
         {
         {
-        setState(153);
+        setState(142);
         match(COMMA);
-        setState(154);
+        setState(143);
         declvar();
         }
         }
-        setState(159);
+        setState(148);
         _errHandler.sync(this);
         _la = _input.LA(1);
       }
@@ -1006,9 +921,7 @@ public final DeclarationContext declaration() throws RecognitionException {
   }
 
   public static class DecltypeContext extends ParserRuleContext {
-    public IdentifierContext identifier() {
-      return getRuleContext(IdentifierContext.class,0);
-    }
+    public TerminalNode TYPE() { return getToken(PainlessParser.TYPE, 0); }
     public List<TerminalNode> LBRACE() { return getTokens(PainlessParser.LBRACE); }
     public TerminalNode LBRACE(int i) {
       return getToken(PainlessParser.LBRACE, i);
@@ -1035,21 +948,21 @@ public final DecltypeContext decltype() throws RecognitionException {
     try {
       enterOuterAlt(_localctx, 1);
       {
-      setState(160);
-      identifier();
-      setState(165);
+      setState(149);
+      match(TYPE);
+      setState(154);
       _errHandler.sync(this);
       _la = _input.LA(1);
       while (_la==LBRACE) {
         {
         {
-        setState(161);
+        setState(150);
         match(LBRACE);
-        setState(162);
+        setState(151);
         match(RBRACE);
         }
         }
-        setState(167);
+        setState(156);
         _errHandler.sync(this);
         _la = _input.LA(1);
       }
@@ -1067,9 +980,7 @@ public final DecltypeContext decltype() throws RecognitionException {
   }
 
   public static class DeclvarContext extends ParserRuleContext {
-    public IdentifierContext identifier() {
-      return getRuleContext(IdentifierContext.class,0);
-    }
+    public TerminalNode ID() { return getToken(PainlessParser.ID, 0); }
     public TerminalNode ASSIGN() { return getToken(PainlessParser.ASSIGN, 0); }
     public ExpressionContext expression() {
       return getRuleContext(ExpressionContext.class,0);
@@ -1092,15 +1003,15 @@ public final DeclvarContext declvar() throws RecognitionException {
     try {
       enterOuterAlt(_localctx, 1);
       {
-      setState(168);
-      identifier();
-      setState(171);
+      setState(157);
+      match(ID);
+      setState(160);
       _la = _input.LA(1);
       if (_la==ASSIGN) {
         {
-        setState(169);
+        setState(158);
         match(ASSIGN);
-        setState(170);
+        setState(159);
         expression(0);
         }
       }
@@ -1121,19 +1032,12 @@ public final DeclvarContext declvar() throws RecognitionException {
   public static class TrapContext extends ParserRuleContext {
     public TerminalNode CATCH() { return getToken(PainlessParser.CATCH, 0); }
     public TerminalNode LP() { return getToken(PainlessParser.LP, 0); }
+    public TerminalNode TYPE() { return getToken(PainlessParser.TYPE, 0); }
+    public TerminalNode ID() { return getToken(PainlessParser.ID, 0); }
     public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
-    public List<IdentifierContext> identifier() {
-      return getRuleContexts(IdentifierContext.class);
-    }
-    public IdentifierContext identifier(int i) {
-      return getRuleContext(IdentifierContext.class,i);
-    }
     public BlockContext block() {
       return getRuleContext(BlockContext.class,0);
     }
-    public EmptyscopeContext emptyscope() {
-      return getRuleContext(EmptyscopeContext.class,0);
-    }
     public TrapContext(ParserRuleContext parent, int invokingState) {
       super(parent, invokingState);
     }
@@ -1151,79 +1055,18 @@ public final TrapContext trap() throws RecognitionException {
     try {
       enterOuterAlt(_localctx, 1);
       {
-      setState(173);
+      setState(162);
       match(CATCH);
-      setState(174);
+      setState(163);
       match(LP);
-      {
-      setState(175);
-      identifier();
-      setState(176);
-      identifier();
-      }
-      setState(178);
-      match(RP);
-      setState(181);
-      switch ( getInterpreter().adaptivePredict(_input,16,_ctx) ) {
-      case 1:
-        {
-        setState(179);
-        block();
-        }
-        break;
-      case 2:
-        {
-        setState(180);
-        emptyscope();
-        }
-        break;
-      }
-      }
-    }
-    catch (RecognitionException re) {
-      _localctx.exception = re;
-      _errHandler.reportError(this, re);
-      _errHandler.recover(this, re);
-    }
-    finally {
-      exitRule();
-    }
-    return _localctx;
-  }
-
-  public static class IdentifierContext extends ParserRuleContext {
-    public TerminalNode ID() { return getToken(PainlessParser.ID, 0); }
-    public GenericContext generic() {
-      return getRuleContext(GenericContext.class,0);
-    }
-    public IdentifierContext(ParserRuleContext parent, int invokingState) {
-      super(parent, invokingState);
-    }
-    @Override public int getRuleIndex() { return RULE_identifier; }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitIdentifier(this);
-      else return visitor.visitChildren(this);
-    }
-  }
-
-  public final IdentifierContext identifier() throws RecognitionException {
-    IdentifierContext _localctx = new IdentifierContext(_ctx, getState());
-    enterRule(_localctx, 22, RULE_identifier);
-    try {
-      enterOuterAlt(_localctx, 1);
-      {
-      setState(183);
+      setState(164);
+      match(TYPE);
+      setState(165);
       match(ID);
-      setState(185);
-      switch ( getInterpreter().adaptivePredict(_input,17,_ctx) ) {
-      case 1:
-        {
-        setState(184);
-        generic();
-        }
-        break;
-      }
+      setState(166);
+      match(RP);
+      setState(167);
+      block();
       }
     }
     catch (RecognitionException re) {
@@ -1237,59 +1080,34 @@ public final IdentifierContext identifier() throws RecognitionException {
     return _localctx;
   }
 
-  public static class GenericContext extends ParserRuleContext {
-    public TerminalNode LT() { return getToken(PainlessParser.LT, 0); }
-    public List<IdentifierContext> identifier() {
-      return getRuleContexts(IdentifierContext.class);
-    }
-    public IdentifierContext identifier(int i) {
-      return getRuleContext(IdentifierContext.class,i);
-    }
-    public TerminalNode GT() { return getToken(PainlessParser.GT, 0); }
-    public List<TerminalNode> COMMA() { return getTokens(PainlessParser.COMMA); }
-    public TerminalNode COMMA(int i) {
-      return getToken(PainlessParser.COMMA, i);
-    }
-    public GenericContext(ParserRuleContext parent, int invokingState) {
+  public static class DelimiterContext extends ParserRuleContext {
+    public TerminalNode SEMICOLON() { return getToken(PainlessParser.SEMICOLON, 0); }
+    public TerminalNode EOF() { return getToken(PainlessParser.EOF, 0); }
+    public DelimiterContext(ParserRuleContext parent, int invokingState) {
       super(parent, invokingState);
     }
-    @Override public int getRuleIndex() { return RULE_generic; }
+    @Override public int getRuleIndex() { return RULE_delimiter; }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitGeneric(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitDelimiter(this);
       else return visitor.visitChildren(this);
     }
   }
 
-  public final GenericContext generic() throws RecognitionException {
-    GenericContext _localctx = new GenericContext(_ctx, getState());
-    enterRule(_localctx, 24, RULE_generic);
+  public final DelimiterContext delimiter() throws RecognitionException {
+    DelimiterContext _localctx = new DelimiterContext(_ctx, getState());
+    enterRule(_localctx, 22, RULE_delimiter);
     int _la;
     try {
       enterOuterAlt(_localctx, 1);
       {
-      setState(187);
-      match(LT);
-      setState(188);
-      identifier();
-      setState(193);
-      _errHandler.sync(this);
+      setState(169);
       _la = _input.LA(1);
-      while (_la==COMMA) {
-        {
-        {
-        setState(189);
-        match(COMMA);
-        setState(190);
-        identifier();
-        }
-        }
-        setState(195);
-        _errHandler.sync(this);
-        _la = _input.LA(1);
+      if ( !(_la==EOF || _la==SEMICOLON) ) {
+      _errHandler.recoverInline(this);
+      } else {
+        consume();
       }
-      setState(196);
-      match(GT);
       }
     }
     catch (RecognitionException re) {
@@ -1304,6 +1122,7 @@ public final GenericContext generic() throws RecognitionException {
   }
 
   public static class ExpressionContext extends ParserRuleContext {
+    public boolean s =  true;
     public ExpressionContext(ParserRuleContext parent, int invokingState) {
       super(parent, invokingState);
     }
@@ -1312,6 +1131,19 @@ public ExpressionContext(ParserRuleContext parent, int invokingState) {
     public ExpressionContext() { }
     public void copyFrom(ExpressionContext ctx) {
       super.copyFrom(ctx);
+      this.s = ctx.s;
+    }
+  }
+  public static class SingleContext extends ExpressionContext {
+    public UnaryContext u;
+    public UnaryContext unary() {
+      return getRuleContext(UnaryContext.class,0);
+    }
+    public SingleContext(ExpressionContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitSingle(this);
+      else return visitor.visitChildren(this);
     }
   }
   public static class CompContext extends ExpressionContext {
@@ -1336,17 +1168,6 @@ public ExpressionContext expression(int i) {
       else return visitor.visitChildren(this);
     }
   }
-  public static class ReadContext extends ExpressionContext {
-    public ChainContext chain() {
-      return getRuleContext(ChainContext.class,0);
-    }
-    public ReadContext(ExpressionContext ctx) { copyFrom(ctx); }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitRead(this);
-      else return visitor.visitChildren(this);
-    }
-  }
   public static class BoolContext extends ExpressionContext {
     public List<ExpressionContext> expression() {
       return getRuleContexts(ExpressionContext.class);
@@ -1364,6 +1185,8 @@ public ExpressionContext expression(int i) {
     }
   }
   public static class ConditionalContext extends ExpressionContext {
+    public ExpressionContext e0;
+    public ExpressionContext e1;
     public List<ExpressionContext> expression() {
       return getRuleContexts(ExpressionContext.class);
     }
@@ -1405,106 +1228,6 @@ public ExpressionContext expression() {
       else return visitor.visitChildren(this);
     }
   }
-  public static class FalseContext extends ExpressionContext {
-    public TerminalNode FALSE() { return getToken(PainlessParser.FALSE, 0); }
-    public FalseContext(ExpressionContext ctx) { copyFrom(ctx); }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitFalse(this);
-      else return visitor.visitChildren(this);
-    }
-  }
-  public static class NumericContext extends ExpressionContext {
-    public TerminalNode OCTAL() { return getToken(PainlessParser.OCTAL, 0); }
-    public TerminalNode HEX() { return getToken(PainlessParser.HEX, 0); }
-    public TerminalNode INTEGER() { return getToken(PainlessParser.INTEGER, 0); }
-    public TerminalNode DECIMAL() { return getToken(PainlessParser.DECIMAL, 0); }
-    public NumericContext(ExpressionContext ctx) { copyFrom(ctx); }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitNumeric(this);
-      else return visitor.visitChildren(this);
-    }
-  }
-  public static class UnaryContext extends ExpressionContext {
-    public ExpressionContext expression() {
-      return getRuleContext(ExpressionContext.class,0);
-    }
-    public TerminalNode BOOLNOT() { return getToken(PainlessParser.BOOLNOT, 0); }
-    public TerminalNode BWNOT() { return getToken(PainlessParser.BWNOT, 0); }
-    public TerminalNode ADD() { return getToken(PainlessParser.ADD, 0); }
-    public TerminalNode SUB() { return getToken(PainlessParser.SUB, 0); }
-    public UnaryContext(ExpressionContext ctx) { copyFrom(ctx); }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitUnary(this);
-      else return visitor.visitChildren(this);
-    }
-  }
-  public static class PrecedenceContext extends ExpressionContext {
-    public TerminalNode LP() { return getToken(PainlessParser.LP, 0); }
-    public ExpressionContext expression() {
-      return getRuleContext(ExpressionContext.class,0);
-    }
-    public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
-    public PrecedenceContext(ExpressionContext ctx) { copyFrom(ctx); }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitPrecedence(this);
-      else return visitor.visitChildren(this);
-    }
-  }
-  public static class PreincContext extends ExpressionContext {
-    public ChainContext chain() {
-      return getRuleContext(ChainContext.class,0);
-    }
-    public TerminalNode INCR() { return getToken(PainlessParser.INCR, 0); }
-    public TerminalNode DECR() { return getToken(PainlessParser.DECR, 0); }
-    public PreincContext(ExpressionContext ctx) { copyFrom(ctx); }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitPreinc(this);
-      else return visitor.visitChildren(this);
-    }
-  }
-  public static class PostincContext extends ExpressionContext {
-    public ChainContext chain() {
-      return getRuleContext(ChainContext.class,0);
-    }
-    public TerminalNode INCR() { return getToken(PainlessParser.INCR, 0); }
-    public TerminalNode DECR() { return getToken(PainlessParser.DECR, 0); }
-    public PostincContext(ExpressionContext ctx) { copyFrom(ctx); }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitPostinc(this);
-      else return visitor.visitChildren(this);
-    }
-  }
-  public static class CastContext extends ExpressionContext {
-    public TerminalNode LP() { return getToken(PainlessParser.LP, 0); }
-    public DecltypeContext decltype() {
-      return getRuleContext(DecltypeContext.class,0);
-    }
-    public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
-    public ExpressionContext expression() {
-      return getRuleContext(ExpressionContext.class,0);
-    }
-    public CastContext(ExpressionContext ctx) { copyFrom(ctx); }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitCast(this);
-      else return visitor.visitChildren(this);
-    }
-  }
-  public static class NullContext extends ExpressionContext {
-    public TerminalNode NULL() { return getToken(PainlessParser.NULL, 0); }
-    public NullContext(ExpressionContext ctx) { copyFrom(ctx); }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitNull(this);
-      else return visitor.visitChildren(this);
-    }
-  }
   public static class BinaryContext extends ExpressionContext {
     public List<ExpressionContext> expression() {
       return getRuleContexts(ExpressionContext.class);
@@ -1530,15 +1253,6 @@ public ExpressionContext expression(int i) {
       else return visitor.visitChildren(this);
     }
   }
-  public static class TrueContext extends ExpressionContext {
-    public TerminalNode TRUE() { return getToken(PainlessParser.TRUE, 0); }
-    public TrueContext(ExpressionContext ctx) { copyFrom(ctx); }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitTrue(this);
-      else return visitor.visitChildren(this);
-    }
-  }
 
   public final ExpressionContext expression() throws RecognitionException {
     return expression(0);
@@ -1549,339 +1263,235 @@ private ExpressionContext expression(int _p) throws RecognitionException {
     int _parentState = getState();
     ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
     ExpressionContext _prevctx = _localctx;
-    int _startState = 26;
-    enterRecursionRule(_localctx, 26, RULE_expression, _p);
+    int _startState = 24;
+    enterRecursionRule(_localctx, 24, RULE_expression, _p);
     int _la;
     try {
       int _alt;
       enterOuterAlt(_localctx, 1);
       {
-      setState(224);
-      switch ( getInterpreter().adaptivePredict(_input,19,_ctx) ) {
+      setState(180);
+      switch ( getInterpreter().adaptivePredict(_input,15,_ctx) ) {
       case 1:
-        {
-        _localctx = new UnaryContext(_localctx);
-        _ctx = _localctx;
-        _prevctx = _localctx;
-
-        setState(199);
-        _la = _input.LA(1);
-        if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB))) != 0)) ) {
-        _errHandler.recoverInline(this);
-        } else {
-          consume();
-        }
-        setState(200);
-        expression(14);
-        }
-        break;
-      case 2:
-        {
-        _localctx = new CastContext(_localctx);
-        _ctx = _localctx;
-        _prevctx = _localctx;
-        setState(201);
-        match(LP);
-        setState(202);
-        decltype();
-        setState(203);
-        match(RP);
-        setState(204);
-        expression(13);
-        }
-        break;
-      case 3:
         {
         _localctx = new AssignmentContext(_localctx);
         _ctx = _localctx;
         _prevctx = _localctx;
-        setState(206);
-        chain();
-        setState(207);
+
+        setState(172);
+        chain(true);
+        setState(173);
         _la = _input.LA(1);
         if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ASSIGN) | (1L << AADD) | (1L << ASUB) | (1L << AMUL) | (1L << ADIV) | (1L << AREM) | (1L << AAND) | (1L << AXOR) | (1L << AOR) | (1L << ALSH) | (1L << ARSH) | (1L << AUSH))) != 0)) ) {
         _errHandler.recoverInline(this);
         } else {
           consume();
         }
-        setState(208);
+        setState(174);
         expression(1);
+         ((AssignmentContext)_localctx).s =  false; 
         }
         break;
-      case 4:
+      case 2:
         {
-        _localctx = new PrecedenceContext(_localctx);
+        _localctx = new SingleContext(_localctx);
         _ctx = _localctx;
         _prevctx = _localctx;
-        setState(210);
-        match(LP);
-        setState(211);
-        expression(0);
-        setState(212);
-        match(RP);
-        }
-        break;
-      case 5:
-        {
-        _localctx = new NumericContext(_localctx);
-        _ctx = _localctx;
-        _prevctx = _localctx;
-        setState(214);
-        _la = _input.LA(1);
-        if ( !(((((_la - 63)) & ~0x3f) == 0 && ((1L << (_la - 63)) & ((1L << (OCTAL - 63)) | (1L << (HEX - 63)) | (1L << (INTEGER - 63)) | (1L << (DECIMAL - 63)))) != 0)) ) {
-        _errHandler.recoverInline(this);
-        } else {
-          consume();
-        }
-        }
-        break;
-      case 6:
-        {
-        _localctx = new TrueContext(_localctx);
-        _ctx = _localctx;
-        _prevctx = _localctx;
-        setState(215);
-        match(TRUE);
-        }
-        break;
-      case 7:
-        {
-        _localctx = new FalseContext(_localctx);
-        _ctx = _localctx;
-        _prevctx = _localctx;
-        setState(216);
-        match(FALSE);
-        }
-        break;
-      case 8:
-        {
-        _localctx = new NullContext(_localctx);
-        _ctx = _localctx;
-        _prevctx = _localctx;
-        setState(217);
-        match(NULL);
-        }
-        break;
-      case 9:
-        {
-        _localctx = new PostincContext(_localctx);
-        _ctx = _localctx;
-        _prevctx = _localctx;
-        setState(218);
-        chain();
-        setState(219);
-        _la = _input.LA(1);
-        if ( !(_la==INCR || _la==DECR) ) {
-        _errHandler.recoverInline(this);
-        } else {
-          consume();
-        }
-        }
-        break;
-      case 10:
-        {
-        _localctx = new PreincContext(_localctx);
-        _ctx = _localctx;
-        _prevctx = _localctx;
-        setState(221);
-        _la = _input.LA(1);
-        if ( !(_la==INCR || _la==DECR) ) {
-        _errHandler.recoverInline(this);
-        } else {
-          consume();
-        }
-        setState(222);
-        chain();
-        }
-        break;
-      case 11:
-        {
-        _localctx = new ReadContext(_localctx);
-        _ctx = _localctx;
-        _prevctx = _localctx;
-        setState(223);
-        chain();
+        setState(177);
+        ((SingleContext)_localctx).u = unary(false);
+         ((SingleContext)_localctx).s =  ((SingleContext)_localctx).u.s; 
         }
         break;
       }
       _ctx.stop = _input.LT(-1);
-      setState(264);
+      setState(241);
       _errHandler.sync(this);
-      _alt = getInterpreter().adaptivePredict(_input,21,_ctx);
+      _alt = getInterpreter().adaptivePredict(_input,17,_ctx);
       while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
         if ( _alt==1 ) {
           if ( _parseListeners!=null ) triggerExitRuleEvent();
           _prevctx = _localctx;
           {
-          setState(262);
-          switch ( getInterpreter().adaptivePredict(_input,20,_ctx) ) {
+          setState(239);
+          switch ( getInterpreter().adaptivePredict(_input,16,_ctx) ) {
           case 1:
             {
             _localctx = new BinaryContext(new ExpressionContext(_parentctx, _parentState));
             pushNewRecursionContext(_localctx, _startState, RULE_expression);
-            setState(226);
+            setState(182);
             if (!(precpred(_ctx, 12))) throw new FailedPredicateException(this, "precpred(_ctx, 12)");
-            setState(227);
+            setState(183);
             _la = _input.LA(1);
             if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << MUL) | (1L << DIV) | (1L << REM))) != 0)) ) {
             _errHandler.recoverInline(this);
             } else {
               consume();
             }
-            setState(228);
+            setState(184);
             expression(13);
+             ((BinaryContext)_localctx).s =  false; 
             }
             break;
           case 2:
             {
             _localctx = new BinaryContext(new ExpressionContext(_parentctx, _parentState));
             pushNewRecursionContext(_localctx, _startState, RULE_expression);
-            setState(229);
+            setState(187);
             if (!(precpred(_ctx, 11))) throw new FailedPredicateException(this, "precpred(_ctx, 11)");
-            setState(230);
+            setState(188);
             _la = _input.LA(1);
             if ( !(_la==ADD || _la==SUB) ) {
             _errHandler.recoverInline(this);
             } else {
               consume();
             }
-            setState(231);
+            setState(189);
             expression(12);
+             ((BinaryContext)_localctx).s =  false; 
             }
             break;
           case 3:
             {
             _localctx = new BinaryContext(new ExpressionContext(_parentctx, _parentState));
             pushNewRecursionContext(_localctx, _startState, RULE_expression);
-            setState(232);
+            setState(192);
             if (!(precpred(_ctx, 10))) throw new FailedPredicateException(this, "precpred(_ctx, 10)");
-            setState(233);
+            setState(193);
             _la = _input.LA(1);
             if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LSH) | (1L << RSH) | (1L << USH))) != 0)) ) {
             _errHandler.recoverInline(this);
             } else {
               consume();
             }
-            setState(234);
+            setState(194);
             expression(11);
+             ((BinaryContext)_localctx).s =  false; 
             }
             break;
           case 4:
             {
             _localctx = new CompContext(new ExpressionContext(_parentctx, _parentState));
             pushNewRecursionContext(_localctx, _startState, RULE_expression);
-            setState(235);
+            setState(197);
             if (!(precpred(_ctx, 9))) throw new FailedPredicateException(this, "precpred(_ctx, 9)");
-            setState(236);
+            setState(198);
             _la = _input.LA(1);
             if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LT) | (1L << LTE) | (1L << GT) | (1L << GTE))) != 0)) ) {
             _errHandler.recoverInline(this);
             } else {
               consume();
             }
-            setState(237);
+            setState(199);
             expression(10);
+             ((CompContext)_localctx).s =  false; 
             }
             break;
           case 5:
             {
             _localctx = new CompContext(new ExpressionContext(_parentctx, _parentState));
             pushNewRecursionContext(_localctx, _startState, RULE_expression);
-            setState(238);
+            setState(202);
             if (!(precpred(_ctx, 8))) throw new FailedPredicateException(this, "precpred(_ctx, 8)");
-            setState(239);
+            setState(203);
             _la = _input.LA(1);
             if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EQ) | (1L << EQR) | (1L << NE) | (1L << NER))) != 0)) ) {
             _errHandler.recoverInline(this);
             } else {
               consume();
             }
-            setState(240);
+            setState(204);
             expression(9);
+             ((CompContext)_localctx).s =  false; 
             }
             break;
           case 6:
             {
             _localctx = new BinaryContext(new ExpressionContext(_parentctx, _parentState));
             pushNewRecursionContext(_localctx, _startState, RULE_expression);
-            setState(241);
+            setState(207);
             if (!(precpred(_ctx, 7))) throw new FailedPredicateException(this, "precpred(_ctx, 7)");
-            setState(242);
+            setState(208);
             match(BWAND);
-            setState(243);
+            setState(209);
             expression(8);
+             ((BinaryContext)_localctx).s =  false; 
             }
             break;
           case 7:
             {
             _localctx = new BinaryContext(new ExpressionContext(_parentctx, _parentState));
             pushNewRecursionContext(_localctx, _startState, RULE_expression);
-            setState(244);
+            setState(212);
             if (!(precpred(_ctx, 6))) throw new FailedPredicateException(this, "precpred(_ctx, 6)");
-            setState(245);
+            setState(213);
             match(XOR);
-            setState(246);
+            setState(214);
             expression(7);
+             ((BinaryContext)_localctx).s =  false; 
             }
             break;
           case 8:
             {
             _localctx = new BinaryContext(new ExpressionContext(_parentctx, _parentState));
             pushNewRecursionContext(_localctx, _startState, RULE_expression);
-            setState(247);
+            setState(217);
             if (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, "precpred(_ctx, 5)");
-            setState(248);
+            setState(218);
             match(BWOR);
-            setState(249);
+            setState(219);
             expression(6);
+             ((BinaryContext)_localctx).s =  false; 
             }
             break;
           case 9:
             {
             _localctx = new BoolContext(new ExpressionContext(_parentctx, _parentState));
             pushNewRecursionContext(_localctx, _startState, RULE_expression);
-            setState(250);
+            setState(222);
             if (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, "precpred(_ctx, 4)");
-            setState(251);
+            setState(223);
             match(BOOLAND);
-            setState(252);
+            setState(224);
             expression(5);
+             ((BoolContext)_localctx).s =  false; 
             }
             break;
           case 10:
             {
             _localctx = new BoolContext(new ExpressionContext(_parentctx, _parentState));
             pushNewRecursionContext(_localctx, _startState, RULE_expression);
-            setState(253);
+            setState(227);
             if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, "precpred(_ctx, 3)");
-            setState(254);
+            setState(228);
             match(BOOLOR);
-            setState(255);
+            setState(229);
             expression(4);
+             ((BoolContext)_localctx).s =  false; 
             }
             break;
           case 11:
             {
             _localctx = new ConditionalContext(new ExpressionContext(_parentctx, _parentState));
             pushNewRecursionContext(_localctx, _startState, RULE_expression);
-            setState(256);
+            setState(232);
             if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, "precpred(_ctx, 2)");
-            setState(257);
+            setState(233);
             match(COND);
-            setState(258);
-            expression(0);
-            setState(259);
+            setState(234);
+            ((ConditionalContext)_localctx).e0 = expression(0);
+            setState(235);
             match(COLON);
-            setState(260);
-            expression(2);
+            setState(236);
+            ((ConditionalContext)_localctx).e1 = expression(2);
+             ((ConditionalContext)_localctx).s =  ((ConditionalContext)_localctx).e0.s && ((ConditionalContext)_localctx).e1.s; 
             }
             break;
           }
           } 
         }
-        setState(266);
+        setState(243);
         _errHandler.sync(this);
-        _alt = getInterpreter().adaptivePredict(_input,21,_ctx);
+        _alt = getInterpreter().adaptivePredict(_input,17,_ctx);
       }
       }
     }
@@ -1896,180 +1506,262 @@ private ExpressionContext expression(int _p) throws RecognitionException {
     return _localctx;
   }
 
-  public static class ChainContext extends ParserRuleContext {
-    public LinkprecContext linkprec() {
-      return getRuleContext(LinkprecContext.class,0);
+  public static class UnaryContext extends ParserRuleContext {
+    public boolean c;
+    public boolean s =  true;
+    public UnaryContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }
+    public UnaryContext(ParserRuleContext parent, int invokingState, boolean c) {
+      super(parent, invokingState);
+      this.c = c;
     }
-    public LinkcastContext linkcast() {
-      return getRuleContext(LinkcastContext.class,0);
+    @Override public int getRuleIndex() { return RULE_unary; }
+   
+    public UnaryContext() { }
+    public void copyFrom(UnaryContext ctx) {
+      super.copyFrom(ctx);
+      this.c = ctx.c;
+      this.s = ctx.s;
     }
-    public LinkvarContext linkvar() {
-      return getRuleContext(LinkvarContext.class,0);
+  }
+  public static class CastContext extends UnaryContext {
+    public TerminalNode LP() { return getToken(PainlessParser.LP, 0); }
+    public DecltypeContext decltype() {
+      return getRuleContext(DecltypeContext.class,0);
     }
-    public LinknewContext linknew() {
-      return getRuleContext(LinknewContext.class,0);
+    public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
+    public UnaryContext unary() {
+      return getRuleContext(UnaryContext.class,0);
     }
-    public LinkstringContext linkstring() {
-      return getRuleContext(LinkstringContext.class,0);
+    public CastContext(UnaryContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitCast(this);
+      else return visitor.visitChildren(this);
     }
-    public ChainContext(ParserRuleContext parent, int invokingState) {
-      super(parent, invokingState);
+  }
+  public static class PreContext extends UnaryContext {
+    public ChainContext chain() {
+      return getRuleContext(ChainContext.class,0);
     }
-    @Override public int getRuleIndex() { return RULE_chain; }
+    public TerminalNode INCR() { return getToken(PainlessParser.INCR, 0); }
+    public TerminalNode DECR() { return getToken(PainlessParser.DECR, 0); }
+    public PreContext(UnaryContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitChain(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitPre(this);
       else return visitor.visitChildren(this);
     }
   }
-
-  public final ChainContext chain() throws RecognitionException {
-    ChainContext _localctx = new ChainContext(_ctx, getState());
-    enterRule(_localctx, 28, RULE_chain);
-    try {
-      setState(272);
-      switch ( getInterpreter().adaptivePredict(_input,22,_ctx) ) {
-      case 1:
-        enterOuterAlt(_localctx, 1);
-        {
-        setState(267);
-        linkprec();
-        }
-        break;
-      case 2:
-        enterOuterAlt(_localctx, 2);
-        {
-        setState(268);
-        linkcast();
-        }
-        break;
-      case 3:
-        enterOuterAlt(_localctx, 3);
-        {
-        setState(269);
-        linkvar();
-        }
-        break;
-      case 4:
-        enterOuterAlt(_localctx, 4);
-        {
-        setState(270);
-        linknew();
-        }
-        break;
-      case 5:
-        enterOuterAlt(_localctx, 5);
-        {
-        setState(271);
-        linkstring();
-        }
-        break;
-      }
-    }
-    catch (RecognitionException re) {
-      _localctx.exception = re;
-      _errHandler.reportError(this, re);
-      _errHandler.recover(this, re);
+  public static class ReadContext extends UnaryContext {
+    public ChainContext chain() {
+      return getRuleContext(ChainContext.class,0);
     }
-    finally {
-      exitRule();
+    public ReadContext(UnaryContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitRead(this);
+      else return visitor.visitChildren(this);
     }
-    return _localctx;
   }
-
-  public static class LinkprecContext extends ParserRuleContext {
-    public TerminalNode LP() { return getToken(PainlessParser.LP, 0); }
-    public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
-    public LinkprecContext linkprec() {
-      return getRuleContext(LinkprecContext.class,0);
-    }
-    public LinkcastContext linkcast() {
-      return getRuleContext(LinkcastContext.class,0);
+  public static class PostContext extends UnaryContext {
+    public ChainContext chain() {
+      return getRuleContext(ChainContext.class,0);
     }
-    public LinkvarContext linkvar() {
-      return getRuleContext(LinkvarContext.class,0);
+    public TerminalNode INCR() { return getToken(PainlessParser.INCR, 0); }
+    public TerminalNode DECR() { return getToken(PainlessParser.DECR, 0); }
+    public PostContext(UnaryContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitPost(this);
+      else return visitor.visitChildren(this);
     }
-    public LinknewContext linknew() {
-      return getRuleContext(LinknewContext.class,0);
+  }
+  public static class NullContext extends UnaryContext {
+    public TerminalNode NULL() { return getToken(PainlessParser.NULL, 0); }
+    public NullContext(UnaryContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitNull(this);
+      else return visitor.visitChildren(this);
     }
-    public LinkstringContext linkstring() {
-      return getRuleContext(LinkstringContext.class,0);
+  }
+  public static class TrueContext extends UnaryContext {
+    public TerminalNode TRUE() { return getToken(PainlessParser.TRUE, 0); }
+    public TrueContext(UnaryContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitTrue(this);
+      else return visitor.visitChildren(this);
     }
-    public LinkdotContext linkdot() {
-      return getRuleContext(LinkdotContext.class,0);
+  }
+  public static class FalseContext extends UnaryContext {
+    public TerminalNode FALSE() { return getToken(PainlessParser.FALSE, 0); }
+    public FalseContext(UnaryContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitFalse(this);
+      else return visitor.visitChildren(this);
     }
-    public LinkbraceContext linkbrace() {
-      return getRuleContext(LinkbraceContext.class,0);
+  }
+  public static class NumericContext extends UnaryContext {
+    public TerminalNode OCTAL() { return getToken(PainlessParser.OCTAL, 0); }
+    public TerminalNode HEX() { return getToken(PainlessParser.HEX, 0); }
+    public TerminalNode INTEGER() { return getToken(PainlessParser.INTEGER, 0); }
+    public TerminalNode DECIMAL() { return getToken(PainlessParser.DECIMAL, 0); }
+    public NumericContext(UnaryContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitNumeric(this);
+      else return visitor.visitChildren(this);
     }
-    public LinkprecContext(ParserRuleContext parent, int invokingState) {
-      super(parent, invokingState);
+  }
+  public static class OperatorContext extends UnaryContext {
+    public UnaryContext unary() {
+      return getRuleContext(UnaryContext.class,0);
     }
-    @Override public int getRuleIndex() { return RULE_linkprec; }
+    public TerminalNode BOOLNOT() { return getToken(PainlessParser.BOOLNOT, 0); }
+    public TerminalNode BWNOT() { return getToken(PainlessParser.BWNOT, 0); }
+    public TerminalNode ADD() { return getToken(PainlessParser.ADD, 0); }
+    public TerminalNode SUB() { return getToken(PainlessParser.SUB, 0); }
+    public OperatorContext(UnaryContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitLinkprec(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitOperator(this);
       else return visitor.visitChildren(this);
     }
   }
 
-  public final LinkprecContext linkprec() throws RecognitionException {
-    LinkprecContext _localctx = new LinkprecContext(_ctx, getState());
-    enterRule(_localctx, 30, RULE_linkprec);
+  public final UnaryContext unary(boolean c) throws RecognitionException {
+    UnaryContext _localctx = new UnaryContext(_ctx, getState(), c);
+    enterRule(_localctx, 26, RULE_unary);
+    int _la;
     try {
-      enterOuterAlt(_localctx, 1);
-      {
-      setState(274);
-      match(LP);
-      setState(280);
-      switch ( getInterpreter().adaptivePredict(_input,23,_ctx) ) {
+      setState(273);
+      switch ( getInterpreter().adaptivePredict(_input,18,_ctx) ) {
       case 1:
+        _localctx = new PreContext(_localctx);
+        enterOuterAlt(_localctx, 1);
         {
-        setState(275);
-        linkprec();
+        setState(244);
+        if (!( !_localctx.c )) throw new FailedPredicateException(this, " !$c ");
+        setState(245);
+        _la = _input.LA(1);
+        if ( !(_la==INCR || _la==DECR) ) {
+        _errHandler.recoverInline(this);
+        } else {
+          consume();
+        }
+        setState(246);
+        chain(true);
         }
         break;
       case 2:
+        _localctx = new PostContext(_localctx);
+        enterOuterAlt(_localctx, 2);
         {
-        setState(276);
-        linkcast();
+        setState(247);
+        if (!( !_localctx.c )) throw new FailedPredicateException(this, " !$c ");
+        setState(248);
+        chain(true);
+        setState(249);
+        _la = _input.LA(1);
+        if ( !(_la==INCR || _la==DECR) ) {
+        _errHandler.recoverInline(this);
+        } else {
+          consume();
+        }
         }
         break;
       case 3:
+        _localctx = new ReadContext(_localctx);
+        enterOuterAlt(_localctx, 3);
         {
-        setState(277);
-        linkvar();
+        setState(251);
+        if (!( !_localctx.c )) throw new FailedPredicateException(this, " !$c ");
+        setState(252);
+        chain(false);
         }
         break;
       case 4:
+        _localctx = new NumericContext(_localctx);
+        enterOuterAlt(_localctx, 4);
         {
-        setState(278);
-        linknew();
+        setState(253);
+        if (!( !_localctx.c )) throw new FailedPredicateException(this, " !$c ");
+        setState(254);
+        _la = _input.LA(1);
+        if ( !(((((_la - 63)) & ~0x3f) == 0 && ((1L << (_la - 63)) & ((1L << (OCTAL - 63)) | (1L << (HEX - 63)) | (1L << (INTEGER - 63)) | (1L << (DECIMAL - 63)))) != 0)) ) {
+        _errHandler.recoverInline(this);
+        } else {
+          consume();
+        }
+         ((NumericContext)_localctx).s =  false; 
         }
         break;
       case 5:
+        _localctx = new TrueContext(_localctx);
+        enterOuterAlt(_localctx, 5);
         {
-        setState(279);
-        linkstring();
+        setState(256);
+        if (!( !_localctx.c )) throw new FailedPredicateException(this, " !$c ");
+        setState(257);
+        match(TRUE);
+         ((TrueContext)_localctx).s =  false; 
         }
         break;
-      }
-      setState(282);
-      match(RP);
-      setState(285);
-      switch ( getInterpreter().adaptivePredict(_input,24,_ctx) ) {
-      case 1:
+      case 6:
+        _localctx = new FalseContext(_localctx);
+        enterOuterAlt(_localctx, 6);
         {
-        setState(283);
-        linkdot();
+        setState(259);
+        if (!( !_localctx.c )) throw new FailedPredicateException(this, " !$c ");
+        setState(260);
+        match(FALSE);
+         ((FalseContext)_localctx).s =  false; 
         }
         break;
-      case 2:
+      case 7:
+        _localctx = new NullContext(_localctx);
+        enterOuterAlt(_localctx, 7);
         {
-        setState(284);
-        linkbrace();
+        setState(262);
+        if (!( !_localctx.c )) throw new FailedPredicateException(this, " !$c ");
+        setState(263);
+        match(NULL);
+         ((NullContext)_localctx).s =  false; 
+        }
+        break;
+      case 8:
+        _localctx = new OperatorContext(_localctx);
+        enterOuterAlt(_localctx, 8);
+        {
+        setState(265);
+        if (!( !_localctx.c )) throw new FailedPredicateException(this, " !$c ");
+        setState(266);
+        _la = _input.LA(1);
+        if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB))) != 0)) ) {
+        _errHandler.recoverInline(this);
+        } else {
+          consume();
+        }
+        setState(267);
+        unary(false);
+        }
+        break;
+      case 9:
+        _localctx = new CastContext(_localctx);
+        enterOuterAlt(_localctx, 9);
+        {
+        setState(268);
+        match(LP);
+        setState(269);
+        decltype();
+        setState(270);
+        match(RP);
+        setState(271);
+        unary(_localctx.c);
         }
         break;
-      }
       }
     }
     catch (RecognitionException re) {
@@ -2083,202 +1775,210 @@ public final LinkprecContext linkprec() throws RecognitionException {
     return _localctx;
   }
 
-  public static class LinkcastContext extends ParserRuleContext {
-    public TerminalNode LP() { return getToken(PainlessParser.LP, 0); }
+  public static class ChainContext extends ParserRuleContext {
+    public boolean c;
+    public ChainContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }
+    public ChainContext(ParserRuleContext parent, int invokingState, boolean c) {
+      super(parent, invokingState);
+      this.c = c;
+    }
+    @Override public int getRuleIndex() { return RULE_chain; }
+   
+    public ChainContext() { }
+    public void copyFrom(ChainContext ctx) {
+      super.copyFrom(ctx);
+      this.c = ctx.c;
+    }
+  }
+  public static class StaticContext extends ChainContext {
     public DecltypeContext decltype() {
       return getRuleContext(DecltypeContext.class,0);
     }
-    public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
-    public LinkprecContext linkprec() {
-      return getRuleContext(LinkprecContext.class,0);
+    public DotContext dot() {
+      return getRuleContext(DotContext.class,0);
+    }
+    public List<SecondaryContext> secondary() {
+      return getRuleContexts(SecondaryContext.class);
     }
-    public LinkcastContext linkcast() {
-      return getRuleContext(LinkcastContext.class,0);
+    public SecondaryContext secondary(int i) {
+      return getRuleContext(SecondaryContext.class,i);
     }
-    public LinkvarContext linkvar() {
-      return getRuleContext(LinkvarContext.class,0);
+    public StaticContext(ChainContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitStatic(this);
+      else return visitor.visitChildren(this);
     }
-    public LinknewContext linknew() {
-      return getRuleContext(LinknewContext.class,0);
+  }
+  public static class DynamicContext extends ChainContext {
+    public PrimaryContext p;
+    public PrimaryContext primary() {
+      return getRuleContext(PrimaryContext.class,0);
     }
-    public LinkstringContext linkstring() {
-      return getRuleContext(LinkstringContext.class,0);
+    public List<SecondaryContext> secondary() {
+      return getRuleContexts(SecondaryContext.class);
     }
-    public LinkcastContext(ParserRuleContext parent, int invokingState) {
-      super(parent, invokingState);
+    public SecondaryContext secondary(int i) {
+      return getRuleContext(SecondaryContext.class,i);
     }
-    @Override public int getRuleIndex() { return RULE_linkcast; }
+    public DynamicContext(ChainContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitLinkcast(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitDynamic(this);
       else return visitor.visitChildren(this);
     }
   }
-
-  public final LinkcastContext linkcast() throws RecognitionException {
-    LinkcastContext _localctx = new LinkcastContext(_ctx, getState());
-    enterRule(_localctx, 32, RULE_linkcast);
-    try {
-      enterOuterAlt(_localctx, 1);
-      {
-      setState(287);
-      match(LP);
-      setState(288);
-      decltype();
-      setState(289);
-      match(RP);
-      setState(295);
-      switch ( getInterpreter().adaptivePredict(_input,25,_ctx) ) {
-      case 1:
-        {
-        setState(290);
-        linkprec();
-        }
-        break;
-      case 2:
-        {
-        setState(291);
-        linkcast();
-        }
-        break;
-      case 3:
-        {
-        setState(292);
-        linkvar();
-        }
-        break;
-      case 4:
-        {
-        setState(293);
-        linknew();
-        }
-        break;
-      case 5:
-        {
-        setState(294);
-        linkstring();
-        }
-        break;
-      }
-      }
+  public static class NewarrayContext extends ChainContext {
+    public TerminalNode NEW() { return getToken(PainlessParser.NEW, 0); }
+    public TerminalNode TYPE() { return getToken(PainlessParser.TYPE, 0); }
+    public List<TerminalNode> LBRACE() { return getTokens(PainlessParser.LBRACE); }
+    public TerminalNode LBRACE(int i) {
+      return getToken(PainlessParser.LBRACE, i);
     }
-    catch (RecognitionException re) {
-      _localctx.exception = re;
-      _errHandler.reportError(this, re);
-      _errHandler.recover(this, re);
+    public List<ExpressionContext> expression() {
+      return getRuleContexts(ExpressionContext.class);
     }
-    finally {
-      exitRule();
+    public ExpressionContext expression(int i) {
+      return getRuleContext(ExpressionContext.class,i);
     }
-    return _localctx;
-  }
-
-  public static class LinkbraceContext extends ParserRuleContext {
-    public TerminalNode LBRACE() { return getToken(PainlessParser.LBRACE, 0); }
-    public ExpressionContext expression() {
-      return getRuleContext(ExpressionContext.class,0);
+    public List<TerminalNode> RBRACE() { return getTokens(PainlessParser.RBRACE); }
+    public TerminalNode RBRACE(int i) {
+      return getToken(PainlessParser.RBRACE, i);
     }
-    public TerminalNode RBRACE() { return getToken(PainlessParser.RBRACE, 0); }
-    public LinkdotContext linkdot() {
-      return getRuleContext(LinkdotContext.class,0);
+    public DotContext dot() {
+      return getRuleContext(DotContext.class,0);
     }
-    public LinkbraceContext linkbrace() {
-      return getRuleContext(LinkbraceContext.class,0);
+    public List<SecondaryContext> secondary() {
+      return getRuleContexts(SecondaryContext.class);
     }
-    public LinkbraceContext(ParserRuleContext parent, int invokingState) {
-      super(parent, invokingState);
+    public SecondaryContext secondary(int i) {
+      return getRuleContext(SecondaryContext.class,i);
     }
-    @Override public int getRuleIndex() { return RULE_linkbrace; }
+    public NewarrayContext(ChainContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitLinkbrace(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitNewarray(this);
       else return visitor.visitChildren(this);
     }
   }
 
-  public final LinkbraceContext linkbrace() throws RecognitionException {
-    LinkbraceContext _localctx = new LinkbraceContext(_ctx, getState());
-    enterRule(_localctx, 34, RULE_linkbrace);
+  public final ChainContext chain(boolean c) throws RecognitionException {
+    ChainContext _localctx = new ChainContext(_ctx, getState(), c);
+    enterRule(_localctx, 28, RULE_chain);
     try {
-      enterOuterAlt(_localctx, 1);
-      {
-      setState(297);
-      match(LBRACE);
-      setState(298);
-      expression(0);
-      setState(299);
-      match(RBRACE);
-      setState(302);
-      switch ( getInterpreter().adaptivePredict(_input,26,_ctx) ) {
+      int _alt;
+      setState(309);
+      switch ( getInterpreter().adaptivePredict(_input,24,_ctx) ) {
       case 1:
+        _localctx = new DynamicContext(_localctx);
+        enterOuterAlt(_localctx, 1);
         {
-        setState(300);
-        linkdot();
+        setState(275);
+        ((DynamicContext)_localctx).p = primary(_localctx.c);
+        setState(279);
+        _errHandler.sync(this);
+        _alt = getInterpreter().adaptivePredict(_input,19,_ctx);
+        while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
+          if ( _alt==1 ) {
+            {
+            {
+            setState(276);
+            secondary(((DynamicContext)_localctx).p.s);
+            }
+            } 
+          }
+          setState(281);
+          _errHandler.sync(this);
+          _alt = getInterpreter().adaptivePredict(_input,19,_ctx);
+        }
         }
         break;
       case 2:
+        _localctx = new StaticContext(_localctx);
+        enterOuterAlt(_localctx, 2);
         {
-        setState(301);
-        linkbrace();
+        setState(282);
+        decltype();
+        setState(283);
+        dot();
+        setState(287);
+        _errHandler.sync(this);
+        _alt = getInterpreter().adaptivePredict(_input,20,_ctx);
+        while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
+          if ( _alt==1 ) {
+            {
+            {
+            setState(284);
+            secondary(true);
+            }
+            } 
+          }
+          setState(289);
+          _errHandler.sync(this);
+          _alt = getInterpreter().adaptivePredict(_input,20,_ctx);
+        }
         }
         break;
-      }
-      }
-    }
-    catch (RecognitionException re) {
-      _localctx.exception = re;
-      _errHandler.reportError(this, re);
-      _errHandler.recover(this, re);
-    }
-    finally {
-      exitRule();
-    }
-    return _localctx;
-  }
-
-  public static class LinkdotContext extends ParserRuleContext {
-    public TerminalNode DOT() { return getToken(PainlessParser.DOT, 0); }
-    public LinkcallContext linkcall() {
-      return getRuleContext(LinkcallContext.class,0);
-    }
-    public LinkfieldContext linkfield() {
-      return getRuleContext(LinkfieldContext.class,0);
-    }
-    public LinkdotContext(ParserRuleContext parent, int invokingState) {
-      super(parent, invokingState);
-    }
-    @Override public int getRuleIndex() { return RULE_linkdot; }
-    @Override
-    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitLinkdot(this);
-      else return visitor.visitChildren(this);
-    }
-  }
-
-  public final LinkdotContext linkdot() throws RecognitionException {
-    LinkdotContext _localctx = new LinkdotContext(_ctx, getState());
-    enterRule(_localctx, 36, RULE_linkdot);
-    try {
-      enterOuterAlt(_localctx, 1);
-      {
-      setState(304);
-      match(DOT);
-      setState(307);
-      switch ( getInterpreter().adaptivePredict(_input,27,_ctx) ) {
-      case 1:
+      case 3:
+        _localctx = new NewarrayContext(_localctx);
+        enterOuterAlt(_localctx, 3);
         {
-        setState(305);
-        linkcall();
+        setState(290);
+        match(NEW);
+        setState(291);
+        match(TYPE);
+        setState(296); 
+        _errHandler.sync(this);
+        _alt = 1;
+        do {
+          switch (_alt) {
+          case 1:
+            {
+            {
+            setState(292);
+            match(LBRACE);
+            setState(293);
+            expression(0);
+            setState(294);
+            match(RBRACE);
+            }
+            }
+            break;
+          default:
+            throw new NoViableAltException(this);
+          }
+          setState(298); 
+          _errHandler.sync(this);
+          _alt = getInterpreter().adaptivePredict(_input,21,_ctx);
+        } while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );
+        setState(307);
+        switch ( getInterpreter().adaptivePredict(_input,23,_ctx) ) {
+        case 1:
+          {
+          setState(300);
+          dot();
+          setState(304);
+          _errHandler.sync(this);
+          _alt = getInterpreter().adaptivePredict(_input,22,_ctx);
+          while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
+            if ( _alt==1 ) {
+              {
+              {
+              setState(301);
+              secondary(true);
+              }
+              } 
+            }
+            setState(306);
+            _errHandler.sync(this);
+            _alt = getInterpreter().adaptivePredict(_input,22,_ctx);
+          }
+          }
+          break;
         }
-        break;
-      case 2:
-        {
-        setState(306);
-        linkfield();
         }
         break;
       }
-      }
     }
     catch (RecognitionException re) {
       _localctx.exception = re;
@@ -2291,110 +1991,145 @@ public final LinkdotContext linkdot() throws RecognitionException {
     return _localctx;
   }
 
-  public static class LinkcallContext extends ParserRuleContext {
-    public TerminalNode EXTID() { return getToken(PainlessParser.EXTID, 0); }
-    public ArgumentsContext arguments() {
-      return getRuleContext(ArgumentsContext.class,0);
-    }
-    public LinkdotContext linkdot() {
-      return getRuleContext(LinkdotContext.class,0);
-    }
-    public LinkbraceContext linkbrace() {
-      return getRuleContext(LinkbraceContext.class,0);
-    }
-    public LinkcallContext(ParserRuleContext parent, int invokingState) {
+  public static class PrimaryContext extends ParserRuleContext {
+    public boolean c;
+    public boolean s =  true;
+    public PrimaryContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }
+    public PrimaryContext(ParserRuleContext parent, int invokingState, boolean c) {
       super(parent, invokingState);
+      this.c = c;
+    }
+    @Override public int getRuleIndex() { return RULE_primary; }
+   
+    public PrimaryContext() { }
+    public void copyFrom(PrimaryContext ctx) {
+      super.copyFrom(ctx);
+      this.c = ctx.c;
+      this.s = ctx.s;
     }
-    @Override public int getRuleIndex() { return RULE_linkcall; }
+  }
+  public static class StringContext extends PrimaryContext {
+    public TerminalNode STRING() { return getToken(PainlessParser.STRING, 0); }
+    public StringContext(PrimaryContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitLinkcall(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitString(this);
       else return visitor.visitChildren(this);
     }
   }
-
-  public final LinkcallContext linkcall() throws RecognitionException {
-    LinkcallContext _localctx = new LinkcallContext(_ctx, getState());
-    enterRule(_localctx, 38, RULE_linkcall);
-    try {
-      enterOuterAlt(_localctx, 1);
-      {
-      setState(309);
-      match(EXTID);
-      setState(310);
-      arguments();
-      setState(313);
-      switch ( getInterpreter().adaptivePredict(_input,28,_ctx) ) {
-      case 1:
-        {
-        setState(311);
-        linkdot();
-        }
-        break;
-      case 2:
-        {
-        setState(312);
-        linkbrace();
-        }
-        break;
-      }
-      }
+  public static class VariableContext extends PrimaryContext {
+    public TerminalNode ID() { return getToken(PainlessParser.ID, 0); }
+    public VariableContext(PrimaryContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitVariable(this);
+      else return visitor.visitChildren(this);
     }
-    catch (RecognitionException re) {
-      _localctx.exception = re;
-      _errHandler.reportError(this, re);
-      _errHandler.recover(this, re);
+  }
+  public static class ExprprecContext extends PrimaryContext {
+    public ExpressionContext e;
+    public TerminalNode LP() { return getToken(PainlessParser.LP, 0); }
+    public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
+    public ExpressionContext expression() {
+      return getRuleContext(ExpressionContext.class,0);
     }
-    finally {
-      exitRule();
+    public ExprprecContext(PrimaryContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitExprprec(this);
+      else return visitor.visitChildren(this);
     }
-    return _localctx;
   }
-
-  public static class LinkvarContext extends ParserRuleContext {
-    public IdentifierContext identifier() {
-      return getRuleContext(IdentifierContext.class,0);
-    }
-    public LinkdotContext linkdot() {
-      return getRuleContext(LinkdotContext.class,0);
+  public static class NewobjectContext extends PrimaryContext {
+    public TerminalNode NEW() { return getToken(PainlessParser.NEW, 0); }
+    public TerminalNode TYPE() { return getToken(PainlessParser.TYPE, 0); }
+    public ArgumentsContext arguments() {
+      return getRuleContext(ArgumentsContext.class,0);
     }
-    public LinkbraceContext linkbrace() {
-      return getRuleContext(LinkbraceContext.class,0);
+    public NewobjectContext(PrimaryContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitNewobject(this);
+      else return visitor.visitChildren(this);
     }
-    public LinkvarContext(ParserRuleContext parent, int invokingState) {
-      super(parent, invokingState);
+  }
+  public static class ChainprecContext extends PrimaryContext {
+    public TerminalNode LP() { return getToken(PainlessParser.LP, 0); }
+    public UnaryContext unary() {
+      return getRuleContext(UnaryContext.class,0);
     }
-    @Override public int getRuleIndex() { return RULE_linkvar; }
+    public TerminalNode RP() { return getToken(PainlessParser.RP, 0); }
+    public ChainprecContext(PrimaryContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitLinkvar(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitChainprec(this);
       else return visitor.visitChildren(this);
     }
   }
 
-  public final LinkvarContext linkvar() throws RecognitionException {
-    LinkvarContext _localctx = new LinkvarContext(_ctx, getState());
-    enterRule(_localctx, 40, RULE_linkvar);
+  public final PrimaryContext primary(boolean c) throws RecognitionException {
+    PrimaryContext _localctx = new PrimaryContext(_ctx, getState(), c);
+    enterRule(_localctx, 30, RULE_primary);
     try {
-      enterOuterAlt(_localctx, 1);
-      {
-      setState(315);
-      identifier();
-      setState(318);
-      switch ( getInterpreter().adaptivePredict(_input,29,_ctx) ) {
+      setState(327);
+      switch ( getInterpreter().adaptivePredict(_input,25,_ctx) ) {
       case 1:
+        _localctx = new ExprprecContext(_localctx);
+        enterOuterAlt(_localctx, 1);
         {
-        setState(316);
-        linkdot();
+        setState(311);
+        if (!( !_localctx.c )) throw new FailedPredicateException(this, " !$c ");
+        setState(312);
+        match(LP);
+        setState(313);
+        ((ExprprecContext)_localctx).e = expression(0);
+        setState(314);
+        match(RP);
+         ((ExprprecContext)_localctx).s =  ((ExprprecContext)_localctx).e.s; 
         }
         break;
       case 2:
+        _localctx = new ChainprecContext(_localctx);
+        enterOuterAlt(_localctx, 2);
         {
         setState(317);
-        linkbrace();
+        if (!( _localctx.c )) throw new FailedPredicateException(this, " $c ");
+        setState(318);
+        match(LP);
+        setState(319);
+        unary(true);
+        setState(320);
+        match(RP);
+        }
+        break;
+      case 3:
+        _localctx = new StringContext(_localctx);
+        enterOuterAlt(_localctx, 3);
+        {
+        setState(322);
+        match(STRING);
+        }
+        break;
+      case 4:
+        _localctx = new VariableContext(_localctx);
+        enterOuterAlt(_localctx, 4);
+        {
+        setState(323);
+        match(ID);
+        }
+        break;
+      case 5:
+        _localctx = new NewobjectContext(_localctx);
+        enterOuterAlt(_localctx, 5);
+        {
+        setState(324);
+        match(NEW);
+        setState(325);
+        match(TYPE);
+        setState(326);
+        arguments();
         }
         break;
-      }
       }
     }
     catch (RecognitionException re) {
@@ -2408,56 +2143,52 @@ public final LinkvarContext linkvar() throws RecognitionException {
     return _localctx;
   }
 
-  public static class LinkfieldContext extends ParserRuleContext {
-    public TerminalNode EXTID() { return getToken(PainlessParser.EXTID, 0); }
-    public TerminalNode EXTINTEGER() { return getToken(PainlessParser.EXTINTEGER, 0); }
-    public LinkdotContext linkdot() {
-      return getRuleContext(LinkdotContext.class,0);
+  public static class SecondaryContext extends ParserRuleContext {
+    public boolean s;
+    public DotContext dot() {
+      return getRuleContext(DotContext.class,0);
     }
-    public LinkbraceContext linkbrace() {
-      return getRuleContext(LinkbraceContext.class,0);
+    public BraceContext brace() {
+      return getRuleContext(BraceContext.class,0);
     }
-    public LinkfieldContext(ParserRuleContext parent, int invokingState) {
+    public SecondaryContext(ParserRuleContext parent, int invokingState) { super(parent, invokingState); }
+    public SecondaryContext(ParserRuleContext parent, int invokingState, boolean s) {
       super(parent, invokingState);
+      this.s = s;
     }
-    @Override public int getRuleIndex() { return RULE_linkfield; }
+    @Override public int getRuleIndex() { return RULE_secondary; }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitLinkfield(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitSecondary(this);
       else return visitor.visitChildren(this);
     }
   }
 
-  public final LinkfieldContext linkfield() throws RecognitionException {
-    LinkfieldContext _localctx = new LinkfieldContext(_ctx, getState());
-    enterRule(_localctx, 42, RULE_linkfield);
-    int _la;
+  public final SecondaryContext secondary(boolean s) throws RecognitionException {
+    SecondaryContext _localctx = new SecondaryContext(_ctx, getState(), s);
+    enterRule(_localctx, 32, RULE_secondary);
     try {
-      enterOuterAlt(_localctx, 1);
-      {
-      setState(320);
-      _la = _input.LA(1);
-      if ( !(_la==EXTINTEGER || _la==EXTID) ) {
-      _errHandler.recoverInline(this);
-      } else {
-        consume();
-      }
-      setState(323);
-      switch ( getInterpreter().adaptivePredict(_input,30,_ctx) ) {
+      setState(333);
+      switch ( getInterpreter().adaptivePredict(_input,26,_ctx) ) {
       case 1:
+        enterOuterAlt(_localctx, 1);
         {
-        setState(321);
-        linkdot();
+        setState(329);
+        if (!( _localctx.s )) throw new FailedPredicateException(this, " $s ");
+        setState(330);
+        dot();
         }
         break;
       case 2:
+        enterOuterAlt(_localctx, 2);
         {
-        setState(322);
-        linkbrace();
+        setState(331);
+        if (!( _localctx.s )) throw new FailedPredicateException(this, " $s ");
+        setState(332);
+        brace();
         }
         break;
       }
-      }
     }
     catch (RecognitionException re) {
       _localctx.exception = re;
@@ -2470,114 +2201,76 @@ public final LinkfieldContext linkfield() throws RecognitionException {
     return _localctx;
   }
 
-  public static class LinknewContext extends ParserRuleContext {
-    public TerminalNode NEW() { return getToken(PainlessParser.NEW, 0); }
-    public IdentifierContext identifier() {
-      return getRuleContext(IdentifierContext.class,0);
+  public static class DotContext extends ParserRuleContext {
+    public DotContext(ParserRuleContext parent, int invokingState) {
+      super(parent, invokingState);
     }
+    @Override public int getRuleIndex() { return RULE_dot; }
+   
+    public DotContext() { }
+    public void copyFrom(DotContext ctx) {
+      super.copyFrom(ctx);
+    }
+  }
+  public static class CallinvokeContext extends DotContext {
+    public TerminalNode DOT() { return getToken(PainlessParser.DOT, 0); }
+    public TerminalNode DOTID() { return getToken(PainlessParser.DOTID, 0); }
     public ArgumentsContext arguments() {
       return getRuleContext(ArgumentsContext.class,0);
     }
-    public LinkdotContext linkdot() {
-      return getRuleContext(LinkdotContext.class,0);
-    }
-    public List<TerminalNode> LBRACE() { return getTokens(PainlessParser.LBRACE); }
-    public TerminalNode LBRACE(int i) {
-      return getToken(PainlessParser.LBRACE, i);
-    }
-    public List<ExpressionContext> expression() {
-      return getRuleContexts(ExpressionContext.class);
-    }
-    public ExpressionContext expression(int i) {
-      return getRuleContext(ExpressionContext.class,i);
-    }
-    public List<TerminalNode> RBRACE() { return getTokens(PainlessParser.RBRACE); }
-    public TerminalNode RBRACE(int i) {
-      return getToken(PainlessParser.RBRACE, i);
-    }
-    public LinknewContext(ParserRuleContext parent, int invokingState) {
-      super(parent, invokingState);
+    public CallinvokeContext(DotContext ctx) { copyFrom(ctx); }
+    @Override
+    public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitCallinvoke(this);
+      else return visitor.visitChildren(this);
     }
-    @Override public int getRuleIndex() { return RULE_linknew; }
+  }
+  public static class FieldaccessContext extends DotContext {
+    public TerminalNode DOT() { return getToken(PainlessParser.DOT, 0); }
+    public TerminalNode DOTID() { return getToken(PainlessParser.DOTID, 0); }
+    public TerminalNode DOTINTEGER() { return getToken(PainlessParser.DOTINTEGER, 0); }
+    public FieldaccessContext(DotContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitLinknew(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitFieldaccess(this);
       else return visitor.visitChildren(this);
     }
   }
 
-  public final LinknewContext linknew() throws RecognitionException {
-    LinknewContext _localctx = new LinknewContext(_ctx, getState());
-    enterRule(_localctx, 44, RULE_linknew);
+  public final DotContext dot() throws RecognitionException {
+    DotContext _localctx = new DotContext(_ctx, getState());
+    enterRule(_localctx, 34, RULE_dot);
+    int _la;
     try {
-      int _alt;
-      enterOuterAlt(_localctx, 1);
-      {
-      setState(325);
-      match(NEW);
-      setState(326);
-      identifier();
-      setState(342);
-      switch (_input.LA(1)) {
-      case LP:
-        {
+      setState(340);
+      switch ( getInterpreter().adaptivePredict(_input,27,_ctx) ) {
+      case 1:
+        _localctx = new CallinvokeContext(_localctx);
+        enterOuterAlt(_localctx, 1);
         {
-        setState(327);
+        setState(335);
+        match(DOT);
+        setState(336);
+        match(DOTID);
+        setState(337);
         arguments();
-        setState(329);
-        switch ( getInterpreter().adaptivePredict(_input,31,_ctx) ) {
-        case 1:
-          {
-          setState(328);
-          linkdot();
-          }
-          break;
-        }
-        }
         }
         break;
-      case LBRACE:
-        {
+      case 2:
+        _localctx = new FieldaccessContext(_localctx);
+        enterOuterAlt(_localctx, 2);
         {
-        setState(335); 
-        _errHandler.sync(this);
-        _alt = 1;
-        do {
-          switch (_alt) {
-          case 1:
-            {
-            {
-            setState(331);
-            match(LBRACE);
-            setState(332);
-            expression(0);
-            setState(333);
-            match(RBRACE);
-            }
-            }
-            break;
-          default:
-            throw new NoViableAltException(this);
-          }
-          setState(337); 
-          _errHandler.sync(this);
-          _alt = getInterpreter().adaptivePredict(_input,32,_ctx);
-        } while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );
-        setState(340);
-        switch ( getInterpreter().adaptivePredict(_input,33,_ctx) ) {
-        case 1:
-          {
-          setState(339);
-          linkdot();
-          }
-          break;
-        }
+        setState(338);
+        match(DOT);
+        setState(339);
+        _la = _input.LA(1);
+        if ( !(_la==DOTINTEGER || _la==DOTID) ) {
+        _errHandler.recoverInline(this);
+        } else {
+          consume();
         }
         }
         break;
-      default:
-        throw new NoViableAltException(this);
-      }
       }
     }
     catch (RecognitionException re) {
@@ -2591,48 +2284,44 @@ public final LinknewContext linknew() throws RecognitionException {
     return _localctx;
   }
 
-  public static class LinkstringContext extends ParserRuleContext {
-    public TerminalNode STRING() { return getToken(PainlessParser.STRING, 0); }
-    public LinkdotContext linkdot() {
-      return getRuleContext(LinkdotContext.class,0);
+  public static class BraceContext extends ParserRuleContext {
+    public BraceContext(ParserRuleContext parent, int invokingState) {
+      super(parent, invokingState);
     }
-    public LinkbraceContext linkbrace() {
-      return getRuleContext(LinkbraceContext.class,0);
+    @Override public int getRuleIndex() { return RULE_brace; }
+   
+    public BraceContext() { }
+    public void copyFrom(BraceContext ctx) {
+      super.copyFrom(ctx);
     }
-    public LinkstringContext(ParserRuleContext parent, int invokingState) {
-      super(parent, invokingState);
+  }
+  public static class BraceaccessContext extends BraceContext {
+    public TerminalNode LBRACE() { return getToken(PainlessParser.LBRACE, 0); }
+    public ExpressionContext expression() {
+      return getRuleContext(ExpressionContext.class,0);
     }
-    @Override public int getRuleIndex() { return RULE_linkstring; }
+    public TerminalNode RBRACE() { return getToken(PainlessParser.RBRACE, 0); }
+    public BraceaccessContext(BraceContext ctx) { copyFrom(ctx); }
     @Override
     public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
-      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitLinkstring(this);
+      if ( visitor instanceof PainlessParserVisitor ) return ((PainlessParserVisitor<? extends T>)visitor).visitBraceaccess(this);
       else return visitor.visitChildren(this);
     }
   }
 
-  public final LinkstringContext linkstring() throws RecognitionException {
-    LinkstringContext _localctx = new LinkstringContext(_ctx, getState());
-    enterRule(_localctx, 46, RULE_linkstring);
+  public final BraceContext brace() throws RecognitionException {
+    BraceContext _localctx = new BraceContext(_ctx, getState());
+    enterRule(_localctx, 36, RULE_brace);
     try {
+      _localctx = new BraceaccessContext(_localctx);
       enterOuterAlt(_localctx, 1);
       {
+      setState(342);
+      match(LBRACE);
+      setState(343);
+      expression(0);
       setState(344);
-      match(STRING);
-      setState(347);
-      switch ( getInterpreter().adaptivePredict(_input,35,_ctx) ) {
-      case 1:
-        {
-        setState(345);
-        linkdot();
-        }
-        break;
-      case 2:
-        {
-        setState(346);
-        linkbrace();
-        }
-        break;
-      }
+      match(RBRACE);
       }
     }
     catch (RecognitionException re) {
@@ -2672,40 +2361,40 @@ public ArgumentsContext(ParserRuleContext parent, int invokingState) {
 
   public final ArgumentsContext arguments() throws RecognitionException {
     ArgumentsContext _localctx = new ArgumentsContext(_ctx, getState());
-    enterRule(_localctx, 48, RULE_arguments);
+    enterRule(_localctx, 38, RULE_arguments);
     int _la;
     try {
       enterOuterAlt(_localctx, 1);
       {
       {
-      setState(349);
+      setState(346);
       match(LP);
-      setState(358);
-      _la = _input.LA(1);
-      if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LP) | (1L << NEW) | (1L << BOOLNOT) | (1L << BWNOT) | (1L << ADD) | (1L << SUB) | (1L << INCR) | (1L << DECR) | (1L << OCTAL))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (HEX - 64)) | (1L << (INTEGER - 64)) | (1L << (DECIMAL - 64)) | (1L << (STRING - 64)) | (1L << (TRUE - 64)) | (1L << (FALSE - 64)) | (1L << (NULL - 64)) | (1L << (ID - 64)))) != 0)) {
+      setState(355);
+      switch ( getInterpreter().adaptivePredict(_input,29,_ctx) ) {
+      case 1:
         {
-        setState(350);
+        setState(347);
         expression(0);
-        setState(355);
+        setState(352);
         _errHandler.sync(this);
         _la = _input.LA(1);
         while (_la==COMMA) {
           {
           {
-          setState(351);
+          setState(348);
           match(COMMA);
-          setState(352);
+          setState(349);
           expression(0);
           }
           }
-          setState(357);
+          setState(354);
           _errHandler.sync(this);
           _la = _input.LA(1);
         }
         }
+        break;
       }
-
-      setState(360);
+      setState(357);
       match(RP);
       }
       }
@@ -2723,179 +2412,224 @@ public final ArgumentsContext arguments() throws RecognitionException {
 
   public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
     switch (ruleIndex) {
-    case 13:
+    case 1:
+      return statement_sempred((StatementContext)_localctx, predIndex);
+    case 12:
       return expression_sempred((ExpressionContext)_localctx, predIndex);
+    case 13:
+      return unary_sempred((UnaryContext)_localctx, predIndex);
+    case 15:
+      return primary_sempred((PrimaryContext)_localctx, predIndex);
+    case 16:
+      return secondary_sempred((SecondaryContext)_localctx, predIndex);
     }
     return true;
   }
-  private boolean expression_sempred(ExpressionContext _localctx, int predIndex) {
+  private boolean statement_sempred(StatementContext _localctx, int predIndex) {
     switch (predIndex) {
     case 0:
-      return precpred(_ctx, 12);
+      return  _input.LA(1) != ELSE ;
+    }
+    return true;
+  }
+  private boolean expression_sempred(ExpressionContext _localctx, int predIndex) {
+    switch (predIndex) {
     case 1:
-      return precpred(_ctx, 11);
+      return precpred(_ctx, 12);
     case 2:
-      return precpred(_ctx, 10);
+      return precpred(_ctx, 11);
     case 3:
-      return precpred(_ctx, 9);
+      return precpred(_ctx, 10);
     case 4:
-      return precpred(_ctx, 8);
+      return precpred(_ctx, 9);
     case 5:
-      return precpred(_ctx, 7);
+      return precpred(_ctx, 8);
     case 6:
-      return precpred(_ctx, 6);
+      return precpred(_ctx, 7);
     case 7:
-      return precpred(_ctx, 5);
+      return precpred(_ctx, 6);
     case 8:
-      return precpred(_ctx, 4);
+      return precpred(_ctx, 5);
     case 9:
-      return precpred(_ctx, 3);
+      return precpred(_ctx, 4);
     case 10:
+      return precpred(_ctx, 3);
+    case 11:
       return precpred(_ctx, 2);
     }
     return true;
   }
+  private boolean unary_sempred(UnaryContext _localctx, int predIndex) {
+    switch (predIndex) {
+    case 12:
+      return  !_localctx.c ;
+    case 13:
+      return  !_localctx.c ;
+    case 14:
+      return  !_localctx.c ;
+    case 15:
+      return  !_localctx.c ;
+    case 16:
+      return  !_localctx.c ;
+    case 17:
+      return  !_localctx.c ;
+    case 18:
+      return  !_localctx.c ;
+    case 19:
+      return  !_localctx.c ;
+    }
+    return true;
+  }
+  private boolean primary_sempred(PrimaryContext _localctx, int predIndex) {
+    switch (predIndex) {
+    case 20:
+      return  !_localctx.c ;
+    case 21:
+      return  _localctx.c ;
+    }
+    return true;
+  }
+  private boolean secondary_sempred(SecondaryContext _localctx, int predIndex) {
+    switch (predIndex) {
+    case 22:
+      return  _localctx.s ;
+    case 23:
+      return  _localctx.s ;
+    }
+    return true;
+  }
 
   public static final String _serializedATN =
-    "\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3K\u016d\4\2\t\2\4"+
+    "\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3L\u016a\4\2\t\2\4"+
     "\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t"+
     "\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22"+
-    "\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31\t\31"+
-    "\4\32\t\32\3\2\6\2\66\n\2\r\2\16\2\67\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3\3"+
-    "\3\3\5\3C\n\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3K\n\3\3\3\3\3\3\3\3\3\3\3\3\3"+
-    "\3\3\3\3\3\3\3\3\3\3\5\3X\n\3\3\3\3\3\5\3\\\n\3\3\3\3\3\5\3`\n\3\3\3\3"+
-    "\3\3\3\5\3e\n\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3"+
-    "\3\6\3u\n\3\r\3\16\3v\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3\u0080\n\3\3\4\3"+
-    "\4\6\4\u0084\n\4\r\4\16\4\u0085\3\4\3\4\3\4\5\4\u008b\n\4\3\5\3\5\5\5"+
-    "\u008f\n\5\3\6\3\6\3\6\3\7\3\7\5\7\u0096\n\7\3\b\3\b\3\t\3\t\3\t\3\t\7"+
-    "\t\u009e\n\t\f\t\16\t\u00a1\13\t\3\n\3\n\3\n\7\n\u00a6\n\n\f\n\16\n\u00a9"+
-    "\13\n\3\13\3\13\3\13\5\13\u00ae\n\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\5"+
-    "\f\u00b8\n\f\3\r\3\r\5\r\u00bc\n\r\3\16\3\16\3\16\3\16\7\16\u00c2\n\16"+
-    "\f\16\16\16\u00c5\13\16\3\16\3\16\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3"+
-    "\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3"+
-    "\17\3\17\3\17\3\17\3\17\5\17\u00e3\n\17\3\17\3\17\3\17\3\17\3\17\3\17"+
-    "\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17"+
+    "\4\23\t\23\4\24\t\24\4\25\t\25\3\2\7\2,\n\2\f\2\16\2/\13\2\3\2\3\2\3\3"+
+    "\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3;\n\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3C\n\3"+
+    "\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3P\n\3\3\3\3\3\5\3T\n\3"+
+    "\3\3\3\3\5\3X\n\3\3\3\3\3\3\3\5\3]\n\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3"+
+    "\3\3\3\3\3\3\3\3\3\3\3\3\6\3m\n\3\r\3\16\3n\3\3\3\3\3\3\3\3\3\3\3\3\3"+
+    "\3\5\3x\n\3\3\4\3\4\5\4|\n\4\3\5\3\5\7\5\u0080\n\5\f\5\16\5\u0083\13\5"+
+    "\3\5\3\5\3\6\3\6\3\7\3\7\5\7\u008b\n\7\3\b\3\b\3\t\3\t\3\t\3\t\7\t\u0093"+
+    "\n\t\f\t\16\t\u0096\13\t\3\n\3\n\3\n\7\n\u009b\n\n\f\n\16\n\u009e\13\n"+
+    "\3\13\3\13\3\13\5\13\u00a3\n\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\r\3\r\3"+
+    "\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\5\16\u00b7\n\16\3\16\3\16"+
+    "\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16"+
+    "\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16"+
+    "\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16"+
+    "\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\7\16"+
+    "\u00f2\n\16\f\16\16\16\u00f5\13\16\3\17\3\17\3\17\3\17\3\17\3\17\3\17"+
     "\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17"+
-    "\3\17\3\17\7\17\u0109\n\17\f\17\16\17\u010c\13\17\3\20\3\20\3\20\3\20"+
-    "\3\20\5\20\u0113\n\20\3\21\3\21\3\21\3\21\3\21\3\21\5\21\u011b\n\21\3"+
-    "\21\3\21\3\21\5\21\u0120\n\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22"+
-    "\5\22\u012a\n\22\3\23\3\23\3\23\3\23\3\23\5\23\u0131\n\23\3\24\3\24\3"+
-    "\24\5\24\u0136\n\24\3\25\3\25\3\25\3\25\5\25\u013c\n\25\3\26\3\26\3\26"+
-    "\5\26\u0141\n\26\3\27\3\27\3\27\5\27\u0146\n\27\3\30\3\30\3\30\3\30\5"+
-    "\30\u014c\n\30\3\30\3\30\3\30\3\30\6\30\u0152\n\30\r\30\16\30\u0153\3"+
-    "\30\5\30\u0157\n\30\5\30\u0159\n\30\3\31\3\31\3\31\5\31\u015e\n\31\3\32"+
-    "\3\32\3\32\3\32\7\32\u0164\n\32\f\32\16\32\u0167\13\32\5\32\u0169\n\32"+
-    "\3\32\3\32\3\32\2\3\34\33\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&"+
-    "(*,.\60\62\2\r\3\3\r\r\4\2\32\33\37 \3\2\65@\3\2AD\3\2\63\64\3\2\34\36"+
-    "\3\2\37 \3\2!#\3\2$\'\3\2(+\3\2JK\u01a3\2\65\3\2\2\2\4\177\3\2\2\2\6\u008a"+
-    "\3\2\2\2\b\u008e\3\2\2\2\n\u0090\3\2\2\2\f\u0095\3\2\2\2\16\u0097\3\2"+
-    "\2\2\20\u0099\3\2\2\2\22\u00a2\3\2\2\2\24\u00aa\3\2\2\2\26\u00af\3\2\2"+
-    "\2\30\u00b9\3\2\2\2\32\u00bd\3\2\2\2\34\u00e2\3\2\2\2\36\u0112\3\2\2\2"+
-    " \u0114\3\2\2\2\"\u0121\3\2\2\2$\u012b\3\2\2\2&\u0132\3\2\2\2(\u0137\3"+
-    "\2\2\2*\u013d\3\2\2\2,\u0142\3\2\2\2.\u0147\3\2\2\2\60\u015a\3\2\2\2\62"+
-    "\u015f\3\2\2\2\64\66\5\4\3\2\65\64\3\2\2\2\66\67\3\2\2\2\67\65\3\2\2\2"+
-    "\678\3\2\2\289\3\2\2\29:\7\2\2\3:\3\3\2\2\2;<\7\16\2\2<=\7\t\2\2=>\5\34"+
-    "\17\2>?\7\n\2\2?B\5\6\4\2@A\7\17\2\2AC\5\6\4\2B@\3\2\2\2BC\3\2\2\2C\u0080"+
-    "\3\2\2\2DE\7\20\2\2EF\7\t\2\2FG\5\34\17\2GJ\7\n\2\2HK\5\6\4\2IK\5\b\5"+
-    "\2JH\3\2\2\2JI\3\2\2\2K\u0080\3\2\2\2LM\7\21\2\2MN\5\6\4\2NO\7\20\2\2"+
-    "OP\7\t\2\2PQ\5\34\17\2QR\7\n\2\2RS\t\2\2\2S\u0080\3\2\2\2TU\7\22\2\2U"+
-    "W\7\t\2\2VX\5\f\7\2WV\3\2\2\2WX\3\2\2\2XY\3\2\2\2Y[\7\r\2\2Z\\\5\34\17"+
-    "\2[Z\3\2\2\2[\\\3\2\2\2\\]\3\2\2\2]_\7\r\2\2^`\5\16\b\2_^\3\2\2\2_`\3"+
-    "\2\2\2`a\3\2\2\2ad\7\n\2\2be\5\6\4\2ce\5\b\5\2db\3\2\2\2dc\3\2\2\2e\u0080"+
-    "\3\2\2\2fg\5\20\t\2gh\t\2\2\2h\u0080\3\2\2\2ij\7\23\2\2j\u0080\t\2\2\2"+
-    "kl\7\24\2\2l\u0080\t\2\2\2mn\7\25\2\2no\5\34\17\2op\t\2\2\2p\u0080\3\2"+
-    "\2\2qr\7\27\2\2rt\5\6\4\2su\5\26\f\2ts\3\2\2\2uv\3\2\2\2vt\3\2\2\2vw\3"+
-    "\2\2\2w\u0080\3\2\2\2xy\7\31\2\2yz\5\34\17\2z{\t\2\2\2{\u0080\3\2\2\2"+
-    "|}\5\34\17\2}~\t\2\2\2~\u0080\3\2\2\2\177;\3\2\2\2\177D\3\2\2\2\177L\3"+
-    "\2\2\2\177T\3\2\2\2\177f\3\2\2\2\177i\3\2\2\2\177k\3\2\2\2\177m\3\2\2"+
-    "\2\177q\3\2\2\2\177x\3\2\2\2\177|\3\2\2\2\u0080\5\3\2\2\2\u0081\u0083"+
-    "\7\5\2\2\u0082\u0084\5\4\3\2\u0083\u0082\3\2\2\2\u0084\u0085\3\2\2\2\u0085"+
-    "\u0083\3\2\2\2\u0085\u0086\3\2\2\2\u0086\u0087\3\2\2\2\u0087\u0088\7\6"+
-    "\2\2\u0088\u008b\3\2\2\2\u0089\u008b\5\4\3\2\u008a\u0081\3\2\2\2\u008a"+
-    "\u0089\3\2\2\2\u008b\7\3\2\2\2\u008c\u008f\5\n\6\2\u008d\u008f\7\r\2\2"+
-    "\u008e\u008c\3\2\2\2\u008e\u008d\3\2\2\2\u008f\t\3\2\2\2\u0090\u0091\7"+
-    "\5\2\2\u0091\u0092\7\6\2\2\u0092\13\3\2\2\2\u0093\u0096\5\20\t\2\u0094"+
-    "\u0096\5\34\17\2\u0095\u0093\3\2\2\2\u0095\u0094\3\2\2\2\u0096\r\3\2\2"+
-    "\2\u0097\u0098\5\34\17\2\u0098\17\3\2\2\2\u0099\u009a\5\22\n\2\u009a\u009f"+
-    "\5\24\13\2\u009b\u009c\7\f\2\2\u009c\u009e\5\24\13\2\u009d\u009b\3\2\2"+
-    "\2\u009e\u00a1\3\2\2\2\u009f\u009d\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0\21"+
-    "\3\2\2\2\u00a1\u009f\3\2\2\2\u00a2\u00a7\5\30\r\2\u00a3\u00a4\7\7\2\2"+
-    "\u00a4\u00a6\7\b\2\2\u00a5\u00a3\3\2\2\2\u00a6\u00a9\3\2\2\2\u00a7\u00a5"+
-    "\3\2\2\2\u00a7\u00a8\3\2\2\2\u00a8\23\3\2\2\2\u00a9\u00a7\3\2\2\2\u00aa"+
-    "\u00ad\5\30\r\2\u00ab\u00ac\7\65\2\2\u00ac\u00ae\5\34\17\2\u00ad\u00ab"+
-    "\3\2\2\2\u00ad\u00ae\3\2\2\2\u00ae\25\3\2\2\2\u00af\u00b0\7\30\2\2\u00b0"+
-    "\u00b1\7\t\2\2\u00b1\u00b2\5\30\r\2\u00b2\u00b3\5\30\r\2\u00b3\u00b4\3"+
-    "\2\2\2\u00b4\u00b7\7\n\2\2\u00b5\u00b8\5\6\4\2\u00b6\u00b8\5\n\6\2\u00b7"+
-    "\u00b5\3\2\2\2\u00b7\u00b6\3\2\2\2\u00b8\27\3\2\2\2\u00b9\u00bb\7I\2\2"+
-    "\u00ba\u00bc\5\32\16\2\u00bb\u00ba\3\2\2\2\u00bb\u00bc\3\2\2\2\u00bc\31"+
-    "\3\2\2\2\u00bd\u00be\7$\2\2\u00be\u00c3\5\30\r\2\u00bf\u00c0\7\f\2\2\u00c0"+
-    "\u00c2\5\30\r\2\u00c1\u00bf\3\2\2\2\u00c2\u00c5\3\2\2\2\u00c3\u00c1\3"+
-    "\2\2\2\u00c3\u00c4\3\2\2\2\u00c4\u00c6\3\2\2\2\u00c5\u00c3\3\2\2\2\u00c6"+
-    "\u00c7\7&\2\2\u00c7\33\3\2\2\2\u00c8\u00c9\b\17\1\2\u00c9\u00ca\t\3\2"+
-    "\2\u00ca\u00e3\5\34\17\20\u00cb\u00cc\7\t\2\2\u00cc\u00cd\5\22\n\2\u00cd"+
-    "\u00ce\7\n\2\2\u00ce\u00cf\5\34\17\17\u00cf\u00e3\3\2\2\2\u00d0\u00d1"+
-    "\5\36\20\2\u00d1\u00d2\t\4\2\2\u00d2\u00d3\5\34\17\3\u00d3\u00e3\3\2\2"+
-    "\2\u00d4\u00d5\7\t\2\2\u00d5\u00d6\5\34\17\2\u00d6\u00d7\7\n\2\2\u00d7"+
-    "\u00e3\3\2\2\2\u00d8\u00e3\t\5\2\2\u00d9\u00e3\7F\2\2\u00da\u00e3\7G\2"+
-    "\2\u00db\u00e3\7H\2\2\u00dc\u00dd\5\36\20\2\u00dd\u00de\t\6\2\2\u00de"+
-    "\u00e3\3\2\2\2\u00df\u00e0\t\6\2\2\u00e0\u00e3\5\36\20\2\u00e1\u00e3\5"+
-    "\36\20\2\u00e2\u00c8\3\2\2\2\u00e2\u00cb\3\2\2\2\u00e2\u00d0\3\2\2\2\u00e2"+
-    "\u00d4\3\2\2\2\u00e2\u00d8\3\2\2\2\u00e2\u00d9\3\2\2\2\u00e2\u00da\3\2"+
-    "\2\2\u00e2\u00db\3\2\2\2\u00e2\u00dc\3\2\2\2\u00e2\u00df\3\2\2\2\u00e2"+
-    "\u00e1\3\2\2\2\u00e3\u010a\3\2\2\2\u00e4\u00e5\f\16\2\2\u00e5\u00e6\t"+
-    "\7\2\2\u00e6\u0109\5\34\17\17\u00e7\u00e8\f\r\2\2\u00e8\u00e9\t\b\2\2"+
-    "\u00e9\u0109\5\34\17\16\u00ea\u00eb\f\f\2\2\u00eb\u00ec\t\t\2\2\u00ec"+
-    "\u0109\5\34\17\r\u00ed\u00ee\f\13\2\2\u00ee\u00ef\t\n\2\2\u00ef\u0109"+
-    "\5\34\17\f\u00f0\u00f1\f\n\2\2\u00f1\u00f2\t\13\2\2\u00f2\u0109\5\34\17"+
-    "\13\u00f3\u00f4\f\t\2\2\u00f4\u00f5\7,\2\2\u00f5\u0109\5\34\17\n\u00f6"+
-    "\u00f7\f\b\2\2\u00f7\u00f8\7-\2\2\u00f8\u0109\5\34\17\t\u00f9\u00fa\f"+
-    "\7\2\2\u00fa\u00fb\7.\2\2\u00fb\u0109\5\34\17\b\u00fc\u00fd\f\6\2\2\u00fd"+
-    "\u00fe\7/\2\2\u00fe\u0109\5\34\17\7\u00ff\u0100\f\5\2\2\u0100\u0101\7"+
-    "\60\2\2\u0101\u0109\5\34\17\6\u0102\u0103\f\4\2\2\u0103\u0104\7\61\2\2"+
-    "\u0104\u0105\5\34\17\2\u0105\u0106\7\62\2\2\u0106\u0107\5\34\17\4\u0107"+
-    "\u0109\3\2\2\2\u0108\u00e4\3\2\2\2\u0108\u00e7\3\2\2\2\u0108\u00ea\3\2"+
-    "\2\2\u0108\u00ed\3\2\2\2\u0108\u00f0\3\2\2\2\u0108\u00f3\3\2\2\2\u0108"+
-    "\u00f6\3\2\2\2\u0108\u00f9\3\2\2\2\u0108\u00fc\3\2\2\2\u0108\u00ff\3\2"+
-    "\2\2\u0108\u0102\3\2\2\2\u0109\u010c\3\2\2\2\u010a\u0108\3\2\2\2\u010a"+
-    "\u010b\3\2\2\2\u010b\35\3\2\2\2\u010c\u010a\3\2\2\2\u010d\u0113\5 \21"+
-    "\2\u010e\u0113\5\"\22\2\u010f\u0113\5*\26\2\u0110\u0113\5.\30\2\u0111"+
-    "\u0113\5\60\31\2\u0112\u010d\3\2\2\2\u0112\u010e\3\2\2\2\u0112\u010f\3"+
-    "\2\2\2\u0112\u0110\3\2\2\2\u0112\u0111\3\2\2\2\u0113\37\3\2\2\2\u0114"+
-    "\u011a\7\t\2\2\u0115\u011b\5 \21\2\u0116\u011b\5\"\22\2\u0117\u011b\5"+
-    "*\26\2\u0118\u011b\5.\30\2\u0119\u011b\5\60\31\2\u011a\u0115\3\2\2\2\u011a"+
-    "\u0116\3\2\2\2\u011a\u0117\3\2\2\2\u011a\u0118\3\2\2\2\u011a\u0119\3\2"+
-    "\2\2\u011b\u011c\3\2\2\2\u011c\u011f\7\n\2\2\u011d\u0120\5&\24\2\u011e"+
-    "\u0120\5$\23\2\u011f\u011d\3\2\2\2\u011f\u011e\3\2\2\2\u011f\u0120\3\2"+
-    "\2\2\u0120!\3\2\2\2\u0121\u0122\7\t\2\2\u0122\u0123\5\22\n\2\u0123\u0129"+
-    "\7\n\2\2\u0124\u012a\5 \21\2\u0125\u012a\5\"\22\2\u0126\u012a\5*\26\2"+
-    "\u0127\u012a\5.\30\2\u0128\u012a\5\60\31\2\u0129\u0124\3\2\2\2\u0129\u0125"+
-    "\3\2\2\2\u0129\u0126\3\2\2\2\u0129\u0127\3\2\2\2\u0129\u0128\3\2\2\2\u012a"+
-    "#\3\2\2\2\u012b\u012c\7\7\2\2\u012c\u012d\5\34\17\2\u012d\u0130\7\b\2"+
-    "\2\u012e\u0131\5&\24\2\u012f\u0131\5$\23\2\u0130\u012e\3\2\2\2\u0130\u012f"+
-    "\3\2\2\2\u0130\u0131\3\2\2\2\u0131%\3\2\2\2\u0132\u0135\7\13\2\2\u0133"+
-    "\u0136\5(\25\2\u0134\u0136\5,\27\2\u0135\u0133\3\2\2\2\u0135\u0134\3\2"+
-    "\2\2\u0136\'\3\2\2\2\u0137\u0138\7K\2\2\u0138\u013b\5\62\32\2\u0139\u013c"+
-    "\5&\24\2\u013a\u013c\5$\23\2\u013b\u0139\3\2\2\2\u013b\u013a\3\2\2\2\u013b"+
-    "\u013c\3\2\2\2\u013c)\3\2\2\2\u013d\u0140\5\30\r\2\u013e\u0141\5&\24\2"+
-    "\u013f\u0141\5$\23\2\u0140\u013e\3\2\2\2\u0140\u013f\3\2\2\2\u0140\u0141"+
-    "\3\2\2\2\u0141+\3\2\2\2\u0142\u0145\t\f\2\2\u0143\u0146\5&\24\2\u0144"+
-    "\u0146\5$\23\2\u0145\u0143\3\2\2\2\u0145\u0144\3\2\2\2\u0145\u0146\3\2"+
-    "\2\2\u0146-\3\2\2\2\u0147\u0148\7\26\2\2\u0148\u0158\5\30\r\2\u0149\u014b"+
-    "\5\62\32\2\u014a\u014c\5&\24\2\u014b\u014a\3\2\2\2\u014b\u014c\3\2\2\2"+
-    "\u014c\u0159\3\2\2\2\u014d\u014e\7\7\2\2\u014e\u014f\5\34\17\2\u014f\u0150"+
-    "\7\b\2\2\u0150\u0152\3\2\2\2\u0151\u014d\3\2\2\2\u0152\u0153\3\2\2\2\u0153"+
-    "\u0151\3\2\2\2\u0153\u0154\3\2\2\2\u0154\u0156\3\2\2\2\u0155\u0157\5&"+
-    "\24\2\u0156\u0155\3\2\2\2\u0156\u0157\3\2\2\2\u0157\u0159\3\2\2\2\u0158"+
-    "\u0149\3\2\2\2\u0158\u0151\3\2\2\2\u0159/\3\2\2\2\u015a\u015d\7E\2\2\u015b"+
-    "\u015e\5&\24\2\u015c\u015e\5$\23\2\u015d\u015b\3\2\2\2\u015d\u015c\3\2"+
-    "\2\2\u015d\u015e\3\2\2\2\u015e\61\3\2\2\2\u015f\u0168\7\t\2\2\u0160\u0165"+
-    "\5\34\17\2\u0161\u0162\7\f\2\2\u0162\u0164\5\34\17\2\u0163\u0161\3\2\2"+
-    "\2\u0164\u0167\3\2\2\2\u0165\u0163\3\2\2\2\u0165\u0166\3\2\2\2\u0166\u0169"+
-    "\3\2\2\2\u0167\u0165\3\2\2\2\u0168\u0160\3\2\2\2\u0168\u0169\3\2\2\2\u0169"+
-    "\u016a\3\2\2\2\u016a\u016b\7\n\2\2\u016b\63\3\2\2\2(\67BJW[_dv\177\u0085"+
-    "\u008a\u008e\u0095\u009f\u00a7\u00ad\u00b7\u00bb\u00c3\u00e2\u0108\u010a"+
-    "\u0112\u011a\u011f\u0129\u0130\u0135\u013b\u0140\u0145\u014b\u0153\u0156"+
-    "\u0158\u015d\u0165\u0168";
+    "\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\5\17\u0114\n\17\3\20\3\20\7\20"+
+    "\u0118\n\20\f\20\16\20\u011b\13\20\3\20\3\20\3\20\7\20\u0120\n\20\f\20"+
+    "\16\20\u0123\13\20\3\20\3\20\3\20\3\20\3\20\3\20\6\20\u012b\n\20\r\20"+
+    "\16\20\u012c\3\20\3\20\7\20\u0131\n\20\f\20\16\20\u0134\13\20\5\20\u0136"+
+    "\n\20\5\20\u0138\n\20\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21"+
+    "\3\21\3\21\3\21\3\21\3\21\3\21\5\21\u014a\n\21\3\22\3\22\3\22\3\22\5\22"+
+    "\u0150\n\22\3\23\3\23\3\23\3\23\3\23\5\23\u0157\n\23\3\24\3\24\3\24\3"+
+    "\24\3\25\3\25\3\25\3\25\7\25\u0161\n\25\f\25\16\25\u0164\13\25\5\25\u0166"+
+    "\n\25\3\25\3\25\3\25\2\3\32\26\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36"+
+    " \"$&(\2\r\3\3\r\r\3\2\65@\3\2\34\36\3\2\37 \3\2!#\3\2$\'\3\2(+\3\2\63"+
+    "\64\3\2AD\4\2\32\33\37 \3\2KL\u0190\2-\3\2\2\2\4w\3\2\2\2\6{\3\2\2\2\b"+
+    "}\3\2\2\2\n\u0086\3\2\2\2\f\u008a\3\2\2\2\16\u008c\3\2\2\2\20\u008e\3"+
+    "\2\2\2\22\u0097\3\2\2\2\24\u009f\3\2\2\2\26\u00a4\3\2\2\2\30\u00ab\3\2"+
+    "\2\2\32\u00b6\3\2\2\2\34\u0113\3\2\2\2\36\u0137\3\2\2\2 \u0149\3\2\2\2"+
+    "\"\u014f\3\2\2\2$\u0156\3\2\2\2&\u0158\3\2\2\2(\u015c\3\2\2\2*,\5\4\3"+
+    "\2+*\3\2\2\2,/\3\2\2\2-+\3\2\2\2-.\3\2\2\2.\60\3\2\2\2/-\3\2\2\2\60\61"+
+    "\7\2\2\3\61\3\3\2\2\2\62\63\7\16\2\2\63\64\7\t\2\2\64\65\5\32\16\2\65"+
+    "\66\7\n\2\2\66:\5\6\4\2\678\7\17\2\28;\5\6\4\29;\6\3\2\2:\67\3\2\2\2:"+
+    "9\3\2\2\2;x\3\2\2\2<=\7\20\2\2=>\7\t\2\2>?\5\32\16\2?B\7\n\2\2@C\5\6\4"+
+    "\2AC\5\n\6\2B@\3\2\2\2BA\3\2\2\2Cx\3\2\2\2DE\7\21\2\2EF\5\b\5\2FG\7\20"+
+    "\2\2GH\7\t\2\2HI\5\32\16\2IJ\7\n\2\2JK\5\30\r\2Kx\3\2\2\2LM\7\22\2\2M"+
+    "O\7\t\2\2NP\5\f\7\2ON\3\2\2\2OP\3\2\2\2PQ\3\2\2\2QS\7\r\2\2RT\5\32\16"+
+    "\2SR\3\2\2\2ST\3\2\2\2TU\3\2\2\2UW\7\r\2\2VX\5\16\b\2WV\3\2\2\2WX\3\2"+
+    "\2\2XY\3\2\2\2Y\\\7\n\2\2Z]\5\6\4\2[]\5\n\6\2\\Z\3\2\2\2\\[\3\2\2\2]x"+
+    "\3\2\2\2^_\5\20\t\2_`\5\30\r\2`x\3\2\2\2ab\7\23\2\2bx\5\30\r\2cd\7\24"+
+    "\2\2dx\5\30\r\2ef\7\25\2\2fg\5\32\16\2gh\5\30\r\2hx\3\2\2\2ij\7\27\2\2"+
+    "jl\5\b\5\2km\5\26\f\2lk\3\2\2\2mn\3\2\2\2nl\3\2\2\2no\3\2\2\2ox\3\2\2"+
+    "\2pq\7\31\2\2qr\5\32\16\2rs\5\30\r\2sx\3\2\2\2tu\5\32\16\2uv\5\30\r\2"+
+    "vx\3\2\2\2w\62\3\2\2\2w<\3\2\2\2wD\3\2\2\2wL\3\2\2\2w^\3\2\2\2wa\3\2\2"+
+    "\2wc\3\2\2\2we\3\2\2\2wi\3\2\2\2wp\3\2\2\2wt\3\2\2\2x\5\3\2\2\2y|\5\b"+
+    "\5\2z|\5\4\3\2{y\3\2\2\2{z\3\2\2\2|\7\3\2\2\2}\u0081\7\5\2\2~\u0080\5"+
+    "\4\3\2\177~\3\2\2\2\u0080\u0083\3\2\2\2\u0081\177\3\2\2\2\u0081\u0082"+
+    "\3\2\2\2\u0082\u0084\3\2\2\2\u0083\u0081\3\2\2\2\u0084\u0085\7\6\2\2\u0085"+
+    "\t\3\2\2\2\u0086\u0087\7\r\2\2\u0087\13\3\2\2\2\u0088\u008b\5\20\t\2\u0089"+
+    "\u008b\5\32\16\2\u008a\u0088\3\2\2\2\u008a\u0089\3\2\2\2\u008b\r\3\2\2"+
+    "\2\u008c\u008d\5\32\16\2\u008d\17\3\2\2\2\u008e\u008f\5\22\n\2\u008f\u0094"+
+    "\5\24\13\2\u0090\u0091\7\f\2\2\u0091\u0093\5\24\13\2\u0092\u0090\3\2\2"+
+    "\2\u0093\u0096\3\2\2\2\u0094\u0092\3\2\2\2\u0094\u0095\3\2\2\2\u0095\21"+
+    "\3\2\2\2\u0096\u0094\3\2\2\2\u0097\u009c\7I\2\2\u0098\u0099\7\7\2\2\u0099"+
+    "\u009b\7\b\2\2\u009a\u0098\3\2\2\2\u009b\u009e\3\2\2\2\u009c\u009a\3\2"+
+    "\2\2\u009c\u009d\3\2\2\2\u009d\23\3\2\2\2\u009e\u009c\3\2\2\2\u009f\u00a2"+
+    "\7J\2\2\u00a0\u00a1\7\65\2\2\u00a1\u00a3\5\32\16\2\u00a2\u00a0\3\2\2\2"+
+    "\u00a2\u00a3\3\2\2\2\u00a3\25\3\2\2\2\u00a4\u00a5\7\30\2\2\u00a5\u00a6"+
+    "\7\t\2\2\u00a6\u00a7\7I\2\2\u00a7\u00a8\7J\2\2\u00a8\u00a9\7\n\2\2\u00a9"+
+    "\u00aa\5\b\5\2\u00aa\27\3\2\2\2\u00ab\u00ac\t\2\2\2\u00ac\31\3\2\2\2\u00ad"+
+    "\u00ae\b\16\1\2\u00ae\u00af\5\36\20\2\u00af\u00b0\t\3\2\2\u00b0\u00b1"+
+    "\5\32\16\3\u00b1\u00b2\b\16\1\2\u00b2\u00b7\3\2\2\2\u00b3\u00b4\5\34\17"+
+    "\2\u00b4\u00b5\b\16\1\2\u00b5\u00b7\3\2\2\2\u00b6\u00ad\3\2\2\2\u00b6"+
+    "\u00b3\3\2\2\2\u00b7\u00f3\3\2\2\2\u00b8\u00b9\f\16\2\2\u00b9\u00ba\t"+
+    "\4\2\2\u00ba\u00bb\5\32\16\17\u00bb\u00bc\b\16\1\2\u00bc\u00f2\3\2\2\2"+
+    "\u00bd\u00be\f\r\2\2\u00be\u00bf\t\5\2\2\u00bf\u00c0\5\32\16\16\u00c0"+
+    "\u00c1\b\16\1\2\u00c1\u00f2\3\2\2\2\u00c2\u00c3\f\f\2\2\u00c3\u00c4\t"+
+    "\6\2\2\u00c4\u00c5\5\32\16\r\u00c5\u00c6\b\16\1\2\u00c6\u00f2\3\2\2\2"+
+    "\u00c7\u00c8\f\13\2\2\u00c8\u00c9\t\7\2\2\u00c9\u00ca\5\32\16\f\u00ca"+
+    "\u00cb\b\16\1\2\u00cb\u00f2\3\2\2\2\u00cc\u00cd\f\n\2\2\u00cd\u00ce\t"+
+    "\b\2\2\u00ce\u00cf\5\32\16\13\u00cf\u00d0\b\16\1\2\u00d0\u00f2\3\2\2\2"+
+    "\u00d1\u00d2\f\t\2\2\u00d2\u00d3\7,\2\2\u00d3\u00d4\5\32\16\n\u00d4\u00d5"+
+    "\b\16\1\2\u00d5\u00f2\3\2\2\2\u00d6\u00d7\f\b\2\2\u00d7\u00d8\7-\2\2\u00d8"+
+    "\u00d9\5\32\16\t\u00d9\u00da\b\16\1\2\u00da\u00f2\3\2\2\2\u00db\u00dc"+
+    "\f\7\2\2\u00dc\u00dd\7.\2\2\u00dd\u00de\5\32\16\b\u00de\u00df\b\16\1\2"+
+    "\u00df\u00f2\3\2\2\2\u00e0\u00e1\f\6\2\2\u00e1\u00e2\7/\2\2\u00e2\u00e3"+
+    "\5\32\16\7\u00e3\u00e4\b\16\1\2\u00e4\u00f2\3\2\2\2\u00e5\u00e6\f\5\2"+
+    "\2\u00e6\u00e7\7\60\2\2\u00e7\u00e8\5\32\16\6\u00e8\u00e9\b\16\1\2\u00e9"+
+    "\u00f2\3\2\2\2\u00ea\u00eb\f\4\2\2\u00eb\u00ec\7\61\2\2\u00ec\u00ed\5"+
+    "\32\16\2\u00ed\u00ee\7\62\2\2\u00ee\u00ef\5\32\16\4\u00ef\u00f0\b\16\1"+
+    "\2\u00f0\u00f2\3\2\2\2\u00f1\u00b8\3\2\2\2\u00f1\u00bd\3\2\2\2\u00f1\u00c2"+
+    "\3\2\2\2\u00f1\u00c7\3\2\2\2\u00f1\u00cc\3\2\2\2\u00f1\u00d1\3\2\2\2\u00f1"+
+    "\u00d6\3\2\2\2\u00f1\u00db\3\2\2\2\u00f1\u00e0\3\2\2\2\u00f1\u00e5\3\2"+
+    "\2\2\u00f1\u00ea\3\2\2\2\u00f2\u00f5\3\2\2\2\u00f3\u00f1\3\2\2\2\u00f3"+
+    "\u00f4\3\2\2\2\u00f4\33\3\2\2\2\u00f5\u00f3\3\2\2\2\u00f6\u00f7\6\17\16"+
+    "\3\u00f7\u00f8\t\t\2\2\u00f8\u0114\5\36\20\2\u00f9\u00fa\6\17\17\3\u00fa"+
+    "\u00fb\5\36\20\2\u00fb\u00fc\t\t\2\2\u00fc\u0114\3\2\2\2\u00fd\u00fe\6"+
+    "\17\20\3\u00fe\u0114\5\36\20\2\u00ff\u0100\6\17\21\3\u0100\u0101\t\n\2"+
+    "\2\u0101\u0114\b\17\1\2\u0102\u0103\6\17\22\3\u0103\u0104\7F\2\2\u0104"+
+    "\u0114\b\17\1\2\u0105\u0106\6\17\23\3\u0106\u0107\7G\2\2\u0107\u0114\b"+
+    "\17\1\2\u0108\u0109\6\17\24\3\u0109\u010a\7H\2\2\u010a\u0114\b\17\1\2"+
+    "\u010b\u010c\6\17\25\3\u010c\u010d\t\13\2\2\u010d\u0114\5\34\17\2\u010e"+
+    "\u010f\7\t\2\2\u010f\u0110\5\22\n\2\u0110\u0111\7\n\2\2\u0111\u0112\5"+
+    "\34\17\2\u0112\u0114\3\2\2\2\u0113\u00f6\3\2\2\2\u0113\u00f9\3\2\2\2\u0113"+
+    "\u00fd\3\2\2\2\u0113\u00ff\3\2\2\2\u0113\u0102\3\2\2\2\u0113\u0105\3\2"+
+    "\2\2\u0113\u0108\3\2\2\2\u0113\u010b\3\2\2\2\u0113\u010e\3\2\2\2\u0114"+
+    "\35\3\2\2\2\u0115\u0119\5 \21\2\u0116\u0118\5\"\22\2\u0117\u0116\3\2\2"+
+    "\2\u0118\u011b\3\2\2\2\u0119\u0117\3\2\2\2\u0119\u011a\3\2\2\2\u011a\u0138"+
+    "\3\2\2\2\u011b\u0119\3\2\2\2\u011c\u011d\5\22\n\2\u011d\u0121\5$\23\2"+
+    "\u011e\u0120\5\"\22\2\u011f\u011e\3\2\2\2\u0120\u0123\3\2\2\2\u0121\u011f"+
+    "\3\2\2\2\u0121\u0122\3\2\2\2\u0122\u0138\3\2\2\2\u0123\u0121\3\2\2\2\u0124"+
+    "\u0125\7\26\2\2\u0125\u012a\7I\2\2\u0126\u0127\7\7\2\2\u0127\u0128\5\32"+
+    "\16\2\u0128\u0129\7\b\2\2\u0129\u012b\3\2\2\2\u012a\u0126\3\2\2\2\u012b"+
+    "\u012c\3\2\2\2\u012c\u012a\3\2\2\2\u012c\u012d\3\2\2\2\u012d\u0135\3\2"+
+    "\2\2\u012e\u0132\5$\23\2\u012f\u0131\5\"\22\2\u0130\u012f\3\2\2\2\u0131"+
+    "\u0134\3\2\2\2\u0132\u0130\3\2\2\2\u0132\u0133\3\2\2\2\u0133\u0136\3\2"+
+    "\2\2\u0134\u0132\3\2\2\2\u0135\u012e\3\2\2\2\u0135\u0136\3\2\2\2\u0136"+
+    "\u0138\3\2\2\2\u0137\u0115\3\2\2\2\u0137\u011c\3\2\2\2\u0137\u0124\3\2"+
+    "\2\2\u0138\37\3\2\2\2\u0139\u013a\6\21\26\3\u013a\u013b\7\t\2\2\u013b"+
+    "\u013c\5\32\16\2\u013c\u013d\7\n\2\2\u013d\u013e\b\21\1\2\u013e\u014a"+
+    "\3\2\2\2\u013f\u0140\6\21\27\3\u0140\u0141\7\t\2\2\u0141\u0142\5\34\17"+
+    "\2\u0142\u0143\7\n\2\2\u0143\u014a\3\2\2\2\u0144\u014a\7E\2\2\u0145\u014a"+
+    "\7J\2\2\u0146\u0147\7\26\2\2\u0147\u0148\7I\2\2\u0148\u014a\5(\25\2\u0149"+
+    "\u0139\3\2\2\2\u0149\u013f\3\2\2\2\u0149\u0144\3\2\2\2\u0149\u0145\3\2"+
+    "\2\2\u0149\u0146\3\2\2\2\u014a!\3\2\2\2\u014b\u014c\6\22\30\3\u014c\u0150"+
+    "\5$\23\2\u014d\u014e\6\22\31\3\u014e\u0150\5&\24\2\u014f\u014b\3\2\2\2"+
+    "\u014f\u014d\3\2\2\2\u0150#\3\2\2\2\u0151\u0152\7\13\2\2\u0152\u0153\7"+
+    "L\2\2\u0153\u0157\5(\25\2\u0154\u0155\7\13\2\2\u0155\u0157\t\f\2\2\u0156"+
+    "\u0151\3\2\2\2\u0156\u0154\3\2\2\2\u0157%\3\2\2\2\u0158\u0159\7\7\2\2"+
+    "\u0159\u015a\5\32\16\2\u015a\u015b\7\b\2\2\u015b\'\3\2\2\2\u015c\u0165"+
+    "\7\t\2\2\u015d\u0162\5\32\16\2\u015e\u015f\7\f\2\2\u015f\u0161\5\32\16"+
+    "\2\u0160\u015e\3\2\2\2\u0161\u0164\3\2\2\2\u0162\u0160\3\2\2\2\u0162\u0163"+
+    "\3\2\2\2\u0163\u0166\3\2\2\2\u0164\u0162\3\2\2\2\u0165\u015d\3\2\2\2\u0165"+
+    "\u0166\3\2\2\2\u0166\u0167\3\2\2\2\u0167\u0168\7\n\2\2\u0168)\3\2\2\2"+
+    " -:BOSW\\nw{\u0081\u008a\u0094\u009c\u00a2\u00b6\u00f1\u00f3\u0113\u0119"+
+    "\u0121\u012c\u0132\u0135\u0137\u0149\u014f\u0156\u0162\u0165";
   public static final ATN _ATN =
     new ATNDeserializer().deserialize(_serializedATN.toCharArray());
   static {
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParserBaseVisitor.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParserBaseVisitor.java
index dad6e419e258..7d5ed4c9e6f8 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParserBaseVisitor.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParserBaseVisitor.java
@@ -101,14 +101,14 @@
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitMultiple(PainlessParser.MultipleContext ctx) { return visitChildren(ctx); }
+  @Override public T visitTrailer(PainlessParser.TrailerContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitSingle(PainlessParser.SingleContext ctx) { return visitChildren(ctx); }
+  @Override public T visitBlock(PainlessParser.BlockContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
@@ -116,13 +116,6 @@
    * {@link #visitChildren} on {@code ctx}.</p>
    */
   @Override public T visitEmpty(PainlessParser.EmptyContext ctx) { return visitChildren(ctx); }
-  /**
-   * {@inheritDoc}
-   *
-   * <p>The default implementation returns the result of calling
-   * {@link #visitChildren} on {@code ctx}.</p>
-   */
-  @Override public T visitEmptyscope(PainlessParser.EmptyscopeContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
@@ -171,14 +164,14 @@
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitIdentifier(PainlessParser.IdentifierContext ctx) { return visitChildren(ctx); }
+  @Override public T visitDelimiter(PainlessParser.DelimiterContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitGeneric(PainlessParser.GenericContext ctx) { return visitChildren(ctx); }
+  @Override public T visitSingle(PainlessParser.SingleContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
@@ -192,168 +185,175 @@
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitRead(PainlessParser.ReadContext ctx) { return visitChildren(ctx); }
+  @Override public T visitBool(PainlessParser.BoolContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitBool(PainlessParser.BoolContext ctx) { return visitChildren(ctx); }
+  @Override public T visitConditional(PainlessParser.ConditionalContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitConditional(PainlessParser.ConditionalContext ctx) { return visitChildren(ctx); }
+  @Override public T visitAssignment(PainlessParser.AssignmentContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitAssignment(PainlessParser.AssignmentContext ctx) { return visitChildren(ctx); }
+  @Override public T visitBinary(PainlessParser.BinaryContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitFalse(PainlessParser.FalseContext ctx) { return visitChildren(ctx); }
+  @Override public T visitPre(PainlessParser.PreContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitNumeric(PainlessParser.NumericContext ctx) { return visitChildren(ctx); }
+  @Override public T visitPost(PainlessParser.PostContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitUnary(PainlessParser.UnaryContext ctx) { return visitChildren(ctx); }
+  @Override public T visitRead(PainlessParser.ReadContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitPrecedence(PainlessParser.PrecedenceContext ctx) { return visitChildren(ctx); }
+  @Override public T visitNumeric(PainlessParser.NumericContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitPreinc(PainlessParser.PreincContext ctx) { return visitChildren(ctx); }
+  @Override public T visitTrue(PainlessParser.TrueContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitPostinc(PainlessParser.PostincContext ctx) { return visitChildren(ctx); }
+  @Override public T visitFalse(PainlessParser.FalseContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitCast(PainlessParser.CastContext ctx) { return visitChildren(ctx); }
+  @Override public T visitNull(PainlessParser.NullContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitNull(PainlessParser.NullContext ctx) { return visitChildren(ctx); }
+  @Override public T visitOperator(PainlessParser.OperatorContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitBinary(PainlessParser.BinaryContext ctx) { return visitChildren(ctx); }
+  @Override public T visitCast(PainlessParser.CastContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitTrue(PainlessParser.TrueContext ctx) { return visitChildren(ctx); }
+  @Override public T visitDynamic(PainlessParser.DynamicContext ctx) { return visitChildren(ctx); }
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The default implementation returns the result of calling
+   * {@link #visitChildren} on {@code ctx}.</p>
+   */
+  @Override public T visitStatic(PainlessParser.StaticContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitChain(PainlessParser.ChainContext ctx) { return visitChildren(ctx); }
+  @Override public T visitNewarray(PainlessParser.NewarrayContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitLinkprec(PainlessParser.LinkprecContext ctx) { return visitChildren(ctx); }
+  @Override public T visitExprprec(PainlessParser.ExprprecContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitLinkcast(PainlessParser.LinkcastContext ctx) { return visitChildren(ctx); }
+  @Override public T visitChainprec(PainlessParser.ChainprecContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitLinkbrace(PainlessParser.LinkbraceContext ctx) { return visitChildren(ctx); }
+  @Override public T visitString(PainlessParser.StringContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitLinkdot(PainlessParser.LinkdotContext ctx) { return visitChildren(ctx); }
+  @Override public T visitVariable(PainlessParser.VariableContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitLinkcall(PainlessParser.LinkcallContext ctx) { return visitChildren(ctx); }
+  @Override public T visitNewobject(PainlessParser.NewobjectContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitLinkvar(PainlessParser.LinkvarContext ctx) { return visitChildren(ctx); }
+  @Override public T visitSecondary(PainlessParser.SecondaryContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitLinkfield(PainlessParser.LinkfieldContext ctx) { return visitChildren(ctx); }
+  @Override public T visitCallinvoke(PainlessParser.CallinvokeContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitLinknew(PainlessParser.LinknewContext ctx) { return visitChildren(ctx); }
+  @Override public T visitFieldaccess(PainlessParser.FieldaccessContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
    * <p>The default implementation returns the result of calling
    * {@link #visitChildren} on {@code ctx}.</p>
    */
-  @Override public T visitLinkstring(PainlessParser.LinkstringContext ctx) { return visitChildren(ctx); }
+  @Override public T visitBraceaccess(PainlessParser.BraceaccessContext ctx) { return visitChildren(ctx); }
   /**
    * {@inheritDoc}
    *
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParserVisitor.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParserVisitor.java
index 7a3b594ab152..ab1254e1a910 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParserVisitor.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParserVisitor.java
@@ -94,31 +94,23 @@
    */
   T visitExpr(PainlessParser.ExprContext ctx);
   /**
-   * Visit a parse tree produced by the {@code multiple}
-   * labeled alternative in {@link PainlessParser#block}.
+   * Visit a parse tree produced by {@link PainlessParser#trailer}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitMultiple(PainlessParser.MultipleContext ctx);
+  T visitTrailer(PainlessParser.TrailerContext ctx);
   /**
-   * Visit a parse tree produced by the {@code single}
-   * labeled alternative in {@link PainlessParser#block}.
+   * Visit a parse tree produced by {@link PainlessParser#block}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitSingle(PainlessParser.SingleContext ctx);
+  T visitBlock(PainlessParser.BlockContext ctx);
   /**
    * Visit a parse tree produced by {@link PainlessParser#empty}.
    * @param ctx the parse tree
    * @return the visitor result
    */
   T visitEmpty(PainlessParser.EmptyContext ctx);
-  /**
-   * Visit a parse tree produced by {@link PainlessParser#emptyscope}.
-   * @param ctx the parse tree
-   * @return the visitor result
-   */
-  T visitEmptyscope(PainlessParser.EmptyscopeContext ctx);
   /**
    * Visit a parse tree produced by {@link PainlessParser#initializer}.
    * @param ctx the parse tree
@@ -156,17 +148,18 @@
    */
   T visitTrap(PainlessParser.TrapContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#identifier}.
+   * Visit a parse tree produced by {@link PainlessParser#delimiter}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitIdentifier(PainlessParser.IdentifierContext ctx);
+  T visitDelimiter(PainlessParser.DelimiterContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#generic}.
+   * Visit a parse tree produced by the {@code single}
+   * labeled alternative in {@link PainlessParser#expression}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitGeneric(PainlessParser.GenericContext ctx);
+  T visitSingle(PainlessParser.SingleContext ctx);
   /**
    * Visit a parse tree produced by the {@code comp}
    * labeled alternative in {@link PainlessParser#expression}.
@@ -174,13 +167,6 @@
    * @return the visitor result
    */
   T visitComp(PainlessParser.CompContext ctx);
-  /**
-   * Visit a parse tree produced by the {@code read}
-   * labeled alternative in {@link PainlessParser#expression}.
-   * @param ctx the parse tree
-   * @return the visitor result
-   */
-  T visitRead(PainlessParser.ReadContext ctx);
   /**
    * Visit a parse tree produced by the {@code bool}
    * labeled alternative in {@link PainlessParser#expression}.
@@ -203,135 +189,158 @@
    */
   T visitAssignment(PainlessParser.AssignmentContext ctx);
   /**
-   * Visit a parse tree produced by the {@code false}
+   * Visit a parse tree produced by the {@code binary}
    * labeled alternative in {@link PainlessParser#expression}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitFalse(PainlessParser.FalseContext ctx);
+  T visitBinary(PainlessParser.BinaryContext ctx);
   /**
-   * Visit a parse tree produced by the {@code numeric}
-   * labeled alternative in {@link PainlessParser#expression}.
+   * Visit a parse tree produced by the {@code pre}
+   * labeled alternative in {@link PainlessParser#unary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitNumeric(PainlessParser.NumericContext ctx);
+  T visitPre(PainlessParser.PreContext ctx);
   /**
-   * Visit a parse tree produced by the {@code unary}
-   * labeled alternative in {@link PainlessParser#expression}.
+   * Visit a parse tree produced by the {@code post}
+   * labeled alternative in {@link PainlessParser#unary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitUnary(PainlessParser.UnaryContext ctx);
+  T visitPost(PainlessParser.PostContext ctx);
   /**
-   * Visit a parse tree produced by the {@code precedence}
-   * labeled alternative in {@link PainlessParser#expression}.
+   * Visit a parse tree produced by the {@code read}
+   * labeled alternative in {@link PainlessParser#unary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitPrecedence(PainlessParser.PrecedenceContext ctx);
+  T visitRead(PainlessParser.ReadContext ctx);
   /**
-   * Visit a parse tree produced by the {@code preinc}
-   * labeled alternative in {@link PainlessParser#expression}.
+   * Visit a parse tree produced by the {@code numeric}
+   * labeled alternative in {@link PainlessParser#unary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitPreinc(PainlessParser.PreincContext ctx);
+  T visitNumeric(PainlessParser.NumericContext ctx);
   /**
-   * Visit a parse tree produced by the {@code postinc}
-   * labeled alternative in {@link PainlessParser#expression}.
+   * Visit a parse tree produced by the {@code true}
+   * labeled alternative in {@link PainlessParser#unary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitPostinc(PainlessParser.PostincContext ctx);
+  T visitTrue(PainlessParser.TrueContext ctx);
   /**
-   * Visit a parse tree produced by the {@code cast}
-   * labeled alternative in {@link PainlessParser#expression}.
+   * Visit a parse tree produced by the {@code false}
+   * labeled alternative in {@link PainlessParser#unary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitCast(PainlessParser.CastContext ctx);
+  T visitFalse(PainlessParser.FalseContext ctx);
   /**
    * Visit a parse tree produced by the {@code null}
-   * labeled alternative in {@link PainlessParser#expression}.
+   * labeled alternative in {@link PainlessParser#unary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
   T visitNull(PainlessParser.NullContext ctx);
   /**
-   * Visit a parse tree produced by the {@code binary}
-   * labeled alternative in {@link PainlessParser#expression}.
+   * Visit a parse tree produced by the {@code operator}
+   * labeled alternative in {@link PainlessParser#unary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitBinary(PainlessParser.BinaryContext ctx);
+  T visitOperator(PainlessParser.OperatorContext ctx);
   /**
-   * Visit a parse tree produced by the {@code true}
-   * labeled alternative in {@link PainlessParser#expression}.
+   * Visit a parse tree produced by the {@code cast}
+   * labeled alternative in {@link PainlessParser#unary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitTrue(PainlessParser.TrueContext ctx);
+  T visitCast(PainlessParser.CastContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code dynamic}
+   * labeled alternative in {@link PainlessParser#chain}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitDynamic(PainlessParser.DynamicContext ctx);
+  /**
+   * Visit a parse tree produced by the {@code static}
+   * labeled alternative in {@link PainlessParser#chain}.
+   * @param ctx the parse tree
+   * @return the visitor result
+   */
+  T visitStatic(PainlessParser.StaticContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#chain}.
+   * Visit a parse tree produced by the {@code newarray}
+   * labeled alternative in {@link PainlessParser#chain}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitChain(PainlessParser.ChainContext ctx);
+  T visitNewarray(PainlessParser.NewarrayContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#linkprec}.
+   * Visit a parse tree produced by the {@code exprprec}
+   * labeled alternative in {@link PainlessParser#primary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitLinkprec(PainlessParser.LinkprecContext ctx);
+  T visitExprprec(PainlessParser.ExprprecContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#linkcast}.
+   * Visit a parse tree produced by the {@code chainprec}
+   * labeled alternative in {@link PainlessParser#primary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitLinkcast(PainlessParser.LinkcastContext ctx);
+  T visitChainprec(PainlessParser.ChainprecContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#linkbrace}.
+   * Visit a parse tree produced by the {@code string}
+   * labeled alternative in {@link PainlessParser#primary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitLinkbrace(PainlessParser.LinkbraceContext ctx);
+  T visitString(PainlessParser.StringContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#linkdot}.
+   * Visit a parse tree produced by the {@code variable}
+   * labeled alternative in {@link PainlessParser#primary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitLinkdot(PainlessParser.LinkdotContext ctx);
+  T visitVariable(PainlessParser.VariableContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#linkcall}.
+   * Visit a parse tree produced by the {@code newobject}
+   * labeled alternative in {@link PainlessParser#primary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitLinkcall(PainlessParser.LinkcallContext ctx);
+  T visitNewobject(PainlessParser.NewobjectContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#linkvar}.
+   * Visit a parse tree produced by {@link PainlessParser#secondary}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitLinkvar(PainlessParser.LinkvarContext ctx);
+  T visitSecondary(PainlessParser.SecondaryContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#linkfield}.
+   * Visit a parse tree produced by the {@code callinvoke}
+   * labeled alternative in {@link PainlessParser#dot}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitLinkfield(PainlessParser.LinkfieldContext ctx);
+  T visitCallinvoke(PainlessParser.CallinvokeContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#linknew}.
+   * Visit a parse tree produced by the {@code fieldaccess}
+   * labeled alternative in {@link PainlessParser#dot}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitLinknew(PainlessParser.LinknewContext ctx);
+  T visitFieldaccess(PainlessParser.FieldaccessContext ctx);
   /**
-   * Visit a parse tree produced by {@link PainlessParser#linkstring}.
+   * Visit a parse tree produced by the {@code braceaccess}
+   * labeled alternative in {@link PainlessParser#brace}.
    * @param ctx the parse tree
    * @return the visitor result
    */
-  T visitLinkstring(PainlessParser.LinkstringContext ctx);
+  T visitBraceaccess(PainlessParser.BraceaccessContext ctx);
   /**
    * Visit a parse tree produced by {@link PainlessParser#arguments}.
    * @param ctx the parse tree
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java
index 9ecf67542489..3669ab24eccc 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/Walker.java
@@ -20,8 +20,13 @@
 package org.elasticsearch.painless.antlr;
 
 import org.antlr.v4.runtime.ANTLRInputStream;
+import org.antlr.v4.runtime.BaseErrorListener;
 import org.antlr.v4.runtime.CommonTokenStream;
+import org.antlr.v4.runtime.DiagnosticErrorListener;
 import org.antlr.v4.runtime.ParserRuleContext;
+import org.antlr.v4.runtime.RecognitionException;
+import org.antlr.v4.runtime.Recognizer;
+import org.antlr.v4.runtime.atn.PredictionMode;
 import org.elasticsearch.painless.CompilerSettings;
 import org.elasticsearch.painless.Operation;
 import org.elasticsearch.painless.Variables.Reserved;
@@ -29,51 +34,54 @@
 import org.elasticsearch.painless.antlr.PainlessParser.ArgumentsContext;
 import org.elasticsearch.painless.antlr.PainlessParser.AssignmentContext;
 import org.elasticsearch.painless.antlr.PainlessParser.BinaryContext;
+import org.elasticsearch.painless.antlr.PainlessParser.BlockContext;
+import org.elasticsearch.painless.antlr.PainlessParser.BoolContext;
+import org.elasticsearch.painless.antlr.PainlessParser.BraceaccessContext;
 import org.elasticsearch.painless.antlr.PainlessParser.BreakContext;
+import org.elasticsearch.painless.antlr.PainlessParser.CallinvokeContext;
 import org.elasticsearch.painless.antlr.PainlessParser.CastContext;
+import org.elasticsearch.painless.antlr.PainlessParser.ChainprecContext;
+import org.elasticsearch.painless.antlr.PainlessParser.CompContext;
 import org.elasticsearch.painless.antlr.PainlessParser.ConditionalContext;
 import org.elasticsearch.painless.antlr.PainlessParser.ContinueContext;
 import org.elasticsearch.painless.antlr.PainlessParser.DeclContext;
 import org.elasticsearch.painless.antlr.PainlessParser.DeclarationContext;
 import org.elasticsearch.painless.antlr.PainlessParser.DecltypeContext;
 import org.elasticsearch.painless.antlr.PainlessParser.DeclvarContext;
+import org.elasticsearch.painless.antlr.PainlessParser.DelimiterContext;
 import org.elasticsearch.painless.antlr.PainlessParser.DoContext;
+import org.elasticsearch.painless.antlr.PainlessParser.DynamicContext;
 import org.elasticsearch.painless.antlr.PainlessParser.EmptyContext;
-import org.elasticsearch.painless.antlr.PainlessParser.EmptyscopeContext;
 import org.elasticsearch.painless.antlr.PainlessParser.ExprContext;
 import org.elasticsearch.painless.antlr.PainlessParser.ExpressionContext;
-import org.elasticsearch.painless.antlr.PainlessParser.LinkbraceContext;
-import org.elasticsearch.painless.antlr.PainlessParser.LinkcallContext;
-import org.elasticsearch.painless.antlr.PainlessParser.LinkcastContext;
-import org.elasticsearch.painless.antlr.PainlessParser.LinkdotContext;
-import org.elasticsearch.painless.antlr.PainlessParser.ReadContext;
-import org.elasticsearch.painless.antlr.PainlessParser.LinkfieldContext;
-import org.elasticsearch.painless.antlr.PainlessParser.LinknewContext;
-import org.elasticsearch.painless.antlr.PainlessParser.LinkprecContext;
-import org.elasticsearch.painless.antlr.PainlessParser.ChainContext;
-import org.elasticsearch.painless.antlr.PainlessParser.LinkstringContext;
-import org.elasticsearch.painless.antlr.PainlessParser.LinkvarContext;
+import org.elasticsearch.painless.antlr.PainlessParser.ExprprecContext;
 import org.elasticsearch.painless.antlr.PainlessParser.FalseContext;
+import org.elasticsearch.painless.antlr.PainlessParser.FieldaccessContext;
 import org.elasticsearch.painless.antlr.PainlessParser.ForContext;
-import org.elasticsearch.painless.antlr.PainlessParser.GenericContext;
-import org.elasticsearch.painless.antlr.PainlessParser.IdentifierContext;
 import org.elasticsearch.painless.antlr.PainlessParser.IfContext;
 import org.elasticsearch.painless.antlr.PainlessParser.InitializerContext;
-import org.elasticsearch.painless.antlr.PainlessParser.MultipleContext;
+import org.elasticsearch.painless.antlr.PainlessParser.NewarrayContext;
+import org.elasticsearch.painless.antlr.PainlessParser.NewobjectContext;
 import org.elasticsearch.painless.antlr.PainlessParser.NullContext;
 import org.elasticsearch.painless.antlr.PainlessParser.NumericContext;
-import org.elasticsearch.painless.antlr.PainlessParser.PostincContext;
-import org.elasticsearch.painless.antlr.PainlessParser.PrecedenceContext;
-import org.elasticsearch.painless.antlr.PainlessParser.PreincContext;
+import org.elasticsearch.painless.antlr.PainlessParser.OperatorContext;
+import org.elasticsearch.painless.antlr.PainlessParser.PostContext;
+import org.elasticsearch.painless.antlr.PainlessParser.PreContext;
+import org.elasticsearch.painless.antlr.PainlessParser.ReadContext;
 import org.elasticsearch.painless.antlr.PainlessParser.ReturnContext;
+import org.elasticsearch.painless.antlr.PainlessParser.SecondaryContext;
 import org.elasticsearch.painless.antlr.PainlessParser.SingleContext;
 import org.elasticsearch.painless.antlr.PainlessParser.SourceContext;
 import org.elasticsearch.painless.antlr.PainlessParser.StatementContext;
+import org.elasticsearch.painless.antlr.PainlessParser.StaticContext;
+import org.elasticsearch.painless.antlr.PainlessParser.StringContext;
 import org.elasticsearch.painless.antlr.PainlessParser.ThrowContext;
+import org.elasticsearch.painless.antlr.PainlessParser.TrailerContext;
 import org.elasticsearch.painless.antlr.PainlessParser.TrapContext;
 import org.elasticsearch.painless.antlr.PainlessParser.TrueContext;
 import org.elasticsearch.painless.antlr.PainlessParser.TryContext;
 import org.elasticsearch.painless.antlr.PainlessParser.UnaryContext;
+import org.elasticsearch.painless.antlr.PainlessParser.VariableContext;
 import org.elasticsearch.painless.antlr.PainlessParser.WhileContext;
 import org.elasticsearch.painless.node.AExpression;
 import org.elasticsearch.painless.node.ALink;
@@ -82,11 +90,11 @@
 import org.elasticsearch.painless.node.EBinary;
 import org.elasticsearch.painless.node.EBool;
 import org.elasticsearch.painless.node.EBoolean;
-import org.elasticsearch.painless.node.EExplicit;
 import org.elasticsearch.painless.node.EChain;
 import org.elasticsearch.painless.node.EComp;
 import org.elasticsearch.painless.node.EConditional;
 import org.elasticsearch.painless.node.EDecimal;
+import org.elasticsearch.painless.node.EExplicit;
 import org.elasticsearch.painless.node.ENull;
 import org.elasticsearch.painless.node.ENumeric;
 import org.elasticsearch.painless.node.EUnary;
@@ -96,21 +104,23 @@
 import org.elasticsearch.painless.node.LField;
 import org.elasticsearch.painless.node.LNewArray;
 import org.elasticsearch.painless.node.LNewObj;
+import org.elasticsearch.painless.node.LStatic;
 import org.elasticsearch.painless.node.LString;
 import org.elasticsearch.painless.node.LVariable;
 import org.elasticsearch.painless.node.SBlock;
 import org.elasticsearch.painless.node.SBreak;
+import org.elasticsearch.painless.node.SCatch;
 import org.elasticsearch.painless.node.SContinue;
 import org.elasticsearch.painless.node.SDeclBlock;
 import org.elasticsearch.painless.node.SDeclaration;
 import org.elasticsearch.painless.node.SDo;
 import org.elasticsearch.painless.node.SExpression;
 import org.elasticsearch.painless.node.SFor;
+import org.elasticsearch.painless.node.SIf;
 import org.elasticsearch.painless.node.SIfElse;
 import org.elasticsearch.painless.node.SReturn;
 import org.elasticsearch.painless.node.SSource;
 import org.elasticsearch.painless.node.SThrow;
-import org.elasticsearch.painless.node.STrap;
 import org.elasticsearch.painless.node.STry;
 import org.elasticsearch.painless.node.SWhile;
 
@@ -120,7 +130,7 @@
 /**
  * Converts the ANTLR tree to a Painless tree.
  */
-public final class Walker extends PainlessParserBaseVisitor<ANode> {
+public final class Walker extends PainlessParserBaseVisitor<Object> {
 
     public static SSource buildPainlessTree(String source, Reserved reserved, CompilerSettings settings) {
         return new Walker(source, reserved, settings).source;
@@ -136,329 +146,292 @@ private Walker(String source, Reserved reserved, CompilerSettings settings) {
         this.source = (SSource)visit(buildAntlrTree(source));
     }
 
-    private SourceContext buildAntlrTree(final String source) {
-        final ANTLRInputStream stream = new ANTLRInputStream(source);
-        final PainlessLexer lexer = new ErrorHandlingLexer(stream);
-        final PainlessParser parser = new PainlessParser(new CommonTokenStream(lexer));
-        final ParserErrorStrategy strategy = new ParserErrorStrategy();
+    private SourceContext buildAntlrTree(String source) {
+        ANTLRInputStream stream = new ANTLRInputStream(source);
+        PainlessLexer lexer = new ErrorHandlingLexer(stream);
+        PainlessParser parser = new PainlessParser(new CommonTokenStream(lexer));
+        ParserErrorStrategy strategy = new ParserErrorStrategy();
 
         lexer.removeErrorListeners();
         parser.removeErrorListeners();
+
+        if (settings.isPicky()) {
+            setupPicky(parser);
+        }
+
         parser.setErrorHandler(strategy);
 
         return parser.source();
     }
 
-    private int line(final ParserRuleContext ctx) {
+    private void setupPicky(PainlessParser parser) {
+        // Diagnostic listener invokes syntaxError on other listeners for ambiguity issues,
+        parser.addErrorListener(new DiagnosticErrorListener(true));
+        // a second listener to fail the test when the above happens.
+        parser.addErrorListener(new BaseErrorListener() {
+            @Override
+            public void syntaxError(final Recognizer<?,?> recognizer, final Object offendingSymbol, final int line,
+                                    final int charPositionInLine, final String msg, final RecognitionException e) {
+                throw new AssertionError("line: " + line + ", offset: " + charPositionInLine +
+                    ", symbol:" + offendingSymbol + " " + msg);
+            }
+        });
+
+        // Enable exact ambiguity detection (costly). we enable exact since its the default for
+        // DiagnosticErrorListener, life is too short to think about what 'inexact ambiguity' might mean.
+        parser.getInterpreter().setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);
+    }
+
+    private int line(ParserRuleContext ctx) {
         return ctx.getStart().getLine();
     }
 
-    private String location(final ParserRuleContext ctx) {
+    private int offset(ParserRuleContext ctx) {
+        return ctx.getStart().getStartIndex();
+    }
+
+    private String location(ParserRuleContext ctx) {
         return "[ " + ctx.getStart().getLine() + " : " + ctx.getStart().getCharPositionInLine() + " ]";
     }
 
     @Override
-    public ANode visitSource(final SourceContext ctx) {
-        final List<AStatement> statements = new ArrayList<>();
+    public Object visitSource(SourceContext ctx) {
+        List<AStatement> statements = new ArrayList<>();
 
-        for (final StatementContext statement : ctx.statement()) {
+        for (StatementContext statement : ctx.statement()) {
             statements.add((AStatement)visit(statement));
         }
 
-        return new SSource(line(ctx), location(ctx), statements);
+        return new SSource(line(ctx), offset(ctx), location(ctx), statements);
     }
 
     @Override
-    public ANode visitIf(final IfContext ctx) {
-        final AExpression condition = (AExpression)visit(ctx.expression());
-        final AStatement ifblock = (AStatement)visit(ctx.block(0));
-        final AStatement elseblock = ctx.block(1) == null ? null : (AStatement)visit(ctx.block(1));
+    public Object visitIf(IfContext ctx) {
+        AExpression expression = (AExpression)visitExpression(ctx.expression());
+        SBlock ifblock = (SBlock)visit(ctx.trailer(0));
 
-        return new SIfElse(line(ctx), location(ctx), condition, ifblock, elseblock);
+        if (ctx.trailer().size() > 1) {
+            SBlock elseblock = (SBlock)visit(ctx.trailer(1));
+
+            return new SIfElse(line(ctx), offset(ctx), location(ctx), expression, ifblock, elseblock);
+        } else {
+            return new SIf(line(ctx), offset(ctx), location(ctx), expression, ifblock);
+        }
     }
 
     @Override
-    public ANode visitWhile(final WhileContext ctx) {
-        final AExpression condition = (AExpression)visit(ctx.expression());
-        final AStatement block = ctx.block() == null ? null : (AStatement)visit(ctx.block());
+    public Object visitWhile(WhileContext ctx) {
+        if (settings.getMaxLoopCounter() > 0) {
+            reserved.usesLoop();
+        }
 
-        reserved.usesLoop();
+        AExpression expression = (AExpression)visitExpression(ctx.expression());
 
-        return new SWhile(line(ctx), location(ctx), condition, block, settings.getMaxLoopCounter());
+        if (ctx.trailer() != null) {
+            SBlock block = (SBlock)visit(ctx.trailer());
+
+            return new SWhile(line(ctx), offset(ctx), location(ctx), settings.getMaxLoopCounter(), expression, block);
+        } else if (ctx.empty() != null) {
+            return new SWhile(line(ctx), offset(ctx), location(ctx), settings.getMaxLoopCounter(), expression, null);
+        } else {
+            throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
+        }
     }
 
     @Override
-    public ANode visitDo(final DoContext ctx) {
-        final AStatement block = ctx.block() == null ? null : (AStatement)visit(ctx.block());
-        final AExpression condition = (AExpression)visit(ctx.expression());
+    public Object visitDo(DoContext ctx) {
+        if (settings.getMaxLoopCounter() > 0) {
+            reserved.usesLoop();
+        }
 
-        reserved.usesLoop();
+        AExpression expression = (AExpression)visitExpression(ctx.expression());
+        SBlock block = (SBlock)visit(ctx.block());
 
-        return new SDo(line(ctx), location(ctx), block, condition, settings.getMaxLoopCounter());
+        return new SDo(line(ctx), offset(ctx), location(ctx), settings.getMaxLoopCounter(), block, expression);
     }
 
     @Override
-    public ANode visitFor(final ForContext ctx) {
-        final ANode intializer = ctx.initializer() == null ? null : visit(ctx.initializer());
-        final AExpression condition = ctx.expression() == null ? null : (AExpression)visit(ctx.expression());
-        final AExpression afterthought = ctx.afterthought() == null ? null : (AExpression)visit(ctx.afterthought());
-        final AStatement block = ctx.block() == null ? null : (AStatement)visit(ctx.block());
+    public Object visitFor(ForContext ctx) {
+        if (settings.getMaxLoopCounter() > 0) {
+            reserved.usesLoop();
+        }
+
+        ANode initializer = ctx.initializer() == null ? null : (ANode)visit(ctx.initializer());
+        AExpression expression = ctx.expression() == null ? null : (AExpression)visitExpression(ctx.expression());
+        AExpression afterthought = ctx.afterthought() == null ? null : (AExpression)visit(ctx.afterthought());
 
-        reserved.usesLoop();
+        if (ctx.trailer() != null) {
+            SBlock block = (SBlock)visit(ctx.trailer());
 
-        return new SFor(line(ctx), location(ctx), intializer, condition, afterthought, block, settings.getMaxLoopCounter());
+            return new SFor(line(ctx), offset(ctx), location(ctx),
+                settings.getMaxLoopCounter(), initializer, expression, afterthought, block);
+        } else if (ctx.empty() != null) {
+            return new SFor(line(ctx), offset(ctx), location(ctx),
+                settings.getMaxLoopCounter(), initializer, expression, afterthought, null);
+        } else {
+            throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
+        }
     }
 
     @Override
-    public ANode visitDecl(final DeclContext ctx) {
+    public Object visitDecl(DeclContext ctx) {
         return visit(ctx.declaration());
     }
 
     @Override
-    public ANode visitContinue(final ContinueContext ctx) {
-        return new SContinue(line(ctx), location(ctx));
+    public Object visitContinue(ContinueContext ctx) {
+        return new SContinue(line(ctx), offset(ctx), location(ctx));
     }
 
     @Override
-    public ANode visitBreak(final BreakContext ctx) {
-        return new SBreak(line(ctx), location(ctx));
+    public Object visitBreak(BreakContext ctx) {
+        return new SBreak(line(ctx), offset(ctx), location(ctx));
     }
 
     @Override
-    public ANode visitReturn(final ReturnContext ctx) {
-        final AExpression expression = (AExpression)visit(ctx.expression());
+    public Object visitReturn(ReturnContext ctx) {
+        AExpression expression = (AExpression)visitExpression(ctx.expression());
 
-        return new SReturn(line(ctx), location(ctx), expression);
+        return new SReturn(line(ctx), offset(ctx), location(ctx), expression);
     }
 
     @Override
-    public ANode visitTry(final TryContext ctx) {
-        final AStatement block = (AStatement)visit(ctx.block());
-        final List<STrap> traps = new ArrayList<>();
+    public Object visitTry(TryContext ctx) {
+        SBlock block = (SBlock)visit(ctx.block());
+        List<SCatch> catches = new ArrayList<>();
 
-        for (final TrapContext trap : ctx.trap()) {
-            traps.add((STrap)visit(trap));
+        for (TrapContext trap : ctx.trap()) {
+            catches.add((SCatch)visit(trap));
         }
 
-        return new STry(line(ctx), location(ctx), block, traps);
+        return new STry(line(ctx), offset(ctx), location(ctx), block, catches);
     }
 
     @Override
-    public ANode visitThrow(final ThrowContext ctx) {
-        final AExpression expression = (AExpression)visit(ctx.expression());
+    public Object visitThrow(ThrowContext ctx) {
+        AExpression expression = (AExpression)visitExpression(ctx.expression());
 
-        return new SThrow(line(ctx), location(ctx), expression);
+        return new SThrow(line(ctx), offset(ctx), location(ctx), expression);
     }
 
     @Override
-    public ANode visitExpr(final ExprContext ctx) {
-        final AExpression expression = (AExpression)visit(ctx.expression());
+    public Object visitExpr(ExprContext ctx) {
+        AExpression expression = (AExpression)visitExpression(ctx.expression());
 
-        return new SExpression(line(ctx), location(ctx), expression);
+        return new SExpression(line(ctx), offset(ctx), location(ctx), expression);
     }
 
     @Override
-    public ANode visitMultiple(final MultipleContext ctx) {
-        final List<AStatement> statements = new ArrayList<>();
+    public Object visitTrailer(TrailerContext ctx) {
+        if (ctx.block() != null) {
+            return visit(ctx.block());
+        } else if (ctx.statement() != null) {
+            List<AStatement> statements = new ArrayList<>();
+            statements.add((AStatement)visit(ctx.statement()));
 
-        for (final StatementContext statement : ctx.statement()) {
-            statements.add((AStatement)visit(statement));
+            return new SBlock(line(ctx), offset(ctx), location(ctx), statements);
+        } else {
+            throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
         }
-
-        return new SBlock(line(ctx), location(ctx), statements);
     }
 
     @Override
-    public ANode visitSingle(final SingleContext ctx) {
-        final List<AStatement> statements = new ArrayList<>();
-        statements.add((AStatement)visit(ctx.statement()));
+    public Object visitBlock(BlockContext ctx) {
+        if (ctx.statement().isEmpty()) {
+            return null;
+        } else {
+            List<AStatement> statements = new ArrayList<>();
 
-        return new SBlock(line(ctx), location(ctx), statements);
-    }
+            for (StatementContext statement : ctx.statement()) {
+                statements.add((AStatement)visit(statement));
+            }
 
-    @Override
-    public ANode visitEmpty(final EmptyContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+            return new SBlock(line(ctx), offset(ctx), location(ctx), statements);
+        }
     }
 
     @Override
-    public ANode visitEmptyscope(final EmptyscopeContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    public Object visitEmpty(EmptyContext ctx) {
+        throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
     }
 
     @Override
-    public ANode visitInitializer(final InitializerContext ctx) {
+    public Object visitInitializer(InitializerContext ctx) {
         if (ctx.declaration() != null) {
             return visit(ctx.declaration());
         } else if (ctx.expression() != null) {
-            return visit(ctx.expression());
-        }
-
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
-    }
-
-    @Override
-    public ANode visitAfterthought(final AfterthoughtContext ctx) {
-        return visit(ctx.expression());
-    }
-
-    @Override
-    public ANode visitDeclaration(final DeclarationContext ctx) {
-        final String type = ctx.decltype().getText();
-        final List<SDeclaration> declarations = new ArrayList<>();
-
-        for (final DeclvarContext declvar : ctx.declvar()) {
-            final String name = declvar.identifier().getText();
-            final AExpression expression = declvar.expression() == null ? null : (AExpression)visit(declvar.expression());
-            declarations.add(new SDeclaration(line(ctx), location(ctx), type, name, expression));
+            return visitExpression(ctx.expression());
+        } else {
+            throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
         }
-
-        return new SDeclBlock(line(ctx), location(ctx), declarations);
     }
 
     @Override
-    public ANode visitDecltype(final DecltypeContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    public Object visitAfterthought(AfterthoughtContext ctx) {
+        return visitExpression(ctx.expression());
     }
 
     @Override
-    public ANode visitDeclvar(final DeclvarContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
-    }
-
-    @Override
-    public ANode visitTrap(final TrapContext ctx) {
-        final String type = ctx.identifier(0).getText();
-        final String name = ctx.identifier(1).getText();
-        final AStatement block = ctx.block() == null ? null : (AStatement)visit(ctx.block());
+    public Object visitDeclaration(DeclarationContext ctx) {
+        String type = ctx.decltype().getText();
+        List<SDeclaration> declarations = new ArrayList<>();
 
-        return new STrap(line(ctx), location(ctx), type, name, block);
-    }
+        for (DeclvarContext declvar : ctx.declvar()) {
+            String name = declvar.ID().getText();
+            AExpression expression = declvar.expression() == null ? null : (AExpression)visitExpression(declvar.expression());
 
-    @Override
-    public ANode visitIdentifier(final IdentifierContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
-    }
-
-    @Override
-    public ANode visitGeneric(final GenericContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
-    }
-
-    @Override
-    public ANode visitPrecedence(final PrecedenceContext ctx) {
-        return visit(ctx.expression());
-    }
-
-    @Override
-    public ANode visitNumeric(final NumericContext ctx) {
-        final boolean negate = ctx.parent instanceof UnaryContext && ((UnaryContext)ctx.parent).SUB() != null;
-
-        if (ctx.DECIMAL() != null) {
-            return new EDecimal(line(ctx), location(ctx), (negate ? "-" : "") + ctx.DECIMAL().getText());
-        } else if (ctx.HEX() != null) {
-            return new ENumeric(line(ctx), location(ctx), (negate ? "-" : "") + ctx.HEX().getText().substring(2), 16);
-        } else if (ctx.INTEGER() != null) {
-            return new ENumeric(line(ctx), location(ctx), (negate ? "-" : "") + ctx.INTEGER().getText(), 10);
-        } else if (ctx.OCTAL() != null) {
-            return new ENumeric(line(ctx), location(ctx), (negate ? "-" : "") + ctx.OCTAL().getText().substring(1), 8);
-        } else {
-            throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+            declarations.add(new SDeclaration(line(ctx), offset(ctx), location(ctx), type, name, expression));
         }
-    }
 
-    @Override
-    public ANode visitTrue(final TrueContext ctx) {
-        return new EBoolean(line(ctx), location(ctx), true);
+        return new SDeclBlock(line(ctx), offset(ctx), location(ctx), declarations);
     }
 
     @Override
-    public ANode visitFalse(FalseContext ctx) {
-        return new EBoolean(line(ctx), location(ctx), false);
+    public Object visitDecltype(DecltypeContext ctx) {
+        throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
     }
 
     @Override
-    public ANode visitNull(final NullContext ctx) {
-        return new ENull(line(ctx), location(ctx));
+    public Object visitDeclvar(DeclvarContext ctx) {
+        throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
     }
 
     @Override
-    public ANode visitPostinc(final PostincContext ctx) {
-        final List<ALink> links = new ArrayList<>();
-        final Operation operation;
-
-        visitChain(ctx.chain(), links);
-
-        if (ctx.INCR() != null) {
-            operation = Operation.INCR;
-        } else if (ctx.DECR() != null) {
-            operation = Operation.DECR;
-        } else {
-            throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
-        }
+    public Object visitTrap(TrapContext ctx) {
+        String type = ctx.TYPE().getText();
+        String name = ctx.ID().getText();
+        SBlock block = (SBlock)visit(ctx.block());
 
-        return new EChain(line(ctx), location(ctx), links, false, true, operation, null);
+        return new SCatch(line(ctx), offset(ctx), location(ctx), type, name, block);
     }
 
     @Override
-    public ANode visitPreinc(final PreincContext ctx) {
-        final List<ALink> links = new ArrayList<>();
-        final Operation operation;
-
-        visitChain(ctx.chain(), links);
-
-        if (ctx.INCR() != null) {
-            operation = Operation.INCR;
-        } else if (ctx.DECR() != null) {
-            operation = Operation.DECR;
-        } else {
-            throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
-        }
-
-        return new EChain(line(ctx), location(ctx), links, true, false, operation, null);
+    public Object visitDelimiter(DelimiterContext ctx) {
+        throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
     }
 
-    @Override
-    public ANode visitRead(final ReadContext ctx) {
-        final List<ALink> links = new ArrayList<>();
-
-        visitChain(ctx.chain(), links);
+    private Object visitExpression(ExpressionContext ctx) {
+        Object expression = visit(ctx);
 
-        return new EChain(line(ctx), location(ctx), links, false, false, null, null);
-    }
+        if (expression instanceof List) {
+            @SuppressWarnings("unchecked")
+            List<ALink> links = (List<ALink>)expression;
 
-    @Override
-    public ANode visitUnary(final UnaryContext ctx) {
-        if (ctx.SUB() != null && ctx.expression() instanceof NumericContext) {
-            return visit(ctx.expression());
+            return new EChain(line(ctx), offset(ctx), location(ctx), links, false, false, null, null);
         } else {
-            final Operation operation;
-
-            if (ctx.BOOLNOT() != null) {
-                operation = Operation.NOT;
-            } else if (ctx.BWNOT() != null) {
-                operation = Operation.BWNOT;
-            } else if (ctx.ADD() != null) {
-                operation = Operation.ADD;
-            } else if (ctx.SUB() != null) {
-                operation = Operation.SUB;
-            } else {
-                throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
-            }
-
-            return new EUnary(line(ctx), location(ctx), operation, (AExpression)visit(ctx.expression()));
+            return expression;
         }
     }
 
     @Override
-    public ANode visitCast(final CastContext ctx) {
-        return new EExplicit(line(ctx), location(ctx), ctx.decltype().getText(), (AExpression)visit(ctx.expression()));
+    public Object visitSingle(SingleContext ctx) {
+        return visit(ctx.unary());
     }
 
     @Override
-    public ANode visitBinary(final BinaryContext ctx) {
-        final AExpression left = (AExpression)visit(ctx.expression(0));
-        final AExpression right = (AExpression)visit(ctx.expression(1));
+    public Object visitBinary(BinaryContext ctx) {
+        AExpression left = (AExpression)visitExpression(ctx.expression(0));
+        AExpression right = (AExpression)visitExpression(ctx.expression(1));
         final Operation operation;
 
         if (ctx.MUL() != null) {
@@ -487,13 +460,13 @@ public ANode visitBinary(final BinaryContext ctx) {
             throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
         }
 
-        return new EBinary(line(ctx), location(ctx), operation, left, right);
+        return new EBinary(line(ctx), offset(ctx), location(ctx), operation, left, right);
     }
 
     @Override
-    public ANode visitComp(PainlessParser.CompContext ctx) {
-        final AExpression left = (AExpression)visit(ctx.expression(0));
-        final AExpression right = (AExpression)visit(ctx.expression(1));
+    public Object visitComp(CompContext ctx) {
+        AExpression left = (AExpression)visitExpression(ctx.expression(0));
+        AExpression right = (AExpression)visitExpression(ctx.expression(1));
         final Operation operation;
 
         if (ctx.LT() != null) {
@@ -516,13 +489,13 @@ public ANode visitComp(PainlessParser.CompContext ctx) {
             throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
         }
 
-        return new EComp(line(ctx), location(ctx), operation, left, right);
+        return new EComp(line(ctx), offset(ctx), location(ctx), operation, left, right);
     }
 
     @Override
-    public ANode visitBool(PainlessParser.BoolContext ctx) {
-        final AExpression left = (AExpression)visit(ctx.expression(0));
-        final AExpression right = (AExpression)visit(ctx.expression(1));
+    public Object visitBool(BoolContext ctx) {
+        AExpression left = (AExpression)visitExpression(ctx.expression(0));
+        AExpression right = (AExpression)visitExpression(ctx.expression(1));
         final Operation operation;
 
         if (ctx.BOOLAND() != null) {
@@ -533,27 +506,27 @@ public ANode visitBool(PainlessParser.BoolContext ctx) {
             throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
         }
 
-        return new EBool(line(ctx), location(ctx), operation, left, right);
+        return new EBool(line(ctx), offset(ctx), location(ctx), operation, left, right);
     }
 
-
     @Override
-    public ANode visitConditional(final ConditionalContext ctx) {
-        final AExpression condition = (AExpression)visit(ctx.expression(0));
-        final AExpression left = (AExpression)visit(ctx.expression(1));
-        final AExpression right = (AExpression)visit(ctx.expression(2));
+    public Object visitConditional(ConditionalContext ctx) {
+        AExpression condition = (AExpression)visitExpression(ctx.expression(0));
+        AExpression left = (AExpression)visitExpression(ctx.expression(1));
+        AExpression right = (AExpression)visitExpression(ctx.expression(2));
 
-        return new EConditional(line(ctx), location(ctx), condition, left, right);
+        return new EConditional(line(ctx), offset(ctx), location(ctx), condition, left, right);
     }
 
     @Override
-    public ANode visitAssignment(final AssignmentContext ctx) {
-        final List<ALink> links = new ArrayList<>();
+    public Object visitAssignment(AssignmentContext ctx) {
+        @SuppressWarnings("unchecked")
+        List<ALink> links = (List<ALink>)visit(ctx.chain());
         final Operation operation;
 
-        visitChain(ctx.chain(), links);
-
-        if (ctx.AMUL() != null) {
+        if (ctx.ASSIGN() != null) {
+            operation = null;
+        } else if (ctx.AMUL() != null) {
             operation = Operation.MUL;
         } else if (ctx.ADIV() != null) {
             operation = Operation.DIV;
@@ -576,222 +549,290 @@ public ANode visitAssignment(final AssignmentContext ctx) {
         } else if (ctx.AOR() != null) {
             operation = Operation.BWOR;
         } else {
-            operation = null;
+            throw new IllegalStateException("Error " + location(ctx) + ": Illegal tree structure.");
         }
 
-        return new EChain(line(ctx), location(ctx), links, false, false, operation, (AExpression)visit(ctx.expression()));
+        AExpression expression = (AExpression)visitExpression(ctx.expression());
+
+        return new EChain(line(ctx), offset(ctx), location(ctx), links, false, false, operation, expression);
     }
 
-    private void visitChain(final ChainContext ctx, final List<ALink> links) {
-        if (ctx.linkprec() != null) {
-            visitLinkprec(ctx.linkprec(), links);
-        } else if (ctx.linkcast() != null) {
-            visitLinkcast(ctx.linkcast(), links);
-        } else if (ctx.linkvar() != null) {
-            visitLinkvar(ctx.linkvar(), links);
-        } else if (ctx.linknew() != null) {
-            visitLinknew(ctx.linknew(), links);
-        } else if (ctx.linkstring() != null) {
-            visitLinkstring(ctx.linkstring(), links);
+    private Object visitUnary(UnaryContext ctx) {
+        Object expression = visit(ctx);
+
+        if (expression instanceof List) {
+            @SuppressWarnings("unchecked")
+            List<ALink> links = (List<ALink>)expression;
+
+            return new EChain(line(ctx), offset(ctx), location(ctx), links, false, false, null, null);
         } else {
-            throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+            return expression;
         }
     }
 
     @Override
-    public ANode visitChain(final ChainContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
-    }
+    public Object visitPre(PreContext ctx) {
+        @SuppressWarnings("unchecked")
+        List<ALink> links = (List<ALink>)visit(ctx.chain());
+        final Operation operation;
 
-    private void visitLinkprec(final LinkprecContext ctx, final List<ALink> links) {
-        if (ctx.linkprec() != null) {
-            visitLinkprec(ctx.linkprec(), links);
-        } else if (ctx.linkcast() != null) {
-            visitLinkcast(ctx.linkcast(), links);
-        } else if (ctx.linkvar() != null) {
-            visitLinkvar(ctx.linkvar(), links);
-        } else if (ctx.linknew() != null) {
-            visitLinknew(ctx.linknew(), links);
-        } else if (ctx.linkstring() != null) {
-            visitLinkstring(ctx.linkstring(), links);
+        if (ctx.INCR() != null) {
+            operation = Operation.INCR;
+        } else if (ctx.DECR() != null) {
+            operation = Operation.DECR;
         } else {
-            throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+            throw new IllegalStateException("Error " + location(ctx) + ": Illegal tree structure.");
         }
 
-        if (ctx.linkbrace() != null) {
-            visitLinkbrace(ctx.linkbrace(), links);
-        } else if (ctx.linkdot() != null) {
-            visitLinkdot(ctx.linkdot(), links);
-        }
+        return new EChain(line(ctx), offset(ctx), location(ctx), links, true, false, operation, null);
     }
 
     @Override
-    public ANode visitLinkprec(final LinkprecContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
-    }
+    public Object visitPost(PostContext ctx) {
+        @SuppressWarnings("unchecked")
+        List<ALink> links = (List<ALink>)visit(ctx.chain());
+        final Operation operation;
 
-    private void visitLinkcast(final LinkcastContext ctx, final List<ALink> links) {
-        if (ctx.linkprec() != null) {
-            visitLinkprec(ctx.linkprec(), links);
-        } else if (ctx.linkcast() != null) {
-            visitLinkcast(ctx.linkcast(), links);
-        } else if (ctx.linkvar() != null) {
-            visitLinkvar(ctx.linkvar(), links);
-        } else if (ctx.linknew() != null) {
-            visitLinknew(ctx.linknew(), links);
-        } else if (ctx.linkstring() != null) {
-            visitLinkstring(ctx.linkstring(), links);
+        if (ctx.INCR() != null) {
+            operation = Operation.INCR;
+        } else if (ctx.DECR() != null) {
+            operation = Operation.DECR;
         } else {
-            throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+            throw new IllegalStateException("Error " + location(ctx) + ": Illegal tree structure.");
         }
 
-        links.add(new LCast(line(ctx), location(ctx), ctx.decltype().getText()));
+        return new EChain(line(ctx), offset(ctx), location(ctx), links, false, true, operation, null);
     }
 
     @Override
-    public ANode visitLinkcast(final LinkcastContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    public Object visitRead(ReadContext ctx) {
+        return visit(ctx.chain());
     }
 
-    private void visitLinkbrace(final LinkbraceContext ctx, final List<ALink> links) {
-        links.add(new LBrace(line(ctx), location(ctx), (AExpression)visit(ctx.expression())));
+    @Override
+    public Object visitNumeric(NumericContext ctx) {
+        final boolean negate = ctx.parent instanceof OperatorContext && ((OperatorContext)ctx.parent).SUB() != null;
 
-        if (ctx.linkbrace() != null) {
-            visitLinkbrace(ctx.linkbrace(), links);
-        } else if (ctx.linkdot() != null) {
-            visitLinkdot(ctx.linkdot(), links);
+        if (ctx.DECIMAL() != null) {
+            return new EDecimal(line(ctx), offset(ctx), location(ctx), (negate ? "-" : "") + ctx.DECIMAL().getText());
+        } else if (ctx.HEX() != null) {
+            return new ENumeric(line(ctx), offset(ctx), location(ctx), (negate ? "-" : "") + ctx.HEX().getText().substring(2), 16);
+        } else if (ctx.INTEGER() != null) {
+            return new ENumeric(line(ctx), offset(ctx), location(ctx), (negate ? "-" : "") + ctx.INTEGER().getText(), 10);
+        } else if (ctx.OCTAL() != null) {
+            return new ENumeric(line(ctx), offset(ctx), location(ctx), (negate ? "-" : "") + ctx.OCTAL().getText().substring(1), 8);
+        } else {
+            throw new IllegalStateException("Error " + location(ctx) + ": Illegal tree structure.");
         }
     }
 
     @Override
-    public ANode visitLinkbrace(final LinkbraceContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    public Object visitTrue(TrueContext ctx) {
+        return new EBoolean(line(ctx), offset(ctx), location(ctx), true);
     }
 
-    private void visitLinkdot(final LinkdotContext ctx, final List<ALink> links) {
-        if (ctx.linkcall() != null) {
-            visitLinkcall(ctx.linkcall(), links);
-        } else if (ctx.linkfield() != null) {
-            visitLinkfield(ctx.linkfield(), links);
-        }
+    @Override
+    public Object visitFalse(FalseContext ctx) {
+        return new EBoolean(line(ctx), offset(ctx), location(ctx), false);
     }
 
     @Override
-    public ANode visitLinkdot(final LinkdotContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    public Object visitNull(NullContext ctx) {
+        return new ENull(line(ctx), offset(ctx), location(ctx));
     }
 
-    private void visitLinkcall(final LinkcallContext ctx, final List<ALink> links) {
-        final List<AExpression> arguments = new ArrayList<>();
-
-        for (final ExpressionContext expression : ctx.arguments().expression()) {
-            arguments.add((AExpression)visit(expression));
-        }
+    @Override
+    public Object visitOperator(OperatorContext ctx) {
+        if (ctx.SUB() != null && ctx.unary() instanceof NumericContext) {
+            return visit(ctx.unary());
+        } else {
+            AExpression expression = (AExpression)visitUnary(ctx.unary());
+            final Operation operation;
 
-        links.add(new LCall(line(ctx), location(ctx), ctx.EXTID().getText(), arguments));
+            if (ctx.BOOLNOT() != null) {
+                operation = Operation.NOT;
+            } else if (ctx.BWNOT() != null) {
+                operation = Operation.BWNOT;
+            } else if (ctx.ADD() != null) {
+                operation = Operation.ADD;
+            } else if (ctx.SUB() != null) {
+                operation = Operation.SUB;
+            } else {
+                throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
+            }
 
-        if (ctx.linkbrace() != null) {
-            visitLinkbrace(ctx.linkbrace(), links);
-        } else if (ctx.linkdot() != null) {
-            visitLinkdot(ctx.linkdot(), links);
+            return new EUnary(line(ctx), offset(ctx), location(ctx), operation, expression);
         }
     }
 
     @Override
-    public ANode visitLinkcall(final LinkcallContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    public Object visitCast(CastContext ctx) {
+        String type = ctx.decltype().getText();
+        Object child = visit(ctx.unary());
+
+        if (child instanceof List) {
+            @SuppressWarnings("unchecked")
+            List<ALink> links = (List<ALink>)child;
+            links.add(new LCast(line(ctx), offset(ctx), location(ctx), type));
+
+            return links;
+        } else {
+            return new EExplicit(line(ctx), offset(ctx), location(ctx), type, (AExpression)child);
+        }
     }
 
-    private void visitLinkvar(final LinkvarContext ctx, final List<ALink> links) {
-        final String name = ctx.identifier().getText();
+    @Override
+    public Object visitDynamic(DynamicContext ctx) {
+        Object child = visit(ctx.primary());
 
-        reserved.markReserved(name);
+        if (child instanceof List) {
+            @SuppressWarnings("unchecked")
+            List<ALink> links = (List<ALink>)child;
 
-        links.add(new LVariable(line(ctx), location(ctx), name));
+            for (SecondaryContext secondary : ctx.secondary()) {
+                links.add((ALink)visit(secondary));
+            }
 
-        if (ctx.linkbrace() != null) {
-            visitLinkbrace(ctx.linkbrace(), links);
-        } else if (ctx.linkdot() != null) {
-            visitLinkdot(ctx.linkdot(), links);
+            return links;
+        } else if (!ctx.secondary().isEmpty()) {
+            throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
+        } else {
+            return child;
         }
     }
 
     @Override
-    public ANode visitLinkvar(final LinkvarContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    public Object visitStatic(StaticContext ctx) {
+        String type = ctx.decltype().getText();
+        List<ALink> links = new ArrayList<>();
+
+        links.add(new LStatic(line(ctx), offset(ctx), location(ctx), type));
+        links.add((ALink)visit(ctx.dot()));
+
+        for (SecondaryContext secondary : ctx.secondary()) {
+            links.add((ALink)visit(secondary));
+        }
+
+        return links;
     }
 
-    private void visitLinkfield(final LinkfieldContext ctx, final List<ALink> links) {
-        final String value;
+    @Override
+    public Object visitNewarray(NewarrayContext ctx) {
+        String type = ctx.TYPE().getText();
+        List<AExpression> expressions = new ArrayList<>();
 
-        if (ctx.EXTID() != null) {
-            value = ctx.EXTID().getText();
-        } else if (ctx.EXTINTEGER() != null) {
-            value = ctx.EXTINTEGER().getText();
-        } else {
-            throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+        for (ExpressionContext expression : ctx.expression()) {
+            expressions.add((AExpression)visitExpression(expression));
         }
 
-        links.add(new LField(line(ctx), location(ctx), value));
+        List<ALink> links = new ArrayList<>();
+        links.add(new LNewArray(line(ctx), offset(ctx), location(ctx), type, expressions));
+
+        if (ctx.dot() != null) {
+            links.add((ALink)visit(ctx.dot()));
 
-        if (ctx.linkbrace() != null) {
-            visitLinkbrace(ctx.linkbrace(), links);
-        } else if (ctx.linkdot() != null) {
-            visitLinkdot(ctx.linkdot(), links);
+            for (SecondaryContext secondary : ctx.secondary()) {
+                links.add((ALink)visit(secondary));
+            }
+        } else if (!ctx.secondary().isEmpty()) {
+            throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
         }
+
+        return links;
     }
 
     @Override
-    public ANode visitLinkfield(final LinkfieldContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    public Object visitExprprec(ExprprecContext ctx) {
+        return visit(ctx.expression());
     }
 
-    private void visitLinknew(final LinknewContext ctx, final List<ALink> links) {
-        final List<AExpression> arguments = new ArrayList<>();
+    @Override
+    public Object visitChainprec(ChainprecContext ctx) {
+        return visit(ctx.unary());
+    }
 
-        if (ctx.arguments() != null) {
-            for (final ExpressionContext expression : ctx.arguments().expression()) {
-                arguments.add((AExpression)visit(expression));
-            }
+    @Override
+    public Object visitString(StringContext ctx) {
+        String string = ctx.STRING().getText().substring(1, ctx.STRING().getText().length() - 1);
+        List<ALink> links = new ArrayList<>();
+        links.add(new LString(line(ctx), offset(ctx), location(ctx), string));
 
-            links.add(new LNewObj(line(ctx), location(ctx), ctx.identifier().getText(), arguments));
-        } else if (ctx.expression().size() > 0) {
-            for (final ExpressionContext expression : ctx.expression()) {
-                arguments.add((AExpression)visit(expression));
-            }
+        return links;
+    }
 
-            links.add(new LNewArray(line(ctx), location(ctx), ctx.identifier().getText(), arguments));
-        } else {
-            throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    @Override
+    public Object visitVariable(VariableContext ctx) {
+        String name = ctx.ID().getText();
+        List<ALink> links = new ArrayList<>();
+        links.add(new LVariable(line(ctx), offset(ctx), location(ctx), name));
+
+        reserved.markReserved(name);
+
+        return links;
+    }
+
+    @Override
+    public Object visitNewobject(NewobjectContext ctx) {
+        String type = ctx.TYPE().getText();
+        List<AExpression> arguments = new ArrayList<>();
+
+        for (ExpressionContext expression : ctx.arguments().expression()) {
+            arguments.add((AExpression)visitExpression(expression));
         }
 
-        if (ctx.linkdot() != null) {
-            visitLinkdot(ctx.linkdot(), links);
+        List<ALink> links = new ArrayList<>();
+        links.add(new LNewObj(line(ctx), offset(ctx), location(ctx), type, arguments));
+
+        return links;
+    }
+
+    @Override
+    public Object visitSecondary(SecondaryContext ctx) {
+        if (ctx.dot() != null) {
+            return visit(ctx.dot());
+        } else if (ctx.brace() != null) {
+            return visit(ctx.brace());
+        } else {
+            throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
         }
     }
 
     @Override
-    public ANode visitLinknew(final LinknewContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    public Object visitCallinvoke(CallinvokeContext ctx) {
+        String name = ctx.DOTID().getText();
+        List<AExpression> arguments = new ArrayList<>();
+
+        for (ExpressionContext expression : ctx.arguments().expression()) {
+            arguments.add((AExpression)visitExpression(expression));
+        }
+
+        return new LCall(line(ctx), offset(ctx), location(ctx), name, arguments);
     }
 
-    private void visitLinkstring(final LinkstringContext ctx, final List<ALink> links) {
-        links.add(new LString(line(ctx), location(ctx), ctx.STRING().getText().substring(1, ctx.STRING().getText().length() - 1)));
+    @Override
+    public Object visitFieldaccess(FieldaccessContext ctx) {
+        final String value;
 
-        if (ctx.linkbrace() != null) {
-            visitLinkbrace(ctx.linkbrace(), links);
-        } else if (ctx.linkdot() != null) {
-            visitLinkdot(ctx.linkdot(), links);
+        if (ctx.DOTID() != null) {
+            value = ctx.DOTID().getText();
+        } else if (ctx.DOTINTEGER() != null) {
+            value = ctx.DOTINTEGER().getText();
+        } else {
+            throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
         }
+
+        return new LField(line(ctx), offset(ctx), location(ctx), value);
     }
 
     @Override
-    public ANode visitLinkstring(final LinkstringContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    public Object visitBraceaccess(BraceaccessContext ctx) {
+        AExpression expression = (AExpression)visitExpression(ctx.expression());
+
+        return new LBrace(line(ctx), offset(ctx), location(ctx), expression);
     }
 
     @Override
-    public ANode visitArguments(final ArgumentsContext ctx) {
-        throw new IllegalStateException("Error " + location(ctx) + ": Unexpected state.");
+    public Object visitArguments(ArgumentsContext ctx) {
+        throw new IllegalStateException("Error " + location(ctx) + " Illegal tree structure.");
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java
index 54eb8091e8e5..c46181817e2b 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AExpression.java
@@ -98,8 +98,8 @@
      */
     protected Label fals = null;
 
-    public AExpression(final int line, final String location) {
-        super(line, location);
+    public AExpression(int line, int offset, String location) {
+        super(line, offset, location);
     }
 
     /**
@@ -110,7 +110,7 @@ public AExpression(final int line, final String location) {
     /**
      * Writes ASM based on the data collected during the analysis phase.
      */
-    abstract void write(MethodWriter adapter);
+    abstract void write(MethodWriter writer);
 
     /**
      * Inserts {@link ECast} nodes into the tree for implicit casts.  Also replaces
@@ -124,7 +124,7 @@ AExpression cast(Variables variables) {
             if (constant == null || this instanceof EConstant) {
                 return this;
             } else {
-                final EConstant econstant = new EConstant(line, location, constant);
+                final EConstant econstant = new EConstant(line, offset, location, constant);
                 econstant.analyze(variables);
 
                 if (!expected.equals(econstant.actual)) {
@@ -135,7 +135,7 @@ AExpression cast(Variables variables) {
             }
         } else {
             if (constant == null) {
-                final ECast ecast = new ECast(line, location, this, cast);
+                final ECast ecast = new ECast(line, offset, location, this, cast);
                 ecast.statement = statement;
                 ecast.actual = expected;
                 ecast.isNull = isNull;
@@ -145,7 +145,7 @@ AExpression cast(Variables variables) {
                 if (expected.sort.constant) {
                     constant = AnalyzerCaster.constCast(location, constant, cast);
 
-                    final EConstant econstant = new EConstant(line, location, constant);
+                    final EConstant econstant = new EConstant(line, offset, location, constant);
                     econstant.analyze(variables);
 
                     if (!expected.equals(econstant.actual)) {
@@ -154,19 +154,19 @@ AExpression cast(Variables variables) {
 
                     return econstant;
                 } else if (this instanceof EConstant) {
-                    final ECast ecast = new ECast(line, location, this, cast);
+                    final ECast ecast = new ECast(line, offset, location, this, cast);
                     ecast.actual = expected;
 
                     return ecast;
                 } else {
-                    final EConstant econstant = new EConstant(line, location, constant);
+                    final EConstant econstant = new EConstant(line, offset, location, constant);
                     econstant.analyze(variables);
 
                     if (!actual.equals(econstant.actual)) {
                         throw new IllegalStateException(error("Illegal tree structure."));
                     }
 
-                    final ECast ecast = new ECast(line, location, econstant, cast);
+                    final ECast ecast = new ECast(line, offset, location, econstant, cast);
                     ecast.actual = expected;
 
                     return ecast;
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ALink.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ALink.java
index e134e7fbcb9b..d68f662f913a 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ALink.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ALink.java
@@ -73,8 +73,8 @@
      */
     String string = null;
 
-    ALink(int line, String location, int size) {
-        super(line, location);
+    ALink(int line, int offset, String location, int size) {
+        super(line, offset, location);
 
         this.size = size;
     }
@@ -90,17 +90,17 @@
     /**
      * Write values before a load/store occurs such as an array index.
      */
-    abstract void write(MethodWriter adapter);
+    abstract void write(MethodWriter writer);
 
     /**
      * Write a load for the specific link type.
      */
-    abstract void load(MethodWriter adapter);
+    abstract void load(MethodWriter writer);
 
     /**
      * Write a store for the specific link type.
      */
-    abstract void store(MethodWriter adapter);
+    abstract void store(MethodWriter writer);
 
     /**
      * Used to copy link data from one to another during analysis in the case of replacement.
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ANode.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ANode.java
index a61b002dfcaf..414f6afe038b 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ANode.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ANode.java
@@ -28,32 +28,38 @@
 public abstract class ANode {
 
     /**
-     * The line number in the original source used for debug messages.
+     * The line number in the original source used for debugging and errors.
      */
     final int line;
 
+    /**
+     * The character offset in the original source used for debugging and errors.
+     */
+    final int offset;
+
     /**
      * The location in the original source to be printed in error messages.
      */
     final String location;
 
-    ANode(final int line, final String location) {
+    ANode(int line, int offset, String location) {
         this.line = line;
+        this.offset = offset;
         this.location = location;
     }
 
     public String error(final String message) {
         return "Error " + location  + ": " + message;
     }
-    
-    /** 
+
+    /**
      * Writes line number information
      * <p>
      * Currently we emit line number data for for leaf S-nodes
      */
-    void writeDebugInfo(MethodWriter adapter) {
+    void writeDebugInfo(MethodWriter writer) {
         Label label = new Label();
-        adapter.visitLabel(label);
-        adapter.visitLineNumber(line, label);
+        writer.visitLabel(label);
+        writer.visitLineNumber(line, label);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AStatement.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AStatement.java
index ebc4a1662688..80d24b4cab31 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AStatement.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/AStatement.java
@@ -107,8 +107,8 @@
      */
     Label brake = null;
 
-    AStatement(int line, String location) {
-        super(line, location);
+    AStatement(int line, int offset, String location) {
+        super(line, offset, location);
     }
 
     /**
@@ -119,5 +119,5 @@
     /**
      * Writes ASM based on the data collected during the analysis phase.
      */
-    abstract void write(MethodWriter adapter);
+    abstract void write(MethodWriter writer);
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBinary.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBinary.java
index ee990f60b614..0c083111d660 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBinary.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBinary.java
@@ -38,8 +38,8 @@
 
     boolean cat = false;
 
-    public EBinary(int line, String location, Operation operation, AExpression left, AExpression right) {
-        super(line, location);
+    public EBinary(int line, int offset, String location, Operation operation, AExpression left, AExpression right) {
+        super(line, offset, location);
 
         this.operation = operation;
         this.left = left;
@@ -79,7 +79,7 @@ private void analyzeMul(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply multiply [*] to types " +
@@ -93,7 +93,7 @@ private void analyzeMul(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant * (int)right.constant;
@@ -115,7 +115,7 @@ private void analyzeDiv(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply divide [/] to types " +
@@ -129,7 +129,7 @@ private void analyzeDiv(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant / (int)right.constant;
@@ -151,7 +151,7 @@ private void analyzeRem(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply remainder [%] to types " +
@@ -165,7 +165,7 @@ private void analyzeRem(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant % (int)right.constant;
@@ -187,14 +187,14 @@ private void analyzeAdd(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteAdd(left.actual, right.actual);
+        Type promote = AnalyzerCaster.promoteAdd(left.actual, right.actual);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply add [+] to types " +
                 "[" + left.actual.name + "] and [" + right.actual.name + "]."));
         }
 
-        final Sort sort = promote.sort;
+        Sort sort = promote.sort;
 
         if (sort == Sort.STRING) {
             left.expected = left.actual;
@@ -239,7 +239,7 @@ private void analyzeSub(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply subtract [-] to types " +
@@ -253,7 +253,7 @@ private void analyzeSub(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant - (int)right.constant;
@@ -275,7 +275,7 @@ private void analyzeLSH(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, false);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, false);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply left shift [<<] to types " +
@@ -290,7 +290,7 @@ private void analyzeLSH(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant << (int)right.constant;
@@ -308,7 +308,7 @@ private void analyzeRSH(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, false);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, false);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply right shift [>>] to types " +
@@ -323,7 +323,7 @@ private void analyzeRSH(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant >> (int)right.constant;
@@ -341,7 +341,7 @@ private void analyzeUSH(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, false);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, false);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply unsigned shift [>>>] to types " +
@@ -356,7 +356,7 @@ private void analyzeUSH(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant >>> (int)right.constant;
@@ -374,7 +374,7 @@ private void analyzeBWAnd(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, false);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, false);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply and [&] to types " +
@@ -388,7 +388,7 @@ private void analyzeBWAnd(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant & (int)right.constant;
@@ -406,7 +406,7 @@ private void analyzeXor(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteXor(left.actual, right.actual);
+        Type promote = AnalyzerCaster.promoteXor(left.actual, right.actual);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply xor [^] to types " +
@@ -420,7 +420,7 @@ private void analyzeXor(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.BOOL) {
                 constant = (boolean)left.constant ^ (boolean)right.constant;
@@ -440,7 +440,7 @@ private void analyzeBWOr(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, false);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, false);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply or [|] to types " +
@@ -454,7 +454,7 @@ private void analyzeBWOr(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant | (int)right.constant;
@@ -469,34 +469,34 @@ private void analyzeBWOr(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         if (actual.sort == Sort.STRING && operation == Operation.ADD) {
             if (!cat) {
-                adapter.writeNewStrings();
+                writer.writeNewStrings();
             }
 
-            left.write(adapter);
+            left.write(writer);
 
             if (!(left instanceof EBinary) || ((EBinary)left).operation != Operation.ADD || left.actual.sort != Sort.STRING) {
-                adapter.writeAppendStrings(left.actual);
+                writer.writeAppendStrings(left.actual);
             }
 
-            right.write(adapter);
+            right.write(writer);
 
             if (!(right instanceof EBinary) || ((EBinary)right).operation != Operation.ADD || right.actual.sort != Sort.STRING) {
-                adapter.writeAppendStrings(right.actual);
+                writer.writeAppendStrings(right.actual);
             }
 
             if (!cat) {
-                adapter.writeToStrings();
+                writer.writeToStrings();
             }
         } else {
-            left.write(adapter);
-            right.write(adapter);
+            left.write(writer);
+            right.write(writer);
 
-            adapter.writeBinaryInstruction(location, actual, operation);
+            writer.writeBinaryInstruction(location, actual, operation);
         }
 
-        adapter.writeBranch(tru, fals);
+        writer.writeBranch(tru, fals);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBool.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBool.java
index 27cd3018dedc..eda3e3647957 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBool.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBool.java
@@ -34,8 +34,8 @@
     AExpression left;
     AExpression right;
 
-    public EBool(int line, String location, Operation operation, AExpression left, AExpression right) {
-        super(line, location);
+    public EBool(int line, int offset, String location, Operation operation, AExpression left, AExpression right) {
+        super(line, offset, location);
 
         this.operation = operation;
         this.left = left;
@@ -66,70 +66,70 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         if (tru != null || fals != null) {
             if (operation == Operation.AND) {
-                final Label localfals = fals == null ? new Label() : fals;
+                Label localfals = fals == null ? new Label() : fals;
 
                 left.fals = localfals;
                 right.tru = tru;
                 right.fals = fals;
 
-                left.write(adapter);
-                right.write(adapter);
+                left.write(writer);
+                right.write(writer);
 
                 if (fals == null) {
-                    adapter.mark(localfals);
+                    writer.mark(localfals);
                 }
             } else if (operation == Operation.OR) {
-                final Label localtru = tru == null ? new Label() : tru;
+                Label localtru = tru == null ? new Label() : tru;
 
                 left.tru = localtru;
                 right.tru = tru;
                 right.fals = fals;
 
-                left.write(adapter);
-                right.write(adapter);
+                left.write(writer);
+                right.write(writer);
 
                 if (tru == null) {
-                    adapter.mark(localtru);
+                    writer.mark(localtru);
                 }
             } else {
                 throw new IllegalStateException(error("Illegal tree structure."));
             }
         } else {
             if (operation == Operation.AND) {
-                final Label localfals = new Label();
-                final Label end = new Label();
+                Label localfals = new Label();
+                Label end = new Label();
 
                 left.fals = localfals;
                 right.fals = localfals;
 
-                left.write(adapter);
-                right.write(adapter);
+                left.write(writer);
+                right.write(writer);
 
-                adapter.push(true);
-                adapter.goTo(end);
-                adapter.mark(localfals);
-                adapter.push(false);
-                adapter.mark(end);
+                writer.push(true);
+                writer.goTo(end);
+                writer.mark(localfals);
+                writer.push(false);
+                writer.mark(end);
             } else if (operation == Operation.OR) {
-                final Label localtru = new Label();
-                final Label localfals = new Label();
-                final Label end = new Label();
+                Label localtru = new Label();
+                Label localfals = new Label();
+                Label end = new Label();
 
                 left.tru = localtru;
                 right.fals = localfals;
 
-                left.write(adapter);
-                right.write(adapter);
+                left.write(writer);
+                right.write(writer);
 
-                adapter.mark(localtru);
-                adapter.push(true);
-                adapter.goTo(end);
-                adapter.mark(localfals);
-                adapter.push(false);
-                adapter.mark(end);
+                writer.mark(localtru);
+                writer.push(true);
+                writer.goTo(end);
+                writer.mark(localfals);
+                writer.push(false);
+                writer.mark(end);
             } else {
                 throw new IllegalStateException(error("Illegal tree structure."));
             }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBoolean.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBoolean.java
index 27d7bb9a6267..a1585e13dbc4 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBoolean.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EBoolean.java
@@ -28,8 +28,8 @@
  */
 public final class EBoolean extends AExpression {
 
-    public EBoolean(int line, String location, boolean constant) {
-        super(line, location);
+    public EBoolean(int line, int offset, String location, boolean constant) {
+        super(line, offset, location);
 
         this.constant = constant;
     }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECast.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECast.java
index 7a8c4a29b605..e2fe5cb6d10b 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECast.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ECast.java
@@ -34,8 +34,8 @@
 
     Cast cast = null;
 
-    ECast(int line, String location, AExpression child, Cast cast) {
-        super(line, location);
+    ECast(int line, int offset, String location, AExpression child, Cast cast) {
+        super(line, offset, location);
 
         this.type = null;
         this.child = child;
@@ -49,9 +49,9 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        child.write(adapter);
-        adapter.writeCast(cast);
-        adapter.writeBranch(tru, fals);
+    void write(MethodWriter writer) {
+        child.write(writer);
+        writer.writeCast(cast);
+        writer.writeBranch(tru, fals);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java
index 31bff2dd66de..2de1a5b320e4 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EChain.java
@@ -46,9 +46,9 @@
     Cast there = null;
     Cast back = null;
 
-    public EChain(int line, String location, List<ALink> links,
+    public EChain(int line, int offset, String location, List<ALink> links,
                   boolean pre, boolean post, Operation operation, AExpression expression) {
-        super(line, location);
+        super(line, offset, location);
 
         this.links = links;
         this.pre = pre;
@@ -76,7 +76,7 @@ private void analyzeLinks(Variables variables) {
         int index = 0;
 
         while (index < links.size()) {
-            final ALink current = links.get(index);
+            ALink current = links.get(index);
 
             if (previous != null) {
                 current.before = previous.after;
@@ -91,7 +91,7 @@ private void analyzeLinks(Variables variables) {
                 current.store = expression != null || pre || post;
             }
 
-            final ALink analyzed = current.analyze(variables);
+            ALink analyzed = current.analyze(variables);
 
             if (analyzed == null) {
                 links.remove(index);
@@ -111,7 +111,7 @@ private void analyzeLinks(Variables variables) {
     }
 
     private void analyzeIncrDecr() {
-        final ALink last = links.get(links.size() - 1);
+        ALink last = links.get(links.size() - 1);
 
         if (pre && post) {
             throw new IllegalStateException(error("Illegal tree structure."));
@@ -120,29 +120,29 @@ private void analyzeIncrDecr() {
                 throw new IllegalStateException(error("Illegal tree structure."));
             }
 
-            final Sort sort = last.after.sort;
+            Sort sort = last.after.sort;
 
             if (operation == Operation.INCR) {
                 if (sort == Sort.DOUBLE) {
-                    expression = new EConstant(line, location, 1D);
+                    expression = new EConstant(line, offset, location, 1D);
                 } else if (sort == Sort.FLOAT) {
-                    expression = new EConstant(line, location, 1F);
+                    expression = new EConstant(line, offset, location, 1F);
                 } else if (sort == Sort.LONG) {
-                    expression = new EConstant(line, location, 1L);
+                    expression = new EConstant(line, offset, location, 1L);
                 } else {
-                    expression = new EConstant(line, location, 1);
+                    expression = new EConstant(line, offset, location, 1);
                 }
 
                 operation = Operation.ADD;
             } else if (operation == Operation.DECR) {
                 if (sort == Sort.DOUBLE) {
-                    expression = new EConstant(line, location, 1D);
+                    expression = new EConstant(line, offset, location, 1D);
                 } else if (sort == Sort.FLOAT) {
-                    expression = new EConstant(line, location, 1F);
+                    expression = new EConstant(line, offset, location, 1F);
                 } else if (sort == Sort.LONG) {
-                    expression = new EConstant(line, location, 1L);
+                    expression = new EConstant(line, offset, location, 1L);
                 } else {
-                    expression = new EConstant(line, location, 1);
+                    expression = new EConstant(line, offset, location, 1);
                 }
 
                 operation = Operation.SUB;
@@ -153,7 +153,7 @@ private void analyzeIncrDecr() {
     }
 
     private void analyzeCompound(Variables variables) {
-        final ALink last = links.get(links.size() - 1);
+        ALink last = links.get(links.size() - 1);
 
         expression.analyze(variables);
 
@@ -214,9 +214,9 @@ private void analyzeCompound(Variables variables) {
     }
 
     private void analyzeWrite(Variables variables) {
-        final ALink last = links.get(links.size() - 1);
+        ALink last = links.get(links.size() - 1);
 
-        // If the store node is a DEF node, we remove the cast to DEF from the expression
+        // If the store node is a def node, we remove the cast to def from the expression
         // and promote the real type to it:
         if (last instanceof IDefLink) {
             expression.analyze(variables);
@@ -234,9 +234,9 @@ private void analyzeWrite(Variables variables) {
     }
 
     private void analyzeRead() {
-        final ALink last = links.get(links.size() - 1);
+        ALink last = links.get(links.size() - 1);
 
-        // If the load node is a DEF node, we adapt its after type to use _this_ expected output type:
+        // If the load node is a def node, we adapt its after type to use _this_ expected output type:
         if (last instanceof IDefLink && this.expected != null) {
             last.after = this.expected;
         }
@@ -247,70 +247,70 @@ private void analyzeRead() {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         if (cat) {
-            adapter.writeNewStrings();
+            writer.writeNewStrings();
         }
 
-        final ALink last = links.get(links.size() - 1);
+        ALink last = links.get(links.size() - 1);
 
-        for (final ALink link : links) {
-            link.write(adapter);
+        for (ALink link : links) {
+            link.write(writer);
 
             if (link == last && link.store) {
                 if (cat) {
-                    adapter.writeDup(link.size, 1);
-                    link.load(adapter);
-                    adapter.writeAppendStrings(link.after);
+                    writer.writeDup(link.size, 1);
+                    link.load(writer);
+                    writer.writeAppendStrings(link.after);
 
-                    expression.write(adapter);
+                    expression.write(writer);
 
                     if (!(expression instanceof EBinary) ||
                         ((EBinary)expression).operation != Operation.ADD || expression.actual.sort != Sort.STRING) {
-                        adapter.writeAppendStrings(expression.actual);
+                        writer.writeAppendStrings(expression.actual);
                     }
 
-                    adapter.writeToStrings();
-                    adapter.writeCast(back);
+                    writer.writeToStrings();
+                    writer.writeCast(back);
 
                     if (link.load) {
-                        adapter.writeDup(link.after.sort.size, link.size);
+                        writer.writeDup(link.after.sort.size, link.size);
                     }
 
-                    link.store(adapter);
+                    link.store(writer);
                 } else if (operation != null) {
-                    adapter.writeDup(link.size, 0);
-                    link.load(adapter);
+                    writer.writeDup(link.size, 0);
+                    link.load(writer);
 
                     if (link.load && post) {
-                        adapter.writeDup(link.after.sort.size, link.size);
+                        writer.writeDup(link.after.sort.size, link.size);
                     }
 
-                    adapter.writeCast(there);
-                    expression.write(adapter);
-                    adapter.writeBinaryInstruction(location, promote, operation);
+                    writer.writeCast(there);
+                    expression.write(writer);
+                    writer.writeBinaryInstruction(location, promote, operation);
 
-                    adapter.writeCast(back);
+                    writer.writeCast(back);
 
                     if (link.load && !post) {
-                        adapter.writeDup(link.after.sort.size, link.size);
+                        writer.writeDup(link.after.sort.size, link.size);
                     }
 
-                    link.store(adapter);
+                    link.store(writer);
                 } else {
-                    expression.write(adapter);
+                    expression.write(writer);
 
                     if (link.load) {
-                        adapter.writeDup(link.after.sort.size, link.size);
+                        writer.writeDup(link.after.sort.size, link.size);
                     }
 
-                    link.store(adapter);
+                    link.store(writer);
                 }
             } else {
-                link.load(adapter);
+                link.load(writer);
             }
         }
 
-        adapter.writeBranch(tru, fals);
+        writer.writeBranch(tru, fals);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java
index 08fed075335e..4521c76d911b 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EComp.java
@@ -46,8 +46,8 @@
     AExpression left;
     AExpression right;
 
-    public EComp(int line, String location, Operation operation, AExpression left, AExpression right) {
-        super(line, location);
+    public EComp(int line, int offset, String location, Operation operation, AExpression left, AExpression right) {
+        super(line, offset, location);
 
         this.operation = operation;
         this.left = left;
@@ -81,7 +81,7 @@ private void analyzeEq(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteEquality(left.actual, right.actual);
+        Type promote = AnalyzerCaster.promoteEquality(left.actual, right.actual);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply equals [==] to types " +
@@ -99,7 +99,7 @@ private void analyzeEq(Variables variables) {
         }
 
         if ((left.constant != null || left.isNull) && (right.constant != null || right.isNull)) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.BOOL) {
                 constant = (boolean)left.constant == (boolean)right.constant;
@@ -127,7 +127,7 @@ private void analyzeEqR(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteEquality(left.actual, right.actual);
+        Type promote = AnalyzerCaster.promoteEquality(left.actual, right.actual);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply reference equals [===] to types " +
@@ -145,7 +145,7 @@ private void analyzeEqR(Variables variables) {
         }
 
         if ((left.constant != null || left.isNull) && (right.constant != null || right.isNull)) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.BOOL) {
                 constant = (boolean)left.constant == (boolean)right.constant;
@@ -169,7 +169,7 @@ private void analyzeNE(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteEquality(left.actual, right.actual);
+        Type promote = AnalyzerCaster.promoteEquality(left.actual, right.actual);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply not equals [!=] to types " +
@@ -187,7 +187,7 @@ private void analyzeNE(Variables variables) {
         }
 
         if ((left.constant != null || left.isNull) && (right.constant != null || right.isNull)) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.BOOL) {
                 constant = (boolean)left.constant != (boolean)right.constant;
@@ -215,7 +215,7 @@ private void analyzeNER(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteEquality(left.actual, right.actual);
+        Type promote = AnalyzerCaster.promoteEquality(left.actual, right.actual);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply reference not equals [!==] to types " +
@@ -233,7 +233,7 @@ private void analyzeNER(Variables variables) {
         }
 
         if ((left.constant != null || left.isNull) && (right.constant != null || right.isNull)) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.BOOL) {
                 constant = (boolean)left.constant != (boolean)right.constant;
@@ -257,7 +257,7 @@ private void analyzeGTE(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply greater than or equals [>=] to types " +
@@ -271,7 +271,7 @@ private void analyzeGTE(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant >= (int)right.constant;
@@ -293,7 +293,7 @@ private void analyzeGT(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply greater than [>] to types " +
@@ -307,7 +307,7 @@ private void analyzeGT(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant > (int)right.constant;
@@ -329,7 +329,7 @@ private void analyzeLTE(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply less than or equals [<=] to types " +
@@ -343,7 +343,7 @@ private void analyzeLTE(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant <= (int)right.constant;
@@ -365,7 +365,7 @@ private void analyzeLT(Variables variables) {
         left.analyze(variables);
         right.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
+        Type promote = AnalyzerCaster.promoteNumeric(left.actual, right.actual, true);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply less than [>=] to types " +
@@ -379,7 +379,7 @@ private void analyzeLT(Variables variables) {
         right = right.cast(variables);
 
         if (left.constant != null && right.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = (int)left.constant < (int)right.constant;
@@ -398,28 +398,28 @@ private void analyzeLT(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        final boolean branch = tru != null || fals != null;
-        final org.objectweb.asm.Type rtype = right.actual.type;
-        final Sort rsort = right.actual.sort;
+    void write(MethodWriter writer) {
+        boolean branch = tru != null || fals != null;
+        org.objectweb.asm.Type rtype = right.actual.type;
+        Sort rsort = right.actual.sort;
 
-        left.write(adapter);
+        left.write(writer);
 
         if (!right.isNull) {
-            right.write(adapter);
+            right.write(writer);
         }
 
-        final Label jump = tru != null ? tru : fals != null ? fals : new Label();
-        final Label end = new Label();
+        Label jump = tru != null ? tru : fals != null ? fals : new Label();
+        Label end = new Label();
 
-        final boolean eq = (operation == Operation.EQ || operation == Operation.EQR) && (tru != null || fals == null) ||
+        boolean eq = (operation == Operation.EQ || operation == Operation.EQR) && (tru != null || fals == null) ||
             (operation == Operation.NE || operation == Operation.NER) && fals != null;
-        final boolean ne = (operation == Operation.NE || operation == Operation.NER) && (tru != null || fals == null) ||
+        boolean ne = (operation == Operation.NE || operation == Operation.NER) && (tru != null || fals == null) ||
             (operation == Operation.EQ || operation == Operation.EQR) && fals != null;
-        final boolean lt  = operation == Operation.LT  && (tru != null || fals == null) || operation == Operation.GTE && fals != null;
-        final boolean lte = operation == Operation.LTE && (tru != null || fals == null) || operation == Operation.GT  && fals != null;
-        final boolean gt  = operation == Operation.GT  && (tru != null || fals == null) || operation == Operation.LTE && fals != null;
-        final boolean gte = operation == Operation.GTE && (tru != null || fals == null) || operation == Operation.LT  && fals != null;
+        boolean lt  = operation == Operation.LT  && (tru != null || fals == null) || operation == Operation.GTE && fals != null;
+        boolean lte = operation == Operation.LTE && (tru != null || fals == null) || operation == Operation.GT  && fals != null;
+        boolean gt  = operation == Operation.GT  && (tru != null || fals == null) || operation == Operation.LTE && fals != null;
+        boolean gte = operation == Operation.GTE && (tru != null || fals == null) || operation == Operation.LT  && fals != null;
 
         boolean writejump = true;
 
@@ -430,8 +430,8 @@ void write(MethodWriter adapter) {
             case CHAR:
                 throw new IllegalStateException(error("Illegal tree structure."));
             case BOOL:
-                if      (eq) adapter.ifZCmp(MethodWriter.EQ, jump);
-                else if (ne) adapter.ifZCmp(MethodWriter.NE, jump);
+                if      (eq) writer.ifZCmp(MethodWriter.EQ, jump);
+                else if (ne) writer.ifZCmp(MethodWriter.NE, jump);
                 else {
                     throw new IllegalStateException(error("Illegal tree structure."));
                 }
@@ -441,12 +441,12 @@ void write(MethodWriter adapter) {
             case LONG:
             case FLOAT:
             case DOUBLE:
-                if      (eq)  adapter.ifCmp(rtype, MethodWriter.EQ, jump);
-                else if (ne)  adapter.ifCmp(rtype, MethodWriter.NE, jump);
-                else if (lt)  adapter.ifCmp(rtype, MethodWriter.LT, jump);
-                else if (lte) adapter.ifCmp(rtype, MethodWriter.LE, jump);
-                else if (gt)  adapter.ifCmp(rtype, MethodWriter.GT, jump);
-                else if (gte) adapter.ifCmp(rtype, MethodWriter.GE, jump);
+                if      (eq)  writer.ifCmp(rtype, MethodWriter.EQ, jump);
+                else if (ne)  writer.ifCmp(rtype, MethodWriter.NE, jump);
+                else if (lt)  writer.ifCmp(rtype, MethodWriter.LT, jump);
+                else if (lte) writer.ifCmp(rtype, MethodWriter.LE, jump);
+                else if (gt)  writer.ifCmp(rtype, MethodWriter.GT, jump);
+                else if (gte) writer.ifCmp(rtype, MethodWriter.GE, jump);
                 else {
                     throw new IllegalStateException(error("Illegal tree structure."));
                 }
@@ -455,66 +455,66 @@ void write(MethodWriter adapter) {
             case DEF:
                 if (eq) {
                     if (right.isNull) {
-                        adapter.ifNull(jump);
+                        writer.ifNull(jump);
                     } else if (!left.isNull && (operation == Operation.EQ || operation == Operation.NE)) {
-                        adapter.invokeStatic(DEF_UTIL_TYPE, DEF_EQ_CALL);
+                        writer.invokeStatic(DEF_UTIL_TYPE, DEF_EQ_CALL);
                         writejump = false;
                     } else {
-                        adapter.ifCmp(rtype, MethodWriter.EQ, jump);
+                        writer.ifCmp(rtype, MethodWriter.EQ, jump);
                     }
                 } else if (ne) {
                     if (right.isNull) {
-                        adapter.ifNonNull(jump);
+                        writer.ifNonNull(jump);
                     } else if (!left.isNull && (operation == Operation.EQ || operation == Operation.NE)) {
-                        adapter.invokeStatic(DEF_UTIL_TYPE, DEF_EQ_CALL);
-                        adapter.ifZCmp(MethodWriter.EQ, jump);
+                        writer.invokeStatic(DEF_UTIL_TYPE, DEF_EQ_CALL);
+                        writer.ifZCmp(MethodWriter.EQ, jump);
                     } else {
-                        adapter.ifCmp(rtype, MethodWriter.NE, jump);
+                        writer.ifCmp(rtype, MethodWriter.NE, jump);
                     }
                 } else if (lt) {
-                    adapter.invokeStatic(DEF_UTIL_TYPE, DEF_LT_CALL);
+                    writer.invokeStatic(DEF_UTIL_TYPE, DEF_LT_CALL);
                     writejump = false;
                 } else if (lte) {
-                    adapter.invokeStatic(DEF_UTIL_TYPE, DEF_LTE_CALL);
+                    writer.invokeStatic(DEF_UTIL_TYPE, DEF_LTE_CALL);
                     writejump = false;
                 } else if (gt) {
-                    adapter.invokeStatic(DEF_UTIL_TYPE, DEF_GT_CALL);
+                    writer.invokeStatic(DEF_UTIL_TYPE, DEF_GT_CALL);
                     writejump = false;
                 } else if (gte) {
-                    adapter.invokeStatic(DEF_UTIL_TYPE, DEF_GTE_CALL);
+                    writer.invokeStatic(DEF_UTIL_TYPE, DEF_GTE_CALL);
                     writejump = false;
                 } else {
                     throw new IllegalStateException(error("Illegal tree structure."));
                 }
 
                 if (branch && !writejump) {
-                    adapter.ifZCmp(MethodWriter.NE, jump);
+                    writer.ifZCmp(MethodWriter.NE, jump);
                 }
 
                 break;
             default:
                 if (eq) {
                     if (right.isNull) {
-                        adapter.ifNull(jump);
+                        writer.ifNull(jump);
                     } else if (operation == Operation.EQ || operation == Operation.NE) {
-                        adapter.invokeStatic(UTILITY_TYPE, CHECKEQUALS);
+                        writer.invokeStatic(UTILITY_TYPE, CHECKEQUALS);
 
                         if (branch) {
-                            adapter.ifZCmp(MethodWriter.NE, jump);
+                            writer.ifZCmp(MethodWriter.NE, jump);
                         }
 
                         writejump = false;
                     } else {
-                        adapter.ifCmp(rtype, MethodWriter.EQ, jump);
+                        writer.ifCmp(rtype, MethodWriter.EQ, jump);
                     }
                 } else if (ne) {
                     if (right.isNull) {
-                        adapter.ifNonNull(jump);
+                        writer.ifNonNull(jump);
                     } else if (operation == Operation.EQ || operation == Operation.NE) {
-                        adapter.invokeStatic(UTILITY_TYPE, CHECKEQUALS);
-                        adapter.ifZCmp(MethodWriter.EQ, jump);
+                        writer.invokeStatic(UTILITY_TYPE, CHECKEQUALS);
+                        writer.ifZCmp(MethodWriter.EQ, jump);
                     } else {
-                        adapter.ifCmp(rtype, MethodWriter.NE, jump);
+                        writer.ifCmp(rtype, MethodWriter.NE, jump);
                     }
                 } else {
                     throw new IllegalStateException(error("Illegal tree structure."));
@@ -522,11 +522,11 @@ void write(MethodWriter adapter) {
         }
 
         if (!branch && writejump) {
-            adapter.push(false);
-            adapter.goTo(end);
-            adapter.mark(jump);
-            adapter.push(true);
-            adapter.mark(end);
+            writer.push(false);
+            writer.goTo(end);
+            writer.mark(jump);
+            writer.push(true);
+            writer.mark(end);
         }
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConditional.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConditional.java
index 8f9d0038586f..a13176e56b73 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConditional.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConditional.java
@@ -35,8 +35,8 @@
     AExpression left;
     AExpression right;
 
-    public EConditional(int line, String location, AExpression condition, AExpression left, AExpression right) {
-        super(line, location);
+    public EConditional(int line, int offset, String location, AExpression condition, AExpression left, AExpression right) {
+        super(line, offset, location);
 
         this.condition = condition;
         this.left = left;
@@ -77,19 +77,19 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        final Label localfals = new Label();
-        final Label end = new Label();
+    void write(MethodWriter writer) {
+        Label localfals = new Label();
+        Label end = new Label();
 
         condition.fals = localfals;
         left.tru = right.tru = tru;
         left.fals = right.fals = fals;
 
-        condition.write(adapter);
-        left.write(adapter);
-        adapter.goTo(end);
-        adapter.mark(localfals);
-        right.write(adapter);
-        adapter.mark(end);
+        condition.write(writer);
+        left.write(writer);
+        writer.goTo(end);
+        writer.mark(localfals);
+        right.write(writer);
+        writer.mark(end);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConstant.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConstant.java
index ac18b849162c..b45e3c33bc28 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConstant.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EConstant.java
@@ -30,8 +30,8 @@
  */
 final class EConstant extends AExpression {
 
-    EConstant(int line, String location, Object constant) {
-        super(line, location);
+    EConstant(int line, int offset, String location, Object constant) {
+        super(line, offset, location);
 
         this.constant = constant;
     }
@@ -62,25 +62,25 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        final Sort sort = actual.sort;
+    void write(MethodWriter writer) {
+        Sort sort = actual.sort;
 
         switch (sort) {
-            case STRING: adapter.push((String)constant);  break;
-            case DOUBLE: adapter.push((double)constant);  break;
-            case FLOAT:  adapter.push((float)constant);   break;
-            case LONG:   adapter.push((long)constant);    break;
-            case INT:    adapter.push((int)constant);     break;
-            case CHAR:   adapter.push((char)constant);    break;
-            case SHORT:  adapter.push((short)constant);   break;
-            case BYTE:   adapter.push((byte)constant);    break;
+            case STRING: writer.push((String)constant);  break;
+            case DOUBLE: writer.push((double)constant);  break;
+            case FLOAT:  writer.push((float)constant);   break;
+            case LONG:   writer.push((long)constant);    break;
+            case INT:    writer.push((int)constant);     break;
+            case CHAR:   writer.push((char)constant);    break;
+            case SHORT:  writer.push((short)constant);   break;
+            case BYTE:   writer.push((byte)constant);    break;
             case BOOL:
                 if (tru != null && (boolean)constant) {
-                    adapter.goTo(tru);
+                    writer.goTo(tru);
                 } else if (fals != null && !(boolean)constant) {
-                    adapter.goTo(fals);
+                    writer.goTo(fals);
                 } else if (tru == null && fals == null) {
-                    adapter.push((boolean)constant);
+                    writer.push((boolean)constant);
                 }
 
                 break;
@@ -89,7 +89,7 @@ void write(MethodWriter adapter) {
         }
 
         if (sort != Sort.BOOL) {
-            adapter.writeBranch(tru, fals);
+            writer.writeBranch(tru, fals);
         }
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDecimal.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDecimal.java
index 85e857da3c4c..034a4ec97f97 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDecimal.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EDecimal.java
@@ -30,8 +30,8 @@
 
     final String value;
 
-    public EDecimal(int line, String location, String value) {
-        super(line, location);
+    public EDecimal(int line, int offset, String location, String value) {
+        super(line, offset, location);
 
         this.value = value;
     }
@@ -42,21 +42,21 @@ void analyze(Variables variables) {
             try {
                 constant = Float.parseFloat(value.substring(0, value.length() - 1));
                 actual = Definition.FLOAT_TYPE;
-            } catch (final NumberFormatException exception) {
+            } catch (NumberFormatException exception) {
                 throw new IllegalArgumentException(error("Invalid float constant [" + value + "]."));
             }
         } else {
             try {
                 constant = Double.parseDouble(value);
                 actual = Definition.DOUBLE_TYPE;
-            } catch (final NumberFormatException exception) {
+            } catch (NumberFormatException exception) {
                 throw new IllegalArgumentException(error("Invalid double constant [" + value + "]."));
             }
         }
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         throw new IllegalArgumentException(error("Illegal tree structure."));
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EExplicit.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EExplicit.java
index 7a8c9dadeca5..643dc2d41419 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EExplicit.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EExplicit.java
@@ -31,8 +31,8 @@
     final String type;
     AExpression child;
 
-    public EExplicit(int line, String location, String type, AExpression child) {
-        super(line, location);
+    public EExplicit(int line, int offset, String location, String type, AExpression child) {
+        super(line, offset, location);
 
         this.type = type;
         this.child = child;
@@ -42,7 +42,7 @@ public EExplicit(int line, String location, String type, AExpression child) {
     void analyze(Variables variables) {
         try {
             actual = Definition.getType(this.type);
-        } catch (final IllegalArgumentException exception) {
+        } catch (IllegalArgumentException exception) {
             throw new IllegalArgumentException(error("Not a type [" + this.type + "]."));
         }
 
@@ -53,7 +53,7 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         throw new IllegalArgumentException(error("Illegal tree structure."));
     }
 
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENull.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENull.java
index 3a8005b20d61..2bb4f4ba5851 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENull.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENull.java
@@ -29,8 +29,8 @@
  */
 public final class ENull extends AExpression {
 
-    public ENull(int line, String location) {
-        super(line, location);
+    public ENull(int line, int offset, String location) {
+        super(line, offset, location);
     }
 
     @Override
@@ -49,7 +49,7 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        adapter.visitInsn(Opcodes.ACONST_NULL);
+    void write(MethodWriter writer) {
+        writer.visitInsn(Opcodes.ACONST_NULL);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENumeric.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENumeric.java
index ee70bb77d44f..0fed456dd647 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENumeric.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/ENumeric.java
@@ -32,8 +32,8 @@
     final String value;
     int radix;
 
-    public ENumeric(int line, String location, String value, int radix) {
-        super(line, location);
+    public ENumeric(int line, int offset, String location, String value, int radix) {
+        super(line, offset, location);
 
         this.value = value;
         this.radix = radix;
@@ -49,7 +49,7 @@ void analyze(Variables variables) {
             try {
                 constant = Double.parseDouble(value.substring(0, value.length() - 1));
                 actual = Definition.DOUBLE_TYPE;
-            } catch (final NumberFormatException exception) {
+            } catch (NumberFormatException exception) {
                 throw new IllegalArgumentException(error("Invalid double constant [" + value + "]."));
             }
         } else if (value.endsWith("f") || value.endsWith("F")) {
@@ -60,20 +60,20 @@ void analyze(Variables variables) {
             try {
                 constant = Float.parseFloat(value.substring(0, value.length() - 1));
                 actual = Definition.FLOAT_TYPE;
-            } catch (final NumberFormatException exception) {
+            } catch (NumberFormatException exception) {
                 throw new IllegalArgumentException(error("Invalid float constant [" + value + "]."));
             }
         } else if (value.endsWith("l") || value.endsWith("L")) {
             try {
                 constant = Long.parseLong(value.substring(0, value.length() - 1), radix);
                 actual = Definition.LONG_TYPE;
-            } catch (final NumberFormatException exception) {
+            } catch (NumberFormatException exception) {
                 throw new IllegalArgumentException(error("Invalid long constant [" + value + "]."));
             }
         } else {
             try {
-                final Sort sort = expected == null ? Sort.INT : expected.sort;
-                final int integer = Integer.parseInt(value, radix);
+                Sort sort = expected == null ? Sort.INT : expected.sort;
+                int integer = Integer.parseInt(value, radix);
 
                 if (sort == Sort.BYTE && integer >= Byte.MIN_VALUE && integer <= Byte.MAX_VALUE) {
                     constant = (byte)integer;
@@ -88,14 +88,14 @@ void analyze(Variables variables) {
                     constant = integer;
                     actual = Definition.INT_TYPE;
                 }
-            } catch (final NumberFormatException exception) {
+            } catch (NumberFormatException exception) {
                 throw new IllegalArgumentException(error("Invalid int constant [" + value + "]."));
             }
         }
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         throw new IllegalArgumentException(error("Illegal tree structure."));
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EUnary.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EUnary.java
index d62fa2c8ebf7..8b02522fca9a 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EUnary.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/EUnary.java
@@ -37,11 +37,11 @@
  */
 public final class EUnary extends AExpression {
 
-    Operation operation;
+    final Operation operation;
     AExpression child;
 
-    public EUnary(int line, String location, Operation operation, AExpression child) {
-        super(line, location);
+    public EUnary(int line, int offset, String location, Operation operation, AExpression child) {
+        super(line, offset, location);
 
         this.operation = operation;
         this.child = child;
@@ -77,7 +77,7 @@ void analyzeNot(Variables variables) {
     void analyzeBWNot(Variables variables) {
         child.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(child.actual, false);
+        Type promote = AnalyzerCaster.promoteNumeric(child.actual, false);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply not [~] to type [" + child.actual.name + "]."));
@@ -87,7 +87,7 @@ void analyzeBWNot(Variables variables) {
         child = child.cast(variables);
 
         if (child.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = ~(int)child.constant;
@@ -104,7 +104,7 @@ void analyzeBWNot(Variables variables) {
     void analyzerAdd(Variables variables) {
         child.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(child.actual, true);
+        Type promote = AnalyzerCaster.promoteNumeric(child.actual, true);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply positive [+] to type [" + child.actual.name + "]."));
@@ -114,7 +114,7 @@ void analyzerAdd(Variables variables) {
         child = child.cast(variables);
 
         if (child.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = +(int)child.constant;
@@ -135,7 +135,7 @@ void analyzerAdd(Variables variables) {
     void analyzerSub(Variables variables) {
         child.analyze(variables);
 
-        final Type promote = AnalyzerCaster.promoteNumeric(child.actual, true);
+        Type promote = AnalyzerCaster.promoteNumeric(child.actual, true);
 
         if (promote == null) {
             throw new ClassCastException(error("Cannot apply negative [-] to type [" + child.actual.name + "]."));
@@ -145,7 +145,7 @@ void analyzerSub(Variables variables) {
         child = child.cast(variables);
 
         if (child.constant != null) {
-            final Sort sort = promote.sort;
+            Sort sort = promote.sort;
 
             if (sort == Sort.INT) {
                 constant = -(int)child.constant;
@@ -164,56 +164,56 @@ void analyzerSub(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         if (operation == Operation.NOT) {
             if (tru == null && fals == null) {
-                final Label localfals = new Label();
-                final Label end = new Label();
+                Label localfals = new Label();
+                Label end = new Label();
 
                 child.fals = localfals;
-                child.write(adapter);
+                child.write(writer);
 
-                adapter.push(false);
-                adapter.goTo(end);
-                adapter.mark(localfals);
-                adapter.push(true);
-                adapter.mark(end);
+                writer.push(false);
+                writer.goTo(end);
+                writer.mark(localfals);
+                writer.push(true);
+                writer.mark(end);
             } else {
                 child.tru = fals;
                 child.fals = tru;
-                child.write(adapter);
+                child.write(writer);
             }
         } else {
-            final org.objectweb.asm.Type type = actual.type;
-            final Sort sort = actual.sort;
+            org.objectweb.asm.Type type = actual.type;
+            Sort sort = actual.sort;
 
-            child.write(adapter);
+            child.write(writer);
 
             if (operation == Operation.BWNOT) {
                 if (sort == Sort.DEF) {
-                    adapter.invokeStatic(DEF_UTIL_TYPE, DEF_NOT_CALL);
+                    writer.invokeStatic(DEF_UTIL_TYPE, DEF_NOT_CALL);
                 } else {
                     if (sort == Sort.INT) {
-                        adapter.push(-1);
+                        writer.push(-1);
                     } else if (sort == Sort.LONG) {
-                        adapter.push(-1L);
+                        writer.push(-1L);
                     } else {
                         throw new IllegalStateException(error("Illegal tree structure."));
                     }
 
-                    adapter.math(MethodWriter.XOR, type);
+                    writer.math(MethodWriter.XOR, type);
                 }
             } else if (operation == Operation.SUB) {
                 if (sort == Sort.DEF) {
-                    adapter.invokeStatic(DEF_UTIL_TYPE, DEF_NEG_CALL);
+                    writer.invokeStatic(DEF_UTIL_TYPE, DEF_NEG_CALL);
                 } else {
-                    adapter.math(MethodWriter.NEG, type);
+                    writer.math(MethodWriter.NEG, type);
                 }
             } else if (operation != Operation.ADD) {
                 throw new IllegalStateException(error("Illegal tree structure."));
             }
 
-            adapter.writeBranch(tru, fals);
+            writer.writeBranch(tru, fals);
         }
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LArrayLength.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LArrayLength.java
index 4a6df96073ea..cea5c629b148 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LArrayLength.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LArrayLength.java
@@ -30,8 +30,8 @@
 
     final String value;
 
-    LArrayLength(int line, String location, String value) {
-        super(line, location, -1);
+    LArrayLength(int line, int offset, String location, String value) {
+        super(line, offset, location, -1);
 
         this.value = value;
     }
@@ -54,17 +54,17 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         // Do nothing.
     }
 
     @Override
-    void load(MethodWriter adapter) {
-        adapter.arrayLength();
+    void load(MethodWriter writer) {
+        writer.arrayLength();
     }
 
     @Override
-    void store(MethodWriter adapter) {
+    void store(MethodWriter writer) {
         throw new IllegalStateException(error("Illegal tree structure."));
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LBrace.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LBrace.java
index 95cc02602f6a..4411913ea07c 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LBrace.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LBrace.java
@@ -34,8 +34,8 @@
 
     AExpression index;
 
-    public LBrace(int line, String location, AExpression index) {
-        super(line, location, 2);
+    public LBrace(int line, int offset, String location, AExpression index) {
+        super(line, offset, location, 2);
 
         this.index = index;
     }
@@ -43,7 +43,7 @@ public LBrace(int line, String location, AExpression index) {
     @Override
     ALink analyze(Variables variables) {
         if (before == null) {
-            throw new IllegalStateException(error("Illegal tree structure."));
+            throw new IllegalArgumentException(error("Illegal array access made without target."));
         }
 
         final Sort sort = before.sort;
@@ -57,29 +57,29 @@ ALink analyze(Variables variables) {
 
             return this;
         } else if (sort == Sort.DEF) {
-            return new LDefArray(line, location, index).copy(this).analyze(variables);
+            return new LDefArray(line, offset, location, index).copy(this).analyze(variables);
         } else if (Map.class.isAssignableFrom(before.clazz)) {
-            return new LMapShortcut(line, location, index).copy(this).analyze(variables);
+            return new LMapShortcut(line, offset, location, index).copy(this).analyze(variables);
         } else if (List.class.isAssignableFrom(before.clazz)) {
-            return new LListShortcut(line, location, index).copy(this).analyze(variables);
+            return new LListShortcut(line, offset, location, index).copy(this).analyze(variables);
         }
 
         throw new IllegalArgumentException(error("Illegal array access on type [" + before.name + "]."));
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        index.write(adapter);
+    void write(MethodWriter writer) {
+        index.write(writer);
     }
 
     @Override
-    void load(MethodWriter adapter) {
-        adapter.arrayLoad(after.type);
+    void load(MethodWriter writer) {
+        writer.arrayLoad(after.type);
     }
 
     @Override
-    void store(MethodWriter adapter) {
-        adapter.arrayStore(after.type);
+    void store(MethodWriter writer) {
+        writer.arrayStore(after.type);
     }
 
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LCall.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LCall.java
index fdb6612e1f4d..29b57d8d3eff 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LCall.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LCall.java
@@ -21,6 +21,7 @@
 
 import org.elasticsearch.painless.Definition;
 import org.elasticsearch.painless.Definition.Method;
+import org.elasticsearch.painless.Definition.Sort;
 import org.elasticsearch.painless.Definition.Struct;
 import org.elasticsearch.painless.Variables;
 import org.elasticsearch.painless.MethodWriter;
@@ -37,8 +38,8 @@
 
     Method method = null;
 
-    public LCall(int line, String location, String name, List<AExpression> arguments) {
-        super(line, location, -1);
+    public LCall(int line, int offset, String location, String name, List<AExpression> arguments) {
+        super(line, offset, location, -1);
 
         this.name = name;
         this.arguments = arguments;
@@ -47,20 +48,20 @@ public LCall(int line, String location, String name, List<AExpression> arguments
     @Override
     ALink analyze(Variables variables) {
         if (before == null) {
-            throw new IllegalStateException(error("Illegal tree structure."));
-        } else if (before.sort == Definition.Sort.ARRAY) {
+            throw new IllegalArgumentException(error("Illegal call [" + name + "] made without target."));
+        } else if (before.sort == Sort.ARRAY) {
             throw new IllegalArgumentException(error("Illegal call [" + name + "] on array type."));
         } else if (store) {
             throw new IllegalArgumentException(error("Cannot assign a value to a call [" + name + "]."));
         }
 
         Definition.MethodKey methodKey = new Definition.MethodKey(name, arguments.size());
-        final Struct struct = before.struct;
+        Struct struct = before.struct;
         method = statik ? struct.staticMethods.get(methodKey) : struct.methods.get(methodKey);
 
         if (method != null) {
             for (int argument = 0; argument < arguments.size(); ++argument) {
-                final AExpression expression = arguments.get(argument);
+                AExpression expression = arguments.get(argument);
 
                 expression.expected = method.arguments.get(argument);
                 expression.internal = true;
@@ -72,8 +73,8 @@ ALink analyze(Variables variables) {
             after = method.rtn;
 
             return this;
-        } else if (before.sort == Definition.Sort.DEF) {
-            final ALink link = new LDefCall(line, location, name, arguments);
+        } else if (before.sort == Sort.DEF) {
+            ALink link = new LDefCall(line, offset, location, name, arguments);
             link.copy(this);
 
             return link.analyze(variables);
@@ -84,31 +85,31 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         // Do nothing.
     }
 
     @Override
-    void load(MethodWriter adapter) {
-        for (final AExpression argument : arguments) {
-            argument.write(adapter);
+    void load(MethodWriter writer) {
+        for (AExpression argument : arguments) {
+            argument.write(writer);
         }
 
         if (java.lang.reflect.Modifier.isStatic(method.reflect.getModifiers())) {
-            adapter.invokeStatic(method.owner.type, method.method);
+            writer.invokeStatic(method.owner.type, method.method);
         } else if (java.lang.reflect.Modifier.isInterface(method.owner.clazz.getModifiers())) {
-            adapter.invokeInterface(method.owner.type, method.method);
+            writer.invokeInterface(method.owner.type, method.method);
         } else {
-            adapter.invokeVirtual(method.owner.type, method.method);
+            writer.invokeVirtual(method.owner.type, method.method);
         }
 
         if (!method.rtn.clazz.equals(method.handle.type().returnType())) {
-            adapter.checkCast(method.rtn.type);
+            writer.checkCast(method.rtn.type);
         }
     }
 
     @Override
-    void store(MethodWriter adapter) {
+    void store(MethodWriter writer) {
         throw new IllegalStateException(error("Illegal tree structure."));
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LCast.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LCast.java
index 8e917c5b99ec..06dee04fca64 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LCast.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LCast.java
@@ -34,8 +34,8 @@
 
     Cast cast = null;
 
-    public LCast(int line, String location, String type) {
-        super(line, location, -1);
+    public LCast(int line, int offset, String location, String type) {
+        super(line, offset, location, -1);
 
         this.type = type;
     }
@@ -43,14 +43,14 @@ public LCast(int line, String location, String type) {
     @Override
     ALink analyze(Variables variables) {
         if (before == null) {
-            throw new IllegalStateException(error("Illegal tree structure."));
+            throw new IllegalStateException(error("Illegal cast without a target."));
         } else if (store) {
             throw new IllegalArgumentException(error("Cannot assign a value to a cast."));
         }
 
         try {
             after = Definition.getType(type);
-        } catch (final IllegalArgumentException exception) {
+        } catch (IllegalArgumentException exception) {
             throw new IllegalArgumentException(error("Not a type [" + type + "]."));
         }
 
@@ -60,17 +60,17 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        adapter.writeCast(cast);
+    void write(MethodWriter writer) {
+        writer.writeCast(cast);
     }
 
     @Override
-    void load(MethodWriter adapter) {
+    void load(MethodWriter writer) {
         // Do nothing.
     }
 
     @Override
-    void store(MethodWriter adapter) {
+    void store(MethodWriter writer) {
         throw new IllegalStateException(error("Illegal tree structure."));
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefArray.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefArray.java
index 1ef12026e655..452a0732cdb2 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefArray.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefArray.java
@@ -34,8 +34,8 @@
 
     AExpression index;
 
-    LDefArray(int line, String location, AExpression index) {
-        super(line, location, 2);
+    LDefArray(int line, int offset, String location, AExpression index) {
+        super(line, offset, location, 2);
 
         this.index = index;
     }
@@ -52,20 +52,19 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        index.write(adapter);
+    void write(MethodWriter writer) {
+        index.write(writer);
     }
 
     @Override
-    void load(MethodWriter adapter) {
-        final String desc = Type.getMethodDescriptor(after.type, Definition.DEF_TYPE.type, index.actual.type);
-        adapter.invokeDynamic("arrayLoad", desc, DEF_BOOTSTRAP_HANDLE, DefBootstrap.ARRAY_LOAD);
+    void load(MethodWriter writer) {
+        String desc = Type.getMethodDescriptor(after.type, Definition.DEF_TYPE.type, index.actual.type);
+        writer.invokeDynamic("arrayLoad", desc, DEF_BOOTSTRAP_HANDLE, (Object)DefBootstrap.ARRAY_LOAD);
     }
 
     @Override
-    void store(MethodWriter adapter) {
-        final String desc = Type.getMethodDescriptor(Definition.VOID_TYPE.type, Definition.DEF_TYPE.type,
-            index.actual.type, after.type);
-        adapter.invokeDynamic("arrayStore", desc, DEF_BOOTSTRAP_HANDLE, DefBootstrap.ARRAY_STORE);
+    void store(MethodWriter writer) {
+        String desc = Type.getMethodDescriptor(Definition.VOID_TYPE.type, Definition.DEF_TYPE.type, index.actual.type, after.type);
+        writer.invokeDynamic("arrayStore", desc, DEF_BOOTSTRAP_HANDLE, (Object)DefBootstrap.ARRAY_STORE);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefCall.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefCall.java
index a9d1cb2b8921..8ddde1cbed4d 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefCall.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefCall.java
@@ -36,8 +36,8 @@
     final String name;
     final List<AExpression> arguments;
 
-    LDefCall(int line, String location, String name, List<AExpression> arguments) {
-        super(line, location, -1);
+    LDefCall(int line, int offset, String location, String name, List<AExpression> arguments) {
+        super(line, offset, location, -1);
 
         this.name = name;
         this.arguments = arguments;
@@ -46,7 +46,7 @@
     @Override
     ALink analyze(Variables variables) {
         for (int argument = 0; argument < arguments.size(); ++argument) {
-            final AExpression expression = arguments.get(argument);
+            AExpression expression = arguments.get(argument);
 
             expression.internal = true;
             expression.analyze(variables);
@@ -61,34 +61,32 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         // Do nothing.
     }
 
     @Override
-    void load(MethodWriter adapter) {
-        final StringBuilder signature = new StringBuilder();
+    void load(MethodWriter writer) {
+        StringBuilder signature = new StringBuilder();
 
         signature.append('(');
         // first parameter is the receiver, we never know its type: always Object
         signature.append(Definition.DEF_TYPE.type.getDescriptor());
 
-        // TODO: remove our explicit conversions and feed more type information for return value,
-        // it can avoid some unnecessary boxing etc.
-        for (final AExpression argument : arguments) {
+        for (AExpression argument : arguments) {
             signature.append(argument.actual.type.getDescriptor());
-            argument.write(adapter);
+            argument.write(writer);
         }
 
         signature.append(')');
         // return value
         signature.append(after.type.getDescriptor());
 
-        adapter.invokeDynamic(name, signature.toString(), DEF_BOOTSTRAP_HANDLE, DefBootstrap.METHOD_CALL);
+        writer.invokeDynamic(name, signature.toString(), DEF_BOOTSTRAP_HANDLE, (Object)DefBootstrap.METHOD_CALL);
     }
 
     @Override
-    void store(MethodWriter adapter) {
+    void store(MethodWriter writer) {
         throw new IllegalStateException(error("Illegal tree structure."));
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefField.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefField.java
index ee0cf990c5b6..b0a9d4dd0d93 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefField.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LDefField.java
@@ -34,8 +34,8 @@
 
     final String value;
 
-    LDefField(int line, String location, String value) {
-        super(line, location, 1);
+    LDefField(int line, int offset, String location, String value) {
+        super(line, offset, location, 1);
 
         this.value = value;
     }
@@ -49,19 +49,19 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         // Do nothing.
     }
 
     @Override
-    void load(MethodWriter adapter) {
-        final String desc = Type.getMethodDescriptor(after.type, Definition.DEF_TYPE.type);
-        adapter.invokeDynamic(value, desc, DEF_BOOTSTRAP_HANDLE, DefBootstrap.LOAD);
+    void load(MethodWriter writer) {
+        String desc = Type.getMethodDescriptor(after.type, Definition.DEF_TYPE.type);
+        writer.invokeDynamic(value, desc, DEF_BOOTSTRAP_HANDLE, (Object)DefBootstrap.LOAD);
     }
 
     @Override
-    void store(MethodWriter adapter) {
-        final String desc = Type.getMethodDescriptor(Definition.VOID_TYPE.type, Definition.DEF_TYPE.type, after.type);
-        adapter.invokeDynamic(value, desc, DEF_BOOTSTRAP_HANDLE, DefBootstrap.STORE);
+    void store(MethodWriter writer) {
+        String desc = Type.getMethodDescriptor(Definition.VOID_TYPE.type, Definition.DEF_TYPE.type, after.type);
+        writer.invokeDynamic(value, desc, DEF_BOOTSTRAP_HANDLE, (Object)DefBootstrap.STORE);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LField.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LField.java
index 44ba33acddaf..9fbe543838f5 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LField.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LField.java
@@ -38,8 +38,8 @@
 
     Field field;
 
-    public LField(int line, String location, String value) {
-        super(line, location, 1);
+    public LField(int line, int offset, String location, String value) {
+        super(line, offset, location, 1);
 
         this.value = value;
     }
@@ -47,18 +47,18 @@ public LField(int line, String location, String value) {
     @Override
     ALink analyze(Variables variables) {
         if (before == null) {
-            throw new IllegalStateException(error("Illegal tree structure."));
+            throw new IllegalArgumentException(error("Illegal field [" + value + "] access made without target."));
         }
 
-        final Sort sort = before.sort;
+        Sort sort = before.sort;
 
         if (sort == Sort.ARRAY) {
-            return new LArrayLength(line, location, value).copy(this).analyze(variables);
+            return new LArrayLength(line, offset, location, value).copy(this).analyze(variables);
         } else if (sort == Sort.DEF) {
-            return new LDefField(line, location, value).copy(this).analyze(variables);
+            return new LDefField(line, offset, location, value).copy(this).analyze(variables);
         }
 
-        final Struct struct = before.struct;
+        Struct struct = before.struct;
         field = statik ? struct.staticMembers.get(value) : struct.members.get(value);
 
         if (field != null) {
@@ -71,25 +71,26 @@ ALink analyze(Variables variables) {
 
             return this;
         } else {
-            // TODO: improve this: the isXXX case seems missing???
-            final boolean shortcut =
-                struct.methods.containsKey(new Definition.MethodKey("get" + 
-                        Character.toUpperCase(value.charAt(0)) + value.substring(1), 0)) ||
-                struct.methods.containsKey(new Definition.MethodKey("set" + 
-                        Character.toUpperCase(value.charAt(0)) + value.substring(1), 1));
+            boolean shortcut =
+                struct.methods.containsKey(new Definition.MethodKey("get" +
+                    Character.toUpperCase(value.charAt(0)) + value.substring(1), 0)) ||
+                struct.methods.containsKey(new Definition.MethodKey("is" +
+                    Character.toUpperCase(value.charAt(0)) + value.substring(1), 0)) ||
+                struct.methods.containsKey(new Definition.MethodKey("set" +
+                    Character.toUpperCase(value.charAt(0)) + value.substring(1), 1));
 
             if (shortcut) {
-                return new LShortcut(line, location, value).copy(this).analyze(variables);
+                return new LShortcut(line, offset, location, value).copy(this).analyze(variables);
             } else {
-                final EConstant index = new EConstant(line, location, value);
+                EConstant index = new EConstant(line, offset, location, value);
                 index.analyze(variables);
 
                 if (Map.class.isAssignableFrom(before.clazz)) {
-                    return new LMapShortcut(line, location, index).copy(this).analyze(variables);
+                    return new LMapShortcut(line, offset, location, index).copy(this).analyze(variables);
                 }
-                
+
                 if (List.class.isAssignableFrom(before.clazz)) {
-                    return new LListShortcut(line, location, index).copy(this).analyze(variables);
+                    return new LListShortcut(line, offset, location, index).copy(this).analyze(variables);
                 }
             }
         }
@@ -98,25 +99,25 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         // Do nothing.
     }
 
     @Override
-    void load(MethodWriter adapter) {
+    void load(MethodWriter writer) {
         if (java.lang.reflect.Modifier.isStatic(field.reflect.getModifiers())) {
-            adapter.getStatic(field.owner.type, field.reflect.getName(), field.type.type);
+            writer.getStatic(field.owner.type, field.reflect.getName(), field.type.type);
         } else {
-            adapter.getField(field.owner.type, field.reflect.getName(), field.type.type);
+            writer.getField(field.owner.type, field.reflect.getName(), field.type.type);
         }
     }
 
     @Override
-    void store(MethodWriter adapter) {
+    void store(MethodWriter writer) {
         if (java.lang.reflect.Modifier.isStatic(field.reflect.getModifiers())) {
-            adapter.putStatic(field.owner.type, field.reflect.getName(), field.type.type);
+            writer.putStatic(field.owner.type, field.reflect.getName(), field.type.type);
         } else {
-            adapter.putField(field.owner.type, field.reflect.getName(), field.type.type);
+            writer.putField(field.owner.type, field.reflect.getName(), field.type.type);
         }
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LListShortcut.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LListShortcut.java
index 52f82c9d1ca0..f95c24f85923 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LListShortcut.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LListShortcut.java
@@ -34,8 +34,8 @@
     Method getter;
     Method setter;
 
-    LListShortcut(int line, String location, AExpression index) {
-        super(line, location, 2);
+    LListShortcut(int line, int offset, String location, AExpression index) {
+        super(line, offset, location, 2);
 
         this.index = index;
     }
@@ -73,31 +73,31 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        index.write(adapter);
+    void write(MethodWriter writer) {
+        index.write(writer);
     }
 
     @Override
-    void load(MethodWriter adapter) {
+    void load(MethodWriter writer) {
         if (java.lang.reflect.Modifier.isInterface(getter.owner.clazz.getModifiers())) {
-            adapter.invokeInterface(getter.owner.type, getter.method);
+            writer.invokeInterface(getter.owner.type, getter.method);
         } else {
-            adapter.invokeVirtual(getter.owner.type, getter.method);
+            writer.invokeVirtual(getter.owner.type, getter.method);
         }
 
         if (!getter.rtn.clazz.equals(getter.handle.type().returnType())) {
-            adapter.checkCast(getter.rtn.type);
+            writer.checkCast(getter.rtn.type);
         }
     }
 
     @Override
-    void store(MethodWriter adapter) {
+    void store(MethodWriter writer) {
         if (java.lang.reflect.Modifier.isInterface(setter.owner.clazz.getModifiers())) {
-            adapter.invokeInterface(setter.owner.type, setter.method);
+            writer.invokeInterface(setter.owner.type, setter.method);
         } else {
-            adapter.invokeVirtual(setter.owner.type, setter.method);
+            writer.invokeVirtual(setter.owner.type, setter.method);
         }
 
-        adapter.writePop(setter.rtn.sort.size);
+        writer.writePop(setter.rtn.sort.size);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LMapShortcut.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LMapShortcut.java
index 9fbc39d72b3b..afe93ba1048d 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LMapShortcut.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LMapShortcut.java
@@ -34,8 +34,8 @@
     Method getter;
     Method setter;
 
-    LMapShortcut(int line, String location, AExpression index) {
-        super(line, location, 2);
+    LMapShortcut(int line, int offset, String location, AExpression index) {
+        super(line, offset, location, 2);
 
         this.index = index;
     }
@@ -72,31 +72,31 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        index.write(adapter);
+    void write(MethodWriter writer) {
+        index.write(writer);
     }
 
     @Override
-    void load(MethodWriter adapter) {
+    void load(MethodWriter writer) {
         if (java.lang.reflect.Modifier.isInterface(getter.owner.clazz.getModifiers())) {
-            adapter.invokeInterface(getter.owner.type, getter.method);
+            writer.invokeInterface(getter.owner.type, getter.method);
         } else {
-            adapter.invokeVirtual(getter.owner.type, getter.method);
+            writer.invokeVirtual(getter.owner.type, getter.method);
         }
 
         if (!getter.rtn.clazz.equals(getter.handle.type().returnType())) {
-            adapter.checkCast(getter.rtn.type);
+            writer.checkCast(getter.rtn.type);
         }
     }
 
     @Override
-    void store(MethodWriter adapter) {
+    void store(MethodWriter writer) {
         if (java.lang.reflect.Modifier.isInterface(setter.owner.clazz.getModifiers())) {
-            adapter.invokeInterface(setter.owner.type, setter.method);
+            writer.invokeInterface(setter.owner.type, setter.method);
         } else {
-            adapter.invokeVirtual(setter.owner.type, setter.method);
+            writer.invokeVirtual(setter.owner.type, setter.method);
         }
 
-        adapter.writePop(setter.rtn.sort.size);
+        writer.writePop(setter.rtn.sort.size);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LNewArray.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LNewArray.java
index da88b45e72d7..ffe6168f812b 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LNewArray.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LNewArray.java
@@ -34,8 +34,8 @@
     final String type;
     final List<AExpression> arguments;
 
-    public LNewArray(int line, String location, String type, List<AExpression> arguments) {
-        super(line, location, -1);
+    public LNewArray(int line, int offset, String location, String type, List<AExpression> arguments) {
+        super(line, offset, location, -1);
 
         this.type = type;
         this.arguments = arguments;
@@ -44,23 +44,23 @@ public LNewArray(int line, String location, String type, List<AExpression> argum
     @Override
     ALink analyze(Variables variables) {
         if (before != null) {
-            throw new IllegalStateException(error("Illegal tree structure."));
+            throw new IllegalArgumentException(error("Cannot create a new array with a target already defined."));
         } else if (store) {
             throw new IllegalArgumentException(error("Cannot assign a value to a new array."));
         } else if (!load) {
-            throw new IllegalArgumentException(error("A newly created array must be assigned."));
+            throw new IllegalArgumentException(error("A newly created array must be read."));
         }
 
         final Type type;
 
         try {
             type = Definition.getType(this.type);
-        } catch (final IllegalArgumentException exception) {
+        } catch (IllegalArgumentException exception) {
             throw new IllegalArgumentException(error("Not a type [" + this.type + "]."));
         }
 
         for (int argument = 0; argument < arguments.size(); ++argument) {
-            final AExpression expression = arguments.get(argument);
+            AExpression expression = arguments.get(argument);
 
             expression.expected = Definition.INT_TYPE;
             expression.analyze(variables);
@@ -73,25 +73,25 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         // Do nothing.
     }
 
     @Override
-    void load(MethodWriter adapter) {
-        for (final AExpression argument : arguments) {
-            argument.write(adapter);
+    void load(MethodWriter writer) {
+        for (AExpression argument : arguments) {
+            argument.write(writer);
         }
 
         if (arguments.size() > 1) {
-            adapter.visitMultiANewArrayInsn(after.type.getDescriptor(), after.type.getDimensions());
+            writer.visitMultiANewArrayInsn(after.type.getDescriptor(), after.type.getDimensions());
         } else {
-            adapter.newArray(Definition.getType(after.struct, 0).type);
+            writer.newArray(Definition.getType(after.struct, 0).type);
         }
     }
 
     @Override
-    void store(MethodWriter adapter) {
+    void store(MethodWriter writer) {
         throw new IllegalStateException(error("Illegal tree structure."));
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LNewObj.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LNewObj.java
index 28209e96f2b2..dc8b711ee8c7 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LNewObj.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LNewObj.java
@@ -38,8 +38,8 @@
 
     Constructor constructor;
 
-    public LNewObj(int line, String location, String type, List<AExpression> arguments) {
-        super(line, location, -1);
+    public LNewObj(int line, int offset, String location, String type, List<AExpression> arguments) {
+        super(line, offset, location, -1);
 
         this.type = type;
         this.arguments = arguments;
@@ -48,7 +48,7 @@ public LNewObj(int line, String location, String type, List<AExpression> argumen
     @Override
     ALink analyze(Variables variables) {
         if (before != null) {
-            throw new IllegalStateException(error("Illegal tree structure"));
+            throw new IllegalArgumentException(error("Illegal new call with a target already defined."));
         } else if (store) {
             throw new IllegalArgumentException(error("Cannot assign a value to a new call."));
         }
@@ -57,15 +57,15 @@ ALink analyze(Variables variables) {
 
         try {
             type = Definition.getType(this.type);
-        } catch (final IllegalArgumentException exception) {
+        } catch (IllegalArgumentException exception) {
             throw new IllegalArgumentException(error("Not a type [" + this.type + "]."));
         }
 
-        final Struct struct = type.struct;
+        Struct struct = type.struct;
         constructor = struct.constructors.get(new Definition.MethodKey("new", arguments.size()));
 
         if (constructor != null) {
-            final Type[] types = new Type[constructor.arguments.size()];
+            Type[] types = new Type[constructor.arguments.size()];
             constructor.arguments.toArray(types);
 
             if (constructor.arguments.size() != arguments.size()) {
@@ -74,7 +74,7 @@ ALink analyze(Variables variables) {
             }
 
             for (int argument = 0; argument < arguments.size(); ++argument) {
-                final AExpression expression = arguments.get(argument);
+                AExpression expression = arguments.get(argument);
 
                 expression.expected = types[argument];
                 expression.internal = true;
@@ -92,27 +92,27 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         // Do nothing.
     }
 
     @Override
-    void load(MethodWriter adapter) {
-        adapter.newInstance(after.type);
+    void load(MethodWriter writer) {
+        writer.newInstance(after.type);
 
         if (load) {
-            adapter.dup();
+            writer.dup();
         }
 
         for (AExpression argument : arguments) {
-            argument.write(adapter);
+            argument.write(writer);
         }
 
-        adapter.invokeConstructor(constructor.owner.type, constructor.method);
+        writer.invokeConstructor(constructor.owner.type, constructor.method);
     }
 
     @Override
-    void store(MethodWriter adapter) {
+    void store(MethodWriter writer) {
         throw new IllegalStateException(error("Illegal tree structure."));
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LShortcut.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LShortcut.java
index 85a7d70c46e8..c6aafd47bffa 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LShortcut.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LShortcut.java
@@ -36,17 +36,22 @@
     Method getter = null;
     Method setter = null;
 
-    LShortcut(int line, String location, String value) {
-        super(line, location, 1);
+    LShortcut(int line, int offset, String location, String value) {
+        super(line, offset, location, 1);
 
         this.value = value;
     }
 
     @Override
     ALink analyze(Variables variables) {
-        final Struct struct = before.struct;
+        Struct struct = before.struct;
 
         getter = struct.methods.get(new Definition.MethodKey("get" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0));
+
+        if (getter == null) {
+            getter = struct.methods.get(new Definition.MethodKey("is" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 0));
+        }
+
         setter = struct.methods.get(new Definition.MethodKey("set" + Character.toUpperCase(value.charAt(0)) + value.substring(1), 1));
 
         if (getter != null && (getter.rtn.sort == Sort.VOID || !getter.arguments.isEmpty())) {
@@ -73,31 +78,31 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         // Do nothing.
     }
 
     @Override
-    void load(MethodWriter adapter) {
+    void load(MethodWriter writer) {
         if (java.lang.reflect.Modifier.isInterface(getter.owner.clazz.getModifiers())) {
-            adapter.invokeInterface(getter.owner.type, getter.method);
+            writer.invokeInterface(getter.owner.type, getter.method);
         } else {
-            adapter.invokeVirtual(getter.owner.type, getter.method);
+            writer.invokeVirtual(getter.owner.type, getter.method);
         }
 
         if (!getter.rtn.clazz.equals(getter.handle.type().returnType())) {
-            adapter.checkCast(getter.rtn.type);
+            writer.checkCast(getter.rtn.type);
         }
     }
 
     @Override
-    void store(MethodWriter adapter) {
+    void store(MethodWriter writer) {
         if (java.lang.reflect.Modifier.isInterface(setter.owner.clazz.getModifiers())) {
-            adapter.invokeInterface(setter.owner.type, setter.method);
+            writer.invokeInterface(setter.owner.type, setter.method);
         } else {
-            adapter.invokeVirtual(setter.owner.type, setter.method);
+            writer.invokeVirtual(setter.owner.type, setter.method);
         }
 
-        adapter.writePop(setter.rtn.sort.size);
+        writer.writePop(setter.rtn.sort.size);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LStatic.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LStatic.java
new file mode 100644
index 000000000000..8919b75dc27c
--- /dev/null
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LStatic.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.painless.node;
+
+import org.elasticsearch.painless.Definition;
+import org.elasticsearch.painless.MethodWriter;
+import org.elasticsearch.painless.Variables;
+
+/**
+ * Represents a static type target.
+ */
+public final class LStatic extends ALink {
+
+    final String type;
+
+    public LStatic(int line, int offset, String location, String type) {
+        super(line, offset, location, 0);
+
+        this.type = type;
+    }
+
+    @Override
+    ALink analyze(Variables variables) {
+        if (before != null) {
+            throw new IllegalArgumentException(error("Illegal static type [" + type + "] after target already defined."));
+        }
+
+        try {
+            after = Definition.getType(type);
+            statik = true;
+        } catch (IllegalArgumentException exception) {
+            throw new IllegalArgumentException(error("Not a type [" + type + "]."));
+        }
+
+        return this;
+    }
+
+    @Override
+    void write(MethodWriter writer) {
+        throw new IllegalStateException(error("Illegal tree structure."));
+    }
+
+    @Override
+    void load(MethodWriter writer) {
+        throw new IllegalStateException(error("Illegal tree structure."));
+    }
+
+    @Override
+    void store(MethodWriter writer) {
+        throw new IllegalStateException(error("Illegal tree structure."));
+    }
+}
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LString.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LString.java
index 07d76d42676e..446750a22bbd 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LString.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LString.java
@@ -28,8 +28,8 @@
  */
 public final class LString extends ALink {
 
-    public LString(int line, String location, String string) {
-        super(line, location, -1);
+    public LString(int line, int offset, String location, String string) {
+        super(line, offset, location, -1);
 
         this.string = string;
     }
@@ -37,7 +37,7 @@ public LString(int line, String location, String string) {
     @Override
     ALink analyze(Variables variables) {
         if (before != null) {
-            throw new IllegalStateException("Illegal tree structure.");
+            throw new IllegalArgumentException(error("Illegal String constant [" + string + "]."));
         } else if (store) {
             throw new IllegalArgumentException(error("Cannot write to read-only String constant [" + string + "]."));
         } else if (!load) {
@@ -50,17 +50,17 @@ ALink analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         // Do nothing.
     }
 
     @Override
-    void load(MethodWriter adapter) {
-        adapter.push(string);
+    void load(MethodWriter writer) {
+        writer.push(string);
     }
 
     @Override
-    void store(MethodWriter adapter) {
+    void store(MethodWriter writer) {
         throw new IllegalStateException(error("Illegal tree structure."));
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LVariable.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LVariable.java
index 85a2048bdc6e..3a555d93c874 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LVariable.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/LVariable.java
@@ -19,12 +19,10 @@
 
 package org.elasticsearch.painless.node;
 
-import org.elasticsearch.painless.Definition;
-import org.elasticsearch.painless.Definition.Type;
+import org.elasticsearch.painless.MethodWriter;
 import org.elasticsearch.painless.Variables;
 import org.elasticsearch.painless.Variables.Variable;
 import org.objectweb.asm.Opcodes;
-import org.elasticsearch.painless.MethodWriter;
 
 /**
  * Represents a variable load/store.
@@ -35,8 +33,8 @@
 
     int slot;
 
-    public LVariable(int line, String location, String name) {
-        super(line, location, 0);
+    public LVariable(int line, int offset, String location, String name) {
+        super(line, offset, location, 0);
 
         this.name = name;
     }
@@ -44,46 +42,33 @@ public LVariable(int line, String location, String name) {
     @Override
     ALink analyze(Variables variables) {
         if (before != null) {
-            throw new IllegalStateException(error("Illegal tree structure."));
+            throw new IllegalArgumentException(error("Illegal variable [" + name + "] access with target already defined."));
         }
 
-        Type type = null;
+        Variable variable = variables.getVariable(location, name);
 
-        try {
-            type = Definition.getType(name);
-        } catch (final IllegalArgumentException exception) {
-            // Do nothing.
+        if (store && variable.readonly) {
+            throw new IllegalArgumentException(error("Variable [" + variable.name + "] is read-only."));
         }
 
-        if (type != null) {
-            statik = true;
-            after = type;
-        } else {
-            final Variable variable = variables.getVariable(location, name);
-
-            if (store && variable.readonly) {
-                throw new IllegalArgumentException(error("Variable [" + variable.name + "] is read-only."));
-            }
-
-            slot = variable.slot;
-            after = variable.type;
-        }
+        slot = variable.slot;
+        after = variable.type;
 
         return this;
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         // Do nothing.
     }
 
     @Override
-    void load(MethodWriter adapter) {
-        adapter.visitVarInsn(after.type.getOpcode(Opcodes.ILOAD), slot);
+    void load(MethodWriter writer) {
+        writer.visitVarInsn(after.type.getOpcode(Opcodes.ILOAD), slot);
     }
 
     @Override
-    void store(MethodWriter adapter) {
-        adapter.visitVarInsn(after.type.getOpcode(Opcodes.ISTORE), slot);
+    void store(MethodWriter writer) {
+        writer.visitVarInsn(after.type.getOpcode(Opcodes.ISTORE), slot);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBlock.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBlock.java
index a925c411a2aa..0f05243f9944 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBlock.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBlock.java
@@ -32,14 +32,18 @@
 
     final List<AStatement> statements;
 
-    public SBlock(int line, String location, List<AStatement> statements) {
-        super(line, location);
+    public SBlock(int line, int offset, String location, List<AStatement> statements) {
+        super(line, offset, location);
 
         this.statements = Collections.unmodifiableList(statements);
     }
 
     @Override
     void analyze(Variables variables) {
+        if (statements == null || statements.isEmpty()) {
+            throw new IllegalArgumentException(error("A block must contain at least one statement."));
+        }
+
         final AStatement last = statements.get(statements.size() - 1);
 
         for (AStatement statement : statements) {
@@ -63,11 +67,11 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
+    void write(MethodWriter writer) {
         for (AStatement statement : statements) {
             statement.continu = continu;
             statement.brake = brake;
-            statement.write(adapter);
+            statement.write(writer);
         }
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBreak.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBreak.java
index fb12a2b452e6..727cd4b929ce 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBreak.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBreak.java
@@ -27,8 +27,8 @@
  */
 public final class SBreak extends AStatement {
 
-    public SBreak(int line, String location) {
-        super(line, location);
+    public SBreak(int line, int offset, String location) {
+        super(line, offset, location);
     }
 
     @Override
@@ -44,8 +44,9 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        adapter.goTo(brake);
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        writer.goTo(brake);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/STrap.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SCatch.java
similarity index 68%
rename from modules/lang-painless/src/main/java/org/elasticsearch/painless/node/STrap.java
rename to modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SCatch.java
index 9a791b1615de..b3b32d741cd5 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/STrap.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SCatch.java
@@ -19,6 +19,8 @@
 
 package org.elasticsearch.painless.node;
 
+import org.elasticsearch.painless.Definition;
+import org.elasticsearch.painless.Definition.Type;
 import org.elasticsearch.painless.Variables;
 import org.elasticsearch.painless.Variables.Variable;
 import org.objectweb.asm.Label;
@@ -28,11 +30,11 @@
 /**
  * Represents a catch block as part of a try-catch block.
  */
-public final class STrap extends AStatement {
+public final class SCatch extends AStatement {
 
     final String type;
     final String name;
-    final AStatement block;
+    final SBlock block;
 
     Variable variable;
 
@@ -40,8 +42,8 @@
     Label end;
     Label exception;
 
-    public STrap(int line, String location, String type, String name, AStatement block) {
-        super(line, location);
+    public SCatch(int line, int offset, String location, String type, String name, SBlock block) {
+        super(line, offset, location);
 
         this.type = type;
         this.name = name;
@@ -50,12 +52,20 @@ public STrap(int line, String location, String type, String name, AStatement blo
 
     @Override
     void analyze(Variables variables) {
-        variable = variables.addVariable(location, type, name, true, false);
+        final Type type;
+
+        try {
+            type = Definition.getType(this.type);
+        } catch (IllegalArgumentException exception) {
+            throw new IllegalArgumentException(error("Not a type [" + this.type + "]."));
+        }
 
-        if (!Exception.class.isAssignableFrom(variable.type.clazz)) {
-            throw new ClassCastException(error("Not an exception type [" + variable.type.name + "]."));
+        if (!Exception.class.isAssignableFrom(type.clazz)) {
+            throw new ClassCastException(error("Not an exception type [" + this.type + "]."));
         }
 
+        variable = variables.addVariable(location, type, name, true, false);
+
         if (block != null) {
             block.lastSource = lastSource;
             block.inLoop = inLoop;
@@ -73,23 +83,24 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        final Label jump = new Label();
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        Label jump = new Label();
 
-        adapter.mark(jump);
-        adapter.visitVarInsn(variable.type.type.getOpcode(Opcodes.ISTORE), variable.slot);
+        writer.mark(jump);
+        writer.visitVarInsn(variable.type.type.getOpcode(Opcodes.ISTORE), variable.slot);
 
         if (block != null) {
             block.continu = continu;
             block.brake = brake;
-            block.write(adapter);
+            block.write(writer);
         }
 
-        adapter.visitTryCatchBlock(begin, end, jump, variable.type.type.getInternalName());
+        writer.visitTryCatchBlock(begin, end, jump, variable.type.type.getInternalName());
 
         if (exception != null && !block.allEscape) {
-            adapter.goTo(exception);
+            writer.goTo(exception);
         }
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SContinue.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SContinue.java
index 01ca3f5697d4..bfea104f23d4 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SContinue.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SContinue.java
@@ -27,8 +27,8 @@
  */
 public final class SContinue extends AStatement {
 
-    public SContinue(int line, String location) {
-        super(line, location);
+    public SContinue(int line, int offset, String location) {
+        super(line, offset, location);
     }
 
     @Override
@@ -47,8 +47,9 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        adapter.goTo(continu);
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        writer.goTo(continu);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDeclBlock.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDeclBlock.java
index 917dd9b8e5a3..ddfe54c22eb2 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDeclBlock.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDeclBlock.java
@@ -32,15 +32,15 @@
 
     final List<SDeclaration> declarations;
 
-    public SDeclBlock(int line, String location, List<SDeclaration> declarations) {
-        super(line, location);
+    public SDeclBlock(int line, int offset, String location, List<SDeclaration> declarations) {
+        super(line, offset, location);
 
         this.declarations = Collections.unmodifiableList(declarations);
     }
 
     @Override
     void analyze(Variables variables) {
-        for (final SDeclaration declaration : declarations) {
+        for (SDeclaration declaration : declarations) {
             declaration.analyze(variables);
         }
 
@@ -48,9 +48,9 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        for (final SDeclaration declaration : declarations) {
-            declaration.write(adapter);
+    void write(MethodWriter writer) {
+        for (SDeclaration declaration : declarations) {
+            declaration.write(writer);
         }
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDeclaration.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDeclaration.java
index 0e366dfc19bc..246fb9928360 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDeclaration.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDeclaration.java
@@ -19,7 +19,8 @@
 
 package org.elasticsearch.painless.node;
 
-import org.elasticsearch.painless.Definition.Sort;
+import org.elasticsearch.painless.Definition;
+import org.elasticsearch.painless.Definition.Type;
 import org.elasticsearch.painless.Variables;
 import org.elasticsearch.painless.Variables.Variable;
 import org.objectweb.asm.Opcodes;
@@ -36,8 +37,8 @@
 
     Variable variable;
 
-    public SDeclaration(int line, String location, String type, String name, AExpression expression) {
-        super(line, location);
+    public SDeclaration(int line, int offset, String location, String type, String name, AExpression expression) {
+        super(line, offset, location);
 
         this.type = type;
         this.name = name;
@@ -46,40 +47,44 @@ public SDeclaration(int line, String location, String type, String name, AExpres
 
     @Override
     void analyze(Variables variables) {
-        variable = variables.addVariable(location, type, name, false, false);
+        final Type type;
+
+        try {
+            type = Definition.getType(this.type);
+        } catch (IllegalArgumentException exception) {
+            throw new IllegalArgumentException(error("Not a type [" + this.type + "]."));
+        }
 
         if (expression != null) {
-            expression.expected = variable.type;
+            expression.expected = type;
             expression.analyze(variables);
             expression = expression.cast(variables);
         }
+
+        variable = variables.addVariable(location, type, name, false, false);
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        final org.objectweb.asm.Type type = variable.type.type;
-        final Sort sort = variable.type.sort;
-
-        final boolean initialize = expression == null;
-
-        if (!initialize) {
-            expression.write(adapter);
-        }
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
 
-        switch (sort) {
-            case VOID:   throw new IllegalStateException(error("Illegal tree structure."));
-            case BOOL:
-            case BYTE:
-            case SHORT:
-            case CHAR:
-            case INT:    if (initialize) adapter.push(0);    break;
-            case LONG:   if (initialize) adapter.push(0L);   break;
-            case FLOAT:  if (initialize) adapter.push(0.0F); break;
-            case DOUBLE: if (initialize) adapter.push(0.0);  break;
-            default:     if (initialize) adapter.visitInsn(Opcodes.ACONST_NULL);
+        if (expression == null) {
+            switch (variable.type.sort) {
+                case VOID:   throw new IllegalStateException(error("Illegal tree structure."));
+                case BOOL:
+                case BYTE:
+                case SHORT:
+                case CHAR:
+                case INT:    writer.push(0);    break;
+                case LONG:   writer.push(0L);   break;
+                case FLOAT:  writer.push(0.0F); break;
+                case DOUBLE: writer.push(0.0);  break;
+                default:     writer.visitInsn(Opcodes.ACONST_NULL);
+            }
+        } else {
+            expression.write(writer);
         }
 
-        adapter.visitVarInsn(type.getOpcode(Opcodes.ISTORE), variable.slot);
+        writer.visitVarInsn(variable.type.type.getOpcode(Opcodes.ISTORE), variable.slot);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDo.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDo.java
index 6c8785a923a6..3fbc3b9fafcb 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDo.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDo.java
@@ -29,12 +29,12 @@
  */
 public final class SDo extends AStatement {
 
-    final AStatement block;
-    AExpression condition;
     final int maxLoopCounter;
+    final SBlock block;
+    AExpression condition;
 
-    public SDo(int line, String location, AStatement block, AExpression condition, int maxLoopCounter) {
-        super(line, location);
+    public SDo(int line, int offset, String location, int maxLoopCounter, SBlock block, AExpression condition) {
+        super(line, offset, location);
 
         this.condition = condition;
         this.block = block;
@@ -45,6 +45,10 @@ public SDo(int line, String location, AStatement block, AExpression condition, i
     void analyze(Variables variables) {
         variables.incrementScope();
 
+        if (block == null) {
+            throw new IllegalArgumentException(error("Extraneous do while loop."));
+        }
+
         block.beginLoop = true;
         block.inLoop = true;
 
@@ -81,26 +85,27 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        final Label start = new Label();
-        final Label begin = new Label();
-        final Label end = new Label();
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        Label start = new Label();
+        Label begin = new Label();
+        Label end = new Label();
 
-        adapter.mark(start);
+        writer.mark(start);
 
         block.continu = begin;
         block.brake = end;
-        block.write(adapter);
+        block.write(writer);
 
-        adapter.mark(begin);
+        writer.mark(begin);
 
         condition.fals = end;
-        condition.write(adapter);
+        condition.write(writer);
 
-        adapter.writeLoopCounter(loopCounterSlot, Math.max(1, block.statementCount));
+        writer.writeLoopCounter(loopCounterSlot, Math.max(1, block.statementCount));
 
-        adapter.goTo(start);
-        adapter.mark(end);
+        writer.goTo(start);
+        writer.mark(end);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SExpression.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SExpression.java
index 9d2bc6385a54..a9f47fb65228 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SExpression.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SExpression.java
@@ -31,8 +31,8 @@
 
     AExpression expression;
 
-    public SExpression(int line, String location, AExpression expression) {
-        super(line, location);
+    public SExpression(int line, int offset, String location, AExpression expression) {
+        super(line, offset, location);
 
         this.expression = expression;
     }
@@ -59,14 +59,15 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        expression.write(adapter);
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        expression.write(writer);
 
         if (methodEscape) {
-            adapter.returnValue();
+            writer.returnValue();
         } else {
-            adapter.writePop(expression.expected.sort.size);
+            writer.writePop(expression.expected.sort.size);
         }
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SFor.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SFor.java
index 56073e6e8db1..5fb1845e5512 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SFor.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SFor.java
@@ -29,15 +29,15 @@
  */
 public final class SFor extends AStatement {
 
+    final int maxLoopCounter;
     ANode initializer;
     AExpression condition;
     AExpression afterthought;
-    final AStatement block;
-    final int maxLoopCounter;
+    final SBlock block;
 
-    public SFor(int line, String location,
-                ANode initializer, AExpression condition, AExpression afterthought, AStatement block, int maxLoopCounter) {
-        super(line, location);
+    public SFor(int line, int offset, String location, int maxLoopCounter,
+                ANode initializer, AExpression condition, AExpression afterthought, SBlock block) {
+        super(line, offset, location);
 
         this.initializer = initializer;
         this.condition = condition;
@@ -56,7 +56,7 @@ void analyze(Variables variables) {
             if (initializer instanceof SDeclBlock) {
                 ((SDeclBlock)initializer).analyze(variables);
             } else if (initializer instanceof AExpression) {
-                final AExpression initializer = (AExpression)this.initializer;
+                AExpression initializer = (AExpression)this.initializer;
 
                 initializer.read = false;
                 initializer.analyze(variables);
@@ -70,7 +70,6 @@ void analyze(Variables variables) {
         }
 
         if (condition != null) {
-
             condition.expected = Definition.BOOLEAN_TYPE;
             condition.analyze(variables);
             condition = condition.cast(variables);
@@ -99,8 +98,6 @@ void analyze(Variables variables) {
             }
         }
 
-        int count = 1;
-
         if (block != null) {
             block.beginLoop = true;
             block.inLoop = true;
@@ -116,7 +113,7 @@ void analyze(Variables variables) {
                 allEscape = true;
             }
 
-            block.statementCount = Math.max(count, block.statementCount);
+            block.statementCount = Math.max(1, block.statementCount);
         }
 
         statementCount = 1;
@@ -129,26 +126,27 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        final Label start = new Label();
-        final Label begin = afterthought == null ? start : new Label();
-        final Label end = new Label();
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        Label start = new Label();
+        Label begin = afterthought == null ? start : new Label();
+        Label end = new Label();
 
         if (initializer instanceof SDeclBlock) {
-            ((SDeclBlock)initializer).write(adapter);
+            ((SDeclBlock)initializer).write(writer);
         } else if (initializer instanceof AExpression) {
             AExpression initializer = (AExpression)this.initializer;
 
-            initializer.write(adapter);
-            adapter.writePop(initializer.expected.sort.size);
+            initializer.write(writer);
+            writer.writePop(initializer.expected.sort.size);
         }
 
-        adapter.mark(start);
+        writer.mark(start);
 
         if (condition != null) {
             condition.fals = end;
-            condition.write(adapter);
+            condition.write(writer);
         }
 
         boolean allEscape = false;
@@ -162,21 +160,21 @@ void write(MethodWriter adapter) {
                 ++statementCount;
             }
 
-            adapter.writeLoopCounter(loopCounterSlot, statementCount);
-            block.write(adapter);
+            writer.writeLoopCounter(loopCounterSlot, statementCount);
+            block.write(writer);
         } else {
-            adapter.writeLoopCounter(loopCounterSlot, 1);
+            writer.writeLoopCounter(loopCounterSlot, 1);
         }
 
         if (afterthought != null) {
-            adapter.mark(begin);
-            afterthought.write(adapter);
+            writer.mark(begin);
+            afterthought.write(writer);
         }
 
         if (afterthought != null || !allEscape) {
-            adapter.goTo(start);
+            writer.goTo(start);
         }
 
-        adapter.mark(end);
+        writer.mark(end);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SIf.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SIf.java
new file mode 100644
index 000000000000..180b5023811a
--- /dev/null
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SIf.java
@@ -0,0 +1,84 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.painless.node;
+
+import org.elasticsearch.painless.Definition;
+import org.elasticsearch.painless.Variables;
+import org.objectweb.asm.Label;
+import org.elasticsearch.painless.MethodWriter;
+
+/**
+ * Represents an if block.
+ */
+public final class SIf extends AStatement {
+
+    AExpression condition;
+    final SBlock ifblock;
+
+    public SIf(int line, int offset, String location, AExpression condition, SBlock ifblock) {
+        super(line, offset, location);
+
+        this.condition = condition;
+        this.ifblock = ifblock;
+    }
+
+    @Override
+    void analyze(Variables variables) {
+        condition.expected = Definition.BOOLEAN_TYPE;
+        condition.analyze(variables);
+        condition = condition.cast(variables);
+
+        if (condition.constant != null) {
+            throw new IllegalArgumentException(error("Extraneous if statement."));
+        }
+
+        if (ifblock == null) {
+            throw new IllegalArgumentException(error("Extraneous if statement."));
+        }
+
+        ifblock.lastSource = lastSource;
+        ifblock.inLoop = inLoop;
+        ifblock.lastLoop = lastLoop;
+
+        variables.incrementScope();
+        ifblock.analyze(variables);
+        variables.decrementScope();
+
+        anyContinue = ifblock.anyContinue;
+        anyBreak = ifblock.anyBreak;
+        statementCount = ifblock.statementCount;
+    }
+
+    @Override
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        Label fals = new Label();
+
+        condition.fals = fals;
+        condition.write(writer);
+
+        ifblock.continu = continu;
+        ifblock.brake = brake;
+        ifblock.write(writer);
+
+        writer.mark(fals);
+    }
+}
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SIfElse.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SIfElse.java
index 560ce44e415d..217584f32abc 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SIfElse.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SIfElse.java
@@ -30,11 +30,11 @@
 public final class SIfElse extends AStatement {
 
     AExpression condition;
-    final AStatement ifblock;
-    final AStatement elseblock;
+    final SBlock ifblock;
+    final SBlock elseblock;
 
-    public SIfElse(int line, String location, AExpression condition, AStatement ifblock, AStatement elseblock) {
-        super(line, location);
+    public SIfElse(int line, int offset, String location, AExpression condition, SBlock ifblock, SBlock elseblock) {
+        super(line, offset, location);
 
         this.condition = condition;
         this.ifblock = ifblock;
@@ -51,6 +51,10 @@ void analyze(Variables variables) {
             throw new IllegalArgumentException(error("Extraneous if statement."));
         }
 
+        if (ifblock == null) {
+            throw new IllegalArgumentException(error("Extraneous if statement."));
+        }
+
         ifblock.lastSource = lastSource;
         ifblock.inLoop = inLoop;
         ifblock.lastLoop = lastLoop;
@@ -63,49 +67,50 @@ void analyze(Variables variables) {
         anyBreak = ifblock.anyBreak;
         statementCount = ifblock.statementCount;
 
-        if (elseblock != null) {
-            elseblock.lastSource = lastSource;
-            elseblock.inLoop = inLoop;
-            elseblock.lastLoop = lastLoop;
-
-            variables.incrementScope();
-            elseblock.analyze(variables);
-            variables.decrementScope();
-
-            methodEscape = ifblock.methodEscape && elseblock.methodEscape;
-            loopEscape = ifblock.loopEscape && elseblock.loopEscape;
-            allEscape = ifblock.allEscape && elseblock.allEscape;
-            anyContinue |= elseblock.anyContinue;
-            anyBreak |= elseblock.anyBreak;
-            statementCount = Math.max(ifblock.statementCount, elseblock.statementCount);
+        if (elseblock == null) {
+            throw new IllegalArgumentException(error("Extraneous else statement."));
         }
+
+        elseblock.lastSource = lastSource;
+        elseblock.inLoop = inLoop;
+        elseblock.lastLoop = lastLoop;
+
+        variables.incrementScope();
+        elseblock.analyze(variables);
+        variables.decrementScope();
+
+        methodEscape = ifblock.methodEscape && elseblock.methodEscape;
+        loopEscape = ifblock.loopEscape && elseblock.loopEscape;
+        allEscape = ifblock.allEscape && elseblock.allEscape;
+        anyContinue |= elseblock.anyContinue;
+        anyBreak |= elseblock.anyBreak;
+        statementCount = Math.max(ifblock.statementCount, elseblock.statementCount);
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        final Label end = new Label();
-        final Label fals = elseblock != null ? new Label() : end;
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        Label end = new Label();
+        Label fals = elseblock != null ? new Label() : end;
 
         condition.fals = fals;
-        condition.write(adapter);
+        condition.write(writer);
 
         ifblock.continu = continu;
         ifblock.brake = brake;
-        ifblock.write(adapter);
+        ifblock.write(writer);
 
-        if (elseblock != null) {
-            if (!ifblock.allEscape) {
-                adapter.goTo(end);
-            }
+        if (!ifblock.allEscape) {
+            writer.goTo(end);
+        }
 
-            adapter.mark(fals);
+        writer.mark(fals);
 
-            elseblock.continu = continu;
-            elseblock.brake = brake;
-            elseblock.write(adapter);
-        }
+        elseblock.continu = continu;
+        elseblock.brake = brake;
+        elseblock.write(writer);
 
-        adapter.mark(end);
+        writer.mark(end);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SReturn.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SReturn.java
index ecdf5c7b69af..2f342a5b7b93 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SReturn.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SReturn.java
@@ -30,8 +30,8 @@
 
     AExpression expression;
 
-    public SReturn(int line, String location, AExpression expression) {
-        super(line, location);
+    public SReturn(int line, int offset, String location, AExpression expression) {
+        super(line, offset, location);
 
         this.expression = expression;
     }
@@ -51,9 +51,10 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        expression.write(adapter);
-        adapter.returnValue();
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        expression.write(writer);
+        writer.returnValue();
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSource.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSource.java
index 0932ae6e2f0f..899d54225dcc 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSource.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SSource.java
@@ -33,19 +33,23 @@
 
     final List<AStatement> statements;
 
-    public SSource(int line, String location, List<AStatement> statements) {
-        super(line, location);
+    public SSource(int line, int offset, String location, List<AStatement> statements) {
+        super(line, offset, location);
 
         this.statements = Collections.unmodifiableList(statements);
     }
 
     @Override
     public void analyze(Variables variables) {
+        if (statements == null || statements.isEmpty()) {
+            throw new IllegalArgumentException(error("Cannot generate an empty script."));
+        }
+
         variables.incrementScope();
 
         final AStatement last = statements.get(statements.size() - 1);
 
-        for (final AStatement statement : statements) {
+        for (AStatement statement : statements) {
             if (allEscape) {
                 throw new IllegalArgumentException(error("Unreachable statement."));
             }
@@ -61,14 +65,14 @@ public void analyze(Variables variables) {
     }
 
     @Override
-    public void write(MethodWriter adapter) {
-        for (final AStatement statement : statements) {
-            statement.write(adapter);
+    public void write(MethodWriter writer) {
+        for (AStatement statement : statements) {
+            statement.write(writer);
         }
 
         if (!methodEscape) {
-            adapter.visitInsn(Opcodes.ACONST_NULL);
-            adapter.returnValue();
+            writer.visitInsn(Opcodes.ACONST_NULL);
+            writer.returnValue();
         }
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SThrow.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SThrow.java
index a0bfa12e2673..d002f1f9dada 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SThrow.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SThrow.java
@@ -30,8 +30,8 @@
 
     AExpression expression;
 
-    public SThrow(int line, String location, AExpression expression) {
-        super(line, location);
+    public SThrow(int line, int offset, String location, AExpression expression) {
+        super(line, offset, location);
 
         this.expression = expression;
     }
@@ -49,9 +49,10 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        expression.write(adapter);
-        adapter.throwException();
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        expression.write(writer);
+        writer.throwException();
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/STry.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/STry.java
index 4f97d5835ccb..a4ef00ef1461 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/STry.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/STry.java
@@ -31,18 +31,22 @@
  */
 public final class STry extends AStatement {
 
-    final AStatement block;
-    final List<STrap> traps;
+    final SBlock block;
+    final List<SCatch> catches;
 
-    public STry(int line, String location, AStatement block, List<STrap> traps) {
-        super(line, location);
+    public STry(int line, int offset, String location, SBlock block, List<SCatch> traps) {
+        super(line, offset, location);
 
         this.block = block;
-        this.traps = Collections.unmodifiableList(traps);
+        this.catches = Collections.unmodifiableList(traps);
     }
 
     @Override
     void analyze(Variables variables) {
+        if (block == null) {
+            throw new IllegalArgumentException(error("Extraneous try statement."));
+        }
+
         block.lastSource = lastSource;
         block.inLoop = inLoop;
         block.lastLoop = lastLoop;
@@ -59,55 +63,56 @@ void analyze(Variables variables) {
 
         int statementCount = 0;
 
-        for (final STrap trap : traps) {
-            trap.lastSource = lastSource;
-            trap.inLoop = inLoop;
-            trap.lastLoop = lastLoop;
+        for (SCatch catc : catches) {
+            catc.lastSource = lastSource;
+            catc.inLoop = inLoop;
+            catc.lastLoop = lastLoop;
 
             variables.incrementScope();
-            trap.analyze(variables);
+            catc.analyze(variables);
             variables.decrementScope();
 
-            methodEscape &= trap.methodEscape;
-            loopEscape &= trap.loopEscape;
-            allEscape &= trap.allEscape;
-            anyContinue |= trap.anyContinue;
-            anyBreak |= trap.anyBreak;
+            methodEscape &= catc.methodEscape;
+            loopEscape &= catc.loopEscape;
+            allEscape &= catc.allEscape;
+            anyContinue |= catc.anyContinue;
+            anyBreak |= catc.anyBreak;
 
-            statementCount = Math.max(statementCount, trap.statementCount);
+            statementCount = Math.max(statementCount, catc.statementCount);
         }
 
         this.statementCount = block.statementCount + statementCount;
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        final Label begin = new Label();
-        final Label end = new Label();
-        final Label exception = new Label();
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        Label begin = new Label();
+        Label end = new Label();
+        Label exception = new Label();
 
-        adapter.mark(begin);
+        writer.mark(begin);
 
         block.continu = continu;
         block.brake = brake;
-        block.write(adapter);
+        block.write(writer);
 
         if (!block.allEscape) {
-            adapter.goTo(exception);
+            writer.goTo(exception);
         }
 
-        adapter.mark(end);
+        writer.mark(end);
 
-        for (final STrap trap : traps) {
-            trap.begin = begin;
-            trap.end = end;
-            trap.exception = traps.size() > 1 ? exception : null;
-            trap.write(adapter);
+        for (SCatch catc : catches) {
+            catc.begin = begin;
+            catc.end = end;
+            catc.exception = catches.size() > 1 ? exception : null;
+            catc.write(writer);
         }
 
-        if (!block.allEscape || traps.size() > 1) {
-            adapter.mark(exception);
+        if (!block.allEscape || catches.size() > 1) {
+            writer.mark(exception);
         }
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SWhile.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SWhile.java
index 48f59c55189c..322ae110f660 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SWhile.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SWhile.java
@@ -29,16 +29,16 @@
  */
 public final class SWhile extends AStatement {
 
-    AExpression condition;
-    final AStatement block;
     final int maxLoopCounter;
+    AExpression condition;
+    final SBlock block;
 
-    public SWhile(int line, String location, AExpression condition, AStatement block, int maxLoopCounter) {
-        super(line, location);
+    public SWhile(int line, int offset, String location, int maxLoopCounter, AExpression condition, SBlock block) {
+        super(line, offset, location);
 
+        this.maxLoopCounter = maxLoopCounter;
         this.condition = condition;
         this.block = block;
-        this.maxLoopCounter = maxLoopCounter;
     }
 
     @Override
@@ -63,8 +63,6 @@ void analyze(Variables variables) {
             }
         }
 
-        int count = 1;
-
         if (block != null) {
             block.beginLoop = true;
             block.inLoop = true;
@@ -72,7 +70,7 @@ void analyze(Variables variables) {
             block.analyze(variables);
 
             if (block.loopEscape && !block.anyContinue) {
-                throw new IllegalArgumentException(error("Extranous while loop."));
+                throw new IllegalArgumentException(error("Extraneous while loop."));
             }
 
             if (continuous && !block.anyBreak) {
@@ -80,7 +78,7 @@ void analyze(Variables variables) {
                 allEscape = true;
             }
 
-            block.statementCount = Math.max(count, block.statementCount);
+            block.statementCount = Math.max(1, block.statementCount);
         }
 
         statementCount = 1;
@@ -93,30 +91,31 @@ void analyze(Variables variables) {
     }
 
     @Override
-    void write(MethodWriter adapter) {
-        writeDebugInfo(adapter);
-        final Label begin = new Label();
-        final Label end = new Label();
+    void write(MethodWriter writer) {
+        writeDebugInfo(writer);
+
+        Label begin = new Label();
+        Label end = new Label();
 
-        adapter.mark(begin);
+        writer.mark(begin);
 
         condition.fals = end;
-        condition.write(adapter);
+        condition.write(writer);
 
         if (block != null) {
-            adapter.writeLoopCounter(loopCounterSlot, Math.max(1, block.statementCount));
+            writer.writeLoopCounter(loopCounterSlot, Math.max(1, block.statementCount));
 
             block.continu = begin;
             block.brake = end;
-            block.write(adapter);
+            block.write(writer);
         } else {
-            adapter.writeLoopCounter(loopCounterSlot, 1);
+            writer.writeLoopCounter(loopCounterSlot, 1);
         }
 
         if (block == null || !block.allEscape) {
-            adapter.goTo(begin);
+            writer.goTo(begin);
         }
 
-        adapter.mark(end);
+        writer.mark(end);
     }
 }
diff --git a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/package-info.java b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/package-info.java
index 0d4e993b39bb..47aa868d6dc9 100644
--- a/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/package-info.java
+++ b/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/package-info.java
@@ -59,21 +59,23 @@
  * {@link org.elasticsearch.painless.node.LNewArray} - Represents an array instantiation.
  * {@link org.elasticsearch.painless.node.LNewObj} - Respresents and object instantiation.
  * {@link org.elasticsearch.painless.node.LShortcut} - Represents a field load/store shortcut.  (Internal only.)
+ * {@link org.elasticsearch.painless.node.LStatic} - Represents a static type target.
  * {@link org.elasticsearch.painless.node.LString} - Represents a string constant.
  * {@link org.elasticsearch.painless.node.LVariable} - Represents a variable load/store.
  * {@link org.elasticsearch.painless.node.SBlock} - Represents a set of statements as a branch of control-flow.
  * {@link org.elasticsearch.painless.node.SBreak} - Represents a break statement.
+ * {@link org.elasticsearch.painless.node.SCatch} - Represents a catch block as part of a try-catch block.
  * {@link org.elasticsearch.painless.node.SContinue} - Represents a continue statement.
  * {@link org.elasticsearch.painless.node.SDeclaration} - Represents a single variable declaration.
  * {@link org.elasticsearch.painless.node.SDeclBlock} - Represents a series of declarations.
  * {@link org.elasticsearch.painless.node.SDo} - Represents a do-while loop.
  * {@link org.elasticsearch.painless.node.SExpression} - Represents the top-level node for an expression as a statement.
  * {@link org.elasticsearch.painless.node.SFor} - Represents a for loop.
+ * {@link org.elasticsearch.painless.node.SIf} - Represents an if block.
  * {@link org.elasticsearch.painless.node.SIfElse} - Represents an if/else block.
  * {@link org.elasticsearch.painless.node.SReturn} - Represents a return statement.
  * {@link org.elasticsearch.painless.node.SSource} - The root of all Painless trees.  Contains a series of statements.
  * {@link org.elasticsearch.painless.node.SThrow} - Represents a throw statement.
- * {@link org.elasticsearch.painless.node.STrap} - Represents a catch block as part of a try-catch block.
  * {@link org.elasticsearch.painless.node.STry} - Represents the try block as part of a try-catch block.
  * {@link org.elasticsearch.painless.node.SWhile} - Represents a while loop.
  * <p>
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/NoSemiColonTests.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/NoSemiColonTests.java
index e4af7a2d1668..c57a756f1096 100644
--- a/modules/lang-painless/src/test/java/org/elasticsearch/painless/NoSemiColonTests.java
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/NoSemiColonTests.java
@@ -59,7 +59,7 @@ public void testDeclarationStatement() {
         assertEquals(String[][].class, exec("String[][] a = new String[1][2]; return a").getClass());
         assertEquals(Map[][][].class, exec("Map[][][] a = new Map[1][2][3]; return a").getClass());
     }
-    
+
     public void testExpression() {
         assertEquals(10, exec("10"));
         assertEquals(10, exec("5 + 5"));
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/ScriptTestCase.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/ScriptTestCase.java
index c3ce127034e4..d95fa3897dac 100644
--- a/modules/lang-painless/src/test/java/org/elasticsearch/painless/ScriptTestCase.java
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/ScriptTestCase.java
@@ -26,6 +26,7 @@
 import org.junit.Before;
 
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.Map;
 
 /**
@@ -48,7 +49,9 @@ public Object exec(String script) {
 
     /** Compiles and returns the result of {@code script} with access to {@code vars} */
     public Object exec(String script, Map<String, Object> vars) {
-        return exec(script, vars, Collections.emptyMap());
+        Map<String,String> compilerSettings = new HashMap<>();
+        compilerSettings.put(CompilerSettings.PICKY, "true");
+        return exec(script, vars, compilerSettings);
     }
 
     /** Compiles and returns the result of {@code script} with access to {@code vars} and compile-time parameters */
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/WhenThingsGoWrongTests.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/WhenThingsGoWrongTests.java
index 15ae321534e3..9cdce7583f54 100644
--- a/modules/lang-painless/src/test/java/org/elasticsearch/painless/WhenThingsGoWrongTests.java
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/WhenThingsGoWrongTests.java
@@ -52,13 +52,13 @@ public void testLineNumbers() {
                  "return y.isEmpty();");
         });
         assertEquals(3, exception.getStackTrace()[0].getLineNumber());
-        
+
         // trigger NPE at line 4 in script (inside conditional)
         exception = expectThrows(NullPointerException.class, () -> {
             exec("String x = null;\n" +
                  "boolean y = false;\n" +
                  "if (!y) {\n" +
-                 "  y = x.isEmpty();\n" + 
+                 "  y = x.isEmpty();\n" +
                  "}\n" +
                  "return y;");
         });
@@ -133,7 +133,7 @@ public void testInfiniteLoops() {
             exec("try { int x; } catch (PainlessError error) {}");
             fail("should have hit ParseException");
         });
-        assertTrue(parseException.getMessage().contains("Not a type [PainlessError]."));
+        assertTrue(parseException.getMessage().contains("unexpected token ['PainlessError']"));
     }
 
     public void testLoopLimits() {
diff --git a/modules/lang-painless/src/test/java/org/elasticsearch/painless/antlr/ParserTests.java b/modules/lang-painless/src/test/java/org/elasticsearch/painless/antlr/ParserTests.java
new file mode 100644
index 000000000000..aedecfc9c91d
--- /dev/null
+++ b/modules/lang-painless/src/test/java/org/elasticsearch/painless/antlr/ParserTests.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed to Elasticsearch under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.elasticsearch.painless.antlr;
+
+import org.antlr.v4.runtime.ANTLRInputStream;
+import org.antlr.v4.runtime.BaseErrorListener;
+import org.antlr.v4.runtime.CommonTokenStream;
+import org.antlr.v4.runtime.DiagnosticErrorListener;
+import org.antlr.v4.runtime.RecognitionException;
+import org.antlr.v4.runtime.Recognizer;
+import org.antlr.v4.runtime.atn.PredictionMode;
+import org.elasticsearch.painless.antlr.PainlessParser.SourceContext;
+import org.elasticsearch.painless.ScriptTestCase;
+
+import java.text.ParseException;
+
+public class ParserTests extends ScriptTestCase {
+    private static class TestException extends RuntimeException {
+        TestException(String msg) {
+            super(msg);
+        }
+    }
+
+    private SourceContext buildAntlrTree(String source) {
+        ANTLRInputStream stream = new ANTLRInputStream(source);
+        PainlessLexer lexer = new ErrorHandlingLexer(stream);
+        PainlessParser parser = new PainlessParser(new CommonTokenStream(lexer));
+        ParserErrorStrategy strategy = new ParserErrorStrategy();
+
+        lexer.removeErrorListeners();
+        parser.removeErrorListeners();
+
+        // Diagnostic listener invokes syntaxError on other listeners for ambiguity issues,
+        parser.addErrorListener(new DiagnosticErrorListener(true));
+        // a second listener to fail the test when the above happens.
+        parser.addErrorListener(new BaseErrorListener() {
+            @Override
+            public void syntaxError(final Recognizer<?, ?> recognizer, final Object offendingSymbol, final int line,
+                                    final int charPositionInLine, final String msg, final RecognitionException e) {
+                throw new TestException("line: " + line + ", offset: " + charPositionInLine +
+                    ", symbol:" + offendingSymbol + " " + msg);
+            }
+        });
+
+        // Enable exact ambiguity detection (costly). we enable exact since its the default for
+        // DiagnosticErrorListener, life is too short to think about what 'inexact ambiguity' might mean.
+        parser.getInterpreter().setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);
+        parser.setErrorHandler(strategy);
+
+        return parser.source();
+    }
+
+    public void testIllegalSecondary() {
+        //TODO: Need way more corner case tests.
+        Exception exception = expectThrows(TestException.class, () -> buildAntlrTree("(x = 5).y"));
+        assertTrue(exception.getMessage().contains("no viable alternative"));
+        exception = expectThrows(TestException.class, () -> buildAntlrTree("((x = 5).y = 2).z;"));
+        assertTrue(exception.getMessage().contains("no viable alternative"));
+        exception = expectThrows(TestException.class, () -> buildAntlrTree("(2 + 2).z"));
+        assertTrue(exception.getMessage().contains("no viable alternative"));
+        exception = expectThrows(RuntimeException.class, () -> buildAntlrTree("((Map)x.-x)"));
+        assertTrue(exception.getMessage().contains("unexpected character"));
+    }
+}
