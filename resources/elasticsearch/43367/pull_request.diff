diff --git a/libs/geo/src/main/java/org/elasticsearch/geo/geometry/GeometryUtils.java b/libs/geo/src/main/java/org/elasticsearch/geo/geometry/GeometryUtils.java
index 9a7d4b99d3e5..c7bfa16b16a8 100644
--- a/libs/geo/src/main/java/org/elasticsearch/geo/geometry/GeometryUtils.java
+++ b/libs/geo/src/main/java/org/elasticsearch/geo/geometry/GeometryUtils.java
@@ -22,7 +22,7 @@
 /**
  * Geometry-related utility methods
  */
-final class GeometryUtils {
+public final class GeometryUtils {
     /**
      * Minimum longitude value.
      */
@@ -67,4 +67,12 @@ static void checkLongitude(double longitude) {
         }
     }
 
+    public static double checkAltitude(final boolean ignoreZValue, double zValue) {
+        if (ignoreZValue == false) {
+            throw new IllegalArgumentException("found Z value [" + zValue + "] but [ignore_z_value] "
+                + "parameter is [" + ignoreZValue + "]");
+        }
+        return zValue;
+    }
+
 }
diff --git a/libs/geo/src/main/java/org/elasticsearch/geo/utils/WellKnownText.java b/libs/geo/src/main/java/org/elasticsearch/geo/utils/WellKnownText.java
index e1af54e3383e..007bb036cec8 100644
--- a/libs/geo/src/main/java/org/elasticsearch/geo/utils/WellKnownText.java
+++ b/libs/geo/src/main/java/org/elasticsearch/geo/utils/WellKnownText.java
@@ -22,6 +22,7 @@
 import org.elasticsearch.geo.geometry.Circle;
 import org.elasticsearch.geo.geometry.Geometry;
 import org.elasticsearch.geo.geometry.GeometryCollection;
+import org.elasticsearch.geo.geometry.GeometryUtils;
 import org.elasticsearch.geo.geometry.GeometryVisitor;
 import org.elasticsearch.geo.geometry.Line;
 import org.elasticsearch.geo.geometry.LinearRing;
@@ -52,17 +53,25 @@
     public static final String COMMA = ",";
     public static final String NAN = "NaN";
 
-    private static final String NUMBER = "<NUMBER>";
-    private static final String EOF = "END-OF-STREAM";
-    private static final String EOL = "END-OF-LINE";
+    private final String NUMBER = "<NUMBER>";
+    private final String EOF = "END-OF-STREAM";
+    private final String EOL = "END-OF-LINE";
 
-    public static String toWKT(Geometry geometry) {
+    private final boolean coerce;
+    private final boolean ignoreZValue;
+
+    public WellKnownText(boolean coerce, boolean ignoreZValue) {
+        this.coerce = coerce;
+        this.ignoreZValue = ignoreZValue;
+    }
+
+    public String toWKT(Geometry geometry) {
         StringBuilder builder = new StringBuilder();
         toWKT(geometry, builder);
         return builder.toString();
     }
 
-    public static void toWKT(Geometry geometry, StringBuilder sb) {
+    public void toWKT(Geometry geometry, StringBuilder sb) {
         sb.append(getWKTName(geometry));
         sb.append(SPACE);
         if (geometry.isEmpty()) {
@@ -216,7 +225,7 @@ public Void visit(Rectangle rectangle) {
         }
     }
 
-    public static Geometry fromWKT(String wkt) throws IOException, ParseException {
+    public Geometry fromWKT(String wkt) throws IOException, ParseException {
         StringReader reader = new StringReader(wkt);
         try {
             // setup the tokenizer; configured to read words w/o numbers
@@ -243,7 +252,7 @@ public static Geometry fromWKT(String wkt) throws IOException, ParseException {
     /**
      * parse geometry from the stream tokenizer
      */
-    private static Geometry parseGeometry(StreamTokenizer stream) throws IOException, ParseException {
+    private Geometry parseGeometry(StreamTokenizer stream) throws IOException, ParseException {
         final String type = nextWord(stream).toLowerCase(Locale.ROOT);
         switch (type) {
             case "point":
@@ -268,7 +277,7 @@ private static Geometry parseGeometry(StreamTokenizer stream) throws IOException
         throw new IllegalArgumentException("Unknown geometry type: " + type);
     }
 
-    private static GeometryCollection<Geometry> parseGeometryCollection(StreamTokenizer stream) throws IOException, ParseException {
+    private GeometryCollection<Geometry> parseGeometryCollection(StreamTokenizer stream) throws IOException, ParseException {
         if (nextEmptyOrOpen(stream).equals(EMPTY)) {
             return GeometryCollection.EMPTY;
         }
@@ -280,7 +289,7 @@ private static Geometry parseGeometry(StreamTokenizer stream) throws IOException
         return new GeometryCollection<>(shapes);
     }
 
-    private static Point parsePoint(StreamTokenizer stream) throws IOException, ParseException {
+    private Point parsePoint(StreamTokenizer stream) throws IOException, ParseException {
         if (nextEmptyOrOpen(stream).equals(EMPTY)) {
             return Point.EMPTY;
         }
@@ -288,7 +297,7 @@ private static Point parsePoint(StreamTokenizer stream) throws IOException, Pars
         double lat = nextNumber(stream);
         Point pt;
         if (isNumberNext(stream)) {
-            pt = new Point(lat, lon, nextNumber(stream));
+            pt = new Point(lat, lon, GeometryUtils.checkAltitude(ignoreZValue, nextNumber(stream)));
         } else {
             pt = new Point(lat, lon);
         }
@@ -296,7 +305,7 @@ private static Point parsePoint(StreamTokenizer stream) throws IOException, Pars
         return pt;
     }
 
-    private static void parseCoordinates(StreamTokenizer stream, ArrayList<Double> lats, ArrayList<Double> lons, ArrayList<Double> alts)
+    private void parseCoordinates(StreamTokenizer stream, ArrayList<Double> lats, ArrayList<Double> lons, ArrayList<Double> alts)
         throws IOException, ParseException {
         parseCoordinate(stream, lats, lons, alts);
         while (nextCloserOrComma(stream).equals(COMMA)) {
@@ -304,19 +313,19 @@ private static void parseCoordinates(StreamTokenizer stream, ArrayList<Double> l
         }
     }
 
-    private static void parseCoordinate(StreamTokenizer stream, ArrayList<Double> lats, ArrayList<Double> lons, ArrayList<Double> alts)
+    private void parseCoordinate(StreamTokenizer stream, ArrayList<Double> lats, ArrayList<Double> lons, ArrayList<Double> alts)
         throws IOException, ParseException {
         lons.add(nextNumber(stream));
         lats.add(nextNumber(stream));
         if (isNumberNext(stream)) {
-            alts.add(nextNumber(stream));
+            alts.add(GeometryUtils.checkAltitude(ignoreZValue, nextNumber(stream)));
         }
         if (alts.isEmpty() == false && alts.size() != lons.size()) {
             throw new ParseException("coordinate dimensions do not match: " + tokenString(stream), stream.lineno());
         }
     }
 
-    private static MultiPoint parseMultiPoint(StreamTokenizer stream) throws IOException, ParseException {
+    private MultiPoint parseMultiPoint(StreamTokenizer stream) throws IOException, ParseException {
         String token = nextEmptyOrOpen(stream);
         if (token.equals(EMPTY)) {
             return MultiPoint.EMPTY;
@@ -336,7 +345,7 @@ private static MultiPoint parseMultiPoint(StreamTokenizer stream) throws IOExcep
         return new MultiPoint(Collections.unmodifiableList(points));
     }
 
-    private static Line parseLine(StreamTokenizer stream) throws IOException, ParseException {
+    private Line parseLine(StreamTokenizer stream) throws IOException, ParseException {
         String token = nextEmptyOrOpen(stream);
         if (token.equals(EMPTY)) {
             return Line.EMPTY;
@@ -352,7 +361,7 @@ private static Line parseLine(StreamTokenizer stream) throws IOException, ParseE
         }
     }
 
-    private static MultiLine parseMultiLine(StreamTokenizer stream) throws IOException, ParseException {
+    private MultiLine parseMultiLine(StreamTokenizer stream) throws IOException, ParseException {
         String token = nextEmptyOrOpen(stream);
         if (token.equals(EMPTY)) {
             return MultiLine.EMPTY;
@@ -365,12 +374,13 @@ private static MultiLine parseMultiLine(StreamTokenizer stream) throws IOExcepti
         return new MultiLine(Collections.unmodifiableList(lines));
     }
 
-    private static LinearRing parsePolygonHole(StreamTokenizer stream) throws IOException, ParseException {
+    private LinearRing parsePolygonHole(StreamTokenizer stream) throws IOException, ParseException {
         nextOpener(stream);
         ArrayList<Double> lats = new ArrayList<>();
         ArrayList<Double> lons = new ArrayList<>();
         ArrayList<Double> alts = new ArrayList<>();
         parseCoordinates(stream, lats, lons, alts);
+        closeLinearRingIfCoerced(lats, lons, alts);
         if (alts.isEmpty()) {
             return new LinearRing(toArray(lats), toArray(lons));
         } else {
@@ -378,7 +388,7 @@ private static LinearRing parsePolygonHole(StreamTokenizer stream) throws IOExce
         }
     }
 
-    private static Polygon parsePolygon(StreamTokenizer stream) throws IOException, ParseException {
+    private Polygon parsePolygon(StreamTokenizer stream) throws IOException, ParseException {
         if (nextEmptyOrOpen(stream).equals(EMPTY)) {
             return Polygon.EMPTY;
         }
@@ -391,6 +401,7 @@ private static Polygon parsePolygon(StreamTokenizer stream) throws IOException,
         while (nextCloserOrComma(stream).equals(COMMA)) {
             holes.add(parsePolygonHole(stream));
         }
+        closeLinearRingIfCoerced(lats, lons, alts);
         LinearRing shell;
         if (alts.isEmpty()) {
             shell = new LinearRing(toArray(lats), toArray(lons));
@@ -404,7 +415,25 @@ private static Polygon parsePolygon(StreamTokenizer stream) throws IOException,
         }
     }
 
-    private static MultiPolygon parseMultiPolygon(StreamTokenizer stream) throws IOException, ParseException {
+    /**
+     * Treats supplied arrays as coordinates of a linear ring. If the ring is not closed and coerce is set to true,
+     * the first set of coordinates (lat, lon and alt if available) are added to the end of the arrays.
+     */
+    private void closeLinearRingIfCoerced(ArrayList<Double> lats, ArrayList<Double> lons, ArrayList<Double> alts) {
+        if (coerce && lats.isEmpty() == false && lons.isEmpty() == false) {
+            int last = lats.size() - 1;
+            if (!lats.get(0).equals(lats.get(last)) || !lons.get(0).equals(lons.get(last)) ||
+                (alts.isEmpty() == false && !alts.get(0).equals(alts.get(last)))) {
+                lons.add(lons.get(0));
+                lats.add(lats.get(0));
+                if (alts.isEmpty() == false) {
+                    alts.add(alts.get(0));
+                }
+            }
+        }
+    }
+
+    private MultiPolygon parseMultiPolygon(StreamTokenizer stream) throws IOException, ParseException {
         String token = nextEmptyOrOpen(stream);
         if (token.equals(EMPTY)) {
             return MultiPolygon.EMPTY;
@@ -417,7 +446,7 @@ private static MultiPolygon parseMultiPolygon(StreamTokenizer stream) throws IOE
         return new MultiPolygon(Collections.unmodifiableList(polygons));
     }
 
-    private static Rectangle parseBBox(StreamTokenizer stream) throws IOException, ParseException {
+    private Rectangle parseBBox(StreamTokenizer stream) throws IOException, ParseException {
         if (nextEmptyOrOpen(stream).equals(EMPTY)) {
             return Rectangle.EMPTY;
         }
@@ -434,7 +463,7 @@ private static Rectangle parseBBox(StreamTokenizer stream) throws IOException, P
     }
 
 
-    private static Circle parseCircle(StreamTokenizer stream) throws IOException, ParseException {
+    private Circle parseCircle(StreamTokenizer stream) throws IOException, ParseException {
         if (nextEmptyOrOpen(stream).equals(EMPTY)) {
             return Circle.EMPTY;
         }
@@ -453,7 +482,7 @@ private static Circle parseCircle(StreamTokenizer stream) throws IOException, Pa
     /**
      * next word in the stream
      */
-    private static String nextWord(StreamTokenizer stream) throws ParseException, IOException {
+    private String nextWord(StreamTokenizer stream) throws ParseException, IOException {
         switch (stream.nextToken()) {
             case StreamTokenizer.TT_WORD:
                 final String word = stream.sval;
@@ -468,7 +497,7 @@ private static String nextWord(StreamTokenizer stream) throws ParseException, IO
         throw new ParseException("expected word but found: " + tokenString(stream), stream.lineno());
     }
 
-    private static double nextNumber(StreamTokenizer stream) throws IOException, ParseException {
+    private double nextNumber(StreamTokenizer stream) throws IOException, ParseException {
         if (stream.nextToken() == StreamTokenizer.TT_WORD) {
             if (stream.sval.equalsIgnoreCase(NAN)) {
                 return Double.NaN;
@@ -483,7 +512,7 @@ private static double nextNumber(StreamTokenizer stream) throws IOException, Par
         throw new ParseException("expected number but found: " + tokenString(stream), stream.lineno());
     }
 
-    private static String tokenString(StreamTokenizer stream) {
+    private String tokenString(StreamTokenizer stream) {
         switch (stream.ttype) {
             case StreamTokenizer.TT_WORD:
                 return stream.sval;
@@ -497,13 +526,13 @@ private static String tokenString(StreamTokenizer stream) {
         return "'" + (char) stream.ttype + "'";
     }
 
-    private static boolean isNumberNext(StreamTokenizer stream) throws IOException {
+    private boolean isNumberNext(StreamTokenizer stream) throws IOException {
         final int type = stream.nextToken();
         stream.pushBack();
         return type == StreamTokenizer.TT_WORD;
     }
 
-    private static String nextEmptyOrOpen(StreamTokenizer stream) throws IOException, ParseException {
+    private String nextEmptyOrOpen(StreamTokenizer stream) throws IOException, ParseException {
         final String next = nextWord(stream);
         if (next.equals(EMPTY) || next.equals(LPAREN)) {
             return next;
@@ -512,28 +541,28 @@ private static String nextEmptyOrOpen(StreamTokenizer stream) throws IOException
             + " but found: " + tokenString(stream), stream.lineno());
     }
 
-    private static String nextCloser(StreamTokenizer stream) throws IOException, ParseException {
+    private String nextCloser(StreamTokenizer stream) throws IOException, ParseException {
         if (nextWord(stream).equals(RPAREN)) {
             return RPAREN;
         }
         throw new ParseException("expected " + RPAREN + " but found: " + tokenString(stream), stream.lineno());
     }
 
-    private static String nextComma(StreamTokenizer stream) throws IOException, ParseException {
+    private String nextComma(StreamTokenizer stream) throws IOException, ParseException {
         if (nextWord(stream).equals(COMMA) == true) {
             return COMMA;
         }
         throw new ParseException("expected " + COMMA + " but found: " + tokenString(stream), stream.lineno());
     }
 
-    private static String nextOpener(StreamTokenizer stream) throws IOException, ParseException {
+    private String nextOpener(StreamTokenizer stream) throws IOException, ParseException {
         if (nextWord(stream).equals(LPAREN)) {
             return LPAREN;
         }
         throw new ParseException("expected " + LPAREN + " but found: " + tokenString(stream), stream.lineno());
     }
 
-    private static String nextCloserOrComma(StreamTokenizer stream) throws IOException, ParseException {
+    private String nextCloserOrComma(StreamTokenizer stream) throws IOException, ParseException {
         String token = nextWord(stream);
         if (token.equals(COMMA) || token.equals(RPAREN)) {
             return token;
@@ -542,7 +571,7 @@ private static String nextCloserOrComma(StreamTokenizer stream) throws IOExcepti
             + " but found: " + tokenString(stream), stream.lineno());
     }
 
-    public static String getWKTName(Geometry geometry) {
+    private static String getWKTName(Geometry geometry) {
         return geometry.visit(new GeometryVisitor<String, RuntimeException>() {
             @Override
             public String visit(Circle circle) {
@@ -596,7 +625,7 @@ public String visit(Rectangle rectangle) {
         });
     }
 
-    private static double[] toArray(ArrayList<Double> doubles) {
+    private double[] toArray(ArrayList<Double> doubles) {
         return doubles.stream().mapToDouble(i -> i).toArray();
     }
 
diff --git a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/BaseGeometryTestCase.java b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/BaseGeometryTestCase.java
index cc7dcd340c73..47d0f4285ad0 100644
--- a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/BaseGeometryTestCase.java
+++ b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/BaseGeometryTestCase.java
@@ -53,9 +53,10 @@ protected final T createTestInstance() {
     @SuppressWarnings("unchecked")
     @Override
     protected T copyInstance(T instance, Version version) throws IOException {
-        String text = WellKnownText.toWKT(instance);
+        WellKnownText wkt = new WellKnownText(true, true);
+        String text = wkt.toWKT(instance);
         try {
-            return (T) WellKnownText.fromWKT(text);
+            return (T) wkt.fromWKT(text);
         } catch (ParseException e) {
             throw new ElasticsearchException(e);
         }
diff --git a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/CircleTests.java b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/CircleTests.java
index a38a29af24b5..8bad65db616c 100644
--- a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/CircleTests.java
+++ b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/CircleTests.java
@@ -36,14 +36,15 @@ protected Circle createTestInstance(boolean hasAlt) {
     }
 
     public void testBasicSerialization() throws IOException, ParseException {
-        assertEquals("circle (20.0 10.0 15.0)", WellKnownText.toWKT(new Circle(10, 20, 15)));
-        assertEquals(new Circle(10, 20, 15), WellKnownText.fromWKT("circle (20.0 10.0 15.0)"));
+        WellKnownText wkt = new WellKnownText(true, true);
+        assertEquals("circle (20.0 10.0 15.0)", wkt.toWKT(new Circle(10, 20, 15)));
+        assertEquals(new Circle(10, 20, 15), wkt.fromWKT("circle (20.0 10.0 15.0)"));
 
-        assertEquals("circle (20.0 10.0 15.0 25.0)", WellKnownText.toWKT(new Circle(10, 20, 25, 15)));
-        assertEquals(new Circle(10, 20, 25, 15), WellKnownText.fromWKT("circle (20.0 10.0 15.0 25.0)"));
+        assertEquals("circle (20.0 10.0 15.0 25.0)", wkt.toWKT(new Circle(10, 20, 25, 15)));
+        assertEquals(new Circle(10, 20, 25, 15), wkt.fromWKT("circle (20.0 10.0 15.0 25.0)"));
 
-        assertEquals("circle EMPTY", WellKnownText.toWKT(Circle.EMPTY));
-        assertEquals(Circle.EMPTY, WellKnownText.fromWKT("circle EMPTY)"));
+        assertEquals("circle EMPTY", wkt.toWKT(Circle.EMPTY));
+        assertEquals(Circle.EMPTY, wkt.fromWKT("circle EMPTY)"));
     }
 
     public void testInitValidation() {
diff --git a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/GeometryCollectionTests.java b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/GeometryCollectionTests.java
index 8b6415270635..905d0f3c1257 100644
--- a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/GeometryCollectionTests.java
+++ b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/GeometryCollectionTests.java
@@ -35,14 +35,15 @@
 
 
     public void testBasicSerialization() throws IOException, ParseException {
+        WellKnownText wkt = new WellKnownText(true, true);
         assertEquals("geometrycollection (point (20.0 10.0),point EMPTY)",
-            WellKnownText.toWKT(new GeometryCollection<Geometry>(Arrays.asList(new Point(10, 20), Point.EMPTY))));
+            wkt.toWKT(new GeometryCollection<Geometry>(Arrays.asList(new Point(10, 20), Point.EMPTY))));
 
         assertEquals(new GeometryCollection<Geometry>(Arrays.asList(new Point(10, 20), Point.EMPTY)),
-            WellKnownText.fromWKT("geometrycollection (point (20.0 10.0),point EMPTY)"));
+            wkt.fromWKT("geometrycollection (point (20.0 10.0),point EMPTY)"));
 
-        assertEquals("geometrycollection EMPTY", WellKnownText.toWKT(GeometryCollection.EMPTY));
-        assertEquals(GeometryCollection.EMPTY, WellKnownText.fromWKT("geometrycollection EMPTY)"));
+        assertEquals("geometrycollection EMPTY", wkt.toWKT(GeometryCollection.EMPTY));
+        assertEquals(GeometryCollection.EMPTY, wkt.fromWKT("geometrycollection EMPTY)"));
     }
 
     @SuppressWarnings("ConstantConditions")
diff --git a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/LineTests.java b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/LineTests.java
index 7156039f9085..0f59940f973f 100644
--- a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/LineTests.java
+++ b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/LineTests.java
@@ -31,16 +31,17 @@ protected Line createTestInstance(boolean hasAlt) {
     }
 
     public void testBasicSerialization() throws IOException, ParseException {
-        assertEquals("linestring (3.0 1.0, 4.0 2.0)", WellKnownText.toWKT(new Line(new double[]{1, 2}, new double[]{3, 4})));
-        assertEquals(new Line(new double[]{1, 2}, new double[]{3, 4}), WellKnownText.fromWKT("linestring (3 1, 4 2)"));
+        WellKnownText wkt = new WellKnownText(true, true);
+        assertEquals("linestring (3.0 1.0, 4.0 2.0)", wkt.toWKT(new Line(new double[]{1, 2}, new double[]{3, 4})));
+        assertEquals(new Line(new double[]{1, 2}, new double[]{3, 4}), wkt.fromWKT("linestring (3 1, 4 2)"));
 
-        assertEquals("linestring (3.0 1.0 5.0, 4.0 2.0 6.0)", WellKnownText.toWKT(new Line(new double[]{1, 2}, new double[]{3, 4},
+        assertEquals("linestring (3.0 1.0 5.0, 4.0 2.0 6.0)", wkt.toWKT(new Line(new double[]{1, 2}, new double[]{3, 4},
             new double[]{5, 6})));
         assertEquals(new Line(new double[]{1, 2}, new double[]{3, 4}, new double[]{6, 5}),
-            WellKnownText.fromWKT("linestring (3 1 6, 4 2 5)"));
+            wkt.fromWKT("linestring (3 1 6, 4 2 5)"));
 
-        assertEquals("linestring EMPTY", WellKnownText.toWKT(Line.EMPTY));
-        assertEquals(Line.EMPTY, WellKnownText.fromWKT("linestring EMPTY)"));
+        assertEquals("linestring EMPTY", wkt.toWKT(Line.EMPTY));
+        assertEquals(Line.EMPTY, wkt.fromWKT("linestring EMPTY)"));
     }
 
     public void testInitValidation() {
@@ -53,4 +54,10 @@ public void testInitValidation() {
         ex = expectThrows(IllegalArgumentException.class, () -> new Line(new double[]{1, 100, 3, 1}, new double[]{3, 4, 5, 3}));
         assertEquals("invalid latitude 100.0; must be between -90.0 and 90.0", ex.getMessage());
     }
+
+    public void testWKTValidation() {
+        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,
+            () -> new WellKnownText(randomBoolean(), false).fromWKT("linestring (3 1 6, 4 2 5)"));
+        assertEquals("found Z value [6.0] but [ignore_z_value] parameter is [false]", ex.getMessage());
+    }
 }
diff --git a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/LinearRingTests.java b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/LinearRingTests.java
index d5b708f558ca..9327e2046d5f 100644
--- a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/LinearRingTests.java
+++ b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/LinearRingTests.java
@@ -26,7 +26,7 @@
 
     public void testBasicSerialization() {
         UnsupportedOperationException ex = expectThrows(UnsupportedOperationException.class,
-            () -> WellKnownText.toWKT(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3})));
+            () -> new WellKnownText(true, true).toWKT(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3})));
         assertEquals("line ring cannot be serialized using WKT", ex.getMessage());
     }
 
diff --git a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiLineTests.java b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiLineTests.java
index 3fcb84d93b7d..22e0c4459a3f 100644
--- a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiLineTests.java
+++ b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiLineTests.java
@@ -40,12 +40,13 @@ protected MultiLine createTestInstance(boolean hasAlt) {
     }
 
     public void testBasicSerialization() throws IOException, ParseException {
-        assertEquals("multilinestring ((3.0 1.0, 4.0 2.0))", WellKnownText.toWKT(
+        WellKnownText wkt = new WellKnownText(true, true);
+        assertEquals("multilinestring ((3.0 1.0, 4.0 2.0))", wkt.toWKT(
             new MultiLine(Collections.singletonList(new Line(new double[]{1, 2}, new double[]{3, 4})))));
         assertEquals(new MultiLine(Collections.singletonList(new Line(new double[]{1, 2}, new double[]{3, 4}))),
-            WellKnownText.fromWKT("multilinestring ((3 1, 4 2))"));
+            wkt.fromWKT("multilinestring ((3 1, 4 2))"));
 
-        assertEquals("multilinestring EMPTY", WellKnownText.toWKT(MultiLine.EMPTY));
-        assertEquals(MultiLine.EMPTY, WellKnownText.fromWKT("multilinestring EMPTY)"));
+        assertEquals("multilinestring EMPTY", wkt.toWKT(MultiLine.EMPTY));
+        assertEquals(MultiLine.EMPTY, wkt.fromWKT("multilinestring EMPTY)"));
     }
 }
diff --git a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiPointTests.java b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiPointTests.java
index ecdcc0815a82..d3f8b5738cb9 100644
--- a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiPointTests.java
+++ b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiPointTests.java
@@ -41,22 +41,23 @@ protected MultiPoint createTestInstance(boolean hasAlt) {
     }
 
     public void testBasicSerialization() throws IOException, ParseException {
-        assertEquals("multipoint (2.0 1.0)", WellKnownText.toWKT(
+        WellKnownText wkt = new WellKnownText(true, true);
+        assertEquals("multipoint (2.0 1.0)", wkt.toWKT(
             new MultiPoint(Collections.singletonList(new Point(1, 2)))));
         assertEquals(new MultiPoint(Collections.singletonList(new Point(1 ,2))),
-            WellKnownText.fromWKT("multipoint (2 1)"));
+            wkt.fromWKT("multipoint (2 1)"));
 
         assertEquals("multipoint (2.0 1.0, 3.0 4.0)",
-            WellKnownText.toWKT(new MultiPoint(Arrays.asList(new Point(1, 2), new Point(4, 3)))));
+            wkt.toWKT(new MultiPoint(Arrays.asList(new Point(1, 2), new Point(4, 3)))));
         assertEquals(new MultiPoint(Arrays.asList(new Point(1, 2), new Point(4, 3))),
-            WellKnownText.fromWKT("multipoint (2 1, 3 4)"));
+            wkt.fromWKT("multipoint (2 1, 3 4)"));
 
         assertEquals("multipoint (2.0 1.0 10.0, 3.0 4.0 20.0)",
-            WellKnownText.toWKT(new MultiPoint(Arrays.asList(new Point(1, 2, 10), new Point(4, 3, 20)))));
+            wkt.toWKT(new MultiPoint(Arrays.asList(new Point(1, 2, 10), new Point(4, 3, 20)))));
         assertEquals(new MultiPoint(Arrays.asList(new Point(1, 2, 10), new Point(4, 3, 20))),
-            WellKnownText.fromWKT("multipoint (2 1 10, 3 4 20)"));
+            wkt.fromWKT("multipoint (2 1 10, 3 4 20)"));
 
-        assertEquals("multipoint EMPTY", WellKnownText.toWKT(MultiPoint.EMPTY));
-        assertEquals(MultiPoint.EMPTY, WellKnownText.fromWKT("multipoint EMPTY)"));
+        assertEquals("multipoint EMPTY", wkt.toWKT(MultiPoint.EMPTY));
+        assertEquals(MultiPoint.EMPTY, wkt.fromWKT("multipoint EMPTY)"));
     }
 }
diff --git a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiPolygonTests.java b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiPolygonTests.java
index 1b82cfd3871a..fb4d8821ac3f 100644
--- a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiPolygonTests.java
+++ b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/MultiPolygonTests.java
@@ -40,14 +40,15 @@ protected MultiPolygon createTestInstance(boolean hasAlt) {
     }
 
     public void testBasicSerialization() throws IOException, ParseException {
+        WellKnownText wkt = new WellKnownText(true, true);
         assertEquals("multipolygon (((3.0 1.0, 4.0 2.0, 5.0 3.0, 3.0 1.0)))",
-            WellKnownText.toWKT(new MultiPolygon(Collections.singletonList(
+            wkt.toWKT(new MultiPolygon(Collections.singletonList(
                 new Polygon(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3}))))));
         assertEquals(new MultiPolygon(Collections.singletonList(
             new Polygon(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3})))),
-            WellKnownText.fromWKT("multipolygon (((3.0 1.0, 4.0 2.0, 5.0 3.0, 3.0 1.0)))"));
+            wkt.fromWKT("multipolygon (((3.0 1.0, 4.0 2.0, 5.0 3.0, 3.0 1.0)))"));
 
-        assertEquals("multipolygon EMPTY", WellKnownText.toWKT(MultiPolygon.EMPTY));
-        assertEquals(MultiPolygon.EMPTY, WellKnownText.fromWKT("multipolygon EMPTY)"));
+        assertEquals("multipolygon EMPTY", wkt.toWKT(MultiPolygon.EMPTY));
+        assertEquals(MultiPolygon.EMPTY, wkt.fromWKT("multipolygon EMPTY)"));
     }
 }
diff --git a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/PointTests.java b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/PointTests.java
index d480f44e30a4..4b590a3beb56 100644
--- a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/PointTests.java
+++ b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/PointTests.java
@@ -31,14 +31,15 @@ protected Point createTestInstance(boolean hasAlt) {
     }
 
     public void testBasicSerialization() throws IOException, ParseException {
-        assertEquals("point (20.0 10.0)", WellKnownText.toWKT(new Point(10, 20)));
-        assertEquals(new Point(10, 20), WellKnownText.fromWKT("point (20.0 10.0)"));
+        WellKnownText wkt = new WellKnownText(true, true);
+        assertEquals("point (20.0 10.0)", wkt.toWKT(new Point(10, 20)));
+        assertEquals(new Point(10, 20), wkt.fromWKT("point (20.0 10.0)"));
 
-        assertEquals("point (20.0 10.0 100.0)", WellKnownText.toWKT(new Point(10, 20, 100)));
-        assertEquals(new Point(10, 20, 100), WellKnownText.fromWKT("point (20.0 10.0 100.0)"));
+        assertEquals("point (20.0 10.0 100.0)", wkt.toWKT(new Point(10, 20, 100)));
+        assertEquals(new Point(10, 20, 100), wkt.fromWKT("point (20.0 10.0 100.0)"));
 
-        assertEquals("point EMPTY", WellKnownText.toWKT(Point.EMPTY));
-        assertEquals(Point.EMPTY, WellKnownText.fromWKT("point EMPTY)"));
+        assertEquals("point EMPTY", wkt.toWKT(Point.EMPTY));
+        assertEquals(Point.EMPTY, wkt.fromWKT("point EMPTY)"));
     }
 
     public void testInitValidation() {
@@ -48,4 +49,10 @@ public void testInitValidation() {
         ex = expectThrows(IllegalArgumentException.class, () -> new Point(10, 500));
         assertEquals("invalid longitude 500.0; must be between -180.0 and 180.0", ex.getMessage());
     }
+
+    public void testWKTValidation() {
+        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,
+            () -> new WellKnownText(randomBoolean(), false).fromWKT("point (20.0 10.0 100.0)"));
+        assertEquals("found Z value [100.0] but [ignore_z_value] parameter is [false]", ex.getMessage());
+    }
 }
diff --git a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/PolygonTests.java b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/PolygonTests.java
index fd3032435891..33a5325c87b8 100644
--- a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/PolygonTests.java
+++ b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/PolygonTests.java
@@ -32,18 +32,28 @@ protected Polygon createTestInstance(boolean hasAlt) {
     }
 
     public void testBasicSerialization() throws IOException, ParseException {
+        WellKnownText wkt = new WellKnownText(true, true);
         assertEquals("polygon ((3.0 1.0, 4.0 2.0, 5.0 3.0, 3.0 1.0))",
-            WellKnownText.toWKT(new Polygon(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3}))));
+            wkt.toWKT(new Polygon(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3}))));
         assertEquals(new Polygon(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3})),
-            WellKnownText.fromWKT("polygon ((3 1, 4 2, 5 3, 3 1))"));
+            wkt.fromWKT("polygon ((3 1, 4 2, 5 3, 3 1))"));
 
         assertEquals("polygon ((3.0 1.0 5.0, 4.0 2.0 4.0, 5.0 3.0 3.0, 3.0 1.0 5.0))",
-            WellKnownText.toWKT(new Polygon(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3}, new double[]{5, 4, 3, 5}))));
+            wkt.toWKT(new Polygon(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3}, new double[]{5, 4, 3, 5}))));
         assertEquals(new Polygon(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3}, new double[]{5, 4, 3, 5})),
-            WellKnownText.fromWKT("polygon ((3 1 5, 4 2 4, 5 3 3, 3 1 5))"));
+            wkt.fromWKT("polygon ((3 1 5, 4 2 4, 5 3 3, 3 1 5))"));
 
-        assertEquals("polygon EMPTY", WellKnownText.toWKT(Polygon.EMPTY));
-        assertEquals(Polygon.EMPTY, WellKnownText.fromWKT("polygon EMPTY)"));
+        // Auto closing in coerce mode
+        assertEquals(new Polygon(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3})),
+            wkt.fromWKT("polygon ((3 1, 4 2, 5 3))"));
+        assertEquals(new Polygon(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3}, new double[]{5, 4, 3, 5})),
+            wkt.fromWKT("polygon ((3 1 5, 4 2 4, 5 3 3))"));
+        assertEquals(new Polygon(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3}),
+            Collections.singletonList(new LinearRing(new double[]{1.5, 1.5, 1.0, 1.5}, new double[]{0.5, 2.5, 2.0, 0.5}))),
+            wkt.fromWKT("polygon ((3 1, 4 2, 5 3, 3 1), (0.5 1.5, 2.5 1.5, 2.0 1.0))"));
+
+        assertEquals("polygon EMPTY", wkt.toWKT(Polygon.EMPTY));
+        assertEquals(Polygon.EMPTY, wkt.fromWKT("polygon EMPTY)"));
     }
 
     public void testInitValidation() {
@@ -60,4 +70,20 @@ public void testInitValidation() {
                 Collections.singletonList(new LinearRing(new double[]{1, 2, 3, 1}, new double[]{3, 4, 5, 3}))));
         assertEquals("holes must have the same number of dimensions as the polygon", ex.getMessage());
     }
+
+    public void testWKTValidation() {
+        IllegalArgumentException ex = expectThrows(IllegalArgumentException.class,
+            () -> new WellKnownText(false, true).fromWKT("polygon ((3 1 5, 4 2 4, 5 3 3))"));
+        assertEquals("first and last points of the linear ring must be the same (it must close itself): " +
+            "lats[0]=1.0 lats[2]=3.0 lons[0]=3.0 lons[2]=5.0 alts[0]=5.0 alts[2]=3.0", ex.getMessage());
+
+        ex = expectThrows(IllegalArgumentException.class,
+            () -> new WellKnownText(randomBoolean(), false).fromWKT("polygon ((3 1 5, 4 2 4, 5 3 3, 3 1 5))"));
+        assertEquals("found Z value [5.0] but [ignore_z_value] parameter is [false]", ex.getMessage());
+
+        ex = expectThrows(IllegalArgumentException.class,
+            () -> new WellKnownText(false, randomBoolean()).fromWKT("polygon ((3 1, 4 2, 5 3, 3 1), (0.5 1.5, 2.5 1.5, 2.0 1.0))"));
+        assertEquals("first and last points of the linear ring must be the same (it must close itself): " +
+            "lats[0]=1.5 lats[2]=1.0 lons[0]=0.5 lons[2]=2.0", ex.getMessage());
+    }
 }
diff --git a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/RectangleTests.java b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/RectangleTests.java
index 14cb777f94bb..afbf9f1ae8af 100644
--- a/libs/geo/src/test/java/org/elasticsearch/geo/geometry/RectangleTests.java
+++ b/libs/geo/src/test/java/org/elasticsearch/geo/geometry/RectangleTests.java
@@ -32,11 +32,12 @@ protected Rectangle createTestInstance(boolean hasAlt) {
     }
 
     public void testBasicSerialization() throws IOException, ParseException {
-        assertEquals("bbox (10.0, 20.0, 40.0, 30.0)", WellKnownText.toWKT(new Rectangle(30, 40, 10, 20)));
-        assertEquals(new Rectangle(30, 40, 10, 20), WellKnownText.fromWKT("bbox (10.0, 20.0, 40.0, 30.0)"));
+        WellKnownText wkt = new WellKnownText(true, true);
+        assertEquals("bbox (10.0, 20.0, 40.0, 30.0)", wkt.toWKT(new Rectangle(30, 40, 10, 20)));
+        assertEquals(new Rectangle(30, 40, 10, 20), wkt.fromWKT("bbox (10.0, 20.0, 40.0, 30.0)"));
 
-        assertEquals("bbox EMPTY", WellKnownText.toWKT(Rectangle.EMPTY));
-        assertEquals(Rectangle.EMPTY, WellKnownText.fromWKT("bbox EMPTY)"));
+        assertEquals("bbox EMPTY", wkt.toWKT(Rectangle.EMPTY));
+        assertEquals(Rectangle.EMPTY, wkt.fromWKT("bbox EMPTY)"));
     }
 
     public void testInitValidation() {
diff --git a/server/src/main/java/org/elasticsearch/common/geo/GeoJson.java b/server/src/main/java/org/elasticsearch/common/geo/GeoJson.java
index 9ee869f9ae13..777223106130 100644
--- a/server/src/main/java/org/elasticsearch/common/geo/GeoJson.java
+++ b/server/src/main/java/org/elasticsearch/common/geo/GeoJson.java
@@ -64,14 +64,20 @@
     private static final ParseField FIELD_ORIENTATION = new ParseField("orientation");
     private static final ParseField FIELD_RADIUS = new ParseField("radius");
 
-    private GeoJson() {
-
+    private final boolean rightOrientation;
+    private final boolean coerce;
+    private final boolean ignoreZValue;
+
+    public GeoJson(boolean rightOrientation, boolean coerce, boolean ignoreZValue) {
+        this.rightOrientation = rightOrientation;
+        this.coerce = coerce;
+        this.ignoreZValue = ignoreZValue;
     }
 
-    public static Geometry fromXContent(XContentParser parser, boolean rightOrientation, boolean coerce, boolean ignoreZValue)
+    public Geometry fromXContent(XContentParser parser)
         throws IOException {
         try (XContentSubParser subParser = new XContentSubParser(parser)) {
-            return PARSER.apply(subParser, new ParserContext(rightOrientation, coerce, ignoreZValue));
+            return PARSER.apply(subParser, this);
         }
     }
 
@@ -197,26 +203,14 @@ private XContentBuilder coordinatesToXContent(Polygon polygon) throws IOExceptio
         return builder.endObject();
     }
 
-    private static class ParserContext {
-        public final boolean defaultOrientation;
-        public final boolean coerce;
-        public final boolean ignoreZValue;
-
-        ParserContext(boolean defaultOrientation, boolean coerce, boolean ignoreZValue) {
-            this.defaultOrientation = defaultOrientation;
-            this.coerce = coerce;
-            this.ignoreZValue = ignoreZValue;
-        }
-    }
-
-    private static ConstructingObjectParser<Geometry, ParserContext> PARSER =
+    private static ConstructingObjectParser<Geometry, GeoJson> PARSER =
         new ConstructingObjectParser<>("geojson", true, (a, c) -> {
             String type = (String) a[0];
             CoordinateNode coordinates = (CoordinateNode) a[1];
             @SuppressWarnings("unchecked") List<Geometry> geometries = (List<Geometry>) a[2];
             Boolean orientation = orientationFromString((String) a[3]);
             DistanceUnit.Distance radius = (DistanceUnit.Distance) a[4];
-            return createGeometry(type, geometries, coordinates, orientation, c.defaultOrientation, c.coerce, radius);
+            return createGeometry(type, geometries, coordinates, orientation, c.rightOrientation, c.coerce, radius);
         });
 
     static {
diff --git a/server/src/main/java/org/elasticsearch/common/geo/GeometryParser.java b/server/src/main/java/org/elasticsearch/common/geo/GeometryParser.java
index 8e1db18ccdd9..fe06c3a9c33d 100644
--- a/server/src/main/java/org/elasticsearch/common/geo/GeometryParser.java
+++ b/server/src/main/java/org/elasticsearch/common/geo/GeometryParser.java
@@ -32,22 +32,26 @@
  */
 public final class GeometryParser {
 
-    private GeometryParser() {
+    private final GeoJson geoJsonParser;
+    private final WellKnownText wellKnownTextParser;
 
+    public GeometryParser(boolean rightOrientation, boolean coerce, boolean ignoreZValue) {
+        geoJsonParser = new GeoJson(rightOrientation, coerce, ignoreZValue);
+        wellKnownTextParser = new WellKnownText(coerce, ignoreZValue);
     }
 
     /**
      * Parses supplied XContent into Geometry
      */
-    public static Geometry parse(XContentParser parser, boolean orientation, boolean coerce, boolean ignoreZValue) throws IOException,
+    public Geometry parse(XContentParser parser) throws IOException,
         ParseException {
         if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {
             return null;
         } else if (parser.currentToken() == XContentParser.Token.START_OBJECT) {
-            return GeoJson.fromXContent(parser, orientation, coerce, ignoreZValue);
+            return geoJsonParser.fromXContent(parser);
         } else if (parser.currentToken() == XContentParser.Token.VALUE_STRING) {
             // TODO: Add support for ignoreZValue and coerce to WKT
-            return WellKnownText.fromWKT(parser.text());
+            return wellKnownTextParser.fromWKT(parser.text());
         }
         throw new ElasticsearchParseException("shape must be an object consisting of type and coordinates");
     }
diff --git a/server/src/test/java/org/elasticsearch/common/geo/BaseGeoParsingTestCase.java b/server/src/test/java/org/elasticsearch/common/geo/BaseGeoParsingTestCase.java
index 7f6c56855ec7..d19f7934c656 100644
--- a/server/src/test/java/org/elasticsearch/common/geo/BaseGeoParsingTestCase.java
+++ b/server/src/test/java/org/elasticsearch/common/geo/BaseGeoParsingTestCase.java
@@ -70,7 +70,7 @@ protected void assertGeometryEquals(Object expected, XContentBuilder geoJson, bo
     protected void assertGeometryEquals(org.elasticsearch.geo.geometry.Geometry expected, XContentBuilder geoJson) throws IOException {
         try (XContentParser parser = createParser(geoJson)) {
             parser.nextToken();
-            assertEquals(expected, GeoJson.fromXContent(parser, true, false, false));
+            assertEquals(expected, new GeoJson(true, false, false).fromXContent(parser));
         }
     }
 
diff --git a/server/src/test/java/org/elasticsearch/common/geo/GeoJsonParserTests.java b/server/src/test/java/org/elasticsearch/common/geo/GeoJsonParserTests.java
index 4e2c2e50e2cf..e095c7e381a8 100644
--- a/server/src/test/java/org/elasticsearch/common/geo/GeoJsonParserTests.java
+++ b/server/src/test/java/org/elasticsearch/common/geo/GeoJsonParserTests.java
@@ -72,7 +72,7 @@ public void testParseLineString() throws IOException {
         Line expected = new Line(new double[] {0.0, 1.0}, new double[] { 100.0, 101.0});
         try (XContentParser parser = createParser(lineGeoJson)) {
             parser.nextToken();
-            assertEquals(expected, GeoJson.fromXContent(parser, false, false, true));
+            assertEquals(expected, new GeoJson(false, false, true).fromXContent(parser));
         }
     }
 
@@ -124,7 +124,7 @@ public void testParseMultiDimensionShapes() throws IOException {
 
         try (XContentParser parser = createParser(pointGeoJson)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, false, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(false, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -140,7 +140,7 @@ public void testParseMultiDimensionShapes() throws IOException {
 
         try (XContentParser parser = createParser(lineGeoJson)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, false, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(false, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
     }
@@ -178,7 +178,7 @@ public void testParseEnvelope() throws IOException {
                 .endObject();
         try (XContentParser parser = createParser(multilinesGeoJson)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, false, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(false, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -189,7 +189,7 @@ public void testParseEnvelope() throws IOException {
                 .endObject();
         try (XContentParser parser = createParser(multilinesGeoJson)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, false, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(false, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
     }
@@ -239,7 +239,7 @@ public void testParse3DPolygon() throws IOException {
         ));
         try (XContentParser parser = createParser(polygonGeoJson)) {
             parser.nextToken();
-            assertEquals(expected, GeoJson.fromXContent(parser, true, false, true));
+            assertEquals(expected, new GeoJson(true, false, true).fromXContent(parser));
         }
     }
 
@@ -259,7 +259,7 @@ public void testInvalidDimensionalPolygon() throws IOException {
             .endObject();
         try (XContentParser parser = createParser(polygonGeoJson)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, true));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, true).fromXContent(parser));
             assertNull(parser.nextToken());
         }
     }
@@ -275,7 +275,7 @@ public void testParseInvalidPoint() throws IOException {
                 .endObject();
         try (XContentParser parser = createParser(invalidPoint1)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -288,7 +288,7 @@ public void testParseInvalidPoint() throws IOException {
                 .endObject();
         try (XContentParser parser = createParser(invalidPoint2)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
     }
@@ -302,7 +302,7 @@ public void testParseInvalidMultipoint() throws IOException {
                 .endObject();
         try (XContentParser parser = createParser(invalidMultipoint1)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -315,7 +315,7 @@ public void testParseInvalidMultipoint() throws IOException {
                 .endObject();
         try (XContentParser parser = createParser(invalidMultipoint2)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -329,7 +329,7 @@ public void testParseInvalidMultipoint() throws IOException {
                 .endObject();
         try (XContentParser parser = createParser(invalidMultipoint3)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
     }
@@ -370,7 +370,7 @@ public void testParseInvalidDimensionalMultiPolygon() throws IOException {
 
         try (XContentParser parser = createParser(JsonXContent.jsonXContent, multiPolygonGeoJson)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
    }
@@ -391,7 +391,7 @@ public void testParseInvalidPolygon() throws IOException {
                 .endObject());
         try (XContentParser parser = createParser(JsonXContent.jsonXContent, invalidPoly)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -406,7 +406,7 @@ public void testParseInvalidPolygon() throws IOException {
 
         try (XContentParser parser = createParser(JsonXContent.jsonXContent, invalidPoly)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -421,7 +421,7 @@ public void testParseInvalidPolygon() throws IOException {
 
         try (XContentParser parser = createParser(JsonXContent.jsonXContent, invalidPoly)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -436,7 +436,7 @@ public void testParseInvalidPolygon() throws IOException {
 
         try (XContentParser parser = createParser(JsonXContent.jsonXContent, invalidPoly)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -449,7 +449,7 @@ public void testParseInvalidPolygon() throws IOException {
 
         try (XContentParser parser = createParser(JsonXContent.jsonXContent, invalidPoly)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -460,7 +460,7 @@ public void testParseInvalidPolygon() throws IOException {
 
         try (XContentParser parser = createParser(JsonXContent.jsonXContent, invalidPoly)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -473,7 +473,7 @@ public void testParseInvalidPolygon() throws IOException {
 
         try (XContentParser parser = createParser(JsonXContent.jsonXContent, invalidPoly)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
     }
@@ -710,7 +710,7 @@ public void testParseInvalidShapes() throws IOException {
 
         try (XContentParser parser = createParser(tooLittlePointGeoJson)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
 
@@ -723,7 +723,7 @@ public void testParseInvalidShapes() throws IOException {
 
         try (XContentParser parser = createParser(emptyPointGeoJson)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertNull(parser.nextToken());
         }
     }
@@ -749,7 +749,7 @@ public void testParseInvalidGeometryCollectionShapes() throws IOException {
             parser.nextToken(); // foo
             parser.nextToken(); // start object
             parser.nextToken(); // start object
-            expectThrows(XContentParseException.class, () -> GeoJson.fromXContent(parser, true, false, false));
+            expectThrows(XContentParseException.class, () -> new GeoJson(true, false, false).fromXContent(parser));
             assertEquals(XContentParser.Token.END_OBJECT, parser.nextToken()); // end of the document
             assertNull(parser.nextToken()); // no more elements afterwards
         }
diff --git a/server/src/test/java/org/elasticsearch/common/geo/GeoJsonSerializationTests.java b/server/src/test/java/org/elasticsearch/common/geo/GeoJsonSerializationTests.java
index ab6e3242654f..b0ee969119c1 100644
--- a/server/src/test/java/org/elasticsearch/common/geo/GeoJsonSerializationTests.java
+++ b/server/src/test/java/org/elasticsearch/common/geo/GeoJsonSerializationTests.java
@@ -49,6 +49,7 @@
     private static class GeometryWrapper implements ToXContentObject {
 
         private Geometry geometry;
+        private static GeoJson PARSER = new GeoJson(true, false, true);
 
         GeometryWrapper(Geometry geometry) {
             this.geometry = geometry;
@@ -61,7 +62,7 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws
 
         public static GeometryWrapper fromXContent(XContentParser parser) throws IOException {
             parser.nextToken();
-            return new GeometryWrapper(GeoJson.fromXContent(parser, true, false, true));
+            return new GeometryWrapper(PARSER.fromXContent(parser));
         }
 
         @Override
diff --git a/server/src/test/java/org/elasticsearch/common/geo/GeometryParserTests.java b/server/src/test/java/org/elasticsearch/common/geo/GeometryParserTests.java
index 24ba7780cefd..0d2b182741fc 100644
--- a/server/src/test/java/org/elasticsearch/common/geo/GeometryParserTests.java
+++ b/server/src/test/java/org/elasticsearch/common/geo/GeometryParserTests.java
@@ -44,7 +44,7 @@ public void testGeoJsonParsing() throws Exception {
 
         try (XContentParser parser = createParser(pointGeoJson)) {
             parser.nextToken();
-            assertEquals(new Point(0, 100), GeometryParser.parse(parser, true, randomBoolean(), randomBoolean()));
+            assertEquals(new Point(0, 100), new GeometryParser(true, randomBoolean(), randomBoolean()).parse(parser));
         }
 
         XContentBuilder pointGeoJsonWithZ = XContentFactory.jsonBuilder()
@@ -55,13 +55,13 @@ public void testGeoJsonParsing() throws Exception {
 
         try (XContentParser parser = createParser(pointGeoJsonWithZ)) {
             parser.nextToken();
-            assertEquals(new Point(0, 100, 10.0), GeometryParser.parse(parser, true, randomBoolean(), true));
+            assertEquals(new Point(0, 100, 10.0), new GeometryParser(true, randomBoolean(), true).parse(parser));
         }
 
 
         try (XContentParser parser = createParser(pointGeoJsonWithZ)) {
             parser.nextToken();
-            expectThrows(XContentParseException.class, () -> GeometryParser.parse(parser, true, randomBoolean(), false));
+            expectThrows(XContentParseException.class, () -> new GeometryParser(true, randomBoolean(), false).parse(parser));
         }
 
         XContentBuilder polygonGeoJson = XContentFactory.jsonBuilder()
@@ -81,13 +81,13 @@ public void testGeoJsonParsing() throws Exception {
         try (XContentParser parser = createParser(polygonGeoJson)) {
             parser.nextToken();
             // Coerce should automatically close the polygon
-            assertEquals(p, GeometryParser.parse(parser, true, true, randomBoolean()));
+            assertEquals(p, new GeometryParser(true, true, randomBoolean()).parse(parser));
         }
 
         try (XContentParser parser = createParser(polygonGeoJson)) {
             parser.nextToken();
             // No coerce - the polygon parsing should fail
-            expectThrows(XContentParseException.class, () -> GeometryParser.parse(parser, true, false, randomBoolean()));
+            expectThrows(XContentParseException.class, () -> new GeometryParser(true, false, randomBoolean()).parse(parser));
         }
     }
 
@@ -101,7 +101,7 @@ public void testWKTParsing() throws Exception {
             parser.nextToken(); // Start object
             parser.nextToken(); // Field Name
             parser.nextToken(); // Field Value
-            assertEquals(new Point(0, 100), GeometryParser.parse(parser, true, randomBoolean(), randomBoolean()));
+            assertEquals(new Point(0, 100), new GeometryParser(true, randomBoolean(), randomBoolean()).parse(parser));
         }
     }
 
@@ -115,7 +115,7 @@ public void testNullParsing() throws Exception {
             parser.nextToken(); // Start object
             parser.nextToken(); // Field Name
             parser.nextToken(); // Field Value
-            assertNull(GeometryParser.parse(parser, true, randomBoolean(), randomBoolean()));
+            assertNull(new GeometryParser(true, randomBoolean(), randomBoolean()).parse(parser));
         }
     }
 
@@ -130,7 +130,7 @@ public void testUnsupportedValueParsing() throws Exception {
             parser.nextToken(); // Field Name
             parser.nextToken(); // Field Value
             ElasticsearchParseException ex = expectThrows(ElasticsearchParseException.class,
-                () -> GeometryParser.parse(parser, true, randomBoolean(), randomBoolean()));
+                () -> new GeometryParser(true, randomBoolean(), randomBoolean()).parse(parser));
             assertEquals("shape must be an object consisting of type and coordinates", ex.getMessage());
         }
     }
diff --git a/x-pack/plugin/sql/jdbc/src/main/java/org/elasticsearch/xpack/sql/jdbc/TypeConverter.java b/x-pack/plugin/sql/jdbc/src/main/java/org/elasticsearch/xpack/sql/jdbc/TypeConverter.java
index 7e21f2206b1e..bb66a1041893 100644
--- a/x-pack/plugin/sql/jdbc/src/main/java/org/elasticsearch/xpack/sql/jdbc/TypeConverter.java
+++ b/x-pack/plugin/sql/jdbc/src/main/java/org/elasticsearch/xpack/sql/jdbc/TypeConverter.java
@@ -54,6 +54,8 @@
  */
 final class TypeConverter {
 
+    private static WellKnownText WKT = new WellKnownText(true, true);
+
     private TypeConverter() {}
 
     /**
@@ -246,7 +248,7 @@ static Object convert(Object v, EsType columnType, String typeString) throws SQL
             case GEO_POINT:
             case GEO_SHAPE:
                 try {
-                    return WellKnownText.fromWKT(v.toString());
+                    return WKT.fromWKT(v.toString());
                 } catch (IOException | ParseException ex) {
                     throw new SQLException("Cannot parse geo_shape", ex);
                 }
diff --git a/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/JdbcAssert.java b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/JdbcAssert.java
index 76894fc5a53d..47a14e180fd1 100644
--- a/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/JdbcAssert.java
+++ b/x-pack/plugin/sql/qa/src/main/java/org/elasticsearch/xpack/sql/qa/jdbc/JdbcAssert.java
@@ -51,6 +51,8 @@
 
     private static final IntObjectHashMap<EsType> SQL_TO_TYPE = new IntObjectHashMap<>();
 
+    private static final WellKnownText WKT = new WellKnownText(true, true);
+
     static {
         for (EsType type : EsType.values()) {
             SQL_TO_TYPE.putIfAbsent(type.getVendorTypeNumber().intValue(), type);
@@ -270,7 +272,7 @@ else if (type == Types.DOUBLE) {
                         if (actualObject instanceof Geometry) {
                             // We need to convert the expected object to libs/geo Geometry for comparision
                             try {
-                                expectedObject = WellKnownText.fromWKT(expectedObject.toString());
+                                expectedObject = WKT.fromWKT(expectedObject.toString());
                             } catch (IOException | ParseException ex) {
                                 fail(ex.getMessage());
                             }
diff --git a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/geo/GeoShape.java b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/geo/GeoShape.java
index 74b5c9646b85..f9a025ea4f09 100644
--- a/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/geo/GeoShape.java
+++ b/x-pack/plugin/sql/src/main/java/org/elasticsearch/xpack/sql/expression/function/scalar/geo/GeoShape.java
@@ -49,6 +49,10 @@
 
     private final Geometry shape;
 
+    private static final GeometryParser GEOMETRY_PARSER = new GeometryParser(true, true, true);
+
+    private static final WellKnownText WKT_PARSER = new WellKnownText(true, true);
+
     public GeoShape(double lon, double lat) {
         shape = new Point(lat, lon);
     }
@@ -72,17 +76,17 @@ public GeoShape(StreamInput in) throws IOException {
 
     @Override
     public void writeTo(StreamOutput out) throws IOException {
-        out.writeString(WellKnownText.toWKT(shape));
+        out.writeString(WKT_PARSER.toWKT(shape));
     }
 
     @Override
     public String toString() {
-        return WellKnownText.toWKT(shape);
+        return WKT_PARSER.toWKT(shape);
     }
 
     @Override
     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
-        return builder.value(WellKnownText.toWKT(shape));
+        return builder.value(WKT_PARSER.toWKT(shape));
     }
 
     public Geometry toGeometry() {
@@ -216,7 +220,7 @@ private static Geometry parse(Object value) throws IOException, ParseException {
             parser.nextToken(); // start object
             parser.nextToken(); // field name
             parser.nextToken(); // field value
-            return GeometryParser.parse(parser, true, true, true);
+            return GEOMETRY_PARSER.parse(parser);
         }
     }
 }
diff --git a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/geo/StWkttosqlProcessorTests.java b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/geo/StWkttosqlProcessorTests.java
index fc7b33ae905d..818897dce343 100644
--- a/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/geo/StWkttosqlProcessorTests.java
+++ b/x-pack/plugin/sql/src/test/java/org/elasticsearch/xpack/sql/expression/function/scalar/geo/StWkttosqlProcessorTests.java
@@ -39,4 +39,13 @@ public void testTypeCheck() {
         siae = expectThrows(SqlIllegalArgumentException.class, () -> procPoint.process("point (10 10"));
         assertEquals("Cannot parse [point (10 10] as a geo_shape value", siae.getMessage());
     }
+
+    public void testCoerce() {
+        StWkttosqlProcessor proc = new StWkttosqlProcessor();
+        assertNull(proc.process(null));
+        Object result = proc.process("POLYGON ((3 1 5, 4 2 4, 5 3 3))");
+        assertThat(result, instanceOf(GeoShape.class));
+        GeoShape geoShape = (GeoShape) result;
+        assertEquals("polygon ((3.0 1.0 5.0, 4.0 2.0 4.0, 5.0 3.0 3.0, 3.0 1.0 5.0))", geoShape.toString());
+    }
 }
