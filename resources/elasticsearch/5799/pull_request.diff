diff --git a/src/main/java/org/elasticsearch/action/deletebyquery/TransportShardDeleteByQueryAction.java b/src/main/java/org/elasticsearch/action/deletebyquery/TransportShardDeleteByQueryAction.java
index 5e930dfe8853..b9074c4ba1cd 100644
--- a/src/main/java/org/elasticsearch/action/deletebyquery/TransportShardDeleteByQueryAction.java
+++ b/src/main/java/org/elasticsearch/action/deletebyquery/TransportShardDeleteByQueryAction.java
@@ -125,7 +125,7 @@ protected ClusterBlockException checkRequestBlock(ClusterState state, ShardDelet
             indexShard.deleteByQuery(deleteByQuery);
         } finally {
             SearchContext searchContext = SearchContext.current();
-            searchContext.clearAndRelease();
+            searchContext.release();
             SearchContext.removeCurrent();
         }
         return new PrimaryResponse<>(shardRequest.request, new ShardDeleteByQueryResponse(), null);
@@ -148,7 +148,7 @@ protected void shardOperationOnReplica(ReplicaOperationRequest shardRequest) {
             indexShard.deleteByQuery(deleteByQuery);
         } finally {
             SearchContext searchContext = SearchContext.current();
-            searchContext.clearAndRelease();
+            searchContext.release();
             SearchContext.removeCurrent();
         }
     }
diff --git a/src/main/java/org/elasticsearch/index/search/child/ChildrenConstantScoreQuery.java b/src/main/java/org/elasticsearch/index/search/child/ChildrenConstantScoreQuery.java
index 2475531573e9..018ca461e022 100644
--- a/src/main/java/org/elasticsearch/index/search/child/ChildrenConstantScoreQuery.java
+++ b/src/main/java/org/elasticsearch/index/search/child/ChildrenConstantScoreQuery.java
@@ -41,6 +41,7 @@
 import org.elasticsearch.index.mapper.Uid;
 import org.elasticsearch.index.mapper.internal.UidFieldMapper;
 import org.elasticsearch.search.internal.SearchContext;
+import org.elasticsearch.search.internal.SearchContext.Lifetime;
 
 import java.io.IOException;
 import java.util.Set;
@@ -123,7 +124,7 @@ public Weight createWeight(IndexSearcher searcher) throws IOException {
                 shortCircuitFilter = new ParentIdsFilter(parentType, nonNestedDocsFilter, parentIds);
             }
             final ParentWeight parentWeight = new ParentWeight(parentFilter, shortCircuitFilter, parentIds);
-            searchContext.addReleasable(parentWeight);
+            searchContext.addReleasable(parentWeight, Lifetime.COLLECTION);
             releaseParentIds = false;
             return parentWeight;
         } finally {
diff --git a/src/main/java/org/elasticsearch/index/search/child/ChildrenQuery.java b/src/main/java/org/elasticsearch/index/search/child/ChildrenQuery.java
index ee01eea69c60..7cb75b079e1d 100644
--- a/src/main/java/org/elasticsearch/index/search/child/ChildrenQuery.java
+++ b/src/main/java/org/elasticsearch/index/search/child/ChildrenQuery.java
@@ -41,6 +41,7 @@
 import org.elasticsearch.index.mapper.Uid;
 import org.elasticsearch.index.mapper.internal.UidFieldMapper;
 import org.elasticsearch.search.internal.SearchContext;
+import org.elasticsearch.search.internal.SearchContext.Lifetime;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -219,7 +220,7 @@ public Weight createWeight(IndexSearcher searcher) throws IOException {
             parentFilter = new ApplyAcceptedDocsFilter(this.parentFilter);
         }
         ParentWeight parentWeight = new ParentWeight(rewrittenChildQuery.createWeight(searcher), parentFilter, size, parentIds, scores, occurrences);
-        searchContext.addReleasable(parentWeight);
+        searchContext.addReleasable(parentWeight, Lifetime.COLLECTION);
         return parentWeight;
     }
 
diff --git a/src/main/java/org/elasticsearch/index/search/child/CustomQueryWrappingFilter.java b/src/main/java/org/elasticsearch/index/search/child/CustomQueryWrappingFilter.java
index 2f7c940c947d..143d00ba833c 100644
--- a/src/main/java/org/elasticsearch/index/search/child/CustomQueryWrappingFilter.java
+++ b/src/main/java/org/elasticsearch/index/search/child/CustomQueryWrappingFilter.java
@@ -27,6 +27,7 @@
 import org.elasticsearch.common.lucene.docset.DocIdSets;
 import org.elasticsearch.common.lucene.search.NoCacheFilter;
 import org.elasticsearch.search.internal.SearchContext;
+import org.elasticsearch.search.internal.SearchContext.Lifetime;
 
 import java.io.IOException;
 import java.util.IdentityHashMap;
@@ -66,7 +67,7 @@ public DocIdSet getDocIdSet(final AtomicReaderContext context, final Bits accept
             IndexSearcher searcher = searchContext.searcher();
             docIdSets = new IdentityHashMap<>();
             this.searcher = searcher;
-            searchContext.addReleasable(this);
+            searchContext.addReleasable(this, Lifetime.COLLECTION);
 
             final Weight weight = searcher.createNormalizedWeight(query);
             for (final AtomicReaderContext leaf : searcher.getTopReaderContext().leaves()) {
diff --git a/src/main/java/org/elasticsearch/index/search/child/ParentConstantScoreQuery.java b/src/main/java/org/elasticsearch/index/search/child/ParentConstantScoreQuery.java
index 2c6893094949..9a1e3f4d3a72 100644
--- a/src/main/java/org/elasticsearch/index/search/child/ParentConstantScoreQuery.java
+++ b/src/main/java/org/elasticsearch/index/search/child/ParentConstantScoreQuery.java
@@ -36,6 +36,7 @@
 import org.elasticsearch.index.fielddata.ordinals.Ordinals;
 import org.elasticsearch.index.fielddata.plain.ParentChildIndexFieldData;
 import org.elasticsearch.search.internal.SearchContext;
+import org.elasticsearch.search.internal.SearchContext.Lifetime;
 
 import java.io.IOException;
 import java.util.Set;
@@ -104,7 +105,7 @@ public Weight createWeight(IndexSearcher searcher) throws IOException {
             }
 
             final ChildrenWeight childrenWeight = new ChildrenWeight(childrenFilter, parentIds);
-            searchContext.addReleasable(childrenWeight);
+            searchContext.addReleasable(childrenWeight, Lifetime.COLLECTION);
             releaseParentIds = false;
             return childrenWeight;
         } finally {
diff --git a/src/main/java/org/elasticsearch/index/search/child/ParentQuery.java b/src/main/java/org/elasticsearch/index/search/child/ParentQuery.java
index 9aa0455e889f..4a7d7e14703e 100644
--- a/src/main/java/org/elasticsearch/index/search/child/ParentQuery.java
+++ b/src/main/java/org/elasticsearch/index/search/child/ParentQuery.java
@@ -40,6 +40,7 @@
 import org.elasticsearch.index.fielddata.ordinals.Ordinals;
 import org.elasticsearch.index.fielddata.plain.ParentChildIndexFieldData;
 import org.elasticsearch.search.internal.SearchContext;
+import org.elasticsearch.search.internal.SearchContext.Lifetime;
 
 import java.io.IOException;
 import java.util.Set;
@@ -156,7 +157,7 @@ public Weight createWeight(IndexSearcher searcher) throws IOException {
                 Releasables.release(collector.parentIds, collector.scores);
             }
         }
-        searchContext.addReleasable(childWeight);
+        searchContext.addReleasable(childWeight, Lifetime.COLLECTION);
         return childWeight;
     }
 
diff --git a/src/main/java/org/elasticsearch/index/search/child/TopChildrenQuery.java b/src/main/java/org/elasticsearch/index/search/child/TopChildrenQuery.java
index 0fad99e6685f..e421a8b05986 100644
--- a/src/main/java/org/elasticsearch/index/search/child/TopChildrenQuery.java
+++ b/src/main/java/org/elasticsearch/index/search/child/TopChildrenQuery.java
@@ -38,6 +38,7 @@
 import org.elasticsearch.index.mapper.Uid;
 import org.elasticsearch.index.mapper.internal.UidFieldMapper;
 import org.elasticsearch.search.internal.SearchContext;
+import org.elasticsearch.search.internal.SearchContext.Lifetime;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -168,7 +169,7 @@ public Weight createWeight(IndexSearcher searcher) throws IOException {
         }
 
         ParentWeight parentWeight =  new ParentWeight(rewrittenChildQuery.createWeight(searcher), parentDocs);
-        searchContext.addReleasable(parentWeight);
+        searchContext.addReleasable(parentWeight, Lifetime.COLLECTION);
         return parentWeight;
     }
 
diff --git a/src/main/java/org/elasticsearch/percolator/PercolateContext.java b/src/main/java/org/elasticsearch/percolator/PercolateContext.java
index 387f22e8f5cf..30c89344eda1 100644
--- a/src/main/java/org/elasticsearch/percolator/PercolateContext.java
+++ b/src/main/java/org/elasticsearch/percolator/PercolateContext.java
@@ -23,12 +23,11 @@
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.*;
-import org.elasticsearch.ElasticsearchException;
 import org.elasticsearch.action.percolate.PercolateShardRequest;
 import org.elasticsearch.action.search.SearchType;
 import org.elasticsearch.cache.recycler.CacheRecycler;
 import org.elasticsearch.cache.recycler.PageCacheRecycler;
-import org.elasticsearch.common.lease.Releasable;
+import org.elasticsearch.common.lease.Releasables;
 import org.elasticsearch.common.lucene.HashedBytesRef;
 import org.elasticsearch.common.text.StringText;
 import org.elasticsearch.common.util.BigArrays;
@@ -207,18 +206,15 @@ public SearchLookup lookup() {
     }
 
     @Override
-    public boolean release() throws ElasticsearchException {
+    protected void doRelease() {
         try {
             if (docSearcher != null) {
                 IndexReader indexReader = docSearcher.reader();
                 fieldDataService.clear(indexReader);
                 indexService.cache().clear(indexReader);
-                return docSearcher.release();
-            } else {
-                return false;
             }
         } finally {
-            engineSearcher.release();
+            Releasables.release(docSearcher, engineSearcher);
         }
     }
 
@@ -295,11 +291,6 @@ public SearchContext facets(SearchContextFacets facets) {
     }
 
     // Unused:
-    @Override
-    public boolean clearAndRelease() {
-        throw new UnsupportedOperationException();
-    }
-
     @Override
     public void preProcess() {
         throw new UnsupportedOperationException();
@@ -679,16 +670,6 @@ public FetchSearchResult fetchResult() {
         throw new UnsupportedOperationException();
     }
 
-    @Override
-    public void addReleasable(Releasable releasable) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void clearReleasables() {
-        throw new UnsupportedOperationException();
-    }
-
     @Override
     public ScanContext scanContext() {
         throw new UnsupportedOperationException();
diff --git a/src/main/java/org/elasticsearch/search/SearchService.java b/src/main/java/org/elasticsearch/search/SearchService.java
index 474718499296..9884c7fd6762 100644
--- a/src/main/java/org/elasticsearch/search/SearchService.java
+++ b/src/main/java/org/elasticsearch/search/SearchService.java
@@ -69,10 +69,8 @@
 import org.elasticsearch.search.dfs.DfsPhase;
 import org.elasticsearch.search.dfs.DfsSearchResult;
 import org.elasticsearch.search.fetch.*;
-import org.elasticsearch.search.internal.DefaultSearchContext;
-import org.elasticsearch.search.internal.InternalScrollSearchRequest;
-import org.elasticsearch.search.internal.SearchContext;
-import org.elasticsearch.search.internal.ShardSearchRequest;
+import org.elasticsearch.search.internal.*;
+import org.elasticsearch.search.internal.SearchContext.Lifetime;
 import org.elasticsearch.search.query.*;
 import org.elasticsearch.search.warmer.IndexWarmersMetaData;
 import org.elasticsearch.threadpool.ThreadPool;
@@ -575,6 +573,8 @@ private void contextProcessedSuccessfully(SearchContext context) {
     }
 
     private void cleanContext(SearchContext context) {
+        assert context == SearchContext.current();
+        context.clearReleasables(Lifetime.PHASE);
         SearchContext.removeCurrent();
     }
 
diff --git a/src/main/java/org/elasticsearch/search/aggregations/AggregationPhase.java b/src/main/java/org/elasticsearch/search/aggregations/AggregationPhase.java
index 73b899bc0edf..b2f2164c5762 100644
--- a/src/main/java/org/elasticsearch/search/aggregations/AggregationPhase.java
+++ b/src/main/java/org/elasticsearch/search/aggregations/AggregationPhase.java
@@ -25,7 +25,6 @@
 import org.apache.lucene.search.Scorer;
 import org.elasticsearch.ElasticsearchException;
 import org.elasticsearch.common.inject.Inject;
-import org.elasticsearch.common.lease.Releasables;
 import org.elasticsearch.common.lucene.search.Queries;
 import org.elasticsearch.common.lucene.search.XCollector;
 import org.elasticsearch.common.lucene.search.XConstantScoreQuery;
@@ -106,41 +105,34 @@ public void execute(SearchContext context) throws ElasticsearchException {
         }
 
         Aggregator[] aggregators = context.aggregations().aggregators();
-        boolean success = false;
-        try {
-            List<Aggregator> globals = new ArrayList<>();
-            for (int i = 0; i < aggregators.length; i++) {
-                if (aggregators[i] instanceof GlobalAggregator) {
-                    globals.add(aggregators[i]);
-                }
+        List<Aggregator> globals = new ArrayList<>();
+        for (int i = 0; i < aggregators.length; i++) {
+            if (aggregators[i] instanceof GlobalAggregator) {
+                globals.add(aggregators[i]);
             }
+        }
 
-            // optimize the global collector based execution
-            if (!globals.isEmpty()) {
-                AggregationsCollector collector = new AggregationsCollector(globals, context.aggregations().aggregationContext());
-                Query query = new XConstantScoreQuery(Queries.MATCH_ALL_FILTER);
-                Filter searchFilter = context.searchFilter(context.types());
-                if (searchFilter != null) {
-                    query = new XFilteredQuery(query, searchFilter);
-                }
-                try {
-                    context.searcher().search(query, collector);
-                } catch (Exception e) {
-                    throw new QueryPhaseExecutionException(context, "Failed to execute global aggregators", e);
-                }
-                collector.postCollection();
+        // optimize the global collector based execution
+        if (!globals.isEmpty()) {
+            AggregationsCollector collector = new AggregationsCollector(globals, context.aggregations().aggregationContext());
+            Query query = new XConstantScoreQuery(Queries.MATCH_ALL_FILTER);
+            Filter searchFilter = context.searchFilter(context.types());
+            if (searchFilter != null) {
+                query = new XFilteredQuery(query, searchFilter);
             }
-
-            List<InternalAggregation> aggregations = new ArrayList<>(aggregators.length);
-            for (Aggregator aggregator : context.aggregations().aggregators()) {
-                aggregations.add(aggregator.buildAggregation(0));
+            try {
+                context.searcher().search(query, collector);
+            } catch (Exception e) {
+                throw new QueryPhaseExecutionException(context, "Failed to execute global aggregators", e);
             }
-            context.queryResult().aggregations(new InternalAggregations(aggregations));
-            success = true;
-        } finally {
-            Releasables.release(success, aggregators);
+            collector.postCollection();
         }
 
+        List<InternalAggregation> aggregations = new ArrayList<>(aggregators.length);
+        for (Aggregator aggregator : context.aggregations().aggregators()) {
+            aggregations.add(aggregator.buildAggregation(0));
+        }
+        context.queryResult().aggregations(new InternalAggregations(aggregations));
     }
 
 
diff --git a/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java b/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java
index 4aea993279f7..6f93c9ea4ed3 100644
--- a/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java
+++ b/src/main/java/org/elasticsearch/search/aggregations/Aggregator.java
@@ -19,12 +19,12 @@
 package org.elasticsearch.search.aggregations;
 
 import org.elasticsearch.common.lease.Releasable;
-import org.elasticsearch.common.lease.Releasables;
 import org.elasticsearch.common.lucene.ReaderContextAware;
 import org.elasticsearch.common.util.BigArrays;
 import org.elasticsearch.common.xcontent.XContentParser;
 import org.elasticsearch.search.aggregations.support.AggregationContext;
 import org.elasticsearch.search.internal.SearchContext;
+import org.elasticsearch.search.internal.SearchContext.Lifetime;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -84,6 +84,9 @@ protected Aggregator(String name, BucketAggregationMode bucketAggregationMode, A
         assert factories != null : "sub-factories provided to BucketAggregator must not be null, use AggragatorFactories.EMPTY instead";
         this.factories = factories;
         this.subAggregators = factories.createSubAggregators(this, estimatedBucketsCount);
+        // TODO: change it to SEARCH_PHASE, but this would imply allocating the aggregators in the QUERY
+        // phase instead of DFS like it is done today
+        context.searchContext().addReleasable(this, Lifetime.CONTEXT);
     }
 
     /**
@@ -175,13 +178,7 @@ public final void postCollection() {
     /** Called upon release of the aggregator. */
     @Override
     public boolean release() {
-        boolean success = false;
-        try {
-            doRelease();
-            success = true;
-        } finally {
-            Releasables.release(success, subAggregators);
-        }
+        doRelease();
         return true;
     }
 
diff --git a/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java b/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java
index 40d8f53fd5ee..07766c7f709b 100644
--- a/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java
+++ b/src/main/java/org/elasticsearch/search/aggregations/AggregatorFactories.java
@@ -18,8 +18,6 @@
  */
 package org.elasticsearch.search.aggregations;
 
-import com.google.common.collect.Iterables;
-import com.google.common.collect.UnmodifiableIterator;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.elasticsearch.common.lease.Releasables;
 import org.elasticsearch.common.util.ObjectArray;
@@ -28,8 +26,6 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
 import java.util.List;
 
 /**
@@ -82,9 +78,6 @@ private static Aggregator createAndRegisterContextAware(AggregationContext conte
                     long arraySize = estimatedBucketsCount > 0 ?  estimatedBucketsCount : 1;
                     aggregators = bigArrays.newObjectArray(arraySize);
                     aggregators.set(0, first);
-                    for (long i = 1; i < arraySize; ++i) {
-                        aggregators.set(i, createAndRegisterContextAware(parent.context(), factory, parent, estimatedBucketsCount));
-                    }
                 }
 
                 @Override
@@ -135,29 +128,7 @@ public InternalAggregation buildEmptyAggregation() {
 
                 @Override
                 public void doRelease() {
-                    final Iterable<Aggregator> aggregatorsIter = new Iterable<Aggregator>() {
-
-                        @Override
-                        public Iterator<Aggregator> iterator() {
-                            return new UnmodifiableIterator<Aggregator>() {
-
-                                long i = 0;
-
-                                @Override
-                                public boolean hasNext() {
-                                    return i < aggregators.size();
-                                }
-
-                                @Override
-                                public Aggregator next() {
-                                    return aggregators.get(i++);
-                                }
-
-                            };
-                        }
-
-                    };
-                    Releasables.release(Iterables.concat(aggregatorsIter, Collections.singleton(aggregators)));
+                    Releasables.release(aggregators);
                 }
             };
         }
diff --git a/src/main/java/org/elasticsearch/search/fetch/matchedqueries/MatchedQueriesFetchSubPhase.java b/src/main/java/org/elasticsearch/search/fetch/matchedqueries/MatchedQueriesFetchSubPhase.java
index 913d52ed86f1..15c76cb68a3b 100644
--- a/src/main/java/org/elasticsearch/search/fetch/matchedqueries/MatchedQueriesFetchSubPhase.java
+++ b/src/main/java/org/elasticsearch/search/fetch/matchedqueries/MatchedQueriesFetchSubPhase.java
@@ -30,6 +30,7 @@
 import org.elasticsearch.search.fetch.FetchSubPhase;
 import org.elasticsearch.search.internal.InternalSearchHit;
 import org.elasticsearch.search.internal.SearchContext;
+import org.elasticsearch.search.internal.SearchContext.Lifetime;
 
 import java.io.IOException;
 import java.util.List;
@@ -97,7 +98,7 @@ private void addMatchedQueries(HitContext hitContext, ImmutableMap<String, Filte
             } catch (IOException e) {
                 // ignore
             } finally {
-                SearchContext.current().clearReleasables();
+                SearchContext.current().clearReleasables(Lifetime.COLLECTION);
             }
         }
     }
diff --git a/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java
index bad42c55ebd7..6e1969d653ce 100644
--- a/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java
+++ b/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java
@@ -21,6 +21,8 @@
 
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.search.*;
+import org.elasticsearch.common.lease.Releasable;
+import org.elasticsearch.common.lease.Releasables;
 import org.elasticsearch.common.lucene.MinimumScoreCollector;
 import org.elasticsearch.common.lucene.MultiCollector;
 import org.elasticsearch.common.lucene.search.FilteredCollector;
@@ -28,6 +30,7 @@
 import org.elasticsearch.common.lucene.search.XFilteredQuery;
 import org.elasticsearch.index.engine.Engine;
 import org.elasticsearch.search.dfs.CachedDfSource;
+import org.elasticsearch.search.internal.SearchContext.Lifetime;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -36,7 +39,7 @@
 /**
  * Context-aware extension of {@link IndexSearcher}.
  */
-public class ContextIndexSearcher extends IndexSearcher {
+public class ContextIndexSearcher extends IndexSearcher implements Releasable {
 
     public static enum Stage {
         NA,
@@ -66,10 +69,10 @@ public ContextIndexSearcher(SearchContext searchContext, Engine.Searcher searche
         setSimilarity(searcher.searcher().getSimilarity());
     }
 
-    public void release() {
-        if (mainDocIdSetCollector != null) {
-            mainDocIdSetCollector.release();
-        }
+    @Override
+    public boolean release() {
+        Releasables.release(mainDocIdSetCollector);
+        return true;
     }
 
     public void dfSource(CachedDfSource dfSource) {
@@ -129,7 +132,7 @@ public Weight createNormalizedWeight(Query query) throws IOException {
             }
             return in.createNormalizedWeight(query);
         } catch (Throwable t) {
-            searchContext.clearReleasables();
+            searchContext.clearReleasables(Lifetime.COLLECTION);
             throw new RuntimeException(t);
         }
     }
@@ -187,7 +190,7 @@ public void search(List<AtomicReaderContext> leaves, Weight weight, Collector co
                 }
             }
         } finally {
-            searchContext.clearReleasables();
+            searchContext.clearReleasables(Lifetime.COLLECTION);
         }
     }
 
@@ -200,7 +203,7 @@ public Explanation explain(Query query, int doc) throws IOException {
             XFilteredQuery filteredQuery = new XFilteredQuery(query, searchContext.aliasFilter());
             return super.explain(filteredQuery, doc);
         } finally {
-            searchContext.clearReleasables();
+            searchContext.clearReleasables(Lifetime.COLLECTION);
         }
     }
 }
\ No newline at end of file
diff --git a/src/main/java/org/elasticsearch/search/internal/DefaultSearchContext.java b/src/main/java/org/elasticsearch/search/internal/DefaultSearchContext.java
index 424a8146ecb0..f0dde28eada3 100644
--- a/src/main/java/org/elasticsearch/search/internal/DefaultSearchContext.java
+++ b/src/main/java/org/elasticsearch/search/internal/DefaultSearchContext.java
@@ -30,7 +30,6 @@
 import org.elasticsearch.cache.recycler.CacheRecycler;
 import org.elasticsearch.cache.recycler.PageCacheRecycler;
 import org.elasticsearch.common.Nullable;
-import org.elasticsearch.common.lease.Releasable;
 import org.elasticsearch.common.lease.Releasables;
 import org.elasticsearch.common.lucene.search.AndFilter;
 import org.elasticsearch.common.lucene.search.Queries;
@@ -177,8 +176,6 @@
 
     private volatile long lastAccessTime = -1;
 
-    private List<Releasable> clearables = null;
-
     private volatile boolean useSlowScroll;
 
     public DefaultSearchContext(long id, ShardSearchRequest request, SearchShardTarget shardTarget,
@@ -207,19 +204,12 @@ public DefaultSearchContext(long id, ShardSearchRequest request, SearchShardTarg
     }
 
     @Override
-    public boolean release() throws ElasticsearchException {
+    public void doRelease() throws ElasticsearchException {
         if (scanContext != null) {
             scanContext.clear();
         }
         // clear and scope phase we  have
-        searcher.release();
-        engineSearcher.release();
-        return true;
-    }
-
-    public boolean clearAndRelease() {
-        clearReleasables();
-        return release();
+        Releasables.release(searcher, engineSearcher);
     }
 
     /**
@@ -678,25 +668,6 @@ public FetchSearchResult fetchResult() {
         return fetchResult;
     }
 
-    @Override
-    public void addReleasable(Releasable releasable) {
-        if (clearables == null) {
-            clearables = new ArrayList<>();
-        }
-        clearables.add(releasable);
-    }
-
-    @Override
-    public void clearReleasables() {
-        if (clearables != null) {
-            try {
-                Releasables.release(clearables);
-            } finally {
-                clearables.clear();
-            }
-        }
-    }
-
     public ScanContext scanContext() {
         if (scanContext == null) {
             scanContext = new ScanContext();
diff --git a/src/main/java/org/elasticsearch/search/internal/DocIdSetCollector.java b/src/main/java/org/elasticsearch/search/internal/DocIdSetCollector.java
index 91cd7888d4ca..28ad743e3d62 100644
--- a/src/main/java/org/elasticsearch/search/internal/DocIdSetCollector.java
+++ b/src/main/java/org/elasticsearch/search/internal/DocIdSetCollector.java
@@ -23,6 +23,7 @@
 import org.apache.lucene.search.Collector;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.util.FixedBitSet;
+import org.elasticsearch.common.lease.Releasable;
 import org.elasticsearch.common.lucene.docset.ContextDocIdSet;
 import org.elasticsearch.common.lucene.search.XCollector;
 import org.elasticsearch.index.cache.docset.DocSetCache;
@@ -33,7 +34,7 @@
 
 /**
  */
-public class DocIdSetCollector extends XCollector {
+public class DocIdSetCollector extends XCollector implements Releasable {
 
     private final DocSetCache docSetCache;
     private final Collector collector;
@@ -53,10 +54,11 @@ public DocIdSetCollector(DocSetCache docSetCache, Collector collector) {
         return docSets;
     }
 
-    public void release() {
+    public boolean release() {
         for (ContextDocIdSet docSet : docSets) {
             docSetCache.release(docSet);
         }
+        return true;
     }
 
     @Override
diff --git a/src/main/java/org/elasticsearch/search/internal/SearchContext.java b/src/main/java/org/elasticsearch/search/internal/SearchContext.java
index db94fdcd140d..3bcc88e55f1a 100644
--- a/src/main/java/org/elasticsearch/search/internal/SearchContext.java
+++ b/src/main/java/org/elasticsearch/search/internal/SearchContext.java
@@ -18,6 +18,9 @@
  */
 package org.elasticsearch.search.internal;
 
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimap;
+import com.google.common.collect.MultimapBuilder;
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreDoc;
@@ -27,6 +30,7 @@
 import org.elasticsearch.cache.recycler.PageCacheRecycler;
 import org.elasticsearch.common.Nullable;
 import org.elasticsearch.common.lease.Releasable;
+import org.elasticsearch.common.lease.Releasables;
 import org.elasticsearch.common.util.BigArrays;
 import org.elasticsearch.index.analysis.AnalysisService;
 import org.elasticsearch.index.cache.docset.DocSetCache;
@@ -59,6 +63,8 @@
 import org.elasticsearch.search.scan.ScanContext;
 import org.elasticsearch.search.suggest.SuggestionSearchContext;
 
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 
 /**
@@ -81,7 +87,18 @@ public static SearchContext current() {
         return current.get();
     }
 
-    public abstract boolean clearAndRelease();
+    private Multimap<Lifetime, Releasable> clearables = null;
+
+    public final boolean release() {
+        try {
+            clearReleasables(Lifetime.CONTEXT);
+            return true;
+        } finally {
+            doRelease();
+        }
+    }
+
+    protected abstract void doRelease();
 
     /**
      * Should be called before executing the main query and after all other parameters have been set.
@@ -288,9 +305,29 @@ public static SearchContext current() {
 
     public abstract FetchSearchResult fetchResult();
 
-    public abstract void addReleasable(Releasable releasable);
+    /**
+     * Schedule the release of a resource. The time when {@link Releasable#release()} will be called on this object
+     * is function of the provided {@link Lifetime}.
+     */
+    public void addReleasable(Releasable releasable, Lifetime lifetime) {
+        if (clearables == null) {
+            clearables = MultimapBuilder.enumKeys(Lifetime.class).arrayListValues().build();
+        }
+        clearables.put(lifetime, releasable);
+    }
 
-    public abstract void clearReleasables();
+    public void clearReleasables(Lifetime lifetime) {
+        if (clearables != null) {
+            List<Collection<Releasable>> releasables = new ArrayList<>();
+            for (Lifetime lc : Lifetime.values()) {
+                if (lc.compareTo(lifetime) > 0) {
+                    break;
+                }
+                releasables.add(clearables.removeAll(lc));
+            }
+            Releasables.release(Iterables.concat(releasables));
+        }
+    }
 
     public abstract ScanContext scanContext();
 
@@ -305,4 +342,22 @@ public static SearchContext current() {
     public abstract boolean useSlowScroll();
 
     public abstract SearchContext useSlowScroll(boolean useSlowScroll);
+
+    /**
+     * The life time of an object that is used during search execution.
+     */
+    public enum Lifetime {
+        /**
+         * This life time is for objects that only live during collection time.
+         */
+        COLLECTION,
+        /**
+         * This life time is for objects that need to live until the end of the current search phase.
+         */
+        PHASE,
+        /**
+         * This life time is for objects that need to live until the search context they are attached to is destroyed.
+         */
+        CONTEXT;
+    }
 }
diff --git a/src/test/java/org/elasticsearch/index/search/child/TestSearchContext.java b/src/test/java/org/elasticsearch/index/search/child/TestSearchContext.java
index 42bc3d2db16b..94f49d69021a 100644
--- a/src/test/java/org/elasticsearch/index/search/child/TestSearchContext.java
+++ b/src/test/java/org/elasticsearch/index/search/child/TestSearchContext.java
@@ -26,7 +26,6 @@
 import org.elasticsearch.action.search.SearchType;
 import org.elasticsearch.cache.recycler.CacheRecycler;
 import org.elasticsearch.cache.recycler.PageCacheRecycler;
-import org.elasticsearch.common.lease.Releasable;
 import org.elasticsearch.common.util.BigArrays;
 import org.elasticsearch.index.analysis.AnalysisService;
 import org.elasticsearch.index.cache.docset.DocSetCache;
@@ -94,11 +93,6 @@ public TestSearchContext() {
         this.indexFieldDataService = null;
     }
 
-    @Override
-    public boolean clearAndRelease() {
-        return false;
-    }
-
     @Override
     public void preProcess() {
     }
@@ -556,14 +550,6 @@ public FetchSearchResult fetchResult() {
         return null;
     }
 
-    @Override
-    public void addReleasable(Releasable releasable) {
-    }
-
-    @Override
-    public void clearReleasables() {
-    }
-
     @Override
     public ScanContext scanContext() {
         return null;
@@ -590,8 +576,8 @@ public FieldMapper smartNameFieldMapper(String name) {
     }
 
     @Override
-    public boolean release() throws ElasticsearchException {
-        return false;
+    public void doRelease() throws ElasticsearchException {
+        // no-op
     }
 
     @Override
diff --git a/src/test/java/org/elasticsearch/search/aggregations/bucket/DoubleTermsTests.java b/src/test/java/org/elasticsearch/search/aggregations/bucket/DoubleTermsTests.java
index b964436f863a..77619e8a1a7e 100644
--- a/src/test/java/org/elasticsearch/search/aggregations/bucket/DoubleTermsTests.java
+++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/DoubleTermsTests.java
@@ -18,7 +18,6 @@
  */
 package org.elasticsearch.search.aggregations.bucket;
 
-import org.apache.lucene.util.LuceneTestCase;
 import org.elasticsearch.ElasticsearchException;
 import org.elasticsearch.action.index.IndexRequestBuilder;
 import org.elasticsearch.action.search.SearchResponse;
@@ -33,7 +32,6 @@
 import org.elasticsearch.search.aggregations.metrics.stats.extended.ExtendedStats;
 import org.elasticsearch.search.aggregations.metrics.sum.Sum;
 import org.elasticsearch.test.ElasticsearchIntegrationTest;
-import org.elasticsearch.test.cache.recycler.MockBigArrays;
 import org.hamcrest.Matchers;
 import org.junit.Test;
 
@@ -217,7 +215,6 @@ public void singleValueField_OrderedByTermDesc() throws Exception {
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_WithSubAggregation() throws Exception {
         SearchResponse response = client().prepareSearch("idx").setTypes("type")
@@ -433,7 +430,6 @@ public void multiValuedField_WithValueScript_WithInheritedSubAggregator() throws
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void script_SingleValue() throws Exception {
         SearchResponse response = client().prepareSearch("idx").setTypes("type")
@@ -615,7 +611,6 @@ public void partiallyUnmapped() throws Exception {
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void emptyAggregation() throws Exception {
         SearchResponse searchResponse = client().prepareSearch("empty_bucket_idx")
@@ -756,11 +751,8 @@ public void singleValuedField_OrderedBySubAggregationAsc_MultiHierarchyLevels()
         assertThat(max.getValue(), equalTo(asc ? 4.0 : 2.0));
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByMissingSubAggregation() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
 
             client().prepareSearch("idx").setTypes("type")
@@ -776,11 +768,8 @@ public void singleValuedField_OrderedByMissingSubAggregation() throws Exception
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByNonMetricsOrMultiBucketSubAggregation() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
 
             client().prepareSearch("idx").setTypes("type")
@@ -797,11 +786,8 @@ public void singleValuedField_OrderedByNonMetricsOrMultiBucketSubAggregation() t
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByMultiValuedSubAggregation_WithUknownMetric() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
 
             client().prepareSearch("idx").setTypes("type")
@@ -819,11 +805,8 @@ public void singleValuedField_OrderedByMultiValuedSubAggregation_WithUknownMetri
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByMultiValuedSubAggregation_WithoutMetric() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
 
             client().prepareSearch("idx").setTypes("type")
@@ -841,7 +824,6 @@ public void singleValuedField_OrderedByMultiValuedSubAggregation_WithoutMetric()
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedBySingleValueSubAggregationDesc() throws Exception {
         boolean asc = false;
diff --git a/src/test/java/org/elasticsearch/search/aggregations/bucket/LongTermsTests.java b/src/test/java/org/elasticsearch/search/aggregations/bucket/LongTermsTests.java
index 783571492545..8691d2005e65 100644
--- a/src/test/java/org/elasticsearch/search/aggregations/bucket/LongTermsTests.java
+++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/LongTermsTests.java
@@ -18,7 +18,6 @@
  */
 package org.elasticsearch.search.aggregations.bucket;
 
-import org.apache.lucene.util.LuceneTestCase;
 import org.elasticsearch.ElasticsearchException;
 import org.elasticsearch.action.index.IndexRequestBuilder;
 import org.elasticsearch.action.search.SearchResponse;
@@ -32,7 +31,6 @@
 import org.elasticsearch.search.aggregations.metrics.stats.extended.ExtendedStats;
 import org.elasticsearch.search.aggregations.metrics.sum.Sum;
 import org.elasticsearch.test.ElasticsearchIntegrationTest;
-import org.elasticsearch.test.cache.recycler.MockBigArrays;
 import org.hamcrest.Matchers;
 import org.junit.Test;
 
@@ -513,7 +511,6 @@ public void script_MultiValued() throws Exception {
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void script_MultiValued_WithAggregatorInherited_NoExplicitType() throws Exception {
 
@@ -753,11 +750,8 @@ public void singleValuedField_OrderedBySubAggregationAsc_MultiHierarchyLevels()
         assertThat(max.getValue(), equalTo(asc ? 4.0 : 2.0));
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByMissingSubAggregation() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
 
             client().prepareSearch("idx").setTypes("type")
@@ -773,11 +767,8 @@ public void singleValuedField_OrderedByMissingSubAggregation() throws Exception
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByNonMetricsOrMultiBucketSubAggregation() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
 
             client().prepareSearch("idx").setTypes("type")
@@ -794,11 +785,8 @@ public void singleValuedField_OrderedByNonMetricsOrMultiBucketSubAggregation() t
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByMultiValuedSubAggregation_WithUknownMetric() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
 
             client().prepareSearch("idx").setTypes("type")
@@ -816,11 +804,8 @@ public void singleValuedField_OrderedByMultiValuedSubAggregation_WithUknownMetri
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByMultiValuedSubAggregation_WithoutMetric() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
 
             client().prepareSearch("idx").setTypes("type")
diff --git a/src/test/java/org/elasticsearch/search/aggregations/bucket/NestedTests.java b/src/test/java/org/elasticsearch/search/aggregations/bucket/NestedTests.java
index a5437ed1de32..7afe45141a13 100644
--- a/src/test/java/org/elasticsearch/search/aggregations/bucket/NestedTests.java
+++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/NestedTests.java
@@ -18,7 +18,6 @@
  */
 package org.elasticsearch.search.aggregations.bucket;
 
-import org.apache.lucene.util.LuceneTestCase;
 import org.elasticsearch.ElasticsearchException;
 import org.elasticsearch.action.index.IndexRequestBuilder;
 import org.elasticsearch.action.search.SearchResponse;
@@ -33,7 +32,6 @@
 import org.elasticsearch.search.aggregations.metrics.stats.Stats;
 import org.elasticsearch.search.aggregations.metrics.sum.Sum;
 import org.elasticsearch.test.ElasticsearchIntegrationTest;
-import org.elasticsearch.test.cache.recycler.MockBigArrays;
 import org.hamcrest.Matchers;
 import org.junit.Test;
 
@@ -186,10 +184,8 @@ public void simple() throws Exception {
         assertThat(stats.getAvg(), equalTo((double) sum / count));
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void onNonNestedField() throws Exception {
-        MockBigArrays.discardNextCheck();
         try {
             client().prepareSearch("idx")
                     .addAggregation(nested("nested").path("value")
diff --git a/src/test/java/org/elasticsearch/search/aggregations/bucket/StringTermsTests.java b/src/test/java/org/elasticsearch/search/aggregations/bucket/StringTermsTests.java
index a511e734dd08..1bc388fe8d2d 100644
--- a/src/test/java/org/elasticsearch/search/aggregations/bucket/StringTermsTests.java
+++ b/src/test/java/org/elasticsearch/search/aggregations/bucket/StringTermsTests.java
@@ -19,7 +19,6 @@
 package org.elasticsearch.search.aggregations.bucket;
 
 import com.google.common.base.Strings;
-import org.apache.lucene.util.LuceneTestCase;
 import org.elasticsearch.ElasticsearchException;
 import org.elasticsearch.action.index.IndexRequestBuilder;
 import org.elasticsearch.action.search.SearchResponse;
@@ -27,12 +26,12 @@
 import org.elasticsearch.search.aggregations.bucket.filter.Filter;
 import org.elasticsearch.search.aggregations.bucket.histogram.Histogram;
 import org.elasticsearch.search.aggregations.bucket.terms.Terms;
+import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregatorFactory.ExecutionMode;
 import org.elasticsearch.search.aggregations.metrics.avg.Avg;
 import org.elasticsearch.search.aggregations.metrics.stats.Stats;
 import org.elasticsearch.search.aggregations.metrics.stats.extended.ExtendedStats;
 import org.elasticsearch.search.aggregations.metrics.valuecount.ValueCount;
 import org.elasticsearch.test.ElasticsearchIntegrationTest;
-import org.elasticsearch.test.cache.recycler.MockBigArrays;
 import org.hamcrest.Matchers;
 import org.junit.Test;
 
@@ -45,7 +44,6 @@
 import static org.elasticsearch.index.query.FilterBuilders.termFilter;
 import static org.elasticsearch.index.query.QueryBuilders.matchAllQuery;
 import static org.elasticsearch.search.aggregations.AggregationBuilders.*;
-import static org.elasticsearch.search.aggregations.bucket.terms.TermsAggregatorFactory.ExecutionMode;
 import static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertSearchResponse;
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.is;
@@ -943,11 +941,8 @@ public void singleValuedField_OrderedBySubAggregationAsc_MultiHierarchyLevels()
     }
 
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByMissingSubAggregation() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
 
             client().prepareSearch("idx").setTypes("type")
@@ -964,11 +959,8 @@ public void singleValuedField_OrderedByMissingSubAggregation() throws Exception
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByNonMetricsOrMultiBucketSubAggregation() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
 
             client().prepareSearch("idx").setTypes("type")
@@ -986,11 +978,8 @@ public void singleValuedField_OrderedByNonMetricsOrMultiBucketSubAggregation() t
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByMultiValuedSubAggregation_WithUknownMetric() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
             client().prepareSearch("idx").setTypes("type")
                     .addAggregation(terms("terms")
@@ -1008,11 +997,8 @@ public void singleValuedField_OrderedByMultiValuedSubAggregation_WithUknownMetri
         }
     }
 
-    @LuceneTestCase.AwaitsFix(bugUrl = "https://github.com/elasticsearch/elasticsearch/issues/5703")
     @Test
     public void singleValuedField_OrderedByMultiValuedSubAggregation_WithoutMetric() throws Exception {
-
-        MockBigArrays.discardNextCheck();
         try {
 
             client().prepareSearch("idx").setTypes("type")
diff --git a/src/test/java/org/elasticsearch/test/cache/recycler/MockBigArrays.java b/src/test/java/org/elasticsearch/test/cache/recycler/MockBigArrays.java
index 435d1127eb4a..26986318cd38 100644
--- a/src/test/java/org/elasticsearch/test/cache/recycler/MockBigArrays.java
+++ b/src/test/java/org/elasticsearch/test/cache/recycler/MockBigArrays.java
@@ -45,26 +45,11 @@
      */
     private static final boolean TRACK_ALLOCATIONS = false;
 
-    private static boolean DISCARD = false;
-
     private static ConcurrentMap<Object, Object> ACQUIRED_ARRAYS = new ConcurrentHashMap<>();
 
-    /**
-     * Discard the next check that all arrays should be released. This can be useful if for a specific test, the cost to make
-     * sure the array is released is higher than the cost the user would experience if the array would not be released.
-     */
-    public static void discardNextCheck() {
-        DISCARD = true;
-    }
-
     public static void ensureAllArraysAreReleased() throws Exception {
-        if (DISCARD) {
-            DISCARD = false;
-        } else {
-            final Map<Object, Object> masterCopy = Maps.newHashMap(ACQUIRED_ARRAYS);
-            if (masterCopy.isEmpty()) {
-                return;
-            }
+        final Map<Object, Object> masterCopy = Maps.newHashMap(ACQUIRED_ARRAYS);
+        if (!masterCopy.isEmpty()) {
             // not empty, we might be executing on a shared cluster that keeps on obtaining
             // and releasing arrays, lets make sure that after a reasonable timeout, all master
             // copy (snapshot) have been released
@@ -74,14 +59,13 @@ public boolean apply(Object input) {
                     return Sets.intersection(masterCopy.keySet(), ACQUIRED_ARRAYS.keySet()).isEmpty();
                 }
             });
-            if (success) {
-                return;
-            }
-            masterCopy.keySet().retainAll(ACQUIRED_ARRAYS.keySet());
-            ACQUIRED_ARRAYS.keySet().removeAll(masterCopy.keySet()); // remove all existing master copy we will report on
-            if (!masterCopy.isEmpty()) {
-                final Object cause = masterCopy.entrySet().iterator().next().getValue();
-                throw new RuntimeException(masterCopy.size() + " arrays have not been released", cause instanceof Throwable ? (Throwable) cause : null);
+            if (!success) {
+                masterCopy.keySet().retainAll(ACQUIRED_ARRAYS.keySet());
+                ACQUIRED_ARRAYS.keySet().removeAll(masterCopy.keySet()); // remove all existing master copy we will report on
+                if (!masterCopy.isEmpty()) {
+                    final Object cause = masterCopy.entrySet().iterator().next().getValue();
+                    throw new RuntimeException(masterCopy.size() + " arrays have not been released", cause instanceof Throwable ? (Throwable) cause : null);
+                }
             }
         }
     }
diff --git a/src/test/java/org/elasticsearch/test/cache/recycler/MockPageCacheRecycler.java b/src/test/java/org/elasticsearch/test/cache/recycler/MockPageCacheRecycler.java
index e01774aaf1be..a64e4f548cf5 100644
--- a/src/test/java/org/elasticsearch/test/cache/recycler/MockPageCacheRecycler.java
+++ b/src/test/java/org/elasticsearch/test/cache/recycler/MockPageCacheRecycler.java
@@ -43,26 +43,24 @@
 
     public static void ensureAllPagesAreReleased() throws Exception {
         final Map<Object, Throwable> masterCopy = Maps.newHashMap(ACQUIRED_PAGES);
-        if (masterCopy.isEmpty()) {
-            return;
-        }
-        // not empty, we might be executing on a shared cluster that keeps on obtaining
-        // and releasing pages, lets make sure that after a reasonable timeout, all master
-        // copy (snapshot) have been released
-        boolean success = ElasticsearchTestCase.awaitBusy(new Predicate<Object>() {
-            @Override
-            public boolean apply(Object input) {
-                return Sets.intersection(masterCopy.keySet(), ACQUIRED_PAGES.keySet()).isEmpty();
-            }
-        });
-        if (success) {
-            return;
-        }
-        masterCopy.keySet().retainAll(ACQUIRED_PAGES.keySet());
-        ACQUIRED_PAGES.keySet().removeAll(masterCopy.keySet()); // remove all existing master copy we will report on
         if (!masterCopy.isEmpty()) {
-            final Throwable t = masterCopy.entrySet().iterator().next().getValue();
-            throw new RuntimeException(masterCopy.size() + " pages have not been released", t);
+            // not empty, we might be executing on a shared cluster that keeps on obtaining
+            // and releasing pages, lets make sure that after a reasonable timeout, all master
+            // copy (snapshot) have been released
+            boolean success = ElasticsearchTestCase.awaitBusy(new Predicate<Object>() {
+                @Override
+                public boolean apply(Object input) {
+                    return Sets.intersection(masterCopy.keySet(), ACQUIRED_PAGES.keySet()).isEmpty();
+                }
+            });
+            if (!success) {
+                masterCopy.keySet().retainAll(ACQUIRED_PAGES.keySet());
+                ACQUIRED_PAGES.keySet().removeAll(masterCopy.keySet()); // remove all existing master copy we will report on
+                if (!masterCopy.isEmpty()) {
+                    final Throwable t = masterCopy.entrySet().iterator().next().getValue();
+                    throw new RuntimeException(masterCopy.size() + " pages have not been released", t);
+                }
+            }
         }
     }
 
