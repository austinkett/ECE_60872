diff --git a/Tools/Replay/Replay.cpp b/Tools/Replay/Replay.cpp
index 8745046fd805..6259e7afbb29 100644
--- a/Tools/Replay/Replay.cpp
+++ b/Tools/Replay/Replay.cpp
@@ -794,7 +794,8 @@ void Replay::loop()
         if (streq(type,"ATT")) {
             Vector3f ekf_euler;
             Vector3f velNED;
-            Vector3f posNED;
+            Vector2f posNE;
+            float posD;
             Vector3f gyroBias;
             float accelWeighting;
             float accelZBias1;
@@ -803,11 +804,10 @@ void Replay::loop()
             Vector3f magNED;
             Vector3f magXYZ;
             Vector3f DCM_attitude;
-            Vector3f ekf_relpos;
             Vector3f velInnov;
             Vector3f posInnov;
             Vector3f magInnov;
-            float    tasInnov;
+            float tasInnov;
             float velVar;
             float posVar;
             float hgtVar;
@@ -820,7 +820,8 @@ void Replay::loop()
             dcm_matrix.to_euler(&DCM_attitude.x, &DCM_attitude.y, &DCM_attitude.z);
             _vehicle.EKF.getEulerAngles(ekf_euler);
             _vehicle.EKF.getVelNED(velNED);
-            _vehicle.EKF.getPosNED(posNED);
+            _vehicle.EKF.getPosNE(posNE);
+            _vehicle.EKF.getPosD(posD);
             _vehicle.EKF.getGyroBias(gyroBias);
             _vehicle.EKF.getIMU1Weighting(accelWeighting);
             _vehicle.EKF.getAccelZBias(accelZBias1, accelZBias2);
@@ -830,7 +831,6 @@ void Replay::loop()
             _vehicle.EKF.getInnovations(velInnov, posInnov, magInnov, tasInnov);
             _vehicle.EKF.getVariances(velVar, posVar, hgtVar, magVar, tasVar, offset);
             _vehicle.EKF.getFilterFaults(faultStatus);
-            _vehicle.EKF.getPosNED(ekf_relpos);
             Vector3f inav_pos = _vehicle.inertial_nav.get_position() * 0.01f;
             float temp = degrees(ekf_euler.z);
 
@@ -858,9 +858,9 @@ void Replay::loop()
                     inav_pos.x,
                     inav_pos.y,
                     inav_pos.z,
-                    ekf_relpos.x,
-                    ekf_relpos.y,
-                    -ekf_relpos.z);
+                    posNE.x,
+                    posNE.y,
+                    -posD);
             fprintf(plotf2, "%.3f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f %.1f\n",
                     AP_HAL::millis() * 0.001f,
                     degrees(ekf_euler.x),
@@ -869,17 +869,17 @@ void Replay::loop()
                     velNED.x, 
                     velNED.y, 
                     velNED.z, 
-                    posNED.x, 
-                    posNED.y, 
-                    posNED.z, 
+                    posNE.x,
+                    posNE.y,
+                    posD,
                     60*degrees(gyroBias.x), 
                     60*degrees(gyroBias.y), 
                     60*degrees(gyroBias.z), 
                     windVel.x, 
                     windVel.y, 
-                    magNED.x, 
-                    magNED.y, 
-                    magNED.z, 
+                    magNED.x,
+                    magNED.y,
+                    magNED.z,
                     magXYZ.x, 
                     magXYZ.y, 
                     magXYZ.z,
@@ -894,9 +894,8 @@ void Replay::loop()
             float       velN  = (float)(velNED.x); // velocity North (m/s)
             float       velE  = (float)(velNED.y); // velocity East (m/s)
             float       velD  = (float)(velNED.z); // velocity Down (m/s)
-            float       posN  = (float)(posNED.x); // metres North
-            float       posE  = (float)(posNED.y); // metres East
-            float       posD  = (float)(posNED.z); // metres Down
+            float       posN  = (float)(posNE.x); // metres North
+            float       posE  = (float)(posNE.y); // metres East
             float       gyrX  = (float)(6000*degrees(gyroBias.x)); // centi-deg/min
             float       gyrY  = (float)(6000*degrees(gyroBias.y)); // centi-deg/min
             float       gyrZ  = (float)(6000*degrees(gyroBias.z)); // centi-deg/min
diff --git a/Tools/autotest/apmrover2.py b/Tools/autotest/apmrover2.py
index 4d891f54e991..f5fae73122ed 100644
--- a/Tools/autotest/apmrover2.py
+++ b/Tools/autotest/apmrover2.py
@@ -14,8 +14,8 @@
 homeloc = None
 
 def arm_rover(mavproxy, mav):
-    # wait for EKF to settle
-    wait_seconds(mav, 15)
+    # wait for EKF and GPS checks to pass
+    wait_seconds(mav, 30)
 
     mavproxy.send('arm throttle\n')
     mavproxy.expect('ARMED')
diff --git a/Tools/autotest/arducopter.py b/Tools/autotest/arducopter.py
index a0c43db654c4..9f977d3b5238 100644
--- a/Tools/autotest/arducopter.py
+++ b/Tools/autotest/arducopter.py
@@ -21,7 +21,7 @@
 
 homeloc = None
 num_wp = 0
-speedup_default = 5
+speedup_default = 10
 
 def hover(mavproxy, mav, hover_throttle=1500):
     mavproxy.send('rc 3 %u\n' % hover_throttle)
@@ -987,8 +987,8 @@ def fly_ArduCopter(binary, viewerip=None, map=False, valgrind=False, gdb=False):
         setup_rc(mavproxy)
         homeloc = mav.location()
 
-        # wait 10sec to allow EKF to settle
-        wait_seconds(mav, 10)
+        # wait for EKF and GPS checks to pass
+        wait_seconds(mav, 30)
 
         # Arm
         print("# Arm motors")
@@ -1340,8 +1340,8 @@ def fly_CopterAVC(binary, viewerip=None, map=False, valgrind=False, gdb=False):
         print("Lowering rotor speed")
         mavproxy.send('rc 8 1000\n')
 
-        # wait 20sec to allow EKF to settle
-        wait_seconds(mav, 20)
+        # wait for EKF and GPS checks to pass
+        wait_seconds(mav, 30)
 
         # Arm
         print("# Arm motors")
diff --git a/Tools/autotest/arduplane.py b/Tools/autotest/arduplane.py
index cc80ec9a6fa8..e977e4ad3756 100644
--- a/Tools/autotest/arduplane.py
+++ b/Tools/autotest/arduplane.py
@@ -17,8 +17,8 @@
 def takeoff(mavproxy, mav):
     '''takeoff get to 30m altitude'''
 
-    # wait for EKF to settle
-    wait_seconds(mav, 15)
+    # wait for EKF and GPS checks to pass
+    wait_seconds(mav, 30)
 
     mavproxy.send('arm throttle\n')
     mavproxy.expect('ARMED')
diff --git a/Tools/autotest/quadplane.py b/Tools/autotest/quadplane.py
index 982c8757fb8a..ed86347d7513 100644
--- a/Tools/autotest/quadplane.py
+++ b/Tools/autotest/quadplane.py
@@ -101,8 +101,8 @@ def fly_QuadPlane(binary, viewerip=None, map=False, valgrind=False, gdb=False):
         homeloc = mav.location()
         print("Home location: %s" % homeloc)
 
-        # wait for EKF to settle
-        wait_seconds(mav, 15)
+        # wait for EKF and GPS checks to pass
+        wait_seconds(mav, 30)
 
         mavproxy.send('arm throttle\n')
         mavproxy.expect('ARMED')
diff --git a/libraries/AP_AHRS/AP_AHRS.h b/libraries/AP_AHRS/AP_AHRS.h
index 099924d04fde..2cdb26dbe735 100644
--- a/libraries/AP_AHRS/AP_AHRS.h
+++ b/libraries/AP_AHRS/AP_AHRS.h
@@ -293,6 +293,18 @@ class AP_AHRS
         return false;
     }
 
+    // return a position relative to home in meters, North/East
+    // order. Return true if estimate is valid
+    virtual bool get_relative_position_NE(Vector2f &vecNE) const {
+        return false;
+    }
+
+    // return a Down position relative to home in meters
+    // Return true if estimate is valid
+    virtual bool get_relative_position_D(float &posD) const {
+        return false;
+    }
+
     // return ground speed estimate in meters/second. Used by ground vehicles.
     float groundspeed(void) {
         return groundspeed_vector().length();
diff --git a/libraries/AP_AHRS/AP_AHRS_NavEKF.cpp b/libraries/AP_AHRS/AP_AHRS_NavEKF.cpp
index f4134d3acadc..dde6a1e7b126 100644
--- a/libraries/AP_AHRS/AP_AHRS_NavEKF.cpp
+++ b/libraries/AP_AHRS/AP_AHRS_NavEKF.cpp
@@ -343,7 +343,7 @@ bool AP_AHRS_NavEKF::get_position(struct Location &loc) const
     switch (active_EKF_type()) {
 #if AP_AHRS_WITH_EKF1
     case EKF_TYPE1:
-        if (EKF1.getLLH(loc) && EKF1.getPosNED(ned_pos) && EKF1.getOriginLLH(origin)) {
+        if (EKF1.getLLH(loc) && EKF1.getPosD(ned_pos.z) && EKF1.getOriginLLH(origin)) {
             // fixup altitude using relative position from EKF origin
             loc.alt = origin.alt - ned_pos.z*100;
             return true;
@@ -351,7 +351,7 @@ bool AP_AHRS_NavEKF::get_position(struct Location &loc) const
         break;
 #endif
     case EKF_TYPE2:
-        if (EKF2.getLLH(loc) && EKF2.getPosNED(-1,ned_pos) && EKF2.getOriginLLH(origin)) {
+        if (EKF2.getLLH(loc) && EKF2.getPosD(-1,ned_pos.z) && EKF2.getOriginLLH(origin)) {
             // fixup altitude using relative position from EKF origin
             loc.alt = origin.alt - ned_pos.z*100;
             return true;
@@ -677,13 +677,27 @@ bool AP_AHRS_NavEKF::get_relative_position_NED(Vector3f &vec) const
         return false;
 
 #if AP_AHRS_WITH_EKF1
-    case EKF_TYPE1:
-        return EKF1.getPosNED(vec);
+    case EKF_TYPE1: {
+        Vector2f posNE;
+        float posD;
+        bool position_is_valid = (EKF1.getPosNE(posNE) && EKF1.getPosD(posD));
+        vec.x = posNE.x;
+        vec.y = posNE.y;
+        vec.z = posD;
+        return position_is_valid;
+    }
 #endif
 
     case EKF_TYPE2:
-    default:
-        return EKF2.getPosNED(-1,vec);
+    default: {
+        Vector2f posNE;
+        float posD;
+        bool position_is_valid = (EKF2.getPosNE(-1,posNE) && EKF2.getPosD(-1,posD));
+        vec.x = posNE.x;
+        vec.y = posNE.y;
+        vec.z = posD;
+        return position_is_valid;
+    }
 
 #if CONFIG_HAL_BOARD == HAL_BOARD_SITL
     case EKF_TYPE_SITL: {
@@ -699,6 +713,69 @@ bool AP_AHRS_NavEKF::get_relative_position_NED(Vector3f &vec) const
     }
 }
 
+// write a relative ground position estimate in meters, North/East order
+// return true if estimate is valid
+bool AP_AHRS_NavEKF::get_relative_position_NE(Vector2f &posNE) const
+{
+    switch (active_EKF_type()) {
+    case EKF_TYPE_NONE:
+        return false;
+
+#if AP_AHRS_WITH_EKF1
+    case EKF_TYPE1: {
+        bool position_is_valid = EKF1.getPosNE(posNE);
+        return position_is_valid;
+    }
+#endif
+
+    case EKF_TYPE2:
+    default: {
+        bool position_is_valid = EKF2.getPosNE(-1,posNE);
+        return position_is_valid;
+    }
+
+#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
+    case EKF_TYPE_SITL: {
+        Location loc;
+        get_position(loc);
+        posNE = location_diff(get_home(), loc);
+        return true;
+    }
+#endif
+    }
+}
+
+// write a relative ground position in meters, Down
+// return true if the estimate is valid
+bool AP_AHRS_NavEKF::get_relative_position_D(float &posD) const
+{
+    switch (active_EKF_type()) {
+    case EKF_TYPE_NONE:
+        return false;
+
+#if AP_AHRS_WITH_EKF1
+    case EKF_TYPE1: {
+        bool position_is_valid = EKF1.getPosD(posD);
+        return position_is_valid;
+    }
+#endif
+
+    case EKF_TYPE2:
+    default: {
+        bool position_is_valid = EKF2.getPosD(-1,posD);
+        return position_is_valid;
+    }
+
+#if CONFIG_HAL_BOARD == HAL_BOARD_SITL
+    case EKF_TYPE_SITL: {
+        const struct SITL::sitl_fdm &fdm = _sitl->state;
+        posD = -(fdm.altitude - get_home().alt*0.01f);
+        return true;
+    }
+#endif
+    }
+}
+
 /*
   canonicalise _ekf_type, forcing it to be 0, 1 or 2
  */
diff --git a/libraries/AP_AHRS/AP_AHRS_NavEKF.h b/libraries/AP_AHRS/AP_AHRS_NavEKF.h
index 782e2864f6f9..b798cf4eca77 100644
--- a/libraries/AP_AHRS/AP_AHRS_NavEKF.h
+++ b/libraries/AP_AHRS/AP_AHRS_NavEKF.h
@@ -140,6 +140,14 @@ class AP_AHRS_NavEKF : public AP_AHRS_DCM
     bool get_velocity_NED(Vector3f &vec) const;
     bool get_relative_position_NED(Vector3f &vec) const;
 
+    // return the relative position in North/East order
+    // return true if the estimate is valid
+    bool get_relative_position_NE(Vector2f &posNE) const;
+
+    // return the relative position in North/East order
+    // return true if the estimate is valid
+    bool get_relative_position_D(float &posD) const;
+
     // Get a derivative of the vertical position in m/s which is kinematically consistent with the vertical position is required by some control loops.
     // This is different to the vertical velocity from the EKF which is not always consistent with the verical position due to the various errors that are being corrected for.
     bool get_vert_pos_rate(float &velocity);
diff --git a/libraries/AP_InertialNav/AP_InertialNav_NavEKF.cpp b/libraries/AP_InertialNav/AP_InertialNav_NavEKF.cpp
index a8f551bdbb2e..5f6ad615bb55 100644
--- a/libraries/AP_InertialNav/AP_InertialNav_NavEKF.cpp
+++ b/libraries/AP_InertialNav/AP_InertialNav_NavEKF.cpp
@@ -16,19 +16,27 @@
 */
 void AP_InertialNav_NavEKF::update(float dt)
 {
-    // get the position relative to the local earth frame origin
-    if (_ahrs_ekf.get_relative_position_NED(_relpos_cm)) {
-        _relpos_cm *= 100; // convert to cm
-        _relpos_cm.z = - _relpos_cm.z; // InertialNav is NEU
+    // get the NE position relative to the local earth frame origin
+    Vector2f posNE;
+    if (_ahrs_ekf.get_relative_position_NE(posNE)) {
+        _relpos_cm.x = posNE.x * 100; // convert from m to cm
+        _relpos_cm.y = posNE.y * 100; // convert from m to cm
+    }
+
+    // get the D position relative to the local earth frame origin
+    float posD;
+    if (_ahrs_ekf.get_relative_position_D(posD)) {
+        _relpos_cm.z = - posD * 100; // convert from m in NED to cm in NEU
     }
 
     // get the absolute WGS-84 position
     _haveabspos = _ahrs_ekf.get_position(_abspos);
 
     // get the velocity relative to the local earth frame
-    if (_ahrs_ekf.get_velocity_NED(_velocity_cm)) {
-        _velocity_cm *= 100; // convert to cm/s
-        _velocity_cm.z = -_velocity_cm.z; // InertialNav is NEU
+    Vector3f velNED;
+    if (_ahrs_ekf.get_velocity_NED(velNED)) {
+        _velocity_cm = velNED * 100; // convert to cm/s
+        _velocity_cm.z = -_velocity_cm.z; // convert from NED to NEU
     }
 
     // Get a derivative of the vertical position which is kinematically consistent with the vertical position is required by some control loops.
diff --git a/libraries/AP_NavEKF/AP_NavEKF.cpp b/libraries/AP_NavEKF/AP_NavEKF.cpp
index 8f73ae3480dd..5e97b8c5aef3 100644
--- a/libraries/AP_NavEKF/AP_NavEKF.cpp
+++ b/libraries/AP_NavEKF/AP_NavEKF.cpp
@@ -470,15 +470,26 @@ bool NavEKF::healthy(void) const
     return core->healthy();
 }
 
-// Return the last calculated NED position relative to the reference point (m).
+// Write the last calculated North East position relative to the reference point (m).
 // If a calculated solution is not available, use the best available data and return false
 // If false returned, do not use for flight control
-bool NavEKF::getPosNED(Vector3f &pos) const
+bool NavEKF::getPosNE(Vector2f &posNE) const
 {
     if (!core) {
         return false;
     }
-    return core->getPosNED(pos);
+    return core->getPosNE(posNE);
+}
+
+// Write the last calculated Down position relative to the reference point (m).
+// If a calculated solution is not available, use the best available data and return false
+// If false returned, do not use for flight control
+bool NavEKF::getPosD(float &posD) const
+{
+    if (!core) {
+        return false;
+    }
+    return core->getPosD(posD);
 }
 
 // return NED velocity in m/s
diff --git a/libraries/AP_NavEKF/AP_NavEKF.h b/libraries/AP_NavEKF/AP_NavEKF.h
index 543746003e1c..6c34f22f8cc6 100644
--- a/libraries/AP_NavEKF/AP_NavEKF.h
+++ b/libraries/AP_NavEKF/AP_NavEKF.h
@@ -71,10 +71,15 @@ class NavEKF
     // Check basic filter health metrics and return a consolidated health status
     bool healthy(void) const;
 
-    // Return the last calculated NED position relative to the reference point (m).
+    // Write the last calculated North East position relative to the reference point (m).
     // If a calculated solution is not available, use the best available data and return false
     // If false returned, do not use for flight control
-    bool getPosNED(Vector3f &pos) const;
+    bool getPosNE(Vector2f &posNE) const;
+
+    // Write the last calculated Down position relative to the reference point (m).
+    // If a calculated solution is not available, use the best available data and return false
+    // If false returned, do not use for flight control
+    bool getPosD(float &posD) const;
 
     // return NED velocity in m/s
     void getVelNED(Vector3f &vel) const;
diff --git a/libraries/AP_NavEKF/AP_NavEKF_core.cpp b/libraries/AP_NavEKF/AP_NavEKF_core.cpp
index 36e675437197..e2b9146f24ef 100644
--- a/libraries/AP_NavEKF/AP_NavEKF_core.cpp
+++ b/libraries/AP_NavEKF/AP_NavEKF_core.cpp
@@ -445,6 +445,9 @@ void NavEKF_core::UpdateFilter()
     SelectTasFusion();
     SelectBetaFusion();
 
+    // Update the filter status
+    updateFilterStatus();
+
 end:
     // stop the timer used for load measurement
     hal.util->perf_end(_perf_UpdateFilter);
@@ -3355,19 +3358,15 @@ float NavEKF_core::getPosDownDerivative(void) const
     return posDownDerivative;
 }
 
-// Return the last calculated NED position relative to the reference point (m).
-// if a calculated solution is not available, use the best available data and return false
-bool NavEKF_core::getPosNED(Vector3f &pos) const
+// Write the last calculated NE position relative to the reference point (m).
+// Return true if the estimate is valid
+bool NavEKF_core::getPosNE(Vector2f &posNE) const
 {
-    // The EKF always has a height estimate regardless of mode of operation
-    pos.z = state.position.z;
     // There are three modes of operation, absolute position (GPS fusion), relative position (optical flow fusion) and constant position (no position estimate available)
-    nav_filter_status status;
-    getFilterStatus(status);
-    if (status.flags.horiz_pos_abs || status.flags.horiz_pos_rel) {
+    if (filterStatus.flags.horiz_pos_abs || filterStatus.flags.horiz_pos_rel) {
         // This is the normal mode of operation where we can use the EKF position states
-        pos.x = state.position.x;
-        pos.y = state.position.y;
+        posNE.x = state.position.x;
+        posNE.y = state.position.y;
         return true;
     } else {
         // In constant position mode the EKF position states are at the origin, so we cannot use them as a position estimate
@@ -3376,25 +3375,34 @@ bool NavEKF_core::getPosNED(Vector3f &pos) const
                 // If the origin has been set and we have GPS, then return the GPS position relative to the origin
                 const struct Location &gpsloc = _ahrs->get_gps().location();
                 Vector2f tempPosNE = location_diff(EKF_origin, gpsloc);
-                pos.x = tempPosNE.x;
-                pos.y = tempPosNE.y;
+                posNE.x = tempPosNE.x;
+                posNE.y = tempPosNE.y;
                 return false;
             } else {
                 // If no GPS fix is available, all we can do is provide the last known position
-                pos.x = state.position.x + lastKnownPositionNE.x;
-                pos.y = state.position.y + lastKnownPositionNE.y;
+                posNE.x = state.position.x + lastKnownPositionNE.x;
+                posNE.y = state.position.y + lastKnownPositionNE.y;
                 return false;
             }
         } else {
             // If the origin has not been set, then we have no means of providing a relative position
-            pos.x = 0.0f;
-            pos.y = 0.0f;
+            posNE.x = 0.0f;
+            posNE.y = 0.0f;
             return false;
         }
     }
     return false;
 }
 
+// Write the last calculated D position relative to the reference point (m).
+// Return true if the estimate is valid
+bool NavEKF_core::getPosD(float &posD) const
+{
+    // The EKF always has a height estimate regardless of mode of operation
+    posD = state.position.z;
+    return filterStatus.flags.vert_pos;
+}
+
 // return body axis gyro bias estimates in rad/sec
 void NavEKF_core::getGyroBias(Vector3f &gyroBias) const
 {
@@ -3543,9 +3551,7 @@ bool NavEKF_core::getLLH(struct Location &loc) const
         loc.flags.terrain_alt = 0;
 
         // there are three modes of operation, absolute position (GPS fusion), relative position (optical flow fusion) and constant position (no aiding)
-        nav_filter_status status;
-        getFilterStatus(status);
-        if (status.flags.horiz_pos_abs || status.flags.horiz_pos_rel) {
+        if (filterStatus.flags.horiz_pos_abs || filterStatus.flags.horiz_pos_rel) {
             loc.lat = EKF_origin.lat;
             loc.lng = EKF_origin.lng;
             location_offset(loc, state.position.x, state.position.y);
@@ -4515,6 +4521,7 @@ void NavEKF_core::InitialiseVariables()
     posResetNE.zero();
     velResetNE.zero();
     hgtInnovFiltState = 0.0f;
+    memset(&filterStatus, 0, sizeof(filterStatus));
 }
 
 // return true if we should use the airspeed sensor
@@ -4637,22 +4644,9 @@ void  NavEKF_core::getFilterGpsStatus(nav_gps_status &faults) const
     faults.flags.bad_horiz_vel      = gpsCheckStatus.bad_horiz_vel; // The GPS horizontal speed is excessive (check assumes the vehicle is static)
 }
 
-/*
-return filter function status as a bitmasked integer
- 0 = attitude estimate valid
- 1 = horizontal velocity estimate valid
- 2 = vertical velocity estimate valid
- 3 = relative horizontal position estimate valid
- 4 = absolute horizontal position estimate valid
- 5 = vertical position estimate valid
- 6 = terrain height estimate valid
- 7 = constant position mode
-*/
-void  NavEKF_core::getFilterStatus(nav_filter_status &status) const
+// Update the naigation filter status message
+void  NavEKF_core::updateFilterStatus(void)
 {
-    // init return value
-    status.value = 0;
-
     bool doingFlowNav = (PV_AidingMode == AID_RELATIVE) && flowDataValid;
     bool doingWindRelNav = !tasTimeout && assume_zero_sideslip();
     bool doingNormalGpsNav = !posTimeout && (PV_AidingMode == AID_ABSOLUTE);
@@ -4665,42 +4659,44 @@ void  NavEKF_core::getFilterStatus(nav_filter_status &status) const
     bool gyroHealthy = checkGyroHealthPreFlight();
 
     // set individual flags
-    status.flags.attitude = !state.quat.is_nan() && filterHealthy && gyroHealthy;   // attitude valid (we need a better check)
-    status.flags.horiz_vel = someHorizRefData && notDeadReckoning && filterHealthy;      // horizontal velocity estimate valid
-    status.flags.vert_vel = someVertRefData && filterHealthy;        // vertical velocity estimate valid
-    status.flags.horiz_pos_rel = ((doingFlowNav && gndOffsetValid) || doingWindRelNav || doingNormalGpsNav) && notDeadReckoning && filterHealthy;   // relative horizontal position estimate valid
-    status.flags.horiz_pos_abs = !gpsAidingBad && doingNormalGpsNav && notDeadReckoning && filterHealthy; // absolute horizontal position estimate valid
-    status.flags.vert_pos = !hgtTimeout && filterHealthy;            // vertical position estimate valid
-    status.flags.terrain_alt = gndOffsetValid && filterHealthy;		// terrain height estimate valid
-    status.flags.const_pos_mode = constPosMode && filterHealthy;     // constant position mode
-    status.flags.pred_horiz_pos_rel = (optFlowNavPossible || gpsNavPossible) && filterHealthy && gyroHealthy; // we should be able to estimate a relative position when we enter flight mode
-    status.flags.pred_horiz_pos_abs = gpsNavPossible && filterHealthy && gyroHealthy; // we should be able to estimate an absolute position when we enter flight mode
-    status.flags.takeoff_detected = takeOffDetected; // takeoff for optical flow navigation has been detected
-    status.flags.takeoff = expectGndEffectTakeoff; // The EKF has been told to expect takeoff and is in a ground effect mitigation mode
-    status.flags.touchdown = expectGndEffectTouchdown; // The EKF has been told to detect touchdown and is in a ground effect mitigation mode
-    status.flags.using_gps = (imuSampleTime_ms - lastPosPassTime) < 4000;
-    status.flags.gps_glitching = !gpsAccuracyGood; // The GPS is glitching
+    filterStatus.flags.attitude = !state.quat.is_nan() && filterHealthy && gyroHealthy;   // attitude valid (we need a better check)
+    filterStatus.flags.horiz_vel = someHorizRefData && notDeadReckoning && filterHealthy;      // horizontal velocity estimate valid
+    filterStatus.flags.vert_vel = someVertRefData && filterHealthy;        // vertical velocity estimate valid
+    filterStatus.flags.horiz_pos_rel = ((doingFlowNav && gndOffsetValid) || doingWindRelNav || doingNormalGpsNav) && notDeadReckoning && filterHealthy;   // relative horizontal position estimate valid
+    filterStatus.flags.horiz_pos_abs = !gpsAidingBad && doingNormalGpsNav && notDeadReckoning && filterHealthy; // absolute horizontal position estimate valid
+    filterStatus.flags.vert_pos = !hgtTimeout && filterHealthy;            // vertical position estimate valid
+    filterStatus.flags.terrain_alt = gndOffsetValid && filterHealthy;		// terrain height estimate valid
+    filterStatus.flags.const_pos_mode = constPosMode && filterHealthy;     // constant position mode
+    filterStatus.flags.pred_horiz_pos_rel = (optFlowNavPossible || gpsNavPossible) && filterHealthy && gyroHealthy; // we should be able to estimate a relative position when we enter flight mode
+    filterStatus.flags.pred_horiz_pos_abs = gpsNavPossible && filterHealthy && gyroHealthy; // we should be able to estimate an absolute position when we enter flight mode
+    filterStatus.flags.takeoff_detected = takeOffDetected; // takeoff for optical flow navigation has been detected
+    filterStatus.flags.takeoff = expectGndEffectTakeoff; // The EKF has been told to expect takeoff and is in a ground effect mitigation mode
+    filterStatus.flags.touchdown = expectGndEffectTouchdown; // The EKF has been told to detect touchdown and is in a ground effect mitigation mode
+    filterStatus.flags.using_gps = (imuSampleTime_ms - lastPosPassTime) < 4000;
+    filterStatus.flags.gps_glitching = !gpsAccuracyGood; // The GPS is glitching
 }
 
-// send an EKF_STATUS message to GCS
-void NavEKF_core::send_status_report(mavlink_channel_t chan)
+// Return the navigation filter status message
+void  NavEKF_core::getFilterStatus(nav_filter_status &status) const
 {
-    // get filter status
-    nav_filter_status filt_state;
-    getFilterStatus(filt_state);
+    status = filterStatus;
+}
 
+    // send an EKF_STATUS message to GCS
+void NavEKF_core::send_status_report(mavlink_channel_t chan)
+{
     // prepare flags
     uint16_t flags = 0;
-    if (filt_state.flags.attitude) { flags |= EKF_ATTITUDE; }
-    if (filt_state.flags.horiz_vel) { flags |= EKF_VELOCITY_HORIZ; }
-    if (filt_state.flags.vert_vel) { flags |= EKF_VELOCITY_VERT; }
-    if (filt_state.flags.horiz_pos_rel) { flags |= EKF_POS_HORIZ_REL; }
-    if (filt_state.flags.horiz_pos_abs) { flags |= EKF_POS_HORIZ_ABS; }
-    if (filt_state.flags.vert_pos) { flags |= EKF_POS_VERT_ABS; }
-    if (filt_state.flags.terrain_alt) { flags |= EKF_POS_VERT_AGL; }
-    if (filt_state.flags.const_pos_mode) { flags |= EKF_CONST_POS_MODE; }
-    if (filt_state.flags.pred_horiz_pos_rel) { flags |= EKF_PRED_POS_HORIZ_REL; }
-    if (filt_state.flags.pred_horiz_pos_abs) { flags |= EKF_PRED_POS_HORIZ_ABS; }
+    if (filterStatus.flags.attitude) { flags |= EKF_ATTITUDE; }
+    if (filterStatus.flags.horiz_vel) { flags |= EKF_VELOCITY_HORIZ; }
+    if (filterStatus.flags.vert_vel) { flags |= EKF_VELOCITY_VERT; }
+    if (filterStatus.flags.horiz_pos_rel) { flags |= EKF_POS_HORIZ_REL; }
+    if (filterStatus.flags.horiz_pos_abs) { flags |= EKF_POS_HORIZ_ABS; }
+    if (filterStatus.flags.vert_pos) { flags |= EKF_POS_VERT_ABS; }
+    if (filterStatus.flags.terrain_alt) { flags |= EKF_POS_VERT_AGL; }
+    if (filterStatus.flags.const_pos_mode) { flags |= EKF_CONST_POS_MODE; }
+    if (filterStatus.flags.pred_horiz_pos_rel) { flags |= EKF_PRED_POS_HORIZ_REL; }
+    if (filterStatus.flags.pred_horiz_pos_abs) { flags |= EKF_PRED_POS_HORIZ_ABS; }
 
     // get variances
     float velVar, posVar, hgtVar, tasVar;
diff --git a/libraries/AP_NavEKF/AP_NavEKF_core.h b/libraries/AP_NavEKF/AP_NavEKF_core.h
index bb3a716f731a..c3b84264195a 100644
--- a/libraries/AP_NavEKF/AP_NavEKF_core.h
+++ b/libraries/AP_NavEKF/AP_NavEKF_core.h
@@ -114,10 +114,15 @@ class NavEKF_core
     // Check basic filter health metrics and return a consolidated health status
     bool healthy(void) const;
 
-    // Return the last calculated NED position relative to the reference point (m).
+    // Write the last calculated NE position relative to the reference point (m).
     // If a calculated solution is not available, use the best available data and return false
     // If false returned, do not use for flight control
-    bool getPosNED(Vector3f &pos) const;
+    bool getPosNE(Vector2f &posNE) const;
+
+    // Write the last calculated D position relative to the reference point (m).
+    // If a calculated solution is not available, use the best available data and return false
+    // If false returned, do not use for flight control
+    bool getPosD(float &posD) const;
 
     // return NED velocity in m/s
     void getVelNED(Vector3f &vel) const;
@@ -259,9 +264,7 @@ class NavEKF_core
     */
     void  getFilterTimeouts(uint8_t &timeouts) const;
 
-    /*
-    return filter status flags
-    */
+    // return filter status flags
     void  getFilterStatus(nav_filter_status &status) const;
 
     /*
@@ -324,6 +327,9 @@ class NavEKF_core
         Vector3f    omega;          // 31 .. 33
     } &state;
 
+    // update the navigation filter status
+    void  updateFilterStatus(void);
+
     // update the quaternion, velocity and position states using IMU measurements
     void UpdateStrapdownEquationsNED();
 
@@ -697,6 +703,7 @@ class NavEKF_core
     Vector3f delAngBiasAtArming;    // value of the gyro delta angle bias at arming
     float hgtInnovFiltState;        // state used for fitering of the height innovations used for pre-flight checks
     Quaternion prevQuatMagReset;    // Quaternion from the previous frame that the magnetic field state reset condition test was performed
+    nav_filter_status filterStatus; // contains the status of various filter outputs
 
     // Used by smoothing of state corrections
     Vector10 gpsIncrStateDelta;    // vector of corrections to attitude, velocity and position to be applied over the period between the current and next GPS measurement
diff --git a/libraries/AP_NavEKF2/AP_NavEKF2.cpp b/libraries/AP_NavEKF2/AP_NavEKF2.cpp
index c9e532d31e6c..ca37330a1dcf 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2.cpp
+++ b/libraries/AP_NavEKF2/AP_NavEKF2.cpp
@@ -673,17 +673,28 @@ int8_t NavEKF2::getPrimaryCoreIndex(void) const
     return primary;
 }
 
+// Write the last calculated NE position relative to the reference point (m).
+// If a calculated solution is not available, use the best available data and return false
+// If false returned, do not use for flight control
+bool NavEKF2::getPosNE(int8_t instance, Vector2f &posNE)
+{
+    if (instance < 0 || instance >= num_cores) instance = primary;
+    if (!core) {
+        return false;
+    }
+    return core[instance].getPosNE(posNE);
+}
 
-// Return the last calculated NED position relative to the reference point (m).
+// Write the last calculated D position relative to the reference point (m).
 // If a calculated solution is not available, use the best available data and return false
 // If false returned, do not use for flight control
-bool NavEKF2::getPosNED(int8_t instance, Vector3f &pos)
+bool NavEKF2::getPosD(int8_t instance, float &posD)
 {
     if (instance < 0 || instance >= num_cores) instance = primary;
     if (!core) {
         return false;
     }
-    return core[instance].getPosNED(pos);
+    return core[instance].getPosD(posD);
 }
 
 // return NED velocity in m/s
diff --git a/libraries/AP_NavEKF2/AP_NavEKF2.h b/libraries/AP_NavEKF2/AP_NavEKF2.h
index 1485695bc4d6..4e0c9ee09d49 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2.h
+++ b/libraries/AP_NavEKF2/AP_NavEKF2.h
@@ -62,11 +62,17 @@ class NavEKF2
     // return -1 if no primary core selected
     int8_t getPrimaryCoreIndex(void) const;
 
-    // Return the last calculated NED position relative to the reference point (m) for the specified instance.
+    // Write the last calculated NE position relative to the reference point (m) for the specified instance.
     // An out of range instance (eg -1) returns data for the the primary instance
     // If a calculated solution is not available, use the best available data and return false
     // If false returned, do not use for flight control
-    bool getPosNED(int8_t instance, Vector3f &pos);
+    bool getPosNE(int8_t instance, Vector2f &posNE);
+
+    // Write the last calculated D position relative to the reference point (m) for the specified instance.
+    // An out of range instance (eg -1) returns data for the the primary instance
+    // If a calculated solution is not available, use the best available data and return false
+    // If false returned, do not use for flight control
+    bool getPosD(int8_t instance, float &posD);
 
     // return NED velocity in m/s for the specified instance
     // An out of range instance (eg -1) returns data for the the primary instance
diff --git a/libraries/AP_NavEKF2/AP_NavEKF2_Control.cpp b/libraries/AP_NavEKF2/AP_NavEKF2_Control.cpp
index 57b79a7d7179..48130ad5a9ab 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2_Control.cpp
+++ b/libraries/AP_NavEKF2/AP_NavEKF2_Control.cpp
@@ -157,29 +157,77 @@ void NavEKF2_core::setWindMagStateLearningMode()
 // Set inertial navigation aiding mode
 void NavEKF2_core::setAidingMode()
 {
-    // Determine when to commence aiding for inertial navigation
     // Save the previous status so we can detect when it has changed
-    prevIsAiding = isAiding;
-    // Don't allow filter to start position or velocity aiding until the tilt and yaw alignment is complete
-    bool filterIsStable = tiltAlignComplete && yawAlignComplete;
-    // If GPS usage has been prohiited then we use flow aiding provided optical flow data is present
-    bool useFlowAiding = (frontend->_fusionModeGPS == 3) && optFlowDataPresent();
-    // Start aiding if we have a source of aiding data and the filter attitude algnment is complete
-    // Latch to on
-    isAiding = ((readyToUseGPS() || useFlowAiding) && filterIsStable) || isAiding;
+    PV_AidingModePrev = PV_AidingMode;
+
+    // Determine if we should change aiding mode
+     if (PV_AidingMode == AID_NONE) {
+        // Don't allow filter to start position or velocity aiding until the tilt and yaw alignment is complete
+        // and IMU gyro bias estimates have stabilised
+        bool filterIsStable = tiltAlignComplete && yawAlignComplete && checkGyroCalStatus();
+        // If GPS usage has been prohiited then we use flow aiding provided optical flow data is present
+        // GPS aiding is the perferred option unless excluded by the user
+        if((frontend->_fusionModeGPS) != 3 && readyToUseGPS() && filterIsStable && !gpsInhibit) {
+            PV_AidingMode = AID_ABSOLUTE;
+        } else if ((frontend->_fusionModeGPS == 3) && optFlowDataPresent()) {
+            PV_AidingMode = AID_RELATIVE;
+        }
+    } else if (PV_AidingMode == AID_RELATIVE) {
+         // Check if the optical flow sensor has timed out
+         bool flowSensorTimeout = ((imuSampleTime_ms - flowValidMeaTime_ms) > 5000);
+         // Check if the fusion has timed out (flow measurements have been rejected for too long)
+         bool flowFusionTimeout = ((imuSampleTime_ms - prevFlowFuseTime_ms) > 5000);
+         if (flowSensorTimeout || flowFusionTimeout) {
+             PV_AidingMode = AID_NONE;
+         }
+     } else if (PV_AidingMode == AID_ABSOLUTE) {
+         // check if we can use opticalflow as a backup
+         bool optFlowBackupAvailable = (flowDataValid && !hgtTimeout);
+
+         // Set GPS time-out threshold depending on whether we have an airspeed sensor to constrain drift
+         uint16_t gpsRetryTimeout_ms = useAirspeed() ? frontend->gpsRetryTimeUseTAS_ms : frontend->gpsRetryTimeNoTAS_ms;
+
+         // Set the time that copters will fly without a GPS lock before failing the GPS and switching to a non GPS mode
+         uint16_t gpsFailTimeout_ms = optFlowBackupAvailable ? frontend->gpsFailTimeWithFlow_ms : gpsRetryTimeout_ms;
+
+         // If we haven't received GPS data for a while and we are using it for aiding, then declare the position and velocity data as being timed out
+         if (imuSampleTime_ms - lastTimeGpsReceived_ms > gpsFailTimeout_ms) {
+
+             // Let other processes know that GPS is not available and that a timeout has occurred
+             posTimeout = true;
+             velTimeout = true;
+             gpsNotAvailable = true;
+
+             // If we are totally reliant on GPS for navigation, then we need to switch to a non-GPS mode of operation
+             // If we don't have airspeed or sideslip assumption or optical flow to constrain drift, then go into constant position mode.
+             // If we can do optical flow nav (valid flow data and height above ground estimate), then go into flow nav mode.
+             if (!useAirspeed() && !assume_zero_sideslip()) {
+                 if (optFlowBackupAvailable) {
+                     // attempt optical flow navigation
+                     PV_AidingMode = AID_RELATIVE;
+                 } else {
+                     // put the filter into constant position mode
+                     PV_AidingMode = AID_NONE;
+                 }
+             }
+         } else if (gpsInhibit) {
+             // put the filter into constant position mode in response to an exernal request
+             PV_AidingMode = AID_NONE;
+         }
+     }
 
     // check to see if we are starting or stopping aiding and set states and modes as required
-    if (isAiding != prevIsAiding) {
-        // We have transitioned either into or out of aiding
-        // zero stored velocities used to do dead-reckoning
-        heldVelNE.zero();
+    if (PV_AidingMode != PV_AidingModePrev) {
         // set various  usage modes based on the condition when we start aiding. These are then held until aiding is stopped.
-        if (!isAiding) {
+        if (PV_AidingMode == AID_NONE) {
             // We have ceased aiding
+            hal.console->printf("EKF2 IMU%u has stopped aiding\n",(unsigned)imu_index);
             // When not aiding, estimate orientation & height fusing synthetic constant position and zero velocity measurement to constrain tilt errors
-            PV_AidingMode = AID_NONE;
             posTimeout = true;
-            velTimeout = true;
+            velTimeout = true;            
+            // Reset the normalised innovation to avoid false failing bad fusion tests
+            velTestRatio = 0.0f;
+            posTestRatio = 0.0f;
              // store the current position to be used to keep reporting the last known position
             lastKnownPositionNE.x = stateStruct.position.x;
             lastKnownPositionNE.y = stateStruct.position.y;
@@ -188,20 +236,18 @@ void NavEKF2_core::setAidingMode()
             meaHgtAtTakeOff = baroDataDelayed.hgt;
             // reset the vertical position state to faster recover from baro errors experienced during touchdown
             stateStruct.position.z = -meaHgtAtTakeOff;
-        } else if (frontend->_fusionModeGPS == 3) {
+        } else if (PV_AidingMode == AID_RELATIVE) {
             // We have commenced aiding, but GPS usage has been prohibited so use optical flow only
             hal.console->printf("EKF2 IMU%u is using optical flow\n",(unsigned)imu_index);
-            PV_AidingMode = AID_RELATIVE; // we have optical flow data and can estimate all vehicle states
             posTimeout = true;
             velTimeout = true;
             // Reset the last valid flow measurement time
             flowValidMeaTime_ms = imuSampleTime_ms;
             // Reset the last valid flow fusion time
             prevFlowFuseTime_ms = imuSampleTime_ms;
-        } else {
+        } else if (PV_AidingMode == AID_ABSOLUTE) {
             // We have commenced aiding and GPS usage is allowed
             hal.console->printf("EKF2 IMU%u is using GPS\n",(unsigned)imu_index);
-            PV_AidingMode = AID_ABSOLUTE; // we have GPS data and can estimate all vehicle states
             posTimeout = false;
             velTimeout = false;
             // we need to reset the GPS timers to prevent GPS timeout logic being invoked on entry into GPS aiding
@@ -211,18 +257,13 @@ void NavEKF2_core::setAidingMode()
             // reset the last valid position fix time to prevent unwanted activation of GPS glitch logic
             lastPosPassTime_ms = imuSampleTime_ms;
         }
-        // Reset the position and velocity
+
+        // Always reset the position and velocity when changing mode
         ResetVelocity();
         ResetPosition();
 
     }
 
-    // Always turn aiding off when the vehicle is disarmed
-    if (!isAiding) {
-        PV_AidingMode = AID_NONE;
-        posTimeout = true;
-        velTimeout = true;
-    }
 }
 
 // Check the tilt and yaw alignmnent status
@@ -272,7 +313,7 @@ bool NavEKF2_core::optFlowDataPresent(void) const
 // return true if the filter to be ready to use gps
 bool NavEKF2_core::readyToUseGPS(void) const
 {
-    return validOrigin && tiltAlignComplete && yawAlignComplete && gpsGoodToAlign && (frontend->_fusionModeGPS != 3);
+    return validOrigin && tiltAlignComplete && yawAlignComplete && gpsGoodToAlign && (frontend->_fusionModeGPS != 3) && gpsDataToFuse;
 }
 
 // return true if we should use the compass
@@ -295,7 +336,7 @@ bool NavEKF2_core::assume_zero_sideslip(void) const
 // set the LLH location of the filters NED origin
 bool NavEKF2_core::setOriginLLH(struct Location &loc)
 {
-    if (isAiding) {
+    if (PV_AidingMode == AID_ABSOLUTE) {
         return false;
     }
     EKF_origin = loc;
@@ -323,6 +364,17 @@ void NavEKF2_core::recordYawReset()
     }
 }
 
+// return true and set the class variable true if the delta angle bias has been learned
+bool NavEKF2_core::checkGyroCalStatus(void)
+{
+    // check delta angle bias variances
+    const float delAngBiasVarMax = sq(radians(0.15f * dtEkfAvg));
+    delAngBiasLearned =  (P[9][9] <= delAngBiasVarMax) &&
+                            (P[10][10] <= delAngBiasVarMax) &&
+                            (P[11][11] <= delAngBiasVarMax);
+    return delAngBiasLearned;
+}
+
 // Commands the EKF to not use GPS.
 // This command must be sent prior to arming
 // This command is forgotten by the EKF each time the vehicle disarms
@@ -331,16 +383,47 @@ void NavEKF2_core::recordYawReset()
 // Returns 2 if attitude, 3D-velocity, vertical position and relative horizontal position will be provided
 uint8_t NavEKF2_core::setInhibitGPS(void)
 {
-    if(!isAiding) {
+    if((PV_AidingMode == AID_ABSOLUTE) && motorsArmed) {
         return 0;
-    }
-    if (optFlowDataPresent()) {
-        frontend->_fusionModeGPS = 3;
-//#error writing to a tuning parameter
-        return 2;
     } else {
+        gpsInhibit = true;
         return 1;
     }
+    // option 2 is not yet implemented as it requires a deeper integration of optical flow and GPS operation
+}
+
+// Update the filter status
+void  NavEKF2_core::updateFilterStatus(void)
+{
+    // init return value
+    filterStatus.value = 0;
+    bool doingFlowNav = (PV_AidingMode == AID_RELATIVE) && flowDataValid;
+    bool doingWindRelNav = !tasTimeout && assume_zero_sideslip();
+    bool doingNormalGpsNav = !posTimeout && (PV_AidingMode == AID_ABSOLUTE);
+    bool someVertRefData = (!velTimeout && useGpsVertVel) || !hgtTimeout;
+    bool someHorizRefData = !(velTimeout && posTimeout && tasTimeout) || doingFlowNav;
+    bool optFlowNavPossible = flowDataValid && (frontend->_fusionModeGPS == 3) && delAngBiasLearned;
+    bool gpsNavPossible = !gpsNotAvailable && gpsGoodToAlign && delAngBiasLearned;
+    bool filterHealthy = healthy() && tiltAlignComplete && (yawAlignComplete || (!use_compass() && (PV_AidingMode == AID_NONE)));
+    // If GPS height usage is specified, height is considered to be inaccurate until the GPS passes all checks
+    bool hgtNotAccurate = (frontend->_altSource == 2) && !validOrigin;
+
+    // set individual flags
+    filterStatus.flags.attitude = !stateStruct.quat.is_nan() && filterHealthy;   // attitude valid (we need a better check)
+    filterStatus.flags.horiz_vel = someHorizRefData && filterHealthy;      // horizontal velocity estimate valid
+    filterStatus.flags.vert_vel = someVertRefData && filterHealthy;        // vertical velocity estimate valid
+    filterStatus.flags.horiz_pos_rel = ((doingFlowNav && gndOffsetValid) || doingWindRelNav || doingNormalGpsNav) && filterHealthy;   // relative horizontal position estimate valid
+    filterStatus.flags.horiz_pos_abs = doingNormalGpsNav && filterHealthy; // absolute horizontal position estimate valid
+    filterStatus.flags.vert_pos = !hgtTimeout && filterHealthy && !hgtNotAccurate; // vertical position estimate valid
+    filterStatus.flags.terrain_alt = gndOffsetValid && filterHealthy;		// terrain height estimate valid
+    filterStatus.flags.const_pos_mode = (PV_AidingMode == AID_NONE) && filterHealthy;     // constant position mode
+    filterStatus.flags.pred_horiz_pos_rel = ((optFlowNavPossible || gpsNavPossible) && filterHealthy) || filterStatus.flags.horiz_pos_rel; // we should be able to estimate a relative position when we enter flight mode
+    filterStatus.flags.pred_horiz_pos_abs = (gpsNavPossible && filterHealthy) || filterStatus.flags.horiz_pos_abs; // we should be able to estimate an absolute position when we enter flight mode
+    filterStatus.flags.takeoff_detected = takeOffDetected; // takeoff for optical flow navigation has been detected
+    filterStatus.flags.takeoff = expectGndEffectTakeoff; // The EKF has been told to expect takeoff and is in a ground effect mitigation mode
+    filterStatus.flags.touchdown = expectGndEffectTouchdown; // The EKF has been told to detect touchdown and is in a ground effect mitigation mode
+    filterStatus.flags.using_gps = ((imuSampleTime_ms - lastPosPassTime_ms) < 4000) && (PV_AidingMode == AID_ABSOLUTE);
+    filterStatus.flags.gps_glitching = !gpsAccuracyGood && (PV_AidingMode == AID_ABSOLUTE); // The GPS is glitching
 }
 
 #endif // HAL_CPU_CLASS
diff --git a/libraries/AP_NavEKF2/AP_NavEKF2_MagFusion.cpp b/libraries/AP_NavEKF2/AP_NavEKF2_MagFusion.cpp
index b3b589031964..d0f7c77c58df 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2_MagFusion.cpp
+++ b/libraries/AP_NavEKF2/AP_NavEKF2_MagFusion.cpp
@@ -27,6 +27,8 @@ void NavEKF2_core::controlMagYawReset()
     if (assume_zero_sideslip() && !finalInflightYawInit && inFlight ) {
         gpsYawResetRequest = true;
         return;
+    } else {
+        gpsYawResetRequest = false;
     }
 
     // Quaternion and delta rotation vector that are re-used for different calculations
@@ -96,7 +98,7 @@ void NavEKF2_core::controlMagYawReset()
         // and get an updated quaternion
         Quaternion newQuat = calcQuatAndFieldStates(eulerAngles.x, eulerAngles.y);
 
-        // if a yaw reset has been requested, apply the updated quaterniont the current state
+        // if a yaw reset has been requested, apply the updated quaternion to the current state
         if (magYawResetRequest) {
             // previous value used to calculate a reset delta
             Quaternion prevQuat = stateStruct.quat;
@@ -140,11 +142,11 @@ void NavEKF2_core::controlMagYawReset()
 // vector from GPS. It is used to align the yaw angle after launch or takeoff.
 void NavEKF2_core::realignYawGPS()
 {
-    // get quaternion from existing filter states and calculate roll, pitch and yaw angles
-    Vector3f eulerAngles;
-    stateStruct.quat.to_euler(eulerAngles.x, eulerAngles.y, eulerAngles.z);
-
     if ((sq(gpsDataDelayed.vel.x) + sq(gpsDataDelayed.vel.y)) > 25.0f) {
+        // get quaternion from existing filter states and calculate roll, pitch and yaw angles
+        Vector3f eulerAngles;
+        stateStruct.quat.to_euler(eulerAngles.x, eulerAngles.y, eulerAngles.z);
+
         // calculate course yaw angle
         float velYaw = atan2f(stateStruct.velocity.y,stateStruct.velocity.x);
 
@@ -162,6 +164,9 @@ void NavEKF2_core::realignYawGPS()
 
             // calculate new filter quaternion states from Euler angles
             stateStruct.quat.from_euler(eulerAngles.x, eulerAngles.y, gpsYaw);
+            // reset the velocity and posiiton states as they will be inaccurate due to bad yaw
+            ResetVelocity();
+            ResetPosition();
 
             // send yaw alignment information to console
             hal.console->printf("EKF2 IMU%u yaw aligned to GPS velocity\n",(unsigned)imu_index);
@@ -169,28 +174,21 @@ void NavEKF2_core::realignYawGPS()
             // zero the attitude covariances becasue the corelations will now be invalid
             zeroAttCovOnly();
 
-            // reset the position and velocity fusion timers to cause the states to be reset to the GPS on the next GPS fusion cycle
-            lastPosPassTime_ms = 0;
-            lastVelPassTime_ms = 0;
-
             // record the yaw reset event
             recordYawReset();
 
-            // clear any GPS yaw requests
+            // clear all pending yaw reset requests
             gpsYawResetRequest = false;
+            magYawResetRequest = false;
 
+            if (use_compass()) {
+                // request a mag field reset which may enable us to use the magnetoemter if the previous fault was due to bad initialisation
+                magStateResetRequest = true;
+                // clear the all sensors failed status so that the magnetometers sensors get a second chance now that we are flying
+                allMagSensorsFailed = false;
+            }
         }
     }
-
-    // fix magnetic field states and clear any compass fault conditions
-    if (use_compass()) {
-        // submit a request to reset the magnetic field states
-        magStateResetRequest = true;
-
-        // We shoud retry the primary magnetometer if previously switched or failed
-        magSelectIndex = 0;
-        allMagSensorsFailed = false;
-    }
 }
 
 /********************************************************
diff --git a/libraries/AP_NavEKF2/AP_NavEKF2_Measurements.cpp b/libraries/AP_NavEKF2/AP_NavEKF2_Measurements.cpp
index 34e46bccaf64..f027206e7743 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2_Measurements.cpp
+++ b/libraries/AP_NavEKF2/AP_NavEKF2_Measurements.cpp
@@ -185,7 +185,13 @@ void NavEKF2_core::readMagData()
                     stateStruct.body_magfield.zero();
                     // clear the measurement buffer
                     storedMag.reset();
-                    }
+                    // clear the data waiting flag so that we do not use any data pending from the previous sensor
+                    magDataToFuse = false;
+                    // request a reset of the magnetic field states
+                    magStateResetRequest = true;
+                    // declare the field unlearned so that the reset request will be obeyed
+                    magFieldLearned = false;
+                }
             }
         }
 
@@ -417,6 +423,8 @@ void NavEKF2_core::readGpsData()
             if (PV_AidingMode != AID_ABSOLUTE) {
                 // Pre-alignment checks
                 gpsGoodToAlign = calcGpsGoodToAlign();
+            } else {
+                gpsGoodToAlign = false;
             }
 
             // Post-alignment checks
@@ -454,54 +462,6 @@ void NavEKF2_core::readGpsData()
             gpsCheckStatus.bad_fix = true;
         }
     }
-
-    // We need to handle the case where GPS is lost for a period of time that is too long to dead-reckon
-    // If that happens we need to put the filter into a constant position mode, reset the velocity states to zero
-    // and use the last estimated position as a synthetic GPS position
-
-    // check if we can use opticalflow as a backup
-    bool optFlowBackupAvailable = (flowDataValid && !hgtTimeout);
-
-    // Set GPS time-out threshold depending on whether we have an airspeed sensor to constrain drift
-    uint16_t gpsRetryTimeout_ms = useAirspeed() ? frontend->gpsRetryTimeUseTAS_ms : frontend->gpsRetryTimeNoTAS_ms;
-
-    // Set the time that copters will fly without a GPS lock before failing the GPS and switching to a non GPS mode
-    uint16_t gpsFailTimeout_ms = optFlowBackupAvailable ? frontend->gpsFailTimeWithFlow_ms : gpsRetryTimeout_ms;
-
-    // If we haven't received GPS data for a while and we are using it for aiding, then declare the position and velocity data as being timed out
-    if (imuSampleTime_ms - lastTimeGpsReceived_ms > gpsFailTimeout_ms) {
-
-        // Let other processes know that GPS is not available and that a timeout has occurred
-        posTimeout = true;
-        velTimeout = true;
-        gpsNotAvailable = true;
-
-        // If we are totally reliant on GPS for navigation, then we need to switch to a non-GPS mode of operation
-        // If we don't have airspeed or sideslip assumption or optical flow to constrain drift, then go into constant position mode.
-        // If we can do optical flow nav (valid flow data and height above ground estimate), then go into flow nav mode.
-        if (PV_AidingMode == AID_ABSOLUTE && !useAirspeed() && !assume_zero_sideslip()) {
-            if (optFlowBackupAvailable) {
-                // we can do optical flow only nav
-                frontend->_fusionModeGPS = 3;
-                PV_AidingMode = AID_RELATIVE;
-            } else {
-                // store the current position
-                lastKnownPositionNE.x = stateStruct.position.x;
-                lastKnownPositionNE.y = stateStruct.position.y;
-
-                // put the filter into constant position mode
-                PV_AidingMode = AID_NONE;
-
-                // Reset the velocity and position states
-                ResetVelocity();
-                ResetPosition();
-
-                // Reset the normalised innovation to avoid false failing bad fusion tests
-                velTestRatio = 0.0f;
-                posTestRatio = 0.0f;
-            }
-        }
-    }
 }
 
 // read the delta angle and corresponding time interval from the IMU
@@ -534,7 +494,7 @@ void NavEKF2_core::readBaroData()
 
         // If we are in takeoff mode, the height measurement is limited to be no less than the measurement at start of takeoff
         // This prevents negative baro disturbances due to copter downwash corrupting the EKF altitude during initial ascent
-        if (isAiding && getTakeoffExpected()) {
+        if (getTakeoffExpected()) {
             baroDataNew.hgt = MAX(baroDataNew.hgt, meaHgtAtTakeOff);
         }
 
diff --git a/libraries/AP_NavEKF2/AP_NavEKF2_OptFlowFusion.cpp b/libraries/AP_NavEKF2/AP_NavEKF2_OptFlowFusion.cpp
index 17a327ded855..5dac887b1b79 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2_OptFlowFusion.cpp
+++ b/libraries/AP_NavEKF2/AP_NavEKF2_OptFlowFusion.cpp
@@ -39,33 +39,17 @@ void NavEKF2_core::SelectFlowFusion()
     // Perform Data Checks
     // Check if the optical flow data is still valid
     flowDataValid = ((imuSampleTime_ms - flowValidMeaTime_ms) < 1000);
-    // Check if the optical flow sensor has timed out
-    bool flowSensorTimeout = ((imuSampleTime_ms - flowValidMeaTime_ms) > 5000);
-    // Check if the fusion has timed out (flow measurements have been rejected for too long)
-    bool flowFusionTimeout = ((imuSampleTime_ms - prevFlowFuseTime_ms) > 5000);
     // check is the terrain offset estimate is still valid
     gndOffsetValid = ((imuSampleTime_ms - gndHgtValidTime_ms) < 5000);
     // Perform tilt check
     bool tiltOK = (Tnb_flow.c.z > frontend->DCM33FlowMin);
-    // Constrain measurements to zero if we are using optical flow and are on the ground
-    if (frontend->_fusionModeGPS == 3 && !takeOffDetected && isAiding) {
+    // Constrain measurements to zero if we are on the ground
+    if (frontend->_fusionModeGPS == 3 && !takeOffDetected) {
         ofDataDelayed.flowRadXYcomp.zero();
         ofDataDelayed.flowRadXY.zero();
         flowDataValid = true;
     }
 
-    // If the flow measurements have been rejected for too long and we are relying on them, then revert to constant position mode
-    if ((flowSensorTimeout || flowFusionTimeout) && PV_AidingMode == AID_RELATIVE) {
-        PV_AidingMode = AID_NONE;
-        // reset the velocity
-        ResetVelocity();
-        // store the current position to be used to as a sythetic position measurement
-        lastKnownPositionNE.x = stateStruct.position.x;
-        lastKnownPositionNE.y = stateStruct.position.y;
-        // reset the position
-        ResetPosition();
-    }
-
     // if we do have valid flow measurements, fuse data into a 1-state EKF to estimate terrain height
     // we don't do terrain height estimation in optical flow only mode as the ground becomes our zero height reference
     if ((flowDataToFuse || rangeDataToFuse) && tiltOK) {
diff --git a/libraries/AP_NavEKF2/AP_NavEKF2_Outputs.cpp b/libraries/AP_NavEKF2/AP_NavEKF2_Outputs.cpp
index 1249c5f16ee9..acb7d15a914c 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2_Outputs.cpp
+++ b/libraries/AP_NavEKF2/AP_NavEKF2_Outputs.cpp
@@ -209,19 +209,15 @@ void NavEKF2_core::getAccelZBias(float &zbias) const {
     }
 }
 
-// Return the last calculated NED position relative to the reference point (m).
-// if a calculated solution is not available, use the best available data and return false
-bool NavEKF2_core::getPosNED(Vector3f &pos) const
+// Write the last estimated NE position relative to the reference point (m).
+// Return true if the estimate is valid
+bool NavEKF2_core::getPosNE(Vector2f &posNE) const
 {
-    // The EKF always has a height estimate regardless of mode of operation
-    pos.z = outputDataNew.position.z;
     // There are three modes of operation, absolute position (GPS fusion), relative position (optical flow fusion) and constant position (no position estimate available)
-    nav_filter_status status;
-    getFilterStatus(status);
     if (PV_AidingMode != AID_NONE) {
         // This is the normal mode of operation where we can use the EKF position states
-        pos.x = outputDataNew.position.x;
-        pos.y = outputDataNew.position.y;
+        posNE.x = outputDataNew.position.x;
+        posNE.y = outputDataNew.position.y;
         return true;
     } else {
         // In constant position mode the EKF position states are at the origin, so we cannot use them as a position estimate
@@ -230,26 +226,36 @@ bool NavEKF2_core::getPosNED(Vector3f &pos) const
                 // If the origin has been set and we have GPS, then return the GPS position relative to the origin
                 const struct Location &gpsloc = _ahrs->get_gps().location();
                 Vector2f tempPosNE = location_diff(EKF_origin, gpsloc);
-                pos.x = tempPosNE.x;
-                pos.y = tempPosNE.y;
+                posNE.x = tempPosNE.x;
+                posNE.y = tempPosNE.y;
                 return false;
             } else {
                 // If no GPS fix is available, all we can do is provide the last known position
-                pos.x = outputDataNew.position.x;
-                pos.y = outputDataNew.position.y;
+                posNE.x = outputDataNew.position.x;
+                posNE.y = outputDataNew.position.y;
                 return false;
             }
         } else {
             // If the origin has not been set, then we have no means of providing a relative position
-            pos.x = 0.0f;
-            pos.y = 0.0f;
+            posNE.x = 0.0f;
+            posNE.y = 0.0f;
             return false;
         }
     }
     return false;
 }
 
+// Write the last calculated D position relative to the reference point (m).
+// Return true if the estimte is valid
+bool NavEKF2_core::getPosD(float &posD) const
+{
+    // The EKF always has a height estimate regardless of mode of operation
+    posD = outputDataNew.position.z;
+
+    // Return the current height solution status
+    return filterStatus.flags.vert_pos;
 
+}
 // return the estimated height above ground level
 bool NavEKF2_core::getHAGL(float &HAGL) const
 {
@@ -272,9 +278,7 @@ bool NavEKF2_core::getLLH(struct Location &loc) const
         loc.flags.terrain_alt = 0;
 
         // there are three modes of operation, absolute position (GPS fusion), relative position (optical flow fusion) and constant position (no aiding)
-        nav_filter_status status;
-        getFilterStatus(status);
-        if (status.flags.horiz_pos_abs || status.flags.horiz_pos_rel) {
+        if (filterStatus.flags.horiz_pos_abs || filterStatus.flags.horiz_pos_rel) {
             loc.lat = EKF_origin.lat;
             loc.lng = EKF_origin.lng;
             location_offset(loc, outputDataNew.position.x, outputDataNew.position.y);
@@ -448,45 +452,10 @@ void  NavEKF2_core::getFilterTimeouts(uint8_t &timeouts) const
                 tasTimeout<<4);
 }
 
-/*
-Return a filter function status that indicates:
-    Which outputs are valid
-    If the filter has detected takeoff
-    If the filter has activated the mode that mitigates against ground effect static pressure errors
-    If GPS data is being used
-*/
+// Return the navigation filter status message
 void  NavEKF2_core::getFilterStatus(nav_filter_status &status) const
 {
-    // init return value
-    status.value = 0;
-
-    bool doingFlowNav = (PV_AidingMode == AID_RELATIVE) && flowDataValid;
-    bool doingWindRelNav = !tasTimeout && assume_zero_sideslip();
-    bool doingNormalGpsNav = !posTimeout && (PV_AidingMode == AID_ABSOLUTE);
-    bool someVertRefData = (!velTimeout && useGpsVertVel) || !hgtTimeout;
-    bool someHorizRefData = !(velTimeout && posTimeout && tasTimeout) || doingFlowNav;
-    bool optFlowNavPossible = flowDataValid && (frontend->_fusionModeGPS == 3);
-    bool gpsNavPossible = !gpsNotAvailable && gpsGoodToAlign;
-    bool filterHealthy = healthy() && tiltAlignComplete && (yawAlignComplete || (!use_compass() && (PV_AidingMode == AID_NONE)));
-    // If GPS height usage is specified, height is considered to be inaccurate until the GPS passes all checks
-    bool hgtNotAccurate = (frontend->_altSource == 2) && !validOrigin;
-
-    // set individual flags
-    status.flags.attitude = !stateStruct.quat.is_nan() && filterHealthy;   // attitude valid (we need a better check)
-    status.flags.horiz_vel = someHorizRefData && filterHealthy;      // horizontal velocity estimate valid
-    status.flags.vert_vel = someVertRefData && filterHealthy;        // vertical velocity estimate valid
-    status.flags.horiz_pos_rel = ((doingFlowNav && gndOffsetValid) || doingWindRelNav || doingNormalGpsNav) && filterHealthy;   // relative horizontal position estimate valid
-    status.flags.horiz_pos_abs = doingNormalGpsNav && filterHealthy; // absolute horizontal position estimate valid
-    status.flags.vert_pos = !hgtTimeout && filterHealthy && !hgtNotAccurate; // vertical position estimate valid
-    status.flags.terrain_alt = gndOffsetValid && filterHealthy;		// terrain height estimate valid
-    status.flags.const_pos_mode = (PV_AidingMode == AID_NONE) && filterHealthy;     // constant position mode
-    status.flags.pred_horiz_pos_rel = ((optFlowNavPossible || gpsNavPossible) && filterHealthy) || status.flags.horiz_pos_rel; // we should be able to estimate a relative position when we enter flight mode
-    status.flags.pred_horiz_pos_abs = (gpsNavPossible && filterHealthy) || status.flags.horiz_pos_abs; // we should be able to estimate an absolute position when we enter flight mode
-    status.flags.takeoff_detected = takeOffDetected; // takeoff for optical flow navigation has been detected
-    status.flags.takeoff = expectGndEffectTakeoff; // The EKF has been told to expect takeoff and is in a ground effect mitigation mode
-    status.flags.touchdown = expectGndEffectTouchdown; // The EKF has been told to detect touchdown and is in a ground effect mitigation mode
-    status.flags.using_gps = ((imuSampleTime_ms - lastPosPassTime_ms) < 4000) && (PV_AidingMode == AID_ABSOLUTE);
-    status.flags.gps_glitching = !gpsAccuracyGood && (PV_AidingMode == AID_ABSOLUTE); // The GPS is glitching
+    status = filterStatus;
 }
 
 /*
@@ -512,40 +481,36 @@ void  NavEKF2_core::getFilterGpsStatus(nav_gps_status &faults) const
 // send an EKF_STATUS message to GCS
 void NavEKF2_core::send_status_report(mavlink_channel_t chan)
 {
-    // get filter status
-    nav_filter_status filt_state;
-    getFilterStatus(filt_state);
-
     // prepare flags
     uint16_t flags = 0;
-    if (filt_state.flags.attitude) {
+    if (filterStatus.flags.attitude) {
         flags |= EKF_ATTITUDE;
     }
-    if (filt_state.flags.horiz_vel) {
+    if (filterStatus.flags.horiz_vel) {
         flags |= EKF_VELOCITY_HORIZ;
     }
-    if (filt_state.flags.vert_vel) {
+    if (filterStatus.flags.vert_vel) {
         flags |= EKF_VELOCITY_VERT;
     }
-    if (filt_state.flags.horiz_pos_rel) {
+    if (filterStatus.flags.horiz_pos_rel) {
         flags |= EKF_POS_HORIZ_REL;
     }
-    if (filt_state.flags.horiz_pos_abs) {
+    if (filterStatus.flags.horiz_pos_abs) {
         flags |= EKF_POS_HORIZ_ABS;
     }
-    if (filt_state.flags.vert_pos) {
+    if (filterStatus.flags.vert_pos) {
         flags |= EKF_POS_VERT_ABS;
     }
-    if (filt_state.flags.terrain_alt) {
+    if (filterStatus.flags.terrain_alt) {
         flags |= EKF_POS_VERT_AGL;
     }
-    if (filt_state.flags.const_pos_mode) {
+    if (filterStatus.flags.const_pos_mode) {
         flags |= EKF_CONST_POS_MODE;
     }
-    if (filt_state.flags.pred_horiz_pos_rel) {
+    if (filterStatus.flags.pred_horiz_pos_rel) {
         flags |= EKF_PRED_POS_HORIZ_REL;
     }
-    if (filt_state.flags.pred_horiz_pos_abs) {
+    if (filterStatus.flags.pred_horiz_pos_abs) {
         flags |= EKF_PRED_POS_HORIZ_ABS;
     }
 
diff --git a/libraries/AP_NavEKF2/AP_NavEKF2_PosVelFusion.cpp b/libraries/AP_NavEKF2/AP_NavEKF2_PosVelFusion.cpp
index d14ed37f5b22..0706b3b0222f 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2_PosVelFusion.cpp
+++ b/libraries/AP_NavEKF2/AP_NavEKF2_PosVelFusion.cpp
@@ -27,7 +27,7 @@ void NavEKF2_core::ResetVelocity(void)
 
     if (PV_AidingMode != AID_ABSOLUTE) {
         stateStruct.velocity.zero();
-    } else if (!gpsNotAvailable) {
+    } else {
         // reset horizontal velocity states to the GPS velocity
         stateStruct.velocity.x  = gpsDataNew.vel.x; // north velocity from blended accel data
         stateStruct.velocity.y  = gpsDataNew.vel.y; // east velocity from blended accel data
@@ -68,7 +68,7 @@ void NavEKF2_core::ResetPosition(void)
         // reset all position state history to the last known position
         stateStruct.position.x = lastKnownPositionNE.x;
         stateStruct.position.y = lastKnownPositionNE.y;
-    } else if (!gpsNotAvailable) {
+    } else  {
         // write to state vector and compensate for offset  between last GPs measurement and the EKF time horizon
         stateStruct.position.x = gpsDataNew.pos.x  + 0.001f*gpsDataNew.vel.x*(float(imuDataDelayed.time_ms) - float(gpsDataNew.time_ms));
         stateStruct.position.y = gpsDataNew.pos.y  + 0.001f*gpsDataNew.vel.y*(float(imuDataDelayed.time_ms) - float(gpsDataNew.time_ms));
diff --git a/libraries/AP_NavEKF2/AP_NavEKF2_VehicleStatus.cpp b/libraries/AP_NavEKF2/AP_NavEKF2_VehicleStatus.cpp
index 10ab880f5e68..047196dd0924 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2_VehicleStatus.cpp
+++ b/libraries/AP_NavEKF2/AP_NavEKF2_VehicleStatus.cpp
@@ -38,7 +38,7 @@ bool NavEKF2_core::calcGpsGoodToAlign(void)
     if ((magTestRatio.x <= 1.0f && magTestRatio.y <= 1.0f && yawTestRatio <= 1.0f) || !consistentMagData) {
         magYawResetTimer_ms = imuSampleTime_ms;
     }
-    if (imuSampleTime_ms - magYawResetTimer_ms > 5000) {
+    if ((imuSampleTime_ms - magYawResetTimer_ms > 5000) && !motorsArmed) {
         // request reset of heading and magnetic field states
         magYawResetRequest = true;
         // reset timer to ensure that bad magnetometer data cannot cause a heading reset more often than every 5 seconds
diff --git a/libraries/AP_NavEKF2/AP_NavEKF2_core.cpp b/libraries/AP_NavEKF2/AP_NavEKF2_core.cpp
index 510875621069..4a7ea44566f1 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2_core.cpp
+++ b/libraries/AP_NavEKF2/AP_NavEKF2_core.cpp
@@ -176,10 +176,9 @@ void NavEKF2_core::InitialiseVariables()
     flowGyroBias.y = 0;
     heldVelNE.zero();
     PV_AidingMode = AID_NONE;
+    PV_AidingModePrev = AID_NONE;
     posTimeout = true;
     velTimeout = true;
-    isAiding = false;
-    prevIsAiding = false;
     memset(&faultStatus, 0, sizeof(faultStatus));
     hgtRate = 0.0f;
     mag_state.q0 = 1;
@@ -213,8 +212,8 @@ void NavEKF2_core::InitialiseVariables()
     tasStoreIndex = 0;
     ofStoreIndex = 0;
     delAngCorrection.zero();
-    velCorrection.zero();
-    posCorrection.zero();
+    velErrintegral.zero();
+    posErrintegral.zero();
     gpsGoodToAlign = false;
     gpsNotAvailable = true;
     motorsArmed = false;
@@ -262,6 +261,9 @@ void NavEKF2_core::InitialiseVariables()
     yawInnovAtLastMagReset = 0.0f;
     quatAtLastMagReset = stateStruct.quat;
     magFieldLearned = false;
+    delAngBiasLearned = false;
+    memset(&filterStatus, 0, sizeof(filterStatus));
+    gpsInhibit = false;
 
     // zero data buffers
     storedIMU.reset();
@@ -459,6 +461,9 @@ void NavEKF2_core::UpdateFilter(bool predict)
 
         // Update states using sideslip constraint assumption for fly-forward vehicles
         SelectBetaFusion();
+
+        // Update the filter status
+        updateFilterStatus();
     }
 
     // Wind output forward from the fusion to output time horizon
@@ -633,54 +638,47 @@ void NavEKF2_core::calcOutputStates()
         delAngCorrection = deltaAngErr * errorGain * dtIMUavg;
 
         // calculate velocity and position tracking errors
-        Vector3f velDelta = (stateStruct.velocity - outputDataDelayed.velocity);
-        Vector3f posDelta = (stateStruct.position - outputDataDelayed.position);
+        Vector3f velErr = (stateStruct.velocity - outputDataDelayed.velocity);
+        Vector3f posErr = (stateStruct.position - outputDataDelayed.position);
 
         // collect magnitude tracking error for diagnostics
         outputTrackError.x = deltaAngErr.length();
-        outputTrackError.y = velDelta.length();
-        outputTrackError.z = posDelta.length();
-
-        // If the user specifes a time constant for the position and velocity states then calculate and apply the position
-        // and velocity corrections immediately to the whole output history which takes longer to process but enables smaller
-        // time constants to be used. Else apply the corrections to the current state only using the same time constant
-        // used for the quaternion corrections.
-        if (frontend->_tauVelPosOutput > 0) {
-            // convert time constant from centi-seconds to seconds
-            float tauPosVel = constrain_float(0.01f*(float)frontend->_tauVelPosOutput, 0.1f, 0.5f);
-
-            // calculate a gain to track the EKF position states with the specified time constant
-            float velPosGain = dtEkfAvg / constrain_float(tauPosVel, dtEkfAvg, 10.0f);
-
-            // use a PI feedback to calculate a correction that will be applied to the output state history
-            posCorrection += posDelta * sq(velPosGain) * 0.1f; // I term
-            velCorrection += velDelta * sq(velPosGain) * 0.1f; // I term
-            velDelta *= velPosGain; // P term
-            posDelta *= velPosGain; // P term
-
-            // loop through the output filter state history and apply the corrections to the velocity and position states
-            // this method is too expensive to use for the attitude states due to the quaternion operations required
-            // but does not introduce a time delay in the 'correction loop' and allows smaller tracking time constants
-            // to be used
-            output_elements outputStates;
-            for (unsigned index=0; index < imu_buffer_length; index++) {
-                outputStates = storedOutput[index];
-
-                // a constant  velocity correction is applied
-                outputStates.velocity += velDelta + velCorrection;
-
-                // a constant position correction is applied
-                outputStates.position += posDelta + posCorrection;
-
-                // push the updated data to the buffer
-                storedOutput[index] = outputStates;
-            }
+        outputTrackError.y = velErr.length();
+        outputTrackError.z = posErr.length();
+
+        // convert user specified time constant from centi-seconds to seconds
+        float tauPosVel = constrain_float(0.01f*(float)frontend->_tauVelPosOutput, 0.1f, 0.5f);
+
+        // calculate a gain to track the EKF position states with the specified time constant
+        float velPosGain = dtEkfAvg / constrain_float(tauPosVel, dtEkfAvg, 10.0f);
+
+        // use a PI feedback to calculate a correction that will be applied to the output state history
+        posErrintegral += posErr;
+        velErrintegral += velErr;
+        Vector3f velCorrection = velErr * velPosGain + velErrintegral * sq(velPosGain) * 0.1f;
+        Vector3f posCorrection = posErr * velPosGain + posErrintegral * sq(velPosGain) * 0.1f;
 
-            // update output state to corrected values
-            //outputDataDelayed = storedOutput[storedIMU.get_oldest_index()];
-            outputDataNew = storedOutput[storedIMU.get_youngest_index()];
+        // loop through the output filter state history and apply the corrections to the velocity and position states
+        // this method is too expensive to use for the attitude states due to the quaternion operations required
+        // but does not introduce a time delay in the 'correction loop' and allows smaller tracking time constants
+        // to be used
+        output_elements outputStates;
+        for (unsigned index=0; index < imu_buffer_length; index++) {
+            outputStates = storedOutput[index];
 
+            // a constant  velocity correction is applied
+            outputStates.velocity += velCorrection;
+
+            // a constant position correction is applied
+            outputStates.position += posCorrection;
+
+            // push the updated data to the buffer
+            storedOutput[index] = outputStates;
         }
+
+        // update output state to corrected values
+        outputDataNew = storedOutput[storedIMU.get_youngest_index()];
+
     }
 }
 
diff --git a/libraries/AP_NavEKF2/AP_NavEKF2_core.h b/libraries/AP_NavEKF2/AP_NavEKF2_core.h
index 98502df69975..26078f776de2 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2_core.h
+++ b/libraries/AP_NavEKF2/AP_NavEKF2_core.h
@@ -66,10 +66,15 @@ class NavEKF2_core
     // Intended to be used by the front-end to determine which is the primary EKF
     float faultScore(void) const;
 
-    // Return the last calculated NED position relative to the reference point (m).
+    // Write the last calculated NE position relative to the reference point (m).
     // If a calculated solution is not available, use the best available data and return false
     // If false returned, do not use for flight control
-    bool getPosNED(Vector3f &pos) const;
+    bool getPosNE(Vector2f &posNE) const;
+
+    // Write the last calculated D position relative to the reference point (m).
+    // If a calculated solution is not available, use the best available data and return false
+    // If false returned, do not use for flight control
+    bool getPosD(float &posD) const;
 
     // return NED velocity in m/s
     void getVelNED(Vector3f &vel) const;
@@ -384,6 +389,9 @@ class NavEKF2_core
         uint32_t    time_ms;        // 4
     };
 
+    // update the navigation filter status
+    void  updateFilterStatus(void);
+
     // update the quaternion, velocity and position states using IMU measurements
     void UpdateStrapdownEquationsNED();
 
@@ -586,6 +594,9 @@ class NavEKF2_core
     // Assess GPS data quality and return true if good enough to align the EKF
     bool calcGpsGoodToAlign(void);
 
+    // return true and set the class variable true if the delta angle bias has been learned
+    bool checkGyroCalStatus(void);
+
     // update inflight calculaton that determines if GPS data is good enough for reliable navigation
     void calcGpsGoodForFlight(void);
 
@@ -722,8 +733,6 @@ class NavEKF2_core
     bool inhibitWindStates;         // true when wind states and covariances are to remain constant
     bool inhibitMagStates;          // true when magnetic field states and covariances are to remain constant
     bool gpsNotAvailable;           // bool true when valid GPS data is not available
-    bool isAiding;                  // true when the filter is fusing position, velocity or flow measurements
-    bool prevIsAiding;              // isAiding from previous frame
     struct Location EKF_origin;     // LLH origin of the NED axis system - do not change unless filter is reset
     bool validOrigin;               // true when the EKF origin is valid
     float gpsSpdAccuracy;           // estimated speed accuracy in m/s returned by the GPS receiver
@@ -764,8 +773,8 @@ class NavEKF2_core
     output_elements outputDataNew;  // output state data at the current time step
     output_elements outputDataDelayed; // output state data at the current time step
     Vector3f delAngCorrection;      // correction applied to delta angles used by output observer to track the EKF
-    Vector3f velCorrection;         // correction applied to velocities used by the output observer to track the EKF
-    Vector3f posCorrection;         // correction applied to positions used by the output observer to track the EKF
+    Vector3f velErrintegral;        // integral of output predictor NED velocity tracking error (m)
+    Vector3f posErrintegral;        // integral of output predictor NED position tracking error (m.sec)
     float innovYaw;                 // compass yaw angle innovation (rad)
     uint32_t timeTasReceived_ms;    // time last TAS data was received (msec)
     bool gpsGoodToAlign;            // true when the GPS quality can be used to initialise the navigation system
@@ -798,6 +807,8 @@ class NavEKF2_core
     bool magFieldLearned;           // true when the magnetic field has been learned
     Vector3f earthMagFieldVar;      // NED earth mag field variances for last learned field (mGauss^2)
     Vector3f bodyMagFieldVar;       // XYZ body mag field variances for last learned field (mGauss^2)
+    bool delAngBiasLearned;         // true when the gyro bias has been learned
+    nav_filter_status filterStatus; // contains the status of various filter outputs
 
     Vector3f outputTrackError;
 
@@ -870,7 +881,9 @@ class NavEKF2_core
                      AID_NONE=1,       // no aiding is being used so only attitude and height estimates are available. Either constVelMode or constPosMode must be used to constrain tilt drift.
                      AID_RELATIVE=2    // only optical flow aiding is being used so position estimates will be relative
                     };
-    AidingMode PV_AidingMode;           // Defines the preferred mode for aiding of velocity and position estimates from the INS
+    AidingMode PV_AidingMode;       // Defines the preferred mode for aiding of velocity and position estimates from the INS
+    AidingMode PV_AidingModePrev;   // Value of PV_AidingMode from the previous frame - used to detect transitions
+    bool gpsInhibit;                // externally set flag informing the EKF not to use the GPS
     bool gndOffsetValid;            // true when the ground offset state can still be considered valid
     Vector3f delAngBodyOF;          // bias corrected delta angle of the vehicle IMU measured summed across the time since the last OF measurement
     float delTimeOF;                // time that delAngBodyOF is summed across
diff --git a/libraries/DataFlash/LogFile.cpp b/libraries/DataFlash/LogFile.cpp
index cf973009e5e9..d7f8a68dd076 100644
--- a/libraries/DataFlash/LogFile.cpp
+++ b/libraries/DataFlash/LogFile.cpp
@@ -1131,7 +1131,8 @@ void DataFlash_Class::Log_Write_EKF(AP_AHRS_NavEKF &ahrs, bool optFlowEnabled)
     if (ahrs.get_NavEKF().enabled()) {
         // Write first EKF packet
         Vector3f euler;
-        Vector3f posNED;
+        Vector2f posNE;
+        float posD;
         Vector3f velNED;
         Vector3f dAngBias;
         Vector3f dVelBias;
@@ -1139,7 +1140,8 @@ void DataFlash_Class::Log_Write_EKF(AP_AHRS_NavEKF &ahrs, bool optFlowEnabled)
         float posDownDeriv;
         ahrs.get_NavEKF().getEulerAngles(euler);
         ahrs.get_NavEKF().getVelNED(velNED);
-        ahrs.get_NavEKF().getPosNED(posNED);
+        ahrs.get_NavEKF().getPosNE(posNE);
+        ahrs.get_NavEKF().getPosD(posD);
         ahrs.get_NavEKF().getGyroBias(gyroBias);
         posDownDeriv = ahrs.get_NavEKF().getPosDownDerivative();
         struct log_EKF1 pkt = {
@@ -1152,9 +1154,9 @@ void DataFlash_Class::Log_Write_EKF(AP_AHRS_NavEKF &ahrs, bool optFlowEnabled)
             velE    : (float)(velNED.y), // velocity East (m/s)
             velD    : (float)(velNED.z), // velocity Down (m/s)
             posD_dot : (float)(posDownDeriv), // first derivative of down position
-            posN    : (float)(posNED.x), // metres North
-            posE    : (float)(posNED.y), // metres East
-            posD    : (float)(posNED.z), // metres Down
+            posN    : (float)(posNE.x), // metres North
+            posE    : (float)(posNE.y), // metres East
+            posD    : (float)(posD), // metres Down
             gyrX    : (int16_t)(100*degrees(gyroBias.x)), // cd/sec, displayed as deg/sec due to format string
             gyrY    : (int16_t)(100*degrees(gyroBias.y)), // cd/sec, displayed as deg/sec due to format string
             gyrZ    : (int16_t)(100*degrees(gyroBias.z)) // cd/sec, displayed as deg/sec due to format string
@@ -1286,7 +1288,8 @@ void DataFlash_Class::Log_Write_EKF2(AP_AHRS_NavEKF &ahrs, bool optFlowEnabled)
     uint64_t time_us = AP_HAL::micros64();
 	// Write first EKF packet
     Vector3f euler;
-    Vector3f posNED;
+    Vector2f posNE;
+    float posD;
     Vector3f velNED;
     Vector3f dAngBias;
     Vector3f dVelBias;
@@ -1294,7 +1297,8 @@ void DataFlash_Class::Log_Write_EKF2(AP_AHRS_NavEKF &ahrs, bool optFlowEnabled)
     float posDownDeriv;
     ahrs.get_NavEKF2().getEulerAngles(0,euler);
     ahrs.get_NavEKF2().getVelNED(0,velNED);
-    ahrs.get_NavEKF2().getPosNED(0,posNED);
+    ahrs.get_NavEKF2().getPosNE(0,posNE);
+    ahrs.get_NavEKF2().getPosD(0,posD);
     ahrs.get_NavEKF2().getGyroBias(0,gyroBias);
     posDownDeriv = ahrs.get_NavEKF2().getPosDownDerivative(0);
     struct log_EKF1 pkt = {
@@ -1307,9 +1311,9 @@ void DataFlash_Class::Log_Write_EKF2(AP_AHRS_NavEKF &ahrs, bool optFlowEnabled)
         velE    : (float)(velNED.y), // velocity East (m/s)
         velD    : (float)(velNED.z), // velocity Down (m/s)
         posD_dot : (float)(posDownDeriv), // first derivative of down position
-        posN    : (float)(posNED.x), // metres North
-        posE    : (float)(posNED.y), // metres East
-        posD    : (float)(posNED.z), // metres Down
+        posN    : (float)(posNE.x), // metres North
+        posE    : (float)(posNE.y), // metres East
+        posD    : (float)(posD), // metres Down
         gyrX    : (int16_t)(100*degrees(gyroBias.x)), // cd/sec, displayed as deg/sec due to format string
         gyrY    : (int16_t)(100*degrees(gyroBias.y)), // cd/sec, displayed as deg/sec due to format string
         gyrZ    : (int16_t)(100*degrees(gyroBias.z)) // cd/sec, displayed as deg/sec due to format string
@@ -1445,7 +1449,8 @@ void DataFlash_Class::Log_Write_EKF2(AP_AHRS_NavEKF &ahrs, bool optFlowEnabled)
         // Write 6th EKF packet
         ahrs.get_NavEKF2().getEulerAngles(1,euler);
         ahrs.get_NavEKF2().getVelNED(1,velNED);
-        ahrs.get_NavEKF2().getPosNED(1,posNED);
+        ahrs.get_NavEKF2().getPosNE(1,posNE);
+        ahrs.get_NavEKF2().getPosD(1,posD);
         ahrs.get_NavEKF2().getGyroBias(1,gyroBias);
         posDownDeriv = ahrs.get_NavEKF2().getPosDownDerivative(1);
         struct log_EKF1 pkt6 = {
@@ -1458,9 +1463,9 @@ void DataFlash_Class::Log_Write_EKF2(AP_AHRS_NavEKF &ahrs, bool optFlowEnabled)
             velE    : (float)(velNED.y), // velocity East (m/s)
             velD    : (float)(velNED.z), // velocity Down (m/s)
             posD_dot : (float)(posDownDeriv), // first derivative of down position
-            posN    : (float)(posNED.x), // metres North
-            posE    : (float)(posNED.y), // metres East
-            posD    : (float)(posNED.z), // metres Down
+            posN    : (float)(posNE.x), // metres North
+            posE    : (float)(posNE.y), // metres East
+            posD    : (float)(posD), // metres Down
             gyrX    : (int16_t)(100*degrees(gyroBias.x)), // cd/sec, displayed as deg/sec due to format string
             gyrY    : (int16_t)(100*degrees(gyroBias.y)), // cd/sec, displayed as deg/sec due to format string
             gyrZ    : (int16_t)(100*degrees(gyroBias.z)) // cd/sec, displayed as deg/sec due to format string
