diff --git a/ext/standard/php_var.h b/ext/standard/php_var.h
index 4afefbe95aef..2e7c27330d31 100644
--- a/ext/standard/php_var.h
+++ b/ext/standard/php_var.h
@@ -48,6 +48,7 @@ struct php_unserialize_data {
 	void *last;
 	void *first_dtor;
 	void *last_dtor;
+	// In php 7.0, additional properties (if php_unserialize_data was passed) are found in a struct wrapping a pointer to this.
 };
 
 typedef struct php_serialize_data *php_serialize_data_t;
diff --git a/ext/standard/tests/serialize/bug70963.phpt b/ext/standard/tests/serialize/bug70963.phpt
index 93843c606bec..0bdfb2c4c9aa 100644
--- a/ext/standard/tests/serialize/bug70963.phpt
+++ b/ext/standard/tests/serialize/bug70963.phpt
@@ -6,7 +6,7 @@ var_dump(unserialize('a:2:{i:0;O:9:"exception":1:{s:16:"'."\0".'Exception'."\0".
 var_dump(unserialize('a:2:{i:0;O:9:"exception":1:{s:16:"'."\0".'Exception'."\0".'trace";s:4:"test";}i:1;r:3;}'));
 ?>
 --EXPECTF--
-array(1) {
+array(2) {
   [0]=>
   object(Exception)#%d (6) {
     ["message":protected]=>
@@ -22,8 +22,10 @@ array(1) {
     ["previous":"Exception":private]=>
     NULL
   }
+  [1]=>
+  string(4) "test"
 }
-array(1) {
+array(2) {
   [0]=>
   object(Exception)#%d (6) {
     ["message":protected]=>
@@ -39,4 +41,6 @@ array(1) {
     ["previous":"Exception":private]=>
     NULL
   }
+  [1]=>
+  string(4) "test"
 }
diff --git a/ext/standard/tests/serialize/bug72601.phpt b/ext/standard/tests/serialize/bug72601.phpt
new file mode 100644
index 000000000000..ce1f8c7f9de7
--- /dev/null
+++ b/ext/standard/tests/serialize/bug72601.phpt
@@ -0,0 +1,65 @@
+--TEST--
+__wakeup should be able to add dynamic properties without affecting other dynamic properties
+--FILE--
+<?php
+error_reporting(E_ALL|E_STRICT);
+
+class Obj {
+	// Testing $this->a being a dynamic property.
+
+	function __construct($a) {
+		$this->a = $a;
+	}
+
+	public function __wakeup() {
+		echo "Calling __wakeup\n";
+		for ($i = 0; $i < 10000; $i++) {
+			$this->{'b' . $i} = 42;
+		}
+	}
+}
+
+function main() {
+	$obj = new stdClass();
+	$obj->test = 'foo';
+	$variable = [new Obj($obj), new Obj($obj)];
+	$serialized = serialize($variable);
+	printf("%s\n", $serialized);
+	$unserialized = unserialize($serialized);
+	for ($i = 0; $i < 10000; $i++) {
+		if ($unserialized[0]->{'b' . $i} !== 42) {
+			echo "Fail 0 b$i\n";
+			return;
+		}
+		if ($unserialized[1]->{'b' . $i} !== 42) {
+			echo "Fail 1 b$i\n";
+			return;
+		}
+		unset($unserialized[0]->{'b' . $i});
+		unset($unserialized[1]->{'b' . $i});
+	}
+	var_dump($unserialized);
+}
+main();
+--EXPECTF--
+a:2:{i:0;O:3:"Obj":1:{s:1:"a";O:8:"stdClass":1:{s:4:"test";s:3:"foo";}}i:1;O:3:"Obj":1:{s:1:"a";r:3;}}
+Calling __wakeup
+Calling __wakeup
+array(2) {
+  [0]=>
+  object(Obj)#%d (1) {
+    ["a"]=>
+    object(stdClass)#%d (1) {
+      ["test"]=>
+      string(3) "foo"
+    }
+  }
+  [1]=>
+  object(Obj)#%d (1) {
+    ["a"]=>
+    object(stdClass)#%d (1) {
+      ["test"]=>
+      string(3) "foo"
+    }
+  }
+}
diff --git a/ext/standard/tests/serialize/bug72601_2.phpt b/ext/standard/tests/serialize/bug72601_2.phpt
new file mode 100644
index 000000000000..849e65f0abf8
--- /dev/null
+++ b/ext/standard/tests/serialize/bug72601_2.phpt
@@ -0,0 +1,33 @@
+--TEST--
+__wakeup can replace a copy of the object referring to the root node.
+--SKIPIF--
+--FILE--
+<?php
+/* This bug never happened, but adding this test to make sure that further changes to unserialize don't allow freeing the root in __wakeup. */
+class Obj {
+	function __construct($a) {
+		$this->a = $a;
+	}
+
+	public function __wakeup() {
+		echo "Calling __wakeup\n";
+		$this->a = "replaced";
+	}
+}
+
+$a = new stdClass();
+$a->obj = new Obj($a);;
+$serialized = serialize($a);
+printf("%s\n", $serialized);
+$unserialized = unserialize($serialized);
+var_dump($unserialized);
+--EXPECTF--
+O:8:"stdClass":1:{s:3:"obj";O:3:"Obj":1:{s:1:"a";r:1;}}
+Calling __wakeup
+object(stdClass)#%d (1) {
+  ["obj"]=>
+  object(Obj)#%d (1) {
+    ["a"]=>
+    string(8) "replaced"
+  }
+}
diff --git a/ext/standard/tests/serialize/bug72601_3.phpt b/ext/standard/tests/serialize/bug72601_3.phpt
new file mode 100644
index 000000000000..d8baef4e0cc8
--- /dev/null
+++ b/ext/standard/tests/serialize/bug72601_3.phpt
@@ -0,0 +1,50 @@
+--TEST--
+__wakeup should be able to modify dynamic properties without affecting copies of those properties
+--FILE--
+<?php
+error_reporting(E_ALL|E_STRICT);
+
+class Obj {
+	// Testing $this->a being a dynamic property.
+
+	function __construct($a) {
+		$this->a = $a;
+	}
+
+	public function __wakeup() {
+		echo "Calling __wakeup " . json_encode($this->a) . "\n";
+		$this->a = "roh";
+	}
+}
+
+function main() {
+	$obj = new stdClass();
+	$obj->c = null;
+    $variable = [new Obj($obj), new Obj($obj), $obj];
+	$serialized = serialize($variable);
+	printf("%s\n", $serialized);
+	$unserialized = unserialize($serialized);
+	var_dump($unserialized);
+}
+main();
+--EXPECTF--
+a:3:{i:0;O:3:"Obj":1:{s:1:"a";O:8:"stdClass":1:{s:1:"c";N;}}i:1;O:3:"Obj":1:{s:1:"a";r:3;}i:2;r:3;}
+Calling __wakeup {"c":null}
+Calling __wakeup {"c":null}
+array(3) {
+  [0]=>
+  object(Obj)#%d (1) {
+    ["a"]=>
+    string(3) "roh"
+  }
+  [1]=>
+  object(Obj)#%d (1) {
+    ["a"]=>
+    string(3) "roh"
+  }
+  [2]=>
+  object(stdClass)#%d (1) {
+    ["c"]=>
+    NULL
+  }
+}
diff --git a/ext/standard/var_unserializer.c b/ext/standard/var_unserializer.c
index 3fc074dd6ae2..29098aac42a0 100644
--- a/ext/standard/var_unserializer.c
+++ b/ext/standard/var_unserializer.c
@@ -40,6 +40,23 @@ typedef struct {
 	void *next;
 } var_dtor_entries;
 
+typedef struct {
+	zval data[VAR_ENTRIES_MAX];
+	zend_long used_slots;
+	void *next;
+} var_wakeup_entries;
+
+struct php_unserialize_data_extended {
+	php_unserialize_data_t inner;
+	// Additional properties.
+	void *first_wakeup;
+	void *last_wakeup;
+};
+
+typedef struct php_unserialize_data_extended *php_unserialize_data_extended_t;
+
+static zval *var_tmp_wakeup_var(php_unserialize_data_extended_t var_hashx_extended);
+
 static inline void var_push(php_unserialize_data_t *var_hashx, zval *rval)
 {
 	var_entries *var_hash = (*var_hashx)->last;
@@ -67,9 +84,20 @@ static inline void var_push(php_unserialize_data_t *var_hashx, zval *rval)
 PHPAPI void var_push_dtor(php_unserialize_data_t *var_hashx, zval *rval)
 {
 	zval *tmp_var = var_tmp_var(var_hashx);
-    if (!tmp_var) {
-        return;
-    }
+	if (!tmp_var) {
+		return;
+	}
+	ZVAL_COPY(tmp_var, rval);
+}
+
+/* Create a copy of rval (of type IS_OBJECT, with method "__wakeup" defined). Defer the call to __wakeup. */
+PHPAPI void var_push_wakeup(php_unserialize_data_extended_t var_hashx, zval *rval)
+{
+	/* TODO: This could be refactored into a common macro/data structures with var_tmp_var once the implementation is certain. */
+	zval *tmp_var = var_tmp_wakeup_var(var_hashx);
+	if (!tmp_var) {
+		return;
+	}
 	ZVAL_COPY(tmp_var, rval);
 }
 
@@ -99,6 +127,34 @@ PHPAPI zval *var_tmp_var(php_unserialize_data_t *var_hashx)
     return &var_hash->data[var_hash->used_slots++];
 }
 
+/* Create a temporary variable, for calling __wakeup() when unserialization is finished */
+static zval *var_tmp_wakeup_var(php_unserialize_data_extended_t var_hashx_extended)
+{
+	/* TODO: This could be refactored into a common macro/data structures with var_tmp_var once the implementation is certain. */
+	var_wakeup_entries *var_hash;
+
+	if (!var_hashx_extended) {
+		return NULL;
+	}
+
+	var_hash = var_hashx_extended->last_wakeup;
+	if (!var_hash || var_hash->used_slots == VAR_ENTRIES_MAX) {
+		var_hash = emalloc(sizeof(var_wakeup_entries));
+		var_hash->used_slots = 0;
+		var_hash->next = 0;
+
+		if (!var_hashx_extended->first_wakeup) {
+			var_hashx_extended->first_wakeup = var_hash;
+		} else {
+			((var_wakeup_entries *) var_hashx_extended->last_wakeup)->next = var_hash;
+		}
+
+		var_hashx_extended->last_wakeup = var_hash;
+	}
+	ZVAL_UNDEF(&var_hash->data[var_hash->used_slots]);
+	return &var_hash->data[var_hash->used_slots++];
+}
+
 PHPAPI void var_replace(php_unserialize_data_t *var_hashx, zval *ozval, zval *nzval)
 {
 	zend_long i;
@@ -137,6 +193,61 @@ static zval *var_access(php_unserialize_data_t *var_hashx, zend_long id)
 	return var_hash->data[id];
 }
 
+static int var_wakeup_all(php_unserialize_data_extended_t var_hashx_extended, const zend_bool is_cleanup)
+{
+	void *next;
+	zend_long i;
+	zval fname;
+	var_wakeup_entries *wakeup_hash;
+	zend_bool should_wakeup = !is_cleanup;
+	int ret = 1;
+	if (!var_hashx_extended) {
+		return 1;
+	}
+	wakeup_hash = var_hashx_extended->first_wakeup;
+
+#if VAR_ENTRIES_DBG
+	fprintf(stderr, "var_wakeup_all(%ld)\n", wakeup_hash?wakeup_hash->used_slots:-1L);
+#endif
+	if (!wakeup_hash) {
+		return 1;
+	}
+
+	if (!is_cleanup) {
+		ZVAL_STRINGL(&fname, "__wakeup", sizeof("__wakeup") - 1);
+	}
+
+
+	while (wakeup_hash) {
+		for (i = 0; i < wakeup_hash->used_slots; i++) {
+#if VAR_ENTRIES_DBG
+			fprintf(stderr, "var_wakeup_all __wakeup and dtor of copy(%p, %ld)\n", &wakeup_hash->data[i], (long) Z_REFCOUNT_P(&wakeup_hash->data[i]));
+#endif
+
+			if (should_wakeup) {
+				zval retval;
+				BG(serialize_lock)++;
+				call_user_function_ex(CG(function_table), &wakeup_hash->data[i], &fname, &retval, 0, 0, 1, NULL);
+				BG(serialize_lock)--;
+				zval_dtor(&retval);
+				if (EG(exception)) {
+					ret = 0; /* If there is an exception, don't call __wakeup() on the rest of the objects, but continue freeing the memory. */
+				}
+			}
+			zval_ptr_dtor(&wakeup_hash->data[i]);
+		}
+		next = wakeup_hash->next;
+		efree_size(wakeup_hash, sizeof(var_wakeup_entries));
+		wakeup_hash = next;
+	}
+	if (!is_cleanup) {
+		zval_dtor(&fname);
+	}
+	var_hashx_extended->first_wakeup = NULL;
+	return ret;
+}
+
+
 PHPAPI void var_destroy(php_unserialize_data_t *var_hashx)
 {
 	void *next;
@@ -238,7 +349,7 @@ static inline int unserialize_allowed_class(zend_string *class_name, HashTable *
 #define YYMARKER marker
 
 
-#line 246 "ext/standard/var_unserializer.re"
+#line 357 "ext/standard/var_unserializer.re"
 
 
 
@@ -301,7 +412,12 @@ static inline size_t parse_uiv(const unsigned char *p)
 #define UNSERIALIZE_PARAMETER zval *rval, const unsigned char **p, const unsigned char *max, php_unserialize_data_t *var_hash, HashTable *classes
 #define UNSERIALIZE_PASSTHRU rval, p, max, var_hash, classes
 
-static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, zend_long elements, int objprops)
+#define UNSERIALIZE_PARAMETER_EXTENDED zval *rval, const unsigned char **p, const unsigned char *max, php_unserialize_data_extended_t var_hash_extended, HashTable *classes
+#define UNSERIALIZE_PASSTHRU_EXTENDED rval, p, max, var_hash_extended, classes
+
+static int php_var_unserialize_ex_inner(UNSERIALIZE_PARAMETER_EXTENDED);
+
+static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER_EXTENDED, HashTable *ht, zend_long elements, int objprops)
 {
 	while (elements-- > 0) {
 		zval key, *data, d, *old_data;
@@ -309,7 +425,7 @@ static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTab
 
 		ZVAL_UNDEF(&key);
 
-		if (!php_var_unserialize_ex(&key, p, max, NULL, classes)) {
+		if (!php_var_unserialize_ex_inner(&key, p, max, NULL, classes)) {
 			zval_dtor(&key);
 			return 0;
 		}
@@ -323,7 +439,7 @@ static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTab
 numeric_key:
 				if (UNEXPECTED((old_data = zend_hash_index_find(ht, idx)) != NULL)) {
 					//??? update hash
-					var_push_dtor(var_hash, old_data);
+					var_push_dtor(&(var_hash_extended->inner), old_data);
 					data = zend_hash_index_update(ht, idx, &d);
 				} else {
 					data = zend_hash_index_add_new(ht, idx, &d);
@@ -334,7 +450,7 @@ static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTab
 				}
 				if (UNEXPECTED((old_data = zend_hash_find(ht, Z_STR(key))) != NULL)) {
 					//??? update hash
-					var_push_dtor(var_hash, old_data);
+					var_push_dtor(&(var_hash_extended->inner), old_data);
 					data = zend_hash_update(ht, Z_STR(key), &d);
 				} else {
 					data = zend_hash_add_new(ht, Z_STR(key), &d);
@@ -350,7 +466,7 @@ static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTab
 					if (Z_TYPE_P(old_data) == IS_INDIRECT) {
 						old_data = Z_INDIRECT_P(old_data);
 					}
-					var_push_dtor(var_hash, old_data);
+					var_push_dtor(&(var_hash_extended->inner), old_data);
 					data = zend_hash_update_ind(ht, Z_STR(key), &d);
 				} else {
 					data = zend_hash_add_new(ht, Z_STR(key), &d);
@@ -365,7 +481,7 @@ static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTab
 			}
 		}
 
-		if (!php_var_unserialize_ex(data, p, max, var_hash, classes)) {
+		if (!php_var_unserialize_ex_inner(data, p, max, var_hash_extended, classes)) {
 			zval_dtor(&key);
 			return 0;
 		}
@@ -377,7 +493,7 @@ static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTab
 				zend_hash_del_ind(ht, Z_STR(key));
 			}
 		} else {
-			var_push_dtor(var_hash, data);
+			var_push_dtor(&(var_hash_extended->inner), data);
 		}
 
 		zval_dtor(&key);
@@ -391,7 +507,7 @@ static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTab
 	return 1;
 }
 
-static inline int finish_nested_data(UNSERIALIZE_PARAMETER)
+static inline int finish_nested_data(UNSERIALIZE_PARAMETER_EXTENDED)
 {
 	if (*((*p)++) == '}')
 		return 1;
@@ -402,7 +518,7 @@ static inline int finish_nested_data(UNSERIALIZE_PARAMETER)
 	return 0;
 }
 
-static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
+static inline int object_custom(UNSERIALIZE_PARAMETER_EXTENDED, zend_class_entry *ce)
 {
 	zend_long datalen;
 
@@ -418,16 +534,16 @@ static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
 	if (ce->unserialize == NULL) {
 		zend_error(E_WARNING, "Class %s has no unserializer", ZSTR_VAL(ce->name));
 		object_init_ex(rval, ce);
-	} else if (ce->unserialize(rval, ce, (const unsigned char*)*p, datalen, (zend_unserialize_data *)var_hash) != SUCCESS) {
+	} else if (ce->unserialize(rval, ce, (const unsigned char*)*p, datalen, (zend_unserialize_data *)&(var_hash_extended->inner)) != SUCCESS) {
 		return 0;
 	}
 
 	(*p) += datalen;
 
-	return finish_nested_data(UNSERIALIZE_PASSTHRU);
+	return finish_nested_data(UNSERIALIZE_PASSTHRU_EXTENDED);
 }
 
-static inline zend_long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
+static inline zend_long object_common1(UNSERIALIZE_PARAMETER_EXTENDED, zend_class_entry *ce)
 {
 	zend_long elements;
 
@@ -450,10 +566,10 @@ static inline zend_long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *
 #ifdef PHP_WIN32
 # pragma optimize("", off)
 #endif
-static inline int object_common2(UNSERIALIZE_PARAMETER, zend_long elements)
+static inline int object_common2(UNSERIALIZE_PARAMETER_EXTENDED, zend_long elements)
 {
-	zval retval;
-	zval fname;
+	/* Allocates properties for an object, then defers a call to __wakeup if necessary */
+	/* Precondition: var_hash_extended != NULL */
 	HashTable *ht;
 
 	if (Z_TYPE_P(rval) != IS_OBJECT) {
@@ -462,26 +578,21 @@ static inline int object_common2(UNSERIALIZE_PARAMETER, zend_long elements)
 
 	ht = Z_OBJPROP_P(rval);
 	zend_hash_extend(ht, zend_hash_num_elements(ht) + elements, (ht->u.flags & HASH_FLAG_PACKED));
-	if (!process_nested_data(UNSERIALIZE_PASSTHRU, ht, elements, 1)) {
+	if (!process_nested_data(UNSERIALIZE_PASSTHRU_EXTENDED, ht, elements, 1)) {
 		return 0;
 	}
 
 	ZVAL_DEREF(rval);
 	if (Z_OBJCE_P(rval) != PHP_IC_ENTRY &&
 		zend_hash_str_exists(&Z_OBJCE_P(rval)->function_table, "__wakeup", sizeof("__wakeup")-1)) {
-		ZVAL_STRINGL(&fname, "__wakeup", sizeof("__wakeup") - 1);
-		BG(serialize_lock)++;
-		call_user_function_ex(CG(function_table), rval, &fname, &retval, 0, 0, 1, NULL);
-		BG(serialize_lock)--;
-		zval_dtor(&fname);
-		zval_dtor(&retval);
+		var_push_wakeup(var_hash_extended, rval); /* __wakeup will be called in post-order of the graph of zvals (child nodes first), after everything is initialized */
 	}
 
 	if (EG(exception)) {
 		return 0;
 	}
 
-	return finish_nested_data(UNSERIALIZE_PASSTHRU);
+	return finish_nested_data(UNSERIALIZE_PASSTHRU_EXTENDED);
 
 }
 #ifdef PHP_WIN32
@@ -497,6 +608,30 @@ PHPAPI int php_var_unserialize(zval *rval, const unsigned char **p, const unsign
 
 PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 {
+	struct php_unserialize_data_extended var_hash_extended_val;
+	php_unserialize_data_extended_t var_hash_extended;
+	if (var_hash != NULL) {
+		var_hash_extended_val.inner = *var_hash;
+		var_hash_extended_val.first_wakeup = NULL;
+		var_hash_extended_val.last_wakeup  = NULL;
+		var_hash_extended = &var_hash_extended_val;
+	} else {
+		var_hash_extended = NULL;
+	}
+
+	if (php_var_unserialize_ex_inner(UNSERIALIZE_PASSTHRU_EXTENDED) == 0) {
+		var_wakeup_all(var_hash_extended, 1); /* Free the copies of objects (which would call __wakeup) if we haven't already. */
+		return 0;
+	}
+	if (var_wakeup_all(var_hash_extended, 0) == 0) {
+		return 0;
+	}
+	return 1;
+}
+
+/* Unserialize a zval, deferring calls to __wakeup(). This was split out because many extensions call php_var_unserialize/php_var_unserialize_ex directly. */
+/* We ensure __wakeup is called at the very end, so that it doesn't modify/invalidate/delete the arrays/objects/references we are unserializing.. */
+static int php_var_unserialize_ex_inner(UNSERIALIZE_PARAMETER_EXTENDED) {
 	const unsigned char *cursor, *limit, *marker, *start;
 	zval *rval_ref;
 
@@ -507,14 +642,14 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 		return 0;
 	}
 
-	if (var_hash && (*p)[0] != 'R') {
-		var_push(var_hash, rval);
+	if (var_hash_extended && (*p)[0] != 'R') {
+		var_push(&(var_hash_extended->inner), rval);
 	}
 
 	start = cursor;
 
 
-#line 518 "ext/standard/var_unserializer.c"
+#line 653 "ext/standard/var_unserializer.c"
 {
 	YYCTYPE yych;
 	static const unsigned char yybm[] = {
@@ -574,9 +709,9 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy95;
 yy3:
-#line 884 "ext/standard/var_unserializer.re"
+#line 1019 "ext/standard/var_unserializer.re"
 	{ return 0; }
-#line 580 "ext/standard/var_unserializer.c"
+#line 715 "ext/standard/var_unserializer.c"
 yy4:
 	yych = *(YYMARKER = ++YYCURSOR);
 	if (yych == ':') goto yy89;
@@ -619,13 +754,13 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	goto yy3;
 yy14:
 	++YYCURSOR;
-#line 878 "ext/standard/var_unserializer.re"
+#line 1013 "ext/standard/var_unserializer.re"
 	{
 	/* this is the case where we have less data than planned */
 	php_error_docref(NULL, E_NOTICE, "Unexpected end of serialized data");
 	return 0; /* not sure if it should be 0 or 1 here? */
 }
-#line 629 "ext/standard/var_unserializer.c"
+#line 764 "ext/standard/var_unserializer.c"
 yy16:
 	yych = *++YYCURSOR;
 	goto yy3;
@@ -655,7 +790,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	yych = *++YYCURSOR;
 	if (yych != '"') goto yy18;
 	++YYCURSOR;
-#line 733 "ext/standard/var_unserializer.re"
+#line 868 "ext/standard/var_unserializer.re"
 	{
 	size_t len, len2, len3, maxlen;
 	zend_long elements;
@@ -670,7 +805,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	zval retval;
 	zval args[1];
 
-    if (!var_hash) return 0;
+	if (!var_hash_extended) return 0;
 	if (*start == 'C') {
 		custom_object = 1;
 	}
@@ -782,7 +917,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	if (custom_object) {
 		int ret;
 
-		ret = object_custom(UNSERIALIZE_PASSTHRU, ce);
+		ret = object_custom(UNSERIALIZE_PASSTHRU_EXTENDED, ce);
 
 		if (ret && incomplete_class) {
 			php_store_class_name(rval, ZSTR_VAL(class_name), len2);
@@ -791,16 +926,16 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 		return ret;
 	}
 
-	elements = object_common1(UNSERIALIZE_PASSTHRU, ce);
+	elements = object_common1(UNSERIALIZE_PASSTHRU_EXTENDED, ce);
 
 	if (incomplete_class) {
 		php_store_class_name(rval, ZSTR_VAL(class_name), len2);
 	}
 	zend_string_release(class_name);
 
-	return object_common2(UNSERIALIZE_PASSTHRU, elements);
+	return object_common2(UNSERIALIZE_PASSTHRU_EXTENDED, elements);
 }
-#line 804 "ext/standard/var_unserializer.c"
+#line 939 "ext/standard/var_unserializer.c"
 yy25:
 	yych = *++YYCURSOR;
 	if (yych <= ',') {
@@ -825,14 +960,14 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	yych = *++YYCURSOR;
 	if (yych != '"') goto yy18;
 	++YYCURSOR;
-#line 726 "ext/standard/var_unserializer.re"
+#line 861 "ext/standard/var_unserializer.re"
 	{
-    if (!var_hash) return 0;
+	if (!var_hash_extended) return 0;
 
-	return object_common2(UNSERIALIZE_PASSTHRU,
-			object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR));
+	return object_common2(UNSERIALIZE_PASSTHRU_EXTENDED,
+			object_common1(UNSERIALIZE_PASSTHRU_EXTENDED, ZEND_STANDARD_CLASS_DEF_PTR));
 }
-#line 836 "ext/standard/var_unserializer.c"
+#line 971 "ext/standard/var_unserializer.c"
 yy32:
 	yych = *++YYCURSOR;
 	if (yych == '+') goto yy33;
@@ -853,12 +988,12 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	yych = *++YYCURSOR;
 	if (yych != '{') goto yy18;
 	++YYCURSOR;
-#line 702 "ext/standard/var_unserializer.re"
+#line 837 "ext/standard/var_unserializer.re"
 	{
 	zend_long elements = parse_iv(start + 2);
 	/* use iv() not uiv() in order to check data range */
 	*p = YYCURSOR;
-    if (!var_hash) return 0;
+	if (!var_hash_extended) return 0;
 
 	if (elements < 0) {
 		return 0;
@@ -871,13 +1006,13 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 		zend_hash_real_init(Z_ARRVAL_P(rval), 0);
 	}
 
-	if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {
+	if (!process_nested_data(UNSERIALIZE_PASSTHRU_EXTENDED, Z_ARRVAL_P(rval), elements, 0)) {
 		return 0;
 	}
 
-	return finish_nested_data(UNSERIALIZE_PASSTHRU);
+	return finish_nested_data(UNSERIALIZE_PASSTHRU_EXTENDED);
 }
-#line 881 "ext/standard/var_unserializer.c"
+#line 1016 "ext/standard/var_unserializer.c"
 yy39:
 	yych = *++YYCURSOR;
 	if (yych == '+') goto yy40;
@@ -898,7 +1033,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	yych = *++YYCURSOR;
 	if (yych != '"') goto yy18;
 	++YYCURSOR;
-#line 668 "ext/standard/var_unserializer.re"
+#line 803 "ext/standard/var_unserializer.re"
 	{
 	size_t len, maxlen;
 	zend_string *str;
@@ -932,7 +1067,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	ZVAL_STR(rval, str);
 	return 1;
 }
-#line 936 "ext/standard/var_unserializer.c"
+#line 1071 "ext/standard/var_unserializer.c"
 yy46:
 	yych = *++YYCURSOR;
 	if (yych == '+') goto yy47;
@@ -953,7 +1088,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	yych = *++YYCURSOR;
 	if (yych != '"') goto yy18;
 	++YYCURSOR;
-#line 636 "ext/standard/var_unserializer.re"
+#line 771 "ext/standard/var_unserializer.re"
 	{
 	size_t len, maxlen;
 	char *str;
@@ -985,7 +1120,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	ZVAL_STRINGL(rval, str, len);
 	return 1;
 }
-#line 989 "ext/standard/var_unserializer.c"
+#line 1124 "ext/standard/var_unserializer.c"
 yy53:
 	yych = *++YYCURSOR;
 	if (yych <= '/') {
@@ -1073,7 +1208,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	}
 yy63:
 	++YYCURSOR;
-#line 627 "ext/standard/var_unserializer.re"
+#line 762 "ext/standard/var_unserializer.re"
 	{
 #if SIZEOF_ZEND_LONG == 4
 use_double:
@@ -1082,7 +1217,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	ZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));
 	return 1;
 }
-#line 1086 "ext/standard/var_unserializer.c"
+#line 1221 "ext/standard/var_unserializer.c"
 yy65:
 	yych = *++YYCURSOR;
 	if (yych <= ',') {
@@ -1141,7 +1276,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	yych = *++YYCURSOR;
 	if (yych != ';') goto yy18;
 	++YYCURSOR;
-#line 611 "ext/standard/var_unserializer.re"
+#line 746 "ext/standard/var_unserializer.re"
 	{
 	*p = YYCURSOR;
 
@@ -1157,7 +1292,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 
 	return 1;
 }
-#line 1161 "ext/standard/var_unserializer.c"
+#line 1296 "ext/standard/var_unserializer.c"
 yy76:
 	yych = *++YYCURSOR;
 	if (yych == 'N') goto yy73;
@@ -1184,7 +1319,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	if (yych <= '9') goto yy79;
 	if (yych != ';') goto yy18;
 	++YYCURSOR;
-#line 585 "ext/standard/var_unserializer.re"
+#line 720 "ext/standard/var_unserializer.re"
 	{
 #if SIZEOF_ZEND_LONG == 4
 	int digits = YYCURSOR - start - 3;
@@ -1210,7 +1345,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	ZVAL_LONG(rval, parse_iv(start + 2));
 	return 1;
 }
-#line 1214 "ext/standard/var_unserializer.c"
+#line 1349 "ext/standard/var_unserializer.c"
 yy83:
 	yych = *++YYCURSOR;
 	if (yych <= '/') goto yy18;
@@ -1218,22 +1353,22 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	yych = *++YYCURSOR;
 	if (yych != ';') goto yy18;
 	++YYCURSOR;
-#line 579 "ext/standard/var_unserializer.re"
+#line 714 "ext/standard/var_unserializer.re"
 	{
 	*p = YYCURSOR;
 	ZVAL_BOOL(rval, parse_iv(start + 2));
 	return 1;
 }
-#line 1228 "ext/standard/var_unserializer.c"
+#line 1363 "ext/standard/var_unserializer.c"
 yy87:
 	++YYCURSOR;
-#line 573 "ext/standard/var_unserializer.re"
+#line 708 "ext/standard/var_unserializer.re"
 	{
 	*p = YYCURSOR;
 	ZVAL_NULL(rval);
 	return 1;
 }
-#line 1237 "ext/standard/var_unserializer.c"
+#line 1372 "ext/standard/var_unserializer.c"
 yy89:
 	yych = *++YYCURSOR;
 	if (yych <= ',') {
@@ -1256,15 +1391,15 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	if (yych <= '9') goto yy91;
 	if (yych != ';') goto yy18;
 	++YYCURSOR;
-#line 548 "ext/standard/var_unserializer.re"
+#line 683 "ext/standard/var_unserializer.re"
 	{
 	zend_long id;
 
  	*p = YYCURSOR;
-	if (!var_hash) return 0;
+	if (!var_hash_extended) return 0;
 
 	id = parse_iv(start + 2) - 1;
-	if (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {
+	if (id == -1 || (rval_ref = var_access(&(var_hash_extended->inner), id)) == NULL) {
 		return 0;
 	}
 
@@ -1281,7 +1416,7 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 
 	return 1;
 }
-#line 1285 "ext/standard/var_unserializer.c"
+#line 1420 "ext/standard/var_unserializer.c"
 yy95:
 	yych = *++YYCURSOR;
 	if (yych <= ',') {
@@ -1304,15 +1439,15 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	if (yych <= '9') goto yy97;
 	if (yych != ';') goto yy18;
 	++YYCURSOR;
-#line 522 "ext/standard/var_unserializer.re"
+#line 657 "ext/standard/var_unserializer.re"
 	{
 	zend_long id;
 
  	*p = YYCURSOR;
-	if (!var_hash) return 0;
+	if (!var_hash_extended) return 0;
 
 	id = parse_iv(start + 2) - 1;
-	if (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {
+	if (id == -1 || (rval_ref = var_access(&(var_hash_extended->inner), id)) == NULL) {
 		return 0;
 	}
 
@@ -1330,9 +1465,9 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 
 	return 1;
 }
-#line 1334 "ext/standard/var_unserializer.c"
+#line 1469 "ext/standard/var_unserializer.c"
 }
-#line 886 "ext/standard/var_unserializer.re"
+#line 1021 "ext/standard/var_unserializer.re"
 
 
 	return 0;
diff --git a/ext/standard/var_unserializer.re b/ext/standard/var_unserializer.re
index 81cc26db9d11..4ee361a7424b 100644
--- a/ext/standard/var_unserializer.re
+++ b/ext/standard/var_unserializer.re
@@ -38,6 +38,23 @@ typedef struct {
 	void *next;
 } var_dtor_entries;
 
+typedef struct {
+	zval data[VAR_ENTRIES_MAX];
+	zend_long used_slots;
+	void *next;
+} var_wakeup_entries;
+
+struct php_unserialize_data_extended {
+	php_unserialize_data_t inner;
+	// Additional properties.
+	void *first_wakeup;
+	void *last_wakeup;
+};
+
+typedef struct php_unserialize_data_extended *php_unserialize_data_extended_t;
+
+static zval *var_tmp_wakeup_var(php_unserialize_data_extended_t var_hashx_extended);
+
 static inline void var_push(php_unserialize_data_t *var_hashx, zval *rval)
 {
 	var_entries *var_hash = (*var_hashx)->last;
@@ -65,9 +82,20 @@ static inline void var_push(php_unserialize_data_t *var_hashx, zval *rval)
 PHPAPI void var_push_dtor(php_unserialize_data_t *var_hashx, zval *rval)
 {
 	zval *tmp_var = var_tmp_var(var_hashx);
-    if (!tmp_var) {
-        return;
-    }
+	if (!tmp_var) {
+		return;
+	}
+	ZVAL_COPY(tmp_var, rval);
+}
+
+/* Create a copy of rval (of type IS_OBJECT, with method "__wakeup" defined). Defer the call to __wakeup. */
+PHPAPI void var_push_wakeup(php_unserialize_data_extended_t var_hashx, zval *rval)
+{
+	/* TODO: This could be refactored into a common macro/data structures with var_tmp_var once the implementation is certain. */
+	zval *tmp_var = var_tmp_wakeup_var(var_hashx);
+	if (!tmp_var) {
+		return;
+	}
 	ZVAL_COPY(tmp_var, rval);
 }
 
@@ -97,6 +125,34 @@ PHPAPI zval *var_tmp_var(php_unserialize_data_t *var_hashx)
     return &var_hash->data[var_hash->used_slots++];
 }
 
+/* Create a temporary variable, for calling __wakeup() when unserialization is finished */
+static zval *var_tmp_wakeup_var(php_unserialize_data_extended_t var_hashx_extended)
+{
+	/* TODO: This could be refactored into a common macro/data structures with var_tmp_var once the implementation is certain. */
+	var_wakeup_entries *var_hash;
+
+	if (!var_hashx_extended) {
+		return NULL;
+	}
+
+	var_hash = var_hashx_extended->last_wakeup;
+	if (!var_hash || var_hash->used_slots == VAR_ENTRIES_MAX) {
+		var_hash = emalloc(sizeof(var_wakeup_entries));
+		var_hash->used_slots = 0;
+		var_hash->next = 0;
+
+		if (!var_hashx_extended->first_wakeup) {
+			var_hashx_extended->first_wakeup = var_hash;
+		} else {
+			((var_wakeup_entries *) var_hashx_extended->last_wakeup)->next = var_hash;
+		}
+
+		var_hashx_extended->last_wakeup = var_hash;
+	}
+	ZVAL_UNDEF(&var_hash->data[var_hash->used_slots]);
+	return &var_hash->data[var_hash->used_slots++];
+}
+
 PHPAPI void var_replace(php_unserialize_data_t *var_hashx, zval *ozval, zval *nzval)
 {
 	zend_long i;
@@ -135,6 +191,61 @@ static zval *var_access(php_unserialize_data_t *var_hashx, zend_long id)
 	return var_hash->data[id];
 }
 
+static int var_wakeup_all(php_unserialize_data_extended_t var_hashx_extended, const zend_bool is_cleanup)
+{
+	void *next;
+	zend_long i;
+	zval fname;
+	var_wakeup_entries *wakeup_hash;
+	zend_bool should_wakeup = !is_cleanup;
+	int ret = 1;
+	if (!var_hashx_extended) {
+		return 1;
+	}
+	wakeup_hash = var_hashx_extended->first_wakeup;
+
+#if VAR_ENTRIES_DBG
+	fprintf(stderr, "var_wakeup_all(%ld)\n", wakeup_hash?wakeup_hash->used_slots:-1L);
+#endif
+	if (!wakeup_hash) {
+		return 1;
+	}
+
+	if (!is_cleanup) {
+		ZVAL_STRINGL(&fname, "__wakeup", sizeof("__wakeup") - 1);
+	}
+
+
+	while (wakeup_hash) {
+		for (i = 0; i < wakeup_hash->used_slots; i++) {
+#if VAR_ENTRIES_DBG
+			fprintf(stderr, "var_wakeup_all __wakeup and dtor of copy(%p, %ld)\n", &wakeup_hash->data[i], (long) Z_REFCOUNT_P(&wakeup_hash->data[i]));
+#endif
+
+			if (should_wakeup) {
+				zval retval;
+				BG(serialize_lock)++;
+				call_user_function_ex(CG(function_table), &wakeup_hash->data[i], &fname, &retval, 0, 0, 1, NULL);
+				BG(serialize_lock)--;
+				zval_dtor(&retval);
+				if (EG(exception)) {
+					ret = 0; /* If there is an exception, don't call __wakeup() on the rest of the objects, but continue freeing the memory. */
+				}
+			}
+			zval_ptr_dtor(&wakeup_hash->data[i]);
+		}
+		next = wakeup_hash->next;
+		efree_size(wakeup_hash, sizeof(var_wakeup_entries));
+		wakeup_hash = next;
+	}
+	if (!is_cleanup) {
+		zval_dtor(&fname);
+	}
+	var_hashx_extended->first_wakeup = NULL;
+	return ret;
+}
+
+
 PHPAPI void var_destroy(php_unserialize_data_t *var_hashx)
 {
 	void *next;
@@ -305,7 +416,12 @@ static inline size_t parse_uiv(const unsigned char *p)
 #define UNSERIALIZE_PARAMETER zval *rval, const unsigned char **p, const unsigned char *max, php_unserialize_data_t *var_hash, HashTable *classes
 #define UNSERIALIZE_PASSTHRU rval, p, max, var_hash, classes
 
-static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, zend_long elements, int objprops)
+#define UNSERIALIZE_PARAMETER_EXTENDED zval *rval, const unsigned char **p, const unsigned char *max, php_unserialize_data_extended_t var_hash_extended, HashTable *classes
+#define UNSERIALIZE_PASSTHRU_EXTENDED rval, p, max, var_hash_extended, classes
+
+static int php_var_unserialize_ex_inner(UNSERIALIZE_PARAMETER_EXTENDED);
+
+static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER_EXTENDED, HashTable *ht, zend_long elements, int objprops)
 {
 	while (elements-- > 0) {
 		zval key, *data, d, *old_data;
@@ -313,7 +429,7 @@ static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTab
 
 		ZVAL_UNDEF(&key);
 
-		if (!php_var_unserialize_ex(&key, p, max, NULL, classes)) {
+		if (!php_var_unserialize_ex_inner(&key, p, max, NULL, classes)) {
 			zval_dtor(&key);
 			return 0;
 		}
@@ -327,7 +443,7 @@ static zend_always_inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTab
 numeric_key:
 				if (UNEXPECTED((old_data = zend_hash_index_find(ht, idx)) != NULL)) {
 					//??? update hash
-					var_push_dtor(var_hash, old_data);
+					var_push_dtor(&(var_hash_extended->inner), old_data);
 					data = zend_hash_index_update(ht, idx, &d);
 				} else {
 					data = zend_hash_index_add_new(ht, idx, &d);
@@ -338,7 +454,7 @@ numeric_key:
 				}
 				if (UNEXPECTED((old_data = zend_hash_find(ht, Z_STR(key))) != NULL)) {
 					//??? update hash
-					var_push_dtor(var_hash, old_data);
+					var_push_dtor(&(var_hash_extended->inner), old_data);
 					data = zend_hash_update(ht, Z_STR(key), &d);
 				} else {
 					data = zend_hash_add_new(ht, Z_STR(key), &d);
@@ -354,7 +470,7 @@ string_key:
 					if (Z_TYPE_P(old_data) == IS_INDIRECT) {
 						old_data = Z_INDIRECT_P(old_data);
 					}
-					var_push_dtor(var_hash, old_data);
+					var_push_dtor(&(var_hash_extended->inner), old_data);
 					data = zend_hash_update_ind(ht, Z_STR(key), &d);
 				} else {
 					data = zend_hash_add_new(ht, Z_STR(key), &d);
@@ -369,7 +485,7 @@ string_key:
 			}
 		}
 
-		if (!php_var_unserialize_ex(data, p, max, var_hash, classes)) {
+		if (!php_var_unserialize_ex_inner(data, p, max, var_hash_extended, classes)) {
 			zval_dtor(&key);
 			return 0;
 		}
@@ -381,7 +497,7 @@ string_key:
 				zend_hash_del_ind(ht, Z_STR(key));
 			}
 		} else {
-			var_push_dtor(var_hash, data);
+			var_push_dtor(&(var_hash_extended->inner), data);
 		}
 
 		zval_dtor(&key);
@@ -395,7 +511,7 @@ string_key:
 	return 1;
 }
 
-static inline int finish_nested_data(UNSERIALIZE_PARAMETER)
+static inline int finish_nested_data(UNSERIALIZE_PARAMETER_EXTENDED)
 {
 	if (*((*p)++) == '}')
 		return 1;
@@ -406,7 +522,7 @@ static inline int finish_nested_data(UNSERIALIZE_PARAMETER)
 	return 0;
 }
 
-static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
+static inline int object_custom(UNSERIALIZE_PARAMETER_EXTENDED, zend_class_entry *ce)
 {
 	zend_long datalen;
 
@@ -422,16 +538,16 @@ static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
 	if (ce->unserialize == NULL) {
 		zend_error(E_WARNING, "Class %s has no unserializer", ZSTR_VAL(ce->name));
 		object_init_ex(rval, ce);
-	} else if (ce->unserialize(rval, ce, (const unsigned char*)*p, datalen, (zend_unserialize_data *)var_hash) != SUCCESS) {
+	} else if (ce->unserialize(rval, ce, (const unsigned char*)*p, datalen, (zend_unserialize_data *)&(var_hash_extended->inner)) != SUCCESS) {
 		return 0;
 	}
 
 	(*p) += datalen;
 
-	return finish_nested_data(UNSERIALIZE_PASSTHRU);
+	return finish_nested_data(UNSERIALIZE_PASSTHRU_EXTENDED);
 }
 
-static inline zend_long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
+static inline zend_long object_common1(UNSERIALIZE_PARAMETER_EXTENDED, zend_class_entry *ce)
 {
 	zend_long elements;
 
@@ -454,10 +570,10 @@ static inline zend_long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *
 #ifdef PHP_WIN32
 # pragma optimize("", off)
 #endif
-static inline int object_common2(UNSERIALIZE_PARAMETER, zend_long elements)
+static inline int object_common2(UNSERIALIZE_PARAMETER_EXTENDED, zend_long elements)
 {
-	zval retval;
-	zval fname;
+	/* Allocates properties for an object, then defers a call to __wakeup if necessary */
+	/* Precondition: var_hash_extended != NULL */
 	HashTable *ht;
 
 	if (Z_TYPE_P(rval) != IS_OBJECT) {
@@ -466,26 +582,21 @@ static inline int object_common2(UNSERIALIZE_PARAMETER, zend_long elements)
 
 	ht = Z_OBJPROP_P(rval);
 	zend_hash_extend(ht, zend_hash_num_elements(ht) + elements, (ht->u.flags & HASH_FLAG_PACKED));
-	if (!process_nested_data(UNSERIALIZE_PASSTHRU, ht, elements, 1)) {
+	if (!process_nested_data(UNSERIALIZE_PASSTHRU_EXTENDED, ht, elements, 1)) {
 		return 0;
 	}
 
 	ZVAL_DEREF(rval);
 	if (Z_OBJCE_P(rval) != PHP_IC_ENTRY &&
 		zend_hash_str_exists(&Z_OBJCE_P(rval)->function_table, "__wakeup", sizeof("__wakeup")-1)) {
-		ZVAL_STRINGL(&fname, "__wakeup", sizeof("__wakeup") - 1);
-		BG(serialize_lock)++;
-		call_user_function_ex(CG(function_table), rval, &fname, &retval, 0, 0, 1, NULL);
-		BG(serialize_lock)--;
-		zval_dtor(&fname);
-		zval_dtor(&retval);
+		var_push_wakeup(var_hash_extended, rval); /* __wakeup will be called in post-order of the graph of zvals (child nodes first), after everything is initialized */
 	}
 
 	if (EG(exception)) {
 		return 0;
 	}
 
-	return finish_nested_data(UNSERIALIZE_PASSTHRU);
+	return finish_nested_data(UNSERIALIZE_PASSTHRU_EXTENDED);
 
 }
 #ifdef PHP_WIN32
@@ -501,6 +612,30 @@ PHPAPI int php_var_unserialize(zval *rval, const unsigned char **p, const unsign
 
 PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 {
+	struct php_unserialize_data_extended var_hash_extended_val;
+	php_unserialize_data_extended_t var_hash_extended;
+	if (var_hash != NULL) {
+		var_hash_extended_val.inner = *var_hash;
+		var_hash_extended_val.first_wakeup = NULL;
+		var_hash_extended_val.last_wakeup  = NULL;
+		var_hash_extended = &var_hash_extended_val;
+	} else {
+		var_hash_extended = NULL;
+	}
+
+	if (php_var_unserialize_ex_inner(UNSERIALIZE_PASSTHRU_EXTENDED) == 0) {
+		var_wakeup_all(var_hash_extended, 1); /* Free the copies of objects (which would call __wakeup) if we haven't already. */
+		return 0;
+	}
+	if (var_wakeup_all(var_hash_extended, 0) == 0) {
+		return 0;
+	}
+	return 1;
+}
+
+/* Unserialize a zval, deferring calls to __wakeup(). This was split out because many extensions call php_var_unserialize/php_var_unserialize_ex directly. */
+/* We ensure __wakeup is called at the very end, so that it doesn't modify/invalidate/delete the arrays/objects/references we are unserializing.. */
+static int php_var_unserialize_ex_inner(UNSERIALIZE_PARAMETER_EXTENDED) {
 	const unsigned char *cursor, *limit, *marker, *start;
 	zval *rval_ref;
 
@@ -511,8 +646,8 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 		return 0;
 	}
 
-	if (var_hash && (*p)[0] != 'R') {
-		var_push(var_hash, rval);
+	if (var_hash_extended && (*p)[0] != 'R') {
+		var_push(&(var_hash_extended->inner), rval);
 	}
 
 	start = cursor;
@@ -523,10 +658,10 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	zend_long id;
 
  	*p = YYCURSOR;
-	if (!var_hash) return 0;
+	if (!var_hash_extended) return 0;
 
 	id = parse_iv(start + 2) - 1;
-	if (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {
+	if (id == -1 || (rval_ref = var_access(&(var_hash_extended->inner), id)) == NULL) {
 		return 0;
 	}
 
@@ -549,10 +684,10 @@ PHPAPI int php_var_unserialize_ex(UNSERIALIZE_PARAMETER)
 	zend_long id;
 
  	*p = YYCURSOR;
-	if (!var_hash) return 0;
+	if (!var_hash_extended) return 0;
 
 	id = parse_iv(start + 2) - 1;
-	if (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {
+	if (id == -1 || (rval_ref = var_access(&(var_hash_extended->inner), id)) == NULL) {
 		return 0;
 	}
 
@@ -703,7 +838,7 @@ use_double:
 	zend_long elements = parse_iv(start + 2);
 	/* use iv() not uiv() in order to check data range */
 	*p = YYCURSOR;
-    if (!var_hash) return 0;
+	if (!var_hash_extended) return 0;
 
 	if (elements < 0) {
 		return 0;
@@ -716,18 +851,18 @@ use_double:
 		zend_hash_real_init(Z_ARRVAL_P(rval), 0);
 	}
 
-	if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {
+	if (!process_nested_data(UNSERIALIZE_PASSTHRU_EXTENDED, Z_ARRVAL_P(rval), elements, 0)) {
 		return 0;
 	}
 
-	return finish_nested_data(UNSERIALIZE_PASSTHRU);
+	return finish_nested_data(UNSERIALIZE_PASSTHRU_EXTENDED);
 }
 
 "o:" iv ":" ["] {
-    if (!var_hash) return 0;
+	if (!var_hash_extended) return 0;
 
-	return object_common2(UNSERIALIZE_PASSTHRU,
-			object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR));
+	return object_common2(UNSERIALIZE_PASSTHRU_EXTENDED,
+			object_common1(UNSERIALIZE_PASSTHRU_EXTENDED, ZEND_STANDARD_CLASS_DEF_PTR));
 }
 
 object ":" uiv ":" ["]	{
@@ -744,7 +879,7 @@ object ":" uiv ":" ["]	{
 	zval retval;
 	zval args[1];
 
-    if (!var_hash) return 0;
+	if (!var_hash_extended) return 0;
 	if (*start == 'C') {
 		custom_object = 1;
 	}
@@ -856,7 +991,7 @@ object ":" uiv ":" ["]	{
 	if (custom_object) {
 		int ret;
 
-		ret = object_custom(UNSERIALIZE_PASSTHRU, ce);
+		ret = object_custom(UNSERIALIZE_PASSTHRU_EXTENDED, ce);
 
 		if (ret && incomplete_class) {
 			php_store_class_name(rval, ZSTR_VAL(class_name), len2);
@@ -865,14 +1000,14 @@ object ":" uiv ":" ["]	{
 		return ret;
 	}
 
-	elements = object_common1(UNSERIALIZE_PASSTHRU, ce);
+	elements = object_common1(UNSERIALIZE_PASSTHRU_EXTENDED, ce);
 
 	if (incomplete_class) {
 		php_store_class_name(rval, ZSTR_VAL(class_name), len2);
 	}
 	zend_string_release(class_name);
 
-	return object_common2(UNSERIALIZE_PASSTHRU, elements);
+	return object_common2(UNSERIALIZE_PASSTHRU_EXTENDED, elements);
 }
 
 "}" {
