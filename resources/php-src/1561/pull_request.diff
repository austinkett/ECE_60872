diff --git a/ext/pdo/pdo_dbh.c b/ext/pdo/pdo_dbh.c
index d027d9796328..92d2ca29c1ed 100644
--- a/ext/pdo/pdo_dbh.c
+++ b/ext/pdo/pdo_dbh.c
@@ -38,6 +38,43 @@
 
 static int pdo_dbh_attribute_set(pdo_dbh_t *dbh, long attr, zval *value TSRMLS_DC);
 
+PDO_API zval *pdo_throw_exception_ex(pdo_error_type *pdo_err, long code TSRMLS_DC, const char *format, ...) /* {{{ */
+{
+	va_list arg;
+	char *message;
+	zval *zexception, *info;
+	zend_class_entry *exception_ce;
+
+	va_start(arg, format);
+	zend_vspprintf(&message, 0, format, arg);
+	va_end(arg);
+
+	exception_ce = php_pdo_get_exception();
+
+	MAKE_STD_ZVAL(zexception);
+	object_init_ex(zexception, exception_ce);
+
+	zend_update_property_string(exception_ce, zexception, "message", sizeof("message")-1, message TSRMLS_CC);
+	zend_update_property_long(exception_ce, zexception, "code", sizeof("code")-1, code TSRMLS_CC);
+
+	MAKE_STD_ZVAL(info);
+	array_init(info);
+
+	add_next_index_string(info, *pdo_err, 1);
+	add_next_index_long(info, code);
+	add_next_index_string(info, message, 1);
+
+	efree(message);
+
+	zend_update_property(exception_ce, zexception, "errorInfo", sizeof("errorInfo")-1, info TSRMLS_CC);
+	zval_ptr_dtor(&info);
+
+	zend_throw_exception_internal(zexception TSRMLS_CC);
+
+	return zexception;
+}
+/* }}} */
+
 void pdo_raise_impl_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, const char *sqlstate, const char *supp TSRMLS_DC) /* {{{ */
 {
 	pdo_error_type *pdo_err = &dbh->error_code;
diff --git a/ext/pdo/php_pdo_error.h b/ext/pdo/php_pdo_error.h
index e9d70a7c0b20..c02b5894f391 100644
--- a/ext/pdo/php_pdo_error.h
+++ b/ext/pdo/php_pdo_error.h
@@ -24,6 +24,7 @@
 #include "php_pdo_driver.h"
 
 PDO_API void pdo_handle_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt TSRMLS_DC);
+PDO_API zval *pdo_throw_exception_ex(pdo_error_type *pdo_err, long code TSRMLS_DC, const char *format, ...);
 
 #define PDO_DBH_CLEAR_ERR()             do { \
 	strlcpy(dbh->error_code, PDO_ERR_NONE, sizeof(PDO_ERR_NONE)); \
diff --git a/ext/pdo/tests/bug_64705.phpt b/ext/pdo/tests/bug_64705.phpt
new file mode 100644
index 000000000000..24724a9fafec
--- /dev/null
+++ b/ext/pdo/tests/bug_64705.phpt
@@ -0,0 +1,47 @@
+--TEST--
+PDO Common: Bug #64705 errorInfo property of PDOException is null when PDO::__construct() fails
+--SKIPIF--
+<?php # vim:ft=php
+if (!extension_loaded('pdo')) die('skip');
+$dir = getenv('REDIR_TEST_DIR');
+if (false == $dir) die('skip no driver');
+require_once $dir . 'pdo_test.inc';
+PDOTest::skip();
+?>
+--FILE--
+<?php
+if(getenv('REDIR_TEST_DIR') === false) putenv('REDIR_TEST_DIR='.dirname(__FILE__) . '/../../pdo/tests/');
+require_once getenv('REDIR_TEST_DIR') . 'pdo_test.inc';
+
+if(substr(getenv('PDOTEST_DSN'), 0, strlen('sqlite')) === 'sqlite') {
+  putenv('PDOTEST_DSN=sqlite:.');
+} else if(substr(getenv('PDOTEST_DSN'), 0, strlen('odbc')) === 'odbc') {
+  putenv('PDOTEST_DSN=odbc:DRIVER=ibm-db2;HOSTNAME=localhost;PORT=50000;DATABASE=bad_database;PROTOCOL=TCPIP;UID=bad_user;PWD=bad_password;');
+} else if(substr(getenv('PDOTEST_DSN'), 0, strlen('pgsql')) === 'pgsql') {
+  putenv('PDOTEST_DSN=pgsql:host=localhost;port=54321;dbname=bad_database_gDm9VNHRkIxQ');
+}
+
+putenv('PDOTEST_USER=bad_username_gDm9VNHRkIxQ');
+putenv('PDOTEST_PASS=bad_password_gDm9VNHRkIxQ');
+
+try {
+    $db = PDOTest::factory();
+} catch (\PDOException $e) {
+    var_dump($e->errorInfo);
+    var_dump($e->getCode());
+    var_dump($e->getMessage());
+}
+?>
+===DONE===
+--EXPECTF--
+array(3) {
+  [0]=>
+  string(5) "%s"
+  [1]=>
+  int(%d)
+  [2]=>
+  string(%d) "SQLSTATE[%s]%A"
+}
+int(%d)
+string(%d) "SQLSTATE[%s]%A"
+===DONE===
\ No newline at end of file
diff --git a/ext/pdo_dblib/dblib_driver.c b/ext/pdo_dblib/dblib_driver.c
index 70b440298213..45c08b406188 100644
--- a/ext/pdo_dblib/dblib_driver.c
+++ b/ext/pdo_dblib/dblib_driver.c
@@ -95,7 +95,7 @@ static int dblib_handle_preparer(pdo_dbh_t *dbh, const char *sql, long sql_len,
 {
 	pdo_dblib_db_handle *H = (pdo_dblib_db_handle *)dbh->driver_data;
 	pdo_dblib_stmt *S = ecalloc(1, sizeof(*S));
-	
+
 	S->H = H;
 	stmt->driver_data = S;
 	stmt->methods = &dblib_stmt_methods;
@@ -119,7 +119,7 @@ static long dblib_handle_doer(pdo_dbh_t *dbh, const char *sql, long sql_len TSRM
 	if (FAIL == dbsqlexec(H->link)) {
 		return -1;
 	}
-	
+
 	resret = dbresults(H->link);
 
 	if (resret == FAIL) {
@@ -165,7 +165,7 @@ static int dblib_handle_quoter(pdo_dbh_t *dbh, const char *unquoted, int unquote
 	*q++ = '\'';
 	*q++ = '\0';
 	*quotedlen = l+1;
-	
+
 	return 1;
 }
 
@@ -173,15 +173,15 @@ static int pdo_dblib_transaction_cmd(const char *cmd, pdo_dbh_t *dbh TSRMLS_DC)
 {
 	pdo_dblib_db_handle *H = (pdo_dblib_db_handle *)dbh->driver_data;
 	RETCODE ret;
-	
+
 	if (FAIL == dbcmd(H->link, cmd)) {
 		return 0;
 	}
-	
+
 	if (FAIL == dbsqlexec(H->link)) {
 		return 0;
 	}
-	
+
 	return 1;
 }
 
@@ -200,25 +200,25 @@ static int dblib_handle_rollback(pdo_dbh_t *dbh TSRMLS_DC)
 	return pdo_dblib_transaction_cmd("ROLLBACK TRANSACTION", dbh TSRMLS_CC);
 }
 
-char *dblib_handle_last_id(pdo_dbh_t *dbh, const char *name, unsigned int *len TSRMLS_DC) 
+char *dblib_handle_last_id(pdo_dbh_t *dbh, const char *name, unsigned int *len TSRMLS_DC)
 {
 	pdo_dblib_db_handle *H = (pdo_dblib_db_handle *)dbh->driver_data;
 
 	RETCODE ret;
 	char *id = NULL;
 
-	/* 
+	/*
 	 * Would use scope_identity() but it's not implemented on Sybase
 	 */
-	
+
 	if (FAIL == dbcmd(H->link, "SELECT @@IDENTITY")) {
 		return NULL;
 	}
-	
+
 	if (FAIL == dbsqlexec(H->link)) {
 		return NULL;
 	}
-	
+
 	ret = dbresults(H->link);
 	if (ret == FAIL || ret == NO_MORE_RESULTS) {
 		dbcancel(H->link);
@@ -226,7 +226,7 @@ char *dblib_handle_last_id(pdo_dbh_t *dbh, const char *name, unsigned int *len T
 	}
 
 	ret = dbnextrow(H->link);
-	
+
 	if (ret == FAIL || ret == NO_MORE_ROWS) {
 		dbcancel(H->link);
 		return NULL;
@@ -239,7 +239,7 @@ char *dblib_handle_last_id(pdo_dbh_t *dbh, const char *name, unsigned int *len T
 
 	id = emalloc(32);
 	*len = dbconvert(NULL, (dbcoltype(H->link, 1)) , (dbdata(H->link, 1)) , (dbdatlen(H->link, 1)), SQLCHAR, id, (DBINT)-1);
-		
+
 	dbcancel(H->link);
 	return id;
 }
@@ -267,7 +267,7 @@ static int pdo_dblib_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 	pdo_dblib_db_handle *H;
 	int i, nvars, nvers, ret = 0;
 	int *val;
-	
+
 	const pdo_dblib_keyval tdsver[] = {
 		 {"4.2",DBVERSION_42}
 		,{"4.6",DBVERSION_46}
@@ -283,9 +283,11 @@ static int pdo_dblib_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 #endif
 		,{"10.0",DBVERSION_100}
 		,{"auto",0} /* Only works with FreeTDS. Other drivers will bork */
-		
+
 	};
-	
+
+	nvers = sizeof(tdsver)/sizeof(tdsver[0]);
+
 	struct pdo_data_src_parser vars[] = {
 		{ "charset",	NULL,	0 }
 		,{ "appname",	"PHP " PDO_DBLIB_FLAVOUR,	0 }
@@ -294,10 +296,9 @@ static int pdo_dblib_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 		,{ "secure",	NULL,	0 } /* DBSETLSECURE */
 		,{ "version",	NULL,	0 } /* DBSETLVERSION */
 	};
-	
+
 	nvars = sizeof(vars)/sizeof(vars[0]);
-	nvers = sizeof(tdsver)/sizeof(tdsver[0]);
-	
+
 	php_pdo_parse_data_source(dbh->data_source, dbh->data_source_len, vars, nvars);
 
 	H = pecalloc(1, sizeof(*H), dbh->is_persistent);
@@ -310,21 +311,21 @@ static int pdo_dblib_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 
 	DBERRHANDLE(H->login, (EHANDLEFUNC) error_handler);
 	DBMSGHANDLE(H->login, (MHANDLEFUNC) msg_handler);
-	
+
 	if(vars[5].optval) {
 		for(i=0;i<nvers;i++) {
 			if(strcmp(vars[5].optval,tdsver[i].key) == 0) {
 				if(FAIL==dbsetlversion(H->login, tdsver[i].value)) {
-					pdo_raise_impl_error(dbh, NULL, "HY000", "PDO_DBLIB: Failed to set version specified in connection string." TSRMLS_CC);		
+					pdo_raise_impl_error(dbh, NULL, "HY000", "PDO_DBLIB: Failed to set version specified in connection string." TSRMLS_CC);
 					goto cleanup;
 				}
 				break;
 			}
 		}
-		
+
 		if (i==nvers) {
 			printf("Invalid version '%s'\n", vars[5].optval);
-			pdo_raise_impl_error(dbh, NULL, "HY000", "PDO_DBLIB: Invalid version specified in connection string." TSRMLS_CC);		
+			pdo_raise_impl_error(dbh, NULL, "HY000", "PDO_DBLIB: Invalid version specified in connection string." TSRMLS_CC);
 			goto cleanup; /* unknown version specified */
 		}
 	}
@@ -340,7 +341,7 @@ static int pdo_dblib_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 			goto cleanup;
 		}
 	}
-	
+
 #if !PHP_DBLIB_IS_MSSQL
 	if (vars[0].optval) {
 		DBSETLCHARSET(H->login, vars[0].optval);
@@ -398,7 +399,7 @@ static int pdo_dblib_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 	dbh->driver_data = H;
 
 	if (!ret) {
-		zend_throw_exception_ex(php_pdo_get_exception(), DBLIB_G(err).dberr TSRMLS_CC,
+		pdo_throw_exception_ex(DBLIB_G(err).sqlstate, DBLIB_G(err).dberr TSRMLS_CC,
 			"SQLSTATE[%s] %s (severity %d)",
 			DBLIB_G(err).sqlstate,
 			DBLIB_G(err).dberrstr,
diff --git a/ext/pdo_firebird/firebird_driver.c b/ext/pdo_firebird/firebird_driver.c
index a3f34d554f7f..b0bd447108a7 100644
--- a/ext/pdo_firebird/firebird_driver.c
+++ b/ext/pdo_firebird/firebird_driver.c
@@ -40,11 +40,11 @@ static int firebird_alloc_prepare_stmt(pdo_dbh_t*, const char*, long, XSQLDA*, i
 void _firebird_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, char const *file, long line TSRMLS_DC) /* {{{ */
 {
 #if 0
-	pdo_firebird_db_handle *H = stmt ? ((pdo_firebird_stmt *)stmt->driver_data)->H 
+	pdo_firebird_db_handle *H = stmt ? ((pdo_firebird_stmt *)stmt->driver_data)->H
 		: (pdo_firebird_db_handle *)dbh->driver_data;
 #endif
 	pdo_error_type *const error_code = stmt ? &stmt->error_code : &dbh->error_code;
-	
+
 #if 0
 	switch (isc_sqlcode(H->isc_status)) {
 
@@ -70,7 +70,7 @@ void _firebird_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, char const *file, long li
 
 			*error_code = PDO_ERR_ALREADY_EXISTS;
 			break;
-		
+
 			*error_code = PDO_ERR_NOT_IMPLEMENTED;
 			break;
 		case -313:
@@ -78,11 +78,11 @@ void _firebird_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, char const *file, long li
 			*error_code = PDO_ERR_MISMATCH;
 			break;
 		case -303:
-		case -314:	
+		case -314:
 		case -413:
 			*error_code = PDO_ERR_TRUNCATED;
 			break;
-			
+
 			*error_code = PDO_ERR_DISCONNECTED;
 			break;
 	}
@@ -98,7 +98,7 @@ void _firebird_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, char const *file, long li
 static int firebird_handle_closer(pdo_dbh_t *dbh TSRMLS_DC) /* {{{ */
 {
 	pdo_firebird_db_handle *H = (pdo_firebird_db_handle *)dbh->driver_data;
-	
+
 	if (dbh->in_txn) {
 		if (dbh->auto_commit) {
 			if (isc_commit_transaction(H->isc_status, &H->tr)) {
@@ -110,7 +110,7 @@ static int firebird_handle_closer(pdo_dbh_t *dbh TSRMLS_DC) /* {{{ */
 			}
 		}
 	}
-	
+
 	if (isc_detach_database(H->isc_status, &H->db)) {
 		RECORD_ERROR(dbh);
 	}
@@ -124,7 +124,7 @@ static int firebird_handle_closer(pdo_dbh_t *dbh TSRMLS_DC) /* {{{ */
 	if (H->timestamp_format) {
 		efree(H->timestamp_format);
 	}
-	
+
 	pefree(H, dbh->is_persistent);
 
 	return 0;
@@ -150,12 +150,12 @@ static int firebird_handle_preparer(pdo_dbh_t *dbh, const char *sql, long sql_le
 
 		ALLOC_HASHTABLE(np);
 		zend_hash_init(np, 8, NULL, NULL, 0);
-		
+
 		/* allocate and prepare statement */
 		if (!firebird_alloc_prepare_stmt(dbh, sql, sql_len, &num_sqlda, &s, np TSRMLS_CC)) {
 			break;
 		}
-	
+
 		/* allocate a statement handle struct of the right size (struct out_sqlda is inlined) */
 		S = ecalloc(1, sizeof(*S)-sizeof(XSQLDA) + XSQLDA_LENGTH(num_sqlda.sqld));
 		S->H = H;
@@ -170,49 +170,49 @@ static int firebird_handle_preparer(pdo_dbh_t *dbh, const char *sql, long sql_le
 				result)) {
 			break;
 		}
-		S->statement_type = result[3];	
-		
+		S->statement_type = result[3];
+
 		/* fill the output sqlda with information about the prepared query */
 		if (isc_dsql_describe(H->isc_status, &s, PDO_FB_SQLDA_VERSION, &S->out_sqlda)) {
 			RECORD_ERROR(dbh);
 			break;
 		}
-		
+
 		/* allocate the input descriptors */
 		if (isc_dsql_describe_bind(H->isc_status, &s, PDO_FB_SQLDA_VERSION, &num_sqlda)) {
 			break;
 		}
-		
+
 		if (num_sqlda.sqld) {
 			S->in_sqlda = ecalloc(1,XSQLDA_LENGTH(num_sqlda.sqld));
 			S->in_sqlda->version = PDO_FB_SQLDA_VERSION;
 			S->in_sqlda->sqln = num_sqlda.sqld;
-		
+
 			if (isc_dsql_describe_bind(H->isc_status, &s, PDO_FB_SQLDA_VERSION, S->in_sqlda)) {
 				break;
 			}
 		}
-	
+
 		stmt->driver_data = S;
 		stmt->methods = &firebird_stmt_methods;
 		stmt->supports_placeholders = PDO_PLACEHOLDER_POSITIONAL;
-	
+
 		return 1;
 
 	} while (0);
 
 	RECORD_ERROR(dbh);
-	
+
 	zend_hash_destroy(np);
 	FREE_HASHTABLE(np);
-	
+
 	if (S) {
 		if (S->in_sqlda) {
 			efree(S->in_sqlda);
 		}
 		efree(S);
 	}
-	
+
 	return 0;
 }
 /* }}} */
@@ -226,12 +226,12 @@ static long firebird_handle_doer(pdo_dbh_t *dbh, const char *sql, long sql_len T
 	char result[64];
 	int ret = 0;
 	XSQLDA in_sqlda, out_sqlda;
-		
+
 	/* TODO no placeholders in exec() for now */
 	in_sqlda.version = out_sqlda.version = PDO_FB_SQLDA_VERSION;
 	in_sqlda.sqld = out_sqlda.sqld = 0;
 	out_sqlda.sqln = 1;
-	
+
 	/* allocate and prepare statement */
 	if (!firebird_alloc_prepare_stmt(dbh, sql, sql_len, &out_sqlda, &stmt, 0 TSRMLS_CC)) {
 		return -1;
@@ -242,7 +242,7 @@ static long firebird_handle_doer(pdo_dbh_t *dbh, const char *sql, long sql_len T
 		RECORD_ERROR(dbh);
 		return -1;
 	}
-	
+
 	/* find out how many rows were affected */
 	if (isc_dsql_sql_info(H->isc_status, &stmt, sizeof(info_count), const_cast(info_count),
 			sizeof(result),	result)) {
@@ -261,7 +261,7 @@ static long firebird_handle_doer(pdo_dbh_t *dbh, const char *sql, long sql_len T
 			i += len+3;
 		}
 	}
-	
+
 	/* commit if we're in auto_commit mode */
 	if (dbh->auto_commit && isc_commit_retaining(H->isc_status, &H->tr)) {
 		RECORD_ERROR(dbh);
@@ -278,35 +278,35 @@ static int firebird_handle_quoter(pdo_dbh_t *dbh, const char *unquoted, int unqu
 	int qcount = 0;
 	char const *co, *l, *r;
 	char *c;
-	
+
 	if (!unquotedlen) {
 		*quotedlen = 2;
 		*quoted = emalloc(*quotedlen+1);
 		strcpy(*quoted, "''");
 		return 1;
 	}
-			
+
 	/* Firebird only requires single quotes to be doubled if string lengths are used */
 	/* count the number of ' characters */
 	for (co = unquoted; (co = strchr(co,'\'')); qcount++, co++);
-	
+
 	*quotedlen = unquotedlen + qcount + 2;
-	*quoted = c = emalloc(*quotedlen+1);		
+	*quoted = c = emalloc(*quotedlen+1);
 	*c++ = '\'';
-	
+
 	/* foreach (chunk that ends in a quote) */
-	for (l = unquoted; (r = strchr(l,'\'')); l = r+1) {			
+	for (l = unquoted; (r = strchr(l,'\'')); l = r+1) {
 		strncpy(c, l, r-l+1);
-		c += (r-l+1);			
+		c += (r-l+1);
 		/* add the second quote */
 		*c++ = '\'';
 	}
-		
+
 	/* copy the remainder */
 	strncpy(c, l, *quotedlen-(c-*quoted)-1);
-	(*quoted)[*quotedlen-1] = '\''; 
+	(*quoted)[*quotedlen-1] = '\'';
 	(*quoted)[*quotedlen]   = '\0';
-	
+
 	return 1;
 }
 /* }}} */
@@ -316,7 +316,7 @@ static int firebird_handle_begin(pdo_dbh_t *dbh TSRMLS_DC) /* {{{ */
 {
 	pdo_firebird_db_handle *H = (pdo_firebird_db_handle *)dbh->driver_data;
 	char tpb[8] = { isc_tpb_version3 }, *ptpb = tpb+1;
-#if abies_0	
+#if abies_0
 	if (dbh->transaction_flags & PDO_TRANS_ISOLATION_LEVEL) {
 		if (dbh->transaction_flags & PDO_TRANS_READ_UNCOMMITTED) {
 			/* this is a poor fit, but it's all we have */
@@ -335,7 +335,7 @@ static int firebird_handle_begin(pdo_dbh_t *dbh TSRMLS_DC) /* {{{ */
 			dbh->transaction_flags &= ~(PDO_TRANS_ISOLATION_LEVEL^PDO_TRANS_SERIALIZABLE);
 		}
 	}
-		
+
 	if (dbh->transaction_flags & PDO_TRANS_ACCESS_MODE) {
 		if (dbh->transaction_flags & PDO_TRANS_READONLY) {
 			*ptpb++ = isc_tpb_read;
@@ -397,13 +397,13 @@ static int firebird_alloc_prepare_stmt(pdo_dbh_t *dbh, const char *sql, long sql
 	pdo_firebird_db_handle *H = (pdo_firebird_db_handle *)dbh->driver_data;
 	char *c, *new_sql, in_quote, in_param, pname[64], *ppname;
 	long l, pindex = -1;
-		
+
 	/* Firebird allows SQL statements up to 64k, so bail if it doesn't fit */
 	if (sql_len > 65536) {
 		strcpy(dbh->error_code, "01004");
 		return 0;
 	}
-	
+
 	/* start a new transaction implicitly if auto_commit is enabled and no transaction is open */
 	if (dbh->auto_commit && !dbh->in_txn) {
 		/* dbh->transaction_flags = PDO_TRANS_READ_UNCOMMITTED; */
@@ -413,17 +413,17 @@ static int firebird_alloc_prepare_stmt(pdo_dbh_t *dbh, const char *sql, long sql
 		}
 		dbh->in_txn = 1;
 	}
-	
+
 	/* allocate the statement */
 	if (isc_dsql_allocate_statement(H->isc_status, &H->db, s)) {
 		RECORD_ERROR(dbh);
 		return 0;
 	}
-	
-	/* in order to support named params, which Firebird itself doesn't, 
+
+	/* in order to support named params, which Firebird itself doesn't,
 	   we need to replace :foo by ?, and store the name we just replaced */
 	new_sql = c = emalloc(sql_len+1);
-	
+
 	for (l = in_quote = in_param = 0; l <= sql_len; ++l) {
 		if ( !(in_quote ^= (sql[l] == '\''))) {
 			if (!in_param) {
@@ -439,9 +439,9 @@ static int firebird_alloc_prepare_stmt(pdo_dbh_t *dbh, const char *sql, long sql
 				}
 			} else {
                                 if ((in_param &= ((sql[l] >= 'A' && sql[l] <= 'Z') || (sql[l] >= 'a' && sql[l] <= 'z')
-                                        || (sql[l] >= '0' && sql[l] <= '9') || sql[l] == '_' || sql[l] == '-'))) { 
+                                        || (sql[l] >= '0' && sql[l] <= '9') || sql[l] == '_' || sql[l] == '-'))) {
+
 
-					
 					*ppname++ = sql[l];
 					continue;
 				} else {
@@ -462,12 +462,12 @@ static int firebird_alloc_prepare_stmt(pdo_dbh_t *dbh, const char *sql, long sql
 		efree(new_sql);
 		return 0;
 	}
-	
+
 	efree(new_sql);
 	return 1;
 }
 /* }}} */
-	
+
 /* called by PDO to set a driver-specific dbh attribute */
 static int firebird_handle_set_attribute(pdo_dbh_t *dbh, long attr, zval *val TSRMLS_DC) /* {{{ */
 {
@@ -477,8 +477,8 @@ static int firebird_handle_set_attribute(pdo_dbh_t *dbh, long attr, zval *val TS
 		case PDO_ATTR_AUTOCOMMIT:
 
 			convert_to_boolean(val);
-	
-			/* ignore if the new value equals the old one */			
+
+			/* ignore if the new value equals the old one */
 			if (dbh->auto_commit ^ Z_BVAL_P(val)) {
 				if (dbh->in_txn) {
 					if (Z_BVAL_P(val)) {
@@ -508,7 +508,7 @@ static int firebird_handle_set_attribute(pdo_dbh_t *dbh, long attr, zval *val TS
 			if (H->date_format) {
 				efree(H->date_format);
 			}
-			spprintf(&H->date_format, 0, "%s", Z_STRVAL_P(val)); 
+			spprintf(&H->date_format, 0, "%s", Z_STRVAL_P(val));
 			return 1;
 
 		case PDO_FB_ATTR_TIME_FORMAT:
@@ -516,7 +516,7 @@ static int firebird_handle_set_attribute(pdo_dbh_t *dbh, long attr, zval *val TS
 			if (H->time_format) {
 				efree(H->time_format);
 			}
-			spprintf(&H->time_format, 0, "%s", Z_STRVAL_P(val)); 
+			spprintf(&H->time_format, 0, "%s", Z_STRVAL_P(val));
 			return 1;
 
 		case PDO_FB_ATTR_TIMESTAMP_FORMAT:
@@ -524,7 +524,7 @@ static int firebird_handle_set_attribute(pdo_dbh_t *dbh, long attr, zval *val TS
 			if (H->timestamp_format) {
 				efree(H->timestamp_format);
 			}
-			spprintf(&H->timestamp_format, 0, "%s", Z_STRVAL_P(val)); 
+			spprintf(&H->timestamp_format, 0, "%s", Z_STRVAL_P(val));
 			return 1;
 	}
 	return 0;
@@ -550,7 +550,7 @@ static int firebird_handle_get_attribute(pdo_dbh_t *dbh, long attr, zval *val TS
 
 	switch (attr) {
 		char tmp[512];
-		
+
 		case PDO_ATTR_AUTOCOMMIT:
 			ZVAL_LONG(val,dbh->auto_commit);
 			return 1;
@@ -575,33 +575,33 @@ static int firebird_handle_get_attribute(pdo_dbh_t *dbh, long attr, zval *val TS
 			if (info_func) {
 				info_func(tmp);
 				ZVAL_STRING(val,tmp,1);
-			} 
+			}
 #else
 			ZVAL_NULL(val);
 #endif
 			}
 			return 1;
-			
+
 		case PDO_ATTR_SERVER_VERSION:
 		case PDO_ATTR_SERVER_INFO:
 			*tmp = 0;
-			
+
 			if (!isc_version(&H->db, firebird_info_cb, (void*)tmp)) {
 				ZVAL_STRING(val,tmp,1);
 				return 1;
 			}
-			
+
 		case PDO_ATTR_FETCH_TABLE_NAMES:
 			ZVAL_BOOL(val, H->fetch_table_names);
 			return 1;
 	}
 	return 0;
-}       
+}
 /* }}} */
-        
+
 /* called by PDO to retrieve driver-specific information about an error that has occurred */
 static int pdo_firebird_fetch_error_func(pdo_dbh_t *dbh, pdo_stmt_t *stmt, zval *info TSRMLS_DC) /* {{{ */
-{       
+{
 	pdo_firebird_db_handle *H = (pdo_firebird_db_handle *)dbh->driver_data;
 	const ISC_STATUS *s = H->isc_status;
 	char buf[400];
@@ -653,14 +653,14 @@ static int pdo_firebird_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRM
 	pdo_firebird_db_handle *H = dbh->driver_data = pecalloc(1,sizeof(*H),dbh->is_persistent);
 
 	php_pdo_parse_data_source(dbh->data_source, dbh->data_source_len, vars, 3);
-	
+
 	do {
-		static char const dpb_flags[] = { 
+		static char const dpb_flags[] = {
 			isc_dpb_user_name, isc_dpb_password, isc_dpb_lc_ctype, isc_dpb_sql_role_name };
 		char const *dpb_values[] = { dbh->username, dbh->password, vars[1].optval, vars[2].optval };
 		char dpb_buffer[256] = { isc_dpb_version1 }, *dpb;
-		
-		dpb = dpb_buffer + 1; 
+
+		dpb = dpb_buffer + 1;
 
 		/* loop through all the provided arguments and set dpb fields accordingly */
 		for (i = 0; i < sizeof(dpb_flags); ++i) {
@@ -671,20 +671,20 @@ static int pdo_firebird_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRM
 				buf_len -= dpb_len;
 			}
 		}
-		
+
 		/* fire it up baby! */
 		if (isc_attach_database(H->isc_status, 0, vars[0].optval, &H->db,(short)(dpb-dpb_buffer), dpb_buffer)) {
 			break;
 		}
-		
+
 		dbh->methods = &firebird_methods;
 		dbh->native_case = PDO_CASE_UPPER;
 		dbh->alloc_own_columns = 1;
-		
+
 		ret = 1;
-		
+
 	} while (0);
-		
+
 	for (i = 0; i < sizeof(vars)/sizeof(vars[0]); ++i) {
 		if (vars[i].freeme) {
 			efree(vars[i].optval);
@@ -695,8 +695,7 @@ static int pdo_firebird_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRM
 		char errmsg[512];
 		const ISC_STATUS *s = H->isc_status;
 		fb_interpret(errmsg, sizeof(errmsg),&s);
-		zend_throw_exception_ex(php_pdo_get_exception(), H->isc_status[1] TSRMLS_CC, "SQLSTATE[%s] [%d] %s",
-				"HY000", H->isc_status[1], errmsg);
+		pdo_throw_exception_ex("HY000", H->isc_status[1] TSRMLS_CC, "SQLSTATE[%s] [%d] %s", "HY000", H->isc_status[1], errmsg);
 	}
 
 	if (!ret) {
diff --git a/ext/pdo_mysql/mysql_driver.c b/ext/pdo_mysql/mysql_driver.c
index e82fdf46db82..33a6ad720ef4 100644
--- a/ext/pdo_mysql/mysql_driver.c
+++ b/ext/pdo_mysql/mysql_driver.c
@@ -46,7 +46,7 @@
 int _pdo_mysql_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, const char *file, int line TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H = (pdo_mysql_db_handle *)dbh->driver_data;
-	pdo_error_type *pdo_err; 
+	pdo_error_type *pdo_err;
 	pdo_mysql_error_info *einfo;
 	pdo_mysql_stmt *S = NULL;
 
@@ -105,8 +105,7 @@ int _pdo_mysql_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, const char *file, int lin
 
 	if (!dbh->methods) {
 		PDO_DBG_INF("Throwing exception");
-		zend_throw_exception_ex(php_pdo_get_exception(), einfo->errcode TSRMLS_CC, "SQLSTATE[%s] [%d] %s",
-				*pdo_err, einfo->errcode, einfo->errmsg);
+		pdo_throw_exception_ex(*pdo_err, einfo->errcode TSRMLS_CC, "SQLSTATE[%s] [%d] %s", *pdo_err, einfo->errcode, einfo->errmsg);
 	}
 
 	PDO_DBG_RETURN(einfo->errcode);
@@ -141,7 +140,7 @@ static int pdo_mysql_fetch_error_func(pdo_dbh_t *dbh, pdo_stmt_t *stmt, zval *in
 static int mysql_handle_closer(pdo_dbh_t *dbh TSRMLS_DC)
 {
 	pdo_mysql_db_handle *H = (pdo_mysql_db_handle *)dbh->driver_data;
-	
+
 	PDO_DBG_ENTER("mysql_handle_closer");
 	PDO_DBG_INF_FMT("dbh=%p", dbh);
 	if (H) {
@@ -169,7 +168,7 @@ static int mysql_handle_preparer(pdo_dbh_t *dbh, const char *sql, long sql_len,
 	int nsql_len = 0;
 	int ret;
 	int server_version;
-	
+
 	PDO_DBG_ENTER("mysql_handle_preparer");
 	PDO_DBG_INF_FMT("dbh=%p", dbh);
 	PDO_DBG_INF_FMT("sql=%.*s", sql_len, sql);
@@ -206,7 +205,7 @@ static int mysql_handle_preparer(pdo_dbh_t *dbh, const char *sql, long sql_len,
 		}
 		PDO_DBG_RETURN(0);
 	}
-	
+
 	if (mysql_stmt_prepare(S->stmt, sql, sql_len)) {
 		/* TODO: might need to pull statement specific info here? */
 		/* if the query isn't supported by the protocol, fallback to emulation */
@@ -247,7 +246,7 @@ static int mysql_handle_preparer(pdo_dbh_t *dbh, const char *sql, long sql_len,
 fallback:
 end:
 	stmt->supports_placeholders = PDO_PLACEHOLDER_NONE;
-	
+
 	PDO_DBG_RETURN(1);
 }
 /* }}} */
@@ -374,10 +373,10 @@ static int pdo_mysql_set_attribute(pdo_dbh_t *dbh, long attr, zval *val TSRMLS_D
 	PDO_DBG_INF_FMT("dbh=%p", dbh);
 	PDO_DBG_INF_FMT("attr=%l", attr);
 	switch (attr) {
-		case PDO_ATTR_AUTOCOMMIT:		
+		case PDO_ATTR_AUTOCOMMIT:
 			convert_to_boolean(val);
-	
-			/* ignore if the new value equals the old one */			
+
+			/* ignore if the new value equals the old one */
 			if (dbh->auto_commit ^ Z_BVAL_P(val)) {
 				dbh->auto_commit = Z_BVAL_P(val);
 				mysql_handle_autocommit(dbh TSRMLS_CC);
@@ -453,7 +452,7 @@ static int pdo_mysql_get_attribute(pdo_dbh_t *dbh, long attr, zval *return_value
 		case PDO_ATTR_AUTOCOMMIT:
 			ZVAL_LONG(return_value, dbh->auto_commit);
 			break;
-			
+
 		case PDO_MYSQL_ATTR_USE_BUFFERED_QUERY:
 			ZVAL_LONG(return_value, H->buffered);
 			break;
@@ -470,7 +469,7 @@ static int pdo_mysql_get_attribute(pdo_dbh_t *dbh, long attr, zval *return_value
 #endif
 
 		default:
-			PDO_DBG_RETURN(0);	
+			PDO_DBG_RETURN(0);
 	}
 
 	PDO_DBG_RETURN(1);
@@ -507,7 +506,7 @@ static int pdo_mysql_check_liveness(pdo_dbh_t *dbh TSRMLS_DC)
 	signal(SIGPIPE, handler);
 #endif /* end mysql_ping() */
 	PDO_DBG_RETURN(SUCCESS);
-} 
+}
 /* }}} */
 
 /* {{{ mysql_methods */
@@ -586,7 +585,7 @@ static int pdo_mysql_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 		pdo_mysql_error(dbh);
 		goto cleanup;
 	}
-	
+
 	dbh->driver_data = H;
 
 #ifndef PDO_USE_MYSQLND
@@ -609,7 +608,7 @@ static int pdo_mysql_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 
 		H->emulate_prepare = pdo_attr_lval(driver_options,
 			PDO_MYSQL_ATTR_DIRECT_QUERY, H->emulate_prepare TSRMLS_CC);
-		H->emulate_prepare = pdo_attr_lval(driver_options, 
+		H->emulate_prepare = pdo_attr_lval(driver_options,
 			PDO_ATTR_EMULATE_PREPARES, H->emulate_prepare TSRMLS_CC);
 
 #ifndef PDO_USE_MYSQLND
@@ -633,7 +632,7 @@ static int pdo_mysql_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 #if PHP_API_VERSION < 20100412
 		if ((PG(open_basedir) && PG(open_basedir)[0] != '\0') || PG(safe_mode))
 #else
-		if (PG(open_basedir) && PG(open_basedir)[0] != '\0') 
+		if (PG(open_basedir) && PG(open_basedir)[0] != '\0')
 #endif
 		{
 			local_infile = 0;
@@ -664,7 +663,7 @@ static int pdo_mysql_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 			}
 			str_efree(init_cmd);
 		}
-#ifndef PDO_USE_MYSQLND		
+#ifndef PDO_USE_MYSQLND
 		default_file = pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_READ_DEFAULT_FILE, NULL TSRMLS_CC);
 		if (default_file) {
 			if (mysql_options(H->server, MYSQL_READ_DEFAULT_FILE, (const char *)default_file)) {
@@ -674,7 +673,7 @@ static int pdo_mysql_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 			}
 			str_efree(default_file);
 		}
-		
+
 		default_group= pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_READ_DEFAULT_GROUP, NULL TSRMLS_CC);
 		if (default_group) {
 			if (mysql_options(H->server, MYSQL_READ_DEFAULT_GROUP, (const char *)default_group)) {
@@ -698,7 +697,7 @@ static int pdo_mysql_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 		ssl_ca = pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_SSL_CA, NULL TSRMLS_CC);
 		ssl_capath = pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_SSL_CAPATH, NULL TSRMLS_CC);
 		ssl_cipher = pdo_attr_strval(driver_options, PDO_MYSQL_ATTR_SSL_CIPHER, NULL TSRMLS_CC);
-		
+
 		if (ssl_key || ssl_cert || ssl_ca || ssl_capath || ssl_cipher) {
 			mysql_ssl_set(H->server, ssl_key, ssl_cert, ssl_ca, ssl_capath, ssl_cipher);
 			if (ssl_key) {
@@ -741,7 +740,7 @@ static int pdo_mysql_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 #endif
 
 	dbname = vars[1].optval;
-	host = vars[2].optval;	
+	host = vars[2].optval;
 	if(vars[3].optval) {
 		port = atoi(vars[3].optval);
 	}
@@ -784,14 +783,14 @@ static int pdo_mysql_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_
 	dbh->methods = &mysql_methods;
 
 	ret = 1;
-	
+
 cleanup:
 	for (i = 0; i < sizeof(vars)/sizeof(vars[0]); i++) {
 		if (vars[i].freeme) {
 			efree(vars[i].optval);
 		}
 	}
-	
+
 	dbh->methods = &mysql_methods;
 
 	PDO_DBG_RETURN(ret);
diff --git a/ext/pdo_oci/oci_driver.c b/ext/pdo_oci/oci_driver.c
index a0cbb5832955..92f86ca679ab 100644
--- a/ext/pdo_oci/oci_driver.c
+++ b/ext/pdo_oci/oci_driver.c
@@ -141,7 +141,7 @@ ub4 _oci_error(OCIError *err, pdo_dbh_t *dbh, pdo_stmt_t *stmt, char *what, swor
 				case 12154:	/* ORA-12154: TNS:could not resolve service name */
 					strcpy(*pdo_err, "42S02");
 					break;
-				
+
 				case	22:	/* ORA-00022: invalid session id */
 				case   378:
 				case   602:
@@ -188,7 +188,7 @@ ub4 _oci_error(OCIError *err, pdo_dbh_t *dbh, pdo_stmt_t *stmt, char *what, swor
 
 	/* little mini hack so that we can use this code from the dbh ctor */
 	if (!dbh->methods) {
-		zend_throw_exception_ex(php_pdo_get_exception(), einfo->errcode TSRMLS_CC, "SQLSTATE[%s]: %s", *pdo_err, einfo->errmsg);
+		pdo_throw_exception_ex(*pdo_err, einfo->errcode TSRMLS_CC, "SQLSTATE[%s] [%d] %s", *pdo_err, einfo->errcode, einfo->errmsg);
 	}
 
 	return einfo->errcode;
@@ -388,19 +388,19 @@ static int oci_handle_quoter(pdo_dbh_t *dbh, const char *unquoted, int unquotedl
 	*quotedlen = unquotedlen + qcount + 2;
 	*quoted = c = emalloc(*quotedlen+1);
 	*c++ = '\'';
-	
+
 	/* foreach (chunk that ends in a quote) */
 	for (l = unquoted; (r = strchr(l,'\'')); l = r+1) {
 		strncpy(c, l, r-l+1);
-		c += (r-l+1);		
+		c += (r-l+1);
 		*c++ = '\'';			/* add second quote */
 	}
 
-    /* Copy remainder and add enclosing quote */	
+    /* Copy remainder and add enclosing quote */
 	strncpy(c, l, *quotedlen-(c-*quoted)-1);
-	(*quoted)[*quotedlen-1] = '\''; 
+	(*quoted)[*quotedlen-1] = '\'';
 	(*quoted)[*quotedlen]   = '\0';
-	
+
 	return 1;
 }
 /* }}} */
@@ -463,7 +463,7 @@ static int oci_handle_set_attribute(pdo_dbh_t *dbh, long attr, zval *val TSRMLS_
 	} else {
 		return 0;
 	}
-	
+
 }
 /* }}} */
 
@@ -478,7 +478,7 @@ static int oci_handle_get_attribute(pdo_dbh_t *dbh, long attr, zval *return_valu
 			text infostr[512];
 			char verstr[15];
 			ub4  vernum;
-			
+
 			if (OCIServerRelease(H->svc, H->err, infostr, (ub4)sizeof(infostr), (ub1)OCI_HTYPE_SVCCTX, &vernum))
 			{
 				ZVAL_STRING(return_value, "<<Unknown>>", 1);
@@ -486,13 +486,13 @@ static int oci_handle_get_attribute(pdo_dbh_t *dbh, long attr, zval *return_valu
 				if (attr == PDO_ATTR_SERVER_INFO) {
 					ZVAL_STRING(return_value, (char *)infostr, 1);
 				} else {
-					slprintf(verstr, sizeof(verstr), "%d.%d.%d.%d.%d", 
+					slprintf(verstr, sizeof(verstr), "%d.%d.%d.%d.%d",
 							 (int)((vernum>>24) & 0xFF),  /* version number */
 							 (int)((vernum>>20) & 0x0F),  /* release number*/
 							 (int)((vernum>>12) & 0xFF),  /* update number */
 							 (int)((vernum>>8)  & 0x0F),  /* port release number */
 							 (int)((vernum>>0)  & 0xFF)); /* port update number */
-					
+
 					ZVAL_STRING(return_value, verstr, 1);
 				}
 			}
@@ -552,7 +552,7 @@ static int pdo_oci_check_liveness(pdo_dbh_t *dbh TSRMLS_DC) /* {{{ */
 	 * such as from Pre-10.1 servers, the error is still from the server and we would have
 	 * successfully performed a roundtrip and validated the connection. Use OCIServerVersion for
 	 * Pre-10.2 clients
-	 */	
+	 */
 #if ((OCI_MAJOR_VERSION > 10) || ((OCI_MAJOR_VERSION == 10) && (OCI_MINOR_VERSION >= 2)))	/* OCIPing available 10.2 onwards */
 	H->last_err = OCIPing (H->svc, H->err, OCI_DEFAULT);
 #else
@@ -564,7 +564,7 @@ static int pdo_oci_check_liveness(pdo_dbh_t *dbh TSRMLS_DC) /* {{{ */
 	}
 
 	OCIErrorGet (H->err, (ub4)1, NULL, &error_code, NULL, 0, OCI_HTYPE_ERROR);
-	
+
 	if (error_code == 1010) {
 		return SUCCESS;
 	}
diff --git a/ext/pdo_odbc/odbc_driver.c b/ext/pdo_odbc/odbc_driver.c
index f274bf98ebe4..254336a1d07b 100644
--- a/ext/pdo_odbc/odbc_driver.c
+++ b/ext/pdo_odbc/odbc_driver.c
@@ -104,8 +104,7 @@ void pdo_odbc_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, PDO_ODBC_HSTMT statement,
 	strcpy(*pdo_err, einfo->last_state);
 /* printf("@@ SQLSTATE[%s] %s\n", *pdo_err, einfo->last_err_msg); */
 	if (!dbh->methods) {
-		zend_throw_exception_ex(php_pdo_get_exception(), einfo->last_error TSRMLS_CC, "SQLSTATE[%s] %s: %d %s",
-				*pdo_err, what, einfo->last_error, einfo->last_err_msg);
+		pdo_throw_exception_ex(*pdo_err, einfo->last_error TSRMLS_CC, "SQLSTATE[%s] %s: %d %s", *pdo_err, what, einfo->last_error, einfo->last_err_msg);
 	}
 
 	/* just like a cursor, once you start pulling, you need to keep
@@ -159,7 +158,7 @@ static int odbc_handle_preparer(pdo_dbh_t *dbh, const char *sql, long sql_len, p
 	 * we want PDO to rewrite them for us */
 	stmt->supports_placeholders = PDO_PLACEHOLDER_POSITIONAL;
 	ret = pdo_parse_params(stmt, (char*)sql, sql_len, &nsql, &nsql_len TSRMLS_CC);
-	
+
 	if (ret == 1) {
 		/* query was re-written */
 		sql = nsql;
@@ -169,7 +168,7 @@ static int odbc_handle_preparer(pdo_dbh_t *dbh, const char *sql, long sql_len, p
 		efree(S);
 		return 0;
 	}
-	
+
 	rc = SQLAllocHandle(SQL_HANDLE_STMT, H->dbc, &S->stmt);
 
 	if (rc == SQL_INVALID_HANDLE || rc == SQL_ERROR) {
@@ -193,7 +192,7 @@ static int odbc_handle_preparer(pdo_dbh_t *dbh, const char *sql, long sql_len, p
 			return 0;
 		}
 	}
-	
+
 	rc = SQLPrepare(S->stmt, (char*)sql, SQL_NTS);
 	if (nsql) {
 		efree(nsql);
@@ -226,7 +225,7 @@ static long odbc_handle_doer(pdo_dbh_t *dbh, const char *sql, long sql_len TSRML
 	RETCODE rc;
 	SQLLEN row_count = -1;
 	PDO_ODBC_HSTMT	stmt;
-	
+
 	rc = SQLAllocHandle(SQL_HANDLE_STMT, H->dbc, &stmt);
 	if (rc != SQL_SUCCESS) {
 		pdo_odbc_drv_error("SQLAllocHandle: STMT");
@@ -398,7 +397,7 @@ static int pdo_odbc_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_D
 	H = pecalloc(1, sizeof(*H), dbh->is_persistent);
 
 	dbh->driver_data = H;
-	
+
 	SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &H->env);
 	rc = SQLSetEnvAttr(H->env, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);
 
@@ -416,7 +415,7 @@ static int pdo_odbc_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_D
 		}
 	}
 #endif
-	
+
 	rc = SQLAllocHandle(SQL_HANDLE_DBC, H->env, &H->dbc);
 	if (rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO) {
 		pdo_odbc_drv_error("SQLAllocHandle (DBC)");
@@ -469,7 +468,7 @@ static int pdo_odbc_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS_D
 
 	dbh->methods = &odbc_methods;
 	dbh->alloc_own_columns = 1;
-	
+
 	return 1;
 
 fail:
diff --git a/ext/pdo_pgsql/pgsql_driver.c b/ext/pdo_pgsql/pgsql_driver.c
index 8467552596c9..2a7158b8f391 100644
--- a/ext/pdo_pgsql/pgsql_driver.c
+++ b/ext/pdo_pgsql/pgsql_driver.c
@@ -105,8 +105,7 @@ int _pdo_pgsql_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, int errcode, const char *
 	}
 
 	if (!dbh->methods) {
-		zend_throw_exception_ex(php_pdo_get_exception(), einfo->errcode TSRMLS_CC, "SQLSTATE[%s] [%d] %s",
-				*pdo_err, einfo->errcode, einfo->errmsg);
+		pdo_throw_exception_ex(pdo_err, einfo->errcode TSRMLS_CC, "SQLSTATE[%s] [%d] %s", *pdo_err, einfo->errcode, einfo->errmsg);
 	}
 
 	return errcode;
diff --git a/ext/pdo_sqlite/sqlite_driver.c b/ext/pdo_sqlite/sqlite_driver.c
index 09df8d7996bb..a26067b43641 100644
--- a/ext/pdo_sqlite/sqlite_driver.c
+++ b/ext/pdo_sqlite/sqlite_driver.c
@@ -53,7 +53,7 @@ int _pdo_sqlite_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, const char *file, int li
 	switch (einfo->errcode) {
 		case SQLITE_NOTFOUND:
 			strncpy(*pdo_err, "42S02", sizeof("42S02"));
-			break;	
+			break;
 
 		case SQLITE_INTERRUPT:
 			strncpy(*pdo_err, "01002", sizeof("01002"));
@@ -66,7 +66,7 @@ int _pdo_sqlite_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, const char *file, int li
 		case SQLITE_TOOBIG:
 			strncpy(*pdo_err, "22001", sizeof("22001"));
 			break;
-	
+
 		case SQLITE_CONSTRAINT:
 			strncpy(*pdo_err, "23000", sizeof("23000"));
 			break;
@@ -78,10 +78,9 @@ int _pdo_sqlite_error(pdo_dbh_t *dbh, pdo_stmt_t *stmt, const char *file, int li
 	}
 
 	if (!dbh->methods) {
-		zend_throw_exception_ex(php_pdo_get_exception(), einfo->errcode TSRMLS_CC, "SQLSTATE[%s] [%d] %s",
-				*pdo_err, einfo->errcode, einfo->errmsg);
+		pdo_throw_exception_ex(*pdo_err, einfo->errcode TSRMLS_CC, "SQLSTATE[%s] [%d] %s", *pdo_err, einfo->errcode, einfo->errmsg);
 	}
-	
+
 	return einfo->errcode;
 }
 /* }}} */
@@ -155,7 +154,7 @@ static void pdo_sqlite_cleanup_callbacks(pdo_sqlite_db_handle *H TSRMLS_DC)
 static int sqlite_handle_closer(pdo_dbh_t *dbh TSRMLS_DC) /* {{{ */
 {
 	pdo_sqlite_db_handle *H = (pdo_sqlite_db_handle *)dbh->driver_data;
-	
+
 	if (H) {
 		pdo_sqlite_error_info *einfo = &H->einfo;
 
@@ -223,7 +222,7 @@ static char *pdo_sqlite_last_insert_id(pdo_dbh_t *dbh, const char *name, unsigne
 {
 	pdo_sqlite_db_handle *H = (pdo_sqlite_db_handle *)dbh->driver_data;
 	char *id;
-	
+
 	id = php_pdo_int64_to_str(sqlite3_last_insert_rowid(H->db) TSRMLS_CC);
 	*len = strlen(id);
 	return id;
@@ -287,9 +286,9 @@ static int pdo_sqlite_get_attribute(pdo_dbh_t *dbh, long attr, zval *return_valu
 		case PDO_ATTR_SERVER_VERSION:
 			ZVAL_STRING(return_value, (char *)sqlite3_libversion(), 1);
 			break;
-		
+
 		default:
-			return 0;	
+			return 0;
 	}
 
 	return 1;
@@ -318,13 +317,13 @@ static int do_callback(struct pdo_sqlite_fci *fc, zval *cb,
 	int ret;
 	int fake_argc;
 	zval **agg_context = NULL;
-	
+
 	if (is_agg) {
 		is_agg = 2;
 	}
-	
+
 	fake_argc = argc + is_agg;
-	
+
 	fc->fci.size = sizeof(fc->fci);
 	fc->fci.function_table = EG(function_table);
 	fc->fci.function_name = cb;
@@ -332,7 +331,7 @@ static int do_callback(struct pdo_sqlite_fci *fc, zval *cb,
 	fc->fci.object_ptr = NULL;
 	fc->fci.retval_ptr_ptr = &retval;
 	fc->fci.param_count = fake_argc;
-	
+
 	/* build up the params */
 
 	if (fake_argc) {
@@ -352,7 +351,7 @@ static int do_callback(struct pdo_sqlite_fci *fc, zval *cb,
 		MAKE_STD_ZVAL(*zargs[1]);
 		ZVAL_LONG(*zargs[1], sqlite3_aggregate_count(context));
 	}
-	
+
 	for (i = 0; i < argc; i++) {
 		zargs[i + is_agg] = emalloc(sizeof(zval *));
 		MAKE_STD_ZVAL(*zargs[i + is_agg]);
@@ -547,7 +546,7 @@ static PHP_METHOD(SQLite, sqliteCreateFunction)
 			&func_name, &func_name_len, &callback, &argc)) {
 		RETURN_FALSE;
 	}
-	
+
 	dbh = zend_object_store_get_object(getThis() TSRMLS_CC);
 	PDO_CONSTRUCT_CHECK;
 
@@ -557,7 +556,7 @@ static PHP_METHOD(SQLite, sqliteCreateFunction)
 		RETURN_FALSE;
 	}
 	efree(cbname);
-	
+
 	H = (pdo_sqlite_db_handle *)dbh->driver_data;
 
 	func = (struct pdo_sqlite_func*)ecalloc(1, sizeof(*func));
@@ -566,10 +565,10 @@ static PHP_METHOD(SQLite, sqliteCreateFunction)
 			func, php_sqlite3_func_callback, NULL, NULL);
 	if (ret == SQLITE_OK) {
 		func->funcname = estrdup(func_name);
-		
+
 		MAKE_STD_ZVAL(func->func);
 		MAKE_COPY_ZVAL(&callback, func->func);
-		
+
 		func->argc = argc;
 
 		func->next = H->funcs;
@@ -601,7 +600,7 @@ static PHP_METHOD(SQLite, sqliteCreateFunction)
    The return value of this function will be used as the return value for this
    aggregate UDF.
 */
-   
+
 static PHP_METHOD(SQLite, sqliteCreateAggregate)
 {
 	struct pdo_sqlite_func *func;
@@ -618,7 +617,7 @@ static PHP_METHOD(SQLite, sqliteCreateAggregate)
 			&func_name, &func_name_len, &step_callback, &fini_callback, &argc)) {
 		RETURN_FALSE;
 	}
-	
+
 	dbh = zend_object_store_get_object(getThis() TSRMLS_CC);
 	PDO_CONSTRUCT_CHECK;
 
@@ -634,7 +633,7 @@ static PHP_METHOD(SQLite, sqliteCreateAggregate)
 		RETURN_FALSE;
 	}
 	efree(cbname);
-	
+
 	H = (pdo_sqlite_db_handle *)dbh->driver_data;
 
 	func = (struct pdo_sqlite_func*)ecalloc(1, sizeof(*func));
@@ -643,13 +642,13 @@ static PHP_METHOD(SQLite, sqliteCreateAggregate)
 			func, NULL, php_sqlite3_func_step_callback, php_sqlite3_func_final_callback);
 	if (ret == SQLITE_OK) {
 		func->funcname = estrdup(func_name);
-		
+
 		MAKE_STD_ZVAL(func->step);
 		MAKE_COPY_ZVAL(&step_callback, func->step);
 
 		MAKE_STD_ZVAL(func->fini);
 		MAKE_COPY_ZVAL(&fini_callback, func->fini);
-		
+
 		func->argc = argc;
 
 		func->next = H->funcs;
@@ -815,7 +814,7 @@ static int pdo_sqlite_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS
 	char *filename;
 
 	H = pecalloc(1, sizeof(pdo_sqlite_db_handle), dbh->is_persistent);
-	
+
 	H->einfo.errcode = 0;
 	H->einfo.errmsg = NULL;
 	dbh->driver_data = H;
@@ -850,10 +849,10 @@ static int pdo_sqlite_handle_factory(pdo_dbh_t *dbh, zval *driver_options TSRMLS
 	dbh->max_escaped_char_length = 2;
 
 	ret = 1;
-	
+
 cleanup:
 	dbh->methods = &sqlite_methods;
-	
+
 	return ret;
 }
 /* }}} */
