diff --git a/docs/claripy.md b/docs/claripy.md
index d2432a1..06d3a5e 100644
--- a/docs/claripy.md
+++ b/docs/claripy.md
@@ -24,8 +24,8 @@ Currently, Claripy supports the following types of ASTs:
 
 | Name | Description | Supported By (Claripy Backends) | Example Code |
 |------|-------------|-----------------------------|---------------|
-| BV | This is a bitvector, whether symbolic (with a name) or concrete (with a value). It has a size (in bits). | BackendConcrete, BackendVSA, BackendZ3 | <ul><li>Create a 32-bit symbolic bitvector "x": `claripy.BVS('x', 32)`</li><li>Create a 32-bit bitvector with the value `0xc001b3475`: `claripy.BVV(0xc001b3a75, 32)`</li><li>Create a 32-bit "strided interval" (see VSA documentation) that can be any divisible-by-10 number between 1000 and 2000: `claripy.SI(name='x', bits=32, lower_bound=1000, upper_bound=2000, stride=10)`</li></ul>   |
-| FP | This is a floating-point number, whether symbolic (with a name) or concrete (with a value). | BackendConcrete, BackendZ3 | TODO  |
+| BV | This is a bitvector, whether symbolic (with a name) or concrete (with a value). It has a size (in bits). | BackendConcrete, BackendVSA, BackendZ3 | <ul><li>Create a 32-bit symbolic bitvector "x": `claripy.BVS('x', 32)`</li><li>Create a 32-bit bitvector with the value `0xc001b3475`: `claripy.BVV(0xc001b3a75, 32)`</li><li>Create a 32-bit "strided interval" (see VSA documentation) that can be any divisible-by-10 number between 1000 and 2000: `claripy.SI(name='x', bits=32, lower_bound=1000, upper_bound=2000, stride=10)`</li></ul> |
+| FP | This is a floating-point number, whether symbolic (with a name) or concrete (with a value). | BackendConcrete, BackendZ3 | <ul><li>Create a `claripy.fp.FSORT_DOUBLE` symbolic floating point "b": `claripy.FPS('b', claripy.fp.FSORT_DOUBLE)`</li><li>Create a `claripy.fp.FSORT_FLOAT` floating point with value `3.2`: `claripy.FPV(3.2, claripy.fp.FSORT_FLOAT)`</li></ul> |
 | Bool | This is a boolean operation (True or False). | BackendConcrete, BackendVSA, BackendZ3 | `claripy.BoolV(True)`, or `claripy.true` or `claripy.false`, or by comparing two ASTs (i.e., `claripy.BVS('x', 32) < claripy.BVS('y', 32)` |
 
 All of the above creation code returns claripy.AST objects, on which operations can then be carried out.
diff --git a/docs/environment.md b/docs/environment.md
index 8f8f3db..9d88a75 100644
--- a/docs/environment.md
+++ b/docs/environment.md
@@ -14,14 +14,14 @@ You _probably_ want to have a development install of angr, i.e. set up with the
 It is remarkably easy to add new API models by just implementing them in certain folders of the angr repository.
 This is also desirable because any work you do in this field will almost always be useful to other people, and this makes it extremely easy to submit a pull request.
 
-However, if you want to do your development out-of-tree, you want to work against a production version of angr, or you want to make customized versions of already-implemented API functions, there are ways to incorperate your extensions programmatically.
+However, if you want to do your development out-of-tree, you want to work against a production version of angr, or you want to make customized versions of already-implemented API functions, there are ways to incorporate your extensions programmatically.
 Both these techniques, in-tree and out-of-tree, will be documented at each step.
 
 ## Dynamic library functions - import dependencies
 
 This is the easiest case, and the case that SimProcedures were originally designed for.
 
-First, you need to write a SimProcedure represnting the function.
+First, you need to write a SimProcedure representing the function.
 Then you need to let angr know about it.
 
 ### Case 1, in-tree development: SimLibraries and catalogues
@@ -66,7 +66,7 @@ Finally, if you don't want to mess with SimLibraries at all, you can do things p
 
 ## Syscalls
 
-Unlike dynamic library methods, syscall procedures aren't incorperated into the project via hooks.
+Unlike dynamic library methods, syscall procedures aren't incorporated into the project via hooks.
 Instead, whenever a syscall instruction is encountered, the basic block should end with a jumpkind of `Ijk_Sys`.
 This will cause the next step to be handled by the SimOS associated with the project, which will extract the syscall number from the state and query a specialized SimLibrary with that.
 
diff --git a/docs/examples.md b/docs/examples.md
index cda545d..fc0bb00 100644
--- a/docs/examples.md
+++ b/docs/examples.md
@@ -4,7 +4,7 @@ To help you get started with [angr](https://github.com/angr/angr), we've created
 We've tried to organize them into major categories, and briefly summarize that each example will expose you to.
 Enjoy!
 
-There are also a great amount of slightly more redunant examples (these mostly stem from CTF problems solved with angr by Shellphish) [here](more-examples.md).
+There are also a great amount of slightly more redundant examples (these mostly stem from CTF problems solved with angr by Shellphish) [here](more-examples.md).
 
 To jump to a specific category:
 
diff --git a/docs/state_plugins.md b/docs/state_plugins.md
index d46ed32..050dfc2 100644
--- a/docs/state_plugins.md
+++ b/docs/state_plugins.md
@@ -1,6 +1,6 @@
 # State Plugins
 
-If you want to store some data on a state and have that information propogated from successor to successor, the easiest way to do this is with `state.globals`.
+If you want to store some data on a state and have that information propagated from successor to successor, the easiest way to do this is with `state.globals`.
 However, this can become obnoxious with large amounts of interesting data, doesn't work at all for merging states, and isn't very object-oriented.
 
 The solution to these problems is to write a *State Plugin* - an appendix to the state that holds data and implements an interface for dealing with the lifecycle of a state.
@@ -44,7 +44,7 @@ It works! Note that plugins automatically become available as attributes on the
 
 State plugins have access to the state, right? So why isn't it part of the initializer?
 It turns out, there are a plethora of issues related to initialization order and dependency issues, so to simplify things as much as possible, the state is not part of the initializer but is rather set onto the state in a separate phase, by using the `set_state` method.
-You can override this state if you need to do things like propogate the state to subcomponents or extract architectural information.
+You can override this state if you need to do things like propagate the state to subcomponents or extract architectural information.
 
 ```python
 >>> def set_state(self, state):
