diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index 98708c8..f4bf6f4 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -1,41 +1,41 @@
-# Intro
+# 介绍
 
-The following cheatsheet aims to give a an overview of various things you can do with angr and as a quick reference to check what exactly the syntax for something was without having to dig through the deeper docs.
+本节旨在提供一个 angr 能做什么的概览，作为使用者的快速参考，不需要深入了解文档就可以学会一些用法
 
-WARNING: This page is for angr 6 and some parts will not be correct for angr 7
+警告：该页面面向 angr 6，某些部分不适用于 angr 7
 
-## General getting started
+## 通用开始
 
-Some useful imports
+一些有用的 imports
 
 ```python
-import angr #the main framework
-import claripy #the solver engine
+import angr # 主框架
+import claripy # 求解引擎
 ```
 
-Loading the binary
+装载二进制程序
 
 ```python
-proj = angr.Project("/path/to/binary", load_options={'auto_load_libs': False} ) # auto_load_libs False for improved performance
+proj = angr.Project("/path/to/binary", load_options={'auto_load_libs': False} ) # auto_load_libs 设置为 False 可以提高性能表现
 ```
 
 ## Path Groups
 
-Generate a path group object
+生成路径组对象
 
 ```python
 path_group = proj.factory.path_group(state, threads=4)
 ```
 
-## Exploring and analysing pathgroups
+## 探索分析路径组
 
-Choosing a different Exploring strategy
+选择不同的探索策略
 
 ```python
 path_group.use_technique(angr.exploration_techniques.DFS())
 ```
 
-Explore Pathgroup until one pathgroup at one of the adresses from `find=` is found
+直到一个路径组在 `find=` 的位置被发现，否则一直探索路径组
 
 ```python
 avoid_addr = [0x400c06, 0x400bc7]
@@ -48,25 +48,25 @@ found = path_group.found[] # The list of paths that reached find condition from
 found.state.se.any_str(sym_arg) # Return a concrete string value for the sym arg to reach this state
 ```
 
-Explore pathgroup until lambda is `True`
+直到 lambda 表达式为 `True`，否则不停止探索路径组
 
 ```python
 path_group.step(until=lambda p: p.active[0].addr >= first_jmp)
 ```
 
-This is especially useful with the ability to access the current STDOUT or STDERR (1 here is the File Descriptor for STDOUT)
+访问当前 STOUT 或 STDERR 是特别有用的（1 是 STDOUT 的文件描述符）
 
 ```python
 path_group.explore(find=lambda p: "correct" in p.state.posix.dumps(1))
 ```
 
-Memory Managment on big searches (Auto Drop Stashes):
+大搜索内存管理（自动丢弃 Stashes）
 
 ```python
 path_group.explore(find=find_addr, avoid=avoid_addr, step_func=lambda lpg: lpg.drop(stash='avoid'))
 ```
 
-### Manually Exploring
+### 手动探索
 
 ```python
 path_group.step(step_func=step_func, until=lambda lpg: len(lpg.found) > 0)
@@ -78,7 +78,7 @@ def step_func(lpg):
     return lpg
 ```
 
-Enable Logging:
+启用日志记录：
 
 ```python
 angr.path_group.l.setLevel("DEBUG")
@@ -86,28 +86,28 @@ angr.path_group.l.setLevel("DEBUG")
 
 ### Stashes
 
-Move Stash:
+移动 Stash：
 
 ```python
 path_group.stash(from_stash="found", to_stash="active")
 ```
 
-Drop Stashes:
+丢弃 Stashes：
 
 ```python
 path_group.drop(stash="avoid")
 ```
 
-## Constraint Solver (claripy)
+## 约束求解器
 
-Create symbolic object
+创建一个符号化对象
 
 ```python
 sym_arg_size = 15 #Length in Bytes because we will multiply with 8 later
 sym_arg = claripy.BVS('sym_arg', 8*sym_arg_size)
 ```
 
-Restrict sym_arg to typical char range
+将 sym_arg 限制在典型的 char 范围
 
 ```python
 for byte in sym_arg.chop(8):
@@ -116,7 +116,7 @@ for byte in sym_arg.chop(8):
     initial_state.add_constraints(byte <= '~') # '\x7e'
 ```
 
-Use the argument to create a state
+使用参数来创建一个 state：
 
 ```python
 argv = [project.filename]
@@ -124,16 +124,16 @@ argv.append(sym_arg)
 state = project.factory.entry_state(args=argv)
 ```
 
-Use argument for solving:
+使用参数来求解：
 
 ```python
 argv1 = angr.claripy.BVS("argv1", flag_size * 8)
 initial_state = b.factory.full_init_state(args=["./antidebug", argv1], add_options=simuvex.o.unicorn, remove_options={simuvex.o.LAZY_SOLVES})
 ```
 
-## FFI and Hooking
+## FFI 与 Hooking
 
-Calling a function from ipython
+在 ipython 中调用函数
 
 ```python
 f = proj.factory.callable(adress)
@@ -142,7 +142,9 @@ x=claripy.BVS('x', 64)
 f(x) #TODO: Find out how to make that result readable
 ```
 
-If what you are interested in is not directly returned because for example the function returns the pointer to a buffer you can access the state after the function returns with
+如果你感兴趣的内容没有直接返回，可能是因为：
+例如，函数返回指向缓冲区的指针，仍然可以在函数返回后访问该 state
+
 
 ```python
 >>> f.result_state
@@ -155,14 +157,14 @@ Hooking
 hook(addr, hook, length=0, kwargs=None)
 ```
 
-There are already predefined hooks for libc.so.6 functions (useful for staticly compiled libraries)
+已有用于 libc.so.6  函数的预定义钩子（对静态编译库有用）
 
 ```python
 hook = simuvex.SimProcedures['libc.so.6']['atoi']
 hook(addr, hook, length=4, kwargs=None)
 ```
 
-Hooking with Simprocedure:
+使用 Simprocedure 进行 Hooking：
 
 ```python
 class fixpid(SimProcedure):
@@ -172,9 +174,9 @@ class fixpid(SimProcedure):
 b.hook(0x4008cd, fixpid, length=5)
 ```
 
-## Other useful tricks
+## 其他有用的技巧
 
-Drop into an ipython if a ctr+c is recieved (useful for debugging scripts that are running forever)
+Drop into an ipython if a ctr+c is recieved (调试正在运行的脚本很有用)
 
 ```python
 import signal
@@ -189,14 +191,14 @@ def sigint_handler(signum, frame):
 signal.signal(signal.SIGINT, sigint_handler)
 ```
 
-Get the calltrace of a pathgroup to find out where we got stuck
+得到路径组的调用跟踪，以发现我们 stuck 的位置
 
 ```python
 path = path_group.active[0]
 path.callstack_backtrace
 ```
 
-Get a basic block
+获取基本块
 
 ```python
 block = proj.factory.block(address)
@@ -204,9 +206,9 @@ block.capstone.pp() #Capstone object has pretty print and other data about the d
 block.vex.pp()      #Print vex representation
 ```
 
-## State manipulation
+## State 操纵
 
-Write to state:
+写入 state:
 
 ```python
 aaaa = claripy.BVV(0x41414141, 32) # 32 = Bits
@@ -222,7 +224,7 @@ poi1 += 0x8
 ptr1 = (new_state.se.any_int(new_state.memory.load(poi1, 8, endness='Iend_LE')))
 ```
 
-Read from State:
+从 State 中读取：
 
 ```python
 key = []
@@ -230,9 +232,9 @@ for i in range(38):
     key.append(extractkey.se.any_int(extractkey.memory.load(0x602140+(i*4), 4, endness='Iend_LE')))
 ```
 
-## Debugging angr
+## 调试 angr
 
-Set Breakpoint at every Memory read/write:
+在每次内存读/写设置断点：
 
 ```python
 new_state.inspect.b('mem_read', when=simuvex.BP_AFTER, action=debug_funcRead)
@@ -240,7 +242,7 @@ def debug_funcRead(state):
     print 'Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address
 ```
 
-Set Breakpoint at specific Memory location:
+在特定内存位置上设定断点：
 
 ```python
 new_state.inspect.b('mem_write', mem_write_address=0x6021f1, when=simuvex.BP_AFTER, action=debug_funcWrite)
diff --git a/INSTALL.md b/INSTALL.md
index 1bf4b3f..ff4a2b1 100644
--- a/INSTALL.md
+++ b/INSTALL.md
@@ -1,22 +1,22 @@
-# Installing angr
+# 安装 angr
 
-angr is a python library, so it must be installed into your python environment before it can be used. It is built for Python 2: Py3k support is feasible somewhere out in the future, but we are a little hesitant to make that commitment right now (pull requests welcome!).
+angr 是一个 Python 库，所以必须被安装在 Python 环境中才可以使用。目前 angr 使用 Python 2，对 Python 3 的支持也许将来会实现，我们很犹豫现在就要做出如此承诺（不过我们欢迎您提交 PR！）
 
-We highly recommend using a [python virtual environment](https://virtualenvwrapper.readthedocs.org/en/latest/) to install and use angr. Several of angr's dependencies (z3, pyvex) require libraries of native code that are forked from their originals, and if you already have libz3 or libVEX installed, you definitely don't want to overwrite the official shared objects with ours. In general, don't expect support for problems arising from installing angr outside of a virtualenv.
+我们强烈推荐您使用 [Python 虚拟环境](https://virtualenvwrapper.readthedocs.org/en/latest/) 来安装、使用 angr。因为 angr 的一些依赖（Z3,pyvex）需要的库经过我们的修改了，如果您早已安装了 libz3 或 libVEX，您一定不想让我们的库覆盖官方的库。通常来说，在虚拟环境之外安装的 angr 出现问题，不要期望会得到解答。
 
-### Dependencies
+### 依赖
 
-All of the python dependencies should be handled by pip and/or the setup.py scripts. You will, however, need to build some C to get from here to the end, so you'll need a good build environment as well as the python development headers. At some point in the dependency install process, you'll install the python library cffi, but (on linux, at least) it won't run unless you install your operating system's libffi package.
+通常，所有 Python 的依赖都应该由 pip 或 setup.py 处理。然而，当你想从头到尾构建一个工具的时候，你最好可以构建一个和开发者相同的环境。在你进行依赖安装过程中时，也许你在安装 Python 库 cffi，但是（至少在 linux 上），除非你安装了操作系统的 libffi 包，否则你不可能安装成功。
 
-On Ubuntu, you will want: `sudo apt-get install python-dev libffi-dev build-essential virtualenvwrapper`. If you are trying out angr-management, you will need `sudo apt-get install libqt4-dev graphviz-dev`.
+Ubuntu 需要执行 `sudo apt-get install python-dev libffi-dev build-essential virtualenvwrapper`，如果你想试用 angr-management 的话，还需要执行 `sudo apt-get install libqt4-dev graphviz-dev`
 
-### Most Operating systems, all \*nix systems
+### 大多数操作系统，所有 \*nix 操作系统
 
-`mkvirtualenv angr && pip install angr` should usually be sufficient to install angr in most cases, since angr is published on the Python Package Index.
+`mkvirtualenv angr && pip install angr` 绝大多数情况下就可以成功安装 angr 了，因为 angr 是在 Python Package Index 上发布的库。
 
-Fish (shell) users can either use [virtualfish](https://github.com/adambrenecki/virtualfish) or the [virtualenv](https://pypi.python.org/pypi/virtualenv) package: `vf new angr && vf activate angr && pip install angr`
+Fish (shell) 用户可以使用 [virtualfish](https://github.com/adambrenecki/virtualfish) 或者 [virtualenv](https://pypi.python.org/pypi/virtualenv) 来执行 `vf new angr && vf activate angr && pip install angr`
 
-Failing that, you can install angr by installing the following repositories (and the dependencies listed in their requirements.txt files), in order, from https://github.com/angr:
+或者，您可以通过安装以下组件（以及它们在 requirements.txt 中列出的依赖项）来安装 [angr](https://github.com/angr:)
 
 - [claripy](https://github.com/angr/claripy)
 - [archinfo](https://github.com/angr/archinfo)
@@ -26,16 +26,16 @@ Failing that, you can install angr by installing the following repositories (and
 
 ### Mac OS X
 
-`pip install angr` should work, but there are some caveats.
+`pip install angr` 应该是可以的，但仍然有一些注意事项
 
-If you're unlucky and run into a broken build script with Clang, try using GCC.
+如果用 Clang 不幸遇到构建失败，请试试 GCC
 
 ```bash
 brew install gcc
 env CC=/usr/local/bin/gcc-6 pip install angr
 ```
 
-After installing angr, you will need to fix some shared library paths for the angr native libraries.
+安装 angr 后，您需要修正一些共享库的路径为 angr 自带的库路径
 
 ```bash
 BASEDIR=/usr/local/lib/python2.7/site-packages
@@ -48,14 +48,13 @@ install_name_tool -change libpyvex.dylib "$BASEDIR"/pyvex/lib/libpyvex.dylib "$B
 
 ### Windows
 
-angr can _probably_ be installed from pip on Windows, given that you're in a shell with the visual studio build tools loaded.
+angr  _也许可以_ 使用 pip 在 Windows 上安装成功，你可以通过 visual studio 来进行构建
 
-Capstone is difficult to install on windows. You might need to manually specify a wheel to install, but sometimes it installs under a name different from "capstone", so if that happens you want to just remove capstone from the requirements.txt files in angr and archinfo.
+Capstone 很难安装在 Windows 上，您也许需要手动安装 wheel 版，但有时名字会发生改变，和 capstone 略有出入，此时您只需要在 angr 和 archinfo 的 requirements.txt 中移除 capstone 即可
 
-# Development install
+# 开发者安装
 
-We created a repo with scripts to make life easier for angr developers.
-You can set up angr in development mode by running:
+我们创建了一个方便 angr 开发者的仓库，您可以通过以下方式在开发模式下运行 angr：
 
 ```bash
 git clone git@github.com:angr/angr-dev.git
@@ -64,15 +63,13 @@ mkvirtualenv angr
 ./setup.sh
 ```
 
-This clones all of the repositories and installs them in editable mode.
-`setup.sh` can even create a PyPy virtualenv for you, resulting in significantly faster performance and lower memory usage.
+这将克隆整个仓库并以可编辑模式进行安装，`setup.sh` 甚至可以为您创建一个 PyPy virtualenv 虚拟环境，从而显著提高性能表现并降低内存使用
 
-You can branch/edit/recompile the various modules in-place, and it will automatically reflect in your virtual environment.
+您可以分支、编辑、重编译任何一个模块， 并在虚拟环境中进行测试
 
-## Docker install
+## Docker 安装
 
-For convenience, we ship a Docker image that is 99% guaranteed to work.
-You can install via docker by doing:
+为方便起见，我们上传了一个 Docker 镜像，在绝大多数情况下（99%）它都可以正常工作。您可以通过 docker 来进行安装:
 
 ```bash
 # install docker
@@ -85,13 +82,13 @@ sudo docker pull angr/angr
 sudo docker run -it angr/angr
 ```
 
-Synchronization of files in and out of docker is left as an exercise to the user (hint: check out `docker -v`).
+Docker 的文件同步留给使用者进行练习（提示：check out `docker -v`）
 
-### Modifying the angr container
+### 修改 angr 容器
 
-You might find yourself needing to install additional packages via apt. The vanilla version of the container does not have the sudo package installed, which means the default user in the container cannot escalate privilege to install additional packages. 
+您可能会发现需要通过 apt 来安装其他软件包，容器的 vanilla 版没有安装 sudo 包，这意味着容器中的默认用户没有权限来升级、安装其他包
 
-To over come this hurdle, use the following docker command to grant yourself root access:
+要绕过这个限制，请使用以下 docker 命令来授予 root 权限：
 
 ```bash
 # assuming the docker container is running 
@@ -100,11 +97,11 @@ To over come this hurdle, use the following docker command to grant yourself roo
 docker exec -ti -u root angr bash
 ```
 
-# Troubleshooting
+# 故障排除
 
 ## libgomp.so.1: version GOMP_4.0 not found, or other z3 issues
 
-This specific error represents an incompatibility between the pre-compiled version of `angr-only-z3-custom` and the installed version of `libgomp`. A Z3 recompile is required. You can do this by executing:
+这是一个典型错误，表示预编译版本 `angr-only-z3-custom` 和 `libgomp` 的已安装版本不兼容。需要对 Z3 进行重编译，可以使用以下命令：
 
 ```bash
 pip install -I --no-use-wheel z3-solver
@@ -112,28 +109,27 @@ pip install -I --no-use-wheel z3-solver
 
 ## Can't import angr because of capstone
 
-Sometimes capstone isn't installed correctly for use by angr. There's a good chance just rebuilding capstone, making sure to use the pre-release version (capstone's distribution is very strange) will solve this issue:
+有时候 capstone 安装不正确，也是一个重新构建 capstone 的好机会，确保使用预发行版本（capstone 的版本发行很奇怪）就可以解决这个问题
 
 ```bash
 pip install -I --pre --no-use-wheel capstone
 ```
 
-If this doesn't work, there's a known [issue](https://github.com/aquynh/capstone/issues/445) in installing capstone_3.0.4 using pip in virtualenv/virtualenvwrapper environment. Several users have further reported to be affected by the same bug in native Python installation, too. (See the discussion in Github bug report).
+如果没能解决，可能是一个在 virtualenv/virtualenvwrapper 虚拟环境中使用 pip 安装 capstone_3.0.4 时已知的 [issue](https://github.com/aquynh/capstone/issues/445)，有一些用户报告在非虚拟环境中安装时也遇到了相同的错误（请参看 GitHub 错误报告中的讨论）
 
-In virtual environment, if capstone Python files are installed in `/home/<username>/.virtualenvs/<virtualenv>/lib/python2.7/site-packages/capstone/*.py(c)`, capstone library file will be found in `/home/<username>/.virtualenvs/<virtualenv>/lib/python2.7/site-packages/home/<username>/.virtualenvs/<virtualenv>/lib/python2.7/site-packages/capstone/libcapstone.so`
+在虚拟环境中，如果 capstone 被安装在 `/home/<username>/.virtualenvs/<virtualenv>/lib/python2.7/site-packages/capstone/*.py(c)` 中，capstone 的库文件将会在 `/home/<username>/.virtualenvs/<virtualenv>/lib/python2.7/site-packages/home/<username>/.virtualenvs/<virtualenv>/lib/python2.7/site-packages/capstone/libcapstone.so`
 
-In native environment, if capstone Python files are installed in `/usr/local/lib/python2.7/dist-packages/capstone/*.py(c)`, capstone library file will be found in `/usr/local/lib/python2.7/dist-packages/usr/lib/python2.7/dist-packages/capstone/libcapstone.so`
+在非虚拟环境中，如果 capstone 被安装在 `/usr/local/lib/python2.7/dist-packages/capstone/*.py(c)`中，capstone 的库文件将会在 `/usr/local/lib/python2.7/dist-packages/usr/lib/python2.7/dist-packages/capstone/libcapstone.so`
 
-Moving `libcapstone.so` to the same directory as that of Python files will fix the problem.
+移动 `libcapstone.so` 到和 python 文件相同的目录即可解决这个问题
 
 ## No such file or directory: 'pyvex_c'
 
-Are you running Ubuntu 12.04? If so, please stop using a 5 year old operating system! Upgrading is free!
+您正在使用的环境是 Ubuntu 12.04 吗？如果是，请停止使用这款发布超过五年的操作系统吧！升级是免费的！
 
-You can also try upgrading pip (`pip install -U pip`), which might solve the issue.
+您也可以尝试升级 pip（pip install -U pip），也许可能会解决该问题
 
 ## AttributeError: 'FFI' object has no attribute 'unpack'
 
-You have an outdated version of the `cffi` Python module.  angr now requires at least version 1.7 of cffi.
-Try `pip install --upgrade cffi`.  If the problem persists, make sure your operating system hasn't pre-installed an old version of cffi, which pip may refuse to uninstall.
-If you're using a Python virtual environment with the pypy interpreter, ensure you have a recent version of pypy, as it includes a version of cffi which pip will not upgrade.
+您的 `cffi` Python 模块过时了，angr 需要至少 1.7 版本的 cffi。试着执行 `pip install --upgrade cffi`。如果问题仍然存在，请确保系统中预安装旧版本的 cffi 都被清除了，否则 pip 可能会拒绝卸载
+如果您使用 pypy 作为 Python 的虚拟环境，请确保您使用的是最新版本的 pypy，因为其中包含了一个 pip 是不会为它升级的 cffi 的旧版本
diff --git a/README.md b/README.md
index f4ef018..c06e666 100644
--- a/README.md
+++ b/README.md
@@ -1,31 +1,31 @@
-# What is angr, and how do I use it?
+# angr 是什么？该如何使用？
 
-angr is a multi-architecture binary analysis toolkit, with the capability to perform dynamic symbolic execution \(like Mayhem, KLEE, etc.\) and various static analyses on binaries. If you'd like to learn how to use it, you're in the right place!
+angr 是一个多架构二进制分析工具集，整合了动态符号执行（像 Mayhem、KLEE 等）和各种二进制静态分析的技术。如果你想了解如何使用 angr，那就继续阅读吧！
 
-We've tried to make using angr as pain-free as possible - our goal is to create a user-friendly binary analysis suite, allowing a user to simply start up iPython and easily perform intensive binary analyses with a couple of commands. That being said, binary analysis is complex, which makes angr complex. This documentation is an attempt to help out with that, providing narrative explanation and exploration of angr and its design.
+我们的目标是建立一个用户友好的二进制分析工具集，使得用户可以简单地通过 iPython 中执行几个命令来完成复杂的二进制分析工作。话虽如此，但二进制分析工作毕竟是复杂的，angr 其实也是复杂的。这份文档旨在提供关于 angr 的表述，帮助您探索、理解 angr 的设计。
 
-Several challenges must be overcome to programmatically analyze a binary. They are, roughly:
+试图将二进制分析工作可编程化有以下几个难点：
 
-* Loading a binary into the analysis program.
-* Translating a binary into an intermediate representation \(IR\).
-* Performing the actual analysis. This could be:
-  * A partial or full-program static analysis \(i.e., dependency analysis, program slicing\).
-  * A symbolic exploration of the program's state space \(i.e., "Can we execute it until we find an overflow?"\).
-  * Some combination of the above \(i.e., "Let's execute only program slices that lead to a memory write, to find an overflow."\)
+* 分析程序可以正确加载二进制程序
+* 将二进制程序翻译成中间表示（IR）
+* 实际分析工作中，可能还有如下情形：
+  * 部分、全程序静态分析（如依赖分析、程序切片）
+  * 程序状态空间的符号执行探索（如“我们可以一直执行，直到发现溢出吗？”）
+  * 上述技术的一些组合（如“只执行那些存在内存写入的程序切片，直到发现溢出。”）
 
-angr has components that meet all of these challenges. This book will explain how each one works, and how they can all be used to accomplish your evil goals.
+angr 提供许多组件可以很好的满足这些需要，这份文档将解释各个组件是如何工作的，以及如何利用这些组件来完成你的目的
 
-## Get Started
+## 开始使用
 
-Installation instructions can be found [here](./INSTALL.md).
+安装说明可以在 [这里](./INSTALL.md) 找到
 
-To dive right into angr's capabilities, start with the [top level methods](./docs/toplevel.md) and read forward from there.
+要更深入的理解 angr 的功能，需要从 [顶层设计](./docs/toplevel.md) 入手
 
-A searchable HTML version of this documentation is hosted at [docs.angr.io](http://docs.angr.io/), and an HTML API reference can be found at [angr.io/api-doc](http://angr.io/api-doc/).
+这份文档的可搜索 HTML 版托管在 [docs.angr.io](http://docs.angr.io/) 上，API 参考的 HTML 页面托管在 [angr.io/api-doc](http://angr.io/api-doc/) 上。
 
-## Citing angr
+## 引用
 
-If you use angr in an academic work, please cite the papers for which it was developed:
+如果您要在学术研究中使用 angr，请引用如下的论文
 
 ```bibtex
 @article{shoshitaishvili2016state,
@@ -50,18 +50,15 @@ If you use angr in an academic work, please cite the papers for which it was dev
 }
 ```
 
-## Support
+## 寻求帮助
 
-To get help with angr, you can ask via:
+要获得帮助，您可以通过以下方式：
 
-* the mailing list: angr@lists.cs.ucsb.edu
-* the slack channel: [angr.slack.com](https://angr.slack.com), for which you can get an account [here](http://angr.io/invite.html).
-* the IRC channel: **\#angr** on [freenode](https://freenode.net/)
-* opening an issue on the appropriate github repository
+* 邮件列表： angr@lists.cs.ucsb.edu
+* slack 频道： [angr.slack.com](https://angr.slack.com)，您可以在 [这里](http://angr.io/invite.html) 注册一个账户
+* IRC 频道： **\#angr** 在 [freenode](https://freenode.net/)
+* 在 GitHub 上开一个新的 issue 页
 
-## Going further:
-
-You can read this [paper](https://www.cs.ucsb.edu/~vigna/publications/2016_SP_angrSoK.pdf), explaining some of the internals, algorithms,  
-and used techniques to get a better understanding on what's going on under the  
-hood.
+## 进一步了解
 
+您可以阅读这篇 [论文](https://www.cs.ucsb.edu/~vigna/publications/2016_SP_angrSoK.pdf) 来进一步了解 angr，这篇论文解释了内部设计、算法和使用的相关技术,这样可以帮助您进一步了解 angr
diff --git a/docs/analyses.md b/docs/analyses.md
index 0fa7ce0..c95e99f 100644
--- a/docs/analyses.md
+++ b/docs/analyses.md
@@ -1,26 +1,25 @@
-# Analyses
+# 分析
 
-angr's goal is to make it easy to carry out useful analyses on binary programs.
-This section will discuss how to run and create these analyses.
+angr 的目标是创建简单易用的二进制程序分析工具。本节将讨论如何运行并创建这些分析工具
 
-## Built-in Analyses
+## 内建分析工具
 
-angr comes with several built-in analyses:
+angr 带有一些内置分析工具
 
 | Name                                        | Description                                                                                                                               |
 | --------                                    | -------------                                                                                                                             |
-| CFGFast                                     | Constructs a fast *Control Flow Graph* of the program. `b.analyses.CFG()` is what you want.                                               |
-| [CFGAccurate](analyses/cfg_accurate.md)     | Constructs an accurate *Control Flow Graph* of the program. The simple way to do is via `b.analyses.CFGAccurate()`.                       |
-| VFG                                         | Performs VSA on every function of the program, creating a *Value Flow Graph* and detecting stack variables.                               |
-| DDG                                         | Calculates a data dependency graph, allowing one to determine what statements a given value depends on.                                   |
-| [DFG](analyses/dfg.md)                      | Constructs a *Data Flow Graph* for each basic block present in the CFG                                                                    |
-| [BackwardSlice](analyses/backward_slice.md) | Computes a backward slice of a program w.r.t. a certain target.                                                                           |
-| [Identifier](analyses/identifier.md)        | Identifies common library functions in CGC binaries. |
-| More!                                       | angr has quite a few analyses, most of which work! If you'd like to know how to use one, please submit an issue requesting documentation. |
+| CFGFast                                     | 为程序快速构建一个 *控制流图*，`b.analyses.CFG()` 是可用的                  |
+| [CFGAccurate](analyses/cfg_accurate.md)     | 为程序构建一个精确的 *控制流图*，`b.analyses.CFGAccurate()` 是可用的         |
+| VFG                                         | 对程序中的每个函数执行 VSA，创建一个 *Value Flow Graph* 并检测堆栈变量                |
+| DDG                                         | 计算一个数据依赖图（Data Dependency Graph）, 用来确定给定值所依赖的语句               |
+| [DFG](analyses/dfg.md)                      | 构建 CFG 中的每个基本块的*数据流图*                          |
+| [BackwardSlice](analyses/backward_slice.md) | 计算关于某个确定目标程序的向后切片                                       |
+| [Identifier](analyses/identifier.md)        | 识别 CGC 可执行程序的共享库函数 |
+| More!                                       | angr 有许多分析工具，其中大部分都可以正常使用，如果您想知道如何使用它，请提交 issue |
 
-### Resilience
+### 弹性
 
-Analyses can be written to be resilient, and catch and log basically any error.
-These errors, depending on how they're caught, are logged to the `errors` or `named_errors` attribute of the analysis.
-However, you might want to run an analysis in "fail fast" mode, so that errors are not handled.
-To do this, the argument `fail_fast=True` can be passed into the analysis constructor.
+分析工具可以写成被写成弹性的，可以捕获、记录任意错误。
+这些错误，取决于如何捕捉并记录到 `errors` 或 `named_errors` 分析的属性。
+但是，也许希望以“故障快速”模式运行一个分析工具，此时程序将不响应任何错误处理。
+为此，参数 `fail_fast=True` 可以将此方式传递给分析器构造函数
diff --git a/docs/analyses/dfg.md b/docs/analyses/dfg.md
index f1967e1..eb2313d 100644
--- a/docs/analyses/dfg.md
+++ b/docs/analyses/dfg.md
@@ -1,9 +1,9 @@
 # DFG
 
-A Data Flow Graph represents data dependencies between instructions. In angr, it represents data dependencies on VEX IR.
+数据流图表示指令之间的数据依赖。
+在 angr 中，数据流图代表了 VEX IR 之间的数据依赖
 
-A vertex in the graph represents either a statement or an expression. An edge between two vertices represents the
-data dependency: the value produced (or constant) from one vertex is needed as an input by another vertex.
+图中的顶点代表一个语句或一个表达式，两个顶点之间的边代表数据依赖：从一个顶点产生的值需要做另一个顶点的输入
 
 ```python
 >>> import angr
@@ -11,18 +11,17 @@ data dependency: the value produced (or constant) from one vertex is needed as a
 >>> d = b.analyses.DFG()
 ```
 
-The following options are also available:
+以下选项也可以使用：
 
-| Option  | Description |
+| 选项  | 描述 |
 |---------|-------------|
-| cfg     | If you already have a CFG available you can provide it instead of rebuilding it. |
-| annocfg | An annotated CFG that can be built from an BackwardSlice to construct only the DFGs from the basic block that are present in the backward slice. |
+| cfg     | 如果你已经有可用的 CFG，可以直接使用而非重建 |
+| annocfg | 由 BackwardSlice 构建的带注释的 CFG，只由在后向切片中出现的基本块构建的 DFG |
 
-Each basic block, or node, in the CFG, which is not a SimProcedure, has its DFG available in the dict `d.dfgs`
-where the key is the address of the basic block.
+CFG 中的每个基本块或节点（非 SimProcedure）在字典 `d.dfgs` 中都有 DFG，键为基本块的地址
 
-Every DFG constructed is a [NetworkX](https://networkx.github.io/) di-graph.
-This means that all of the normal NetworkX APIs are available, for example you can print all the input edges of a node in a DFG:
+每个 DFG 都是由 [NetworkX](https://networkx.github.io/) 构建的图。
+这意味着所有基本的 NetworkX API 都是可用的。例如，可以打印 DFG 节点的所有输入边：
 
 ```python
 >>> bbl_addr, dfg = d.dfgs.popitem()
diff --git a/docs/analyses/identifier.md b/docs/analyses/identifier.md
index 9736400..5013568 100644
--- a/docs/analyses/identifier.md
+++ b/docs/analyses/identifier.md
@@ -1,9 +1,8 @@
 # Identifier
 
-
-The identifier uses test cases to identify common library functions in CGC binaries.
-It prefilters by finding some basic information about stack variables/arguments.
-The information of about stack variables can be generally useful in other projects.
+该标识符使用测试用例来识别 CGC 二进制程序中的通用库函数。
+它通过查找关于堆栈变量/参数的一些基本信息来进行预过滤。
+这些关于堆栈变量的信息通常可以用于其他项目中
 
 ```python
 >>> import angr
diff --git a/docs/analysis_writing.md b/docs/analysis_writing.md
index 1835d7b..c068700 100644
--- a/docs/analysis_writing.md
+++ b/docs/analysis_writing.md
@@ -1,8 +1,8 @@
-# Writing Analyses
+# 写一个 Analyses
 
-An analysis can be created by subclassing the `angr.Analysis` class.
-In this section, we'll create a mock analysis to show off the various features.
-Let's start with something simple:
+可以通过继承类 `angr.Analysis` 来创建一个 analysis。
+在本节中，我们将会创建一个模拟 analysis 来展示各种功能。
+让我们从简单的开始吧~
 
 ```python
 >>> import angr
@@ -14,10 +14,10 @@ Let's start with something simple:
 >>> angr.register_analysis(MockAnalysis, 'MockAnalysis')
 ```
 
-This is a very simple analysis -- it takes an option, and stores it.
-Of course, it's not useful, but this is just a demonstration.
+这是一个非常简单的 analysis -- 需要一个选项然后把它存储起来。
+当然，这没什么用，只是一个简单的示例。
 
-Let's see how to run our new analysis
+让我们看看如何运行一个新的 analysis
 
 ```python
 >>> proj = angr.Project("/bin/true")
@@ -25,12 +25,12 @@ Let's see how to run our new analysis
 >>> assert mock.option == 'this is my option'
 ```
 
-If you've registered a new analysis _after_ loading the project, you will need to refresh the list of registered analyses on your project with `proj.analyses.reload_analyses()`.
+如果在加载了项目后注册了一个新的 analysis，需要使用 `proj.analyses.reload_analyses()` 刷新项目中的注册 analyses 列表
 
 ### Working with projects
 
-Via some python magic, your analysis will automatically have the project upon which you are running it under the `self.project` property.
-Use this to interact with your project and analyze it!
+通过一些 Python 魔法，你的 analysis 将会自动添加到项目中，可以在 `self.project` 属性下运行它。
+可以使用它来和项目进行交互并进行分析！
 
 ```python
 >>> class ProjectSummary(angr.Analysis):
@@ -45,12 +45,11 @@ Use this to interact with your project and analyze it!
 This project is a AMD64 binary with an entry point at 0x401410.
 ```
 
-### Naming Analyses
+### Analyses 命名
 
-The `register_analysis` call is what actually adds the analysis to angr.
-Its arguments are the actual analysis class and the name of the analysis.
-The name is how it appears under the `project.analyses` object.
-Usually, you should use the same name as the analysis class, but if you want to use a shorter name, you can.
+调用 `register_analysis` 实际上是添加 analysis 到 angr 中。
+它的参数是实际 analysis 的类，和 analysis 的名字。
+该名字是如何出现在对象 `project.analyses` 下的呢？通常来说，应该使用与 analysis 类同样的名字，但是如果想自定义也是可以的：
 
 ```python
 >>> class FunctionBlockAverage(angr.Analysis):
@@ -61,17 +60,16 @@ Usually, you should use the same name as the analysis class, but if you want to
 >>> angr.register_analysis(FunctionBlockAverage, 'FuncSize')
 ```
 
-After this, you can call this analysis using it's specified name. For example, `b.analyses.FuncSize()`.
+在此之后，就可以使用这个自定义的名字来调用这个 analysis 了，例如：`b.analyses.FuncSize()`
 
-### Analysis Resilience
+### Analysis 弹性
 
-Sometimes, your (or our) code might suck and analyses might throw exceptions.
-We understand, and we also understand that oftentimes a partial result is better than nothing.
-This is specifically true when, for example, running an analysis on all of the functions in a program.
-Even if some of the functions fails, we still want to know the results of the functions that do not.
+有时，你的（或者我们的）代码可能会抛出异常。
+我们明白，有部分结果总比什么都没有好。
+例如，对程序中的所有函数进行 analysis 时，情况就是如此。
+即使某些函数失败了，我们仍然想知道成功那部分函数的结果
 
-To facilitate this, the `Analysis` base class provides a resilience context manager under `self._resilience`.
-Here's an example:
+为了方便，基类 `Analysis` 提供了一个弹性上下文管理器 `self._resilience`。示例如下：
 
 ```python
 >>> class ComplexFunctionAnalysis(angr.Analysis):
@@ -86,23 +84,22 @@ Here's an example:
 ...                     self.results[addr] = "GOOD"
 ```
 
-The context manager catches any exceptions thrown and logs them (as a tuple of the exception type, message, and traceback) to `self.errors`.
-These are also saved and loaded when the analysis is saved and loaded (although the traceback is discarded, as it is not picklable).
+上下文管理器捕获抛出的任何异常，并将它们（异常类型、异常消息、traceback）记录到 `self.errors` 中。
+当 analysis 被保存、加载时，这些数据也将被保存、加载（traceback 因为不可序列化被丢弃）
 
-You can tune the effects of the resilience with two optional keyword parameters to `self._resilience()`.
+你可以使用 `self._resilience()` 的两个可选参数来调整弹性的粒度
 
-The first is `name`, which affects where the error is logged.
-By default, errors are placed in `self.errors`, but if `name` is provided, then instead the error is logged to `self.named_errors`, which is a dict mapping `name` to a list of all the errors that were caught under that name.
-This allows you to easily tell where thrown without examining its traceback.
+首先是 `name` 参数，它会影响错误记录的位置。默认情况下，错误被放在 `self.errors`。但如果指定了 `name` 参数，则会被记录到 `self.named_errors`，这是一个映射 `name` 到所有在这个名字下被捕获的错误列表的字典
+这可以轻松找到抛出异常的位置，而不无需检查 traceback
 
-The second argument is `exception`, which should be the type of the exception that `_resilience` should catch.
-This defaults to `Exception`, which handles (and logs) almost anything that could go wrong.
-You can also pass a tuple of exception types to this option, in which case all of them will be caught.
+第二个参数是 `exception`，指定了应该捕获的异常类型。
+默认为 `Exception`，即记录所有类型的错误。
+也可以使用元组来传递想捕获的异常类型给该参数，这种情况下，指定类型的异常都会被捕获
 
-Using `_resilience` has a few advantages:
+使用 `_resilience` 有以下几个优势：
 
-1. Your exceptions are gracefully logged and easily accessible afterwards. This is really nice for writing testcases.
-2. When creating your analysis, the user can pass `fail_fast=True`, which transparently disable the resilience, which is really nice for manual testing.
-3. It's prettier than having `try`/`except` everywhere.
+1. 异常会被优雅地记录下来，便于以后访问。这对编写测试用例非常友好
+2. 创建自定义的 analysis 时，用户可以设置 `fail_fast=True` 来透明禁用弹性设置，利于手动测试
+3. 比随处可见的 `try`/`except` 更漂亮
 
-Have fun with analyses! Once you master the rest of angr, you can use analyses to understand anything computable!
+一旦你掌握了 angr 的全部，就可以利用 angr 来完成任何分析、计算！
diff --git a/docs/be_creative.md b/docs/be_creative.md
index 93d5af0..5a442a2 100644
--- a/docs/be_creative.md
+++ b/docs/be_creative.md
@@ -1,19 +1,18 @@
-# A final word of advice
+# 最后的建议
 
-Congratulations!
-If you've read this far through the book (editor's note: this comment only really applies when we've actually finished writing all the TODOs so far) then you've been introduced to all the fundamental components of angr necessary to get started with binary analysis.
+恭喜！
+如果你已经阅读完了这本书（编者注：当我们完成了所有 TODO 写作时，才真正适用），我们已经介绍了使用 angr 所必需的二进制分析基本组件
 
+最终，angr 只是一个模拟器。
+这是一个高度可操作、独特的模拟器，其中有许多关于环境的考量。
 Ultimately, angr is just an emulator.
 It is a highly instrumentable and very unique emulator with lots of considerations for environment, true, but at its core, the work you do with angr is about extracting knowledge about how a bunch of bytecode behaves on a CPU.
-In designing angr, we've tried to provide you with the tools and abstractions on top of this emulator to make certain common tasks more useful, but there's no problem you can't solve just by working with a SimState and observing the affects of `.step()`.
+在设计 angr 时，我们试着提供一组工具以及模拟器顶层的抽象来应对常见的任务，同时没有什么问题是通过 SimState 和 `.step()` 不能解决的
 
-As you read further into this book, we'll describe more technical subjects and how to tune angr's behavior for complicated scenarios.
-This knowledge should inform your use of angr so you can take the quickest path to a solution to any given problem, but ultimately, you will want to solve problems by exercising creativity with the tools at your disposal.
-If you can take a problem and wrangle it into a form where it has defined and tractable inputs and outputs, you can absolutely use angr to achieve your goals, given that these goals involve analyzing binaries.
-None of the abstractions or instrumentations we provide are the end-all of how to use angr for a given task - angr is designed so it can be used in as integrated or as ad-hoc of a manner as you desire.
-If you see a path from problem to solution, take it.
+随着对本书的深入阅读，我们将介绍更多技术要点，以及如何针对复杂场景调整 angr。这些知识应该可以告诉你如何使用 angr，这样就可以利用最快的途径解决任何问题，但最终你会使用实践创造来解决遇到的任何问题。
+如果你想把一个问题转换成一个已定义好的、可处理的输入和输出的形式，而这些问题涉及分析二进制文件，完全可以利用 angr 来实现。我们做提供的抽象或插桩都不是固定不变的 - 如何在特定任务中使用 angr - angr 的设计使得其可以按照用户期望的方式进行整合或临时使用。
+如果发现了解决问题的方法，那就实现它！
 
-Of course, it's very difficult to become well-acquainted with such a huge piece of technology as angr.
-To this end you can absolutely lean on the community (through the [angr slack](http://angr.io/invite.html) is the best option) to discuss angr and solving problems with it.
+当然，要完全熟悉 angr 这样一个巨大的框架是非常困难的。因此，可以依靠社区([angr slack](http://angr.io/invite.html) 通常是最好的选择)和大家一起讨论、解决问题
 
-Good luck!
+祝你好运！
diff --git a/docs/claripy.md b/docs/claripy.md
index bb8a8b9..0692799 100644
--- a/docs/claripy.md
+++ b/docs/claripy.md
@@ -1,32 +1,27 @@
-# Solver Engine
+# 求解引擎
 
-angr's solver engine is called Claripy. Claripy exposes the following:
+`angr` 的求解器被称作 `Claripy` ， `Claripy` 提供了如下功能：
 
-- Claripy ASTs (the subclasses of claripy.ast.Base) provide a unified way to interact with concrete and symbolic expressions
-- Claripy frontends provide a unified interface to expression resolution (including constraint solving) over different backends
+- `Claripy ASTs` (`claripy.ast.Base` 的子类) 提供了一种与具体符号表达式交互的统一方式。
+- `Claripy` 前端提供了一个在不同后端解决符号(包括约束求解)表达式的统一接口。
 
-Internally, Claripy seamlessly mediates the co-operation of multiple disparate backends -- concrete bitvectors, VSA constructs, and SAT solvers. It is pretty badass.
+`Claripy` 在后端无缝协调多个不同的后端，具体的位向量， `VSA` 构造， `SAT` 求解器。
 
-Most users of angr will not need to interact directly with Claripy (except for, maybe, claripy AST objects, which represent symbolic expressions) -- angr handles most interactions with Claripy internally.
-However, for dealing with expressions, an understanding of Claripy might be useful.
+大多数 `angr` 用户都不需要直接与 `angr` 交互(除了代表符号表达式的 `claripy AST` 对象)，angr在内部处理大多数与Claripy的交互。然而，在处理表达式时，对 `angr` 的理解是有用的。
 
 ## Claripy ASTs
 
-Claripy ASTs abstract away the differences between the constructs that Claripy supports.
-They define a tree of operations (i.e., `(a + b) / c)` on any type of underlying data.
-Claripy handles the application of these operations on the underlying objects themselves by dispatching requests to the backends.
+`Claripy AST` 抽象出 `Claripy` 支持的构造之间的差异。它们在基础数据类型上定义了一个操作数 (例如, `(a + b) / c)` ，`Claripy` 通过将请求分派到后端来处理这些操作在底层对象本身上的应用。
 
-Currently, Claripy supports the following types of ASTs:
+目前, `Claripy` 支持以下类型的语法树：
 
-| Name | Description | Supported By (Claripy Backends) | Example Code |
+| 名字 | 描述        |  支持 (`Claripy` 后端)      | 示例代码      |
 |------|-------------|-----------------------------|---------------|
-| BV | This is a bitvector, whether symbolic (with a name) or concrete (with a value). It has a size (in bits). | BackendConcrete, BackendVSA, BackendZ3 | <ul><li>Create a 32-bit symbolic bitvector "x": `claripy.BVS('x', 32)`</li><li>Create a 32-bit bitvector with the value `0xc001b3475`: `claripy.BVV(0xc001b3a75, 32)`</li><li>Create a 32-bit "strided interval" (see VSA documentation) that can be any divisible-by-10 number between 1000 and 2000: `claripy.SI(name='x', bits=32, lower_bound=1000, upper_bound=2000, stride=10)`</li></ul>   |
-| FP | This is a floating-point number, whether symbolic (with a name) or concrete (with a value). | BackendConcrete, BackendZ3 | TODO  |
-| Bool | This is a boolean operation (True or False). | BackendConcrete, BackendVSA, BackendZ3 | `claripy.BoolV(True)`, or `claripy.true` or `claripy.false`, or by comparing two ASTs (i.e., `claripy.BVS('x', 32) < claripy.BVS('y', 32)` |
+| BV | 这是位向量，无论是符号还是具体值，都有一个大小（位）| BackendConcrete, BackendVSA, BackendZ3 | <ul><li>创建一个32位的符号位向量 `"x"` : `claripy.BVS('x', 32)`</li><li>创建一个值为 `0xc001b3475` 的 `32` 位向量: `claripy.BVV(0xc001b3a75, 32)`</li><li>创建一个 `32` 位 `"strided interval"` 可以被 `10` 整除的 `1000` 到 `2000` 之间的数（见 `VSA` 文档）: `claripy.SI(name='x', bits=32, lower_bound=1000, upper_bound=2000, stride=10)`</li></ul>   |
+| FP | 这是一个浮点数，无论是符号还是具体的值 | BackendConcrete, BackendZ3 | TODO  |
+| Bool | 这是布尔型操作数 (`True` 或者 `False`). | BackendConcrete, BackendVSA, BackendZ3 | `claripy.BoolV(True)`, 或者 `claripy.true` 或者 `claripy.false`, 或者两个 `ASTs` 的比较值(例如, `claripy.BVS('x', 32) < claripy.BVS('y', 32)` |
 
-All of the above creation code returns claripy.AST objects, on which operations can then be carried out.
-
-ASTs provide several useful operations.
+以上所有的创建代码都会返回 `claripy.AST` 对象，然后可以执行操作。 `ASTs` 提供了一些有用的操作。
 
 ```python
 >>> import claripy
@@ -48,8 +43,8 @@ ASTs provide several useful operations.
 >>> assert ((x+bv)/10).depth == 3
 ```
 
-Applying a condition (==, !=, etc) on ASTs will return an AST that represents the condition being carried out.
-For example:
+在 `AST` 上应用一个条件（==，！=等）将返回一个表示正在执行的条件的 `AST 。 例如：
+
 
 ```python
 >>> r = bv == x
@@ -59,58 +54,54 @@ For example:
 >>> assert isinstance(p, claripy.ast.Bool)
 >>> assert p.is_true()
 ```
+你可以以不同的方式组合这些条件
 
-You can combine these conditions in different ways.
 ```python
 >>> q = claripy.And(claripy.Or(bv == x, bv * 2 == x, bv * 3 == x), x == 0)
 >>> assert isinstance(p, claripy.ast.Bool)
 ```
 
-The usefulness of this will become apparent when we discuss Claripy solvers.
+当我们讨论 `Claripy` 的求解器的时候它的有用性就会显示出来，通常，`Claripy` 支持所有的正常的 `python` 操作(`+, -, |, ==,` 等)，并且通过 `Claripy` 提供额外的。以下是后者提供的可用操作列表。
 
-In general, Claripy supports all of the normal python operations (+, -, |, ==, etc), and provides additional ones via the Claripy instance object. Here's a list of available operations from the latter.
-
-| Name | Description | Example |
+| 名字 | 描述        | 例子    |
 |------|-------------|---------|
-| LShR | Logically shifts a bit expression (BVV, BV, SI) to the right. | `claripy.LShR(x, 10)` |
-| SignExt | Sign-extends a bit expression. | `claripy.SignExt(32, x)` or `x.sign_extend(32)` |
-| ZeroExt | Zero-extends a bit expression. | `claripy.ZeroExt(32, x)` or `x.zero_extend(32)` |
-| Extract | Extracts the given bits (zero-indexed from the *right*, inclusive) from a bit expression. | Extract the rightmost byte of x: `claripy.Extract(7, 0, x)` or `x[7:0]` |
-| Concat | Concatenates several bit expressions together into a new bit expression. | `claripy.Concat(x, y, z)` |
-| RotateLeft | Rotates a bit expression left. | `claripy.RotateLeft(x, 8)` |
-| RotateRight | Rotates a bit expression right. | `claripy.RotateRight(x, 8)` |
-| Reverse | Reverses a bit expression. | `claripy.Reverse(x)` or `x.reversed` |
-| And | Logical And (on boolean expressions) | `claripy.And(x == y, x > 0)` |
-| Or | Logical Or (on boolean expressions) | `claripy.Or(x == y, y < 10)` |
-| Not | Logical Not (on a boolean expression) | `claripy.Not(x == y)` is the same as `x != y` |
-| If | An If-then-else | Choose the maximum of two expressions: `claripy.If(x > y, x, y)` |
-| ULE | Unsigned less than or equal to. | Check if x is less than or equal to y: `claripy.ULE(x, y)` |
-| ULT | Unsigned less than. | Check if x is less than y: `claripy.ULT(x, y)` |
-| UGE | Unsigned greater than or equal to. | Check if x is greater than or equal to y: `claripy.UGE(x, y)` |
-| UGT | Unsigned greater than. | Check if x is greater than y: `claripy.UGT(x, y)` |
-| SLE | Signed less than or equal to. | Check if x is less than or equal to y: `claripy.SLE(x, y)` |
-| SLT | Signed less than. | Check if x is less than y: `claripy.SLT(x, y)` |
-| SGE | Signed greater than or equal to. | Check if x is greater than or equal to y: `claripy.SGE(x, y)` |
-| SGT | Signed greater than. | Check if x is greater than y: `claripy.SGT(x, y)` |
-
-
-**NOTE:** The default python `>`, `<`, `>=`, and `<=` are unsigned in Claripy. This is different than their behavior in Z3, because it seems more natural in binary analysis.
+| LShR | 逻辑上将一个位表达式(`BVV, BV, SI`)右移。 | `claripy.LShR(x, 10)` |
+| SignExt | 符号位扩展 | `claripy.SignExt(32, x)` 或者 `x.sign_extend(32)` |
+| ZeroExt | 零扩展 | `claripy.ZeroExt(32, x)` 或者 `x.zero_extend(32)` |
+| Extract | 从一个位表达式提取给定的位| 提取 `x` 最右边的位 : `claripy.Extract(7, 0, x)` 或者 `x[7:0]` |
+| Concat | 将几个位表达式连接到一个新的位表达式中 | `claripy.Concat(x, y, z)` |
+| RotateLeft | 循环左移表达式 | `claripy.RotateLeft(x, 8)` |
+| RotateRight | 循环右移表达式 | `claripy.RotateRight(x, 8)` |
+| Reverse | 翻转 | `claripy.Reverse(x)` 或者 `x.reversed` |
+| And | 逻辑与（布尔型） | `claripy.And(x == y, x > 0)` |
+| Or | 逻辑或（布尔型） | `claripy.Or(x == y, y < 10)` |
+| Not | 逻辑非（布尔型） | `claripy.Not(x == y)` is the same as `x != y` |
+| If | If-then-else | 选择两个表达式中的最大值: `claripy.If(x > y, x, y)` |
+| ULE | 无符号小于或等于 | 检查 `x` 是否小于等于 `y` : `claripy.ULE(x, y)` |
+| ULT | 无符号小于 | 检查 `x` 是否小于 `y`: `claripy.ULT(x, y)` |
+| UGE | 无符号大于或等于 | 检查 `x` 是否大于或等于 `y`: `claripy.UGE(x, y)` |
+| UGT | 无符号大于 | 检查 `x` 是否大于 `y`: `claripy.UGT(x, y)` |
+| SLE | 有符号小于等于 | 检查 `x` 是否小于等于 `y`: `claripy.SLE(x, y)` |
+| SLT | 有符号小于 | 检查 `x` 是否小于 `y`: `claripy.SLT(x, y)` |
+| SGE | 有符号大于等于 | 检查 `x` 是否大于等于 `y`: `claripy.SGE(x, y)` |
+| SGT | 有符号大于| 检查 `x` 是否大于 `y`: `claripy.SGT(x, y)` |
+
+
+**注意:** `python` 默认的 `>`, `<`, `>=`, 和 `<=` 在 `Claripy` 是无符号的. 这和在 `z3` 中是不同的，因为在二进制分析中这看起来更自然。
 
 ## Solvers
 
-The main point of interaction with Claripy are the Claripy Solvers.
-Solvers expose an API to interpret ASTs in different ways and return usable values.
-There are several different solvers.
+与 `Claripy` 交互的主要是 `Claripy` 求解器。求解器公开的 `API` 可以以不同方式解释 `ASTs` 并且返回可用的值。有几种不同的求解器。
 
-| Name | Description |
+| 名字 | 描述        |
 |------|-------------|
-| Solver | This is analogous to a `z3.Solver()`. It is a solver that tracks constraints on symbolic variables and uses a constraint solver (currently, Z3) to evaluate symbolic expressions. |
-| SolverVSA | This solver uses VSA to reason about values. It is an *approximating* solver, but produces values without performing actual constraint solves. |
-| SolverReplacement | This solver acts as a pass-through to a child solver, allowing the replacement of expressions on-the-fly. It is used as a helper by other solvers and can be used directly to implement exotic analyses. |
-| SolverHybrid | This solver combines the SolverReplacement and the Solver (VSA and Z3) to allow for *approximating* values. You can specify whether or not you want an exact result from your evaluations, and this solver does the rest. |
-| SolverComposite | This solver implements optimizations that solve smaller sets of constraints to speed up constraint solving. |
+| Solver | 类似于 `z3.Solver()`,跟踪符号变量的约束，并且使用约束求解器（现在是 `z3`）计算符号表达式。 |
+| SolverVSA | 这个求解器使用 `VSA` 来推理值，它是一个近似求解器，产生的值没有执行实际的约束求解。 |
+| SolverReplacement | 这个解析器充当子求解器的传递，允许动态地替换表达式。它被其他求解器用作辅助工具，可以直接用于实现奇异分析。 |
+| SolverHybrid | 这个求解器结合了 `SolverReplacement` 和求解器（`VSA` 和 `Z3`），允许近似值。你可以指定你的计算是否需要一个准确的结果，求解器会帮助你完成余下的任务|
+| SolverComposite | 这个求解器实现了在较小的约束条件下实现优化以加速求解|
 
-Some examples of solver usage:
+一些使用求解器的例子:
 
 ```python
 # create the solver and an expression
@@ -135,34 +126,30 @@ Some examples of solver usage:
 >>> assert s.eval(x, 10) == (1,) # interestingly enough, since z can't be y, x can only be 1!
 ```
 
-Custom solvers can be built by combining a Claripy Frontend (the class that handles the actual interaction with SMT solver or the underlying data domain) and some combination of frontend mixins (that handle things like caching, filtering out duplicate constraints, doing opportunistic simplification, and so on).
+自定义求解器可以通过组合一个明确的前端（处理与 `SMT` 求解器或底层数据域的实际交互的类）和前端的一些混合(处理类似缓存、过滤重复约束、进行机会化简化等)的组合而构建。
+
+## Claripy 后端
 
-## Claripy Backends
+后端是 `Claripy` 进行计算的主力。
+`Claripy` 向外公开了 `ASTs`，但是当实际的计算必须完成时，它将这些 `ASTs` 推到可以由后端自己处理的对象中。
+这为外面提供了一个统一的接口，并且支持不同类型的计算。
+例如，`BackendConcrete` 为具体的位向量和布尔型提供了计算支持，`BackendVSA` 引入了诸如 `StridedIntervals` 的 `VSA` 结构，并且详细描述了操作时发生的细节，`BackendZ3` 提供了对符号变量和约束解决的支持。
 
-Backends are Claripy's workhorses.
-Claripy exposes ASTs to the world, but when actual computation has to be done, it pushes those ASTs into objects that can be handled by the backends themselves.
-This provides a unified interface to the outside world while allowing Claripy to support different types of computation.
-For example, BackendConcrete provides computation support for concrete bitvectors and booleans, BackendVSA introduces VSA constructs such as StridedIntervals (and details what happens when operations are performed on them, and BackendZ3 provides support for symbolic variables and constraint solving.
+有一组函数需要后端去实现。对于所有这些函数，对于所有这些功能，“公共”版本预计能够处理 `claripy` 的 `AST` 对象，而“私有”版本只能处理特定于后端本身的对象。
+这是因 `Python` 语法区分的:公共函数将命名为func()，而私有函数将是_func()。
+所有函数都应该返回可由后端应用于其私有方法的对象。如果不能这样做(也就是，有些功能正在尝试后端无法处理)，后端应该增加一个 `BackendError`。
+在这种情况下，`Claripy` 将在它的列表中移动到下一个后端。
 
-There are a set of functions that a backend is expected to implement.
-For all of these functions, the "public" version is expected to be able to deal with claripy's AST objects, while the "private" version should only deal with objects specific to the backend itself.
-This is distinguished with Python idioms: a public function will be named func() while a private function will be _func().
-All functions should return objects that are usable by the backend in its private methods.
-If this can't be done (i.e., some functionality is being attempted that the backend can't handle), the backend should raise a BackendError.
-In this case, Claripy will move on to the next backend in its list.
+所有的后端都必须实现一个 `"convert()"` 函数。这个函数接收一个 `claripy AST` ，并应该返回后端可以用它的私有方法处理的一个对象。
+后端还应该实现一个 `_convert()` 方法，可以接收任何不是一个准确的 `AST` 对象（例如一个整数或来自不同后端的对象）。
+如果 `convert()` 或者 `_convert()` 接收到无法转换为在后端可以使用的格式的数据，后端应该调用 `BackendError` ，因此该对象不会被使用。
+所有的后端都必须实现基础“后端”抽象类的任何功能，这些类目前都是 `"NotImplementedError()"`。
 
-All backends must implement a `convert()` function.
-This function receives a claripy AST and should return an object that the backend can handle in its private methods.
-Backends should also implement a `_convert()` method, which will receive anything that is *not* a claripy AST object (i.e., an integer or an object from a different backend).
-If `convert()` or `_convert()` receives something that the backend can't translate to a format that is usable internally, the backend should raise BackendError, and thus won't be used for that object.
-All backends must also implement any functions of the base `Backend` abstract class that currently raise `NotImplementedError()`.
+`Claripy` 与后端的合约如下：后端应该能够处理它们在私有函数中返回的任何对象，它们从它们的私有或公共函数返回。
+`Claripy` 将永远不会将对象传递给任何后端私有函数，这些后端私有函数不是作为该后端的私有或公共函数的返回值。
+一个例外是`convert（）`和`_convert（）`，因为 `Claripy` 会尝试在 `_convert()` 中处理任何输入的数据，以查看后端是否可以处理该类型的对象。
 
-Claripy's contract with its backends is as follows: backends should be able to handle, in their private functions, any object that they return from their private *or* public functions.
-Claripy will never pass an object to any backend private function that did not originate as a return value from a private or public function of that backend.
-One exception to this is `convert()` and `_convert()`, as Claripy can try to stuff anything it feels like into _convert() to see if the backend can handle that type of object.
+### 模型对象
 
-### Model Objects
+为了在 `ASTs` 中执行实际的、有用的计算，`Claripy` 使用模型对象。模型对象是由 `AST` 表示的操作的结果。`Claripy` 期望这些对象从后端返回，并将这些对象传递到后端的其他函数。
 
-To perform actual, useful computation on ASTs, Claripy uses model objects.
-A model object is a result of the operation represented by the AST.
-Claripy expects these objects to be returned from the backends, and will pass such objects into that backend's other functions.
diff --git a/docs/concretization_strategies.md b/docs/concretization_strategies.md
index db37e0f..5497cf8 100644
--- a/docs/concretization_strategies.md
+++ b/docs/concretization_strategies.md
@@ -1,24 +1,23 @@
-# Symbolic memory addressing
+# 符号内存寻址
 
-angr supports *symbolic memory addressing*, meaning that offsets into memory may be symbolic.
-Our implementation of this is inspired by "Mayhem".
-Specifically, this means that angr concretizes symbolic addresses when they are used as the target of a write.
-This causes some surprises, as users tend to expect symbolic writes to be treated purely symbolically, or "as symbolically" as we treat symbolic reads, but that is not the default behavior.
-However, like most things in angr, this is configurable.
+angr 支持*符号内存寻址*，意味着内存中的偏移量也许是符号。
+我们受到了 “Mayhem” 的启发。
+具体来说，这意味着 angr 在使用它们当作写入目标时具体化了符号地址。
+这可能会引起一些争议，有些用户可能倾向于期望符号写入可以纯粹地使用符号进行处理，或者像符号读取那样“符号化”。但这不是默认的方法，与大多数情况相同，这是可配置的
 
-The address resolution behavior is governed by *concretization strategies*, which are subclasses of `angr.concretization_strategies.SimConcretizationStrategy`.
-Concretization strategies for reads are set in `state.memory.read_strategies` and for writes in `state.memory.write_strategies`.
-These strategies are called, in order, until one of them is able to resolve addresses for the symbolic index.
-By setting your own concretization strategies (or through the use of SimInspect `address_concretization` breakpoints, described above), you can change the way angr resolves symbolic addresses.
+地址解析是由*具体化策略*管理的，这些策略是 `angr.concretization_strategies.SimConcretizationStrategy` 的子类。
+读具体化策略在 `state.memory.read_strategies` 中，写具体化策略在 `state.memory.write_strategies` 中。
+按顺序调用这些策略，知道其中一个能解析符号索引的地址为止。
+通过设置自定义的具体化策略（或通过使用 SimInspect 的断点 `address_concretization`）可以更改 angr 解析符号地址的方式
 
-For example, angr's default concretization strategies for writes are:
+例如，angr 写的默认具体化策略是：
 
-1. A conditional concretization strategy that allows symbolic writes (with a maximum range of 128 possible solutions) for any indices that are annotated with `angr.plugins.symbolic_memory.MultiwriteAnnotation`.
-2. A concretization strategy that simply selects the maximum possible solution of the symbolic index.
+1. 有条件的具体化策略允许符号写入（最大为128个可能解决方案）任何被 `angr.plugins.symbolic_memory.MultiwriteAnnotation` 注释的索引
+2. 简单选择符号索引的最大化可能解决方案的具体化策略
 
-To enable symbolic writes for all indices, you can either add the `SYMBOLIC_WRITE_ADDRESSES` state option at state creation time or manually insert a `angr.concretization_strategies.SimConcretizationStrategyRange` object into `state.memory.write_strategies`.
-The strategy object takes a single argument, which is the maximum range of possible solutions that it allows before giving up and moving on to the next (presumably non-symbolic) strategy.
+要为所有索引启用符号写入，可以在 state 创建时添加选项 `SYMBOLIC_WRITE_ADDRESSES`，或手动插入对象 `angr.concretization_strategies.SimConcretizationStrategyRange` 到 `state.memory.write_strategies` 中。
+策略对象使用单一参数，这个策略是那些放弃并转向下一个（可能是非符号）策略之前所有可能解决方案的最大范围，
 
-## Writing concretization strategies
+## 写具体化策略
 
 TODO
\ No newline at end of file
diff --git a/docs/course.md b/docs/course.md
index 03cbdd3..64e42de 100644
--- a/docs/course.md
+++ b/docs/course.md
@@ -1,9 +1,9 @@
 # How to angr
 
-This is a stub for a step-by-step angr course.
-This course is meant to supplement the examples, gitbook, and API reference by gradually introducing new users to more and more advanced angr features.
+这是一个一步一步学 angr 课程的目录。
+本课程旨在通过示例、gitbook 与 API 文档不断向用户介绍更高级的 angr 功能。
 
-Where possible, we'll include slides explaining the underlying concepts and maybe even some video tutorials!
+可能的话，会包含解释底层概念的幻灯片，甚至是一些视频教程！
 
 # TODO: basic symbolic execution - step a path group
 
diff --git a/docs/courses/step0-basic_symbol_execution.md b/docs/courses/step0-basic_symbol_execution.md
deleted file mode 100644
index 47004d9..0000000
--- a/docs/courses/step0-basic_symbol_execution.md
+++ /dev/null
@@ -1,79 +0,0 @@
-# angr courses - Step 0 - Basic symbolic execution
-
-The first thing you are going to do with angr is executing symbolicaly your
-program. As a reminder, you can check what symbolic execution is [here](symbolic.md).
-
-The binary and source code for this course can be found [here](./src/).
-
-```python
->>> import angr
-
-# We load the binary in angr
->>> project = angr.Project('docs/courses/src/step0.bin')
-
-# Let's make things more readable
->>> addr_main = 0x4004a6
->>> first_jmp = 0x4004b9
->>> endpoint = 0x4004d6
->>> first_branch_left = 0x4004bb
->>> first_branch_right = 0x4004c2
->>> second_branch_left = 0x4004ca
->>> second_branch_right = 0x4004d1
-
-
-# We create a state so that angr starts at the beginning of the main function
->>> main_state = project.factory.blank_state(addr=addr_main)
->>> sm = project.factory.simgr(main_state)
->>> assert sm.active[0].addr == addr_main
-
-
-# Our simulation manager hasn't done anything yet, so it only has one active state
-# which address is main
-# Let's step
-# The simgr.step functions accepts different arguments to regulate
-# the stepping. Here, let's try to step until we reach the first comparison
->>> sm.step(until=lambda pg: pg.active[0].addr >= first_jmp)
-
-
-# We now have two active states. Each of them took a branch from the
-# comparison and will progress independently from the other one
->>> print(sm)
->>> for i, s in enumerate(sm.active):
-...     print 'Active state %d: %s' % (i, hex(s.addr))
->>> assert len(sm.active) == 2
->>> assert sm.active[0].addr == first_branch_left
->>> assert sm.active[1].addr == first_branch_right
-
-
-# If we make the first step, it will continue until reaching the endpoint
-# The other one, however, will reach another comparison and should
-# split again
->>> sm.step()
->>> print(sm)
->>> for i, s in enumerate(sm.active):
-...     print 'Active state %d: %s' % (i, hex(s.addr))
->>> assert len(sm.active) == 3
->>> assert sm.active[0].addr == endpoint
->>> assert sm.active[1].addr == second_branch_left
->>> assert sm.active[2].addr == second_branch_right
-
-
-# Good, we now have three states
-# - The two first states reached the endpoint, and became unconstrained, since
-# we started executing directly at main function. We would have seen these 2 states
-# if we had enabled save_unconstrained option of our SimulationManager.
-# - The other one will have the same history thus stop stepping at the endpoint
->>> sm.step()
->>> print(sm)
->>> for i, s in enumerate(sm.active):
-...     print 'Active state %d: %s' % (i, hex(s.addr))
->>> assert len(sm.active) == 1
->>> assert sm.active[0].addr == endpoint
-
-
-# The same effect can be done by using simgr.explore()
-# The explorer will step every state until no more states are active
->>> sm = project.factory.simgr(main_state)
->>> sm.explore()
->>> assert len(sm.active) == 0
-```
diff --git a/docs/courses/step0-basic_symbol_execution/step0-basic_symbol_execution.md b/docs/courses/step0-basic_symbol_execution/step0-basic_symbol_execution.md
new file mode 100644
index 0000000..6d36b09
--- /dev/null
+++ b/docs/courses/step0-basic_symbol_execution/step0-basic_symbol_execution.md
@@ -0,0 +1,74 @@
+# angr courses - Step 0 - Basic symbolic execution
+
+第一个尝试就是使用符号执行。提醒您，关于符号执行，您可以在 [文档](/docs/symbolic.md) 中了解更多
+
+The binary and source code for this course can be found [here](./).
+
+```python
+>>> import angr
+
+# 装载二进制程序到 angr
+>>> project = angr.Project('docs/courses/step0-basic_symbol_execution/step0.bin')
+
+# 将一些关键信息提出来易于阅读
+>>> addr_main = 0x4004a6
+>>> first_jmp = 0x4004b9
+>>> endpoint = 0x4004d6
+>>> first_branch_left = 0x4004bb
+>>> first_branch_right = 0x4004c2
+>>> second_branch_left = 0x4004ca
+>>> second_branch_right = 0x4004d1
+
+
+# 我们创建了一个i额 satate，以便 angr 可以在主函数开始
+>>> main_state = project.factory.blank_state(addr=addr_main)
+>>> pg = project.factory.path_group(main_state)
+>>> assert pg.active[0].addr == addr_main
+
+
+# 我们的路径组合没有任何操作，所以只有一个活动路径
+# 现在我们在主函数，继续往下执行
+# pathgroup.step 函数接受不同的参数
+# 此时，直到我们遇到第一个比较指令，否则会一直向下执行
+>>> pg.step(until=lambda p: p.active[0].addr >= first_jmp)
+
+
+# 我们现在有两个活动路径了
+# 它们分别是比较指令的两个分支，且彼此独立
+>>> print(pg)
+>>> for i, p in enumerate(pg.active):
+...     print("Active path {0}: {1}".format(i, hex(p.addr)))
+>>> assert len(pg.active) == 2
+>>> assert pg.active[0].addr == first_branch_left
+>>> assert pg.active[1].addr == first_branch_right
+
+
+# 如果我们执行第一条路径，程序会一直执行到结束
+# 如果我们执行另一条路径，会遇到另一个比较指令再次分裂路径
+>>> pg.step()
+>>> print(pg)
+>>> for i, p in enumerate(pg.active):
+...     print("Active path {0}: {1}".format(i, hex(p.addr)))
+>>> assert len(pg.active) == 3
+>>> assert pg.active[0].addr == endpoint
+>>> assert pg.active[1].addr == second_branch_left
+>>> assert pg.active[2].addr == second_branch_right
+
+
+# 我们现在有三条路径了！
+# 第一条路径会一直执行到结束，另一条路径也会执行到结束
+>>> pg.step()
+>>> print(pg)
+>>> for i, p in enumerate(pg.active):
+...     print("Active path {0}: {1}".format(i, hex(p.addr)))
+>>> assert len(pg.active) == 1
+>>> assert len(pg.deadended) == 2
+>>> assert pg.active[0].addr == endpoint
+
+
+# 同样的效果可以通过 pathgroup.explore() 来完成
+# explorer 会探索每条路径，直到没有更多的活跃路径为止
+>>> pg = project.factory.path_group(main_state)
+>>> pg.explore()
+>>> assert len(pg.active) == 0
+```
diff --git a/docs/courses/src/step0.bin b/docs/courses/step0-basic_symbol_execution/step0.bin
old mode 100755
new mode 100644
similarity index 100%
rename from docs/courses/src/step0.bin
rename to docs/courses/step0-basic_symbol_execution/step0.bin
diff --git a/docs/courses/src/step0.c b/docs/courses/step0-basic_symbol_execution/step0.c
similarity index 100%
rename from docs/courses/src/step0.c
rename to docs/courses/step0-basic_symbol_execution/step0.c
diff --git a/docs/courses/step1-stashes/stashes.md b/docs/courses/step1-stashes/stashes.md
new file mode 100644
index 0000000..4778360
--- /dev/null
+++ b/docs/courses/step1-stashes/stashes.md
@@ -0,0 +1,42 @@
+# angr courses - step 1 - stashes
+
+The binary and source code for this course can be found [here](./).
+
+##### 背景： Stashes
+路径组合是 angr 符号执行的接口。顾名思义，路径组合用来组织不同组的二进制文件中的不同路径，被叫做 *stashes*
+绝大多数 *stashes* 处在 *active*、*deadended*、*found* 和 *avoid* 状态之间
+想了解更多关于路径组合的信息，请看路径组合的 [文档](/docs/pathgroups.md)
+
+```python
+>>> import angr
+
+# 装载二进制程序到 project
+# 我们不想分析外部库，所以不加载这些外部库，angr 会替换它们
+>>> proj = angr.Project("docs/courses/step1-stashes/step1.bin", load_options={'auto_load_libs': False})
+
+# 创建控制流图来找到函数地址
+>>> proj.analyses.CFG()
+>>> addr_puts = proj.kb.functions.function(name="puts").addr
+>>> addr_main = proj.kb.functions.function(name="main").addr
+>>> addr_path_explosion = 0x400591
+
+# 创建路径组合
+>>> pg = proj.factory.path_group()
+
+# 直到找到 puts 函数否则不停止探索，同时避免路径爆炸
+>>> pg.explore(find=addr_puts, avoid=addr_path_explosion)
+
+>>> assert len(pg.active) == 1
+>>> assert len(pg.found) == 1
+>>> assert len(pg.avoid) == 1
+
+>>> print pg
+
+# 也可以探索剩余活动路径
+>>> pg.explore()
+
+>>> assert len(pg.active) == 0
+>>> assert len(pg.deadended) == 1
+
+>>> print pg
+```
\ No newline at end of file
diff --git a/docs/courses/step1-stashes/step1.bin b/docs/courses/step1-stashes/step1.bin
new file mode 100644
index 0000000..5feacdd
Binary files /dev/null and b/docs/courses/step1-stashes/step1.bin differ
diff --git a/docs/courses/step1-stashes/step1.c b/docs/courses/step1-stashes/step1.c
new file mode 100644
index 0000000..91ebbae
--- /dev/null
+++ b/docs/courses/step1-stashes/step1.c
@@ -0,0 +1,26 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+int main(int argc, char** argv) {
+    int something = strlen(argv[1]);
+
+    // stash avoided
+    if(something == 1) {
+        // some path explosion
+        int a = 1;
+        for(int i = 0; i < 10000; i++) {
+            a += a;
+        }
+        return a;
+    }
+
+    // stash found
+    if(something == 3) {
+        printf("The End\n");
+        return 0;
+    }
+
+    // stash active
+    return 0;
+}
\ No newline at end of file
diff --git a/docs/courses/step2-hooking/hooking.md b/docs/courses/step2-hooking/hooking.md
new file mode 100644
index 0000000..dc72833
--- /dev/null
+++ b/docs/courses/step2-hooking/hooking.md
@@ -0,0 +1,57 @@
+# angr courses - step 2 - hooking, path explosion
+
+The binary and source code for this course can be found [here](./).
+
+##### 背景：路径爆炸
+每个条件跳转都会带来可能路径数量的指数级增长。与符号执行相同，对所有活动路径的跟踪也导致了执行时间的指数级增长
+
+##### 创造路径爆炸
+为了模拟路径爆炸，我们使用考拉兹猜想（Collatz conjecture）函数
+该循环一直循环下去最后都会返回 1
+
+##### 代码示例： Hooking
+如果传递给考拉兹猜想函数的第一个命令行参数是 123456，我们对随后的打印输出的 secret 感兴趣。为了排除它，我们使用 angr 的 *hooking* 功能来简单地将其替换成自定义函数。想了解更多关于 hooking 的信息，请查阅相关 [文档](/docs/toplevel.md#hooking)
+
+```python
+>>> import angr
+
+# 装载二进制程序
+>>> proj = angr.Project('docs/courses/step2-hooking/step2.bin')
+
+# 一些重要的内存地址信息
+>>> addr_collatz_first_instruction = 0x400637
+>>> addr_collatz_last_instruction  = 0x40069f
+>>> addr_after_print_secret        = 0x40070c
+
+>>> collatz_length = addr_collatz_last_instruction - addr_collatz_first_instruction
+
+# 该函数将用来替换考拉兹猜想函数
+# 它接受当前 state 作为参数，并设置寄存器 RAX（the return value）的值为 1
+>>> def return1(state):
+...    state.regs.rax = 1
+
+# Hook 用上面的函数替换考拉兹猜想函数
+# 当执行到考拉兹猜想函数的地址时，Hook 函数将会被执行，二进制程序的 'length' 字节将会被跳过
+>>> proj.hook(addr_collatz_first_instruction, return1, length=collatz_length)
+
+# 创建一个新的路径组合来执行符号执行
+>>> pg = proj.factory.path_group()
+
+# 启动调试打印，可以看到每一次路径组合的 state
+>>> angr.path_group.l.setLevel("DEBUG")
+
+# 探索二进制程序，当 secret 被打印出来才会停止
+>>> pg.explore(find=addr_after_print_secret)
+
+# 至少有一个路径发现了目标
+>>> assert len(pg.found) > 0
+
+# 发现目标的第一个路径的 state
+>>> found_state = pg.found[0].state
+
+# 打印 I/O 中的所有字符串，以找到程序打印出的字符串
+>>> for file in found_state.posix.files:
+...    print found_state.posix.dumps(file)
+
+The secret is >1234<!
+```
\ No newline at end of file
diff --git a/docs/courses/step2-hooking/step2.bin b/docs/courses/step2-hooking/step2.bin
new file mode 100644
index 0000000..96a8039
Binary files /dev/null and b/docs/courses/step2-hooking/step2.bin differ
diff --git a/docs/courses/step2-hooking/step2.c b/docs/courses/step2-hooking/step2.c
new file mode 100644
index 0000000..dd042c3
--- /dev/null
+++ b/docs/courses/step2-hooking/step2.c
@@ -0,0 +1,38 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+// this function prints a secret
+void printSecret() {
+    printf("The secret is >1234<!\n");
+}
+
+// this function prints every entry of the collatz sequence, beginning with the number n
+// it returns 1 or loops forever
+long cheatedCollatzSequence(long n) {
+    while(n != 1) {
+        printf("%ld\n", n);
+        if(n % 2 == 0) {
+            n /= 2;
+        } else {
+            n = 3 * n + 1;
+        }
+    }
+    return n;
+}
+
+int main(int argc, char **argv) {
+    // print collatz sequence starting with number 837799 -> very long sequence -> path explosion
+    long c = cheatedCollatzSequence(837799L);
+
+    // read first command line argument as long
+    char* ptr;
+    long n = strtol(argv[1], &ptr, 10); // produces segfault if not specified
+
+    // print secret if collatz-return-value and command-line-value add to lets say 123456
+    if(c + n == 123456) {
+        printSecret();
+        return 0;
+    } else {
+        return 1;
+    }
+}
\ No newline at end of file
diff --git a/docs/courses/step3-command_line_params/command_line_params.md b/docs/courses/step3-command_line_params/command_line_params.md
new file mode 100644
index 0000000..93ddb33
--- /dev/null
+++ b/docs/courses/step3-command_line_params/command_line_params.md
@@ -0,0 +1,94 @@
+# angr courses - step 3 - symbolic command line parameters and constraints on them
+
+The binary and source code for this course can be found [here](./).
+
+##### 本次的二进制文件
+这次要分析的二进制文件在执行时需要一个命令行参数，如果参数满足某些要求，则会打印成功的字符串。你可以认为这是一个待破解的登录框
+
+##### 背景：Concept of symbolic values
+我们和 angr 都不知道正确的密码是什么，该值是完全符号化的，意味着一开始的时候它没有确定的值
+看下面的 C 程序示例
+当用 angr 分析相应的二进制文件时，state *a* 第一个参数是完全符号化的
+由于 if 语句，活动路径被分为两条：
+
+* 第一条路径（if 条件为 true，对应 state *b*）添加了 argv[1] 等于 test 的约束
+* 第二条路径（if 条件为 flase，对应 state *c*）与之相反 argv[1] 不等于 test
+
+```c
+int main(int argc, char** argv) {
+	// a
+	if(strcmp(argv[1], "test") == 0) {
+		// b
+	} else {
+		// c
+	}
+}
+```
+了解更多信息参看 [文档](/docs/claripy.md)
+
+##### 背景：angr 中的具体化符号值
+我们知道 *b* 处有重要的东西，我们想知道什么参数传递过去才能到 *b*。
+在 angr 中，我们可以简单地让约束求解器对当前 state 进行求解，得到满足约束的符号变量的可能值。
+在下面的例子中，使用了 32 个符号位组成的 bitvector
+
+```python
+>>> some_symbolic_variable = claripy.BVS("some_name", 8 * 4)
+>>> print state.se.any_str(some_symbolic_variable)
+```
+
+注意，符号变量取决于 state，不同 state 下的程序对符号变量有不同的约束（对比 *a* 与 *b* 两处）
+
+##### 代码示例：查找正确的参数
+
+```python
+>>> import angr
+>>> import claripy
+
+# 装载二进制程序
+>>> proj = angr.Project("docs/courses/step3-command_line_params/step3.bin")
+
+# 查找 puts 地址
+# 生成的 CFG 存储在知识库中，被用来查找函数
+>>> proj.analyses.CFG()
+>>> addr_puts = proj.kb.functions.function(name="puts").addr
+
+# 使用 claripy 创建一个符号化 bitvector
+# 因为 char 长 8 bit，我们需要将 char 字符的数量乘以 8
+>>> num_input_chars = 50
+>>> input_str = claripy.BVS("argv1", 8 * num_input_chars)
+
+# 创建具有手动指定命令行参数的初始状态
+>>> init_state = proj.factory.entry_state(args=["docs/courses/step3-command_line_params/step3.bin", input_str])
+
+# 将此参数限制为字母数字的符号 (a-z, A-Z, 0-9)
+# 为此，我们必须向符号化的 bitvector 每个比特位都添加约束
+# claripy.Or/claripy.And 是逻辑上的或和与
+>>> for i in xrange(num_input_chars):
+...     current_byte = input_str.get_byte(i)
+...     init_state.add_constraints(
+...         claripy.Or(
+...             claripy.And(current_byte >= 'a', current_byte <= 'z'),
+...             claripy.And(current_byte >= 'A', current_byte <= 'Z'),
+...             claripy.And(current_byte >= '0', current_byte <= '9')
+...         )
+...     )
+
+# 创建初始 state 时创建路径组合
+>>> pg = proj.factory.path_group(init_state)
+
+# 直到发现输出，否则不停止探索
+>>> pg.explore(find=addr_puts)
+
+# 至少一个路径发现了输出
+>>> assert len(pg.found) > 0
+
+# 发现目标地址的第一条路劲的 state
+>>> found_state = pg.found[0].state
+
+# 评估目标 state 下的符号化输入字符串，找出可能到达目的地址的输入
+>>> possible_inputs = found_state.se.any_n_str(input_str, 20)
+
+# 打印出来
+>>> for input in possible_inputs:
+...     print input
+```
\ No newline at end of file
diff --git a/docs/courses/step3-command_line_params/step3.bin b/docs/courses/step3-command_line_params/step3.bin
new file mode 100644
index 0000000..4d40039
Binary files /dev/null and b/docs/courses/step3-command_line_params/step3.bin differ
diff --git a/docs/courses/step3-command_line_params/step3.c b/docs/courses/step3-command_line_params/step3.c
new file mode 100644
index 0000000..3ad7dc2
--- /dev/null
+++ b/docs/courses/step3-command_line_params/step3.c
@@ -0,0 +1,10 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+int main(int argc, char** argv) {
+    char* pass = "zardus";
+    if(strncmp(argv[1] + 5, pass, strlen(pass)) == 0) {
+        printf("You win the internet!\n");
+    }
+}
\ No newline at end of file
diff --git a/docs/courses/step4-control_flow_graphs/cfg.md b/docs/courses/step4-control_flow_graphs/cfg.md
new file mode 100644
index 0000000..fcf2ee3
--- /dev/null
+++ b/docs/courses/step4-control_flow_graphs/cfg.md
@@ -0,0 +1,45 @@
+# angr courses - step 4 - control flow graphs
+
+The binary for this course can be found [here](./).
+
+## 背景：控制流图
+控制流图表示程序所有可能的路径。其节点是基本块，节点间用有向边连接表示在二进制程序中存在基本块 _a_ 到基本块 _b_ 的跳转。
+因为 CFG 可以很好地理解程序的功能，故而在二进制分析中扮演着关键角色
+在 angr 中也被用于其他分析中，并且实现了两次。一个主要侧重准确性（CFGAccurate），另一个主要侧重速度（CFGFast）
+
+我们使用 angr 的 CFGAccurate 来从给定的二进制程序中生成一个控制流图，该程序要求特定个用户输入
+由于 angr 本身不能显示 CFG（例如以 PNG 图片格式），我们使用了 [angrutils](https://github.com/axt/angr-utils) 的函数 plot_cfg
+CFGAccurate 的多个参数在 [文档](/docs/analyses/cfg_accurate.md) 和 [API](http://angr.io/api-doc/angr.html#angr.analyses.cfg_accurate.CFGAccurate) 中有着详细的阐述
+
+
+```python
+# 导入 angr 与 angrutils 的 plot_cfg
+>>> import angr
+>>> from angrutils import plot_cfg
+
+# 装载二进制程序到 project
+# 我们不想分析外部库，所以不加载这些外部库，angr 会替换它们
+>>> proj = angr.Project("docs/courses/step4-control_flow_graphs/step4.bin", load_options={'auto_load_libs': False})
+
+# 查找主函数地址
+# 设置为生成 CFG 的起始点
+>>> main_addr = proj.loader.main_bin.get_symbol("main").addr
+
+# 生成 CFG
+>>> cfg = proj.analyses.CFGAccurate(fail_fast=True, starts=[main_addr], context_sensitivity_level=4, keep_state=True, call_depth=10, normalize=True)
+
+# 渲染生成的 CFG 为 PNG 图片
+>>> plot_cfg(cfg, "step4_cfg_main", asminst=True, vexinst=False, func_addr={main_addr: True}, debug_info=False, remove_imports=True, remove_path_terminator=True)
+```
+
+生成的 CFG 如下，可以看出这个二进制程序：
+1. 打印输出（调用 puts）
+2. 获取用户输入（调用 fgets）
+3. 对输入进行 base64 解码（调用 b64d）
+4. 进行一些数学运算
+5. 将运算结果和一些硬编码的值进行检查比较
+6. 打印提示信息（调用 puts）
+
+![CFG not found][cfg]
+
+[cfg]: ./step4_cfg_main.png "CFGAccurate"
\ No newline at end of file
diff --git a/docs/courses/step4-control_flow_graphs/step4.bin b/docs/courses/step4-control_flow_graphs/step4.bin
new file mode 100644
index 0000000..2a95431
Binary files /dev/null and b/docs/courses/step4-control_flow_graphs/step4.bin differ
diff --git a/docs/courses/step4-control_flow_graphs/step4_cfg_main.png b/docs/courses/step4-control_flow_graphs/step4_cfg_main.png
new file mode 100644
index 0000000..a13eb28
Binary files /dev/null and b/docs/courses/step4-control_flow_graphs/step4_cfg_main.png differ
diff --git a/docs/courses/step5-symbol_execution_example/states.md b/docs/courses/step5-symbol_execution_example/states.md
new file mode 100644
index 0000000..406bfde
--- /dev/null
+++ b/docs/courses/step5-symbol_execution_example/states.md
@@ -0,0 +1,64 @@
+# angr courses - step 5 - finding correct input, SimState
+
+The binary for this course can be found [here](./).
+
+##### 背景： SimState
+angr 的模块 SimuVEX 提供了 SimState 来表示符号执行时的每个 state。
+每个 state 包括寄存器和内存的值，求解器和系统的状态，像打开的文件描述符和套接字。
+每个 state 也都知道它的下一个 state
+
+本节中，我们利用上节中使用的 [关于 CFG](/docs/courses/step4-control_flow_graphs/cfg.md) 的二进制文件。我们已经通过查看 CFG 了解了程序需要一些输入，并执行一些数学运算，再与硬编码的常量进行检查比对。之后会打印输出一些东西。
+
+我们想找到正确的输入，所以我们首先要找到一种办法来确定输入是否是正确的。要了解二进制程序中可能打印的字符串，需要查看 .rodata 段：
+`$ objdump --section .rodata --source step5.bin`
+
+现在我们可以定义函数来测试打印输出的字符串：
+
+```python
+>>> def correct(path):
+...    return "Congratz" in path.state.posix.dumps(1)
+
+>>> def incorrect(path):
+...    return "Nope" in path.state.posix.dumps(1)
+```
+
+从程序开始处分析整个二进制程序，包括 b64d 函数，需要的时间太长。我们希望可以从某处开始执行。为此，我们必须为开始执行点创建一个空白的 state。
+在 CFG 中可以看到，用户输入存在 r9 寄存器中，因此它必须设置到某个内存区域。angr 中的执行只是模拟的一个值，像 0x42，这不会引起段错误
+
+```python
+>>> SOME_MEMORY_ADDR = 0x42
+
+>>> init_state = proj.factory.blank_state(addr=0x400843)
+>>> init_state.regs.rcx = 0
+>>> init_state.regs.rsi = 0
+>>> init_state.regs.rdi = 0
+>>> init_state.regs.r10 = 0
+>>> init_state.regs.r9 = SOME_MEMORY_ADDR
+>>> init_state.regs.r8 = 0
+```
+
+现在我们可以基于该 state 来创建路径组合了，日志记录级别设置为 `DEBUG`，这样可以跟踪路径组合的变化。
+以前指定的函数可以用来告诉路径组合什么样的路径应该被丢弃
+
+```python
+>>> angr.path_group.l.setLevel("DEBUG")
+>>> pg = proj.factory.path_group(init_state)
+>>> pg.explore(find=correct, avoid=incorrect)
+>>> print pg
+<PathGroup with 4 avoid, 1 found>
+```
+
+一条路径到达了打印成功信息输出的 state 处，我们使用该 state 来得到符号变量代表的用户输入的可能值。通过将变量送给求解器，一个具体值就可以被求解出来。
+在我们调用 base64 解码后开始执行，我们发现用户输入必须是 base64 编码过的，所以我们对其进行 base64 编码：
+
+```python
+>>> found_state = pg.found[0].state
+>>> symbolic_input_string = found_state.memory.load(SOME_MEMORY_ADDR, 16)
+>>> concrete_input_string = found_state.se.any_str(symbolic_input_string)
+
+>>> import base64
+>>> print base64.b64encode(concrete_input_string)
+PFVweE7IBZBJgsulkxZVyw==
+```
+
+使用这串字符串输入给真实二进制程序，将会打印成功信息："Congratz, you win!" ！
\ No newline at end of file
diff --git a/docs/courses/step5-symbol_execution_example/step5.bin b/docs/courses/step5-symbol_execution_example/step5.bin
new file mode 100644
index 0000000..2a95431
Binary files /dev/null and b/docs/courses/step5-symbol_execution_example/step5.bin differ
diff --git a/docs/examples.md b/docs/examples.md
index 2a97048..89e6164 100644
--- a/docs/examples.md
+++ b/docs/examples.md
@@ -1,4 +1,4 @@
-# angr examples
+# angr 示例
 
 To help you get started with [angr](https://github.com/angr/angr), we've created several examples.
 We've tried to organize them into major categories, and briefly summarize that each example will expose you to.
@@ -8,14 +8,14 @@ There are also a great amount of slightly more redunant examples (these mostly s
 
 To jump to a specific category:
 
-- [Introduction](#introduction) - examples showing off the very basics of angr's functionality
-- [Reversing](#reversing) - examples showing angr being used in reverse engineering tasks
-- [Vulnerability Discovery](#vulnerability-discovery) - examples of angr being used to search for vulnerabilities
-- [Exploitation](#exploitation) - examples of angr being used as an exploitation assistance tool
+- [介绍](#introduction) - examples showing off the very basics of angr's functionality
+- [逆向工程](#reversing) - examples showing angr being used in reverse engineering tasks
+- [漏洞挖掘](#vulnerability-discovery) - examples of angr being used to search for vulnerabilities
+- [漏洞利用](#exploitation) - examples of angr being used as an exploitation assistance tool
 
-## Introduction
+## 介绍
 
-These are some introductory examples to give an idea of how to use angr's API.
+我们准备了一些关于如何使用 angr 的 API 的例子
 
 ### Fauxware
 
@@ -24,10 +24,10 @@ This is a basic script that explains how to use angr to symbolically execute a p
 Binary, source, and script are found [here.](https://github.com/angr/angr-doc/tree/master/examples/fauxware)
 
 
-## Reversing
+## 逆向
 
-These are examples that use angr to solve reverse engineering challenges.
-There are a lot of these.
+有许多用 angr 来解决逆向工程问题的例子，我们也准备了一些。
+我们选择了其中一些典型的例子，
 We've chosen the most unique ones, and relegated the rest to the [CTF Challenges](#) section below.
 
 
diff --git a/docs/faq.md b/docs/faq.md
index 5633f4c..318d863 100644
--- a/docs/faq.md
+++ b/docs/faq.md
@@ -1,82 +1,76 @@
-# Frequently Asked Questions
+# FAQ
 
-This is a collection of commonly-asked "how do I do X?" questions and other general questions about angr, for those too lazy to read this whole document.
+这是一个常见问题的辑录，对于那些懒得阅读整个文档的人是个福音
 
-If your question is of the form "how do I fix X issue", see also the Troubleshooting section of the [install instructions](../INSTALL.md).
+如果您遇到了“要修复X该怎么做？”的问题，请参阅[安装说明](../INSTALL.md)的故障排除部分
 
-## Why is it named angr?
-The core of angr's analysis is on VEX IR, and when something is vexing, it makes you angry.
+## 为什么叫 angr？
+angr 的分析核心是 VEX IR，出现一些问题的时候，你会非常生气！
 
-## How should "angr" be stylized?
-All lowercase, even at the beginning of sentences. It's an anti-proper noun.
+## angr 应该怎样拼写使用？
+全部小写，即使是在句子的开头。这是一个反专有名词（anti-proper noun）
 
-## How can I get diagnostic information about what angr is doing?
-angr uses the standard `logging` module for logging, with every package and submodule creating a new logger.
+## 如何得到 angr 运行的诊断信息？
+angr 使用标准库中的 `logging` 模块来进行日志记录，每个包与其子模块都会创建一个新的日志（logger）
 
-The simplest way to get debug output is the following:
+得到调试输出最简单的方法如下：
 ```python
 import logging
 logging.getLogger('angr').setLevel('DEBUG')
 ```
 
-You may want to use `INFO` or whatever else instead.
-By default, angr will enable logging at the `WARNING` level.
+你也许想要使用 `INFO` 级别或其他日志级别来代替。
+默认情况下，angr 的日志等级为 `WARNING`
 
-Each angr module has its own logger string, usually all the python modules above it in the hierarchy, plus itself, joined with dots.
-For example, `angr.analyses.cfg`.
-Because of the way the python logging module works, you can set the verbosity for all submodules in a module by setting a verbosity level for the parent module.
-For example, `logging.getLogger('angr.analyses').setLevel('INFO')` will make the CFG, as well as all other analyses, log at the INFO level.
+angr 的每个模块都有自己的日志字符串，通常来说按照层次结构排列下来的 Python 模块，逐渐加上点。例如：`angr.analyses.cfg`。
+依据 logging 模块的工作方式，可以通过为父模块设置日志级别来设置模块中所有子模块的日志级别。例如 `logging.getLogger('angr.analyses').setLevel('INFO')` 将会生成 CFG，与其他分析相同，日志会记录在 INFO 级别
 
-## Why is angr so slow?
-[It's complicated!](speed.md)
+## 为什么 angr 这么慢？
+这个问题十分复杂，请参阅[速度解释](speed.md)
 
-## How do I find bugs using angr?
-It's complicated!
-The easiest way to do this is to define a "bug condition", for example, "the instruction pointer has become a symbolic variable", and run symbolic exploration until you find a state matching that condition, then dump the input as a testcase.
-However, you will quickly run into the state explosion problem.
-How you address this is up to you.
-Your solution may be as simple as adding an `avoid` condition or as complicated as implementing CMU's MAYHEM system as an [Exploration Technique](otiegnqwvk.md).
+## 如何使用 angr 来发现 bug？
+这又是一个复杂的问题！最简单的方法是定义一个“bug 条件”，例如：指令指针变成一个符号变量。然后启动符号探索，直到发现能匹配条件的 state，angr 会将其 dump 为输入用例文件
+但是，往往会很快遇到状态爆炸的问题。
+如何解决这个问题就取决于你了。也许是通过添加一个 `avoid` 条件，或者利用 CMU 开发的 Mayhem 作为[探索技术](otiegnqwvk.md)
 
-## Why did you choose VEX instead of another IR (such as LLVM, REIL, BAP, etc)?
-We had two design goals in angr that influenced this choice:
+## 为什么选择 VEX 而不是其他 IR(例如 LLVM、REIL、BAP 等)？
+angr 最初的两个设计目标影响了我们的选择：
 
-1. angr needed to be able to analyze binaries from multiple architectures. This mandated the use of an IR to preserve our sanity, and required the IR to support many architectures.
-2. We wanted to implement a binary analysis engine, not a binary lifter. Many projects start and end with the implementation of a lifter, which is a time consuming process. We needed to take something that existed and already supported the lifting of multiple architectures.
+1. angr 需要能够分析多个体系结构的二进制文件。这就要求我们必须使用支持多架构的 IR
+2. 我们想要实现一个二进制分析引擎，而不是一个二进制 lifter。许多项目的启动和结束时都需要执行 lifter，这十分耗时。我们需要使用一个已经存在并且已经支持多种体系结构的解决方案
 
-Searching around the internet, the major choices were:
+经过搜索研究，有以下几个主要的选择：
 
-- LLVM is an obvious first candidate, but lifting binary code to LLVM cleanly is a pain. The two solutions are either lifting to LLVM through QEMU, which is hackish (and the only implementation of it seems very tightly integrated into S2E), or mcsema, which only supports x86.
-- TCG is QEMU's IR, but extracting it seems very daunting as well and documentation is very scarse.
-- REIL seems promising, but there is no standard reference implementation that supports all the architectures that we wanted. It seems like a nice academic work, but to use it, we would have to implement our own lifters, which we wanted to avoid.
-- BAP was another possibility. When we started work on angr, BAP only supported lifting x86 code, and up-do-date versions of BAP were only available to academic collaborators of the BAP authors. These were two deal-breakers. BAP has since become open, but it still only supports x86_64, x86, and ARM.
-- VEX was the only choice that offered an open library and support for many architectures. As a bonus, it is very well documented and designed specifically for program analysis, making it very easy to use in angr.
+- LLVM 是第一选择，但是想要清晰地提升（lift）二进制代码到 LLVM 是一个痛苦的过程。一共有两种解决方案，一种是通过 QEMU 来提升到 LLVM，而 QEMU 是 hsckish（其唯一实现就是紧密整合进了 S2E 中）的；另一种 mcsema 只支持 x86 结构
+- TCG 是 QEMU 的 IR，但是提取它也很困难，它的文档非常粗糙
+- REIL 看起来不错，但是没找到标准参考实现来执行来支持我们设计的全部架构。这是一个很好的学术工作，但要使用的话，就不得不实现自己的 lifter，而这这是我们竭力避免的
+- BAP 是另一个选择，当我们开始设计 angr 时，BAP 只支持 x86，而 BAP 的最新版本只提供给 BAP 作者的学术合作方。同时它只支持 x86_64、x86 与 ARM
+- VEX 是提供开放库并支持多架构的唯一选择。它转为程序分析设计，在 angr 中也是非常易用
 
-While angr uses VEX now, there's no fundamental reason that multiple IRs cannot be used. There are two parts of angr, outside of the `angr.engines.vex` package, that are VEX-specific:
+虽然 angr 现在使用的是 VEX，但并没有多 IR 不能被使用的根本原因。除了 `angr.engines.vex` 包，angr 有两部分是 VEX 独占的：
 
-- the jump lables (i.e., the `Ijk_Ret` for returns, `Ijk_Call` for calls, and so forth) are VEX enums.
-- VEX treats registers as a memory space, and so does angr. While we provide accesses to `state.regs.rax` and friends, on the backend, this does `state.registers.load(8, 8)`, where the first `8` is a VEX-defined offset for `rax` to the register file.
+- jump 表（例如，`Ijk_Ret` 表示返回、`Ijk_Call` 表示调用等等）使用的是 VEX 的枚举变量
+- VEX 将寄存器视作内存空间，angr 也是这么做的。虽然我们提供对 `state.regs.rax` 的访问，但在后端实际做的是 `state.registers.load(8, 8)`，第一个 `8` 是 VEX 定义的 `rax` 寄存器的偏移
 
-To support multiple IRs, we'll either want to abstract these things or translate their labels to VEX analogues.
+为了支持多个 IR，要么抽象这些结构，要么把他们的标签转换成 VEX 的类似体
 
-
-### My load options are ignored when creating a Project.
-CLE options are an optional argument. Make sure you call Project with the following syntax:
+### 创建项目时，自定义的加载选项会被忽略
+CLE 选择是可选参数，请确保使用以下语法调用项目：
 
 ```python
 b = angr.Project('/bin/true', load_options=load_options)
 ```
 
-rather than:
+不能是以下这样：
 ```python
 b = angr.Project('/bin/true', load_options)
 ```
 
-## Why are some ARM addresses off-by-one?
-In order to encode THUMB-ness of an ARM code address, we set the lowest bit to one.
-This convention comes from LibVEX, and is not entirely our choice!
-If you see an odd ARM address, that just means the code at `address - 1` is in THUMB mode.
+## 为什么 ARM 地址 off-by-one？
+为了编码 ARM 代码地址的 THUMB-ness，我们设置最低位为1。
+这个惯例是从 LibVEX 沿袭下来的，并不完全是我们自己的选择！
+如果看到了一个奇怪的 ARM 地址，就意味着代码处于 `address - 1` 的 THUMB 模式
 
-## How do I serialize angr objects?
-[Pickle](https://docs.python.org/2/library/pickle.html) will work.
-However, python will default to using an extremely old pickle protocol that does not support more complex python data structures, so you must specify a [more advanced data stream format](https://docs.python.org/2/library/pickle.html#data-stream-format).
-The easiest way to do this is `pickle.dumps(obj, -1)`.
+## 如何序列号 angr 对象？
+[Pickle](https://docs.python.org/2/library/pickle.html) 就可以。
+但是，Python将会默认使用一个不支持复杂 Python 数据机构的非常古老的 Pickle 协议，所以你必须指定一个[更高的数据流格式](https://docs.python.org/2/library/pickle.html#data-stream-format)。最简单的方法是 `pickle.dumps(obj, -1)`
diff --git a/docs/gotchas.md b/docs/gotchas.md
index 3a1179d..cd2b4d4 100644
--- a/docs/gotchas.md
+++ b/docs/gotchas.md
@@ -1,41 +1,34 @@
-# Gotchas when using angr
+# 使用 angr 时易陷入的困境
 
-This section contains a list of gotchas that users/victims of angr frequently run into.
+这一节包含了一些用户经常遇到的陷阱列表
 
-## SimProcedure inaccuracy
+## SimProcedure 不准确
 
-To make symbolic execution more tractable, angr replaces common library functions with summaries written in Python.
-We call these summaries SimProcedures.
-SimProcedures allow us to mitigate path explosion that would otherwise be introduced by, for example, `strlen` running on a symbolic string.
+为了使符号执行更加容易处理，angr 用 Python 编写的摘要来替换常见的库函数。我们把这些摘要称为SimProcedures。
+SimProcedures 可以帮助我们削弱路径爆炸，否则将会引入大量的路径爆炸，例如在符号字符串上运行 `strlen`
 
-Unfortunately, our SimProcedures are far from perfect.
-If angr is displaying unexpected behavior, it might be caused by a buggy/incomplete SimProcedure.
-There are several things that you can do:
+不幸的是，我们的 SimProcedures 没有那么完善。如果 angr 做了预期之外的事情，可能是由于错误/不完整的 SimProcedure 造成的。有以下几种补救办法：
 
-1. Disable the SimProcedure (you can exclude specific SimProcedures by passing options to the [angr.Project class](http://angr.io/api-doc/angr.html#module-angr.project)). This has the drawback of likely leading to a path explosion, unless you are very careful about constraining the input to the function in question. The path explosion can be partially mitigated with other angr capabilities (such as Veritesting).
-2. Replace the SimProcedure with something written directly to the situation in question. For example, our `scanf` implementation is not complete, but if you just need to support a single, known format string, you can write a hook to do exactly that.
-3. Fix the SimProcedure.
+1. 禁用 SimProcedures（也可以将选项传递给 [angr.Project](http://angr.io/api-doc/angr.html#module-angr.project) 类来排除指定的 SimProcedures）。这可能会导致路径爆炸，除非你可以非常小心地限制输入，路径爆炸可以通过 angr 的其他部分（如 Veritesting）来提供部分缓解的能力
+2. 将 SimProcedure 替换为直接写入相关情况的内容。例如，我们 `scanf` 的实现并不完善，但是如果只需要支持一个已知格式的字符串，就可以编写一个 Hook 来完成这个工作
+3. 完善 SimProcedure.
 
-## Unsupported syscalls
+## 不支持的系统调用
 
-System calls are also implemented as SimProcedures.
-Unfortunately, there are system calls that we have not yet implemented in angr.
-There are several workarounds for an unsupported system call:
+系统调用也是作为 SimProcedures 实现的。不幸的是，有一些系统调用我们还没有在 angr 中实现。对于不支持的系统调用，有几种解决方法：
 
-1. Implement the system call. *TODO: document this process*
-2. Hook the callsite of the system call (using `project.hook`) to make the required modifications to the state in an ad-hoc way.
-3. Use the `state.posix.queued_syscall_returns` list to queue syscall return values. If a return value is queued, the system call will not be executed, and the value will be used instead. Furthermore, a function can be queued instead as the "return value", which will result in that function being applied to the state when the system call is triggered.
+1. 执行系统调用 *TODO: document this process*
+2. Hook 系统调用（使用 `project.hook`）的调用处，为 state 提供临时的必要修改
+3. 使用 `state.posix.queued_syscall_returns` 来维护系统调用返回值的队列。如果返回值在队列中，就不会执行系统调用，直接使用该值。而且，一个函数可以作为“返回值”加入队列中。这会导致该系统调用触发时，该函数被应用到 state 中
 
-## Symbolic memory model
+## 符号内存模型
 
-The default memory model used by angr is inspired by [Mayhem](https://users.ece.cmu.edu/~dbrumley/pdf/Cha%20et%20al._2012_Unleashing%20Mayhem%20on%20Binary%20Code.pdf).
-This memory model supports limited symbolic reads and writes.
-If the memory index of a read is symbolic and the range of possible values of this index is too wide, the index is concretized to a single value.
-If the memory index of a write is symbolic at all, the index is concretized to a single value.
-This is configurable by changing the memory concretization strategies of `state.memory`.
+angr 默认的内存模型受到 [Mayhem](https://users.ece.cmu.edu/~dbrumley/pdf/Cha%20et%20al._2012_Unleashing%20Mayhem%20on%20Binary%20Code.pdf) 的启发。该内存模型支持有限的符号读与写。如果读的内存索引是符号的，并且该索引可能值的范围太宽，该索引就会被具体化为单值。
+如果写的内存索引是符号的，该索引会被具体化为单值。
+这些都可以通过改变内存的具体化策略（`state.memory`）来进行配置
 
-## Symbolic lengths
+## 符号长度
 
-SimProcedures, and especially system calls such as `read()` and `write()` might run into a situation where the *length* of a buffer is symbolic.
-In general, this is handled very poorly: in many cases, this length will end up being concretized outright or retroactively concretized in later steps of execution.
-Even in cases when it is not, the source or destination file might end up looking a bit "weird".
+SimProcedures，特别是系统调用，例如 `read()` 和 `write()` 可能都会遇到一个缓冲区长度是符号值的情况。
+通常来说，对于这个问题的处理总是不令人满意的。在很多情况下，这个值最终会被完全具体化，或在后面的步骤执行中逐渐具体化。
+如果没有具体化，源文件、目标文件看起来可能会有些“奇怪”
diff --git a/docs/ir.md b/docs/ir.md
index c743cea..16fdc10 100644
--- a/docs/ir.md
+++ b/docs/ir.md
@@ -1,55 +1,53 @@
-# Intermediate Representation
+# 中间表示
 
-In order to be able to analyze and execute machine code from different CPU architectures, such as MIPS, ARM, and PowerPC in addition to the classic x86, angr performs most of its analysis on an _intermediate representation_, a structured description of the fundamental actions performed by each CPU instruction.
-By understanding angr's IR, VEX \(which we borrowed from Valgrind\), you will be able to write very quick static analyses and have a better understanding of how angr works.
+为了在不同的 CPU 架构上分析和执行机器代码，例如 MIPS、ARM 和 PowerPC 与经典的 x86，angr 对其中大部分的中间表示进行了分析，对每一个 CPU 指令所执行基本操作的结构化描述
+通过理解 angr 的 IR - VEX \(我们借鉴了 Valgrind\)，你能够快速地进行静态分析并且可以更好的理解 angr 是如何工作的
 
-The VEX IR abstracts away several architecture differences when dealing with different architectures, allowing a single analysis to be run on all of them:
+在处理不同架构时，VEX IR 会提取不同架构之间的差异，从而可以对这些架构进行单个分析
 
-- **Register names.** The quantity and names of registers differ between architectures, but modern CPU designs hold to a common theme: each CPU contains several general purpose registers, a register to hold the stack pointer, a set of registers to store condition flags, and so forth. The IR provides a consistent, abstracted interface to registers on different platforms. Specifically, VEX models the registers as a separate memory space, with integer offsets (e.g., AMD64's `rax` is stored starting at address 16 in this memory space).
-- **Memory access.** Different architectures access memory in different ways. For example, ARM can access memory in both little-endian and big-endian modes. The IR abstracts away these differences.
-- **Memory segmentation.** Some architectures, such as x86, support memory segmentation through the use of special segment registers. The IR understands such memory access mechanisms.
-- **Instruction side-effects.** Most instructions have side-effects. For example, most operations in Thumb mode on ARM update the condition flags, and stack push/pop instructions update the stack pointer. Tracking these side-effects in an *ad hoc* manner in the analysis would be crazy, so the IR makes these effects explicit.
+- **寄存器名** 寄存器的数量和名字在不同的架构中存在差别，但现代 CPU 设计都遵循一个共识：每个 CPU 都包含几个通用寄存器，一个用来保存堆栈指针的寄存器，一系列用来存储条件旗标的寄存器，等等。IR 为不同平台的寄存器提供了一致的抽象接口。具体来说，VEX 将寄存器视为单独的、带有整数偏移的内存空间（例如，AMD64 的 `rax` 会从内存空间的 16 位置开始存储）
+- **内存访问** 不同的架构访问内存的方式不同。例如，ARM 可以以小端和大端模式访问内存。IR 会抽象这些差异
+- **内存分割** 一些架构，比如 x86 通过特殊的段寄存器来实现内存分段，IR 支持这种内存访问机制
+- **指令副产物** 大多数指令都有副产物，例如，ARM 上的 Thumb 模式中的大多数操作都会更新条件旗标、栈操作指令会更新栈指针。在分析中以 *ad hoc* 的方式对副产物进行跟踪是疯狂的，所以 IR 使这些操作的副产物变得更明显
 
-There are lots of choices for an IR. We use VEX, since the uplifting of binary code into VEX is quite well supported.
-VEX is an architecture-agnostic, side-effects-free representation of a number of target machine languages.
-It abstracts machine code into a representation designed to make program analysis easier.
-This representation has four main classes of objects:
+IR 有很多选择，我们选择使用 VEX，因为将二进制代码转换到 VEX 有着相当好的支持。VEX 是架构无关的、side-effects-free 的，许多目标机器语言的中间表示。它将机器代码抽象为易于程序分析的中间表示，其有四个主要的类：
 
-- **Expressions.** IR Expressions represent a calculated or constant value. This includes memory loads, register reads, and results of arithmetic operations.
-- **Operations.** IR Operations describe a *modification* of IR Expressions. This includes integer arithmetic, floating-point arithmetic, bit operations, and so forth. An IR Operation applied to IR Expressions yields an IR Expression as a result.
-- **Temporary variables.** VEX uses temporary variables as internal registers: IR Expressions are stored in temporary variables between use. The content of a temporary variable can be retrieved using an IR Expression. These temporaries are numbered, starting at `t0`. These temporaries are strongly typed (e.g., "64-bit integer" or "32-bit float").
-- **Statements.** IR Statements model changes in the state of the target machine, such as the effect of memory stores and register writes. IR Statements use IR Expressions for values they may need. For example, a memory store *IR Statement* uses an *IR Expression* for the target address of the write, and another *IR Expression* for the content.
-- **Blocks.** An IR Block is a collection of IR Statements, representing an extended basic block (termed "IR Super Block" or "IRSB") in the target architecture. A block can have several exits. For conditional exits from the middle of a basic block, a special *Exit* IR Statement is used. An IR Expression is used to represent the target of the unconditional exit at the end of the block.
+- **表达式** IR 表达式表示计算过的值或不变量，包括内存加载、寄存器读取和算术运算的结果
+- **运算** IR 运算描述了 IR 表达式的 *修改*。包括整数运算、浮点运算、位运算等，IR 表达式的 IR 操作会产生 IR 表达式
+- **临时变量** VEX 使用临时变量作为内部寄存器：IR 表达式存储在临时变量中。可以用 IR 表达式检索临时变量的内容。临时变量是数字型的，从 `t0` 开始，而且是强类型的（例如，64 位整数、32 位浮点数）
+- **语句** IR 语句模型随着目标机的语句改变，例如内存存储与寄存器写入的副产物。IR Statements 使用 IR 表达式可能用到得值。例如内存使用一个 *IR 表达式* 存储 *IR Statement* 要写入的地址，使用另一个 *IR 表达式* 来存储内容
+- **块** IR 块是 IR 语句的集合，表示目标架构上的扩展基本块（称为 IR 超级块或 IRSB）一个块可以有多个出口。块中的条件退出用特殊的 *Exit* IR 语句表示。IR 表达式用来表示基本块末尾无条件退出的目标
 
-VEX IR is actually quite well documented in the `libvex_ir.h` file (https://github.com/angr/vex/blob/master/pub/libvex_ir.h) in the VEX repository. For the lazy, we'll detail some parts of VEX that you'll likely interact with fairly frequently. To begin with, here are some IR Expressions:
+VEX IR 提供了相当好的文档在 `libvex_ir.h` 中(https://github.com/angr/vex/blob/master/pub/libvex_ir.h)。由于懒惰，我们只为您介绍高频使用的部分。首先，这里有一些 IR 表达式：
 
 | IR Expression | Evaluated Value | VEX Output Example |
 | ------------- | --------------- | ------- |
-| Constant | A constant value. | 0x4:I32 |
-| Read Temp | The value stored in a VEX temporary variable. | RdTmp(t10) |
-| Get Register | The value stored in a register. | GET:I32(16) |
-| Load Memory | The value stored at a memory address, with the address specified by another IR Expression. | LDle:I32 / LDbe:I64 |
-| Operation | A result of a specified IR Operation, applied to specified IR Expression arguments. | Add32 |
-| If-Then-Else | If a given IR Expression evaluates to 0, return one IR Expression. Otherwise, return another. | ITE |
-| Helper Function | VEX uses C helper functions for certain operations, such as computing the conditional flags registers of certain architectures. These functions return IR Expressions. | function\_name() |
+| Constant | 恒定不变的值 | 0x4:I32 |
+| Read Temp | 存储在 VEX 临时变量中的值 | RdTmp(t10) |
+| Get Register | 存储在寄存器中的值 | GET:I32(16) |
+| Load Memory | 存储在内存地址中的值，由另一个 IR 表达式指定地址 | LDle:I32 / LDbe:I64 |
+| Operation | 指定 IR 操作的结果，应用于指定的 IR 表达式参数 | Add32 |
+| If-Then-Else | 如果给定的 IR 表达式求值为 0，返回一个 IR 表达式，否则返回另一个 | ITE |
+| Helper Function | VEX 使用 C 辅助函数来进行某些运算，例如计算某些架构下的条件旗标。这些函数会返回 IR 表达式 | function\_name() |
 
-These expressions are then, in turn, used in IR Statements. Here are some common ones:
+这些表达式也可以被用在 IR 语句中，这有一些常见的：
 
 | IR Statement | Meaning | VEX Output Example |
 | ------------ | ------- | ------------------ |
-| Write Temp | Set a VEX temporary variable to the value of the given IR Expression. | WrTmp(t1) = (IR Expression) |
-| Put Register | Update a register with the value of the given IR Expression. | PUT(16) = (IR Expression) |
-| Store Memory | Update a location in memory, given as an IR Expression, with a value, also given as an IR Expression. | STle(0x1000) = (IR Expression) |
-| Exit | A conditional exit from a basic block, with the jump target specified by an IR Expression. The condition is specified by an IR Expression. | if (condition) goto (Boring) 0x4000A00:I32 |
+| Write Temp | 将 VEX 临时变量设置为给定的 IR 表达式的值 | WrTmp(t1) = (IR Expression) |
+| Put Register | 使用给定的 IR 表达式更新寄存器 | PUT(16) = (IR Expression) |
+| Store Memory | 根据 IR 表达式更新内存，位置与值都通过 IR 表达式给出 | STle(0x1000) = (IR Expression) |
+| Exit | 基本块中的条件退出，条件与跳转目标位置都由 IR 表达式指定 | if (condition) goto (Boring) 0x4000A00:I32 |
 
-An example of an IR translation, on ARM, is produced below. In the example, the subtraction operation is translated into a single IR block comprising 5 IR Statements, each of which contains at least one IR Expression (although, in real life, an IR block would typically consist of more than one instruction). Register names are translated into numerical indices given to the *GET* Expression and *PUT* Statement.
-The astute reader will observe that the actual subtraction is modeled by the first 4 IR Statements of the block, and the incrementing of the program counter to point to the next instruction (which, in this case, is located at `0x59FC8`) is modeled by the last statement.
+以下是一个在 ARM 上进行 IR 转换的例子。示例中，减法指令被转换成了一个包含五个 IR 语句的 IR 块，每个语句都包含一个 IR 表达式（虽然实际中 IR 块通常包含超过一个指令）。寄存器也转换成了 *GET* 表达式/*PUT* 语句中的数值型指标。
 
-The following ARM instruction:
+精明的读者应该已经发现了，实际上减法指令是由块中的前四个 IR 语句构成的，程序计数器递增指向下一条指令（本例中是 `0x59FC8`）是由最后一条语句完成的
+
+ARM 指令如下：
 
     subs R2, R2, #8
     
-Becomes this VEX IR:
+转换成 VEX IR：
 
     t0 = GET:I32(16)
     t1 = 0x8:I32
@@ -57,37 +55,37 @@ Becomes this VEX IR:
     PUT(16) = t3
     PUT(68) = 0x59FC8:I32
 
-Now that you understand VEX, you can actually play with some VEX in angr: We use a library called [PyVEX](https://github.com/angr/pyvex) that exposes VEX into Python. In addition, PyVEX implements its own pretty-printing so that it can show register names instead of register offsets in PUT and GET instructions.
+现在，您了解了 VEX，您可以在 angr 里使用 VEX 了，我们使用名为 [PyVEX](https://github.com/angr/pyvex) 的库来将 VEX 在 Python 中可用。另外，PyVEX 已经实现了优雅的输出，可以在 PUT/GET 指令中显示寄存器的名字而非寄存器偏移量
 
-PyVEX is accessable through angr through the `Project.factory.block` interface. There are many different representations you could use to access syntactic properties of a block of code, but they all have in common the trait of analyzing a particular sequence of bytes. Through the `factory.block` constructor, you get a `Block` object that can be easily turned into several different representations. Try `.vex` for a PyVEX IRSB, or `.capstone` for a Capstone block.
+可以通过 `Project.factory.block` 接口访问 PyVEX。您有很多不同的表示方法来访问代码块的语义属性，但它们都具有特定字节序列分析的共同特征。通过 `factory.block` 构造函数，您可以得到一个 `Block` 对象，它可以很容易地转换为多种不同的表示形式。尝试使用 `.vex` 来查看 PyVEX IRSB，或者使用 `.capstone` 得到 Capstone 块
 
-Let's play with PyVEX:
+来试试 PyVEX 吧！
 
 ```python
 >>> import angr
 
-# load the program binary
+# 装载二进制程序
 >>> proj = angr.Project("/bin/true")
 
-# translate the starting basic block
+# 转换起始基本块
 >>> irsb = proj.factory.block(proj.entry).vex
-# and then pretty-print it
+# 将其打印出来
 >>> irsb.pp()
 
-# translate and pretty-print a basic block starting at an address
+# 转换并打印一个地址开始的基本块
 >>> irsb = proj.factory.block(0x401340).vex
 >>> irsb.pp()
 
-# this is the IR Expression of the jump target of the unconditional exit at the end of the basic block
+# 基本块结尾的无条件退出的跳转目标的 IR 表达式
 >>> print irsb.next
 
-# this is the type of the unconditional exit (e.g., a call, ret, syscall, etc)
+# 无条件退出的类型（例如，调用，返回，系统调用等）
 >>> print irsb.jumpkind
 
-# you can also pretty-print it
+# 将其打印出来
 >>> irsb.next.pp()
 
-# iterate through each statement and print all the statements
+# 遍历所有语句并全部打印出来
 >>> for stmt in irsb.statements:
 ...     stmt.pp()
 
@@ -102,7 +100,7 @@ Let's play with PyVEX:
 ...         print stmt.data.result_type
 ...         print ""
 
-# pretty-print the condition and jump target of every conditional exit from the basic block
+# 打印基本块的每个条件退出的条件和目的地址
 >>> for stmt in irsb.statements:
 ...     if isinstance(stmt, pyvex.IRStmt.Exit):
 ...         print "Condition:",
@@ -119,19 +117,16 @@ Let's play with PyVEX:
 >>> print irsb.tyenv.types[0]
 ```
 
-## Condition flags computation (for x86 and ARM)
+## 条件旗标计算（x86 与 ARM）
 
-One of the most common instruction side-effects on x86 and ARM CPUs is updating condition flags, such as the zero flag, the carry flag, or the overflow flag.
-Computer architects usually put the concatenation of these flags (yes, concatenation of the flags, since each condition flag is 1 bit wide) into a special register (i.e. `EFLAGS`/`RFLAGS` on x86, `APSR`/`CPSR` on ARM).
-This special register stores important information about the program state, and is critical for correct emulation of the CPU.
+x86 和 ARM 的 CPU 上最常见的指令副产物之一就是更新条件旗标，例如零标志位，进位标志位或溢出标志位。
+计算机中常常将这些标志位连接起来，存在一个特殊的寄存器中（在 x86 中是 `EFLAGS`/`RFLAGS`，在 ARM 中是 `APSR`/`CPSR`）
+该寄存器中存储着有关程序状态的重要信息，对 CPU 仿真的正确性至关重要
 
-VEX uses 4 registers as its "Flag thunk descriptors" to record details of the latest flag-setting operation.
-VEX has a lazy strategy to compute the flags: when an operation that would update the flags happens, instead of computing the flags, VEX stores a code representing this operation to the `cc_op` pseudo-register, and the arguments to the operation in `cc_dep1` and `cc_dep2`.
-Then, whenever VEX needs to get the actual flag values, it can figure out what the one bit corresponding to the flag in question actually is, based on its flag thunk descriptors.
-This is an optimization in the flags computation, as VEX can now just directly perform the relevant operation in the IR without bothering to compute and update the flags' value.
+VEX 使用四个寄存器作为 "Flag thunk descriptors" 来记录最新的旗标信息。VEX 只在操作触发旗标更新时计算旗标，VEX 存储操作的代码表示到 `cc_op` 伪寄存器，参数存在 `cc_dep1` 和 `cc_dep2` 中。
+当 VEX 需要获取实际的旗标值时，可以根据 "Flag thunk descriptors" 来计算出与该旗标相对应的位上是什么。这是旗标计算中的优化，因为 VEX 现在可以直接在 IR 中执行相关操作，不用干扰计算、更新旗标
 
-Amongst different operations that can be placed in `cc_op`, there is a special value 0 which corresponds to `OP_COPY` operation.
-This operation is supposed to copy the value in `cc_dep1` to the flags.
-It simply means that `cc_dep1` contains the flags' value.
-angr uses this fact to let us efficiently retrieve the flags' value: whenever we ask for the actual flags, angr computes their value, then dumps them back into `cc_dep1` and sets `cc_op = OP_COPY` in order to cache the computation.
-We can also use this operation to allow the user to write to the flags: we just set `cc_op = OP_COPY` to say that a new value being set to the flags, then set `cc_dep1` to that new value.
+`cc_op` 存放着不同的操作指令，也存放着对应于 `OP_COPY` 操作的特殊值 0。 
+这个操作被假定拷贝 `cc_dep1` 的值到旗标中。这意味着 `cc_dep1` 包含旗标的值。
+angr 利用这一点来有效地检索旗标的值：当需要实际旗标的值时，angr 计算其值之后存到 `cc_dep1` 中，并设置 `cc_op = OP_COPY` 来缓存计算结果。
+我们也允许用户来对旗标进行写入，设置 `cc_op = OP_COPY` 表明一个新值要被写入旗标了，然后设置 `cc_dep1` 为新值
diff --git a/docs/loading.md b/docs/loading.md
index 2921e7a..d1ff4a0 100644
--- a/docs/loading.md
+++ b/docs/loading.md
@@ -1,12 +1,12 @@
-# Loading a Binary - CLE and angr Projects
+# 装载二进制程序 - CLE 和 angr Projects
 
-Previously, you saw just the barest taste of angr's loading facilities - you loaded `/bin/true`, and then loaded it again without its shared libraries. You also saw `proj.loader` and a few things it could do. Now, we'll dive into the nuances of these interfaces and the things they can tell you.
+先前，您对 angr 的装载能力只是浅尝辄止 - 您装载了 `/bin/true`，,并且不使用共享库又装载了一次。`proj.loader` 与其能做的事儿也略有展现。现在，我们将介绍这些接口的细微差别，以及这些接口可以提供哪些信息
 
-We briefly mentioned angr's binary loading component, CLE. CLE stands for "CLE Loads Everything", and is responsible for taking a binary \(and any libraries that it depends on\) and presenting it to the rest of angr in a way that is easy to work with.
+我们简要的介绍了 angr 的二进制装载组件 CLE。CLE 代表着 "CLE Loads Everything"，主要负责装载一个二进制文件 \(与其依赖的任意库\) 并以易于使用的方式传递给其他 angr 组件
 
-## The Loader
+## 装载器
 
-Let's re-load `/bin/true` and take a deeper look at how to interact with the loader.
+我们重新装载 `/bin/true` 并且深入了解如何和装载器进行交互
 
 ```python
 >>> import angr, monkeyhex
@@ -15,19 +15,17 @@ Let's re-load `/bin/true` and take a deeper look at how to interact with the loa
 <Loaded true, maps [0x400000:0x5008000]>
 ```
 
-### Loaded Objects
+### 装载对象
 
-The CLE loader \(`cle.Loader`\) represents an entire conglomerate of loaded _binary objects_, loaded and mapped into a single memory space.
-Each binary object is loaded by a loader backend that can handle its filetype \(a subclass of `cle.Backend`\).
-For example, `cle.ELF` is used to load ELF binaries.
+CLE 装载器 \(`cle.Loader`\) 表示加载的 _binary objects_ 的整个集合，装载并映射到单个内存空间。
+每个二进制对象都由装载器后端装载，该后端可以根据其类型进行处理 \(`cle.Backend` 的一个子类\)。例如 `cle.ELF` 被用于装载 ELF 二进制程序
 
-There will also be objects in memory that don't correspond to any loaded binary.
-For example, an object used to provide thread-local storage support, and an externs object used to provide unresolved symbols.
+内存中也存在着不与任何装载的二进制程序对应的对象，例如，用于提供线程本地存储的对象、用于提供未解析符号的外部对象
 
-You can get the full list of objects that CLE has loaded with `loader.all_objects`, as well as several more targeted classifications:
+使用 `loader.all_objects` 可以获得 CLE 装载对象的完整列表，以及几个更有针对性的分类：
 
 ```python
-# All loaded objects
+# 所有装载对象
 >>> proj.loader.all_objects
 [<ELF Object fauxware, maps [0x400000:0x60105f]>,
  <ELF Object libc.so.6, maps [0x1000000:0x13c42bf]>,
@@ -40,44 +38,44 @@ You can get the full list of objects that CLE has loaded with `loader.all_object
 >>> proj.loader.main_object
 <ELF Object true, maps [0x400000:0x60105f]>
 
-# This is a dictionary mapping from shared object name to object
+# 从共享对象名字到对象的字典映射
 >>> proj.loader.shared_objects
 { 'libc.so.6': <ELF Object libc.so.6, maps [0x1000000:0x13c42bf]>
   'ld-linux-x86-64.so.2': <ELF Object ld-linux-x86-64.so.2, maps [0x2000000:0x22241c7]>}
 
-# Here's all the objects that were loaded from ELF files
-# If this were a windows program we'd use all_pe_objects!
+# 这是从 ELF 文件装载的所有对象
+# 如果这是一个 Windows 程序，我们将使用 all_pe_objects！
 >>> proj.loader.all_elf_objects
 [<ELF Object true, maps [0x400000:0x60105f]>,
  <ELF Object libc.so.6, maps [0x1000000:0x13c42bf]>,
  <ELF Object ld-linux-x86-64.so.2, maps [0x2000000:0x22241c7]>]
  
-# Here's the "externs object", which we use to provide addresses for unresolved imports and angr internals
+# 这是“外部对象”，我们用它来提供未解析的 import 的地址与 angr 内部对象
 >>> proj.loader.extern_object
 <ExternObject Object cle##externs, maps [0x5000000:0x5008000]>
 
-# This object is used to provide addresses for emulated syscalls
+# 该对象用来为仿真的系统调用提供地址
 >>> proj.loader.kernel_object
 <KernelObject Object cle##kernel, maps [0x4000000:0x4008000]>
 
-# Finally, you can to get a reference to an object given an address in it
+# 最后，我们可以得到给定地址对象的引用
 >>> proj.loader.find_object_containing(0x400000)
 <ELF Object true, maps [0x400000:0x60105f]>
 ```
 
-You can interact directly with these objects to extract metadata from them:
+您可以直接和这些对象进行交互，从中提取元数据：
 
 ```python
 >>> obj = proj.loader.main_object
 
-# The entry point of the object
+# 对象的入口点
 >>> obj.entry
 0x400580
 
 >>> obj.min_addr, obj.max_addr
 (0x400000, 0x60105f)
 
-# Retrieve this ELF's segments and sections
+# 检索 ELF 的 segment 和 section 
 >>> obj.segments
 <Regions: [<ELFSegment offset=0x0, flags=0x5, filesize=0xa74, vaddr=0x400000, memsize=0xa74>,
            <ELFSegment offset=0xe28, flags=0x6, filesize=0x228, vaddr=0x600e28, memsize=0x238>]>
@@ -87,7 +85,7 @@ You can interact directly with these objects to extract metadata from them:
            <.note.ABI-tag | offset 0x254, vaddr 0x400254, size 0x20>,
             ...etc
             
-# You can get an individual segment or section by an address it contains:
+# 可以通过一个给定的地址得到一个单独的 segment 或 section
 >>> obj.find_segment_containing(obj.entry)
 <ELFSegment offset=0x0, flags=0x5, filesize=0xa74, vaddr=0x400000, memsize=0xa74>
 >>> obj.find_section_containing(obj.entry)
@@ -107,12 +105,11 @@ You can interact directly with these objects to extract metadata from them:
 0x400000
 ```
 
-### Symbols and Relocations
+### 符号与重定向
 
-You can also work with symbols while using CLE.
-A symbol is a fundamental concept in the world of executable formats, effectively mapping a name to an address.
+您也可以在使用 CLE 时使用符号，符号是可执行格式世界中的基本概念，可以有效地将 name 映射到地址
 
-The easiest way to get a symbol from CLE is to use `loader.find_symbol`, which takes either a name or an address and returns a Symbol object.
+从 CLE 获取符号最简单的方法就是 `loader.find_symbol`，给它一个 name 或地址可以返回一个 Symbol 对象
 
 ```python
 >>> malloc = proj.loader.find_symbol('malloc')
@@ -120,12 +117,12 @@ The easiest way to get a symbol from CLE is to use `loader.find_symbol`, which t
 <Symbol "malloc" in libc.so.6 at 0x1054400>
 ```
 
-The most useful attributes on a symbol are its name, its owner, and its address, but the "address" of a symbol can be ambiguous.
-The Symbol object has three ways of reporting its address:
+符号中最有用的属性就是其 name、owner 和地址，但符号的地址可能是不确定的。
+有三种方式得到 Symbol 对象的地址：
 
-- `.rebased_addr` is its address in the global address space. This is what is shown in the print output.
-- `.linked_addr` is its address relative to the prelinked base of the binary. This is the address reported in, for example, `readelf(1)`.
-- `.relative_addr` is its address relative to the object base. This is known in the literature (particularly the Windows literature) as an RVA (relative virtual address).
+- `.rebased_addr` 是其在全局地址空间的地址，也是输出的默认值
+- `.linked_addr` 是其相对于二进制文件预链接基址的地址，例如 `readelf(1)`
+- `.relative_addr` 是其相对于对象库基址的地址，特别是在 Windows 系统中叫做 RVA（相对虚拟地址）
 
 ```python
 >>> malloc.name
@@ -142,10 +139,9 @@ The Symbol object has three ways of reporting its address:
 0x54400
 ```
 
-In addition to providing debug information, symbols also support the notion of dynamic linking.
-libc provides the malloc symbol as an export, and the main binary depends on it.
-If we ask CLE to give us a malloc symbol from the main object directly, it'll tell us that this is an _import symbol_.
-Import symbols do not have meaningful addresses associated with them, but they do provide a reference to the symbol that was used to resolve them, as `.resolvedby`.
+除了提供调试信息外，symbol 还支持动态链接。libc 将 malloc symbol 作为 export，主要的二进制程序都依赖它
+如果我们要求 CLE 直接从主对象给我们一个 malloc symbol，它会告诉我们这是一个 _import symbol_。
+导入符号没有明确意义上的地址，但是确实提供了用于解析它们的符号的引用 `.resolvedby`
 
 ```python
 >>> malloc.is_export
@@ -166,16 +162,16 @@ True
 <Symbol "malloc" in libc.so.6 at 0x1054400>
 ```
 
-The specific ways that the links between imports and exports should be registered in memory are handled by another notion called _relocations_. 
-A relocation says, "when you match _\[import\]_ up with an export symbol, please write the export's address to _\[location\]_, formatted as _\[format\]_."
-We can see the full list of relocations for an object (as `Relocation` instances) as `obj.relocs`, or just a mapping from symbol name to Relocation as `obj.imports`.
-There is no corresponding list of export symbols.
+import 和 export 之间的连接关系应该在内存中注册，这种具体的方式由拎一个成为 _重定向_ 的概念来处理
+重定向的意思是说：当您用一个 export symbol 匹配到一个 import 时，请将 export 的地址写入 _\[location\]_，格式为 _\[format\]_
+我们可以使用 `obj.relocs` 看到一个对象（`Relocation` 实例）的重定向清单，或者只映射 symbol name 到 Relocation 上作为 `obj.imports`
+这里没有 export symbol 的相应清单
 
-A relocation's corresponding import symbol can be accessed as `.symbol`.
-The address the relocation will write to is accessable through any of the address identifiers you can use for Symbol, and you can get a reference to the object requesting the relocation with `.owner_obj` as well.
+重定向对应的 import symbol 可以作为 `.symbol` 被访问
+重定向将要写入的地址是可以通过任意可以用于 Symbol 的地址识别符进行访问，还可以用 `.owner_obj` 得到重定向的对象的引用
 
 ```python
-# Relocations don't have a good pretty-printing, so those addresses are python-internal, unrelated to our program
+# 重定向不会有良好的格式，所以这些地址是 Python 内部的，和我们的程序无关
 >>> proj.loader.shared_objects['libc.so.6'].imports
 {u'__libc_enable_secure': <cle.backends.relocations.generic.GenericJumpslotReloc at 0x4221fb0>,
  u'__tls_get_addr': <cle.backends.relocations.generic.GenericJumpslotReloc at 0x425d150>,
@@ -186,74 +182,78 @@ The address the relocation will write to is accessable through any of the addres
  u'_rtld_global_ro': <cle.backends.relocations.generic.GenericJumpslotReloc at 0x4254210>}
 ```
 
-If an import cannot be resolved to any export, for example, because a shared library could not be found, CLE will automatically update the externs object (`loader.extern_obj`) to claim it provides the symbol as an export.
+如果一个 import 不能解析为任何一个 export。例如，无法找到共享库，CLE 将会自动更新外部对象 (`loader.extern_obj`) 来声明它将识别该 symbol 为一个 export
 
-## Loading Options
+## 装载选项
 
-If you are loading something with `angr.Project` and you want to pass an option to the `cle.Loader` instance that Project implicitly creates, you can just pass the keyword argument directly to the Project constructor, and it will be passed on to CLE.
-You should look at the [CLE API docs.](http://angr.io/api-doc/cle.html) if you want to know everything that could possibly be passed in as an option, but we will go over some important and frequently used options here.
+如果您正在使用 `angr.Project` 装载某些程序，并且想要为 Project 隐式创建的 `cle.Loader` 实例传递一些选项，您可以直接将关键字参数传递给 Project 的构造函数，通过它传递给 CLE。
+如果您想知道所有可能的选项参数，您应该查看 CLE 的 [API 文档](http://angr.io/api-doc/cle.html)
+我们现在只会介绍一些重要且常用的选项
 
-#### Basic Options
+#### 基本选项
 
-We've discussed `auto_load_libs` already - it enables or disables CLE's attempt to automatically resolve shared library dependencies, and is on by default.
-Additionally, there is the opposite, `except_missing_libs`, which, if set to true, will cause an exception to be thrown whenever a binary has a shared library dependency that cannot be resolved.
+我们已经讨论过 `auto_load_libs` - 它可以启用/禁用 CLE 自动尝试解析共享库依赖，默认是开启的。
+此外，如果 `except_missing_libs` 被设置为 true，在二进制文件具有无法解析的共享库依赖时抛出异常
 
-You can pass a list of strings to `force_load_libs` and anything listed will be treated as an unresolved shared library dependency right out of the gate, or you can pass a list of strings to `skip_libs` to prevent any library of that name from being resolved as a dependency.
-Additionally, you can pass a list of strings \(or a single string\) to `custom_ld_path`, which will be used as an additional search path for shared libraries, before any of the defaults: the same directory as the loaded program, the current working directory, and your system libraries.
+您可以传递一个字符串列表给 `force_load_libs`，列表中的任何东西都会被认为是未解析的共享库依赖，或者可以传递字符串列表给 `skip_libs` 来阻止这些名称的库被解析为依赖关系。
+此外，您可以传递字符串列表给 `custom_ld_path`，将会将其作为共享库搜索的附加路径放在所有默认路径之前，被装载程序目录、当前工作目录与系统库目录
 
-#### Per-Binary Options
+#### 特定二进制选项
 
-If you want to specify some options that only apply to a specific binary object, CLE will let you do that too. The parameters `main_ops` and `lib_opts` do this by taking dictionaries of options. `main_opts` is a mapping from option names to option values, while `lib_opts` is a mapping from library name to dictionaries mapping option names to option values.
+CLE 也可以指定一些仅适用于特定二进制对象的选项，参数 `main_ops` 和 `lib_opts` 通过选项字典来实现这一功能。
+`main_opts` 提供从选项名到选项值的映射，`lib_opts` 提供库名到前一个字典的映射，该字典提供从选项名到选项值的映射
 
-The options that you can use vary from backend to backend, but some common ones are:
+每个后端对应的选项不同，但是有一些是通用的：
 
-* `backend` - which backend to use, as either a class or a name
-* `custom_base_addr` - a base address to use
-* `custom_entry_point` - an entry point to use
-* `custom_arch` - the name of an architecture to use
+* `backend` - 使用的后端，作为一个类或者一个名字
+* `custom_base_addr` - 使用的基地址
+* `custom_entry_point` - 使用的入口点
+* `custom_arch` - 使用的架构
 
-Example:
+例如:
 
 ```python
 angr.Project(main_opts={'backend': 'ida', 'custom_arch': 'i386'}, lib_opts={'libc.so.6': {'backend': 'elf'}})
 ```
 
-### Backends
+### 后端
 
-CLE currently has backends for statically loading ELF, PE, CGC, Mach-O and ELF core dump files, as well as loading binaries with IDA and loading files into a flat address space. CLE will automatically detect the correct backend to use in most cases, so you shouldn't need to specify which backend you're using unless you're doing some pretty weird stuff.
+CLE 目前拥有用于静态装载 ELF, PE, CGC, Mach-O 与 ELF core dump 文件的后端，其功能与使用 IDA 装载、将文件装载到 flat 地址空间相同。CLE 会自动检测并匹配正确的后端来使用，所以不需要手动指定
 
-You can force CLE to use a specific backend for an object by by including a key in its options dictionary, as described above. Some backends cannot autodetect which architecture to use and _must_ have a `custom_arch` specified. The key doesn't need to match any list of architectures; angr will identify which architecture you mean given almost any common identifier for any supported arch.
+当然，也可以在选项中强制指定 CLE 使用某一个后端来进行装载，某些后端无法自动检测需要使用的架构，_必须_ 使用 `custom_arch` 手动指定。如果和任何一个架构都不匹配，angr 会确定您所指定的架构，其几乎可以为任何受支持的架构提供任意通用标识符
 
-To refer to a backend, use the name from this table:
+要引用后端，请使用下表中的名字：
 
-| backend name | description | requires `custom_arch`? |
+| 后端名称 | 描述 | 需要 `custom_arch`? |
 | --- | --- | --- |
-| elf | Static loader for ELF files based on PyELFTools | no |
-| pe | Static loader for PE files based on PEFile | no |
-| mach-o | Static loader for Mach-O files. Does not support dynamic linking or rebasing. | no |
-| cgc | Static loader for Cyber Grand Challenge binaries | no |
-| backedcgc | Static loader for CGC binaries that allows specifying memory and register backers | no |
-| elfcore | Static loader for ELF core dumps | no |
-| ida | Launches an instance of IDA to parse the file | yes |
-| blob | Loads the file into memory as a flat image | yes |
+| elf | 基于 PyELFTools 的 ELF 文件静态装载器 | no |
+| pe | 基于 PEFile 的 PE 文件静态装载器 | no |
+| mach-o | Mach-O 文件的静态装载器，不支持动态链接或 rebasing | no |
+| cgc | CGC 二进制程序静态装载器 | no |
+| backedcgc | 允许指定内存和寄存器的 CGC 静态装载器 | no |
+| elfcore | ELF core dumps 的静态装载器 | no |
+| ida | 启动一个 IDA 实例来解析这个文件 | yes |
+| blob | 以 flat image 加载该文件进入内存 | yes |
 
-## Symbolic Function Summaries
+## 符号化函数摘要 Symbolic Function Summaries
 
-By default, Project tries to replace external calls to library functions by using symbolic summaries termed _SimProcedures_ - effectively just python functions that imitate the library function's effect on the state. We've implemented [a whole bunch of functions](https://github.com/angr/angr/tree/master/angr/procedures) as SimProcedures. These builtin procedures are available in the `angr.SIM_PROCEDURES` dictionary, which is two-leveled, keyed first on the package name \(libc, posix, win32, stubs\) and then on the name of the library function. Executing a SimProcedure instead of the actual library function that gets loaded from your system makes analysis a LOT more tractable, at the cost of [some potential inaccuracies](/docs/gotchas.md).
+默认情况下， Project 试着通过称为 _SimProcedures_ 的符号化摘要来替换对库函数的外部调用 - 实际上是用 Python 模拟库函数对 state 的影响
+我们已经实现了 SimProcedures 中的 [一系列功能](https://github.com/angr/angr/tree/master/angr/procedures) ，这些内置的功能更可以在字典 `angr.SIM_PROCEDURES` 中得到，该字典是双层的，第一层的键是包名 \(libc, posix, win32, stubs\)，第二层的键是库函数的名字。执行 SimProcedure 代替从系统装载的实际库函数开始分析更易于处理，当然是以 [一些潜在的不准确](/docs/gotchas.md) 作为代价。
 
-When no such summary is available for a given function:
+当给定的函数没有此类摘要时：
 
-* if `auto_load_libs` is `True` \(this is the default\), then the _real_ library function is executed instead. This may or may not be what you want, depending on the actual function. For example, some of libc's functions are extremely complex to analyze and will most likely cause an explosion of the number of states for the path trying to execute them.
-* if `auto_load_libs` is `False`, then external functions are unresolved, and Project will resolve them to a generic "stub" SimProcedure called `ReturnUnconstrained`. It does what its name says: it returns a unique unconstrained symbolic value each time it is called.
-* if `use_sim_procedures` \(this is a parameter to `angr.Project`, not `cle.Loader`\) is `False` \(it is `True` by default\), then only symbols provided by the extern object will be replaced with SimProcedures, and they will be replaced by a stub `ReturnUnconstrained`, which does nothing but return a symbolic value.
-* you may specify specific symbols to exclude from being replaced with SimProcedures with the parameters to `angr.Project`: `exclude_sim_procedures_list` and `exclude_sim_procedures_func`.
-* Look at the code for `angr.Project._register_object` for the exact algorithm.
+* 如果 `auto_load_libs` 是 `True` \(这也是默认值\)，则会执行真正的库函数。这取决于具体的功能，例如一些 libc 的函数的分析非常复杂，很可能因为试着执行导致路径状态数量爆炸
+* 如果 `auto_load_libs` 是 `False`，则外部函数无法解析，Project 将会解析它们到一个通用的、被叫做 `ReturnUnconstrained` 的 "stub" SimProcedure 上。它会在每次被调用时返回唯一的无约束符号化值
+* 如果 `use_sim_procedures` \(这个参数是 `angr.Project` 的，不是 `cle.Loader` 的\) 是 `False` \(默认为 `True`\)，则只有外部对象提供的符号被 SimProcedures 替换，并且它们会被 stub `ReturnUnconstrained` 替换，它不会执行任何操作只返回一个符号化值
+* 通过将参数 `exclude_sim_procedures_list` 和 `exclude_sim_procedures_func` 送给 `angr.Project` 可以指定特定的符号排除在 SimProcedures 替换的范围之外
+* 可以查看 `angr.Project._register_object` 的代码来确定具体的算法
 
 #### Hooking
 
-The mechanism by which angr replaces library code with a python summary is called hooking, and you can do it too! When performing simulation, at every step angr checks if the current address has been hooked, and if so, runs the hook instead of the binary code at that address. The API to let you do this is `proj.hook(addr, hook)`, where `hook` is a SimProcedure instance. You can manage your project's hooks with `.is_hooked`, `.unhook`, and `.hooked_by`, which should hopefully not require explanation.
+angr 用 Python 摘要代替库函数的机制叫做 Hooking。执行仿真时，每一步 angr 都会检查当前地址是否被 Hook，如果成功则在在地址运行 Hook 代码而不是二进制代码。
+Hooking 的函数是 `proj.hook(addr, hook)`，Hook 的位置是一个 SimProcedure 实例。您可以通过 `.is_hooked`、`.unhook` 和 `.hooked_by` 来管理您工程中的钩子
 
-There is an alternate API for hooking an address that lets you specify your own off-the-cuff function to use as a hook, by using `proj.hook(addr)` as a function decorator. If you do this, you can also optionally specify a `length` keyword argument to make execution jump some number of bytes forward after your hook finishes.
+Hooking 一个地址还有一个可替代的 API，通过使用 `proj.hook(addr)` 作为函数装饰器，可以自己指定 off-the-cuff 函数用作钩子。还可以选择指定一个 `length` 参数来确定钩子执行完成后向前跳转一些字节
 
 ```python
 >>> stub_func = angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'] # this is a CLASS
@@ -273,13 +273,11 @@ True
 True
 ```
 
-Furthermore, you can use `proj.hook_symbol(name, hook)`, providing the name of a symbol as the first argument, to hook the address where the symbol lives.
-One very important usage of this is to extend the behavior of angr's built-in library SimProcedures.
-Since these library functions are just classes, you can subclass them, overriding pieces of their behavior, and then use your subclass in a hook.
+此外，我们可以使用 `proj.hook_symbol(name, hook)` 作为第一个参数提供 symbol 的名字，来勾住 symbol 所在的地址。一个非常重要的用途就是用来扩展 angr 内建库 SimProcedures 的行为
+由于这些库函数只是类，您可以进行子类化，覆写他们的函数，然后在 Hook 中使用您的子类
 
 ## So far so good!
 
-By now, you should have a reasonable understanding of how to control the environment in which your analysis happens, on the level of the CLE loader and the angr Project.
-You should also understand that angr makes a reasonable attempt to simplify its analysis by hooking complex library functions with SimProcedures that summarize the effects of the functions.
+到目前为止，您应该对 CLE 装载器和 angr Project 各级如何控制您分析环境中的各种使用方法有所了解了。还应该了解了 angr 通过 SimProcedures 挂钩复杂函数库提供函数摘要来简化分析。
 
-In order to see all the things you can do with the CLE loader and its backends, look at the [CLE API docs.](http://angr.io/api-doc/cle.html)
+为了查看 CLE 装载器中所有可用的信息以及后端的内容，请查看 [CLE API 文档](http://angr.io/api-doc/cle.html)
diff --git a/docs/more-examples.md b/docs/more-examples.md
index 93786df..8756cb1 100644
--- a/docs/more-examples.md
+++ b/docs/more-examples.md
@@ -1,215 +1,209 @@
-# CTF Challenge Examples
+# CTF Challenge 示例
 
-angr is very often used in CTFs.
-These are example scripts resulting from that use, mostly from Shellphish but also from many others.
+angr 在 CTF 中经常被使用，这些都是使用这个例子的脚本，大部分来自 Shellphish，也有很多其他队伍的
 
 ## ReverseMe example: HackCon 2016 - angry-reverser
 
-Script author: Stanislas Lejay (github: [@P1kachu](https://github.com/P1kachu))
+脚本作者： Stanislas Lejay (github: [@P1kachu](https://github.com/P1kachu))
 
-Script runtime: ~31 minutes
+脚本运行时间：约 31 分钟
 
-Here is the [binary](https://github.com/angr/angr-doc/tree/master/examples/hackcon2016_angry-reverser/yolomolo) and the [script](https://github.com/angr/angr-doc/tree/master/examples/hackcon2016_angry-reverser/solve.py)
+[二进制程序](https://github.com/angr/angr-doc/tree/master/examples/hackcon2016_angry-reverser/yolomolo) 与 [脚本](https://github.com/angr/angr-doc/tree/master/examples/hackcon2016_angry-reverser/solve.py)
 
 ## ReverseMe example: SecurityFest 2016 - fairlight
 
-Script author: chuckleberryfinn (github: [@chuckleberryfinn](https://github.com/chuckleberryfinn))
+脚本作者： chuckleberryfinn (github: [@chuckleberryfinn](https://github.com/chuckleberryfinn))
 
-Script runtime: ~20 seconds
+脚本运行时间：约 20 秒
 
-A simple reverse me that takes a key as a command line argument and checks it against 14 checks.
-Possible to solve the challenge using angr without reversing any of the checks.
+一道简单的逆向题，对一个命令行参数进行十四次检查。
+使用 angr 不用进行逆向就可以轻松解决这个问题。
 
-Here is the [binary](https://github.com/angr/angr-doc/tree/master/examples/securityfest_fairlight/fairlight) and the [script](https://github.com/angr/angr-doc/tree/master/examples/securityfest_fairlight/solve.py)
+[二进制程序](https://github.com/angr/angr-doc/tree/master/examples/securityfest_fairlight/fairlight) 与 [脚本](https://github.com/angr/angr-doc/tree/master/examples/securityfest_fairlight/solve.py)
 
 ## ReverseMe example: DEFCON Quals 2016 - baby-re
 
 - Script 0
 
-    author: David Manouchehri (github: [@Manouchehri](https://github.com/Manouchehri))
+    作者： David Manouchehri (github: [@Manouchehri](https://github.com/Manouchehri))
 
-    Script runtime: 8 minutes
+    脚本运行时间： 8 分钟
 
 - Script 1
 
-    author: Stanislas Lejay (github: [@P1kachu](https://github.com/P1kachu))
+    作者： Stanislas Lejay (github: [@P1kachu](https://github.com/P1kachu))
 
-    Script runtime: 11 sec
+    脚本运行时间： 11 秒
 
-Here is the [binary](https://github.com/angr/angr-doc/blob/master/examples/defcon2016quals_baby-re_1/baby-re) and the scripts:
+[二进制程序](https://github.com/angr/angr-doc/blob/master/examples/defcon2016quals_baby-re_1/baby-re) 与脚本：
 * [script0](https://github.com/angr/angr-doc/tree/master/examples/defcon2016quals_baby-re_0/solve.py)
 * [script1](https://github.com/angr/angr-doc/tree/master/examples/defcon2016quals_baby-re_1/solve.py)
 
 ## ReverseMe example: Google CTF - Unbreakable Enterprise Product Activation (150 points)
 
-Script 0 author: David Manouchehri (github: [@Manouchehri](https://github.com/Manouchehri))
+Script 0 作者： David Manouchehri (github: [@Manouchehri](https://github.com/Manouchehri))
 
-Script runtime: 4.5 sec
+脚本运行时间： 4.5 秒
 
-Script 1 author: Adam Van Prooyen (github: [@docileninja](https://github.com/docileninja))
+Script 1 作者： Adam Van Prooyen (github: [@docileninja](https://github.com/docileninja))
 
-Script runtime: 6.7 sec
+脚本运行时间： 6.7 秒
 
-A Linux binary that takes a key as a command line argument and checks it against a series of constraints.
+对一个 Linux 二进制程序的命令行参数进行一系列的约束检查
 
-Challenge Description:
-> We need help activating this product -- we've lost our license key :(
+Challenge 描述：
+> 帮助我们激活这个产品 - 我们失去了我们的许可证密钥 :(
 >
-> You're our only hope!
+> 你是我们唯一的希望！
 
-Here are the binary and scripts: [script 0](https://github.com/angr/angr-doc/tree/master/examples/google2016_unbreakable_0), [script_1](https://github.com/angr/angr-doc/tree/master/examples/google2016_unbreakable_1)
+[script 0](https://github.com/angr/angr-doc/tree/master/examples/google2016_unbreakable_0) 和 [script_1](https://github.com/angr/angr-doc/tree/master/examples/google2016_unbreakable_1)
 
 ## ReverseMe example: EKOPARTY CTF - Fuckzing reverse (250 points)
 
-Author: Adam Van Prooyen (github: [@docileninja](https://github.com/docileninja))
+作者： Adam Van Prooyen (github: [@docileninja](https://github.com/docileninja))
 
-Script runtime: 29 sec
+脚本运行时间： 29 秒
 
-A Linux binary that takes a team name as input and checks it against a series of constraints.
+以队伍名字作为 Linux 二进制程序的输入并进行一系列的约束检查
 
-Challenge Description:
-> Hundreds of conditions to be meet, will you be able to surpass them?
+Challenge 描述：
+> 需要满足几百个约束，你能完成吗？
 
-Both sample binaries and the script are located [here](https://github.com/angr/angr-doc/tree/master/examples/ekopartyctf2016_rev250) and additional information be found at the author's [write-up](http://van.prooyen.com/reversing/2016/10/30/Fuckzing-reverse-Writeup.html).
+[二进制程序与脚本](https://github.com/angr/angr-doc/tree/master/examples/ekopartyctf2016_rev250) 更多信息可以参阅作者的 [write-up](http://van.prooyen.com/reversing/2016/10/30/Fuckzing-reverse-Writeup.html)
 
 ## ReverseMe example: WhiteHat Grant Prix Global Challenge 2015 - Re400
 
-Author: Fish Wang (github: @ltfish)
+作者： Fish Wang (github: @ltfish)
 
-Script runtime: 5.5 sec
+脚本运行时间： 5.5 秒
 
-A Windows binary that takes a flag as argument, and tells you if the flag is correct or not.
+接受一个 flag 作为参数的 Windows 程序，反馈告诉你 flag 是否正确
 
-"I have to patch out some checks that are difficult for angr to solve (e.g., it uses some bytes of the flag to decrypt some data, and see if those data are legit Windows APIs).
-Other than that, angr works really well for solving this challenge."
+必须手动修正一些对于 angr 来说很难解决的校验检查（例如，其使用 flag 的一些字节来解密数据，并看这些数据是不是合法的 Windows API）。
+除此之外，angr 非常适合解决这个问题
 
-The [binary](https://github.com/angr/angr-doc/tree/master/examples/whitehatvn2015_re400/re400.exe) and the [script](https://github.com/angr/angr-doc/tree/master/examples/whitehatvn2015_re400/solve.py).
+[二进制程序](https://github.com/angr/angr-doc/tree/master/examples/whitehatvn2015_re400/re400.exe) 与 [脚本](https://github.com/angr/angr-doc/tree/master/examples/whitehatvn2015_re400/solve.py).
 
 ## ReverseMe example: EKOPARTY CTF 2015 - rev 100
 
-Author: Fish Wang (github: @ltfish)
+作者： Fish Wang (github: @ltfish)
 
-Script runtime: 5.5 sec
+脚本运行时间： 5.5 秒
 
-This is a painful challenge to solve with angr. I should have done things in a smarter way.
+即使使用 angr 也是一个复杂的问题，应该有更好的解决方式
 
-Here is the [binary](https://github.com/angr/angr-doc/tree/master/examples/ekopartyctf2015_rev100/counter) and the [script](https://github.com/angr/angr-doc/tree/master/examples/ekopartyctf2015_rev100/solve.py).
+[二进制程序](https://github.com/angr/angr-doc/tree/master/examples/ekopartyctf2015_rev100/counter) 与 [脚本](https://github.com/angr/angr-doc/tree/master/examples/ekopartyctf2015_rev100/solve.py).
 
 ## ReverseMe example: ASIS CTF Finals 2015 - fake
 
-Author: Fish Wang (github: @ltfish)
+作者： Fish Wang (github: @ltfish)
 
-Script runtime: 1 min 57 sec
+脚本运行时间： 1 分 57 秒
 
-The solution is pretty straight-forward.
+解决方案简单粗暴
 
-The [binary](https://github.com/angr/angr-doc/tree/master/examples/asisctffinals2015_fake/fake) and the [script](https://github.com/angr/angr-doc/tree/master/examples/asisctffinals2015_fake/solve.py).
+[二进制程序](https://github.com/angr/angr-doc/tree/master/examples/asisctffinals2015_fake/fake) 与 [脚本](https://github.com/angr/angr-doc/tree/master/examples/asisctffinals2015_fake/solve.py).
 
 ## ReverseMe example: Defcamp CTF Qualification 2015 - Reversing 100
 
-Author: Fish Wang (github: @ltfish)
+作者： Fish Wang (github: @ltfish)
 
-angr solves this challenge with almost zero user-interference.
+几乎不用用户交互，angr 就可以解决这个问题
 
-See the [script](https://github.com/angr/angr-doc/tree/master/examples/defcamp_r100/solve.py) and the [binary](https://github.com/angr/angr-doc/tree/master/examples/defcamp_r100/r100).
+[脚本](https://github.com/angr/angr-doc/tree/master/examples/defcamp_r100/solve.py) 与 [二进制程序](https://github.com/angr/angr-doc/tree/master/examples/defcamp_r100/r100).
 
 ## ReverseMe example: Defcamp CTF Qualification 2015 - Reversing 200
 
-Author: Fish Wang (github: @ltfish)
+作者： Fish Wang (github: @ltfish)
 
-angr solves this challenge with almost zero user-interference. Veritesting is required to retrieve the flag promptly.
+几乎不用用户交互，angr 就可以解决这个问题。
+Veritesting 要求及时检索 flag
 
-The [script](https://github.com/angr/angr-doc/tree/master/examples/defcamp_r200/solve.py) and the [binary](https://github.com/angr/angr-doc/tree/master/examples/defcamp_r200/r200).
-It takes a few minutes to run on my laptop.
+[脚本](https://github.com/angr/angr-doc/tree/master/examples/defcamp_r200/solve.py) 与 [二进制程序](https://github.com/angr/angr-doc/tree/master/examples/defcamp_r200/r200)
+
+注意：该脚本在我的电脑上需要运行几分钟
 
 ## ReverseMe example: MMA CTF 2015 - HowToUse
 
-Author: Audrey Dutcher (github: @rhelmot)
+作者： Audrey Dutcher (github: @rhelmot)
+
+我们使用 angr 解决了这个问题，因为我们懒得去逆向或者放在 Windows 上去运行它。
 
-We solved this simple reversing challenge with angr, since we were too lazy to reverse it or run it in Windows.
-The resulting [script](https://github.com/angr/angr-doc/tree/master/examples/mma_howtouse/solve.py) shows how we grabbed the flag out of the [DLL](https://github.com/angr/angr-doc/tree/master/examples/mma_howtouse/howtouse.dll).
+[脚本](https://github.com/angr/angr-doc/tree/master/examples/mma_howtouse/solve.py) 展示了我们如何从 [DLL](https://github.com/angr/angr-doc/tree/master/examples/mma_howtouse/howtouse.dll) 中找到 flag
 
 
 ## CrackMe example: MMA CTF 2015 - SimpleHash
 
-Author: Chris Salls (github: @salls)
+作者： Chris Salls (github: @salls)
+
+这个问题的 95% 都可以使用 angr 来解决，但仍然必须手动来解决一些复杂约束
 
-This crackme is 95% solvable with angr, but we did have to overcome some difficulties.
-The [script](https://github.com/angr/angr-doc/tree/master/examples/mma_simplehash/solve.py) describes the difficulties that were encountered and how we worked around them.
-The binary can be found [here](https://github.com/angr/angr-doc/tree/master/examples/mma_simplehash/simple_hash).
+[脚本](https://github.com/angr/angr-doc/tree/master/examples/mma_simplehash/solve.py) 展示了会遇到什么困难，以及是如何解决的。并带有 [二进制程序](https://github.com/angr/angr-doc/tree/master/examples/mma_simplehash/simple_hash).
 
 
 ## ReverseMe example: FlareOn 2015 - Challenge 10
 
-Author: Fish Wang (github: @ltfish)
+作者： Fish Wang (github: @ltfish)
 
-angr acts as a binary loader and an emulator in solving this challenge.
-I didn’t have to load the driver onto my Windows box.
+angr 可以充当二进制加载器与模拟器来解决这个问题。不必将该驱动加载到 Windows 中
 
-The [script](https://github.com/angr/angr-doc/tree/master/examples/flareon2015_10/solve.py) demonstrates how to hook at arbitrary program points without affecting the intended bytes to be executed (a zero-length hook).
-It also shows how to read bytes out of memory and decode as a string.
+[脚本](https://github.com/angr/angr-doc/tree/master/examples/flareon2015_10/solve.py) 展示了如何在任意程序点 Hook 而不影响要执行的预期字节（零长度Hook），以及如何读取内存中的字节并将其解码为字符串
 
-By the way, here is the [link](https://www.fireeye.com/content/dam/fireeye-www/global/en/blog/threat-research/flareon/2015solution10.pdf) to the intended solution from FireEye.
+顺便一提，这里还有 FireEye 的[解决方案](https://www.fireeye.com/content/dam/fireeye-www/global/en/blog/threat-research/flareon/2015solution10.pdf)
 
 
 ## ReverseMe example: FlareOn 2015 - Challenge 2
 
-Author: Chris Salls (github: @salls)
-
-This [reversing challenge](https://github.com/angr/angr-doc/tree/master/examples/flareon2015_2/very_success) is simple to solve almost entirely with angr, and a lot faster than trying to reverse the password checking function. The script is [here](https://github.com/angr/angr-doc/tree/master/examples/flareon2015_2/solve.py)
-
+作者： Chris Salls (github: @salls)
 
+这个 [二进制程序](https://github.com/angr/angr-doc/tree/master/examples/flareon2015_2/very_success) 使用 angr 就非常容易解决，且比尝试逆向密码校验函数快得多。带有[脚本](https://github.com/angr/angr-doc/tree/master/examples/flareon2015_2/solve.py)
 
 
 ## ReverseMe example: 0ctf 2016 - momo
 
-Author: Fish Wang (github: @ltfish), ocean (github: @ocean1)
+作者： Fish Wang (github: @ltfish), ocean (github: @ocean1)
 
-This challenge is a [movfuscated](https://github.com/xoreaxeaxeax/movfuscator) binary.
-To find the correct password after exploring the binary with Qira it is possible to understand
-how to find the places in the binary where every character is checked using capstone and using angr to
-load the [binary](./examples/0ctf_momo/solve.py) and brute-force the single characters of the flag.
-Be aware that the [script](./examples/0ctf_momo/solve.py) is really slow. Runtime: > 1 hour.
+在使用 Qira 探索了[二进制程序](https://github.com/xoreaxeaxeax/movfuscator)后想要找到正确的密码。
+如何使用 capstone 在二进制程序中找到每个用于校验的字符、如何使用 angr 加载该 [二进制程序](./examples/0ctf_momo/solve.py) 并指定 flag 的单个字符。
+请注意：[脚本](./examples/0ctf_momo/solve.py)执行非常慢，运行时间超过一个小时
 
 
 ## CrackMe example: Layer7 CTF 2015 - Windows challenge OnlyOne
 
-Author: Fish Wang (github: @ltfish)
+作者： Fish Wang (github: @ltfish)
+
+我们在 angr 的帮助下解决了这个问题
 
-We solved this crackme with angr’s help.
-(Fish: This is my first time solving a reversing challenge without understanding what’s going on.)
-The challenge binary is [here](https://github.com/angr/angr-doc/tree/master/examples/layer7_onlyone/onlyone.exe), and the solving script [here](https://github.com/angr/angr-doc/tree/master/examples/layer7_onlyone/solve.py).
+[二进制程序](https://github.com/angr/angr-doc/tree/master/examples/layer7_onlyone/onlyone.exe) 与 [脚本](https://github.com/angr/angr-doc/tree/master/examples/layer7_onlyone/solve.py).
 
-The solving script demonstrates the following:
-- How to load a Windows binary (no difference than an ELF).
-- How to use hook to replace arbitrary code in a loaded program.
-- How to use Explorer to perform a symbolic exploration (although everyone else thinks PathGroup is the future).
-- How to enable Veritesting, and why it is useful.
+脚本演示了：
+- 如何加载 Windows 二进制程序文件（与 ELF 程序没有区别）
+- 如何使用 Hook 替换加载程序中的任意代码
+- 如何使用 Explorer 来执行符号探索（尽管其他人认为 PathGroup 是未来）
+- 如何启用 Veritesting，以及这为什么有用
 
 
 ## CrackMe example: 9447 CTF 2015 - Reversing 330, "nobranch"
 
-Author: Audrey Dutcher (github: @rhelmot)
+作者： Audrey Dutcher (github: @rhelmot)
 
-angr cannot currently solve this problem natively, as the problem is too complex for z3 to solve.
-Formatting the constraints to z3 a little differently allows z3 to come up with an answer relatively quickly.
-(I was asleep while it was solving, so I don't know exactly how long!)
-The script for this is [here](https://github.com/angr/angr-doc/tree/master/examples/9447_nobranch/solve.py) and the binary is [here](https://github.com/angr/angr-doc/tree/master/examples/9447_nobranch/nobranch).
+目前 angr 无法解决这个问题，因为这个问题对于 Z3 来说过于复杂了。但将约束条件格式化后，就使得 Z3 能够相对快速的解决问题（求解时我睡着了，所以我不知道花了多长时间！）
+[脚本](https://github.com/angr/angr-doc/tree/master/examples/9447_nobranch/solve.py) 与 [二进制程序](https://github.com/angr/angr-doc/tree/master/examples/9447_nobranch/nobranch).
 
 ## CrackMe example: ais3_crackme
 
-Author: Antonio Bianchi, Tyler Nighswander
+作者： Antonio Bianchi, Tyler Nighswander
 
-ais3_crackme has been developed by Tyler Nighswander (tylerni7) for ais3 summer school. It is an easy crackme challenge, checking its command line argument.
+ais3_crackme 由 Tyler Nighswander (tylerni7) 为 ais3 暑期培训而开发。是一个检查命令行参数的简单问题
 
 ## ReverseMe: Modern Binary Exploitation - CSCI 4968
 
-Author: David Manouchehri (GitHub [@Manouchehri](https://github.com/Manouchehri))
+作者： David Manouchehri (GitHub [@Manouchehri](https://github.com/Manouchehri))
 
-[This folder](https://github.com/angr/angr-doc/tree/master/examples/CSCI-4968-MBE/challenges) contains scripts used to solve some of the challenges with angr. At the moment it only contains the examples from the IOLI crackme suite, but eventually other solutions will be added.
+该[文件夹](https://github.com/angr/angr-doc/tree/master/examples/CSCI-4968-MBE/challenges)含有许多使用 angr 解决问题的脚本。目前只包含 IOLI crackme 套件中的例子，但最终会添加其他解决方案
 
 ## CrackMe example: Android License Check
 
-Author: Bernhard Mueller (GitHub [@b-mueller](https://github.com/angr/angr-doc/tree/master/examples/))
+作者： Bernhard Mueller (GitHub [@b-mueller](https://github.com/angr/angr-doc/tree/master/examples/))
 
-A [native binary for Android/ARM](https://github.com/b-angr/angr-doc/tree/master/examples/android_arm_license_validation) that validates a license key passed as a command line argument. It was created for the symbolic execution tutorial in the [OWASP Mobile Testing Guide](https://github.com/OWASP/owasp-mstg/).
+为验证命令行参数传递许可证密钥的 [Android/ARM 原生二进制程序](https://github.com/b-angr/angr-doc/tree/master/examples/android_arm_license_validation)问题，其为 [OWASP Mobile Testing Guide](https://github.com/OWASP/owasp-mstg/) 中的符号执行教程而创建
diff --git a/docs/pathgroups.md b/docs/pathgroups.md
index 221ddd6..072f42e 100644
--- a/docs/pathgroups.md
+++ b/docs/pathgroups.md
@@ -1,17 +1,16 @@
 # Simulation Managers
 
-The most important control interface in angr is the SimulationManager, which allows you to control symbolic execution over groups of states simultaneously, applying search strategies to explore a program's state space.
-Here, you'll learn how to use it.
+angr 中最重要的控制接口是 SimulationManager，它提供对 state 组中符号执行的控制，应用搜索策略探索程序的状态空间。
+本节，你将会学会如何使用它
 
-Simulation managers let you wrangle multiple states in a slick way.
-States are organized into “stashes”, which you can step forward, filter, merge, and move around as you wish.
-This allows you to, for example, step two different stashes of states at different rates, then merge them together.
-The default stash for most operations is the `active` stash, which is where your states get put when you initialize a new simulation manager.
+Simulation managers 可以让你以简单的方式来控制多个 state。
+State 被组织为 stash，可以按照使用者的意愿步进、过滤、合并与移动。
+例如，使用者可以以不同的速率步进两个不同的 state，然后对这两个 state 进行合并。
+大多数操作默认的 stash 是 `active` 的，当一个新的 simulation manager 初始化时 state 放置的位置
 
-### Stepping
+### 步进
 
-The most basic capability of a simulation manager is to step forward all states in a given stash by one basic block.
-You do this with `.step()`.
+simulation manager 最基本的功能是通过一个基本块将给定 stash 中的所有 state 向前步进，通过 `.step()` 执行
 
 ```python
 >>> import angr
@@ -26,11 +25,11 @@ You do this with `.step()`.
 [<SimState @ 0x400540>]
 ```
 
-Of course, the real power of the stash model is that when a state encounters a symbolic branch condition, both of the successor states appear in the stash, and you can step both of them in sync.
-When you don't really care about controlling analysis very carefully and you just want to step until there's nothing left to step, you can just use the `.run()` method.
+当然，stash 的真正优势在于当一个 state 遇到一个符号分支条件时，两个后继 state 都出现在 stash 中，允许使用者对齐同步步进。
+当你不太在意控制分析，只是想步进 state 直到没有后继 state 可以继续的时候，可以使用 `.run()`
 
 ```python
-# Step until the first symbolic branch
+# 步进直到第一个符号分支
 >>> while len(simgr.active) == 1:
 ...    simgr.step()
 
@@ -39,21 +38,20 @@ When you don't really care about controlling analysis very carefully and you jus
 >>> simgr.active
 [<SimState @ 0x400692>, <SimState @ 0x400699>]
 
-# Step until everything terminates
+# 步进直到没有后继
 >>> simgr.run()
 >>> simgr
 <SimulationManager with 3 deadended>
 ```
+我们现在有三个 `deadended` 的 state！
+当一个 state 在执行期间没有产生任何的后继，比如到达了 `exit` 系统调用的位置，它将被从 active 的 stash 中移除并放置在 `deadended` 的 stash 中
 
-We now have 3 deadended states!
-When a state fails to produce any successors during execution, for example, because it reached an `exit` syscall, it is removed from the active stash and placed in the `deadended` stash.
+### Stash 管理
 
-### Stash Management
+让我们看看其他的 stash 是如何工作的？
 
-Let's see how to work with other stashes.
-
-To move states between stashes, use `.move()`,  which takes `from_stash` (optional, default "active"), `to_stash`, and `filter_func` (optional, default is to move everything).
-For example, let's move everything that has a certain string in its output:
+为了在 stash 间移动 state，要使用 `.move()`，它带有三个参数 `from_stash`（可选，默认 active）、`to_stash`、`filter_func`（可选，默认全部移动）。
+例如，移动输出中有确定字符串的所有内容：
 
 ```python
 >>> simgr.move(from_stash='deadended', to_stash='authenticated', filter_func=lambda s: 'Welcome' in s.posix.dumps(1))
@@ -61,12 +59,12 @@ For example, let's move everything that has a certain string in its output:
 <SimulationManager with 2 authenticated, 1 deadended>
 ```
 
-We were able to just create a new stash named "authenticated" just by asking for states to be moved to it.
-All the states in this stash have "Welcome" in their stdout, which is a fine metric for now.
+我们要通过移动 state 来创建一个名为 authenticated 的新 stash。
+所有在这个 stash 中的 state 都有 Welcome，目前而言这是一个很好的指标
 
-Each stash is just a list, and you can index into or iterate over the list to access each of the individual states, but there are some alternate methods to access the states too.
-If you prepend the name of a stash with `one_`, you will be given the first state in the stash.
-If you prepend the name of a stash with `mp_`, you will be given a [mulpyplexed](https://github.com/zardus/mulpyplexer) version of the stash.
+每个 stash 只是一个列表，使用者可以索引或迭代列表来访问每个单独的 state。同时，也有一些替代方法来访问 state。
+如果在 stash 的名字前面加上了 `one_`，将会得到 stash 中的第一个 state。
+如果在 stash 的名字前面加上了 `mp_`，将会得到一个 [mulpyplexed](https://github.com/zardus/mulpyplexer) 版本的 stash 
 
 ```python
 >>> for s in simgr.deadended + simgr.authenticated:
@@ -84,61 +82,60 @@ MP(['\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00',
     '\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80\x80@\x80@\x00'])
 ```
 
-Of course, `step`, `run`, and any other method that operates on a single stash of paths can take a `stash` argument, specifying which stash to operate on.
+当然，`step`、`run` 和其他任何操作路径上单独 stash 的函数都可以带上 `stash` 参数来指定操作的 stash
 
-There are lots of fun tools that the simulation manager provides you for managing your stashes.
-We won't go into the rest of them for now, but you should check out the API documentation. TODO: link
+simulation manager 提供了许多有用的工具来管理 stash。
+我们现在不会讲解其余的部分，详情可见 API 文档
 
-## Stash types
+## Stash 类型
 
-You can use stashes for whatever you like, but there are a few stashes that will be used to categorize some special kinds of states.
-These are:
+你可以使用任何你指定的 stash，但是有一些 stash 被用来分类特殊的 state
 
-| Stash | Description |
+| Stash | 描述 |
 |-------|-------------|
-| active     | This stash contains the states that will be stepped by default, unless an alternate stash is specified. |
-| deadended     | A state goes to the deadended stash when it cannot continue the execution for some reason, including no more valid instructions, unsat state of all of its successors, or an invalid instruction pointer. |
-| pruned        | When using `LAZY_SOLVES`, states are not checked for satisfiability unless absolutely necessary. When a state is found to be unsat in the presence of `LAZY_SOLVES`, the state hierarchy is traversed to identify when, in its history, it initially became unsat. All states that are descendants of that point (which will also be unsat, since a state cannot become un-unsat) are pruned and put in this stash. |
-| unconstrained | If the `save_unconstrained` option is provided to the SimulationManager constructor, states that are determined to be unconstrained (i.e., with the instruction pointer controlled by user data or some other source of symbolic data) are placed here. |
-| unsat | If the `save_unsat` option is provided to the SimulationManager constructor, states that are determined to be unsatisfiable (i.e., they have constraints that are contradictory, like the input having to be both "AAAA" and "BBBB" at the same time) are placed here. |
+| active     | 这个 stash 包含默认步进的 state，除非指定了替代的 stash |
+| deadended     | 当一个 state 因为某种原因无法继续执行，可能是没有更多有效指令、所有后继 state 都不成立或者遇到一个无效的指令指针时，state 就会转移到 deadended 的 stash 中 |
+| pruned        | When a state is found to be unsat in the presence of `LAZY_SOLVES`, the state hierarchy is traversed to identify when, in its history, it initially became unsat. All states that are descendants of that point (which will also be unsat, since a state cannot become un-unsat) are pruned and put in this stash. |
+| unconstrained | 如果 `save_unconstrained` 选项提供给 SimulationManager 的构造函数，那些被确定为无约束的 state（由用户数据或其他符号数据源控制的指令指针） 就会放在这里 |
+| unsat | 如果 `save_unsat` 选项提供给 SimulationManager 的构造函数，那些被确定为不可满足的 state（比如具有互斥的约束，输入必须同时是“AAAA”和“BBBB”）就会放在这里 |
 
-There is another list of states that is not a stash: `errored`.
-If, during execution, an error is raised, then the state will be wrapped in an `ErrorRecord` object, which contains the state and the error it raised, and then the record will be inserted into `errored`.
-You can get at the state as it was at the beginning of the execution tick that caused the error with `record.state`, you can see the error that was raised with `record.error`, and you can launch a debug shell at the site of the error with `record.debug()`.
-This is an invaluable debugging tool!
+还有另一个不是 stash 的 state 列表：errored。
+如果在执行过程中发生错误，state 将会被包装在一个 ErrorRecord 的对象中，其中包含 state 和引发的错误，然后记录被插入 errored 列表中。
+可以在造成错误的执行位置开始处使用 `record.state` 得到 state，可以通过 `record.error` 看到引发的错误，并且可以在错误处使用 `record.debug()` 启动一个调试 Shell。
+这是一个非常有价值的调试工具！
 
-### Simple Exploration
+### 简单探索
 
-An extremely common operation in symbolic execution is to find a state that reaches a certain address, while discarding all states that go through another address.
-Simulation manager has a shortcut for this pattern, the `.explore()` method.
+符号执行中一个常见的操作就是找到能到达某个确定地址的 state，同时丢弃所有经过另一地址的 state。
+Simulation manager 提供了一个简便方法： `.explore()`
 
-When launching `.explore()` with a `find` argument, execution will run until a state is found that matches the find condition, which can be the address of an instruction to stop at, a list of addresses to stop at, or a function which takes a state and returns whether it meets some criteria.
-When any of the states in the active stash match the `find` condition, they are placed in the `found` stash, and execution terminates.
-You can then explore the found state, or decide to discard it and continue with the other ones.
-You can also specify an `avoid` condition in the same format as `find`.
-When a state matches the avoid condition, it is put in the `avoided` stash, and execution continues.
-Finally, the `num_find` argument controls the number of states that should be found before returning, with a default of 1.
-Of course, if you run out of states in the active stash before finding this many solutions, execution will stop anyway.
+当 `explore()` 使用 `find` 参数开始时，执行将会一直运行直到找到与条件相匹配的 state，该条件可以是准备停止位置的指令地址、准备停止位置的指令地址列表或者满足一些条件的函数。
+当 active 的 stash 中的任何一个 state 匹配了 find 的条件，就会被移动到 `found` 的 stash 中，并且终止执行。
+使用者可以探索已发现的 state，或者选择放弃这个 state 继续探索。
+还可以使用与 `find` 相同的格式来指定 `avoid` 条件。
+当 state 匹配了 `avoid` 的条件，就会被移动至 `avoided` 的 stash，并保持执行。
+最后，`num_find` 参数控制返回之前找到的 state 的数量，默认值为 1.当然，如果在找到指定数量的解决方案之前就耗尽了 active 的 stash 中的所有 state 执行将会终止 
 
-Let's look at a simple crackme [example](./examples.md#reverseme-modern-binary-exploitation---csci-4968):
+让我们看一个简单 crackme 的[例子](./examples.md#reverseme-modern-binary-exploitation---csci-4968):
 
-First, we load the binary.
+首先，我们加载二进制程序
 ```python
 >>> proj = angr.Project('examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a')
 ```
 
-Next, we create a SimulationManager.
+接下来，我们创建一个 SimulationManager
 ```python
 >>> simgr = proj.factory.simgr()
 ```
 
-Now, we symbolically execute until we find a state that matches our condition (i.e., the "win" condition).
+现在我们进行符号执行，直到找到符合我们条件的 state
 ```python
 >>> simgr.explore(find=lambda s: "Congrats" in s.posix.dumps(1))
 <SimulationManager with 1 active, 1 found>
 ```
 
-Now, we can get the flag out of that state!
+现在，我们可以得到 state 中的 flag 了！
+
 ```python
 >>> s = simgr.found[0]
 >>> print s.posix.dumps(1)
@@ -149,21 +146,20 @@ Enter password: Congrats!
 g00dJ0B!
 ```
 
-Pretty simple, isn't it?
+相当简单吧~不是吗？
 
-Other examples can be found by browsing the [examples](./examples.md).
+其他例子可以通过 [examples.md](./examples.md) 查看
 
-## Exploration Techniques
+## 探索技术
 
-angr ships with several pieces of canned functionality that let you customize the behavior of a simulation manager, called _exploration techniques_.
-The archetypical exploration technique is depth-first search, which puts all active paths except one in a stash called `deferred`, and whenever `active` goes empty, pops a state out of `deferred` and continues.
+angr 附带了几个小功能，可以自定义 simulation manager 的操作行为，称为_探索技术_。探索技术的原型是深度优先搜索，它将除了一个路径外的所有 active 路径都送入被称为 `deferred` 的 stash 中，每当 `active` 为空时，就会弹出一个 `deferred` 的 state 继续执行下去
 
-To use an exploration technique, call `simgr.use_technique(tech)`, where tech is an instance of an ExplorationTechnique subclass.
-angr's built-in exploration techniques can be found under `angr.exploration_techniques`.
+要使用探索技术，调用 `simgr.use_technique(tech)`，这是 ExplorationTechnique 子类的一个实例。
+angr 内置的探索技术可以在 `angr.exploration_techniques` 中找到
 
-Here's a quick overview of some of the built-in ones:
+以下是关于内置探索技术的概览
 
 - TODO
 
-You can also write your own exploration techniques!
-This will be covered in a later chapter.
\ No newline at end of file
+你也可以编写属于你自己的探索技术！
+这一点我们将在以后介绍
diff --git a/docs/pipeline.md b/docs/pipeline.md
index 405795c..ca871f1 100644
--- a/docs/pipeline.md
+++ b/docs/pipeline.md
@@ -1,20 +1,17 @@
-Understanding the Execution Pipeline
+理解执行管道
 ====================================
 
-If you've made it this far you know that at its core, angr is a highly flexible and intensely instrumentable emulator.
-In order to get the most mileage out of it, you'll want to know what happens at every step of the way when you say `path_group.step()`.
+如果你已经看到了这节，想必你已经了解了，Angr 的核心是一个高度灵活、强大、可操作的模拟器。为了更熟练的使用 angr，就需要了解在使用 `path_group.step()` 时都发生了什么
 
-This is intended to be a more advanced document; you'll need to understand the function and intent of `PathGroup`, `ExplorationTechnique`, `Path`, `SimState`, and `SimEngine` in order to understand what we're talking about at times!
-You may want to have the angr source open to follow along with this.
+这是一个更加深入的文档，你需要理解 `PathGroup`、`ExplorationTechnique`、`Path`、`SimState` 和 `SimEngine` 的函数和意图。你也可以打开 angr 的源码跟着我们逐一体会
 
 ## Path Groups
 
-So you've called for a step to occur. Time to begin our journey.
+当你准备调用下一步时，也就开始了
 
 ### `step()`
 
-`PathGroup.step()` function takes many optional parameters.
-The most important of these are `stash`, `n`, `until`, and `step_func`.
+`PathGroup.step()` 函数有许多可选参数，最重要的有 `stash`、`n`、`until` 和 `step_func`。
 `n` is used immediately - the `step()` function loops, calling the `_one_step()` function and passing on all its parameters until either `n` steps have happened or some other termination condition has occurred. If `n` is not provided, it defaults to 1, unless an `until` function is provided, in which case it is 100000 - effectively infinite.
 
 Before any of the termination conditions are checked, however, `step_func` is applied - this function takes the current path group and returns a new path group to replace it.
@@ -141,29 +138,25 @@ In addition to parameters to the stepping process, you can also instantiate new
 Look at the API docs to see what options each engine can take.
 Once you have a new engine instance, you can either pass it into the step process, or directly put it into the `project.factory.engines` list for automatic use.
 
-# When using Unicorn Engine
+# 使用 Unicorn 引擎时
 
-If you add the `o.UNICORN` state option, at every step `SimEngineUnicorn` will be invoked, and try to see if it is allowed to use Unicorn to execute concretely.
+如果添加 `o.UNICORN` 选项，`SimEngineUnicorn` 就会逐步调用，并尝试查看是否允许使用Unicorn来具体执行
 
-What you REALLY want to do is to add the predefined set `o.unicorn` (lowercase) of options to your state:
+也许你真正想要的是将预定义 `o.unicorn`（小写）的选项添加到 state 中
 
 ```python
 unicorn = { UNICORN, UNICORN_SYM_REGS_SUPPORT, INITIALIZE_ZERO_REGISTERS, UNICORN_HANDLE_TRANSMIT_SYSCALL }
 ```
 
-These will enable some additional functionalities and defaults which will greatly enhance your experience.
-Additionally, there are a lot of options you can tune on the `state.unicorn` plugin.
+这些将会启用一些额外的功能和默认设置，都可以提高 angr 的表现。此外，还有很多选项可以调整 `state.unicorn` 插件
 
-A good way to understand how unicorn works is by examining the logging output (`logging.getLogger('angr.engines.unicorn_engine').setLevel('DEBUG'); logging.getLogger('angr.state_plugins.unicorn_engine').setLevel('DEBUG')` from a sample run of unicorn.
+了解 Unicorn 是如何工作的一个好方法是通过检查 Unicorn 的日志输出（`logging.getLogger('angr.engines.unicorn_engine').setLevel('DEBUG'); logging.getLogger('angr.state_plugins.unicorn_engine').setLevel('DEBUG')`）
 
 ```
 INFO    | 2017-02-25 08:19:48,012 | angr.state_plugins.unicorn | started emulation at 0x4012f9 (1000000 steps)
 ```
 
-Here, angr diverts to unicorn engine, beginning with the basic block at 0x4012f9.
-The maximum step count is set to 1000000, so if execution stays in Unicorn for 1000000 blocks, it'll automatically pop out.
-This is to avoid hanging in an infinite loop.
-The block count is configurable via the `state.unicorn.max_steps` variable.
+在此处，angr 会转向 unicorn 引擎，从基本块 0x4012f9 开始，最大步数设置为 1000000。如果在 Unicorn 中执行了一百万块，将会自动弹出。这是为了避免遇到无限循环时崩溃，块的数量也可以通过变量 `state.unicorn.max_steps` 来设置
 
 ```
 INFO    | 2017-02-25 08:19:48,014 | angr.state_plugins.unicorn | mmap [0x401000, 0x401fff], 5 (symbolic)
@@ -174,13 +167,13 @@ INFO    | 2017-02-25 08:19:48,023 | angr.state_plugins.unicorn | mmap [0x400000,
 INFO    | 2017-02-25 08:19:48,025 | angr.state_plugins.unicorn | mmap [0x7000000, 0x7000fff], 5
 ```
 
-angr performs lazy mapping of data that is accessed by unicorn engine, as it is accessed. 0x401000 is the page of instructions that it is executing, 0x7fffffffffe0000 is the stack, and so on. Some of these pages are symbolic, meaning that they contain at least some data that, when accessed, will cause execution to abort out of Unicorn.
+angr 执行由 unicorn 引擎访问的数据的 lazy 映射。0x401000 是正在执行的指令的页面，0x7fffffffffe0000 是堆栈，依此类推。其中一些页面是符号的，这意味着它们至少会包含一些数据，当访问这些数据时，Unicorn 的执行会终止
 
 ```
 INFO    | 2017-02-25 08:19:48,037 | angr.state_plugins.unicorn | finished emulation at 0x7000080 after 3 steps: STOP_STOPPOINT
 ```
 
-Execution stays in Unicorn for 3 basic blocks (a computational waste, considering the required setup), after which it reaches a simprocedure location and jumps out to execute the simproc in angr.
+在 Unicorn 中执行三个基本块后，执行停留在 Unicorn 中，然后到达simproceduce 的位置并跳出在 angr 中执行 simproc
 
 ```
 INFO    | 2017-02-25 08:19:48,076 | angr.state_plugins.unicorn | started emulation at 0x40175d (1000000 steps)
@@ -189,19 +182,18 @@ INFO    | 2017-02-25 08:19:48,079 | angr.state_plugins.unicorn | mmap [0x7ffffff
 INFO    | 2017-02-25 08:19:48,081 | angr.state_plugins.unicorn | mmap [0x6010000, 0x601ffff], 3
 ```
 
-After the simprocedure, execution jumps back into Unicorn.
+simprocedure 后，执行跳回到 Unicorn
 
 ```
 WARNING | 2017-02-25 08:19:48,082 | angr.state_plugins.unicorn | fetching empty page [0x0, 0xfff]
 INFO    | 2017-02-25 08:19:48,103 | angr.state_plugins.unicorn | finished emulation at 0x401777 after 1 steps: STOP_EXECNONE
 ```
 
-Execution bounces out of Unicorn almost right away because the binary accessed the zero-page.
+因为二进制文件访问了零页，所以几乎立即就从 Unicorn 中弹出了
 
 ```
 INFO    | 2017-02-25 08:19:48,120 | angr.engines.unicorn_engine | not enough runs since last unicorn (100)
 INFO    | 2017-02-25 08:19:48,125 | angr.engines.unicorn_engine | not enough runs since last unicorn (99)
 ```
 
-To avoid thrashing in and out of Unicorn (which is expensive), we have cooldowns (attributes of the `state.unicorn` plugin) that wait for certain conditions to hold (i.e., no symbolic memory accesses for X blocks) before jumping back into unicorn when a unicorn run is aborted due to anything but a simprocedure or syscall.
-Here, the condition it's waiting for is for 100 blocks to be executed before jumping back in.
+为了避免在 Unicorn 内外出现反复，在 Unicorn 运行时，我们可以设置一些等待条件的冷却时间（作为插件 `state.unicorn` 的属性）。然后跳回 Unicorn 而不是 simprocedure 或系统调用而被中止。在这里，等待的条件是在返回之前执行一百个块
diff --git a/docs/simprocedures.md b/docs/simprocedures.md
index 5c8b5d8..07d08db 100644
--- a/docs/simprocedures.md
+++ b/docs/simprocedures.md
@@ -1,14 +1,11 @@
-Hooks and SimProcedures in Detail
+详解钩子和SimProcedures
 =================================
 
-Hooks in angr are very powerful!
-You can use them to modify a program's behavior in any way you could imagine.
-However, the exact way you might want to program a specific hook may be non-obvious.
-This chapter should serve as a guide when programming SimProcedures.
+钩子在 `angr` 中非常强大！你可以使用它们以任何你想要的方式修改程序的行为。然而，你想编写一个特定钩子的方法可能并不明显。这章将会在 `SimProcedures` 编程时给予指导。
 
-## Quick Start
+## 快速开始
 
-Here's an example that will remove all bugs from any program:
+这里有一个示例，它将删除任何程序中的所有 `bug` :
 
 ```python
 >>> from angr import Project, SimProcedure
@@ -29,110 +26,74 @@ Program running with argc=<SAO <BV64 0x0>> and argv=<SAO <BV64 0x7fffffffffeffa0
 <SimulationManager with 1 deadended>
 ```
 
-Now, whenever program execution reaches the main function, instead of executing the actual main function, it will execute this procedure!
-This procedure just prints out a message, and returns.
+现在，当程序执行到达主函数，而不是执行实际的主函数时，它将执行这个程序!这个程序只是打印出一条消息，然后返回。我们来讨论下函数发生了什么，当进入函数的时候，当进入函数时，函数的参数从哪里来？
+您可以定义你自己的 `run()` 函数不管您的函数的参数有多少，`SimProcedure` 运行时都会自动从程序中提取这些参数，
+通过[调用约定](structured_data.md#working-with-calling-conventions), 并且调用您的运行函数。类似的，当你从运行函数返回一个值，它被放置到相关状态（也是根据调用约定），并且执行从函数返回的实际控制流动作，根据体系结构可能涉及到链接寄存器或者跳转到堆栈弹出的结果。
 
-Now, let's talk about what happens on the edge of this function!
-When entering the function, where do the values that go into the arguments come from?
-You can define your `run()` function with however many arguments you like, and the SimProcedure runtime will automatically extract from the program state those arguments for you, via a [calling convention](structured_data.md#working-with-calling-conventions), and call your run function with them. Similarly, when you return a value from the run function, it is placed into the state (again, according to the calling convention), and the actual control-flow action of returning from a function is performed, which depending on the architecture may involve jumping to the link register or jumping to the result of a stack pop.
+应该清楚的是，我们刚才所写的 `SimProcedure` 应该完全替换它所挂钩的函数。
+事实上，`SimProcedures` 最初是用来取代库函数。
+稍后将进行更详细的讨论。
 
-It should be clear at this point that the SimProcedure we just wrote is meant to totally replace whatever function it is hooked over top of.
-In fact, the original use case for SimProcedures was replacing library functions.
-More on that later.
+## 明确的层次结构
 
-## Clarifying the Hierarchy
+我们使用了Hook和SimProcedure这两个词。现在让我们来看下区别
+- `SimProcedure` 是一个类，它描述了对一个状态进行的一系列操作。其关键是 `run()` 的方法。
+- `Hook`是一个 `angr` 类，它包含了 `SimProcedure` 和关于如何实例化它的信息。
 
-We've been using the words Hook and SimProcedure sort of interchangeably. Let's fix that.
+在 `Project` 类中，`project._sim_procedures`是一个从地址到 `Hook` 实例的映射。(这个名字是一个历史产物——`SimProcedure` 是 `angr` 中最古老的类之一，而 `Hook` 则相对较新的。)
+当[执行管道](pipeline.md)到达该字典中存在的地址，即被挂钩的地址时，它将执行`procedure = project._sim_procedures[address].instantiate(address, arch)`。
+这个调用的结果是一个 `SimProcedure` 实例！
+我建议你看看[angr/project.py](https://github.com/angr/angr/blob/master/angr/project.py)底层的Hook类的源代码，以便明白这是如何工作的。
 
-- `SimProcedure` is a class that describes a set of actions to take on a state.
-  Its crux is the `run()` method.
-- `Hook` is an angr class that holds a SimProcedure along with information about how to instantiate it.
-
-On a `Project` class, the dict `project._sim_procedures` is a mapping from address to `Hook` instances.
-(The name is a historical artifact - SimProcedure is one of the oldest classes in the angr, suite, while Hook is relatively new.)
-When the [execution pipeline](pipeline.md) reaches an address that is present in that dict, that is, an address that is hooked, it will execute `procedure = project._sim_procedures[address].instantiate(address, arch)`.
-The result of this call is a `SimProcedure` instance!
-I recommend you look at the source code for the Hook class, at the bottom of [angr/project.py](https://github.com/angr/angr/blob/master/angr/project.py) in order to see exactly how this works.
-
-It is important to produce a new instance of the SimProcedure for each time it is run, since the process of running a SimProcedure necessarily involves mutating state on the SimProcedure instance, so we need separate ones for each step, lest we run into race conditions in multithreaded environments.
+每次运行 `SimProcedure` 时都要生成一个新的 `SimProcedure` 实例，这一点很重要，因为运行 `SimProcedure`的过程必然涉及 `SimProcedure` 实例的变异状态，所以我们需要为每一步分别设置一个，以免我们遇到竞争条件 多线程环境。
 
 ### kwargs
 
-This hierarchy implies that you might want to reuse a single SimProcedure in multiple hooks.
-What if you want to use the same SimProcedure in several hooks, but tweaked slightly each time?
-angr's support for this is that any additional keyword arguments you pass to the `Hook()` initializer will end up getting passed as keyword args to your SimProcedure's `run()` method.
-Pretty cool!
-
-## Data Types
-
-If you were paying attention to the example earlier, you noticed that when we printed out the arguments to the `run()` function, they came out as a weird `<SAO <BV64 0xSTUFF>>` class.
-This is a `SimActionObject`.
-Basically, you don't need to worry about it too much, it's just a thin wrapper over a normal bitvector.
-It does a bit of tracking of what exactly you do with it inside the SimProcedure---this is helpful for static analysis.
-
-You may also have noticed that we directly returned the python int `0` from the procedure.
-This will automatically be promoted to a word-sized bitvector!
-You can return a native number, a bitvector, or a SimActionObject.
-
-When you want to write a procedure that deals with floating point numbers, you will need to specify the calling convention manually.
-It's not too hard, just provide a cc to the hook: [`cc = project.factory.cc_from_arg_kinds((True, True), ret_fp=True)`](http://angr.io/api-doc/angr.html#angr.factory.AngrObjectFactory.cc_from_arg_kinds) and `project.hook(Hook(ProcedureClass, cc=mycc))`
-This method for passing in a calling convention works for all calling conventions, so if angr's autodetected one isn't right, you can fix that.
+这个层次意味着您可能想要在多个钩子中重用单个SimProcedure。如果你想在几个钩子上使用相同的SimProcedure，但每次都稍微调整一下，该怎么办呢? `angr` 支持将你传递给 `Hook()`初始值设定项的任何附加关键字参数都会作为关键字参数传递给你的 `SimProcedure` 的 `run()`方法。
 
-## Control Flow
+## 数据类型
 
-How can you exit a SimProcedure?
-We've already gone over the simplest way to do this, returning a value from `run()`.
-This is actually shorthand for calling `self.ret(value)`.
-`self.ret()` is the function which knows how to perform the specific action of returning from a function.
+如果你注意到之前的例子，你注意到当我们将 `run()` 函数的参数打印出来时，它们出现了一个奇怪的 `<SAO <BV64 0xSTUFF>>` 类。这是一个`SimActionObject`。基本上，你不需要担心它太多，它只是一个普通的位向量的包装。它可以跟踪你在 `SimProcedure` 中处理的内容——这有助于静态分析。你也可能注意到我们直接从程序中返回了 `python int 0`。这将自动提升为一个字大小的位向量！您可以返回一个本地数字，一个位图矢量或一个 `SimActionObject`。
+当你想编写一个处理浮点数的程序时，你需要手动指定调用约定。这并不难，只需要为 `hook` 提供一个 `cc`:[`cc = project.factory.cc_from_arg_kinds((True, True), ret_fp=True)`](http://angr.io/api-doc/angr.html#angr.factory.AngrObjectFactory.cc_from_arg_kinds) , `project.hook(Hook(ProcedureClass, cc=mycc))`
+这种传入调用约定的方法适用于所有的调用约定，所以如果 `angr` 的自动检测方法不正确，那么可以用它解决这个问题。
 
-SimProcedures can use lots of different functions like this!
+## 控制流
 
-- `ret(expr)`: Return from a function
-- `jump(addr)`: Jump to an address in the binary
-- `exit(code)`: Terminate the program
-- `call(addr, args, continue_at)`: Call a function in the binary
-- `inline_call(procedure, *args)`: Call another SimProcedure in-line and return the results
+如何退出 `SimProcedure`？ 我们已经完成了最简单的方法，从 `run()` 返回一个值。这实际上是调用 `self.ret(value)` 的简写。`self.ret` 是知道如何执行从函数返回的特定动作的函数。
+SimProcedures可以使用很多像这样的不同的函数！
 
-That second-last one deserves some looking-at.
-We'll get there after a quick detour...
+- `ret(expr)`: 从函数返回
+- `jump(addr)`: J跳到指定地址
+- `exit(code)`: 终结程序
+- `call(addr, args, continue_at)`: 调用一个函数
+- `inline_call(procedure, *args)`: 调用另一个 `SimProcedure` 并返回结果
 
-### Conditional Exits
+倒数第二个值得一看。
 
-What if we want to add a conditional branch out of a SimProcedure?
-In order to do that, you'll need to work directly with the SimSuccessors object for the current execution step.
+### 条件退出
 
-The interface for this is [`self.successors.add_successor(state, addr, guard, jumpkind)`](http://angr.io/api-doc/angr.html#angr.engines.successors.SimSuccessors.add_successor).
-All of these parameters should have an obvious meaning if you've followed along so far.
-Keep in mind that the state you pass in will NOT be copied, so be sure to make a copy if you want to use it again!
+如果我们想为 `SimProcedure` 添加一个条件分支呢？为了做到这一点，您需要直接使用 `SimSuccessors` 对象来执行当前的执行步骤。
+这个接口是[`self.successors.add_successor(state, addr, guard, jumpkind)`](http://angr.io/api-doc/angr.html#angr.engines.successors.SimSuccessors.add_successor).
+所有这些参数都应该有一个明显的含义，如果你一直遵循的话。请记住，您传入的 `state` 将不会被复制，所以如果您想再次使用它，请务必复制它!
 
-### SimProcedure Continuations
+### SimProcedure Continuation
 
-How can we call a function in the binary and have execution resume within our SimProcedure?
-There is a whole bunch of infrastructure called the "SimProcedure Continuation" that will let you do this.
-When you use `self.call(addr, args, continue_at)`, `addr` is expected to be the address you'd like to call, `args` are the arguments you'd like to call it with, and `continue_at` is the name of another method in your SimProcedure class that you'd like execution to continue at when it returns.
-This method must have the same signature as the `run()` method.
-Furthermore, you can pass the keyword argument `cc` as the calling convention that ought to be used to communicate with the callee.
+我们怎样才能调用一个二进制文件中的函数，并在我们的 `SimProcedure` 恢复执行？有一系列的被称作 `SimProcedure Continuation` 的基础设施可以满足你的要求。当你使用 `self.call(addr, args, continue_at)` 时，`addr` 应该是你想要调用的地址， `continue_at` 是 `SimProcedure` 类中另一个方法的名称，您希望在它返回时继续执行它。该方法必须具有与 `run()` 方法相同的签名。此外，您可以将关键字参数 `cc` 作为调用约定，该约定应该用于与 `callee` 通信。
+当你这样做的时候，你完成了你现在的步骤，然后在你指定的函数的下一步重新开始执行。当这个函数返回时，它必须返回一些具体的地址！
+该地址由 `SimProcedure` 运行时指定。
 
-When you do this, you finish your current step, and execution will start again at the next step at the function you've specified.
-When that function returns, it has to return to some concrete address!
-That address is specified by the SimProcedure runtime.
-Each SimProcedure which would like to use the continuation subsystem is allocated a "continuation address", the address which is specified as the return address for any calls that are made out of that procedure.
-When control flow hits that address again, the SimProcedure is started back up again, and the specified `continue_at` function is called instead of `run()`, with the same args and kwargs as the first time.
+每个希望使用 `continuation` 子系统的 `SimProcedure` 都被分配一个 `"continuation 地址"`，这个地址被指定为该过程中所有调用的返回地址。当控制流再次到达这个地址时，`SimProcedure` 再次启动，指定的`continue_at`函数被调用，而不是 `run()`，与第一次使用相同的args和kwargs。
 
-There are two pieces of metadata you need to attach to your SimProcedure class in order to use the continuation subsystem correctly:
+为了正确地使用 `continuation` 子系统，您需要将两个元数据附加到 `SimProcedure` 类中:
 
-- Set the class variable `IS_FUNCTION = True`
-- Set the class variable `local_vars` to a tuple of strings, where each string is the name of an instance variable on your SimProcedure whose value you would like to persist to when you return.
-  Local variables can be any type so long as you don't mutate their instances.
+- 设置类变量 `IS_FUNCTION = True`
+- 设置类变量 `local_vars` 为元组字符串, 其中每个字符串都是您 `SimProcedure` 上的实例变量的名称，您希望在返回时保留其值。
+   局部变量可以是任何类型，只要你不改变他们的实例。
 
-You may have guessed by now that there exists some sort of auxiliary storage in order to hold on to all this data.
-You would be right!
-The state plugin `state.procedure_data` exists to hold all the data that SimProcedures need to store in order to go about their business that must persist between runs.
-It's stuff that ought to be stored in memory, but the data can't be serialized and/or memory allocation is hard.
-In this case, `state.procedure_data.callstack` is a list of "call frames".
-Whenever we jump to a continuation address and try to resume a SimProcedure, we pop a frame off this "call stack" and use its data to re-initialize the SimProcedure instance we're now working with.
+您可能已经猜到，为了保存所有这些数据，存在某种辅助存储。你是正确的! `state` 插件 `state.procedure_data`  是为了保存所有的数据，以便在运行过程中继续执行。这应该是存储在内存的东西，但数据不能被序列化，内存分配很难。在这种情况下，`state.procedure_data.callstack` 是一个 `"call frames"` 的列表。
 
-As an example, let's look at the SimProcedure that angr uses internally to run all the shared library initializers for a `full_init_state`:
+每当我们跳到一个 `continuation` 地址并尝试恢复一个 `SimProcedure` 时，我们从这个 `"call stack" `中弹出一帧，并使用它的数据重新初始化我们正在使用的 `SimProcedure` 实例。
+例如，让我们看一下 `angr` 在内部使用的 `SimProcedure` 运行所有共享库初始化器，以实现 `"full_init_state"`:
 
 ```python
 class LinuxLoader(SimProcedure):
@@ -155,40 +116,29 @@ class LinuxLoader(SimProcedure):
             self.call(addr, (self.state.posix.argc, self.state.posix.argv, self.state.posix.environ), 'run_initializer')
 ```
 
-This is a particularly clever usage of the SimProcedure continuations.
-First, notice that the current project is passed in as a keyword arg, so we have access to internal loader logic.
-We start by getting a list of initializers.
-Then, for as long as the list isn't empty, we pop a single function pointer out of the list (being careful not to mutate the list), and then call it, returning to the `run_initializer` function again.
-When we run out of initializers, we set up the entry state and jump to the program entry point.
+这是 `SimProcedure continuations` 特别聪明的一个用法。首先，注意当前的项目是作为关键字 `arg` 传入的，所以我们可以访问内部的加载器逻辑。我们从获取初始化程序的列表开始。然后，只要列表不是空的，我们从列表中弹出一个单独的函数指针（注意不要改变列表），然后调用它，再次返回`run_initializer`函数。当初始化器用完时，我们设置入口状态并跳转到程序入口点。
 
-Very cool!
+## 全局变量
 
-## Global Variables
+简而言之，您可以将全局变量存储在`state.procedure_data.global_variables`中。这是一个从 `state` 到后继 `state` 的浅拷贝的字典。
+因为它只是一个浅拷贝，它的成员是相同的实例，所以在 `SimProcedure continuations` 中使用本地变量的规则同样适用。您需要注意，不要对用作全局变量的任何项进行突变。
 
-As a brief aside, you can store global variables in `state.procedure_data.global_variables`.
-This is a dictionary that just gets shallow-copied from state to successor state.
-Because it's only a shallow copy, its members are the same instances, so the same rules as local variables in SimProcedure continuations apply.
-You need to be careful not to mutate any item that is used as a global variable.
+## 帮助静态分析
 
-## Helping out static analysis
+我们已经研究了类变量 `IS_FUNCTION`，它允许您使用 `SimProcedure continuation`。
+您可以设置更多的类变量，尽管这些变量对您没有直接的好处——它们仅仅标记了您的函数的属性，以便静态分析知道它在做什么。
 
-We've already looked at the class variable `IS_FUNCTION`, which allows you to use the SimProcedure continuation.
-There are a few more class variables you can set, though these ones have no direct benefit to you - they merely mark attributes of your function so that static analysis knows what it's doing.
+- `NO_RET`: 如果控制流将无法从这个函数返回，请将其设置为true
+- `ADDS_EXITS`: 如果你做了任何控制流而不是返回，那么将这个设置为true
+- `IS_SYSCALL`: 不需加以说明的
 
-- `NO_RET`: Set this to true if control flow will never return from this function
-- `ADDS_EXITS`: Set this to true if you do any control flow other than returning
-- `IS_SYSCALL`: Self-explanatory
+此外，如果设置 `ADDS_EXITS`，您可能还需要定义方法的 `static_exits()`。这个函数接受一个参数，一个 `IRSB` 列表，这个列表在你的函数运行的时候会被执行，并且要求你返回你知道在这种情况下你所知道的所有出口的列表。返回值预期为一个元组的列表 `(address (int), jumpkind (str))`。这是一个快速的，最好的分析，你不应该尝试做任何疯狂的或密集的事情来得到你的答案。
 
-Furthermore, if you set `ADDS_EXITS`, you may also want to define the method `static_exits()`.
-This function takes a single parameter, a list of IRSBs that would be executed in the run-up to your function, and asks you to return a list of all the exits that you know would be produced by your function in that case.
-The return value is expected to be a list of tuples of (address (int), jumpkind (str)).
-This is meant to be a quick, best-effort analysis, and you shouldn't try to do anything crazy or intensive to get your answer.
+## 使用钩子
 
-## User Hooks
+编写和使用 `SimProcedure` 的过程会做出很多假设，这些假设都是您想要在整个函数中进行的。你不打算这样做?
+有一个接口用于挂钩，一个用户钩子，它可以让你简化代码的挂钩过程。
 
-The process of writing and using a SimProcedure makes a lot of assumptions that you want to hook over a whole function.
-What if you don't?
-There's an alternate interface for hooking, a user hook, that lets you streamline the process of hooking sections of code.
 
 ```python
 >>> @project.hook(0x1234, length=5)
@@ -197,44 +147,23 @@ There's an alternate interface for hooking, a user hook, that lets you streamlin
 
 ```
 
-This is a lot simpler!
-The idea is to use a single function instead of an entire SimProcedure subclass.
-No extraction of arguments is performed, no complex control flow happens.
-
-Control flow is controlled by the length argument to `Hook.wrap`.
-After the function finishes executing, the next step will start at 5 bytes after the hooked address.
-If the length argument is omitted or set to zero, execution will resume executing the binary code at exactly the hooked address, without re-triggering the hook. The `Ijk_NoHook` jumpkind allows this to happen.
-
-If you want more control over control flow coming out of a user hook, you can return a list of successor states.
-Each successor will be expected to have `state.ip`, state.scratch.guard`, and `state.scratch.jumpkind` set.
-
-The general rule is, if you want your SimProcedure to either be able to extract function arguments or cause a program return, use a SimProcedure.
-Otherwise, use a user hook.
-
-## Hooking Symbols
-
-First, some background.
+这很简单！这个想法是使用一个单一的函数，而不是整个SimProcedure子类。
+没有提取参数，没有复杂的控制流程发生。
 
-In binary loading, there is the notion of a symbol - a range of memory in the address space which has a name.
-For dynamically linked binaries, there is the notion of an *import symbol*, which is a symbol which has no address, just a name.
-These symbols are used to mark dependencies among binaries and shared objects, usually for functions.
-During the loading process, each import symbol is supposed to be *provided* by a different binary, one that *exports* a symbol of the same name.
-The process of matching import symbols to export symbols is called *dependency resolution*.
+控制流由 `"Hook.wrap"` 的长度参数控制。函数完成执行后，下一个步骤将在挂钩地址之后的5个字节开始。如果长度参数被省略或设置为零，那么执行将恢复执行二进制代码，而不需要重新触发钩子。`"Ijk_NoHook"` 的 `"jumpkind"` 允许这种情况发生。如果您想更好地控制来自用户钩子的控制流，你可以返回后继 `state` 列表。每个后继者都应该有 `state.ip`，`state.scratch.guard` 和 `state.scratch.jumpkind` 集合。一般规则是，如果您希望 `SimProcedure` 能够提取函数参数或导致程序返回，请使用 `SimProcedure`。否则，使用用户挂钩。
 
-When a symbol has been resolved, pointers to the provider's symbol need to be injected into the providee's address space.
-This is a process known as *relocation*.
-A dynamically linked binary contains a table of *relocations*, individual directives stating that, as soon as you resolve import symbol X, please update the code or data at address Y to refer to the corresponding export symbol.
-There are many types of relocations, and so this process is complicated!
+## 挂钩符号
 
-When angr loads a program and it gets the `Loader` object from CLE, it wants to do two things:
-Make sure every imported function gets resolved to _something_, and replace as many imported functions with SimProcedures as possible.
-To do this, CLE exports an interface called `provide_symbol`, which allows angr to advertise its own export symbols and cause the relocation process to point whererver we want for certain symbols.
+首先是一些背景。在二进制加载中，有符号的概念 - 地址空间中有一个符号名称的内存范围。
+对于动态链接的二进制文件，有一个*导入符号*的概念，这是一个没有地址的符号，只是一个名字。
+这些符号用于标记二进制文件和共享对象之间的依赖关系，通常用于函数。在加载过程中，每个导入符号应该由一个不同的二进制*提供*，这个二进制文件的*导出*符号与其同名。
+将导入符号与导出符号进行匹配的过程称为* dependency resolution *。将导入符号与导出符号匹配的过程称为 *依赖解析*。当一个符号被解析时，指向提供者符号的指针需要被注入到被提供者的地址空间中。这是一个称为*重定位*的过程。动态链接的二进制文件包含一个*重定位*表，个别指令说明，只要您解析导入符号X，请更新地址Y的代码或数据以引用相应的导出符号。重定位的种类很多，所以这个过程很复杂！
+当 `angr` 加载一个程序，它从 `CLE` 获取 `Loader` 对象时，它将做两件事情：确保每个导入的函数都被解析为 `_something_` ，并尽可能地用 `SimProcedures` 替换导入函数。为了做到这一点，CLE导出了一个名为 `"provide_symbol"` 的接口，它允许 `angr` 为自己的导出符号做广告，并使迁移过程指向我们想要的特定符号的位置。
 
-This happens on the angr level with the method `Project.hook_symbol`.
-You can use this function to allocate a fresh address, hook that address with whatever you want, and re-point any import symbol of a given name to your hook!
+这发生在 `angr` 级别上，使用方法 `"Project.hook_symbol"`。你可以使用这个函数来分配一个新的地址，用你想要的任何东西来挂钩这个地址，并将一个给定名称的任何导入符号重新指向你的钩子!
 
-This means that you can replace library functions with your own code.
-For instance, to replace `rand()` with a function that always returns a consistent sequence of values:
+这意味着您可以用自己的代码替换库函数。
+例如，替换 `"rand()"` 函数为带有一个总是返回一致的值序列的函数:
 
 ```python
 >>> class NotVeryRand(SimProcedure):
@@ -250,5 +179,5 @@ For instance, to replace `rand()` with a function that always returns a consiste
 
 >>> project.hook_symbol('rand', NotVeryRand(return_values=[413, 612, 1025, 1111]))
 ```
+现在，每当程序试图调用 `rand()`，它将循环从`"return_values"` 数组中返回整数。
 
-Now, whenever the program tries to call `rand()`, it'll return the integers from the `return_values` array in a loop.
diff --git a/docs/simulation.md b/docs/simulation.md
index 95d1468..aaf0e20 100644
--- a/docs/simulation.md
+++ b/docs/simulation.md
@@ -1,37 +1,34 @@
-# Simulation  and Instrumentation
+# 仿真与插桩
 
-When you ask for a step of execution to happen in angr, something has to actually perform the step.
-angr uses a series of engines (subclasses of the `SimEngine` class) to emulate the effects that of a given section of code has on an input state.
-The execution core of angr simply tries all the available engines in sequence, taking the first one that is able to handle the step.
-The following is the default list of engines, in order:
+当你想让 angr 继续向下执行一步时，其实要有几个过程。
+angr 使用一系列引擎（`SimEngine` 类的子类）来模拟给定代码段对输入状态的影响。
+angr 的执行核心会依次简单尝试所有可用引擎，然后选择使用第一个能处理该步的引擎。以下是默认的引擎列表，依次为：
 
-- The failure engine kicks in when the previous step took us to some uncontinuable state
-- The syscall engine kicks in when the previous step ended in a syscall
-- The hook engine kicks in when the current address is hooked
-- The unicorn engine kicks in when the `UNICORN` state option is enabled and there is no symbolic data in the state
-- The VEX engine kicks in as the final fallback.
+- 上一步转移到某种不可连续的状态时，失败引擎将会启动
+- 上一步结束于系统调用时启动系统调用引擎
+- 当前地址被 Hook，启动 Hook 引擎
+- 当 `UNICORN` 状态选项启用且 state 中没有符号数据时，unicorn 引擎启动
+- VEX 引擎作为最后的保底
 
 ## SimSuccessors
 
-The code that actually tries all the engines in turn is `project.factory.successors(state, **kwargs)`, which passes its arguments onto each of the engines.
-This function is at the heart of `state.step()` and `simulation_manager.step()`.
-It returns a SimSuccessors object, which we discussed briefly before.
-The purpose of SimSuccessors is to perform a simple categorization of the successor states, stored in various list attributes.
-They are:
+依次尝试将参数送给每个引擎的代码是 `project.factory.successors(state, **kwargs)`。
+这个函数是 `state.step()` 和 `simulation_manager.step()` 的核心。
+它返回一个 SimSuccessors 对象，SimSuccessors 对象的目的是对存储在各种列表属性中的后继状态进行简单的分类，它们是：
 
-| Attribute | Guard Condition | Instruction Pointer | Description |
+| 属性 | Guard 条件 | 指令指针 | 描述 |
 |-----------|-----------------|---------------------|-------------|
-| `successors` | True (can be symbolic, but constrained to True) | Can be symbolic (but 256 solutions or less; see `unconstrained_successors`). | A normal, satisfiable successor state to the state processed by the engine. The instruction pointer of this state may be symbolic (i.e., a computed jump based on user input), so the state might actually represent *several* potential continuations of execution going forward. |
-| `unsat_successors` | False (can be symbolic, but constrained to False). | Can be symbolic. | Unsatisfiable successors. These are successors whose guard conditions can only be false (i.e., jumps that cannot be taken, or the default branch of jumps that *must* be taken). |
-| `flat_successors` | True (can be symbolic, but constrained to True). | Concrete value. | As noted above, states in the `successors` list can have symbolic instruction pointers. This is rather confusing, as elsewhere in the code (i.e., in `SimEngineVEX.process`, when it's time to step that state forward), we make assumptions that a single program state only represents the execution of a single spot in the code. To alleviate this, when we encounter states in `successors` with symbolic instruction pointers, we compute all possible concrete solutions (up to an arbitrary threshold of 256) for them, and make a copy of the state for each such solution. We call this process "flattening". These `flat_successors` are states, each of which has a different, concrete instruction pointer. For example, if the instruction pointer of a state in `successors` was `X+5`, where `X` had constraints of `X > 0x800000` and `X < 0x800010`, we would flatten it into 16 different `flat_successors` states, one with an instruction pointer of `0x800006`, one with `0x800007`, and so on until `0x800015`. |
-| `unconstrained_successors` | True (can be symbolic, but constrained to True). | Symbolic (with more than 256 solutions). | During the flattening procedure described above, if it turns out that there are more than 256 possible solutions for the instruction pointer, we assume that the instruction pointer has been overwritten with unconstrained data (i.e., a stack overflow with user data). *This assumption is not sound in general*. Such states are placed in `unconstrained_successors` and not in `successors`. |
-| `all_successors` | Anything | Can be symbolic. | This is `successors + unsat_successors + unconstrained_successors`. |
+| `successors` | True (可以是符号，但必须为真) | 可以是符号（但不超过256 个解决方案，详见 `unconstrained_successors`） | 正常、可满足的后继。该 state 的指令指针也许是符号（例如，基于用户输入的计算跳转），所以该 state 代表了一系列潜在的继续执行步 |
+| `unsat_successors` | False (可以是符号，但必须为假) | 可以是符号 | 不满足的后继。这些后继的条件只能是 false。（例如：jump 不能执行，或者 jump 的默认分支必须执行） |
+| `flat_successors` | True (可以是符号，但必须为真). | 具体值 | 如上所述，`successors` 列表中的 state 可以有符号指令指针。这和代码的其他地方一样（在 `SimEngineVEX.process` 处），是很混乱的。我们假定单个程序状态只代表代码中的单点执行。为了缓解这种情况，我们会为它们计算全部可能的解决方案（达到 256 个任意值），并为每个解决方案创建 state 的副本，我们把这个过程叫做扁平化。这些 `flat_successors` 都是 state，每个 state 都有不同的、具体的指令指针。例如，如果 `successors` 中 state 的指令指针是 `X+5`，其中 `X` 的约束为 `X > 0x800000` 且 `X < 0x800010`。我们会将其变为 16 个不同 `flat_successors` 的 state，指令指针从 `0x800006` 一直到 `0x800015` |
+| `unconstrained_successors` | True (可以是符号，但必须为真) | 符号（但不超过 256 个解决方案) | 在上述扁平化的过程中，如果发现指令指针有超过 256 个解决方案，我们假设指令指针已经被无约束数据覆盖（即用户数据堆栈溢出）。一般来说，这个假设并不健全。这些 states 被放置在 `unconstrained_successors` 而不是 `successors` |
+| `all_successors` | Anything | 可以是符号 | 这是 `successors + unsat_successors + unconstrained_successors` |
 
-## Breakpoints
+## 断点
 
-TODO: rewrite this to fix the narrative
+TODO: 重写这部分来修正描述
 
-Like any decent execution engine, angr supports breakpoints. This is pretty cool! A point is set as follows:
+和任何强大的执行引擎一样，angr 也支持断点。摘录一些重点如下：
 
 ```python
 >>> import angr
@@ -54,67 +51,67 @@ Like any decent execution engine, angr supports breakpoints. This is pretty cool
 >>> s.inspect.b('mem_write', when=angr.BP_AFTER, action='IPython')
 ```
 
-There are many other places to break than a memory write. Here is the list. You can break at BP_BEFORE or BP_AFTER for each of these events.
+除了内存写入还支持其他功能，以下是列表，可以在每个事件的 BP_BEFORE 或者 BP_AFTER 上中断
 
-| Event type        | Event meaning |
+| 事件类型        | 事件含义 |
 |-------------------|------------------------------------------|
-| mem_read          | Memory is being read. |
-| mem_write         | Memory is being written. |
-| reg_read          | A register is being read. |
-| reg_write         | A register is being written. |
-| tmp_read          | A temp is being read. |
-| tmp_write         | A temp is being written. |
-| expr              | An expression is being created (i.e., a result of an arithmetic operation or a constant in the IR). |
-| statement         | An IR statement is being translated. |
-| instruction       | A new (native) instruction is being translated. |
-| irsb              | A new basic block is being translated. |
-| constraints       | New constraints are being added to the state. |
-| exit              | A successor is being generated from execution. |
-| symbolic_variable | A new symbolic variable is being created. |
-| call              | A call instruction is hit. |
-| address_concretization | A symbolic memory access is being resolved. |
-
-These events expose different attributes:
-
-| Event type        | Attribute name     | Attribute availability | Attribute meaning                        |
+| mem_read          | 读内存 |
+| mem_write         | 写内存 |
+| reg_read          | 读寄存器 |
+| reg_write         | 写寄存器 |
+| tmp_read          | 临时读 |
+| tmp_write         | 临时写 |
+| expr              | 创建表达式（IR 中的算术运算或常数结果） |
+| statement         | 翻译 IR 表达式 |
+| instruction       | 翻译新（原生）指令 |
+| irsb              | 翻译新基本块 |
+| constraints       | 为 state 添加新约束 |
+| exit              | 执行产生后继 |
+| symbolic_variable | 创建新符号变量 |
+| call              | 命中 call 指令 |
+| address_concretization | 符号内存访问求解 |
+
+这些事件都有不同的属性：
+
+| 事件类型 | 属性名称 | 属性可用性 | 属性含义 |
 |-------------------|--------------------|------------------------|------------------------------------------|
-| mem_read          | mem_read_address   | BP_BEFORE or BP_AFTER  | The address at which memory is being read. |
-| mem_read          | mem_read_length    | BP_BEFORE or BP_AFTER  | The length of the memory read. |
-| mem_read          | mem_read_expr      | BP_AFTER               | The expression at that address. |
-| mem_write         | mem_write_address  | BP_BEFORE or BP_AFTER  | The address at which memory is being written. |
-| mem_write         | mem_write_length   | BP_BEFORE or BP_AFTER  | The length of the memory write. |
-| mem_write         | mem_write_expr     | BP_BEFORE or BP_AFTER  | The expression that is being written. |
-| reg_read          | reg_read_offset    | BP_BEFORE or BP_AFTER  | The offset of the register being read. |
-| reg_read          | reg_read_length    | BP_BEFORE or BP_AFTER  | The length of the register read. |
-| reg_read          | reg_read_expr      | BP_AFTER               | The expression in the register. |
-| reg_write         | reg_write_offset   | BP_BEFORE or BP_AFTER  | The offset of the register being written. |
-| reg_write         | reg_write_length   | BP_BEFORE or BP_AFTER  | The length of the register write. |
-| reg_write         | reg_write_expr     | BP_BEFORE or BP_AFTER  | The expression that is being written. |
-| tmp_read          | tmp_read_num       | BP_BEFORE or BP_AFTER  | The number of the temp being read. |
-| tmp_read          | tmp_read_expr      | BP_AFTER               | The expression of the temp. |
-| tmp_write         | tmp_write_num      | BP_BEFORE or BP_AFTER  | The number of the temp written. |
-| tmp_write         | tmp_write_expr     | BP_AFTER               | The expression written to the temp. |
-| expr              | expr               | BP_AFTER               | The value of the expression. |
-| statement         | statement          | BP_BEFORE or BP_AFTER  | The index of the IR statement (in the IR basic block). |
-| instruction       | instruction        | BP_BEFORE or BP_AFTER  | The address of the native instruction. |
-| irsb              | address            | BP_BEFORE or BP_AFTER  | The address of the basic block. |
-| constraints       | added_constraints   | BP_BEFORE or BP_AFTER  | The list of constraint expressions being added. |
-| call              | function_address      | BP_BEFORE or BP_AFTER  | The name of the function being called. |
-| exit              | exit_target        | BP_BEFORE or BP_AFTER  | The expression representing the target of a SimExit. |
-| exit              | exit_guard         | BP_BEFORE or BP_AFTER  | The expression representing the guard of a SimExit. |
-| exit              | jumpkind           | BP_BEFORE or BP_AFTER  | The expression representing the kind of SimExit. |
-| symbolic_variable | symbolic_name      | BP_BEFORE or BP_AFTER  | The name of the symbolic variable being created. The solver engine might modify this name (by appending a unique ID and length). Check the symbolic_expr for the final symbolic expression. |
-| symbolic_variable | symbolic_size      | BP_BEFORE or BP_AFTER  | The size of the symbolic variable being created. |
-| symbolic_variable | symbolic_expr      | BP_AFTER               | The expression representing the new symbolic variable. |
-| address_concretization | address_concretization_strategy | BP_BEFORE or BP_AFTER | The SimConcretizationStrategy being used to resolve the address. This can be modified by the breakpoint handler to change the strategy that will be applied. If your breakpoint handler sets this to None, this strategy will be skipped. |
-| address_concretization | address_concretization_action | BP_BEFORE or BP_AFTER | The SimAction object being used to record the memory action. |
-| address_concretization | address_concretization_memory | BP_BEFORE or BP_AFTER | The SimMemory object on which the action was taken. |
-| address_concretization | address_concretization_expr | BP_BEFORE or BP_AFTER | The AST representing the memory index being resolved. The breakpoint handler can modify this to affect the address being resolved. |
-| address_concretization | address_concretization_add_constraints | BP_BEFORE or BP_AFTER | Whether or not constraints should/will be added for this read. |
-| address_concretization | address_concretization_result | BP_AFTER | The list of resolved memory addresses (integers). The breakpoint handler can overwrite these to effect a different resolution result. |
-
-These attributes can be accessed as members of `state.inspect` during the appropriate breakpoint callback to access the appropriate values.
-You can even modify these value to modify further uses of the values!
+| mem_read          | mem_read_address   | BP_BEFORE or BP_AFTER  | 读内存的地址 |
+| mem_read          | mem_read_length    | BP_BEFORE or BP_AFTER  | 读内存的长度 |
+| mem_read          | mem_read_expr      | BP_AFTER               | 读地址表达式 |
+| mem_write         | mem_write_address  | BP_BEFORE or BP_AFTER  | 写内存的地址 |
+| mem_write         | mem_write_length   | BP_BEFORE or BP_AFTER  | 写内存的长度 |
+| mem_write         | mem_write_expr     | BP_BEFORE or BP_AFTER  | 写地址表达式 |
+| reg_read          | reg_read_offset    | BP_BEFORE or BP_AFTER  | 读寄存器偏移 |
+| reg_read          | reg_read_length    | BP_BEFORE or BP_AFTER  | 读寄存器长度 |
+| reg_read          | reg_read_expr      | BP_AFTER               | 读寄存器表达式 |
+| reg_write         | reg_write_offset   | BP_BEFORE or BP_AFTER  | 写寄存器偏移 |
+| reg_write         | reg_write_length   | BP_BEFORE or BP_AFTER  | 写寄存器长度 |
+| reg_write         | reg_write_expr     | BP_BEFORE or BP_AFTER  | 写寄存器表达式 |
+| tmp_read          | tmp_read_num       | BP_BEFORE or BP_AFTER  | 临时读数量 |
+| tmp_read          | tmp_read_expr      | BP_AFTER               | 临时读表达式 |
+| tmp_write         | tmp_write_num      | BP_BEFORE or BP_AFTER  | 临时写数量 |
+| tmp_write         | tmp_write_expr     | BP_AFTER               | 临时写表达式 |
+| expr              | expr               | BP_AFTER               | 表达式的值 |
+| statement         | statement          | BP_BEFORE or BP_AFTER  | IR 语句的索引（在 IR 基本块中） |
+| instruction       | instruction        | BP_BEFORE or BP_AFTER  | 原生指令地址 |
+| irsb              | address            | BP_BEFORE or BP_AFTER  | 基本块地址 |
+| constraints       | added_constraints   | BP_BEFORE or BP_AFTER  | 添加的约束表达式的列表 |
+| call              | function_address      | BP_BEFORE or BP_AFTER  | 被调用的函数名 |
+| exit              | exit_target        | BP_BEFORE or BP_AFTER  | 表示 SimExit 目标的表达式 |
+| exit              | exit_guard         | BP_BEFORE or BP_AFTER  | 表示 SimExit Guard 的表达式 |
+| exit              | jumpkind           | BP_BEFORE or BP_AFTER  | 表示 SimExit 类型的表达式 |
+| symbolic_variable | symbolic_name      | BP_BEFORE or BP_AFTER  | 创建的符号变量的名字，约束求解器可能会修改这个名称（通过附加一个唯一的ID和长度）。使用 symbolic_expr 检查符号表达式 |
+| symbolic_variable | symbolic_size      | BP_BEFORE or BP_AFTER  | 创建的符号变量的尺寸 |
+| symbolic_variable | symbolic_expr      | BP_AFTER               | 新符号变量的表达式 |
+| address_concretization | address_concretization_strategy | BP_BEFORE or BP_AFTER | 使用 SimConcretizationStrategy 解析地址，可以通过断点处理程序修改，以改变将要应用的策略。如果你的断点处理程序将其设置为 None，这个策略将会被跳过 |
+| address_concretization | address_concretization_action | BP_BEFORE or BP_AFTER | 用于记录内存操作的 SimAction 对象 |
+| address_concretization | address_concretization_memory | BP_BEFORE or BP_AFTER | 操作 SimMemory 对象 |
+| address_concretization | address_concretization_expr | BP_BEFORE or BP_AFTER | 正在解析的内存索引的 AST，断点处理程序可以修改它以影响正在解析的地址 |
+| address_concretization | address_concretization_add_constraints | BP_BEFORE or BP_AFTER | 是否为读取添加约束 |
+| address_concretization | address_concretization_result | BP_AFTER | 求解内存地址的列表，断点处理程序可以覆盖这些地址产生不同的求解结果 |
+
+这些属性可以在适当的断点回调期间，用 `state.inspect` 作为成员访问。
+甚至可以修改这些值来进一步使用！
 
 ```python
 >>> def track_reads(state):
@@ -123,7 +120,7 @@ You can even modify these value to modify further uses of the values!
 >>> s.inspect.b('mem_read', when=angr.BP_AFTER, action=track_reads)
 ```
 
-Additionally, each of these properties can be used as a keyword argument to `inspect.b` to make the breakpoint conditional:
+此外，每个属性都可以用参数 `inspect.b` 来为断点增加条件：
 
 ```python
 # This will break before a memory write if 0x1000 is a possible value of its target expression
@@ -136,7 +133,8 @@ Additionally, each of these properties can be used as a keyword argument to `ins
 >>> s.inspect.b('instruction', when=angr.BP_AFTER, instruction=0x8000, mem_read_expr=0x1000)
 ```
 
-Cool stuff! In fact, we can even specify a function as a condition:
+非常酷！还可以指定一个函数作为条件：
+
 ```python
 # this is a complex condition that could do anything! In this case, it makes sure that RAX is 0x41414141 and
 # that the basic block starting at 0x8004 was executed sometime in this path's history
@@ -146,5 +144,4 @@ Cool stuff! In fact, we can even specify a function as a condition:
 >>> s.inspect.b('mem_write', condition=cond)
 ```
 
-That is some cool stuff!
-
+这些功能都很有用吧！
diff --git a/docs/solver.md b/docs/solver.md
index 5c7f7b5..f0ea54c 100644
--- a/docs/solver.md
+++ b/docs/solver.md
@@ -1,14 +1,10 @@
-# Symbolic Expressions and Constraint Solving
+# 符号表达与约束求解
 
-angr's power comes not from it being an emulator, but from being able to execute with what we call _symbolic variables_.
-Instead of saying that a variable has a _concrete_ numerical value, we can say that it holds a _symbol_, effectively just a name.
-Then, performing arithmetic operations with that variable will yield a tree of operations (termed an _abstract syntax tree_ or _AST_, from compiler theory).
-ASTs can be translated into constraints for an _SMT solver_, like z3, in order to ask questions like _"given the output of this sequence of operations, what must the input have been?"_
-Here, you'll learn how to use angr to answer this.
+`angr` 的强大并不是因为它是一个仿真器，而是能够执行我们所说的符号变量。变量拥有一个符号，而不是一个具体的值，实际上只是一个名字。在使用该变量进行算数运算时将产生一个操作树（从编译器理论可以称为抽象语法树或 `AST` ）。为了提出类似于"给定操作序列的输出，那输入必须是什么？"的问题，可以将 `AST` 转换为类似于 `z3` 的 `SMT` 求解器的约束
 
-## Working with Bitvectors
+## Bitvectors使用
 
-Let's get a dummy project and state so we can start playing with numbers.
+让我们使用样本 `project` 和 `state` 来开始数字之旅
 
 ```python
 >>> import angr, monkeyhex
@@ -16,8 +12,7 @@ Let's get a dummy project and state so we can start playing with numbers.
 >>> state = proj.factory.entry_state()
 ```
 
-A bitvector is just a sequence of bits, interpreted with the semantics of a bounded integer for arithmetic.
-Let's make a few.
+`bitvector` 只是用有界整数的语义来解释的一个比特序列，下面是一些例子
 
 ```python
 # 64-bit bitvectors with concrete values 1 and 100
@@ -34,8 +29,7 @@ Let's make a few.
 <BV27 0x9>
 ```
 
-As you can see, you can have any sequence of bits and call them a bitvector.
-You can do math with them too:
+正如您看到的，您可以拥有一个任意位的比特序列，称之为 `bitvector`。您也可以使用它们做算数运算：
 
 ```python
 >>> one + one_hundred
@@ -50,9 +44,9 @@ You can do math with them too:
 <BV64 0xffffffffffffff9c>
 ```
 
-You _cannot_ say `one + weird_nine`, though.
-It is a type error to perform an operation on bitvectors of differing lengths.
-You can, however, extend `weird_nine` so it has an appropriate number of bits:
+不过 `one + weird_nine` 是不正确的。
+不同长度的 `bitvector` 进行运算时会发生类型错误。
+但是您可以通过扩张 `weird_nine` 使其具有合适的位数:
 
 ```python
 >>> weird_nine.zero_extend(64 - 27)
@@ -61,10 +55,10 @@ You can, however, extend `weird_nine` so it has an appropriate number of bits:
 <BV64 0xa>
 ```
 
-`zero_extend` will pad the bitvector on the left with the given number of zero bits.
-You can also use `sign_extend` to pad with a duplicate of the highest bit, preserving the value of the bitvector under two's compliment signed integer semantics.
+`zero_extend` 将会在 `bitvector` 左边填充适当位数的 `0` 。
+您还可以使用 `sign_extend` 来填充， `bitvector` 符号位的值将会在左边被填充。
 
-Now, let's introduce some symbols into the mix.
+现在我们来混合介绍一些符号。
 
 ```python
 # Create a bitvector symbol named "x" of length 64 bits
@@ -76,9 +70,7 @@ Now, let's introduce some symbols into the mix.
 <BV64 y_10_64>
 ```
 
-`x` and `y` are now _symbolic variables_, which are kind of like the variables you learned to work with in 7th grade algebra.
-Notice that the name you provided has been been mangled by appending an incrementing counter and 
-You can do as much arithmetic as you want with them, but you won't get a number back, you'll get an AST instead.
+`x` 和 `y` 现在是一个_符号变量_，有点像七年级代数中学习的变量。请注意，您提供的名称因为追加了一个递增计数器而损坏，您可以根据需要对他们进行尽可能多的算数运算，但是您不会得到一个数字，而是一个 `AST`。
 
 ```python
 >>> x + one
@@ -91,12 +83,11 @@ You can do as much arithmetic as you want with them, but you won't get a number
 <BV64 x_9_64 - y_10_64>
 ```
 
-Technically `x` and `y` and even `one` are also ASTs - any bitvector is a tree of operations, even if that tree is only one layer deep.
-To understand this, let's learn how to process ASTs.
+从技术上来说 `x` 和 `y` 甚至 `one` 都是 `ASTs` - 任何 `bitvector` 都是一个操作树，即使这个操作树只有一层。
+为了理解这一点，让我们来学习下如何处理 `ASTs`。
 
-Each AST has a `.op` and a `.args`.
-The op is a string naming the operation being performed, and the args are the values the operation takes as input.
-Unless the op is `BVV` or `BVS` (or a few others...), the args are all other ASTs, the tree eventually terminating with BVVs or BVSs.
+每个 `AST` 都有一个 `.op` 和 `.args`。
+`op` 是正在执行的操作的名字的字符串表示，`args` 是执行操作时作为输入的值。除非 `op` 是 `"BVV"` 或 `"BVS"` (或者其他几个)，`args` 都是其他的 `ASTs`，操作树将会在 `BVVs` 或 `BVSs` 终止。
 
 ```python
 >>> tree = (x + 1) / (y + 2)
@@ -116,12 +107,12 @@ Unless the op is `BVV` or `BVS` (or a few others...), the args are all other AST
 (1, 64)
 ```
 
-From here on out, we will use the word "bitvector" to refer to any AST whose topmost operation produces a bitvector.
-There can be other data types represented through ASTs, including floating point numbers and, as we're about to see, booleans.
+从这里开始，我们将使用 `bitvector` 这个词来指代任何一个最顶端的操作产生一个 `bitvector` 的 `AST`。
+也可以使用 `AST` 来表示其他数据类型，包括浮点数，以及我们即将看到的布尔值。
 
-## Symbolic Constraints
+## 符号约束
 
-Performing comparison operations between any two similarly-typed ASTs will yield another AST - not a bitvector, but now a symbolic boolean.
+在任何两个类型相似的 `AST` 之间进行比较操作会产生另一个 `AST` - 而不是一个 `bitvector`,而是一个符号表达的布尔类型的值。
 
 ```python
 >>> x == 1
@@ -138,14 +129,14 @@ Performing comparison operations between any two similarly-typed ASTs will yield
 <Bool False>
 ```
 
-One tidbit you can see from this is that the comparisons are unsigned by default.
-The -5 in the last example is coerced to `<BV64 0xfffffffffffffffb>`, which is definitely not less than one hundred.
-If you want the comparison to be signed, you can say `one_hundred.SGT(-5)` (that's "signed greater-than").
-A full list of operations can be found at the end of this chapter.
+默认情况下比较是无符号的。
+在最后一个例子中 `-5` 被转换为了 `<BV64 0xfffffffffffffffb>` ,肯定不会小于 `100`。
+您如果想进行有符号之间的比较，可以通过使用 `one_hundred.SGT(-5)` 在本章末尾可以找到完整的操作列表。
 
-This snippet also illustrates an important point about working with angr - you should never directly use a comparison between variables in the condition for an if- or while-statement, since the answer might not have a concrete truth value.
-Even if there is a concrete truth value, `if one > one_hundred` will raise an exception.
-Instead, you should use `solver.is_true` and `solver.is_false`, which test for concrete truthyness/falsiness without performing a constraint solve.
+这段代码也说明了在使用 `angr` 的重要一点，您不应该直接在 `if` 或 `while` 语句的条件下进行变量的比较，因为不会得到一个确定的值。
+
+即使有一个确定的值，`if one > one_hundred` 也会引起异常。
+相反，你应该使用 `solver.is_true` 和 `solver.is_false`,可以在不执行约束求解的时候测试真假。
 
 ```python
 >>> yes = one == 1
@@ -165,13 +156,12 @@ False
 False
 ```
 
-## Constraint Solving
-
-You can use treat any symbolic boolean as an assertion about the valid values of a symbolic variable by adding it as a _constraint_ to the state.
-You can then query for a valid value of a symbolic variable by asking for an evaluation of a symbolic expression.
+## 约束求解
 
-An example will probably be more clear than an explanation here:
+您可以通过使用任何符号布尔值作为符号变量有效值的断言，并将其作为_约束_添加到对应的 `state` 。
+然后您可以通过符号表达式的求值来产生一个具体的值。
 
+一个例子可能比这里的解释更清楚：
 ```python
 >>> state.solver.add(x > y)
 >>> state.solver.add(y > 2)
@@ -180,12 +170,12 @@ An example will probably be more clear than an explanation here:
 4
 ```
 
-By adding these constraints to the state, we've forced the constraint solver to consider them as assertions that must be satisfied about any values it returns.
-If you run this code, you might get a different value for x, but that value will definitely be greater than 3 (since y must be greater than 2 and x must be greater than y) and less than 10.
-Furthermore, if you then say `state.solver.eval(y)`, you'll get a value of y which is consistent with the value of x that you got.
-If you don't add any constraints between two queries, the results will be consistent with each other.
+通过将这些约束添加到 `state` ，我们迫使约束求解器将它们视为必须满足其返回值的断言。
+如果您运行这些代码，你可能会得到一个不同于 `x` 的值，但是这个值肯定大于3（因为 `y` 必须大于 `2`，而 `x` 必须大于 `y` ）,小于 `10`。
+此外，如果你输入  `state.solver.eval(y)`，您得到的 `y` 值和 `x` 值是一致的。
+如果在两次查询之间没有添加任何约束，那么结果将是一致的。
 
-From here, it's easy to see how to do the task we proposed at the beginning of the chapter - finding the input that produced a given output.
+从这里开始，我们将看到如何完成在本章开头提到的任务 - 找到产生给定输出的输入值。
 
 ```python
 # get a fresh state without constraints
@@ -198,11 +188,11 @@ From here, it's easy to see how to do the task we proposed at the beginning of t
 0x3333333333333381
 ```
 
-Note that, again, this solution only works because of the bitvector semantics.
-If we were operating over the domain of integers, there would be no solutions!
+请注意，这个方法只适用于在 `bitvector` 语义。
+如果我们在整数域上运行，将会无解。
 
-If we add conflicting or contradictory constraints, such that there are no values that can be assigned to the variables such that the constraints are satisfied, the state becomes _unsatisfiable_, or unsat, and queries against it will raise an exception.
-You can check the satisfiability of a state with `state.satisfiable()`.
+如果我们添加冲突或矛盾的约束，使得没有可以使约束得到满足的变量的值分配， `state` 变为不满足的，查询时将会产生异常。
+您可以使用 `state.satisfiable()` 来检查一个 `state` 的可满足性。
 
 ```python
 >>> state.solver.add(input < 2**32)
@@ -210,7 +200,7 @@ You can check the satisfiability of a state with `state.satisfiable()`.
 False
 ```
 
-You can also evaluate more complex expressions, not just single variables.
+您也可以计算更复杂的表达式，而不仅仅是单个变量。
 
 ```python
 # fresh state
@@ -225,17 +215,17 @@ You can also evaluate more complex expressions, not just single variables.
 6
 ```
 
-From this we can see that `eval` is a general purpose method to convert any bitvector into a python primitive while respecting the integrity of the state.
-This is why we use `eval` to convert from concrete bitvectors to python ints, too!
+由此我们可以看到 `eval` 是将任何 `bitvector` 转化为 `python` 原语，同时又保持 `state` 完整性的一种通用方法。
+这也是为什么我们是有 `eval` 将具体的 `bitvector` 转化为 `python` 整形的原因。
 
-Also note that the x and y variables can be used in this new state despite having been created using an old state.
-Variables are not tied to any one state, and can exist freely.
+还要注意的是尽管变量 `x` 和 `y` 在旧 `state` 创建，但仍可以在新 `state` 使用。
+变量不与任何一个 `state` 绑定，可以自由存在。
 
-## Floating point numbers
+## 浮点数
 
-z3 has support for the theory of IEEE754 floating point numbers, and so angr can use them as well.
-The main difference is that instead of a width, a floating point number has a _sort_.
-You can create floating point symbols and values with `FPV` and `FPS`.
+`z3` 已经支持 `IEEE754` 标准，所以 `angr` 也可以使用它们。
+主要的区别不是宽度，而是一个浮点数有一个排序。
+您可以使用 `FPV` 和 `FPS` 来创建符号变量和具体的值。 
 
 ```python
 # fresh state
@@ -258,12 +248,12 @@ You can create floating point symbols and values with `FPV` and `FPS`.
 <Bool fpLT(fpAdd('RNE', FPS('FP_b_0_64', DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))>
 ```
 
-So there's a bit to unpack here - for starters the pretty-printing isn't as smart about floating point numbers.
-But past that, most operations actually have a third parameter, implicitly added when you use the binary operators - the rounding mode.
-The IEEE754 spec supports multiple rounding modes (round-to-nearest, round-to-zero, round-to-positive, etc), so z3 has to support them.
-If you want to specify the rounding mode for an operation, use the fp operation explicitly (`solver.fpAdd` for example) with a rounding mode (one of `solver.fp.RM_*`) as the first argument.
+有一点需要在这里说明 - 对于初学者来说，在浮点数上使用预印版并不太好。
+但在过去，大多数操作都有一个第三操作数，在使用二进制运算符时隐式地添加 - 舍入模式。
+`IEEE754` 支持多种舍入模式(圆到近，整数到零，圆到整等等)，所以 `z3` 也支持它们。
+如果您想指定一个操作的舍入模式，请指明 `fp` 的操作（例如：`solver.fpAdd`）,并且使用一个舍入模式( `solver.fp.RM_*` 里面的一个) 作为第一个参数。
 
-Constraints and solving work in the same way, but with `eval` returning a floating point number:
+约束和求解原理相同，使用 `eval` 会返回一个浮点数:
 
 ```python
 >>> state.solver.add(b + 2 < 0)
@@ -272,8 +262,8 @@ Constraints and solving work in the same way, but with `eval` returning a floati
 -2.4999999999999996
 ```
 
-This is nice, but sometimes we need to be able to work directly with the representation of the float as a bitvector.
-You can interpret bitvectors as floats and vice versa, with the methods `raw_to_bv` and `raw_to_fp`:
+这很好，但有时候我们需要直接使用用 `bitvector` 表示的浮点数。
+你可以将 `bitvector` 解释为浮点数，反之亦然，使用 `raw_to_bv` 和 `raw_to_fp`：
 
 ```python
 >>> a.raw_to_bv()
@@ -287,9 +277,9 @@ You can interpret bitvectors as floats and vice versa, with the methods `raw_to_
 <FP64 fpToFP(x_1_64, DOUBLE)>
 ```
 
-These conversions preserve the bit-pattern, as if you casted a float pointer to an int pointer or vice versa.
-However, if you want to preserve the value as closely as possible, as if you casted a float to an int (or vice versa), you can use a different set of methods, `val_to_fp` and `val_to_bv`.
-These methods must take the size or sort of the target value as a parameter, due to the floating-point nature of floats.
+这些转换保留了位模式，就像您将一个浮点数转化为一个整型指针，反之亦然。
+但是，如果您想尽可能的保留原值，就像将浮点类型转换为整型（反之亦然），则可以使用另一组方法，`val_to_fp` 和 `val_to_bv`。
+这些方法因为浮点数的性质必须使用目标值的大小或类型作为参数 
 
 ```python
 >>> a
@@ -300,35 +290,32 @@ These methods must take the size or sort of the target value as a parameter, due
 <FP32 FPV(3.0, FLOAT)>
 ```
 
-These methods can also take a `signed` parameter, designating the signedness of the source or target bitvector.
-
+这些方法也可以使用 `signed` 作为参数，指定源参数和目标参数的符号。
 
-## More Solving Methods
+## 其他方法
 
-`eval` will give you one possible solution to an expression, but what if you want several?
-What if you want to ensure that the solution is unique?
-The solver provides you with several methods for common solving patterns:
+`eval` 将会给你的表达式一个可能的解决方案，但是如果你想得到多个呢？
+如果你想确保解决方案是唯一的呢？
+求解器提供了几种常见的求解模式:
 
-- `solver.eval(expression)` will give you one possible solution to the given expression.
-- `solver.eval_one(expression)` will give you the solution to the given expression, or throw an error if more than one solution is possible.
-- `solver.eval_upto(expression, n)` will give you up to n solutions to the given expression, returning fewer than n if fewer than n are possible.
-- `solver.eval_atleast(expression, n)` will give you n solutions to the given expression, throwing an error if fewer than n are possible.
-- `solver.eval_exact(expression, n)` will give you n solutions to the given expression, throwing an error if fewer or more than are possible.
-- `solver.min(expression)` will give you the minimum possible solution to the given expression.
-- `solver.max(expression)` will give you the maximum possible solution to the given expression.
+- `solver.eval(expression)` 对给定的表达式提供一个解决方案
+- `solver.eval_one(expression)` 对给定的表达式提供一个解决方案，如果大于一个则会抛出异常。
+- `solver.eval_upto(expression, n)` 对给定的表达式提供 `n` 种解决方案，如果少于 `n` ,则返回小于 `n` 。
+- `solver.eval_atleast(expression, n)` 对给定的表达式提供 `n` 种解决方案，如果少于 `n` ，则会抛出错误。
+- `solver.eval_exact(expression, n)` 对给定的表达式提供 `n` 中解决方案，多于或者少于都会抛出错误。
+- `solver.min(expression)` 对给定的表达式提供最小可能的解决方案。
+- `solver.max(expression)` 对给定的表达式提供最大可能的解决方案。
 
-Additionally, all of these methods can take the following keyword arguments:
+此外，所有这些方法都可以使用以下关键字参数：
 
-- `extra_constraints` can be passed as a tuple of constraints.
-  These constraints will be taken into account for this evaluation, but will not be added to the state.
-- `cast_to` can be passed a data type to cast the result to.
-  Currently, this can only be `str`, which will cause the method to return the byte representation of the underlying data.
-  For example, `state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=str)` will return `"ABCD"`.
+- `extra_constraints` 可以作为约束条件的元组传递，这些约束将会在求解是被考虑，但是不会被增加到 `state`。
+- `cast_to` 可以将结果转换成某一数据类型。
+现在只能是 `str` 类型，这将会返回底层数据的字节表示。
+例如： `state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=str)` 将返回 `"ABCD"`。
   
-## Summary
+## 总结
 
-That was a lot!!
-After reading this, you should be able to create and manipulate bitvectors, booleans, and floating point values to form trees of operations, and then query the constraint solver attached to a state for possible solutions under a set of constraints.
-Hopefully by this point you understand the power of using ASTs to represent computations, and the power of a constraint solver.
+在读完本章后，您应该能创建和操作 `bitvector`,布尔值和浮点值来形成操作数，然后在一组约束条件下求解某一个 `state`。
+希望通过这一点您可以了解到使用 `ASTs` 表示计算和约束求解器的强大。
 
-[In the appendix](appendices/options.md), you can find a reference for all the additional operations you can apply to ASTs, in case you ever need a quick table to look at.
+[附录](appendices/options.md), 你可以找到应用于 `ASTs` 的其他操作的引用。
diff --git a/docs/speed.md b/docs/speed.md
index 1603f91..22a14ef 100644
--- a/docs/speed.md
+++ b/docs/speed.md
@@ -1,64 +1,61 @@
-# Speed considerations
-
-The speed of angr as an analysis tool or emulator is greatly handicapped by the fact that it is written in python.
-Regardless, there are a lot of optimizations and tweaks you can use to make angr faster.
-
-## General tips
-
-- *Use pypy*.
-  [Pypy](http://pypy.org/) is an alternate python interpreter that performs optimized jitting of python code.
-  In our tests, it's a 10x speedup out of the box.
-- *Don't load shared libraries unless you need them*.
-  The default setting in angr is to try at all costs to find shared libraries that are compatible with the binary you've loaded, including loading them straight out of your OS libraries.
-  This can complicate things in a lot of scenarios.
-  If you're performing an analysis that's anything more abstract than bare-bones symbolic execution, ESPECIALLY control-flow graph construction, you might want to make the tradeoff of sacrificing accuracy for tractability.
-  angr does a reasonable job of making sane things happen when library calls to functions that don't exist try to happen.
-- *Use hooking and SimProcedures*.
-  If you're enabling shared libraries, then you definitely want to have SimProcedures written for any complicated library function you're jumping into.
-  If there's no autonomy requirement for this project, you can often isolate individual problem spots where analysis hangs up and summarize them with a hook.
-- *Use SimInspect*.
-  [SimInspect](simulation.html#breakpoints) is the most underused and one of the most powerful features of angr.
-  You can hook and modify almost any behavior of angr, including memory index resolution (which is often the slowest part of any angr analysis).
-- *Write a concretization strategy*.
-  A more powerful solution to the problem of memory index resolution is a [concretization strategy](https://github.com/angr/angr/tree/master/angr/concretization_strategies).
-- *Use the Replacement Solver*.
-  You can enable it with the `angr.options.REPLACEMENT_SOLVER` state option.
-  The replacement solver allows you to specify AST replacements that are applied at solve-time.
-  If you add replacements so that all symbolic data is replaced with concrete data when it comes time to do the solve, the runtime is greatly reduced.
-  The API for adding a replacement is `state.se._solver.add_replacement(old, new)`.
-  The replacement solver is a bit finicky, so there are some gotchas, but it'll definitely help.
-
-## If you're performing lots of concrete or partially-concrete execution
-
-- *Use the unicorn engine*.
-  If you have [unicorn engine](https://github.com/unicorn-engine/unicorn/) installed, angr can be built to take advantage of it for concrete emulation.
-  To enable it, add the options in the set `angr.options.unicorn` to your state.
-  Keep in mind that while most items under `angr.options` are individual options, `angr.options.unicorn` is a bundle of options, and is thus a set.
-  *NOTE*: At time of writing the official version of unicorn engine will not work with angr - we have a lot of patches to it to make it work well with angr.
-  They're all pending pull requests at this time, so sit tight. If you're really impatient, ping us about uploading our fork!
-- *Enable fast memory and fast registers*.
-  The state options `angr.options.FAST_MEMORY` and `angr.options.FAST_REGISTERS` will do this.
-  These will switch the memory/registers over to a less intensive memory model that sacrifices accuracy for speed.
-  TODO: document the specific sacrifices. Should be safe for mostly concrete access though.
-  NOTE: not compatible with concretization strategies.
-- *Concretize your input ahead of time*.
-  This is the approach taken by [driller](https://www.internetsociety.org/sites/default/files/blogs-media/driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf).
-  Before execution begins, we fill state.posix.files[0] with symbolic data representing the input, then constrain that symbolic data to what we want the input to be, then set a concrete file size (state.posix.files[0].size = whatever).
-  If you don't require any tracking of the data coming from stdin, you can forego the symbolic part and just fill it with concrete data.
-  If there are other sources of input besides standard input, do the same for those.
-- *Use the afterburner*.
-  While using unicorn, if you add the `UNICORN_THRESHOLD_CONCRETIZATION` state option, angr will accept thresholds after which it causes symbolic values to be concretized so that execution can spend more time in Unicorn. Specifically, the following thresholds exist:
-
-  - `state.se.unicorn.concretization_threshold_memory` - this is the number of times a symbolic variable, stored in memory, is allowed to kick execution out of Unicorn before it is forcefully concretized and forced into Unicorn anyways.
-  - `state.se.unicorn.concretization_threshold_registers` - this is the number of times a symbolic variable, stored in a register, is allowed to kick execution out of Unicorn before it is forcefully concretized and forced into Unicorn anyways.
-  - `state.se.unicorn.concretization_threshold_instruction` - this is the number of times that any given instruction can force execution out of Unicorn (by running into symbolic data) before any symbolic data encountered at that instruction is concretized to force execution into Unicorn.
-
-  You can get further control of what is and isn't concretized with the following sets:
-
-  - `state.se.unicorn.always_concretize` - a set of variable names that will always be concretized to force execution into unicorn (in fact, the memory and register thresholds just end up causing variables to be added to this list).
-  - `state.se.unicorn.never_concretize` - a set of variable names that will never be concretized and forced into Unicorn under any condition.
-  - `state.se.unicorn.concretize_at` - a set of instruction addresses at which data should be concretized and forced into Unicorn. The instruction threshold causes addresses to be added to this set.
-
-  Once something is concretized with the afterburner, you will lose track of that variable.
-  The state will still be consistent, but you'll lose dependencies, as the stuff that comes out of Unicorn is just concrete bits with no memory of what variables they came from.
-  Still, this might be worth it for the speed in some cases, if you know what you want to (or do not want to) concretize.
+# 速度考量
+
+angr 作为一个分析工具或模拟器的速度极大地受到 Python 语言的限制，但仍然有很多优化和调整的方法来让 angr 实现更快的速度
+
+## 通用技巧
+
+- *使用 pypy*.
+  [Pypy](http://pypy.org/) 是一个可替代的 Python 解释器，可以优化要执行的 Python 代码。
+  在我们的测试中，它能提升十倍以上的速度并且开箱即用
+- *除非必要，否则不要加载共享库*
+  angr 的默认设置是尽可能的查找已装载的二进制文件兼容的共享库，以及在操作系统库中直接装载。
+  这往往很复杂，如果您执行的分析比纯符号执行更抽象，特别是像控制流图的构建，您最好做出一些精度上的牺牲。
+  当库调用不存在的函数时，angr 可以做出合理的响应
+- *使用 Hooking 和 SimProcedures*
+  如果您启用了共享库跟踪，您一定想要一个为可以进入任何复杂库函数而编写的 SimProcedures。
+  如果没有对项目的特殊要求，您可以在分析过程中分割单独的问题点，并用 Hook 将其 summarize。
+- *使用 SimInspect*
+  [SimInspect](simulation.html#breakpoints) 是 angr 中使用频度不高但最强大的功能之一。
+  您可以 Hook 并修改 angr 的任何一个行为，包括内存索引解析（这通常是 angr 中最慢的一个部分）
+- *写一个 concretization strategy*
+  内存索引解析更好的解决方案是 [concretization strategy](https://github.com/angr/angr/tree/master/angr/concretization_strategies)
+- *使用替换求解器*.
+  您可以改变 `angr.options.REPLACEMENT_SOLVER` 启用它。替换求解器允许您在求解时进行 AST 替换。
+  如果您添加的替换使得求解时所有符号数据都被具体数据替换了，那么运行时间将大大降低。
+  添加替换的 API 为 `state.se._solver.add_replacement(old, new)`。
+  替换比较麻烦，也会有一些难题，但这绝对值得！
+  
+## 如果进行了很多具体执行或部分具体执行
+
+- *使用 unicorn 引擎*
+  如果您安装了 [unicorn](https://github.com/unicorn-engine/unicorn/)，可以让 angr 调用它来进行具体的仿真。
+  想要启用这个功能，请添加 `angr.options.unicorn` 到您的 state 中。
+  请记住，虽然大多数情况下 `angr.options` 都是单独的选项，但 `angr.options.unicorn` 是一组选项，因此它是一个集合。
+  *注意*：现在 unicorn 的官方版本还不能和 angr 进行联动，我们为了能和 angr 进行协同做了很多改动。
+  这些改动的 PR 都在等待接受，还需要进行等待。如果您不想等待，可以使用我们 fork 的版本！
+- *启用快速内存与快速寄存器*
+  想启用需要修改 `angr.options.FAST_MEMORY` 和 `angr.options.FAST_REGISTERS` 两个 state 选项。
+  这将把内存/寄存器切换到不精确的内存模型，为了速度牺牲了准确性。
+  TODO：这些牺牲对大多数 concrete access though 是安全的
+  NOTE：这和 concretization strategies 不兼容
+- *Concretize your input ahead of time*
+  这是 [driller](https://www.internetsociety.org/sites/default/files/blogs-media/driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf) 采取的方法，在开始执行之前，我们使用代表输入样本的符号数据来填充 state.posix.files[0]。然后将符号数据约束到那些我们希望输入样本应该的样子上，之后设置具体文件大小(state.posix.files[0].size = whatever)。
+  如果您不需要跟踪来自 stdin 的数据，您可以放弃符号部分，只用具体数据进行填充。
+  如果除了标准输入还有其他输入源，以此类推
+- *使用 afterburner*.
+  当使用 unicorn 时，如果添加了 `UNICORN_THRESHOLD_CONCRETIZATION` 选项，angr 将会接受一个符号值具体的阈值，好让更多的时间花在 Unicorn 上。具体来说，存在以下阈值：
+  
+  - `state.se.unicorn.concretization_threshold_memory` - 这是存储在内存中的符号变量在被具体化送入 Unicorn 之前被允许在 Unicorn 中执行的次数
+  - `state.se.unicorn.concretization_threshold_registers` - 这是存储在寄存器中的符号变量在被具体化送入 Unicorn 之前被允许在 Unicorn 中执行的次数
+  - `state.se.unicorn.concretization_threshold_instruction` - 这是任何给定的指令在该指令遇到任何符号数据被具体化以送入 Unicorn 之前送入 Unicorn 的次数（通过进入符号数据）
+
+  您可以通过以下设置进一步控制哪些数据应该被具体化：
+  
+  - `state.se.unicorn.always_concretize` - 一组始终会被具体化并送入 Unicorn 的变量名（实际上，内存与寄存器阈值最终会导致变量添加到此列表中）
+  - `state.se.unicorn.never_concretize` - 一组永远不会被具体化并送入 Unicorn 的变量名
+  - `state.se.unicorn.concretize_at` - 一组数据应该被具体化并送入 Unicorn 的指令地址。指令阈值将会导致指令添加到此列表中。
+
+  一旦被 afterburner 具体化，您将会失去对某些变量的跟踪。
+  state 仍然还是 state，但是您会丢失某些依赖。因为从 Unicorn 出来的东西是具体的，不会记录其来自于哪个变量。
+  不过，在某些情况下，您仍能控制哪些数据要具体化，哪些数据不具体化
+  
\ No newline at end of file
diff --git a/docs/states.md b/docs/states.md
index e57e3ae..9398cd9 100644
--- a/docs/states.md
+++ b/docs/states.md
@@ -1,57 +1,53 @@
-# Machine State - memory, registers, and so on
+# 机器 State - 内存、寄存器等
 
-So far, we've only used angr's simulated program states (`SimState` objects) in the barest possible way in order to demonstrate basic concepts about angr's operation. Here, you'll learn about the structure of a state object and how to interact with it in a variety of useful ways.
+到目前为止，我们只是使用了 angr 的 `SimState` 对象来模拟程序 state 来演示有关 angr 的基本概念。在本节中，您将会了解到一个 state 对象的结构以及如何以各种有用的方式与其进行交互
 
-## Review: Reading and writing memory and registers
+## Review: 读写内存与寄存器
 
-If you've been reading this book in order (and you should be, at least for this first section), you already saw the basics of how to access memory and registers.
-`state.regs` provides read and write access to the registers through attributes with the names of each register, and `state.mem` provides typed read and write access to memory with index-access notation to specify the address followed by an attribute access to specify the type you would like to interpret the memory as.
+如果您是从头开始阅读的，您应该已经看到了关于如何访问内存和寄存器的这部分基础知识。
+`state.regs` 通过每个寄存器的名字这一属性来提供对寄存器的读写访问，`state.mem` 通过索引访问符号来对内存进行类型化读写访问，这些索引访问符号用来指定要访问的地址与你想要把内存解释为的类型
 
-Additionally, you should now know how to work with ASTs, so you can now understand that any bitvector-typed AST can be stored in registers or memory.
+另外，您现在应该知道如何使用 AST 了，所以您现在应该清楚，任何 bitvector 型的 AST 都可以存储在寄存器或内存中
 
-Here are some quick examples for copying and performing operations on data from the state:
+这有一些关于在 state 中拷贝数据或执行操作的示例：
 
 ```python
 >>> import angr
 >>> proj = angr.Project('/bin/true')
 >>> state = proj.factory.entry_state()
 
-# copy rsp to rbp
+# 拷贝 rsp 到 rbp
 >>> state.regs.rbp = state.regs.rsp
 
-# store rdx to memory at 0x1000
+# 存储 rdx 到内存 0x1000 处
 >>> state.mem[0x1000].uint64_t = state.regs.rdx
 
-# dereference rbp
+# rbp 解除引用
 >>> state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved
 
 # add rax, qword ptr [rsp + 8]
 >>> state.regs.rax += state.mem[state.regs.rsp + 8].uint64_t.resolved
 ```
 
-## Basic Execution
+## 基本执行
 
-Earlier, we showed how to use a Simulation Manager to do some basic execution.
-We'll show off the full capabilities of the simulation manager in the next chapter, but for now we can use a much simpler interface to demonstrate how symbolic execution works: `state.step()`.
-This method will perform one step of symbolic execution and return an object called [`SimSuccessors`](http://angr.io/api-doc/angr.html#module-angr.engines.successors).
-Unlike normal emulation, symbolic execution can produce several successor states that can be classified in a number of ways.
-For now, what we care about is the `.successors` property of this object, which is a list containing all the "normal" successors of a given step.
+在前节，我们为您展示了如何使用 Simulation Manager 来进行一些基本的执行。我们将在下一章详细讲解 Simulation Manager 的全部功能，但此时我们可以用一个更简单的接口 `state.step()` 来解释符号执行是如何工作的。
+该方法将执行符号执行的一步并返回一个被调用对象 [`SimSuccessors`](http://angr.io/api-doc/angr.html#module-angr.engines.successors)，与正常的仿真不同，符号执行会产生以多种方式分类的后继 state。现在，我们关心的是这个对象的 `.successors` 属性，其中包含了给定 step 下的全部正常后继 state 列表
 
-Why a list, instead of just a single successor state?
-Well, angr's process of symbolic execution is just the taking the operations of the individual instructions compiled into the program and performing them to mutate a SimState.
-When a line of code like `if (x > 4)` is reached, what happens if x is a symbolic bitvector?
-Somewhere in the depths of angr, the comparison `x > 4` is going to get performed, and the result is going to be `<Bool x_32_1 > 4>`.
+为什么是一个列表而不是单独的后继 state ？
+angr 符号执行的希望就是将编译进程序的每一条指令都执行，以此来畸变 SimState。当执行到例如 `if (x > 4)` 这样的代码时，如果 x 是符号化的 bitvector 会发生什么？
+在 angr 的某处，比较表达式 `x > 4` 会被执行，结果 `<Bool x_32_1 > 4>` 会返回
 
-That's fine, but the next question is, do we take the "true" branch or the "false" one?
-The answer is, we take both!
-We generate two entirely separate successor states - one simulating the case where the condition was true and simulating the case where the condition was false.
-In the first state, we add `x > 4` as a constraint, and in the second state, we add `!(x > 4)` as a constraint.
-That way, whenever we perform a constraint solve using either of these successor states, *the conditions on the state ensure that any solutions we get are valid inputs that will cause execution to follow the same path that the given state has followed.*
+下一个问题就是：我们要执行 true 分支还是 false 分支？
+显然我们都想要执行！
+我们会生成两个完全独立的后继 state - 一个模拟进入 true 分支，另一个模拟进入 flase 分支。
+在第一个 state，我们添加约束 `x > 4`，在第二个 state，我们添加约束 `!(x > 4)`。
+这样，在我们进行约束求解使用这些后继 state 时，*state 对应的条件可以确保得到有效的输入，这些输入可以保证以相同的路径执行到相同的 state*
 
-To demonstrate this, let's use a [fake firmware image](../examples/fauxware/fauxware) as an example.
-If you look at the [source code](../examples/fauxware/fauxware.c) for this binary, you'll see that the authentication mechanism for the firmware is backdoored; any username can be authenticated as an administrator with the password "SOSNEAKY".
-Furthermore, the first comparison against user input that happens is the comparison against the backdoor, so if we step until we get more than one successor state, one of those states will contain conditions constraining the user input to be the backdoor password.
-The following snippet implements this:
+为了说明这一点，我们以一个 [虚假固件镜像](../examples/fauxware/fauxware) 为例。查看[源码](../examples/fauxware/fauxware.c)可以发现验证机制存在后门。任何用户都可以通过密码 "SOSNEAKY" 来作为管理员通过身份认证。
+此外，用户输入的第一次比较发生在后门处，如果我们执行到可以获得超过一个后继 state 时，那么这些 state 中一定有一个 state 包含用户输入中包含后门密码的条件约束
+
+以下这段代码实现了这个功能：
 
 ```python
 >>> proj = angr.Project('examples/fauxware/fauxware')
@@ -69,11 +65,11 @@ The following snippet implements this:
 <SimState @ 0x400699
 ```
 
-Don't look at the constraints on these states directly - the branch we just went through involves the result of `strcmp`, which is a tricky function to emulate symbolically, and the resulting constraints are _very_ complicated.
+不需要直接看这些 state 的约束，因为我们刚经过的分支是 `strcmp` 的结果。这个函数在模拟符号化的过程中很难处理，结果的约束条件 _非常_ 复杂
 
-The program we emulated took data from standard input, which angr treats as an infinite stream of symbolic data by default.
-To perform a constraint solve and get a possible value that input could have taken in order to satisfy the constraints, we'll need to get a reference to the actual contents of stdin.
-We'll go over how our file and input subsystems work later on this very page, but for now, just use `state.posix.files[0].all_bytes()` to retrieve a bitvector represnting all the content read from stdin so far.
+我们的程序从标准输入获取数据，默认情况下，它被 angr 视为无限符号数据流。
+为了执行约束求解得到输入的可能值，这些输入可以满足这些约束条件，我们需要获得标准输入实际内容的引用。
+我们在本节稍后会介绍我们的文件与输入子系统是如何工作的。但现在我们使用 `state.posix.files[0].all_bytes()` 来检索一个代表目前为止从标准输入读取所有内容的 bitvector 
 
 ```python
 >>> input_data = state1.posix.files[0].all_bytes()
@@ -85,50 +81,48 @@ We'll go over how our file and input subsystems work later on this very page, bu
 '\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x00\x80N\x00\x00 \x00\x00\x00\x00'
 ```
 
-As you can see, in order to go down the `state1` path, you must have given as a password the backdoor string "SOSNEAKY".
-In order to go down the `state2` path, you must have given something _besides_ "SOSNEAKY".
-z3 has helpfully provided one of the billions of strings fitting this criteria.
+如您所见，为了让 `state1` 路径执行下去，您必须给出后门密码字符串 "SOSNEAKY"。为了让 `state2` 路径执行下去，您必须给出非 "SOSNEAKY" 的字符串。
+Z3 将会在符合此约束条件的数十亿个字符串中找到一个返回给您
 
-Fauxware was the first program angr's symbolic execution ever successfully worked on, back in 2013.
-By finding its backdoor using angr you are participating in a grand tradition of having a bare-bones understanding of how to use symbolic execution to extract meaning from binaries!
+Fauxware 是 2013 年 angr 第一个符号执行的程序。
+我们使用 angr 找到了它的后门，angr 的能力由来已久。
+希望您能对于如何使用符号执行在二进制程序中提取有意义的信息有一个清楚的认识！
 
 ## State Presets
 
-So far, whenever we've been working with a state, we've created it with `project.factory.entry_state()`.
-This is just one of several *state constructors* available on the project factory:
+到目前为止，只要我们使用了 state 就需要创建 `project.factory.entry_state()`。
+这只是一系列 *state 构造函数* 中的一个：
 
-- `.blank_state()` constructs a "blank slate" blank state, with most of its data left uninitialized.
-  When accessing uninitialized data, an unconstrained symbolic value will be returned.
-- `.entry_state()` constructs a state ready to execute at the main binary's entry point.
-- `.full_init_state()` constructs a state that is ready to execute through any initializers that need to be run before the main binary's entry point, for example, shared library constructors or preinitializers.
-  When it is finished with these it will jump to the entry point.
-- `.call_state()` constructs a state ready to execute a given function.
+- `.blank_state()` 构建一个大部分数据为初始化的空白 state，访问未初始化的数据时，将返回无约束的符号值
+- `.entry_state()` 构建一个要从二进制程序入口点开始执行的 state
+- `.full_init_state()` 准备通过任意初始化器来构造一个 state，这些初始化器需要在二进制程序的入口点前执行，例如，共享库构造器或预初始化器。完成后会跳进入口点
+- `.call_state()` 构建一个从给定函数开始执行的 state
 
-You can customize the state through several arguments to these constructors:
+您可以通过这些构造函数的参数来自定义 state：
 
-- All of these constructors can take an `addr` argument to specify the exact address to start.
+- 所有构造函数都可以通过引用一个 `addr` 参数来指定开始地址
 
-- If you're executing in an environment that can take command line arguments or an environment, you can pass a list of arguments through `args` and a dictionary of environment variables through `env` into `entry_state` and `full_init_state`.
-  The values in these structures can be strings or bitvectors, and will be serialized into the state as the arguments and environment to the simulated execution.
-  The default `args` is an empty list, so if the program you're analyzing expects to find at least an `argv[0]`, you should always provide that!
+- 如果程序在需要命令行参数或者环境变量的情况下执行，可以将参数列表作为 `args`、环境变量的列表作为 `env` 传递给 `entry_state` 和 `full_init_state`。
+  这些结构中的值可以是字符串或 bitvector，序列化后作为模拟执行环境中的参数和环境变量送入 state。
+  默认参数 `args` 是一个空列表，所以如果您正在分析的程序希望至少可以获得 `argv[0]`，那么您应该提供一个！
 
-- If you'd like to have `argc` be symbolic, you can pass a symbolic bitvector as `argc` to the `entry_state` and `full_init_state` constructors.
-  Be careful, though: if you do this, you should also add a constraint to the resulting state that your value for argc cannot be larger than the number of args you passed into `args`.
+- 如果您希望 `argc` 作为符号变量，您应该传递一个符号化的 bitvector 作为 `argc` 传给 `entry_state` 和 `full_init_state` 的构造函数。
+  需要注意的是，如果您需要这样做，还应该为结果 state 添加一些约束，即 argc 的值不能超过你传入 `args` 参数的数量
   
-- To use the call state, you should call it with `.call_state(addr, arg1, arg2, ...)`, where `addr` is the address of the function you want to call and `argN` is the Nth argument to that function, either as a python integer, string, or array, or a bitvector.
-  If you want to have memory allocated and actually pass in a pointer to an object, you should wrap it in an PointerWrapper, i.e. `angr.PointerWrapper("point to me!")`.
-  The results of this API can be a little unpredictable, but we're working on it.
+- 为了使用 call state，您应该调用 `.call_state(addr, arg1, arg2, ...)`，其中 `addr` 是你想要调用的函数的地址，`argN` 是函数的第 N 个参数，可以是整型、字符串、数组或者 bitvector。
+  如果您想分配内存并实际为对象传递一个指针过去，您应该将其置于 PointerWrapper 中，例如 `angr.PointerWrapper("point to me!")`。
+  该 API 的结果可能有些问题，我们会努力确保其正确
   
-- To specify the calling convention used for a function with `call_state`, you can pass a [`SimCC` instance](http://angr.io/api-doc/angr.html#module-angr.calling_conventions) as the `cc` argument.    
-  We try to pick a sane default, but for special cases you will need to help angr out.
-
-There are several more options that can be used in any of these constructors, which will be outlined later on this page!
+- 为指定用于 `call_state` 的函数的调用约定，您可以以参数 `cc` 的形式传递一个 [`SimCC` 实例](http://angr.io/api-doc/angr.html#module-angr.calling_conventions)。
+  我们会尝试选择合理的默认值，但对于特殊情况需要您手动来解决！
+  
+还有几个可以在这些构造函数中使用的参数，本节稍后将会为您介绍！
 
-## Low level interface for memory
+## 内存低级接口
 
-The `state.mem` interface is convenient for loading typed data from memory, but when you want to do raw loads and stores to and from ranges of memory, it's very cumbersome.
-It turns out that `state.mem` is actually just a bunch of logic to correctly access the underlying memory storage, which is just a flat address space filled with bitvector data: `state.memory`.
-You can use `state.memory` directly with the `.load(addr, size)` and `.store(addr, val)` methods:
+接口 `state.mem` 便于从内存中加载类型数据，但想要加载与存储指定内存范围的数据就非常麻烦了。
+`state.mem` 实际实际上只是正确访问低级内存存储的逻辑，只是一个填充了 bitvector 数据：`state.memory` 的平面地址空间。
+您可以使用 `.load(addr, size)` 或 `.store(addr, val)` 作为 `state.memory` 的附属：
 
 ```python
 >>> s = proj.factory.blank_state()
@@ -137,10 +131,10 @@ You can use `state.memory` directly with the `.load(addr, size)` and `.store(add
 <BV48 0x89abcdef0123>
 ```
 
-As you can see, the data is loaded and stored in a "big-endian" fashion, since the primary purpose of `state.memory` is to load an store swaths of data with no attached semantics.
-However, if you want to perform a byteswap on the loaded or stored data, you can pass a keyword argument `endness` - if you specify little-endian, byteswap will happen.
-The endness should be one of the members of the `Endness` enum in the `archinfo` package used to hold declarative data about CPU architectures for angr.
-Additionally, the endness of the program being analyzed can be found as `arch.memory_endness` - for instance `state.arch.memory_endness`.
+如您所见，数据以大端方式加载与存储，因为 `state.memory` 的主要目的是加载没有附属语义的数据。
+但是，如果想要在存储或加载数据上进行 byteswap，您可以传递一个关键参数 `endness` - 如果您指定为小段序，则会发生字节交换 byteswap。
+endness 应该是 `archinfo` 包中枚举变量 `Endness` 中的一个，`archinfo` 中为 angr 保存着有关 CPU 架构的声明性数据。
+另外，正在分析程序的 endness 可以在 `arch.memory_endness` 中找到，例如 `state.arch.memory_endness`
 
 ```python
 >>> import archinfo
@@ -148,21 +142,20 @@ Additionally, the endness of the program being analyzed can be found as `arch.me
 <BV32 0x67453201>
 ```
 
-There is also a low-level interface for register access, `state.registers`, but explaining its behavior involves a [dive](ir.md) into the abstractions that angr uses to seamlessly work with multiple architectures.
+对寄存器访问的低级接口 `state.registers`，但是解释其涉及到 angr 中的 [dive](ir.md)，这个抽象定义用于多架构的无缝协作
 
 
-## State Options
+## State 选项
 
-There are a lot of little tweaks that can be made to the internals of angr that will optimize behavior in some situations and be a detriment in others.
-These tweaks are controlled through state options.
+某些情况下，对 angr 内部的小调整是可以优化其效果的，有时候是有害的。这些都通过控制 state 选项来进行。
 
-On each SimState object, there is a set (`state.options`) of all its enabled options.
-Each option (really just a string) controls the behavior of angr's execution engine in some minute way.
-A listing of the full domain of options, along with the defaults for different state types, can be found in [the appendix](appendices/options.md).
-You can access an individual option for adding to a state through `angr.options`.
-The individual options are named with CAPITAL_LETTERS, but there are also common groupings of objects that you might want to use bundled together, named with lowercase_letters.
+每个 SimState 对象，都有一个选项 `state.options`，
+每个选项（只需要一个字符串）控制着 angr 执行引擎的行为。
+选项的完整列表以及不同 state 类型下的默认值需要参看 [附录](appendices/options.md)。
+您可以通过 `angr.options` 来添加一个单独的选项到 state 中。
+单个选项以 CAPITAL_LETTERS 命名，当您想联合使用时也可以使用对象组，叫做 lowercase_letters
 
-When creating a SimState through any constructor, you may pass the keyword arguments `add_options` and `remove_options`, which should be sets of options that modify the initial options set from the default.
+当您通过构造函数创建 SimState 时，您可以传送关键参数 `add_options` 和 `remove_options`，这些参数是那些默认值被修改了的初始选项的集合
 
 ```python
 # Example: enable lazy solves, an option that causes state satisfiability to be checked as infrequently as possible.
@@ -176,42 +169,41 @@ When creating a SimState through any constructor, you may pass the keyword argum
 >>> s = proj.factory.entry_state(remove_options=angr.options.simplification)
 ```
 
-## State Plugins
+## State 插件
 
 TODO: lord almighty
 
-Common plugins: state.history, state.globals, state.posix (ew), state.callstack
+通用插件： state.history, state.globals, state.posix (ew), state.callstack
 
-## Working with the Filesystem
+## 文件系统
 
-TODO: Describe what a SimFile is
+TODO: 描述什么是 SimFile
 
-There are a number of options which can be passed to the state initialization routines which affect filesystem usage.
-These include the `fs`, `concrete_fs`, and `chroot` options.
+文件系统有很多选项来控制 state 初始化，包括 `fs`、`concrete_fs` 和 `chroot` 选项
 
-The `fs` option allows you to pass in a dictionary of file names to preconfigured SimFile objects.
-This allows you to do things like set a concrete size limit on a file's content.
+`fs` 选项允许您将文件名的字典传给预配置好的 SimFile 对象。
+您可以对文件内容具体设置大小的限制。
 
-Setting the `concrete_fs` option to `True` will cause angr to respect the files on disk.
-For example, if during simulation a program attempts to open 'banner.txt' when `concrete_fs` is set to `False` \(the default\), a SimFile with a symbolic memory backing will be created and simulation will continue as though the file exists.
-When `concrete_fs` mode is set to `True`, if 'banner.txt' exists a new SimFile object will be created with a concrete backing, reducing the resulting state explosion which would be caused by operating on a completely symbolic file.
-Additionally in `concrete_fs` mode if 'banner.txt' mode does not exist, a SimFile object will not be created upon calls to open during simulation and an error code will be returned.
-Additionally, it's important to note that attempts to open files whose path begins with '/dev/' will never be opened concretely even with `concrete_fs` set to `True`.
+设置 `concrete_fs` 选项为 `True`，angr 会 respect 磁盘上的文件。
+例如，在仿真时尝试打开文件 'banner.txt'，此时 `concrete_fs` 置为 `False`（默认为 False），将会创建一个带有符号内存的 SimFile 对象，尽管文件存在，仿真仍会继续。
+当 `concrete_fs` 置为 `True` 时，如果 'banner.txt' 存在，一个新的 SimFile 对象将会具体地创建，这样可以减少在完全符号化的文件上进行操作而导致的状态爆炸。
+此时，若 'banner.txt' 不存在，仿真时的调用 SimFile 对象就不会被创建，并且返回一个错误码。
+此外，需要强调地是：尝试打开那些以 '/dev/' 开头的文件，即使 `concrete_fs` 被设置为 `True` 也不会被具体打开
 
-The `chroot` option allows you to specify an optional root to use while using the `concrete_fs` option.
-This can be convenient if the program you're analyzing references files using an absolute path.
-For example, if the program you are analyzing attempts to open '/etc/passwd', you can set the chroot to your current working directory so that attempts to access '/etc/passwd' will read from '$CWD/etc/passwd'.
+`chroot` 选项，允许您在使用 `concrete_fs` 选项时，指定一个可选的 root 来使用。
+如果您正在分析的程序使用绝对路径，是很便利的。
+例如，程序正在尝试打开 '/etc/passwd'，可以将当前工作目录设置为 chroot，之后对 '/etc/passwd' 的访问尝试都会被视为 '$CWD/etc/passwd'
 
 ```python
 >>> files = {'/dev/stdin': angr.storage.file.SimFile("/dev/stdin", "r", size=30)}
 >>> s = proj.factory.entry_state(fs=files, concrete_fs=True, chroot="angr-chroot/")
 ```
 
-This example will create a state which constricts at most 30 symbolic bytes from being read from stdin and will cause references to files to be resolved concretely within the new root directory `angr-chroot`.
+这个例子会创建一个 state，该 state 限制从标准输入中最多读取 30 个符号字节，对文件的引用都会在新根目录 `angr-chroot` 内被直接解析
 
-## Copying and Merging
+## 复制与合并
 
-A state supports very fast copies, so that you can explore different possibilities:
+state 支持快速拷贝，以便探索不同的可能性：
 
 ```python
 >>> proj = angr.Project('/bin/true')
@@ -223,7 +215,7 @@ A state supports very fast copies, so that you can explore different possibiliti
 >>> s2.mem[0x1000].uint32_t = 0x42424242
 ```
 
-States can also be merged together.
+States 也可以合并在一起
 
 ```python
 # merge will return a tuple. the first element is the merged state
@@ -235,4 +227,4 @@ States can also be merged together.
 >>> aaaa_or_bbbb = s_merged.mem[0x1000].uint32_t
 ```
 
-TODO: describe limitations of merging
+TODO: 描述合并的局限性
diff --git a/docs/structured_data.md b/docs/structured_data.md
index 70a7cb8..a53947a 100644
--- a/docs/structured_data.md
+++ b/docs/structured_data.md
@@ -1,18 +1,15 @@
-Working with Data and Conventions
+使用数据与约定
 =================================
 
-Frequently, you'll want to access structured data from the program you're analyzing.
-angr has several features to make this less of a headache.
+通常来说，你都需要访问你正在分析的程序的结构化数据。Angr 在这个方向上做了一些工作来解决这些难题。
 
-## Working with types
+## 类型
 
-angr has a system for representing types.
-These SimTypes are found in `angr.types` - an instance of any of these classes represents a type.
-Many of the types are incomplete unless they are supplamented with a SimState - their size depends on the architecture you're running under.
-You may do this with `ty.with_state(state)`, which returns a copy of itself, with the state specified.
+angr 有一个代表类型系统。SimTypes 在 `angr.types` 中，类中的任何实例都可以代表一种类型。
+许多类型都不完整，除非被 SimState 替代。类型的宽度大小往往取决于运行机器的体系结构。
+也可以使用 `ty.with_state(state)` 来返回它自身指定状态的一个副本
 
-angr also has a light wrapper around `pycparser`, which is a C parser.
-This helps with getting instances of type objects:
+angr 也用 C 实现了一个轻量的装饰器 `pycparser`，这有助于获取对象的类型信息
 
 ```python
 >>> import angr
@@ -32,7 +29,7 @@ struct aa
 OrderedDict([('x', int), ('y', long)])
 ```
 
-Additionally, you may parse C definitions and have them returned to you in a dict, either of variable/function declarations or of newly defined types:
+此外，你也可以解析 C 的定义，无论是变量/函数声明还是自定义的类型都会返回一个字典：
 
 ```python
 >>> angr.types.parse_defns("int x; typedef struct llist { char* str; struct llist *next; } list_node; list_node *y;")
@@ -56,7 +53,7 @@ OrderedDict([('str', char*), ('next', struct llist*)])
 {'x': (int, double) -> int}
 ```
 
-And finally, you can register struct definitions for future use:
+最后，你可以自己定义数据结构以供使用：
 
 ```python
 >>> angr.types.define_struct('struct abcd { int x; int y; }')
@@ -65,12 +62,12 @@ And finally, you can register struct definitions for future use:
 {'a': struct abcd, 'b': long}
 ```
 
-These type objects aren't all that useful on their own, but they can be passed to other parts of angr to specify data types.
+这些类型对象本身并没什么用，不过可以传递给 angr 的其他组件来指定数据类型
 
-## Accessing typed data from memory
+## 访问内存中指定类型的数据
 
-Now that you know how angr's type system works, you can unlock the full power of the `state.mem` interface!
-Any type that's registered with the types module can be used to extract data from memory.
+既然已经知道了 angr 的类型系统是如何工作的，现在可以解锁 `state.mem` 接口的全部功能了！
+任何在类型模块中注册过的类型都可以用于从内存中提取数据
 
 ```python
 >>> import angr
@@ -113,21 +110,20 @@ Any type that's registered with the types module can be used to extract data fro
 'SOSNEAKY'
 ```
 
-The interface works like this:
+接口如下：
 
-- You first use [array index notation] to specify the address you'd like to load from
-- If at that address is a pointer, you may access the `deref` property to return a SimMemView at the address present in memory.
-- You then specify a type for the data by simply accessing a property of that name.
-  For a list of supported types, look at `state.mem.types`.
-- You can then _refine_ the type. Any type may support any refinement it likes.
-  Right now the only refinements supported are that you may access any member of a struct by its member name, and you may index into a string or array to access that element.
-- If the address you specified initially points to an array of that type, you can say `.array(n)` to view the data as an array of n elements.
-- Finally, extract the structured data with `.resolved` or `.concrete`.
-  `.resolved` will return bitvector values, while `.concrete` will return integer, string, array, etc values, whatever best represents the data.
-- Alternately, you may store a value to memory, by assigning to the chain of properties that you've constructed.
-  Note that because of the way python works, `x = s.mem[...].prop; x = val` will NOT work, you must say `s.mem[...].prop = val`.
+- 首先使用 [数组索引] 来指定要加载的地址
+- 如果该地址是一个指针，可以通过 `deref` 属性返回 SimMemView 在内存中的地址
+- 可以通过访问属性指定数据的类型。支持类型的列表请参见： `state.mem.types`
+- 可以 _重定义_ 类型，任何类型都支持任意重定义。现在唯一支持的重定义就是通过成员名访问结构体中的任何成员，并且也可以使用对字符串/数组的索引来访问元素  
+- 如果如果初始给定的地址指向一个类型的数组，可以将
+ `.array(n)` 看作由n个元素组成的数组
+- 最后，使用 `.resolved` 或者 `.concrete` 提取结构化数据
+  `.resolved` 将返回 bitvector，而 `.concrete` 返回整型、字符串、数组等能代表数据的类型的值
+- 或者，也可以通过分配自定义的属性链将值存储到内存中
+  请注意，由于 Python 的限制，`x = s.mem[...].prop; x = val` 这样的写法不被允许，必须使用 `s.mem[...].prop = val` 才能成功
 
-If you define a struct using `define_struct` or `register_types`, you can access it here as a type:
+如果你使用 `define_struct` 或 `register_types` 定义一个结构，就可以作为一个类型来访问它
 
 ```python
 >>> s.mem[b.entry].abcd
@@ -137,46 +133,42 @@ If you define a struct using `define_struct` or `register_types`, you can access
 } at 0x400580>
 ```
 
-## Working with Calling Conventions
+## 使用调用约定
 
-A calling convention is the specific means by which code passes arguments and return values through function calls.
-While angr comes with a large number of pre-built calling conventions, and a lot of logic for refining calling conventions for specific circumstances (e.g. floating point arguments need to be stored in different locations, it gets worse from there), it will inevitably be insufficient to describe all possible calling conventions a compiler could generate.
-Because of this, you can _customize_ a calling convention by describing where the arguments and return values should live.
+调用约定是通过函数传递参数和返回值的特殊方法。
+虽然 angr 带有大量预设的调用约定，并且在特定情况下（例如，浮点指针参数需要存储在不同的位置）有很多改进调用约定的地方。但是不可避免地不足以描述编译器可能产生的所有调用约定。因此，angr 支持通过描述参数与返回值的位置自定义调用约定
 
-angr's abstraction of calling conventions is called SimCC.
-You can construct new SimCC instances through the angr object factory, with `b.factory.cc(...)`.
+angr 对调用约定的抽象是 SimCC。
+可以通过 angr 的对象工厂来构建一个新的 SimCC 示例，例如 `b.factory.cc(...)`
 
-- Pass as the `args` keyword argument a list of argument storage locations
-- Pass as the `ret_val` keyword argument the location where the return value should be stored
-- Pass as the `func_ty` keyword argument a SymType for the function prototype.
-- Pass it none of these things to use a sane default for the current architecture!
+- 使用参数 `args` 传递参数存储位置的列表
+- 使用参数 `ret_val` 传递返回值存储位置的列表
+- 使用参数 `func_ty` 传递函数原型的 SymType
+- 不使用参数则默认为当前架构的默认值
 
-To specify a value location for the `args` or `ret_val` parameters, use instances of the `SimRegArg` or `SimStackArg` classes.
-You can find them in the factory - `b.factory.cc.Sim*Arg`.
-Register arguments should be instantiated with the name of the register you're storing the value in, and the size of the register in bytes.
-Stack arguments should be instantiated with the offset from the stack pointer *at the time of entry into the function* and the size of the storage location, in bytes.
+要指定 `args` 或 `ret_val` 参数值的位置，要使用 `SimRegArg` 或者 `SimStackArg` 类的实例。
+也可以在工厂中实现 `b.factory.cc.Sim*Arg`。
+寄存器参数应该使用正在存储值的寄存器的名字与寄存器的大小（以字节为单位）来进行实例化。
+使用*进入函数时*堆栈指针的偏移量和存储位置的大小（以字节为单位）来实例化堆栈参数
 
-Once you have a SimCC object, you can use it along with a SimState object to extract or store function arguments more cleanly.
-Take a look at the [API documentation](http://angr.io/api-doc/angr.html#angr.calling_conventions.SimCC) for details.
-Alternately, you can pass it to an interface that can use it to modify its own behavior, like `b.factory.call_state`, or...
+一旦创建了一个 SimCC 对象，就可以和 SimState 对象联合使用来提取/存储函数参数。详见
+ [API 文档](http://angr.io/api-doc/angr.html#angr.calling_conventions.SimCC)。
+或者可以传递给一个接口，接口可以使用这个对象来修改它自身的行为，比如 `b.factory.call_state`
 
-## Callables
+## 可调用对象
 
 <a name=callables></a>
 
-Callables are a Foreign Functions Interface (FFI) for symbolic execution.
-Basic callable usage is to create one with `myfunc = b.factory.callable(addr)`, and then call it! `result = myfunc(args, ...)`
-When you call the callable, angr will set up a `call_state` at the given address, dump the given arguments into memory, and run a `path_group` based on this state until all the paths have exited from the function.
-Then, it merges all the result states together, pulls the return value out of that state, and returns it.
+可调用对象是符号执行的外部函数接口（FFI）。
+简单可调用对象的用法：先使用 `myfunc = b.factory.callable(addr)` 创建一个可调用对象。之后就可以使用 `result = myfunc(args, ...)` 调用它了！
+当你调用可调用对象时，angr 会在给定的地址设置一个 `call_state`，将给定的参数转储到内存中。然后基于这个 state 启动 `path_group`，直到所有路径都从函数中退出。将所有的结果状态合并到一起，将返回值从 state 中提取出来并返回
 
-All the interaction with the state happens with the aid of a `SimCC`, to tell where to put the arguments and where to get the return value.
-By default, it uses a sane default for the architecture, but if you'd like to customize it, you can pass a `SimCC` object in the `cc` keyword argument when constructing the callable.
+与 state 的所有交互都是通过 `SimCC` 来辅助完成的，参数在哪以及哪里获得返回值都是。默认情况下，在不同的架构中使用了一个合理的默认值。但如果想自定义，则可以在构建可调用对象时为 `SimCC` 对象传递参数 `cc` 
 
-You can pass symbolic data as function arguments, and everything will work fine.
-You can even pass more complicated data, like strings, lists, and structures as native python data (use tuples for structures), and it'll be serialized as cleanly as possible into the state.
-If you'd like to specify a pointer to a certain value, you can wrap it in a `PointerWrapper` object, available as `b.factory.callable.PointerWrapper`.
-The exact semantics of how pointer-wrapping work are a little confusing, but they can be boiled down to "unless you specify it with a PointerWrapper or a specific SimArrayType, nothing will be wrapped in a pointer automatically unless it gets to the end and it hasn't yet been wrapped in a pointer yet and the original type is a string, array, or tuple."
-The relevant code is actually in SimCC - it's the `setup_callsite` function.
+可以为函数参数传递符号数据，这是可以正常工作的。
+甚至可以传递更为复杂的数据，比如字符串、列表、结构体，甚至是 Python 原生数据结构（元组作为结构体）。这些都可以轻松地序列化到 state 中。
+如果你想指定一个指针到一定值，就可以在 `PointerWrapper` 对象上“装饰”它，例如 `b.factory.callable.PointerWrapper`。
+对指针实现的装饰确实容易令人感到困惑，但是可以归结为“除非使用 PointerWrapper 或者特定的 SimArrayType 来指定、它们还未被包装在指针中、原始数据类型为字符串、数组或元组，否则指针中什么都不会被自动“装饰”，”
 
-If you don't care for the actual return value of the call, you can say `func.perform_call(arg, ...)`, and then the properties `func.result_state` and `func.result_path_group` will be populated.
-They will actually be populated even if you call the callable normally, but you probably care about them more in this case!
+如果不关心调用的实际返回值，可以使用 `func.perform_call(arg, ...)`，属性 `func.result_state` 和 `func.result_path_group` 都会被填充。
+即使正常调用一个可调用对象，这些属性也会被填充，但是这种情况下可能会更关心！
diff --git a/docs/surveyors.md b/docs/surveyors.md
index 1880025..1d72e50 100644
--- a/docs/surveyors.md
+++ b/docs/surveyors.md
@@ -1,23 +1,16 @@
-# Symbolic Execution - Surveyors
+# 符号执行 - Surveyors
 
-At heart, angr is a symbolic execution engine.
-angr exposes a standard way to write and perform dynamic symbolic execution: the `Surveyor` class.
-A `Surveyor` is the *engine* that drives symbolic execution: it tracks what paths are active, identifies which paths to step forward and which paths to prune, and optimizes resource allocation.
+本质上， `angr` 是一个符号执行引擎。 `angr` 公开了一种标准的方式去编写和执行动态符号执行：`Surveyor` 类。 `Surveyor` 是驱动符号执行的引擎：它跟踪哪些路径是活动的，确定哪些路径可以继续前进，哪些路径舍弃，优化资源分配。
 
-/!\ `Surveyors` are an old API that is rather unwieldy. It's recommended to use [PathGroups](./pathgroups.md) instead. /!\
+/!\ `Surveyors` 是一个相当笨拙的 `API` ,建议使用 [PathGroups](./pathgroups.md) 。 /!\
 
-The `Surveyor` class is not meant to be used directly.
-Rather, it should be subclassed by developers to implement their own analyses.
-That being said, the most common symbolic analysis (i.e., "explore from A to B, trying to avoid C") has already been implemented in the `Explorer` class.
+`Surveyor` 类并不是直接使用的。相反，它由开发人员细分子类去实现不同功能的分析。也就是说，最常见的符号执行已经在 `Explorer` 类里实现了。
 
 ## Explorer
 
-`angr.surveyors.Explorer` is a `Surveyor` subclass that implements symbolic exploration.
-It can be told where to start, where to go, what to avoid, and what paths to stick to.
-It also tries to avoid getting stuck in loops.
+`angr.surveyors.Explorer` 是 `Surveyor` 实现符号执行的一个子类。它可以被告知从哪里开始，到哪里，避免什么及走什么路线。它也试图避免陷入循环。
 
-In the end, one cannot be told what the `Explorer` is.
-You have to see it for yourself:
+很难去解释 `Explorer` 是什么，你必须自己去理解：
 
 ```python
 >>> import angr
@@ -54,9 +47,7 @@ You have to see it for yourself:
 >>> print "%d paths deadended" % len(e.deadended)
 ```
 
-So far, everything we have discussed applies to all `Surveyors`.
-However, the nice thing about an Explorer is that you can tell it to search for, or avoid certain blocks.
-For example, in the `fauxware` sample, we can try to find the "authentication success" function while avoiding the "authentication failed" function.
+到目前为止，我们所讨论的都适用于 `Surveyors` 。`Explorer` 的另一个好处是可以去搜索和避免某些块。例如，在 `fauxware` 例子中，我们可以去搜寻 ` "authentication success" ` 函数并且避免 `"authentication failed"` 函数。
 
 ```python
 # This creates an Explorer that tries to find 0x4006ed (successful auth),
@@ -72,7 +63,7 @@ For example, in the `fauxware` sample, we can try to find the "authentication su
 >>> print "Avoided %d paths" % len(e.avoided)
 ```
 
-Some helper properties are provided for easier access to paths from IPython:
+提供了一些辅助属性可以更容易的访问 `IPython` :
 
 ```python
 >>> print "The first found path is", e._f
@@ -81,8 +72,7 @@ Some helper properties are provided for easier access to paths from IPython:
 
 ## Caller
 
-The `Caller` is a surveyor that handles calling functions to make it easier to figure out what the heck they do.
-It can be used as so:
+`Caller` 是一个负责处理指定函数的 `surveyor` 以便更容易弄清楚函数做了什么，它可以这样使用：
 
 ```python
 # load fauxware
@@ -112,21 +102,12 @@ It can be used as so:
 
 # you can see the secret password "SOSNEAKY" in the first tuple!
 ```
-
-Caller is a pretty powerful tool. Check out the comments on the various functions for more usage info! HOWEVER, there is a much easier tool you can use to call functions, called `callable`. This is described [elsewhere in the docs](./structured_data.md#callables).
+`Caller` 是一个非常强大的工具。查看函数的注释可以获得更多使用信息。然而有一个更简单的方法去调用其他函数，称为 `callable`。在其他文档有[描述](./structured_data.md#callables)。
 
 ## Interrupting Surveyors
 
-A surveyor saves its internal state after every tick.
-In IPython, you should be able to interrupt a surveyor with `Ctrl-C`, and then check what results it has so far, but that's a pretty ugly way of doing it.
-There are two official ways of doing this cleanly: `SIGUSR1` and `SIGUSR2`.
+`surveyor` 在每一次滴答后会保存它的内部状态。在 `IPython` 中，你可以使用 `Ctrl-C` 去中断一个 `surveyor` ,然后去检查到目前为止的结果，但这是一种很丑陋的方法。有两种正式的方式可以做这件事情：`SIGUSR1` 和 `SIGUSR2`。
 
-If you send `SIGUSR1` to a python process running a surveyor, it causes the main loop in `Surveyor.run()` to terminate at the end of the current `Surveyor.step()`.
-You can then analyze the result.
-To continue running the surveyor, call `angr.surveyor.resume_analyses()` (to clear the "signalled" flag) and then call the surveyor's `run()` function.
-Since `SIGUSR1` causes `run()` to return, this is rarely useful in a scripted analysis, as the rest of the program will run after `run()` returns.
-Instead, `SIGUSR1` is meant to provide a clean alternative to `Ctrl-C`.
+如果你给一个运行着 `surveyor` 的 `python` 进程发送 `SIGUSR1` ，将会导致 `Surveyor.run()`的主循环在当前的 `surveyor.step()` 结束时终止。你可以分析结果。为了继续运行 `surveyor` ,你可以调用 `function.angr.surveyor.resume_analyses()` （清除 `"signalled"` 标志） 并且调用 `surveyor` 的 `run` 函数。  因为`SIGUSR1` 导致 `run()` 返回，所以在脚本分析中很少用，因为程序的其他部分将在 `run()` 返回之后继续运行。相反，`SIGUSR1` 是为 `ctrl - c` 提供一个的替代。
 
-Sending SIGUSR2 to the python process, on the other hand, causes `run()` to invoke an `ipdb` breakpoint after every `step()`.
-This allows you to debug, then continue your program.
-Make sure to run `angr.surveyor.disable_singlestep()` before continuing to clear the "signalled" flag.
+在另一方面，如果给 `python` 进程发送 `SIGUSR2`，将会 `run()` 在每一步执行之后调用 `ipdb` 断点。这允许你去调试，继续运行你的程序。在继续运行前请调用 `angr.surveyor.disable_singlestep()` 函数去清除 `"signalled"` 标志。
diff --git a/docs/symbolic.md b/docs/symbolic.md
index 270d3da..0ba3c743 100644
--- a/docs/symbolic.md
+++ b/docs/symbolic.md
@@ -1,11 +1,9 @@
-Symbolic Execution
+符号执行
 ==================
 
-Symbolic execution allows at a time in emulation to determine for a branch all conditions necessary to take a branch or not.
-Every variable is represented as a symbolic value, and each branch as a constraint.
-Thus, symbolic execution allows us to see which conditions allows the program to go from a point A to a point B, by resolving the constraints.
+符号执行用来在仿真时确定分支所需要的条件来执行分支。每个变量都可以表示为一个符号值，每个分支都是一个约束。
+因此，符号执行赋予我们通过约束求解来查看满足哪些条件就可以让程序从 A 点到 B 点的能力。
 
-If you've read this far, you can see how the components of angr work together to make this possible.
-Read on to learn about how to make the leap from tools to results.
+如果您已经阅读了这么多，您应该已经了解了 angr 的各部分组件是如何协同工作的。继续阅读可以了解更多。
 
-TODO: A real introduction to the concept of symbolic execution.
+TODO: 符号执行真正概念的介绍
diff --git a/docs/toplevel.md b/docs/toplevel.md
index a643e40..ce2240e 100644
--- a/docs/toplevel.md
+++ b/docs/toplevel.md
@@ -1,22 +1,20 @@
-# Core Concepts
+# 核心概念
 
-Before getting started with angr, you'll need to have a basic overview of some fundamental angr concepts and how to construct some basic angr objects.
-We'll go over this by examining what's directly available to you after you've loaded a binary!
+在使用 angr 之前，您需要了解一些 angr 的基本概念，以及如果构建一些 angr 的基本对象。
+在您装载了二进制程序后，我们将会把那些可以直接展现给你的功能介绍一番！
 
-Your first action with angr will always be to load a binary into a _project_. We'll use `/bin/true` for these examples.
+首先要做的永远都是将一个二进制程序装载进 _project_ 里，我们使用 `/bin/true` 作为示例程序
 
 ```python
 >>> import angr
 >>> proj = angr.Project('/bin/true')
 ```
 
-A project is your control base in angr.
-With it, you will be able to dispatch analyses and simulations on the executable you just loaded.
-Almost every single object you work with in angr will depend on the existence of a project in some form.
+project 是 angr 的基石。利用它，你可以对刚装载的可执行程序进行分析和模拟。几乎所有在 angr 中的可操纵的对象都在某种程度上依赖 project
 
-## Basic properties
+## 基本属性
 
-First, we have some basic properties about the project: its CPU architecture, its filename, and the address of its entry point.
+首先，我们有一些关于 project 的基本属性：CPU 架构、文件名、入口点地址
 
 ```python
 >>> import monkeyhex # this will format numerical results in hexadecimal
@@ -28,19 +26,19 @@ First, we have some basic properties about the project: its CPU architecture, it
 '/bin/true'
 ```
 
-* _arch_ is an instance of an `archinfo.Arch` object for whichever architecture the program is compiled, in this case little-endian amd64. It contains a ton of clerical data about the CPU it runs on, which you can peruse [at your leisure](https://github.com/angr/archinfo/blob/master/archinfo/arch_amd64.py). The common ones you care about are `arch.bits`, `arch.bytes` \(that one is a `@property` declaration on the [main `Arch` class](https://github.com/angr/archinfo/blob/master/archinfo/arch.py)\), `arch.name`, and `arch.memory_endness`.
-* _entry_ is the entry point of the binary!
-* _filename_ is the absolute filename of the binary. Riveting stuff!
+* _arch_ 是一个 `archinfo.Arch` 对象的实例，用于表示被编译程序所面向的任意架构，此时是 little-endian amd64。它包含许多关于程序运行所在 CPU 的信息，详情可以参阅 [这段代码](https://github.com/angr/archinfo/blob/master/archinfo/arch_amd64.py) 来进行细致的了解。通常我们关心的往往是 `arch.bits`， `arch.bytes` \(这是一个在 [main `Arch` class](https://github.com/angr/archinfo/blob/master/archinfo/arch.py) 中 `@property` 的声明\)， `arch.name` 和 `arch.memory_endness`
+* _entry_ 是二进制程序的入口点
+* _filename_ 是二进制程序的绝对路径文件名
 
-## The loader
+## 装载器
 
-Getting from a binary file to its representation in a virtual address space is pretty complicated! We have a module called CLE to handle that. CLE's result, called the loader, is available in the `.loader` property. We'll get into detail on how to use this [soon](./loading.md), but for now just know that you can use it to see the shared libraries that angr loaded alongside your program and perform basic queries about the loaded address space.
+将二进制文件映射到虚拟地址空间表示是相当复杂的！我们开发了一个叫做 CLE 的模块来处理二进制文件的装载。CLE 完成装载后的对象有一个 `.loader` 属性。我们可以在 [文件](./loading.md) 看到其进一步的使用细节，但现在我们只需要知道通过它可以看到 angr 装载的共享库，以及对装载的地址空间进行基本的查询
 
 ```python
 >>> proj.loader
 <Loaded true, maps [0x400000:0x5004000]>
 
->>> proj.loader.shared_objects # may look a little different for you!
+>>> proj.loader.shared_objects # 也许你看到的和示例不相同
 {'ld-linux-x86-64.so.2': <ELF Object ld-2.24.so, maps [0x2000000:0x2227167]>,
  'libc.so.6': <ELF Object libc-2.24.so, maps [0x1000000:0x13c699f]>}
 
@@ -49,30 +47,30 @@ Getting from a binary file to its representation in a virtual address space is p
 >>> proj.loader.max_addr
 0x5004000
 
->>> proj.loader.main_object  # we've loaded several binaries into this project. Here's the main one!
+>>> proj.loader.main_object  # 我们装载了一系列二进制程序到 project 中，这是关键的一个！
 <ELF Object true, maps [0x400000:0x60721f]>
 
->>> proj.loader.main_object.execstack  # sample query: does this binary have an executable stack?
+>>> proj.loader.main_object.execstack  # 示例查询：该二进制程序是否拥有可执行栈？
 False
->>> proj.loader.main_object.pic  # sample query: is this binary position-independent?
+>>> proj.loader.main_object.pic  # 示例查询：该二进制程序是否是地址无关的？
 True
 ```
 
-## The factory
+## 工厂
 
-There are a lot of classes in angr, and most of them require a project to be instantiated. Instead of making you pass around the project everywhere, we provide `project.factory`, which has several convenient constructors for common objects you'll want to use frequently.
+angr 中有许多类，其中大多数类都需要进行实例化。为了避免您需要四处查阅源码，我们提供了 `project.factory`，它提供了一系列您频繁使用的公共对象的构造函数。
 
-This section will also serve as an introduction to several basic angr concepts. Strap in!
+本节还将介绍几个基本的 angr 概念，坐稳扶好！
 
-#### Blocks
+#### 基本块
 
-First, we have `project.factory.block()`, which is used to extract a [basic block](https://en.wikipedia.org/wiki/Basic_block) of code from a given address. This is an important fact - _angr analyzes code in units of basic blocks._ You will get back a Block object, which can tell you lots of fun things about the block of code:
+首先，我们提供 `project.factory.block()` 函数在给定的地址提取代码对应的 [基本块](https://en.wikipedia.org/wiki/Basic_block) 。基本块很重要，因为 - _angr 以基本块为分析代码的基本单位_。执行后你会得到一个 Block 对象，它可以提供关于代码基本块很多有趣的信息：
 
 ```python
 >>> block = proj.factory.block(proj.entry) # lift a block of code from the program's entry point
 <Block for 0x401670, 42 bytes>
 
->>> block.pp()                          # pretty-print a disassembly to stdout
+>>> block.pp()                      # 优雅地输出反汇编
 0x401670:       xor     ebp, ebp
 0x401672:       mov     r9, rdx
 0x401675:       pop     rsi
@@ -85,34 +83,34 @@ First, we have `project.factory.block()`, which is used to extract a [basic bloc
 0x40168d:       lea     rdi, [rip - 0xd4]
 0x401694:       call    qword ptr [rip + 0x205866]
 
->>> block.instructions                  # how many instructions are there?
+>>> block.instructions                  # 基本块中有多少指令？
 0xb
->>> block.instruction_addrs             # what are the addresses of the instructions?
+>>> block.instruction_addrs             # 指令的地址？
 [0x401670, 0x401672, 0x401675, 0x401676, 0x401679, 0x40167d, 0x40167e, 0x40167f, 0x401686, 0x40168d, 0x401694]
 ```
 
-Additionally, you can use a Block object to get other representations of the block of code:
+此外，您还可以使用 Block 对象来得到基本块的其他表示形式：
 
 ```python
->>> block.capstone                       # capstone disassembly
+>>> block.capstone                       # capstone 反汇编
 <CapstoneBlock for 0x401670>
->>> block.vex                            # VEX IRSB (that's a python internal address, not a program address)
+>>> block.vex                            # VEX IRSB （这是一个 Python 内部地址，不是一个程序地址）
 <pyvex.block.IRSB at 0x7706330>
 ```
 
-#### States
+#### 状态
 
-Here's another fact about angr - the `Project` object only represents an "initialization image" for the program. When you're performing execution with angr, you are working with a specific object representing a _simulated program state_ - a `SimState`. Let's grab one right now!
+这是 angr 另一个重要的概念 - `Project` 对象只表示程序的“初始镜像”。当您使用 angr 装载程序时，其实使用的是一个特定的、表示 _simulated program state_ 的对象 - `SimState`。
 
 ```python
 >>> state = proj.factory.entry_state()
 <SimState @ 0x401670>
 ```
 
-A SimState contains a program's memory, registers, filesystem data... any "live data" that can be changed by execution has a home in the state. We'll cover how to interact with states in depth later, but for now, let's use `state.regs`and `state.mem` to access the registers and memory of this state:
+SimState 中提供程序需要的内存、寄存器、文件系统数据等任何可以在程序执行中被改变的“实时数据”。稍后会介绍如何深入交互操作，现在我们使用 `state.regs` 和 `state.mem` 来访问寄存器和内存：
 
 ```python
->>> state.regs.rip        # get the current instruction pointer
+>>> state.regs.rip        # 得到当前指令指针
 <BV64 0x401670>
 >>> state.regs.rax
 <BV64 0x1c>
@@ -120,18 +118,18 @@ A SimState contains a program's memory, registers, filesystem data... any "live
 <BV32 0x8949ed31>
 ```
 
-Those aren't python ints! Those are _bitvectors_. Python integers don't have the same semantics as words on a CPU, e.g. wrapping on overflow, so we work with bitvectors, which you can think of as an integer as represented by a series of bits, to represent CPU data in angr. Note that each bitvector has a `.length` property describing how wide it is in bits.
+这些不是 Python 的 ints！这些是 _bitvectors_。Python 中的整数和 CPU 中（e.g. wrapping on overflow）并非具有相同的语义，所以我们使用 bitvectors，您可以视其为一系列比特位表示的整数，用以表示 angr 中的 CPU 信息。请注意，每个 bitvector 都具有 `.length` 属性来描述其比特位的宽度
 
-We'll learn all about how to work with them soon, but for now, here's how to convert from python ints to bitvectors and back again:
+我们将会了解它们如何协同工作，但现在我们首先了解如何将 Python 中的正如转换成 bitvectors 以及如何转换回来：
 
 ```python
->>> bv = state.solver.BVV(0x1234, 32)       # create a 32-bit-wide bitvector with value 0x1234
+>>> bv = state.solver.BVV(0x1234, 32)       # 使用 0x1234 创建一个 32 位宽的 bitvector
 <BV32 0x1234>                               # BVV stands for bitvector value
->>> state.solver.eval(bv)                # convert to python int
+>>> state.solver.eval(bv)                # 转换为 Python 中的 int 型
 0x1234
 ```
 
-You can store these bitvectors back to registers and memory, or you can directly store a python integer and it'll be converted to a bitvector of the appropriate size:
+您可以将 bitvectors 存回寄存器和内存，或者直接存一个 Python 整型数，它也可以直接转换成合适大小的 bitvector：
 
 ```python
 >>> state.regs.rsi = state.solver.BVV(3, 64)
@@ -143,34 +141,32 @@ You can store these bitvectors back to registers and memory, or you can directly
 <BV64 0x4>
 ```
 
-The `mem` interface is a little confusing at first, since it's using some pretty hefty python magic. The short version of how to use it is:
+  起初，因为使用了一些 Python 中的奇技淫巧，`mem` 接口有点混乱。简化版本如下：
 
-* Use array\[index\] notation to specify an address
-* Use `.<type>` to specify that the memory should be interpreted as &lt;type&gt; \(common values: char, short, int, long, size_t, uint8_t, uint16_t...\)
-* From there, you can either:
-  * Store a value to it, either a bitvector or a python int
-  * Use `.resolved` to get the value as a bitvector
-  * Use `.concrete` to get the value as a python int
+* 使用 array\[index\] 表示法来指定一个地址
+* 使用 `.<type>` 来指定内存类型的 &lt;类型&gt; \(common values: char, short, int, long, size_t, uint8_t, uint16_t...\)
+* 从现在起，你可以：
+  * 存储一个数，不论是 bitvector 还是 Python 中的整型数
+  * 使用 `.resolved` 来获取一个 bitvector 型的数
+  * 使用 `.concrete` 来获取一个 Python 整型的数
 
-There are more advanced usages that will be covered later!
+更高级的用法将会在后面介绍！
 
-Finally, if you try reading some more registers you may encounter a very strange looking value:
+最后，如果想要更多关于寄存器的信息，也许会遇到一个非常奇怪的值：
 
 ```python
 >>> state.regs.rdi
 <BV64 reg_48_11_64{UNINITIALIZED}>
 ```
 
-This is still a 64-bit bitvector, but it doesn't contain a numerical value.
-Instead, it has a name!
-This is called a _symbolic variable_ and it is the underpinning of symbolic execution.
-Don't panic! We will discuss all of this in detail exactly two chapters from now.
+该值仍然是一个 64 位的 bitvector，但它没有包含十六进制数据。相反它有一个名字，这被称为 _符号变量_，它是符号执行的基础。
+别急，我们会详细讨论其技术细节的！
 
-#### Simulation Managers
+#### 模拟管理器
 
-If a state lets us represent a program at a given point in time, there must be a way to get it to the _next_ point in time. A simulation manager is the primary interface in angr for performing execution, simulation, whatever you want to call it, with states. As a brief introduction, let's show how to tick that state we created earlier forward a few basic blocks.
+如果 state 让我们可以找到程序在某个时刻的代表，那就必须有方法可以得到 _next_ 下一个时间点的位置。模拟管理器是 angr 中用于执行、模拟的主要接口，无论调用它是为了什么，只要和 state 有联系，就与它有关。作为简要介绍，我们将会展示一下如何 tick 我们之前创建的几个基本块的 state
 
-First, we create the simulation manager we're going to be using. The constructor can take a state or a list of states.
+首先，创建我们要使用的模拟管理器。构造函数可以使用 state 或者一个 state 列表
 
 ```python
 >>> simgr = proj.factory.simgr(state) # TODO: change name before merge
@@ -179,30 +175,30 @@ First, we create the simulation manager we're going to be using. The constructor
 [<SimState @ 0x401670>]
 ```
 
-A simulation manager can contain several _stashes_ of states. The default stash, `active`, is initialized with the state we passed in. We could look at `simgr.active[0]` to look at our state some more, if we haven't had enough!
+模拟管理器可以包含多个 _stashes_ 的 state。默认的存储空间， `active` 是用我们传入的 state 进行初始化的。如果觉得还不够，可以进一步查看 `simgr.active[0]` 来得到更进一步的 state 信息！
 
-Now... get ready, we're going to do some execution.
+准备完成，我们准备要执行了！
 
 ```python
 >>> simgr.step()
 ```
 
-We've just performed a basic block's worth of symbolic execution! We can look at the active stash again, noticing that it's been updated, and furthermore, that it has **not** modified our original state. SimState objects are treated as immutable by execution - you can safely use a single state as a "base" for multiple rounds of execution.
+我们刚刚用符号执行的方法执行了一个基本块！我们可以再次查看 active stash，可以发现它已经改变了，而且**没有**修改我们的原始 state。通过执行将 SimState 对象视为不可变，你可以安全地使用一个单独的 state 作为多轮执行的“基底”
 
 ```python
 >>> simgr.active
 [<SimState @ 0x1020300>]
 >>> simgr.active[0].regs.rip                 # new and exciting!
 <BV64 0x1020300>
->>> state.regs.rip                           # still the same!
+>>> state.regs.rip                           # 仍然相同！
 <BV64 0x401670>
 ```
 
-`/bin/true` isn't a very good example for describing how to do interesting things with symbolic execution, so we'll stop here for now.
+`/bin/true` 不是用来展示符号执行能力的好例子，所以我们点到为止
 
-## Analyses
+## 分析
 
-angr comes pre-packaged with several built-in analyses that you can use to extract some fun kinds of information from a program. Here they are:
+angr 内置了几个预先打包好的分析工具，您可以使用它从程序中提取有用的信息：
 
 ```
 >>> proj.analyses.            # Press TAB here in ipython to get an autocomplete-listing of everything:
@@ -216,29 +212,28 @@ angr comes pre-packaged with several built-in analyses that you can use to extra
  proj.analyses.CFGFast              proj.analyses.Reassembler
 ```
 
-A couple of these are documented later in this book, but in general, if you want to find how to use a given analysis, you should look in the [api documentation. ](http://angr.io/api-doc/angr.html?highlight=cfg#module-angr.analysis)As an extremely brief example: here's how you construct and use a quick control-flow graph:
+这些工具有几个将会在后面提到，但一般来说，如果您要查找如何使用给定的分析工具，您应该查看 [API 文档](http://angr.io/api-doc/angr.html?highlight=cfg#module-angr.analysis)。一个非常简单的例子：如何构建快速控制流图：
 
 ```python
-# Originally, when we loaded this binary it also loaded all its dependencies into the same virtual address  space
-# This is undesirable for most analysis.
+# 最初，当我们装载这个二进制程序时，会将所有的依赖项都装载到相同的虚拟地址空间中，在大多数分析场景下这是不可取的
 >>> proj = angr.Project('/bin/true', auto_load_libs=False)
 >>> cfg = proj.analyses.CFGFast()
 <CFGFast Analysis Result at 0x2d85130>
 
 # cfg.graph is a networkx DiGraph full of CFGNode instances
-# You should go look up the networkx APIs to learn how to use this!
+# 您应该查看 networkx 的 API 来学习如何使用它！
 >>> cfg.graph
 <networkx.classes.digraph.DiGraph at 0x2da43a0>
 >>> len(cfg.graph.nodes())
 951
 
-# To get the CFGNode for a given address, use cfg.get_any_node
+# 想要得到某一地址的 CFGNode 要使用 cfg.get_any_node
 >>> entry_node = cfg.get_any_node(proj.entry)
 >>> len(list(cfg.graph.successors(entry_node)))
 2
 ```
 
-## Now what?
+## 然后呢？
 
-Having read this page, you should now be aquainted with several important angr concepts: basic blocks, states, bitvectors, simulation managers, and analyses. You can't really do anything interesting besides just use angr as a glorified debugger, though! Keep reading, and you will unlock deeper powers...
+看完本页后，您应该了解了 angr 的几个基本概念：基本块，state，bitvectors，模拟管理器与分析工具。尽管如此，此刻您仍不能利用 angr 真正完成一些有趣的事情，请继续阅读！将会解锁更强大的力量...
 
