diff --git a/docs/analyses/backward_slice.md b/docs/analyses/backward_slice.md
index 02ed425..a77042b 100644
--- a/docs/analyses/backward_slice.md
+++ b/docs/analyses/backward_slice.md
@@ -67,12 +67,11 @@ BackwardSlice (to [(<CFGNode exit (0x10000a0) [0]>, -1)])
 
 ## Using The `BackwardSlice` Object
 
-Before go ahead and using `BackwardSlice` object, you should be noticed that the design of this class is pretty arbitrary right now, and  it is by no means to be stable in the near future.
-I’ll try my best to keep this documentation updated when a refactoring/redesigning occurs.
+Before you go ahead and use `BackwardSlice` object, you should notice that the design of this class is fairly arbitrary right now, and it is still subject to change in the near future. We’ll try our best to keep this documentation up-to-date.
 
 ### Members
 
-After construction, a `BackwardSlice` has the following members that describe a program slice:
+After construction, a `BackwardSlice` has the following members which describe a program slice:
 
 | Member             | Mode     | Meaning                                                                                                                               |
 | -------            | -------- | -------                                                                                                                               |
diff --git a/docs/analyses/cfg_accurate.md b/docs/analyses/cfg_accurate.md
index 668c620..fe4bb45 100644
--- a/docs/analyses/cfg_accurate.md
+++ b/docs/analyses/cfg_accurate.md
@@ -85,7 +85,7 @@ For example, the `puts()` function above will be analyzed with the following con
 | 2 | Two callers, plus callee | `alpha>error>puts` `main>alpha>puts` `beta>error>puts` `main>beta>puts` |
 | 3 | Three callers, plus callee | `main>alpha>error>puts` `main>alpha>puts` `main>beta>error>puts` `main>beta>puts` |
 
-The upside of increasing the context sensitivity level is that more information can be gleamed from the CFG.
+The upside of increasing the context sensitivity level is that more information can be gleaned from the CFG.
 For example, with context sensitivity of 1, the CFG will show that, when called from `alpha`, `puts` returns to `alpha`, when called from `error`, `puts` returns to `error`, and so forth.
 With context sensitivity of 0, the CFG simply shows that `puts` returns to `alpha`, `beta`, and `error`.
 This, specifically, is the context sensitivity level used in IDA.
diff --git a/docs/analyses/dfg.md b/docs/analyses/dfg.md
index 5794e02..f1967e1 100644
--- a/docs/analyses/dfg.md
+++ b/docs/analyses/dfg.md
@@ -18,12 +18,11 @@ The following options are also available:
 | cfg     | If you already have a CFG available you can provide it instead of rebuilding it. |
 | annocfg | An annotated CFG that can be built from an BackwardSlice to construct only the DFGs from the basic block that are present in the backward slice. |
 
-Each basic block, or node, in the CFG, which is not a SimProcedure, has its DFG built available in the dict `d.dfgs`
+Each basic block, or node, in the CFG, which is not a SimProcedure, has its DFG available in the dict `d.dfgs`
 where the key is the address of the basic block.
 
-Every DFG constructed is a is a [NetworkX](https://networkx.github.io/) di-graph.
-This means that all of the normal NetworkX APIs are available, for example you can print all the input edges of a node
-in a DFG:
+Every DFG constructed is a [NetworkX](https://networkx.github.io/) di-graph.
+This means that all of the normal NetworkX APIs are available, for example you can print all the input edges of a node in a DFG:
 
 ```python
 >>> bbl_addr, dfg = d.dfgs.popitem()
diff --git a/docs/faq.md b/docs/faq.md
index a060cb5..c492ced 100644
--- a/docs/faq.md
+++ b/docs/faq.md
@@ -41,8 +41,8 @@ level for the parent module. For example, `logging.getLogger('angr.analyses').se
 will make the CFG, as well as all other analyses, log at the INFO level.
 
 ### Automatic log settings
-If you're using angr through ipython, you can add a startup script in your
-ipython profile to set various logging levels.
+If you're using angr through IPython, you can add a startup script in your
+IPython profile to set various logging levels.
 
 
 ## Why is a CFG taking forever to construct?
diff --git a/docs/loading.md b/docs/loading.md
index 488a6c1..3900d32 100644
--- a/docs/loading.md
+++ b/docs/loading.md
@@ -75,9 +75,13 @@ By default, CLE will attempt to load all the dependencies of the main binary (e.
 
 ## Loading Options
 
-Loading options can be passed to Project (which in turn will pass it to CLE). 
+Loading options can be passed to Project (which in turn will pass it to CLE) using the `load_options` kwarg:
 
-CLE expects a dict as a set of parameters. Parameters which must be applied to libraries which 
+```python
+>>> b = angr.Project("/bin/true", load_options=dict(auto_load_libs=False)
+```
+
+CLE expects a dict as a set of parameters. Parameters which must be applied to libraries which
 are not the target binary must be passed through the lib_opts parameter in the following form:
 ```python
 load_options = {'main_opts':{options0}, 'lib_opts': {libname1:{options1}, path2:{options2}, ...}}
@@ -114,7 +118,7 @@ etc.
 # A list of paths we can additionally search for shared libraries
 >>> load_options['custom_ld_path'] = ['/my/fav/libs']
 
-# Whether libraries with different version numbers in the filename will be considered equivilant, for example libc.so.6 and libc.so.0
+# Whether libraries with different version numbers in the filename will be considered equivalent, for example libc.so.6 and libc.so.0
 >>> load_options['ignore_import_version_numbers'] = False
 
 # The alignment to use for rebasing shared objects
diff --git a/docs/paths.md b/docs/paths.md
index 63b4d34..85bb4ee 100644
--- a/docs/paths.md
+++ b/docs/paths.md
@@ -101,7 +101,7 @@ Here is a list of the properties in the path history:
 | Path.guards     | The guard conditions that had to be satisfied in order to take the branch listed in Path.targets |
 | Path.jumpkinds  | The type of the exit from each basic block we took, as VEX struct strings |
 | Path.events     | A log of the events that have happened in symbolic execution |
-| Path.actions    | A filtering of Path.events to only include the actions taken by the exeution engine. See below. |
+| Path.actions    | A filtering of Path.events to only include the actions taken by the execution engine. See below. |
 
 Here are the different types of jumpkinds:
 
@@ -168,7 +168,7 @@ To handle this, we allow the creation of a path at any point in the program:
 >>> assert p.addr == 0x800f000
 ```
 
-At this point, all memory, registers, and so forth of the path are blank. In a nutshell, this means that they are fully symbolic and unconstrained, and execution can procede from this point as an overapproximation of what could happen on a real CPU. If you have outside knowledge about what the state should look like at this point, you can craft the blank state into a more precise description of machine state by adding constraints and setting the contents of memory, registers, and files.
+At this point, all memory, registers, and so forth of the path are blank. In a nutshell, this means that they are fully symbolic and unconstrained, and execution can proceed from this point as an over-approximation of what could happen on a real CPU. If you have outside knowledge about what the state should look like at this point, you can craft the blank state into a more precise description of machine state by adding constraints and setting the contents of memory, registers, and files.
 
 ## SimActions Redux
 
diff --git a/docs/pipeline.md b/docs/pipeline.md
index e309018..e8a416b 100644
--- a/docs/pipeline.md
+++ b/docs/pipeline.md
@@ -2,7 +2,7 @@ Understanding the Execution Pipeline
 ====================================
 
 If you've made it this far you know that at its core, angr is a highly flexible and intensely instrumentable emulator.
-In order to get the most milage out of it, you'll want to know what happens at every step of the way when you say `path_group.step()`.
+In order to get the most mileage out of it, you'll want to know what happens at every step of the way when you say `path_group.step()`.
 
 You may want to have the angr source open to follow along with this.
 
@@ -14,13 +14,13 @@ So you've called for a step to occur. Time to begin our journey.
 
 `PathGroup.step()` function takes many optional parameters.
 The most important of these are `stash`, `n`, `until`, and `step_func`.
-`n` is used immediately - the `step()` function loops, calling the `_one_step()` function and passing on all its parameters until either `n` steps have happened or some other termination condition has occured. If `n` is not provided, it defaults to 1, unless an `until` function is provided, in which case it is 100000 - effectively infinte.
+`n` is used immediately - the `step()` function loops, calling the `_one_step()` function and passing on all its parameters until either `n` steps have happened or some other termination condition has occurred. If `n` is not provided, it defaults to 1, unless an `until` function is provided, in which case it is 100000 - effectively infinite.
 
 Before any of the termination conditions are checked, however, `step_func` is applied - this function takes the current path group and returns a new path group to replace it.
 In writing a step function, it is useful to recall that most common path group functions also return a path group - if the path group is immutable (`immutable=True` in the constructor), it is a new object, but otherwise it is the same object as before.
 
 Now, we check the termination conditions - either the stash we are operating on ("active" by default) has gone empty, or the `until` callback function returns True.
-If neiher of these conditions are satisfied, we loop back around to call `_one_step()` again.
+If neither of these conditions are satisfied, we loop back around to call `_one_step()` again.
 
 ### `_one_step()`
 
@@ -119,7 +119,7 @@ It works by making a call into `SimOS` to retrieve the SimProcedure that should
 
 `SimEngineHook` provides the hooking functionality in angr.
 It is used when a state is at an address that is hooked, and the previous jumpkind is *not* `Ijk_NoHook`.
-It simply looks up the given hook, calls `hook.instanciate()` on it in order to retrieve a `SimProcedure` instance, and then runs that procedure.
+It simply looks up the given hook, calls `hook.instantiate()` on it in order to retrieve a `SimProcedure` instance, and then runs that procedure.
 This class is a thin subclass of the `SimEngineProcedure` class present in SimuVEX, for obvious reasons.
 It takes the parameter `procedure`, which will cause `check` to always succeed, and this procedure will be used instead of the SimProcedure that would be obtained from a hook.
 
@@ -137,7 +137,7 @@ At time of writing I'm not sure if this exists anywhere but it really should.
 
 ### Engine instances
 
-In addition to parameters to the stepping process, you can also instanciate new versions of these engines!
+In addition to parameters to the stepping process, you can also instantiate new versions of these engines!
 Look at the API docs to see what options each engine can take.
 Once you have a new engine instance, you can either pass it into the step process, or directly put it into the `project.factory.engines` list for automatic use.
 
diff --git a/docs/simprocedures.md b/docs/simprocedures.md
index 6865120..12d3098 100644
--- a/docs/simprocedures.md
+++ b/docs/simprocedures.md
@@ -30,7 +30,7 @@ Program running with argc=<SAO <BV64 0x0>> and argv=<SAO <BV64 0x7fffffffffeffa0
 <PathGroup with 1 deadended>
 ```
 
-Now, whenever program execution reaches the main function, intead of executing the actual main function, it will execute this procedure!
+Now, whenever program execution reaches the main function, instead of executing the actual main function, it will execute this procedure!
 This procedure just prints out a message, and returns.
 
 Now, let's talk about what happens on the edge of this function!
@@ -38,16 +38,16 @@ When entering the function, where do the values that go into the arguments come
 You can define your `run()` function with however many arguments you like, and the SimProcedure runtime will automatically extract from the program state those arguments for you, via a [calling convention](structured_data.md#working-with-calling-conventions), and call your run function with them. Similarly, when you return a value from the run function, it is placed into the state (again, according to the calling convention), and the actual control-flow action of returning from a function is performed, which depending on the architecture may involve jumping to the link register or jumping to the result of a stack pop.
 
 It should be clear at this point that the SimProcedure we just wrote is meant to totally replace whatever function it is hooked over top of.
-In fact, the original use case for SimProcedures was replacing library funtions.
+In fact, the original use case for SimProcedures was replacing library functions.
 More on that later.
 
 ## Clarifying the Hierarchy
 
-We've been using the words Hook and SimProcedure sort of interchangably. Let's fix that.
+We've been using the words Hook and SimProcedure sort of interchangeably. Let's fix that.
 
 - `SimProcedure` is a simuvex class that describes a set of actions to take on a state.
   Its crux is the `run()` method.
-- `Hook` is an angr class that holds a SimProcedure along with information about how to instanciate it.
+- `Hook` is an angr class that holds a SimProcedure along with information about how to instantiate it.
 
 On a `Project` class, the dict `project._sim_procedures` is a mapping from address to `Hook` instances.
 (The name is a historical artifact - SimProcedure is one of the oldest classes in the angr, suite, while Hook is relatively new.)
@@ -112,7 +112,7 @@ How can we call a function in the binary and have execution resume within our Si
 There is a whole bunch of infrastructure called the "SimProcedure Continuation" that will let you do this.
 When you use `self.call(addr, args, continue_at)`, `addr` is expected to be the address you'd like to call, `args` are the arguments you'd like to call it with, and `continue_at` is the name of another method in your SimProcedure class that you'd like execution to continue at when it returns.
 This method must have the same signature as the `run()` method.
-Futhermore, you can pass the keyword argument `cc` as the calling convention that ought to be used to communicate with the callee.
+Furthermore, you can pass the keyword argument `cc` as the calling convention that ought to be used to communicate with the callee.
 
 When you do this, you finish your current step, and execution will start again at the next step at the function you've specified.
 When that function returns, it has to return to some concrete address!
@@ -126,7 +126,7 @@ There are two pieces of metadata you need to attach to your SimProcedure class i
 - Set the class variable `local_vars` to a tuple of strings, where each string is the name of an instance variable on your SimProcedure whose value you would like to persist to when you return.
   Local variables can be any type so long as you don't mutate their instances.
 
-You may have guessed by now that there exists some sort of auxilliary storage in order to hold on to all this data.
+You may have guessed by now that there exists some sort of auxiliary storage in order to hold on to all this data.
 You would be right!
 The state plugin `state.procedure_data` exists to hold all the data that SimProcedures need to store in order to go about their business that must persist between runs.
 It's stuff that ought to be stored in memory, but the data can't be serialized and/or memory allocation is hard.
@@ -168,7 +168,7 @@ Very cool!
 
 As a brief aside, you can store global variables in `state.procedure_data.global_variables`.
 This is a dictionary that just gets shallow-copied from state to successor state.
-Because it's only a shallow copy, its members are the same instances, so the same rules as local varialbes in SimProcedure continuations apply.
+Because it's only a shallow copy, its members are the same instances, so the same rules as local variables in SimProcedure continuations apply.
 You need to be careful not to mutate any item that is used as a global variable.
 
 ## Helping out static analysis
@@ -178,10 +178,10 @@ There are a few more class variables you can set, though these ones have no dire
 
 - `NO_RET`: Set this to true if control flow will never return from this function
 - `ADDS_EXITS`: Set this to true if you do any control flow other than returning
-- `IS_SYSCALL`: Self-explanitory
+- `IS_SYSCALL`: Self-explanatory
 
 Furthermore, if you set `ADDS_EXITS`, you may also want to define the method `static_exits()`.
-This function takes a single parmeter, a list of IRSBs that would be executed in the run-up to your function, and asks you to return a list of all the exits that you know would be produced by your function in that case.
+This function takes a single parameter, a list of IRSBs that would be executed in the run-up to your function, and asks you to return a list of all the exits that you know would be produced by your function in that case.
 The return value is expected to be a list of tuples of (address (int), jumpkind (str)).
 This is meant to be a quick, best-effort analysis, and you shouldn't try to do anything crazy or intensive to get your answer.
 
@@ -204,7 +204,7 @@ The idea is to use a single function instead of an entire SimProcedure subclass.
 No extraction of arguments is performed, no complex control flow happens.
 
 Control flow is controlled by the length argument to `Hook.wrap`.
-After the function finishes exectuting, the next step will start at 5 bytes after the hooked address.
+After the function finishes executing, the next step will start at 5 bytes after the hooked address.
 If the length argument is omitted or set to zero, execution will resume executing the binary code at exactly the hooked address, without re-triggering the hook. The `Ijk_NoHook` jumpkind allows this to happen.
 
 If you want more control over control flow coming out of a user hook, you can return a list of successor states.
diff --git a/docs/simuvex.md b/docs/simuvex.md
index e577773..65de87f 100644
--- a/docs/simuvex.md
+++ b/docs/simuvex.md
@@ -62,8 +62,8 @@ Like any decent execution engine, SimuVEX supports breakpoints. This is pretty c
 
 >>> s.inspect.b('mem_write', when=simuvex.BP_AFTER, action=debug_func)
 
-# or, you can have it drop you in an embedded ipython!
->>> s.inspect.b('mem_write', when=simuvex.BP_AFTER, action='ipython')
+# or, you can have it drop you in an embedded IPython!
+>>> s.inspect.b('mem_write', when=simuvex.BP_AFTER, action='IPython')
 ```
 
 There are many other places to break than a memory write. Here is the list. You can break at BP_BEFORE or BP_AFTER for each of these events.
@@ -110,7 +110,7 @@ These events expose different attributes:
 | statement         | statement          | BP_BEFORE or BP_AFTER  | The index of the IR statement (in the IR basic block). |
 | instruction       | instruction        | BP_BEFORE or BP_AFTER  | The address of the native instruction. |
 | irsb              | address            | BP_BEFORE or BP_AFTER  | The address of the basic block. |
-| constraints       | added_constrints   | BP_BEFORE or BP_AFTER  | The list of contraint expressions being added. |
+| constraints       | added_constraints   | BP_BEFORE or BP_AFTER  | The list of constraint expressions being added. |
 | call              | function_name      | BP_BEFORE or BP_AFTER  | The name of the function being called. |
 | exit              | exit_target        | BP_BEFORE or BP_AFTER  | The expression representing the target of a SimExit. |
 | exit              | exit_guard         | BP_BEFORE or BP_AFTER  | The expression representing the guard of a SimExit. |
diff --git a/docs/speed.md b/docs/speed.md
index 673099a..0253fcd 100644
--- a/docs/speed.md
+++ b/docs/speed.md
@@ -24,14 +24,14 @@ Regardless, there are a lot of optimizations and tweaks you can use to make angr
 - *Use the Replacement Solver*.
   You can enable it with the `simuvex.o.REPLACEMENT_SOLVER` state option.
   The replacement solver allows you to specify AST replacements that are applied at solve-time.
-  If you add replacements so that all symbolic data is replaced with concrete data when it comes time to do the solve, the runtime is greatly increased.
+  If you add replacements so that all symbolic data is replaced with concrete data when it comes time to do the solve, the runtime is greatly reduced.
   The API for adding a replacement is `state.se._solver.add_replacement(old, new)`.
   The replacement solver is a bit finicky, so there are some gotchas, but it'll definitely help.
 
 ## If you're performing lots of concrete or partially-concrete execution
 
 - *Use the unicorn engine*.
-  If you have [unicorn engine](https://github.com/unicorn/unicorn-engine) installed, Simuvex can be built to take advantage of it for concrete emulation.
+  If you have [unicorn engine](https://github.com/unicorn-engine/unicorn/) installed, Simuvex can be built to take advantage of it for concrete emulation.
   To enable it, add the options in the set `simuvex.o.unicorn` to your state.
   Keep in mind that while most items under `simuvex.o` are individual options, `simuvex.o.unicorn` is a bundle of options, and is thus a set.
   *NOTE*: At time of writing the official version of unicorn engine will not work with angr - we have a lot of patches to it to make it work well with angr.
diff --git a/docs/structured_data.md b/docs/structured_data.md
index d48334b..72e459c 100644
--- a/docs/structured_data.md
+++ b/docs/structured_data.md
@@ -8,7 +8,7 @@ angr has several features to make this less of a headache.
 
 SimuVEX has a system for representing types.
 These SimTypes are found in `simuvex/s_type.py` - an instance of any of these classes represents a type.
-Many of the types are incomplete unless they are supplimented with a SimState - their size depends on the architecture you're running under.
+Many of the types are incomplete unless they are supplamented with a SimState - their size depends on the architecture you're running under.
 You may do this with `ty.with_state(state)`, which returns a copy of itself, with the state specified.
 
 SimuVEX also has a light wrapper around `pycparser`, which is a C parser.
@@ -32,7 +32,7 @@ struct aa
 OrderedDict([('x', int), ('y', long)])
 ```
 
-Additionally, you may parse C defininitions and have them returned to you in a dict:
+Additionally, you may parse C definitions and have them returned to you in a dict:
 
 ```python
 >>> defs = simuvex.s_type.parse_defns("int x; typedef struct llist { char* str; struct llist *next; } list_node; list_node *y;")
@@ -104,7 +104,7 @@ The interface works like this:
 
 - You first use [array index notation] to specify the address you'd like to load from
 - If at that address is a pointer, you may access the `deref` property to return a SimMemView at the address present in memory.
-- You then specify a type for the data by simply accesing a property of that name.
+- You then specify a type for the data by simply accessing a property of that name.
   For a list of supported types, look at `state.mem.types`.
 - You can then _refine_ the type. Any type may support any refinement it likes.
   Right now the only refinements supported are that you may access any member of a struct by its member name, and you may index into a string or array to access that element.
@@ -127,7 +127,7 @@ If you define a struct using `s_type.define_struct`, you can access it here as a
 ## Working with Calling Conventions
 
 A calling convention is the specific means by which code passes arguments and return values through function calls.
-While angr comes with a large number of pre-built calling conventions, and a lot of logic for refining calling conventions for specifc circumstances (e.g. floating point arguments need to be stored in different locations, it gets worse from there), it will inevitably be insufficient to describe all possible calling conventions a compiler could generate.
+While angr comes with a large number of pre-built calling conventions, and a lot of logic for refining calling conventions for specific circumstances (e.g. floating point arguments need to be stored in different locations, it gets worse from there), it will inevitably be insufficient to describe all possible calling conventions a compiler could generate.
 Because of this, you can _customize_ a calling convention by describing where the arguments and return values should live.
 
 angr's abstraction of calling conventions lives in Simuvex as SimCC.
@@ -140,8 +140,8 @@ You can construct new SimCC instances through the angr object factory, with `b.f
 
 To specify a value location for the `args` or `ret_val` parameters, use instances of the `SimRegArg` or `SimStackArg` classes.
 You can find them in the factory - `b.factory.cc.Sim*Arg`.
-Register arguments should be instanciated with the name of the register you're storing the value in, and the size of the register in bytes.
-Stack arguments should be instanciated with the offset from the stack pointer *at the time of entry into the function* and the size of the storage location, in bytes.
+Register arguments should be instantiated with the name of the register you're storing the value in, and the size of the register in bytes.
+Stack arguments should be instantiated with the offset from the stack pointer *at the time of entry into the function* and the size of the storage location, in bytes.
 
 Once you have a SimCC object, you can use it along with a SimState object to extract or store function arguments more cleanly.
 Take a look at the [API documentation](http://angr.io/api-doc/simuvex.html#simuvex.s_cc.SimCC) for details.
@@ -149,13 +149,15 @@ Alternately, you can pass it to an interface that can use it to modify its own b
 
 ## Callables
 
+<a name=callables></a>
+
 Callables are a Foreign Functions Interface (FFI) for symbolic execution.
 Basic callable usage is to create one with `myfunc = b.factory.callable(addr)`, and then call it! `result = myfunc(args, ...)`
 When you call the callable, angr will set up a `call_state` at the given address, dump the given arguments into memory, and run a `path_group` based on this state until all the paths have exited from the function.
 Then, it merges all the result states together, pulls the return value out of that state, and returns it.
 
 All the interaction with the state happens with the aid of a `SimCC`, to tell where to put the arguments and where to get the return value.
-By default, it uses a sane default for the archetecture, but if you'd like to customize it, you can pass a `SimCC` object in the `cc` keyword argument when constructing the callable.
+By default, it uses a sane default for the architecture, but if you'd like to customize it, you can pass a `SimCC` object in the `cc` keyword argument when constructing the callable.
 
 You can pass symbolic data as function arguments, and everything will work fine.
 You can even pass more complicated data, like strings, lists, and structures as native python data (use tuples for structures), and it'll be serialized as cleanly as possible into the state.
diff --git a/docs/surveyors.md b/docs/surveyors.md
index e2d1a5d..299f7eb 100644
--- a/docs/surveyors.md
+++ b/docs/surveyors.md
@@ -72,7 +72,7 @@ For example, in the `fauxware` sample, we can try to find the "authentication su
 >>> print "Avoided %d paths" % len(e.avoided)
 ```
 
-Some helper properties are provided for easier access to paths from ipython:
+Some helper properties are provided for easier access to paths from IPython:
 
 ```python
 >>> print "The first found path is", e._f
@@ -113,12 +113,12 @@ It can be used as so:
 # you can see the secret password "SOSNEAKY" in the first tuple!
 ```
 
-Caller is a pretty powerful tool. Check out the comments on the various functions for more usage info! HOWEVER, there is a much easier tool you can use to call functions, called `callable`. This is described [elsewhere in the docs](https://github.com/angr/angr-doc/blob/master/toplevel.md).
+Caller is a pretty powerful tool. Check out the comments on the various functions for more usage info! HOWEVER, there is a much easier tool you can use to call functions, called `callable`. This is described [elsewhere in the docs](./structured_data.md#callables).
 
 ## Interrupting Surveyors
 
 A surveyor saves its internal state after every tick.
-In ipython, you should be able to interrupt a surveyor with `Ctrl-C`, and then check what results it has so far, but that's a pretty ugly way of doing it.
+In IPython, you should be able to interrupt a surveyor with `Ctrl-C`, and then check what results it has so far, but that's a pretty ugly way of doing it.
 There are two official ways of doing this cleanly: `SIGUSR1` and `SIGUSR2`.
 
 If you send `SIGUSR1` to a python process running a surveyor, it causes the main loop in `Surveyor.run()` to terminate at the end of the current `Surveyor.step()`.
diff --git a/docs/toplevel.md b/docs/toplevel.md
index 250bff1..50a652a 100644
--- a/docs/toplevel.md
+++ b/docs/toplevel.md
@@ -102,7 +102,7 @@ It is not a factory in the Java sense, it is merely a home for all the functions
   Alternately, for simple cases, any keyword arguments you pass `path` will be passed on to `entry_state` to create a state to wrap. It is discussed in depth [here](paths.md).
 - *factory.path_group* creates a path group! Path groups are the future. They're basically very smart lists of paths, so you can pass it a path, a state (which will be wrapped into a path), or a list of paths and states. They are discussed in depth [here](pathgroups.md).
 - *factory.callable* is _very_ cool. Callables are a FFI (foreign functions interface) into arbitrary binary code. They are discussed in depth [here](structured_data.md).
-- *factory.cc* intiializes a calling convention object. This can be initialized with different args or even a function prototype, and then passed to factory.callable or factory.call_state to customize how arguments and return values and return addresses are laid out into memory. It is discussed in depth [here](structured_data.md).
+- *factory.cc* initializes a calling convention object. This can be initialized with different args or even a function prototype, and then passed to factory.callable or factory.call_state to customize how arguments and return values and return addresses are laid out into memory. It is discussed in depth [here](structured_data.md).
 
 ### Lifter
 
