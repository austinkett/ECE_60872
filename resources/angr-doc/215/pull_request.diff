diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8819bf5..8b08ffe 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -12,7 +12,7 @@ You can read about this, as well as a few other breaking changes, in the [MIGRAT
 - Switch to python 3
 - Refactor to Clemory to clean up the API and speed things up drastically
 - Remove `object.symbols_by_addr` (dict) and add `object.symbols` (sorted list); add `fuzzy` parameter to `loader.find_symbol`
-- CFGFast is much, much faster now
+- CFGFast is much, much faster now. CFGAccurate has become CFGEmulated.
 - Support for avx2 unpack instructions, courtesy of D. J. Bernstein
 - angr will now show you a warning when using uninitialized memory or registers
 - angr will now NOT show you a warning if you have a capstone 3.x install unless you're actually interacting with the relevant missing parts
diff --git a/SUMMARY.md b/SUMMARY.md
index b45707e..fc3f6cf 100644
--- a/SUMMARY.md
+++ b/SUMMARY.md
@@ -16,7 +16,7 @@
   * [Analyses](docs/analyses.md)
   * [Remarks](docs/be_creative.md)
 * Built-in Analyses
-  * [CFGAccurate](docs/analyses/cfg_accurate.md)
+  * [CFG](docs/analyses/cfg.md)
   * [Backward Slicing](docs/analyses/backward_slice.md)
   * [Function Identifier](docs/analyses/identifier.md)
 * Advanced Topics
diff --git a/api-doc/source/angr.rst b/api-doc/source/angr.rst
index 56b0397..3a841f9 100644
--- a/api-doc/source/angr.rst
+++ b/api-doc/source/angr.rst
@@ -169,7 +169,7 @@ Analysis
 .. automodule:: angr.analyses.cfg
 .. automodule:: angr.analyses.cfg.cfb
 .. automodule:: angr.analyses.cfg.cfg
-.. automodule:: angr.analyses.cfg.cfg_accurate
+.. automodule:: angr.analyses.cfg.cfg_emulated
 .. automodule:: angr.analyses.cfg.cfg_base
 .. automodule:: angr.analyses.cfg.cfg_fast
 .. automodule:: angr.analyses.cfg.cfg_node
diff --git a/docs/analyses.md b/docs/analyses.md
index 459c2b4..ed3540d 100644
--- a/docs/analyses.md
+++ b/docs/analyses.md
@@ -9,7 +9,7 @@ We will cover writing your own analyses [later](analysis_writing.md), but the id
 | Name                                        | Description                                                                                                                               |
 | --------                                    | -------------                                                                                                                             |
 | CFGFast                                     | Constructs a fast *Control Flow Graph* of the program                                                                                     |
-| [CFGAccurate](analyses/cfg_accurate.md)     | Constructs an accurate *Control Flow Graph* of the program                                                                                |
+| [CFGEmulated](analyses/cfg.md)     | Constructs an accurate *Control Flow Graph* of the program                                                                                |
 | VFG                                         | Performs VSA on every function of the program, creating a *Value Flow Graph* and detecting stack variables                                |
 | DDG                                         | Calculates a *Data Dependency Graph*, allowing one to determine what statements a given value depends on                                  |
 | [BackwardSlice](analyses/backward_slice.md) | Computes a *Backward Slice* of a program with respect to a certain target                                                                 |
diff --git a/docs/analyses/backward_slice.md b/docs/analyses/backward_slice.md
index c11ed58..d15bb00 100644
--- a/docs/analyses/backward_slice.md
+++ b/docs/analyses/backward_slice.md
@@ -13,7 +13,7 @@ This section will act as a how-to for angr’s `BackwardSlice` analysis, and fol
 
 To build a `BackwardSlice`, you will need the following information as input.
 
-- **Required** CFG. A control flow graph (CFG) of the program. This CFG must be an accurate CFG (CFGAccurate).
+- **Required** CFG. A control flow graph (CFG) of the program. This CFG must be an accurate CFG (CFGEmulated).
 - **Required** Target, which is the final destination that your backward slice terminates at.
 - **Optional** CDG. A control dependence graph (CDG) derived from the CFG.
 angr has a built-in analysis `CDG` for that purpose.
@@ -31,7 +31,7 @@ A `BackwardSlice` can be constructed with the following code:
 # you’ll have to keep all input states by specifying keep_state=True. Feel free 
 # to provide more parameters (for example, context_sensitivity_level) for CFG 
 # recovery based on your needs.
->>> cfg = b.analyses.CFGAccurate(context_sensitivity_level=2, keep_state=True)
+>>> cfg = b.analyses.CFGEmulated(context_sensitivity_level=2, keep_state=True)
 
 # Generate the control dependence graph
 >>> cdg = b.analyses.CDG(cfg)
diff --git a/docs/analyses/cfg_accurate.md b/docs/analyses/cfg.md
similarity index 62%
rename from docs/analyses/cfg_accurate.md
rename to docs/analyses/cfg.md
index 9e87759..07daa79 100644
--- a/docs/analyses/cfg_accurate.md
+++ b/docs/analyses/cfg.md
@@ -1,96 +1,39 @@
-# CFGAccurate
+# Control-flow Graph Recovery (CFG)
 
-Here we describe angr’s CFGAccurate analysis in details, as well as some important concepts like context sensitivity and Function Manager of angr.
+angr includes analyses to recover the control-flow graph of a binary program.
+This also includes recovery of function boundaries, as well as reasoning about indirect jumps and other useful metadata.
 
 ## General ideas
 
 A basic analysis that one might carry out on a binary is a Control Flow Graph.
 A CFG is a graph with (conceptually) basic blocks as nodes and jumps/calls/rets/etc as edges.
 
-In angr, there are two types of CFG that can be generated: a fast CFG (CFGFast) and an accurate CFG (CFGAccurate).
-As their names suggested, generating a fast CFG is usually much faster than generating the accurate one.
-In general, CFGFast is what you need.
-This page discusses CFGAccurate.
+In angr, there are two types of CFG that can be generated: a static CFG (CFGFast) and a dynamic CFG (CFGEmulated).
 
-An accurate CFG can be constructed by doing:
+CFGFast uses static analysis to generate a CFG.
+It is significantly faster, but is theoretically bounded by the fact that some control-flow transitions can only be resolved at execution-time.
+This is the same sort of CFG analysis performed by other popular reverse-engineering tools, and its results are comparable with their output.
 
-```python
->>> import angr
-# load your project
->>> b = angr.Project('/bin/true', load_options={'auto_load_libs': False})
-
-# generate an accurate CFG
->>> cfg = b.analyses.CFGAccurate(keep_state=True)
-```
+CFGEmulated uses symbolic execution to capture the CFG. While it is theoretically more accurate, it is dramatically slower.
+It is also typically less complete, due to issues with the accuracy of emulation (system calls, missing hardware features, and so on)
 
-Of course, there are several options for customized CFGs.
-
-| Option | Description |
-|--------|-------------|
-| context_sensitivity_level | This sets the context sensitivity level of the analysis. See the context sensitivity level section below for more information. This is 1 by default. |
-| starts | A list of addresses, to use as entry points into the analysis. |
-| avoid_runs | A list of addresses to ignore in the analysis. |
-| call_depth | Limit the depth of the analysis to some number calls. This is useful for checking which functions a specific function can directly jump to (by setting `call_depth` to 1).
-| initial_state | An initial state can be provided to the CFG, which it will use throughout its analysis. |
-| keep_state | To save memory, the state at each basic block is discarded by default. If `keep_state` is True, the state is saved in the CFGNode. |
-| enable_symbolic_back_traversal | Whether to enable an intensive technique for resolving indirect jumps |
-| enable_advanced_backward_slicing | Whether to enable another intensive technique for resolving direct jumps |
-| more! | Examine the docstring on b.analyses.CFGAccurate for more up-to-date options |
-
-## Context Sensitivity Level
-
-angr constructs a CFG by executing every basic block and seeing where it goes.
-This introduces some challenges: a basic block can act differently in different *contexts*.
-For example, if a block ends in a function return, the target of that return will be different, depending on different callers of the function containing that basic block.
+*If you are unsure which CFG to use, or are having problems with CFGEmulated, try CFGFast first.*
 
-The context sensitivity level is, conceptually, the number of such callers to keep on the callstack.
-To explain this concept, let's look at the following code:
 
-```c
-void error(char *error)
-{
-	puts(error);
-}
+A CFG can be constructed by doing:
 
-void alpha()
-{
-	puts("alpha");
-	error("alpha!");
-}
+```python
+>>> import angr
+# load your project
+>>> p = angr.Project('/bin/true', load_options={'auto_load_libs': False})
 
-void beta()
-{
-	puts("beta");
-	error("beta!");
-}
+# Generate a static CFG
+>>> cfg = p.analyses.CFGFast()
 
-void main()
-{
-	alpha();
-	beta();
-}
+# generate a dynamic CFG
+>>> cfg = p.analyses.CFGEmulated(keep_state=True)
 ```
 
-The above sample has four call chains: `main>alpha>puts`, `main>alpha>error>puts` and `main>beta>puts`, and `main>beta>error>puts`.
-While, in this case, angr can probably execute both call chains, this becomes unfeasible for larger binaries.
-Thus, angr executes the blocks with states limited by the context sensitivity level.
-That is, each function is re-analyzed for each unique context that it is called in.
-
-For example, the `puts()` function above will be analyzed with the following contexts, given different context sensitivity levels:
-
-| Level | Meaning | Contexts |
-|-------|---------|----------|
-| 0 | Callee-only | `puts` |
-| 1 | One caller, plus callee | `alpha>puts` `beta>puts` `error>puts` |
-| 2 | Two callers, plus callee | `alpha>error>puts` `main>alpha>puts` `beta>error>puts` `main>beta>puts` |
-| 3 | Three callers, plus callee | `main>alpha>error>puts` `main>alpha>puts` `main>beta>error>puts` `main>beta>puts` |
-
-The upside of increasing the context sensitivity level is that more information can be gleaned from the CFG.
-For example, with context sensitivity of 1, the CFG will show that, when called from `alpha`, `puts` returns to `alpha`, when called from `error`, `puts` returns to `error`, and so forth.
-With context sensitivity of 0, the CFG simply shows that `puts` returns to `alpha`, `beta`, and `error`.
-This, specifically, is the context sensitivity level used in IDA.
-The downside of increasing the context sensitivity level is that it exponentially increases the analysis time.
-
 ## Using the CFG
 
 The CFG, at its core, is a [NetworkX](https://networkx.github.io/) di-graph.
@@ -161,3 +104,125 @@ Functions have several important properties!
 
 and many more !
 
+
+## CFGFast details
+
+CFGFast peforms a static control-flow and function recovery.
+Starting with the entry point (or any user-defined points) roughly the following procedure is performed:
+
+1) The basic block is lifted to VEX IR, and all its exits (jumps, calls, returns, or continuation to the next block) are collected
+2) For each exit, if this exit is a constant address, we add an edge to the CFG of the correct type, and add the destination block to the set of blocks to be analyzed.
+3) In the event of a function call, the destination block is also considered the start of a new function. If the target function is known to return, the block after the call is also analyzed.
+4) In the event of a return, the current function is marked as returning, and the appropriate edges in the callgraph and CFG are updated.
+4) For all indirect jumps (block exits with a non-constant destination) Indirect Jump Resolution is performed.
+
+### Finding function starts
+
+CFGFast supports multiple ways of deciding where a function starts and ends.
+
+First the binary's main entry point will be analyzed.
+For binaries with symbols (e.g., non-stripped ELF and PE binaries) all function symbols will be used as possible starting points.
+For binaries without symbols, such as stripped binaries, or binaries loaded using the `blob` loader backend, CFG will scan the binary for a set of function prologues defined for the binary's architecture.
+Finally, by default, the binary's entire code section will be scanned for executable contents, regardless of prologues or symbols.
+
+In addition to these, as with CFGEmulated, function starts will also be considered when they are the target of a "call" instruction on the given architecture.
+
+All of these options can be disabled
+
+### FakeRets and function returns
+
+When a function call is observed, we first assume that the callee function eventually returns, and treat the block after it as part of the caller function.
+This inferred control-flow edge is known as a "FakeRet".
+If, in analyzing the callee, we find this not to be true, we update the CFG, removing this "FakeRet", and updating the callgraph and function blocks accordingly.
+As such, the CFG is recovered *twice*.  In doing this, the set of blocks in each function, and whether the function returns, can be recovered and propagated directly.
+
+### Indirect Jump Resolution
+
+*TODO*
+
+
+### Options
+
+These are the most useful options when working with CFGFast:
+
+| Option | Description |
+|--------|-------------|
+| force_complete_scan | (Default: True) Treat the entire binary as code for the purposes of function detection.  If you have a blob (e.g., mixed code and data) *you want to turn this off*. |
+| function_starts | A list of addresses, to use as entry points into the analysis. |
+| normalize | Normalize the resulting functions (e.g., each basic block belongs to at most one function) |
+| collect_data_references | Find all references to data during CFG generation. The results can allow you to find cross-references to data. |
+| resolve_indirect_jumps | Perform additional analysis to attempt to find targets for every indirect jump found during CFG creation. | 
+| more! | Examine the docstring on b.analyses.CFGFast for more up-to-date options |
+
+
+## CFGEmulated details
+
+### Options
+The most common options for CFGEmulated include:
+
+| Option | Description |
+|--------|-------------|
+| context_sensitivity_level | This sets the context sensitivity level of the analysis. See the context sensitivity level section below for more information. This is 1 by default. |
+| starts | A list of addresses, to use as entry points into the analysis. |
+| avoid_runs | A list of addresses to ignore in the analysis. |
+| call_depth | Limit the depth of the analysis to some number calls. This is useful for checking which functions a specific function can directly jump to (by setting `call_depth` to 1).
+| initial_state | An initial state can be provided to the CFG, which it will use throughout its analysis. |
+| keep_state | To save memory, the state at each basic block is discarded by default. If `keep_state` is True, the state is saved in the CFGNode. |
+| enable_symbolic_back_traversal | Whether to enable an intensive technique for resolving indirect jumps |
+| enable_advanced_backward_slicing | Whether to enable another intensive technique for resolving direct jumps |
+| more! | Examine the docstring on b.analyses.CFGEmulated for more up-to-date options |
+
+
+### Context Sensitivity Level
+
+angr constructs a CFG by executing every basic block and seeing where it goes.
+This introduces some challenges: a basic block can act differently in different *contexts*.
+For example, if a block ends in a function return, the target of that return will be different, depending on different callers of the function containing that basic block.
+
+The context sensitivity level is, conceptually, the number of such callers to keep on the callstack.
+To explain this concept, let's look at the following code:
+
+```c
+void error(char *error)
+{
+	puts(error);
+}
+
+void alpha()
+{
+	puts("alpha");
+	error("alpha!");
+}
+
+void beta()
+{
+	puts("beta");
+	error("beta!");
+}
+
+void main()
+{
+	alpha();
+	beta();
+}
+```
+
+The above sample has four call chains: `main>alpha>puts`, `main>alpha>error>puts` and `main>beta>puts`, and `main>beta>error>puts`.
+While, in this case, angr can probably execute both call chains, this becomes unfeasible for larger binaries.
+Thus, angr executes the blocks with states limited by the context sensitivity level.
+That is, each function is re-analyzed for each unique context that it is called in.
+
+For example, the `puts()` function above will be analyzed with the following contexts, given different context sensitivity levels:
+
+| Level | Meaning | Contexts |
+|-------|---------|----------|
+| 0 | Callee-only | `puts` |
+| 1 | One caller, plus callee | `alpha>puts` `beta>puts` `error>puts` |
+| 2 | Two callers, plus callee | `alpha>error>puts` `main>alpha>puts` `beta>error>puts` `main>beta>puts` |
+| 3 | Three callers, plus callee | `main>alpha>error>puts` `main>alpha>puts` `main>beta>error>puts` `main>beta>puts` |
+
+The upside of increasing the context sensitivity level is that more information can be gleaned from the CFG.
+For example, with context sensitivity of 1, the CFG will show that, when called from `alpha`, `puts` returns to `alpha`, when called from `error`, `puts` returns to `error`, and so forth.
+With context sensitivity of 0, the CFG simply shows that `puts` returns to `alpha`, `beta`, and `error`.
+This, specifically, is the context sensitivity level used in IDA.
+The downside of increasing the context sensitivity level is that it exponentially increases the analysis time.
diff --git a/docs/toplevel.md b/docs/toplevel.md
index d81f4aa..22dc5d2 100644
--- a/docs/toplevel.md
+++ b/docs/toplevel.md
@@ -212,7 +212,7 @@ angr comes pre-packaged with several built-in analyses that you can use to extra
  proj.analyses.BoyScout             proj.analyses.Disassembly          proj.analyses.VariableRecoveryFast  
  proj.analyses.CDG                  proj.analyses.GirlScout            proj.analyses.Veritesting           
  proj.analyses.CFG                  proj.analyses.Identifier           proj.analyses.VFG                   
- proj.analyses.CFGAccurate          proj.analyses.LoopFinder           proj.analyses.VSA_DDG               
+ proj.analyses.CFGEmulated          proj.analyses.LoopFinder           proj.analyses.VSA_DDG               
  proj.analyses.CFGFast              proj.analyses.Reassembler
 ```
 
