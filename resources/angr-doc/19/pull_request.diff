diff --git a/examples.md b/examples.md
index 700bf65..154cc03 100644
--- a/examples.md
+++ b/examples.md
@@ -158,6 +158,15 @@ Author: Kyle Ossinger (github: @k0ss)
 
 This is the first in a series of "tutorial scripts" I'll be making which use angr to find exploitable conditions in binaries.  The first example is a very simple program.  The script finds a path from the main entry point to `strcpy`, but **only** when we control the source buffer of the `strcpy` operation.  To hit the right path, angr has to solve for a password argument, but angr solved this in less than 2 seconds on my machine using the standard python interpreter.  The script might look large, but that's only because I've heavily commented it to be more helpful to beginners.  The challenge binary is [here](./examples/strcpy_find/strcpy_test') and the script is [here](./examples/strcpy_find/solve.py).
 
+### Beginner Exploitation example: CADET_0001
+Author: Antonio Bianchi, Jacopo Corbetta
+
+This is a very easy binary containing a stack buffer overflow and an easter egg.
+CADET_00001 is one of the challenge released by DARPA for the Cyber Grand Challenge:
+[link](https://github.com/CyberGrandChallenge/samples/tree/master/examples/CADET_00001)
+The binary can run in the DECREE VM: [link](http://repo.cybergrandchallenge.com/boxes/)
+CADET_00001.adapted (by Jacopo Corbetta) is the same program, modified to be runnable in an Intel x86 Linux machine.
+
 ### Grub "back to 28" bug
 
 Author: Andrwe Dutcher (github: @rhelmot)
diff --git a/examples/CADET_00001/CADET_00001 b/examples/CADET_00001/CADET_00001
new file mode 100755
index 0000000..434fde9
Binary files /dev/null and b/examples/CADET_00001/CADET_00001 differ
diff --git a/examples/CADET_00001/CADET_00001.adapted b/examples/CADET_00001/CADET_00001.adapted
new file mode 100755
index 0000000..2a51e9e
Binary files /dev/null and b/examples/CADET_00001/CADET_00001.adapted differ
diff --git a/examples/CADET_00001/solve.py b/examples/CADET_00001/solve.py
new file mode 100755
index 0000000..4ed3272
--- /dev/null
+++ b/examples/CADET_00001/solve.py
@@ -0,0 +1,96 @@
+#!/usr/bin/env python
+
+'''
+CADET_00001 is one of the challenge released by DARPA for the Cyber Grand Challenge:
+https://github.com/CyberGrandChallenge/samples/tree/master/examples/CADET_00001
+
+The binary can run in the DECREE VM (http://repo.cybergrandchallenge.com/boxes/)
+
+CADET_00001.adapted (by Jacopo Corbetta) is the same program, modified to be runnable in an Intel x86 Linux machine.
+
+The binary contains an easter egg and a stack buffer overflow.
+'''
+
+import angr
+
+
+def main():
+    project= angr.Project("./CADET_00001")
+
+    #let's find the buffer overflow (overwriting the return address)
+    #overwriting the return pointer with user-controllable data will generate
+    #an "unconstrained" state: the symbolic executor does not know how to proceed
+    #since the instruction pointer can assume any value
+
+    #by default angr discards unconstrained paths, so we need to specify the  
+    #save_unconstrained option
+    print "finding the buffer overflow..."
+    pg = project.factory.path_group(save_unconstrained=True)
+    #symbolically execute the binary until an unconstrained path is reached
+    while len(pg.unconstrained)==0:
+        pg.step()
+    unconstrained_path = pg.unconstrained[0]
+    crashing_input = unconstrained_path.state.posix.dumps(0)
+    #cat crash_input.bin | ./CADET_00001.adapted will segfault
+    unconstrained_path.state.posix.dump(0,"crash_input.bin")
+    print "buffer overflow found!"
+    print repr(crashing_input)
+
+
+    #let's now find the easter egg (it takes about 2 minutes)
+    
+    #now we want angr to avoid "unfeasible" paths
+    #by default, "lazy solving" is enabled, this means that angr will not 
+    #automatically discard unfeasible paths
+
+    #to disable "lazy solving" we generate a blank path and we change its options,
+    #then we specify this path as the initial path of the path group
+    print "finding the easter egg..."
+    path = project.factory.path()
+    path.state.options.discard("LAZY_SOLVES")
+    pg = project.factory.path_group(path)
+
+    #at this point we just ask angr to reach the basic block where the easter egg 
+    #text is printed
+    pg.explore(find=0x804833E)
+    found = pg.found[0]
+    solution1 = found.state.posix.dumps(0)
+    print "easter egg found!"
+    print repr(solution1)
+    found.state.posix.dump(0,"easteregg_input1.bin")
+    #you can even check if the easter egg has been found by checking stdout
+    stdout1 = found.state.posix.dumps(1)
+    print repr(stdout1)
+
+    #an alternative way to avoid unfeasible paths (paths that contains an unsatisfiable set
+    #of constraints) is to "manually" step the path group execution and call prune()
+    print "finding the easter egg (again)..."
+    pg = project.factory.path_group()
+    while True:
+        pg.step()
+        pg.prune() #we "manually" ask angr to remove unfeasible paths 
+        found_list = [active for active in pg.active if active.addr == 0x804833E]
+        if len(found_list) > 0:
+            break
+    found = found_list[0]
+    solution2 = found.state.posix.dumps(0)
+    print "easter egg found!"
+    print repr(solution2)
+    found.state.posix.dump(0,"easteregg_input2.bin")
+    #you can even check if the easter egg has been found by checking stdout
+    stdout2 = found.state.posix.dumps(1)
+    print repr(stdout2)
+
+    return (crashing_input, solution1, stdout1, solution2, stdout2)
+
+
+def test():
+    crashing_input, solution1, stdout1, solution2, stdout2 = main()
+    assert (crashing_input) >= 92 and solution1.startswith("^") and solution2.startswith("^") and \
+            "EASTER EGG!" in stdout1 and "EASTER EGG!" in stdout2
+
+
+if __name__ == '__main__':
+    print(repr(main()))
+
+
