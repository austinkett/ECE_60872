diff --git a/examples.md b/examples.md
index 749e4f2..41e58ab 100644
--- a/examples.md
+++ b/examples.md
@@ -132,6 +132,16 @@ For a detailed write-up please visit the author's post [here](http://0x0atang.gi
 you can also find the solution from the FireEye [here](https://www.fireeye.com/content/dam/fireeye-www/global/en/blog/threat-research/flareon/2015solution5.pdf)
 
 
+### ReverseMe example: 0ctf 2016 - momo
+
+Author: Fish Wang (github: @ltfish), ocean (github: @ocean1)
+
+This challenge is a [movfuscated](https://github.com/xoreaxeaxeax/movfuscator) binary.
+To find the correct password after exploring the binary with Qira it is possible to understand 
+how to find the places in the binary where every character is checked using capstone and using angr to
+load the [binary](./examples/0ctf_momo/solve.py) and bruteforce the single characters of the flag.
+Be aware that the [script](./examples/0ctf_momo/solve.py) is really slow.
+
 
 ### CrackMe example: Layer7 CTF 2015 - Windows challenge OnlyOne
 
diff --git a/examples/0ctf_momo_3/momo b/examples/0ctf_momo_3/momo
new file mode 100755
index 0000000..45cd3a4
Binary files /dev/null and b/examples/0ctf_momo_3/momo differ
diff --git a/examples/0ctf_momo_3/solve.py b/examples/0ctf_momo_3/solve.py
new file mode 100644
index 0000000..5997d09
--- /dev/null
+++ b/examples/0ctf_momo_3/solve.py
@@ -0,0 +1,103 @@
+#!/usr/bin/env python
+
+# This is a movfuscated binary from 0ctf 2016, debugging we can see
+# that every byte from the flag gets moved this way:
+# .text:0804ABAC                 mov     edx, dword_81FE260[edx*4]
+# after, varying a few times the input and looking for differences
+# with Qira we can see that it is expected for the content of
+# 0x81fe6e0 and 0x81fe6e4 to be the same
+# since the way the movfuscator "vm" access memory is always the same
+# we can search for the same instructions (in the same order) to
+# establish the targets for angr execution
+
+import sys
+import string
+import angr
+from angr.lifter import CapstoneInsn, CapstoneBlock
+
+
+ins_char = 0x81fe6e0
+flag_char = 0x81fe6e4
+
+after_fgets = 0x08049653
+mov_congrats = 0x0805356E
+
+
+def main():
+    p = angr.Project('./momo', load_options={'auto_load_libs': False})
+
+    addr = after_fgets
+    size = mov_congrats - after_fgets
+
+    # let's disasm with capstone to search targets
+    insn_bytes = ''.join(
+        p.loader.memory.read_bytes(addr, size))
+
+    insns = []
+    for cs_insn in p.arch.capstone.disasm(insn_bytes, addr):
+        insns.append(CapstoneInsn(cs_insn))
+    block = CapstoneBlock(addr, insns, 0, p.arch)
+
+    targets = []
+
+    # let's keep track of the state
+    state = 0
+    for ins in block.insns:
+        if state == 0:
+            if ins.op_str == 'edx, dword ptr [edx*4 + 0x81fe260]':
+                state += 1
+                continue
+        if state == 1:
+            if ins.op_str == 'al, byte ptr [0x81fe6e0]':
+                state += 1
+                continue
+        if state == 2:
+            if ins.op_str == 'dl, byte ptr [0x81fe6e4]':
+                targets.append(ins.address + ins.size)
+                state = 0
+
+    print "found {:d} targets".format(len(targets))
+    assert len(targets) == 28
+
+    flag_arr = ['0', 'c', 't', 'f', '{']
+
+    for target in targets[5:]:
+        print "\nexamining target {:#x}:".format(target)
+        for trychar in string.printable:
+            print trychar,
+            sys.stdout.flush()
+            flag = ''.join(flag_arr)+trychar
+            state = p.factory.entry_state()
+            state.posix.files[0].content.store(0, flag + "\n")
+
+            path = p.factory.path(state=state)
+            e = p.surveyors.Explorer(start=path, find=(target,))
+            e.run()
+
+            assert len(e.found) == 1
+            np = e.found[0]
+
+            while(True):
+                nb_size = target - np.addr
+                if nb_size <= 0:
+                    break
+                np = np.step(max_size=nb_size)[0]
+            assert nb_size == 0
+
+            al = np.state.regs.eax[7:0]
+            dl = np.state.regs.edx[7:0]
+            al_val = al._model_concrete.value
+            dl_val = dl._model_concrete.value
+
+            if al_val == dl_val:
+                flag_arr.append(trychar)
+                break
+
+    return ''.join(flag_arr)
+
+
+def test():
+    assert main() == '0ctf{m0V_I5_tUr1N9_c0P1Et3!}'
+
+if __name__ == '__main__':
+    print main()
