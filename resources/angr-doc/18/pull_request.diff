diff --git a/examples.md b/examples.md
index ddc7d1b..7230548 100644
--- a/examples.md
+++ b/examples.md
@@ -4,7 +4,8 @@ To help you get started with [angr](https://github.com/angr/angr), we've created
 These mostly stem from CTF problems solved with angr by Shellphish.
 Enjoy!
 
-## ReverseMe example: WhiteHat Grant Prix Global Challenge 2015 - Re400
+## CTF Problems
+### ReverseMe example: WhiteHat Grant Prix Global Challenge 2015 - Re400
 
 Author: Fish Wang (github: @ltfish)
 
@@ -18,7 +19,7 @@ Other than that, angr works really well for solving this challenge.
 The [binary](./examples/whitehatvn2015_re400/re400.exe) and the [script](./examples/whitehatvn2015_re400/solve.py). 
 Enjoy!
 
-## ReverseMe example: EKOPARTY CTF 2015 - rev 100
+### ReverseMe example: EKOPARTY CTF 2015 - rev 100
 
 Author: Fish Wang (github: @ltfish)
 
@@ -28,7 +29,7 @@ This is a painful challenge to solve with angr. I should have done things in a s
 
 Here is the [binary](./examples/ekopartyctf2015_rev100/counter) and the [script](./examples/ekopartyctf2015_rev100/solve.py).
 
-## ReverseMe example: ASIS CTF Finals 2015 - fake
+### ReverseMe example: ASIS CTF Finals 2015 - fake
 
 Author: Fish Wang (github: @ltfish)
 
@@ -38,7 +39,7 @@ The solution is pretty straight-forward.
 
 The [binary](./examples/asisctffinals2015_fake/fake) and the [script](./examples/asisctffinals2015_fake/solve.py).
 
-## ReverseMe example: ASIS CTF Finals 2015 - license
+### ReverseMe example: ASIS CTF Finals 2015 - license
 
 Author: Fish Wang (github: @ltfish)
 
@@ -52,7 +53,7 @@ This is a good example that showcases the following:
 
 Here are the [binary](./examples/asisctffinals2015_license/license) and the [script](./examples/asisctffinals2015_license/solve.py).
 
-## ReverseMe example: Defcamp CTF Qualification 2015 - Reversing 100
+### ReverseMe example: Defcamp CTF Qualification 2015 - Reversing 100
 
 Author: Fish Wang (github: @ltfish)
 
@@ -60,7 +61,7 @@ Angr solves this challenge with almost zero user-interference.
 
 See the [script](./examples/defcamp_r100/solve.py) and the [binary](./examples/defcamp_r100/r100).
 
-## ReverseMe example: Defcamp CTF Qualification 2015 - Reversing 200
+### ReverseMe example: Defcamp CTF Qualification 2015 - Reversing 200
 
 Author: Fish Wang (github: @ltfish)
 
@@ -69,7 +70,7 @@ Angr solves this challenge with almost zero user-interference. Veritesting is re
 The [script](./examples/defcamp_r200/solve.py) and the [binary](./examples/defcamp_r200/r200).
 It takes a few minutes to run on my laptop.
 
-## ReverseMe example: MMA CTF 2015 - HowToUse
+### ReverseMe example: MMA CTF 2015 - HowToUse
 
 Author: Andrew Dutcher (github: @rhelmot)
 
@@ -77,7 +78,7 @@ We solved this simple reversing challenge with angr, since we were too lazy to r
 The resulting [script](./examples/mma_howtouse/solve.py) shows how we grabbed the flag out of the [DLL](./examples/mma_howtouse/howtouse.dll).
 
 
-## CrackMe example: MMA CTF 2015 - SimpleHash
+### CrackMe example: MMA CTF 2015 - SimpleHash
 
 Author: Chris Salls (github: @salls)
 
@@ -86,7 +87,7 @@ The [script](./examples/mma_simplehash/solve.py) describes the difficulties that
 The binary can be found [here](./examples/mma_simplehash/simple_hash).
 
 
-## ReverseMe example: FlareOn 2015 - Challenge 10
+### ReverseMe example: FlareOn 2015 - Challenge 10
 
 Author: Fish Wang (github: @ltfish)
 
@@ -99,14 +100,14 @@ It also shows how to read bytes out of memory and decode as a string.
 By the way, here is the [link](https://www.fireeye.com/content/dam/fireeye-www/global/en/blog/threat-research/flareon/2015solution10.pdf) to the intended solution from FireEye.
 
 
-## ReverseMe example: FlareOn 2015 - Challenge 2
+### ReverseMe example: FlareOn 2015 - Challenge 2
 
 Author: Chris Salls (github: @salls)
 
 This [reversing challenge](./examples/flareon2015_2/very_success) is simple to solve almost entirely with angr, and a lot faster than trying to reverse the password checking function. The script is [here](./examples/flareon2015_2/solve.py)
 
 
-## CrackMe example: Layer7 CTF 2015 - Windows challenge OnlyOne
+### CrackMe example: Layer7 CTF 2015 - Windows challenge OnlyOne
 
 Author: Fish Wang (github: @ltfish)
 
@@ -121,7 +122,7 @@ The solving script demonstrates the following:
 - How to enable Veritesting, and why it is useful.
 
 
-## CrackMe example: Whitehat CTF 2015 - Crypto 400
+### CrackMe example: Whitehat CTF 2015 - Crypto 400
 
 Author: Yan Shoshitaishvili (github: @Zardus)
 
@@ -129,17 +130,24 @@ We solved this crackme with angr's help.
 The resulting script will help you understand how angr can be used for crackme assistance.
 You can find this script [here](./examples/whitehat_crypto400/solve.py) and the binary [here](./examples/whitehat_crypto400/whitehat_crypto400).
 
-## CrackMe example: CSAW CTF 2015 Quals - Reversing 500, "wyvern"
+### CrackMe example: CSAW CTF 2015 Quals - Reversing 500, "wyvern"
 
 Author: Andrew Dutcher (github: @rhelmot)
 
 Angr can outright solve this challenge with very little assistance from the user.
 The script to do so is [here](./examples/csaw_wyvern/solve.py) and the binary is [here](./examples/csaw_wyvern/wyvern).
 
-## CrackMe example: 9447 CTF 2015 - Reversing 330, "nobranch"
+### CrackMe example: 9447 CTF 2015 - Reversing 330, "nobranch"
 
 Author: Andrew Dutcher (github: @rhelmot)
 
 Angr cannot currently solve this problem naively, as the problem is too complex for z3 to solve.
 Formatting the constraints to z3 a little differently allows z3 to come up with an answer relatively quickly. (I was asleep while it was solving, so I don't know exactly how long!)
 The script for this is [here](./examples/9447_nobranch/solve.py) and the binary is [here](./examples/9447_nobranch/nobranch).
+
+## Exploitation Examples
+### Beginner Exploitation example: strcpy_find
+
+Author: Kyle Ossinger (github: @k0ss)
+
+This is the first in a series of "tutorial scripts" I'll be making which use angr to find exploitable conditions in binaries.  The first example is a very simple program.  The script finds a path from the main entry point to `strcpy`, but **only** when we control the source buffer of the `strcpy` operation.  To hit the right path, angr has to solve for a password argument, but angr solved this in less than 2 seconds on my machine using the standard python interpreter.  The script might look large, but that's only because I've heavily commented it to be more helpful to beginners.  The challenge binary is [here](./examples/strcpy_find/strcpy_test') and the script is [here](./examples/strcpy_find/solve.py).
diff --git a/examples/strcpy_find/solve.py b/examples/strcpy_find/solve.py
new file mode 100755
index 0000000..49c5d53
--- /dev/null
+++ b/examples/strcpy_find/solve.py
@@ -0,0 +1,157 @@
+#!/usr/bin/env python
+'''
+@author Kyle Ossinger (k0ss_sec)
+@desc   Tutorial solver for an example program.  I noticed most of the angr
+        examples were for solving for a password/flag rather than for finding
+        exploitable memory corruptions.  I hope this will lead you on the path
+        to finding your own memory corruptions.  Enjoy!
+
+'''
+
+import angr
+import claripy  # It is optimal to use claripy.BVV/BVS over state.se.BVV/BVS
+
+def main():
+    '''
+     Just a helper function to grab function names from resolved symbols.
+     This will not be so easy if the binary is stripped.  You will have to
+     open the binary in a disassembler and find the addresses of the
+     functions you are trying to find/avoid in your paths rather than using
+     this helper function.
+    '''
+    def getFuncAddress( funcName ):
+        found = [
+            addr for addr,func in cfg.function_manager.functions.iteritems()
+            if funcName == func.name
+            ]
+        if len( found ) > 0:
+            print "Found "+funcName+"'s address at "+hex(found[0])+"!"
+            return found[0]
+        else:
+            raise Exception("No address found for function : "+funcName)
+
+
+    def get_byte(s, i):
+        pos = s.size() / 8 - 1 - i
+        return s[pos * 8 + 7 : pos * 8]
+
+    '''
+     load the binary, don't load extra libs to save time/memory from state explosion
+    '''
+    project = angr.Project("strcpy_test", load_options={'auto_load_libs':False})
+    '''
+     Set up CFG so we can grab function addresses from symbols.
+     I set the fail_fast option to True to minimize how long
+     this process takes.
+    '''
+    cfg = project.analyses.CFG(fail_fast=True)
+    '''
+     Get addresses of our functions to find or avoid
+    '''
+    addrStrcpy = getFuncAddress('strcpy')
+    addrBadFunc = getFuncAddress('func3')
+    '''
+     Create the list of command-line arguments and add the program name
+    '''
+    argv = [project.filename]   #argv[0]
+    ''' 
+     Add symbolic variable for the password buffer which we are solving for:
+    '''
+    sym_arg_size = 40   #max number of bytes we'll try to solve for
+    '''
+     We use 8 * sym_arg_size because the size argument is in BITS, not bytes
+    '''
+    sym_arg = claripy.BVS('sym_arg', 8*sym_arg_size)
+    argv.append(sym_arg)    #argv[1]
+
+    '''
+     Add the buffer we will copy in if the password is correct
+     When we find a path to strcpy, we will check to make sure
+     that this is the value that is being copied!
+    '''
+    argv.append("HAHAHAHA") # argv[2]
+     
+    '''
+     Initializes an entry state starting at the address of the program entry point
+     We simply pass it the same kind of argument vector that would be passed to the
+     program, in execv() for example.
+    '''
+    state = project.factory.entry_state(args=argv)
+
+    '''
+     Create a new path group from the entry state
+    '''
+    path_group = project.factory.path_group(state)
+     
+    '''
+     Since we want to find a path to strcpy ONLY where we have control of the
+     source buffer, we have to have a custom check function which takes a Path
+     as an argument.
+
+     You might be wondering what we should do to instruct angr to find our
+     target address since we're replacing the 'find=' argument with this
+     'check' function.  Just check p.state.ip.args[0] (the current instruction
+     pointer) to make sure we're at our intended path destination before checking
+     to make sure the other conditions are satisfied.
+    '''
+    def check(p):
+        if (p.state.ip.args[0] == addrStrcpy):    # Ensure that we're at strcpy
+            '''
+             By looking at the disassembly, I've found that the pointer to the
+             source buffer given to strcpy() is kept in RSI.  Here, we dereference
+             the pointer in RSI and grab 8 bytes (len("HAHAHAHA")) from that buffer.
+            '''
+            BV_strCpySrc = p.state.memory.load( p.state.regs.rsi, len(argv[2]) )
+            '''
+             Now that we have the contents of the source buffer in the form of a bit
+             vector, we grab its string representation using the current state's
+             solver engine's function "any_str".
+            '''
+            strCpySrc = p.state.se.any_str( BV_strCpySrc )
+            '''
+             Now we simply return True (found path) if we've found a path to strcpy
+             where we control the source buffer, or False (keep looking for paths) if we
+             don't control the source buffer
+            '''
+            return True if argv[2] in strCpySrc else False
+        else:
+            '''
+             If we aren't in the strcpy function, we need to tell angr to keep looking
+             for new paths.
+            '''
+            return False
+    '''
+     Call the function at the entry_state and find a path that satisfies
+     the check function.  If you specify a tuple/list/set for find or avoid,
+     it translates to an address to find/avoid.  If you just give a function
+     it will pass a Path to the function and check to see if the function returns
+     True or False and proceed accordingly.
+
+     Here, we tell the explore function to find a path that satisfies our check
+     method and avoids any paths that end up in addrBadFunc ('func3')
+    '''
+    path_group = path_group.explore(find=check, avoid=(addrBadFunc,))
+
+    found = path_group.found
+    ''' 
+     Retrieve a concrete value for the password value from the found path.
+     If you put this password in the program's first argument, you should be
+     able to strcpy() any string you want into the destination buffer and
+     cause a segmentation fault if it is too large :)
+    '''
+    if ( len( found ) > 0 ):    #   Make sure we found a path before giving the solution
+        found = path_group.found[0]
+        result = found.state.se.any_str(argv[1])
+    else:   # Aww somehow we didn't find a path.  Time to work on that check() function!
+        result = "Couldn't find any paths which satisfied our conditions."
+    return result
+
+def test():
+    '''
+     angr sometimes returns stuff after the password, so we'll just test the first
+     32 bytes
+    '''
+    assert main()[:27] == "Totally not the password..."
+
+if __name__ == "__main__":
+    print main()
diff --git a/examples/strcpy_find/strcpy_test b/examples/strcpy_find/strcpy_test
new file mode 100755
index 0000000..b70e73f
Binary files /dev/null and b/examples/strcpy_find/strcpy_test differ
