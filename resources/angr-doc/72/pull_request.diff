diff --git a/.gitignore b/.gitignore
index bad49bc..2ca4a88 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
 *.pyc
 api-doc/build
 *.swp
+*.ipynb*
diff --git a/README.md b/README.md
index 2757376..183ff2a 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 # How to be angry
 
-This is a collection of documentation for angr. 
+This is a collection of documentation for angr.
 By reading this, you'll become an angr pro and will be able to fold binaries to your whim.
 
 We've tried to make using angr as pain-free as possible - our goal is to create a user-friendly binary analysis suite, allowing a user to simply start up iPython and easily perform intensive binary analyses with a couple of commands.
@@ -49,3 +49,11 @@ To get help with angr, you can ask via:
 - the mailing list: angr@lists.cs.ucsb.edu
 - the IRC channel: **#angr** on [freenode](https://freenode.net/)
 - opening an issue on the appropriate github repository
+
+## Going further:
+
+You can read this [paper][paper], explaining some of the internals, algorithms,
+and used techniques to get a better understanding on what's going on under the
+hood.
+
+[paper]: https://www.cs.ucsb.edu/~vigna/publications/2016_SP_angrSoK.pdf
diff --git a/docs/analyses.md b/docs/analyses.md
index 89d5a17..256892a 100644
--- a/docs/analyses.md
+++ b/docs/analyses.md
@@ -13,7 +13,7 @@ angr comes with several built-in analyses:
 | [CFGAccurate](analyses/cfg_accurate.md)     | Constructs an accurate *Control Flow Graph* of the program. The simple way to do is via `b.analyses.CFGAccurate()`.                       |
 | VFG                                         | Performs VSA on every function of the program, creating a *Value Flow Graph* and detecting stack variables.                               |
 | DDG                                         | Calculates a data dependency graph, allowing one to determine what statements a given value depends on.                                   |
-| [DFG](../analyses/dfg.md)                      | Constructs a *Data Flow Graph* for each basic block present in the CFG                                                                    |
+| [DFG](analyses/dfg.md)                      | Constructs a *Data Flow Graph* for each basic block present in the CFG                                                                    |
 | [BackwardSlice](analyses/backward_slice.md) | Computes a backward slice of a program w.r.t. a certain target.                                                                           |
 | More!                                       | angr has quite a few analyses, most of which work! If you'd like to know how to use one, please submit an issue requesting documentation. |
 
diff --git a/analyses/dfg.md b/docs/analyses/dfg.md
similarity index 100%
rename from analyses/dfg.md
rename to docs/analyses/dfg.md
diff --git a/docs/claripy.md b/docs/claripy.md
index 4c1ae4e..04e67b6 100644
--- a/docs/claripy.md
+++ b/docs/claripy.md
@@ -13,7 +13,7 @@ However, for dealing with expressions, an understanding of Claripy might be usef
 ## Claripy ASTs
 
 Claripy ASTs abstract away the differences between the constructs that Claripy supports.
-They define a tree of operations (i.e., `(a+b)/c`) on any type of underlying data.
+They define a tree of operations (i.e., `(a + b) / c)` on any type of underlying data.
 Claripy handles the application of these operations on the underlying objects themselves by dispatching requests to the backends.
 
 Currently, Claripy supports the following types of ASTs:
@@ -106,9 +106,9 @@ There are several different frontends.
 |------|-------------|
 | FullFrontend | This is analogous to a `z3.Solver()`. It is a frontend that tracks constraints on symbolic variables and uses a constraint solver (currently, Z3) to evaluate symbolic expressions. |
 | LightFrontend | This frontend uses VSA to reason about values. It is an *approximating* frontend, but produces values without performing constraint solves. |
-| HybridFrontend | This frontend combines VSA and Z3 to allow for *approximating* values. You can specify whether or not you want an exact result from your evaluations, and this frontend does the rest. |
+| ReplacementFrontend | This frontend expands the LightFrontend by allowing the replacement of expressions on-the-fly. It is used as a helper by other frontends and can be used directly to implement exotic analyses. |
+| HybridFrontend | This frontend combines the ReplacementFrontend and the FullFrontend (VSA and Z3) to allow for *approximating* values. You can specify whether or not you want an exact result from your evaluations, and this frontend does the rest. |
 | CompositeFrontend | This frontend implements optimizations that solve smaller sets of constraints to speed up constraint solving. |
-| ReplacementFrontend | This frontend allows the replacement of expressions on-the-fly. It is used as a helper by other frontends and can be used directly to implement exotic analyses. |
 
 Some examples of frontend usage:
 
diff --git a/docs/examples.md b/docs/examples.md
index b018769..c2f8603 100644
--- a/docs/examples.md
+++ b/docs/examples.md
@@ -15,15 +15,19 @@ Binary, source, and script are found [here.](https://github.com/angr/angr-doc/tr
 
 ### ReverseMe example: DEFCON Quals 2016 - baby-re
 
-Script 0 author: David Manouchehri (github: [@Manouchehri](https://github.com/Manouchehri))
+- Script 0
+
+    author: David Manouchehri (github: [@Manouchehri](https://github.com/Manouchehri))
+
+    Script runtime: 8 minutes
 
-Script runtime: 8 minutes
+- Script 1
 
-Script 1 author: Stanislas Lejay (github: [@P1kachu](https://github.com/P1kachu))
+    author: Stanislas Lejay (github: [@P1kachu](https://github.com/P1kachu))
 
-Script runtime: 11 sec
+    Script runtime: 11 sec
 
-Here is the [binary](https://github.com/angr/angr-doc/tree/master/examples/defcon2016quals_baby-re/baby-re) and the scripts:
+Here is the [binary](https://github.com/angr/angr-doc/blob/master/examples/defcon2016quals_baby-re_1/baby-re) and the scripts:
 * [script0](https://github.com/angr/angr-doc/tree/master/examples/defcon2016quals_baby-re_0/solve.py)
 * [script1](https://github.com/angr/angr-doc/tree/master/examples/defcon2016quals_baby-re_1/solve.py)
 
diff --git a/docs/symbolic.md b/docs/symbolic.md
index 88677ba..d04d5a2 100644
--- a/docs/symbolic.md
+++ b/docs/symbolic.md
@@ -7,7 +7,7 @@ value, and each branch as a constraint. Thus, symbolic execution allows us to
 see which conditions allows the program to go from a point A to a point B, by
 resolving the constraints.
 
-Basic archetecture of angr's symbolic execution:
+Basic architecture of angr's symbolic execution:
 
 - simuvex.md is the core engine and provides the concept of a [symbolic machine state](states.md)
 - Also the [means to tick that state forward](simuvex.md) through simulating VEX or running python code
