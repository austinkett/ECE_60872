diff --git a/docs/examples.md b/docs/examples.md
index 876b7f4..083571c 100644
--- a/docs/examples.md
+++ b/docs/examples.md
@@ -17,6 +17,8 @@ Binary, source, and script are found [here.](https://github.com/angr/angr-doc/tr
 
 Script 0 author: David Manouchehri (github: [@Manouchehri](https://github.com/Manouchehri))
 
+Script runtime: 4.5 sec
+
 Script 1 author: Adam Van Prooyen (github: [@docileninja](https://github.com/docileninja))
 
 Script runtime: 6.7 sec
diff --git a/examples/google2016_unbreakable_0/solve.py b/examples/google2016_unbreakable_0/solve.py
old mode 100644
new mode 100755
index 43c3e4e..d0fa401
--- a/examples/google2016_unbreakable_0/solve.py
+++ b/examples/google2016_unbreakable_0/solve.py
@@ -1,48 +1,49 @@
-#!/usr/bin/env python
+#!/usr/bin/env python2
 
 # Author: David Manouchehri <manouchehri@protonmail.com>
 # Google 2016 CTF
 # Challenge: Unbreakable Enterprise Product Activation
+# Team: hack.carleton (http://hack.carleton.team/)
+# Runtime: ~4.5 seconds (single threaded E5-2666 v3 @ 2.90GHz on AWS/EC2)
 
 import angr
 
 def main():
-    proj = angr.Project('./unbreakable-enterprise-product-activation') #, load_options={"auto_load_libs": False})
+    proj = angr.Project('./unbreakable-enterprise-product-activation', load_options={"auto_load_libs": False}) # Disabling the automatic library loading saves a few milliseconds.
 
-    argv1 = angr.claripy.BVS("argv1", 250*8)
+    input_size = 0x43; # Max length from strncpy, see 0x4005ae.
 
-    initial_state = proj.factory.entry_state(args=["./unbreakable-enterprise-product-activation", argv1]) 
-    initial_state.libc.buf_symbolic_bytes=500 # Thanks to @salls for pointing this out.
-
-    # Source: https://github.com/angr/angr-doc/blob/a3f2adac17e16b4633b741ed114692f3a069cc79/examples/whitehatvn2015_re400/solve.py#L10
-    def get_byte(s, i):
-        pos = s.size() / 8 - 1 - i
-        return s[pos * 8 + 7 : pos * 8]
-
-    # For some reason if you constrain less bytes, the solution isn't found.
-    for num in range(0, 75):
-        initial_state.add_constraints(get_byte(argv1, num) != initial_state.se.BVV('\x00'))
+    argv1 = angr.claripy.BVS("argv1", input_size * 8)
 
-    # The .se.BVV('\xXX') is required, just '\xXX' doesn't seem to work.
-    initial_state.add_constraints(get_byte(argv1, 0) == initial_state.se.BVV('\x43')) # C
-    initial_state.add_constraints(get_byte(argv1, 1) == initial_state.se.BVV('\x54')) # T
-    initial_state.add_constraints(get_byte(argv1, 2) == initial_state.se.BVV('\x46')) # F
+    initial_state = proj.factory.entry_state(args=["./unbreakable-enterprise-product-activation", argv1]) 
+    initial_state.libc.buf_symbolic_bytes=input_size + 1 # Thanks to Christopher Salls (@salls) for pointing this out. By default there's only 60 symbolic bytes, which is too small.
+
+    # For some reason if you constrain too few bytes, the solution isn't found. To be safe, I'm constraining them all.
+    for byte in argv1.chop(8):
+        initial_state.add_constraints(byte != '\x00') # null
+        initial_state.add_constraints(byte >= ' ') # '\x20'
+        initial_state.add_constraints(byte <= '~') # '\x7e'
+        # Source: https://www.juniper.net/documentation/en_US/idp5.1/topics/reference/general/intrusion-detection-prevention-custom-attack-object-extended-ascii.html
+        # Thanks to Tom Ravenscroft (@tomravenscroft) for showing me how to restrict to printable characters.
+
+    # We're told that every flag is formatted as "CTF{...}", so we might as well use that information to save processing time. 
+    initial_state.add_constraints(argv1.chop(8)[0] == 'C')
+    initial_state.add_constraints(argv1.chop(8)[1] == 'T')
+    initial_state.add_constraints(argv1.chop(8)[2] == 'F')
+    initial_state.add_constraints(argv1.chop(8)[3] == '{')
+    # angr will still find the solution without setting these, but it'll take a few seconds more.
 
     initial_path = proj.factory.path(initial_state)
     path_group = proj.factory.path_group(initial_state)
-
-    # 0x4005AA = starting of 'good' function
-    # 0x400830 = thank you message
-    # 0x400850 = activation failure
-
+    
+                          # 0x400830 = thank you message
     path_group.explore(find=0x400830, avoid=0x400850)
+                                          # 0x400850 = activation failure
 
-    found = path_group.found[0]
+    found = path_group.found[0] # In our case, there's only one printable solution.
 
     solution = found.state.se.any_str(argv1)
-    #print repr(solution)
-    solution = solution[:solution.find("}")+1]
-    #print solution
+    solution = solution[:solution.find("}")+1] # Trim off the null bytes at the end of the flag (if any).
     return solution
 
 def test():
