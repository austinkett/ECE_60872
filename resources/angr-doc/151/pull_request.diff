diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index c337ec1..98708c8 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -1,35 +1,42 @@
 # Intro
+
 The following cheatsheet aims to give a an overview of various things you can do with angr and as a quick reference to check what exactly the syntax for something was without having to dig through the deeper docs.
 
+WARNING: This page is for angr 6 and some parts will not be correct for angr 7
 
 ## General getting started
+
 Some useful imports
+
 ```python
 import angr #the main framework
 import claripy #the solver engine
 ```
 
 Loading the binary
+
 ```python
-proj = angr.Project("/path/to/binary", load_options={'auto_load_libs': False} ) # auto_load_libs False for improve performance
+proj = angr.Project("/path/to/binary", load_options={'auto_load_libs': False} ) # auto_load_libs False for improved performance
 ```
 
 ## Path Groups
 
 Generate a path group object
+
 ```python
 path_group = proj.factory.path_group(state, threads=4)
 ```
 
 ## Exploring and analysing pathgroups
 
-Choosing a different Exploring strat
+Choosing a different Exploring strategy
+
 ```python
 path_group.use_technique(angr.exploration_techniques.DFS())
 ```
 
+Explore Pathgroup until one pathgroup at one of the adresses from `find=` is found
 
-Explore Pathgroup until one pathgroup at one of the adresses from find is found
 ```python
 avoid_addr = [0x400c06, 0x400bc7]
 find_addr = 0x400c10d
@@ -38,25 +45,29 @@ path_group.explore(find=find_addr, avoid=avoid_addr)
 
 ```python
 found = path_group.found[] # The list of paths that reached find condition from explore
-found.state.se.any_str(sym_arg) # Return a concrete string value for the sym arg to reach this state 
+found.state.se.any_str(sym_arg) # Return a concrete string value for the sym arg to reach this state
 ```
 
-Explore pathgroup until lambda
+Explore pathgroup until lambda is `True`
+
 ```python
 path_group.step(until=lambda p: p.active[0].addr >= first_jmp)
 ```
-This is especially usefull with the ability to access the current STDOUT or STDERR (1 here is the File Descriptor for STDOUT)
+
+This is especially useful with the ability to access the current STDOUT or STDERR (1 here is the File Descriptor for STDOUT)
+
 ```python
 path_group.explore(find=lambda p: "correct" in p.state.posix.dumps(1))
 ```
+
 Memory Managment on big searches (Auto Drop Stashes):
+
 ```python
 path_group.explore(find=find_addr, avoid=avoid_addr, step_func=lambda lpg: lpg.drop(stash='avoid'))
 ```
 
+### Manually Exploring
 
-
-### Manually Exploring:
 ```python
 path_group.step(step_func=step_func, until=lambda lpg: len(lpg.found) > 0)
 
@@ -67,8 +78,8 @@ def step_func(lpg):
     return lpg
 ```
 
-
 Enable Logging:
+
 ```python
 angr.path_group.l.setLevel("DEBUG")
 ```
@@ -76,24 +87,28 @@ angr.path_group.l.setLevel("DEBUG")
 ### Stashes
 
 Move Stash:
+
 ```python
 path_group.stash(from_stash="found", to_stash="active")
 ```
+
 Drop Stashes:
+
 ```python
 path_group.drop(stash="avoid")
 ```
 
-
 ## Constraint Solver (claripy)
 
 Create symbolic object
+
 ```python
-sym_arg_size = 15 #Length in Bytes because we will multiply with 8 later and 
-sym_arg = claripy.BVS('sym_arg', 8*sym_arg_size) 
+sym_arg_size = 15 #Length in Bytes because we will multiply with 8 later
+sym_arg = claripy.BVS('sym_arg', 8*sym_arg_size)
 ```
 
 Restrict sym_arg to typical char range
+
 ```python
 for byte in sym_arg.chop(8):
     initial_state.add_constraints(byte != '\x00') # null
@@ -102,6 +117,7 @@ for byte in sym_arg.chop(8):
 ```
 
 Use the argument to create a state
+
 ```python
 argv = [project.filename]
 argv.append(sym_arg)
@@ -109,6 +125,7 @@ state = project.factory.entry_state(args=argv)
 ```
 
 Use argument for solving:
+
 ```python
 argv1 = angr.claripy.BVS("argv1", flag_size * 8)
 initial_state = b.factory.full_init_state(args=["./antidebug", argv1], add_options=simuvex.o.unicorn, remove_options={simuvex.o.LAZY_SOLVES})
@@ -117,6 +134,7 @@ initial_state = b.factory.full_init_state(args=["./antidebug", argv1], add_optio
 ## FFI and Hooking
 
 Calling a function from ipython
+
 ```python
 f = proj.factory.callable(adress)
 f(10)
@@ -124,29 +142,40 @@ x=claripy.BVS('x', 64)
 f(x) #TODO: Find out how to make that result readable
 ```
 
+If what you are interested in is not directly returned because for example the function returns the pointer to a buffer you can access the state after the function returns with
+
+```python
+>>> f.result_state
+<SimState @ 0x1000550>
+```
+
 Hooking
+
 ```python
 hook(addr, hook, length=0, kwargs=None)
 ```
+
 There are already predefined hooks for libc.so.6 functions (useful for staticly compiled libraries)
+
 ```python
 hook = simuvex.SimProcedures['libc.so.6']['atoi']
 hook(addr, hook, length=4, kwargs=None)
 ```
 
 Hooking with Simprocedure:
+
 ```python
 class fixpid(SimProcedure):
     def run(self):
             return 0x30
-	 
+
 b.hook(0x4008cd, fixpid, length=5)
 ```
 
 ## Other useful tricks
 
-
 Drop into an ipython if a ctr+c is recieved (useful for debugging scripts that are running forever)
+
 ```python
 import signal
 def killmyself():
@@ -154,34 +183,38 @@ def killmyself():
 def sigint_handler(signum, frame):
     print 'Stopping Execution for Debug. If you want to kill the programm issue: killmyself()'
     if not "IPython" in sys.modules:
-		import IPython
-		IPython.embed()
+        import IPython
+        IPython.embed()
 
 signal.signal(signal.SIGINT, sigint_handler)
 ```
 
 Get the calltrace of a pathgroup to find out where we got stuck
+
 ```python
 path = path_group.active[0]
 path.callstack_backtrace
 ```
 
 Get a basic block
+
 ```python
 block = proj.factory.block(address)
 block.capstone.pp() #Capstone object has pretty print and other data about the dissassembly
-block.vex.pp()		#Print vex representation
+block.vex.pp()      #Print vex representation
 ```
 
 ## State manipulation
 
 Write to state:
+
 ```python
 aaaa = claripy.BVV(0x41414141, 32) # 32 = Bits
 state.memory.store(0x6021f2, aaaa)
 ```
 
 Read Pointer to Pointer from Frame:
+
 ```python
 poi1 = new_state.se.any_int(new_state.regs.rbp)-0x10
 poi1 = new_state.se.any_int(new_state.memory.load(poi1, 8, endness='Iend_LE'))
@@ -190,24 +223,25 @@ ptr1 = (new_state.se.any_int(new_state.memory.load(poi1, 8, endness='Iend_LE')))
 ```
 
 Read from State:
+
 ```python
 key = []
 for i in range(38):
-	key.append(extractkey.se.any_int(extractkey.memory.load(0x602140+(i*4), 4, endness='Iend_LE')))
+    key.append(extractkey.se.any_int(extractkey.memory.load(0x602140+(i*4), 4, endness='Iend_LE')))
 ```
 
-
 ## Debugging angr
 
 Set Breakpoint at every Memory read/write:
+
 ```python
 new_state.inspect.b('mem_read', when=simuvex.BP_AFTER, action=debug_funcRead)
 def debug_funcRead(state):
-	print 'Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address
+    print 'Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address
 ```
 
 Set Breakpoint at specific Memory location:
+
 ```python
 new_state.inspect.b('mem_write', mem_write_address=0x6021f1, when=simuvex.BP_AFTER, action=debug_funcWrite)
 ```
-
diff --git a/README.md b/README.md
index 54c3ffe..f4ef018 100644
--- a/README.md
+++ b/README.md
@@ -2,7 +2,7 @@
 
 angr is a multi-architecture binary analysis toolkit, with the capability to perform dynamic symbolic execution \(like Mayhem, KLEE, etc.\) and various static analyses on binaries. If you'd like to learn how to use it, you're in the right place!
 
-We've tried to make using angr as pain-free as possible - our goal is to create a user-friendly binary analysis suite, allowing a user to simply start up iPython and easily perform intensive binary analyses with a couple of commands. That being said, binary analysis is complex, which makes angr complex. This documentation is an attempt to help out with that, providing narritive explanation and exploration of angr and its design.
+We've tried to make using angr as pain-free as possible - our goal is to create a user-friendly binary analysis suite, allowing a user to simply start up iPython and easily perform intensive binary analyses with a couple of commands. That being said, binary analysis is complex, which makes angr complex. This documentation is an attempt to help out with that, providing narrative explanation and exploration of angr and its design.
 
 Several challenges must be overcome to programmatically analyze a binary. They are, roughly:
 
diff --git a/SUMMARY.md b/SUMMARY.md
index 56b40a9..40dd2a3 100644
--- a/SUMMARY.md
+++ b/SUMMARY.md
@@ -9,7 +9,7 @@
   * [Solver Engine](docs/solver.md)
   * [Program State](docs/states.md)
   * [Simulation Managers](docs/pathgroups.md)
-  * [Execution Engines](docs/simuvex.md)
+  * [TODO: Execution Engines](docs/simuvex.md)
 * [Analyses](docs/analyses.md)
   * [CFGAccurate](docs/analyses/cfg_accurate.md)
   * [Backward Slicing](docs/analyses/backward_slice.md)
@@ -20,14 +20,14 @@
   * [Intermediate Representation](docs/ir.md)
   * [Working with Data and Conventions](docs/structured_data.md)
   * [Claripy](docs/claripy.md)
-  * [Symbolic Memory Addressing](docs/concretization_strategies.md)
+  * [TODO: Symbolic Memory Addressing](docs/concretization_strategies.md)
 * Extending angr
   * [Programming SimProcedures](docs/simprocedures.md)
-  * [Extending the Environment Model](docs/environment.md)
-  * [Writing Exploration Techniques](docs/otiegnqwvk.md)
+  * [TODO: Extending the Environment Model](docs/environment.md)
+  * [TODO: Writing Exploration Techniques](docs/exploration_techniques.md)
   * [Writing Analyses](docs/analysis_writing.md)
-  * [Adding Support for New Platforms](docs/angr-bf.md)
+  * [TODO: Adding Support for New Platforms](docs/angr-bf.md)
 * [Examples](docs/examples.md)
 * [FAQ](docs/faq.md)
 * [Changelog](CHANGELOG.md)
-  * [Migrating from angr 6](MIGRATION.md)
+  * [TODO: Migrating from angr 6](MIGRATION.md)
