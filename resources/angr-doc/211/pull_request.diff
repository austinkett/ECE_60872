diff --git a/CHANGELOG.md b/CHANGELOG.md
index ea6271a..592c18a 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,6 +3,22 @@
 This lists the *major* changes in angr.
 Tracking minor changes are left as an exercise for the reader :-)
 
+## angr 8.X.X.X
+
+Welcome to angr 8!
+The biggest change for this major version bump is the transition to python 3.
+You can read about this, as well as a few other breaking changes, in the [migration guide](MIGRATION.md).
+
+- Switch to python 3
+- Refactor to Clemory to clean up the API and speed things up drastically
+- Remove `object.symbols_by_addr` (dict) and add `object.symbols` (sorted list); add `fuzzy` parameter to `loader.find_symbol`
+- CFGFast is much, much faster now. CFGAccurate has been renamed to CFGEmulated.
+- Support for avx2 unpack instructions, courtesy of D. J. Bernstein
+- Removed support for immutable simulation managers
+- angr will now show you a warning when using uninitialized memory or registers
+- angr will now NOT show you a warning if you have a capstone 3.x install unless you're actually interacting with the relevant missing parts
+- Many, many, many bug fixes
+
 ## angr 7.8.7.1
 
 - Remove `LoopLimiter` and `DFG`.
@@ -58,7 +74,7 @@ Tracking minor changes are left as an exercise for the reader :-)
 
 Welcome to angr 7!
 We worked long and hard all summer to make this release the best ever.
-It introduces several breaking changes, so for a quick guide on the most common ways you'll need to update your scripts, take a look at the [migration guide](MIGRATION.md).
+It introduces several breaking changes, so for a quick guide on the most common ways you'll need to update your scripts, take a look at the [migration guide](docs/migration-7.md).
 
 - SimuVEX has been removed and its components have been integrated into angr
 - Path has been removed and its components have been integrated into SimState, notably the new `history` state plugin
diff --git a/INSTALL.md b/INSTALL.md
index 830b3b4..96b641f 100644
--- a/INSTALL.md
+++ b/INSTALL.md
@@ -1,6 +1,6 @@
 # Installing angr
 
-angr is a python library, so it must be installed into your python environment before it can be used. It is built for Python 2: Py3k support is feasible somewhere out in the future, but we are a little hesitant to make that commitment right now (pull requests welcome!).
+angr is a python library, so it must be installed into your python environment before it can be used. It is built for Python 3: Python 2 support is not feasable due to the looming EOL and the small size of our team.
 
 We highly recommend using a [python virtual environment](https://virtualenvwrapper.readthedocs.org/en/latest/) to install and use angr. Several of angr's dependencies (z3, pyvex) require libraries of native code that are forked from their originals, and if you already have libz3 or libVEX installed, you definitely don't want to overwrite the official shared objects with ours. In general, don't expect support for problems arising from installing angr outside of a virtualenv.
 
@@ -8,19 +8,19 @@ We highly recommend using a [python virtual environment](https://virtualenvwrapp
 
 All of the python dependencies should be handled by pip and/or the setup.py scripts. You will, however, need to build some C to get from here to the end, so you'll need a good build environment as well as the python development headers. At some point in the dependency install process, you'll install the python library cffi, but (on linux, at least) it won't run unless you install your operating system's libffi package.
 
-On Ubuntu, you will want: `sudo apt-get install python-dev libffi-dev build-essential virtualenvwrapper`. If you are trying out angr-management, you will need `sudo apt-get install libqt4-dev graphviz-dev`.
+On Ubuntu, you will want: `sudo apt-get install python3-dev libffi-dev build-essential virtualenvwrapper`. If you are trying out angr-management, you will need the [PySide 2 requirements](https://wiki.qt.io/Qt_for_Python/GettingStarted) along with `graphviz-dev`.
 
 ### Most Operating systems, all \*nix systems
 
-`mkvirtualenv angr && pip install angr` should usually be sufficient to install angr in most cases, since angr is published on the Python Package Index.
+`mkvirtualenv --python=$(which python3) angr && pip install angr` should usually be sufficient to install angr in most cases, since angr is published on the Python Package Index.
 
 Fish (shell) users can either use [virtualfish](https://github.com/adambrenecki/virtualfish) or the [virtualenv](https://pypi.python.org/pypi/virtualenv) package: `vf new angr && vf activate angr && pip install angr`
 
 Failing that, you can install angr by installing the following repositories (and the dependencies listed in their requirements.txt files), in order, from https://github.com/angr:
 
-- [claripy](https://github.com/angr/claripy)
 - [archinfo](https://github.com/angr/archinfo)
 - [pyvex](https://github.com/angr/pyvex)
+- [claripy](https://github.com/angr/claripy)
 - [cle](https://github.com/angr/cle)
 - [angr](https://github.com/angr/angr)
 
@@ -39,9 +39,9 @@ After installing angr, you will need to fix some shared library paths for the an
 Activate your virtual env and execute the following lines. [A script](https://github.com/angr/angr-dev/blob/master/fix_macOS.sh) is provided in the angr-dev repo.
 
 ```bash
-PYVEX=`python2 -c 'import pyvex; print pyvex.__path__[0]'`
-UNICORN=`python2 -c 'import unicorn; print unicorn.__path__[0]'`
-ANGR=`python2 -c 'import logging; logging.basicConfig(level=logging.CRITICAL); import angr; print angr.__path__[0]'`
+PYVEX=`python3 -c 'import pyvex; print pyvex.__path__[0]'`
+UNICORN=`python3 -c 'import unicorn; print unicorn.__path__[0]'`
+ANGR=`python3 -c 'import angr; print angr.__path__[0]'`
 
 install_name_tool -change libunicorn.1.dylib "$UNICORN"/lib/libunicorn.dylib "$ANGR"/lib/angr_native.dylib
 install_name_tool -change libpyvex.dylib "$PYVEX"/lib/libpyvex.dylib "$ANGR"/lib/angr_native.dylib
@@ -49,27 +49,44 @@ install_name_tool -change libpyvex.dylib "$PYVEX"/lib/libpyvex.dylib "$ANGR"/lib
 
 ### Windows
 
-angr can _probably_ be installed from pip on Windows, given that you're in a shell with the visual studio build tools loaded.
+As usual, a virtualenv is very strongly recommended. You can use either the [virtualenv-win](https://pypi.org/project/virtualenvwrapper-win/) or [virtualenv](https://pypi.python.org/pypi/virtualenv) packages for this.
 
-Capstone is difficult to install on windows. You might need to manually specify a wheel to install, but sometimes it installs under a name different from "capstone", so if that happens you want to just remove capstone from the requirements.txt files in angr and archinfo.
+angr can be installed from pip on Windows, same as above: `pip install angr`.
+You should not be required to build any C code with this setup, since wheels (binary distributions) should be automatically pulled down for angr and its dependencies.
 
 # Development install
 
-We created a repo with scripts to make life easier for angr developers.
+There is a special repository `angr-dev` with scripts to make life easier for angr developers.
 You can set up angr in development mode by running:
 
 ```bash
-git clone git@github.com:angr/angr-dev.git
+git clone https://github.com/angr/angr-dev
 cd angr-dev
-mkvirtualenv angr
-./setup.sh
+./setup.sh -i -e angr
 ```
 
-This clones all of the repositories and installs them in editable mode.
-`setup.sh` can even create a PyPy virtualenv for you, resulting in significantly faster performance and lower memory usage.
+This creates a virtualenv (`-e angr`), checks for any dependencies you might need (`-i`), clones all of the repositories and installs them in editable mode.
+`setup.sh` can even create a PyPy virtualenv for you (replace `-e` with `-p`), resulting in significantly faster performance and lower memory usage.
 
 You can branch/edit/recompile the various modules in-place, and it will automatically reflect in your virtual environment.
 
+## Development install on windows
+
+The angr-dev repository has a setup.bat script that creates the same setup as above, though it's not as magical as setup.sh.
+Since we'll be building C code, you must be in the visual studio developer command prompt.
+*Make sure that if you're using a 64-bit python interpreter, you're also using the 64-bit build tools* (`VsDevCmd.bat -arch=x64`)
+
+```bash
+pip install virtualenv
+git clone https://github.com/angr/angr-dev
+cd angr-dev
+virtualenv -p "C:\Path\To\python3\python.exe" env
+env\Scripts\activate
+setup.bat
+```
+
+You may also substitute the use of `virtualenv` above with the `virtualenvwrapper-win` package for a more streamlined experience.
+
 ## Docker install
 
 For convenience, we ship a Docker image that is 99% guaranteed to work.
@@ -113,12 +130,23 @@ pip install -I --no-binary z3-solver z3-solver
 
 ## No such file or directory: 'pyvex_c'
 
-Are you running Ubuntu 12.04? If so, please stop using a 5 year old operating system! Upgrading is free!
+Are you running Ubuntu 12.04? If so, please stop using a 6 year old operating system! Upgrading is free!
 
-You can also try upgrading pip (`pip install -U pip`), which might solve the issue.
+You can also try upgrading pip (`python -m pip install -U pip`), which might solve the issue.
 
 ## AttributeError: 'FFI' object has no attribute 'unpack'
 
 You have an outdated version of the `cffi` Python module.  angr now requires at least version 1.7 of cffi.
 Try `pip install --upgrade cffi`.  If the problem persists, make sure your operating system hasn't pre-installed an old version of cffi, which pip may refuse to uninstall.
 If you're using a Python virtual environment with the pypy interpreter, ensure you have a recent version of pypy, as it includes a version of cffi which pip will not upgrade.
+
+## angr has no attribute Project, or similar
+
+If you can import angr but it doesn't seem to be the actual angr module... did you accidentally name your script `angr.py`?
+You can't do that. Python does not work that way.
+
+# AttributeError: 'module' object has no attribute 'KS_ARCH_X86'
+
+You have the `keystone` package installed, which conflicts with the `keystone-engine` package (an optional dependency of angr).
+Please uninstall `keystone`.
+If you would like to install `keystone-engine`, please do it with `pip install --no-binary keystone-engine keystone-engine`, as the current pip distribution is broken.
diff --git a/MIGRATION.md b/MIGRATION.md
index 8c2b7d6..f0e479a 100644
--- a/MIGRATION.md
+++ b/MIGRATION.md
@@ -1,158 +1,91 @@
-# Migrating to angr 7
+# Migrating to angr 8
 
-The release of angr 7 introduces several departures from long-standing angr-isms.
-While the community has created a compatibility layer to give external code written for angr 6 a good chance of working on angr 7, the best thing to do is to port it to the new version.
-This document serves as a guide for this.
+angr has moved from python 2 to python 3!
+We took this opportunity of a major version bump to make a few breaking API changes that improve quality-of-life.
 
-## SimuVEX is gone
+## What do I need to know for migrating my scripts to python 3?
 
-angr versions up through angr 6 split the program analysis into two modules: `simuvex`, which was responsible for analyzing the effects of a single piece of code (whether a basic block or a SimProcedure) on a program state, and `angr`, which aggregated analyses of these basic blocks into program-level analysis such as control-flow recovery, symbolic execution, and so forth.
-In theory, this would encourage for the encapsulation of block-level analyses, and allow other program analysis frameworks to build upon `simuvex` for their needs.
-In practice, no one (to our knowledge) used `simuvex` without `angr`, and the separation introduced frustrating limitations (such as not being able to reference the history of a state from a SimInspect breakpoint) and duplication of code (such as the need to synchronize data from `state.scratch` into `path.history`).
+To begin, just the standard py3k changes, the relevant parts of which we'll rehash here as a reference guide:
 
-Realizing that SimuVEX wasn't a usable independent package, we brainstormed about merging it into angr and further noticed that this would allow us to address the frustrations resulting from their separation.
+- Strings and bytestrings
+  - Strings are now unicode by default, a new `bytes` type holds bytestrings
+  - Bytestring literals can be constructued with the b prefix, like `b'ABCD'`
+  - Conversion between strings and bytestrings happens with `.encode()` and `.decode()`, which use utf-8 as a default. The `latin-1` codec will map byte values to their equivilant unicode codepoints
+  - The `ord()` and `chr()` functions operate on strings, not bytestrings
+  - Enumerating over or indexing into bytestrings produces an unsigned 8 bit integer, not a 1-byte bytestring
+  - Bytestrings have all the string manipulation functions present on strings, including `join`, `upper`/`lower`, `translate`, etc
+  - `hex` and `base64` are no longer string encoding codecs. For hex, use `bytes.fromhex()` and `bytes.hex()`. For base64 use the `base64` module.
+- Builtin functions
+  - `print` and `exec` are now builtin functions instead of statements
+  - Many builtin functions previously returning lists now return iterators, such as `map`, `filter`, and `zip`. `reduce` is no longer a builtin; you have to import it from `functools`.
+- Numbers
+  - The `/` operator is explicitly floating-point division, the `//` operator is expliclty integer division. The magic functions for overriding these ops are `__truediv__` and `__floordiv__`
+  - The int and long types have been merged, there is only int now
+- Dictionary objects have had their `.iterkeys`, `.itervalues`, and `.iteritems` methods removed, and then non-iter versions have been made to return efficient iterators
+- Comparisons between objects of very different types (such as between strings and ints) will raise an exception
 
-All of the SimuVEX concepts (SimStates, SimProcedures, calling conventions, types, etc) have been migrated into angr.
-The migration guide for common classes is bellow:
+In terms of how this has affected angr, any string that represents data from the emulated program will be a bytestring.
+This means that where you previously said `state.solver.eval(x, cast_to=str)` you should now say `cast_to=bytes`.
+When creating concrete bitvectors from strings (including implicitly by just making a comparison against a string) these should be bytestrings. If they are not they will be utf-8 converted and a warning will be printed.
+Symbol names should be unicode strings.
 
-| Before | After |
-|--------|-------|
-| simuvex.SimState | angr.SimState |
-| simuvex.SimProcedure | angr.SimProcedure |
-| simuvex.SimEngine | angr.SimEngine |
-| simuvex.SimCC | angr.SimCC |
-
-And for common modules:
-
-| Before | After |
-|--------|-------|
-| simuvex.s_cc | angr.calling_conventions |
-| simuvex.s_state | angr.sim_state |
-| simuvex.s_procedure | angr.sim_procedure |
-| simuvex.plugins | angr.state_plugins |
-| simuvex.engines | angr.engines |
-| simuvex.concretization_strategies | angr.concretization_strategies |
+For division, however, ASTs are strongly typed so they will treat both division operators as the kind of division that makes sense for their type.
 
-Additionally, `simuvex.SimProcedures` has been renamed to `angr.SIM_PROCEDURES`, since it is a global variable and not a class.
-There have been some other changes to its semantics, see the section on SimProcedures for details.
+## Clemory API changes
 
-## Removal of angr.Path
-
-In angr, a Path object maintained references to a SimState and its history.
-The fact that the history was separated from the state caused a lot of headaches when trying to analyze states inside a breakpoint, and caused overhead in synchronizing data from the state to its history.
-
-In the new model, a state's history is maintained in a SimState plugin: `state.history`.
-Since the path would now simply point to the state, we got rid of it.
-The mapping of concepts is roughly as follows:
+The memory object in CLE (project.loader.memory, not state.memory) has had a few breaking API changes since the bytes type is much nicer to work with than the py2 string for this specific case, and the old API was an inconsistent mess.
 
 | Before | After |
 |--------|-------|
-| path | state |
-| path.state | state |
-| path.history | state.history |
-| path.callstack | state.callstack |
-| path.trace | state.history.descriptions |
-| path.addr_trace | state.history.bbl_addrs |
-| path.jumpkinds | state.history.jumpkinds |
-| path.guards | state.history.guards |
-| path.actions | state.history.actions |
-| path.events | state.history.events |
-| path.recent_actions | state.history.recent_actions |
-
-An important behavior change about `path.actions` and `path.recent_actions` - actions are no longer tracked by default.
-If you would like them to be tracked again, please add `angr.options.refs` to your state.
-
-### Path Group -> Simulation Manager
-
-Since there are no paths, there cannot be a path group.
-Instead, we have a Simulation Manager now (we recommend using the abbreviation "simgr" in places you were previously using "pg"), which is exactly the same as a path group except it holds states instead of paths.
-You can make one with `project.factory.simulation_manager(...)`.
+| `memory.read_bytes(addr, n) -> list[str]` | `memory.load(addr, n) -> bytes` |
+| `memory.write_bytes(addr, list[str])` | `memory.store(addr, bytes)` |
+| `memory.get_byte(addr) -> str` | `memory[addr] -> int` |
+| `memory.read_addr_at(addr) -> int` | `memory.unpack_word(addr) -> int` |
+| `memory.write_addr_at(addr, value) -> int` | `memory.pack_word(addr, value)` |
+|  `memory.stride_repr -> list[(start, end, str)]` | `memory.backers() -> iter[(start, bytearray)]` |
 
-### Errored Paths
+Additionally, `pack_word` and `unpack_word` now take optional `size`, `endness`, and `signed` parameters.
+We have also added `memory.pack(addr, fmt, *data)` and `memory.unpack(addr, fmt)`, which take format strings for use with the `struct` module.
 
-Before, error resilience was handled at the path level, where stepping a path that caused an error would return a subclass of Path called ErroredPath, and these paths would be put in the `errored` stash of a path group.
-Now, error resilience is handled at the simulation manager level, and any state that throws an error during stepping will be wrapped in an ErrorRecord object, which is _not_ a subclass of SimState, and put into the `errored` list attribute of the simulation manager, which is _not_ a stash.
+If you were using the `cbackers` or `read_bytes_c` functions, the conversion is a little more complicated - we were able to remove the split notion of "backers" and "updates" and replaced all backers with bytearrays that we mutate, so we can work directly with the backer objects.
+The `backers()` function iterates through all bottom-level backer objects and their start addresses. You can provide an optional address to the function, and it will skip over all backers that end before that address.
 
-An ErrorRecord object has attributes for `.state` (the initial state that caused the error), `.error` (the error that was thrown), and `.traceback` (the traceback from the error).
-To debug these errors you can call `.debug()`.
+Here is some sample code for producing a C-pointer to a given address:
 
-These changes are because we were uncomfortable making a subclass of SimState, and the ErrorRecord class then has sufficiently different semantics from a normal state that it cannot be placed in a stash.
+```python
+import cffi, cle
+ffi = cffi.FFI()
+ld = cle.Loader('/bin/true')
 
-## Changes to SimProcedures
+addr = ld.main_object.entry
+try:
+    backer_start, backer = next(ld.memory.backers(addr))
+except StopIteration:
+    raise Exception("not mapped")
 
-The most noticeable difference from the old version to the new version is that the catalog of built-in simprocedures are no longer organized strictly according to which library they live in.
-Now, they are organized according to which _standards_ they conform to, which helps with re-using procedures between different libraries.
-For instance, the old `SimProcedures['libc.so.6']` has been split up between `SIM_PROCEDURES['libc']`, `SIM_PROCEDURES['posix']`, and `SIM_PROCEDURES['glibc']`, depending on what specifications each function conforms to.
-This allows us to reuse the `libc` catalog in `msvcrt.dll` and the MUSL libc, for example.
+if backer_start > addr:
+    raise Exception("not mapped")
 
-In order to group SimProcedures together by libraries, we have introduced a new abstraction called the SimLibrary, the definitions for which are stored in `angr.procedures.definitions`.
-Each SimLibrary object stores information about a single shared library, and can contain SimProcedure implementations, calling convention information, and type information.
-SimLibraries are scraped from the filesystem at import time, just like SimProcedures, and placed into `angr.SIM_LIBRARIES`.
+cbacker = ffi.from_buffer(backer)
+addr_pointer = cbacker + (addr - backer_start)
+```
 
-Syscalls are now categorized through a subclass of SimLibrary called SimSyscallLibrary.
-The API for managing syscalls through SimOS has been changed - check the API docs for the SimUserspace class.
+You should not have to use this if you aren't passing the data to a native library - the normal load methods should now be more than fast enough for intensive use.
 
-One important implication of this change is that if you previously used a trick where you changed one of the SimProcedures present in the `SimProcedures` dict in order to change which SimProcedures would be used to hook over library functions by default, this will no longer work.
-Instead of `SimProcedures[lib][func_name] = proc`, you now need to say `SIM_LIBRARIES[lib].add(func_name, proc)`.
-But really you should just be using `hook_symbol` anyway.
+## CLE symbols changes
 
-## Changes to hooking
+Previously, your mechanisms for looking up symbols by their address were `loader.find_symbol()` and `object.symbols_by_addr`, where there was clearly some overlap.
+However, `symbols_by_addr` stayed because it was the only way to enumerate symbols in an object.
+This has changed! `symbols_by_addr` is deprecated and here is now `object.symbols`, a sorted list of Symbol objects, to enumerate symbols in a binary.
 
-The `Hook` class is gone.
-Instead, we now can hook with individual instances of SimProcedure objects, as opposed to just the classes.
-A shallow copy of the SimProcedure will be made at runtime to preserve thread safety.
+Additionally, you can now enumerate all symbols in the entire project with `loader.symbols`.
+This change has also enabled us to add a `fuzzy` parameter to `find_symbol` (returns the first symbol before the given address) and make the output of `loader.describe_addr` much nicer (shows offset from closest symbol).
 
-So, previously, where you would have done `project.hook(addr, Hook(proc, ...))` or `project.hook(addr, proc)`, you can now do `project.hook(addr, proc(...))`.
-In order to use simple functions as hooks, you can either say `project.hook(addr, func)` or decorate the declaration of your function with `@project.hook(addr)`.
+## Deprecations and name changes
 
-Having simprocedures as instances and letting them have access to the project cleans up a lot of other hacks that were present in the codebase, mostly related to the `self.call(...)` SimProcedure continuation system.
-It is no longer required to set `IS_FUNCTION = True` if you intend to use `self.call()` while writing a SimProcedure, and each call-return target you use will have a unique address associated with it.
-These addresses will be allocated lazily, which does have the side effect of making address allocation nondeterministic, sometimes based on dictionary-iteration order.
-
-## Changes to loading
-
-The `hook_symbol` method will no longer attempt to redo relocations for the given symbol, instead just hooking directly over the address of the symbol in whatever library it comes from.
-This speeds up loading substancially and ensures more consistent behavior for when mixing and matching native library code and SimProcedure summaries.
-
-The angr externs object has been moved into CLE, which will ALWAYS make sure that every dependency is resolved to something, never left unrelocated.
-Similarly, CLE provides the "kernel object" used to provide addresses for syscalls now.
-
-| Before | After |
-|--------|-------|
-| `project._extern_obj` | `loader.extern_object` |
-| `project._syscall_obj` | `loader.kernel_object` |
-
-Several properties and methods have been renamed in CLE in order to maintain a more consistent and explicit API.
-The most common changes are listed below:
-
-| Before | After |
-|--------|-------|
-| `loader.whats_at()` | `loader.describe_addr` |
-| `loader.addr_belongs_to_object()` | `loader.find_object_containing()` |
-| `loader.find_symbol_name()` | `loader.find_symbol().name` |
-| whatever the hell you were doing before to look up a symbol | `loader.find_symbol(name or addr)`
-| `loader.find_module_name()` | `loader.find_object_containing().provides` |
-| `loader.find_symbol_got_entry()` | `loader.find_relevant_relocations()` |
-| `loader.main_bin` | `loader.main_object` |
-| `anything.get_min_addr()` | `anything.min_addr` |
-| `symbol.addr` | `symbol.linked_addr` |
-
-## Changes to the solver interface
-
-We cleaned up the menagerie of functions present on `state.solver` (if you're still referring to it as `state.se` you should stop) and simplified it into a cleaner interface:
-
-- `solver.eval(expression)` will give you one possible solution to the given expression.
-- `solver.eval_one(expression)` will give you the solution to the given expression, or throw an error if more than one solution is possible.
-- `solver.eval_upto(expression, n)` will give you up to n solutions to the given expression, returning fewer than n if fewer than n are possible.
-- `solver.eval_atleast(expression, n)` will give you n solutions to the given expression, throwing an error if fewer than n are possible.
-- `solver.eval_exact(expression, n)` will give you n solutions to the given expression, throwing an error if fewer or more than are possible.
-- `solver.min(expression)` will give you the minimum possible solution to the given expression.
-- `solver.max(expression)` will give you the maximum possible solution to the given expression.
-
-Additionally, all of these methods can take the following keyword arguments:
-
-- `extra_constraints` can be passed as a tuple of constraints.
-  These constraints will be taken into account for this evaluation, but will not be added to the state.
-- `cast_to` can be passed a data type to cast the result to.
-  Currently, this can only be `str`, which will cause the method to return the byte representation of the underlying data.
-  For example, `state.solver.eval(state.solver.BVV(0x41424344, 32, cast_to=str)` will return `"ABCD"`.
+- All parameters in cle that started with `custom_` - so, `custom_base_addr`, `custom_entry_point`, `custom_offset`, `custom_arch`, and `custom_ld_path` - have had the `custom_` removed from the beginning of their names.
+- All the functions that were deprecated more than a year ago (at or before the angr 7 release) have been removed.
+- `state.se` has been deprecated.
+  You should have been using `state.solver` for the past few years.
+- Support for immutable simulation managers has been removed.
+  So far as we're aware, nobody was actually useing this, and it was making debugging a pain.
diff --git a/SUMMARY.md b/SUMMARY.md
index da2ed65..fc3f6cf 100644
--- a/SUMMARY.md
+++ b/SUMMARY.md
@@ -1,6 +1,7 @@
 # Summary
 
-* [Introduction](README.md)
+* Welcome to angr!
+  * [Introduction](README.md)
   * [Installing](INSTALL.md)
   * [How to Contribute](HACKING.md)
   * [What to Contribute](HELPWANTED.md)
@@ -15,7 +16,7 @@
   * [Analyses](docs/analyses.md)
   * [Remarks](docs/be_creative.md)
 * Built-in Analyses
-  * [CFGAccurate](docs/analyses/cfg_accurate.md)
+  * [CFG](docs/analyses/cfg.md)
   * [Backward Slicing](docs/analyses/backward_slice.md)
   * [Function Identifier](docs/analyses/identifier.md)
 * Advanced Topics
@@ -38,4 +39,5 @@
   * [List of Claripy Operations](docs/appendices/ops.md)
   * [List of State Options](docs/appendices/options.md)
   * [Changelog](CHANGELOG.md)
-  * [Migrating to angr 7](MIGRATION.md)
+  * [Migrating to angr 8](MIGRATION.md)
+  * [Migrating to angr 7](docs/migration-7.md)
diff --git a/api-doc/source/angr.rst b/api-doc/source/angr.rst
index 56b0397..3a841f9 100644
--- a/api-doc/source/angr.rst
+++ b/api-doc/source/angr.rst
@@ -169,7 +169,7 @@ Analysis
 .. automodule:: angr.analyses.cfg
 .. automodule:: angr.analyses.cfg.cfb
 .. automodule:: angr.analyses.cfg.cfg
-.. automodule:: angr.analyses.cfg.cfg_accurate
+.. automodule:: angr.analyses.cfg.cfg_emulated
 .. automodule:: angr.analyses.cfg.cfg_base
 .. automodule:: angr.analyses.cfg.cfg_fast
 .. automodule:: angr.analyses.cfg.cfg_node
diff --git a/api-doc/source/conf.py b/api-doc/source/conf.py
index 20d1842..71614a9 100644
--- a/api-doc/source/conf.py
+++ b/api-doc/source/conf.py
@@ -114,9 +114,11 @@
 intersphinx_mapping = {'python': ('https://docs.python.org/2.7', None)}
 
 autoclass_content = "both"
+autodoc_inherit_docstrings = False
 autodoc_member_order = 'bysource'
 autodoc_default_options = {
         'members': None,
+        'member-order': 'bysource',
         #'special-members': None,
         'show-inheritance': None,
         # 'private-members': None,
@@ -283,7 +285,6 @@ def setup(app):
 # (source start file, name, description, authors, manual section).
 man_pages = [
     ('angr', 'angr', u'angr analysis module', [author], 3),
-    ('simuvex', 'simuvex', u'angr emulation and instrumentation module', [author], 3),
     ('claripy', 'claripy', u'angr numerical and constraint-solving module', [author], 3),
     ('cle', 'cle', u'angr binary loader', [author], 3),
     ('pyvex', 'pyvex', u'angr binary translator', [author], 3),
diff --git a/api-doc/source/pyvex.rst b/api-doc/source/pyvex.rst
index 0e115a0..7b418f4 100644
--- a/api-doc/source/pyvex.rst
+++ b/api-doc/source/pyvex.rst
@@ -27,8 +27,9 @@ Lifting System
 .. automodule:: pyvex.lifting.lifter
 .. automodule:: pyvex.lifting.post_processor
 .. automodule:: pyvex.lifting.util.irsb_postprocess
-.. automodule:: pyvex.lifting.util.syntax_wrapper
 .. automodule:: pyvex.lifting.util
+.. automodule:: pyvex.lifting.gym
+.. automodule:: pyvex.lifting.util.syntax_wrapper
 .. automodule:: pyvex.lifting.util.vex_helper
 .. automodule:: pyvex.lifting.util.lifter_helper
 .. automodule:: pyvex.lifting.util.instr_helper
@@ -37,6 +38,7 @@ Builtin IR Processors
 ---------------------
 
 .. automodule:: pyvex.lifting.zerodivision
+.. automodule:: pyvex.lifting.gym.arm_spotter
 
 Errors
 ------
diff --git a/docs/analyses.md b/docs/analyses.md
index 459c2b4..ed3540d 100644
--- a/docs/analyses.md
+++ b/docs/analyses.md
@@ -9,7 +9,7 @@ We will cover writing your own analyses [later](analysis_writing.md), but the id
 | Name                                        | Description                                                                                                                               |
 | --------                                    | -------------                                                                                                                             |
 | CFGFast                                     | Constructs a fast *Control Flow Graph* of the program                                                                                     |
-| [CFGAccurate](analyses/cfg_accurate.md)     | Constructs an accurate *Control Flow Graph* of the program                                                                                |
+| [CFGEmulated](analyses/cfg.md)     | Constructs an accurate *Control Flow Graph* of the program                                                                                |
 | VFG                                         | Performs VSA on every function of the program, creating a *Value Flow Graph* and detecting stack variables                                |
 | DDG                                         | Calculates a *Data Dependency Graph*, allowing one to determine what statements a given value depends on                                  |
 | [BackwardSlice](analyses/backward_slice.md) | Computes a *Backward Slice* of a program with respect to a certain target                                                                 |
diff --git a/docs/analyses/backward_slice.md b/docs/analyses/backward_slice.md
index 6109aba..d15bb00 100644
--- a/docs/analyses/backward_slice.md
+++ b/docs/analyses/backward_slice.md
@@ -13,7 +13,7 @@ This section will act as a how-to for angr’s `BackwardSlice` analysis, and fol
 
 To build a `BackwardSlice`, you will need the following information as input.
 
-- **Required** CFG. A control flow graph (CFG) of the program. This CFG must be an accurate CFG (CFGAccurate).
+- **Required** CFG. A control flow graph (CFG) of the program. This CFG must be an accurate CFG (CFGEmulated).
 - **Required** Target, which is the final destination that your backward slice terminates at.
 - **Optional** CDG. A control dependence graph (CDG) derived from the CFG.
 angr has a built-in analysis `CDG` for that purpose.
@@ -31,7 +31,7 @@ A `BackwardSlice` can be constructed with the following code:
 # you’ll have to keep all input states by specifying keep_state=True. Feel free 
 # to provide more parameters (for example, context_sensitivity_level) for CFG 
 # recovery based on your needs.
->>> cfg = b.analyses.CFGAccurate(context_sensitivity_level=2, keep_state=True)
+>>> cfg = b.analyses.CFGEmulated(context_sensitivity_level=2, keep_state=True)
 
 # Generate the control dependence graph
 >>> cdg = b.analyses.CDG(cfg)
@@ -53,7 +53,7 @@ A `BackwardSlice` can be constructed with the following code:
 >>> bs = b.analyses.BackwardSlice(cfg, cdg=cdg, ddg=ddg, targets=[ (target_node, -1) ])
 
 # Here is our awesome program slice!
->>> print bs
+>>> print(bs)
 
 ```
 
diff --git a/docs/analyses/cfg_accurate.md b/docs/analyses/cfg.md
similarity index 58%
rename from docs/analyses/cfg_accurate.md
rename to docs/analyses/cfg.md
index fe4bb45..53fce9b 100644
--- a/docs/analyses/cfg_accurate.md
+++ b/docs/analyses/cfg.md
@@ -1,104 +1,47 @@
-# CFGAccurate
+# Control-flow Graph Recovery (CFG)
 
-Here we describe angr’s CFGAccurate analysis in details, as well as some important concepts like context sensitivity and Function Manager of angr.
+angr includes analyses to recover the control-flow graph of a binary program.
+This also includes recovery of function boundaries, as well as reasoning about indirect jumps and other useful metadata.
 
 ## General ideas
 
 A basic analysis that one might carry out on a binary is a Control Flow Graph.
 A CFG is a graph with (conceptually) basic blocks as nodes and jumps/calls/rets/etc as edges.
 
-In angr, there are two types of CFG that can be generated: a fast CFG (CFGFast) and an accurate CFG (CFGAccurate).
-As their names suggested, generating a fast CFG is usually much faster than generating the accurate one.
-In general, CFGFast is what you need.
-This page discusses CFGAccurate.
+In angr, there are two types of CFG that can be generated: a static CFG (CFGFast) and a dynamic CFG (CFGEmulated).
 
-An accurate CFG can be constructed by doing:
+CFGFast uses static analysis to generate a CFG.
+It is significantly faster, but is theoretically bounded by the fact that some control-flow transitions can only be resolved at execution-time.
+This is the same sort of CFG analysis performed by other popular reverse-engineering tools, and its results are comparable with their output.
 
-```python
->>> import angr
-# load your project
->>> b = angr.Project('/bin/true', load_options={'auto_load_libs': False})
-
-# generate an accurate CFG
->>> cfg = b.analyses.CFGAccurate(keep_state=True)
-```
+CFGEmulated uses symbolic execution to capture the CFG. While it is theoretically more accurate, it is dramatically slower.
+It is also typically less complete, due to issues with the accuracy of emulation (system calls, missing hardware features, and so on)
 
-Of course, there are several options for customized CFGs.
-
-| Option | Description |
-|--------|-------------|
-| context_sensitivity_level | This sets the context sensitivity level of the analysis. See the context sensitivity level section below for more information. This is 1 by default. |
-| starts | A list of addresses, to use as entry points into the analysis. |
-| avoid_runs | A list of addresses to ignore in the analysis. |
-| call_depth | Limit the depth of the analysis to some number calls. This is useful for checking which functions a specific function can directly jump to (by setting `call_depth` to 1).
-| initial_state | An initial state can be provided to the CFG, which it will use throughout its analysis. |
-| keep_state | To save memory, the state at each basic block is discarded by default. If `keep_state` is True, the state is saved in the CFGNode. |
-| enable_symbolic_back_traversal | Whether to enable an intensive technique for resolving indirect jumps |
-| enable_advanced_backward_slicing | Whether to enable another intensive technique for resolving direct jumps |
-| more! | Examine the docstring on b.analyses.CFGAccurate for more up-to-date options |
-
-## Context Sensitivity Level
-
-angr constructs a CFG by executing every basic block and seeing where it goes.
-This introduces some challenges: a basic block can act differently in different *contexts*.
-For example, if a block ends in a function return, the target of that return will be different, depending on different callers of the function containing that basic block.
+*If you are unsure which CFG to use, or are having problems with CFGEmulated, try CFGFast first.*
 
-The context sensitivity level is, conceptually, the number of such callers to keep on the callstack.
-To explain this concept, let's look at the following code:
 
-```c
-void error(char *error)
-{
-	puts(error);
-}
+A CFG can be constructed by doing:
 
-void alpha()
-{
-	puts("alpha");
-	error("alpha!");
-}
+```python
+>>> import angr
+# load your project
+>>> p = angr.Project('/bin/true', load_options={'auto_load_libs': False})
 
-void beta()
-{
-	puts("beta");
-	error("beta!");
-}
+# Generate a static CFG
+>>> cfg = p.analyses.CFGFast()
 
-void main()
-{
-	alpha();
-	beta();
-}
+# generate a dynamic CFG
+>>> cfg = p.analyses.CFGEmulated(keep_state=True)
 ```
 
-The above sample has four call chains: `main>alpha>puts`, `main>alpha>error>puts` and `main>beta>puts`, and `main>beta>error>puts`.
-While, in this case, angr can probably execute both call chains, this becomes unfeasible for larger binaries.
-Thus, angr executes the blocks with states limited by the context sensitivity level.
-That is, each function is re-analyzed for each unique context that it is called in.
-
-For example, the `puts()` function above will be analyzed with the following contexts, given different context sensitivity levels:
-
-| Level | Meaning | Contexts |
-|-------|---------|----------|
-| 0 | Callee-only | `puts` |
-| 1 | One caller, plus callee | `alpha>puts` `beta>puts` `error>puts` |
-| 2 | Two callers, plus callee | `alpha>error>puts` `main>alpha>puts` `beta>error>puts` `main>beta>puts` |
-| 3 | Three callers, plus callee | `main>alpha>error>puts` `main>alpha>puts` `main>beta>error>puts` `main>beta>puts` |
-
-The upside of increasing the context sensitivity level is that more information can be gleaned from the CFG.
-For example, with context sensitivity of 1, the CFG will show that, when called from `alpha`, `puts` returns to `alpha`, when called from `error`, `puts` returns to `error`, and so forth.
-With context sensitivity of 0, the CFG simply shows that `puts` returns to `alpha`, `beta`, and `error`.
-This, specifically, is the context sensitivity level used in IDA.
-The downside of increasing the context sensitivity level is that it exponentially increases the analysis time.
-
 ## Using the CFG
 
 The CFG, at its core, is a [NetworkX](https://networkx.github.io/) di-graph.
 This means that all of the normal NetworkX APIs are available:
 
 ```python
->>> print "This is the graph:", cfg.graph
->>> print "It has %d nodes and %d edges" % (len(cfg.graph.nodes()), len(cfg.graph.edges()))
+>>> print("This is the graph:", cfg.graph)
+>>> print("It has %d nodes and %d edges" % (len(cfg.graph.nodes()), len(cfg.graph.edges())))
 ```
 
 The nodes of the CFG graph are instances of class `CFGNode`.
@@ -106,15 +49,15 @@ Due to context sensitivity, a given basic block can have multiple nodes in the g
 
 ```python
 # this grabs *any* node at a given location:
->>> entry_node = cfg.get_any_node(b.entry)
+>>> entry_node = cfg.get_any_node(p.entry)
 
 # on the other hand, this grabs all of the nodes
->>> print "There were %d contexts for the entry block" % len(cfg.get_all_nodes(b.entry))
+>>> print("There were %d contexts for the entry block" % len(cfg.get_all_nodes(p.entry)))
 
 # we can also look up predecessors and successors
->>> print "Predecessors of the entry point:", entry_node.predecessors
->>> print "Successors of the entry point:", entry_node.successors
->>> print "Successors (and type of jump) of the entry point:", [ jumpkind + " to " + str(node.addr) for node,jumpkind in cfg.get_successors_and_jumpkind(entry_node) ]
+>>> print("Predecessors of the entry point:", entry_node.predecessors)
+>>> print("Successors of the entry point:", entry_node.successors)
+>>> print("Successors (and type of jump) of the entry point:", [ jumpkind + " to " + str(node.addr) for node,jumpkind in cfg.get_successors_and_jumpkind(entry_node) ])
 ```
 
 ### Viewing the CFG
@@ -138,7 +81,7 @@ The CFG result produces an object called the *Function Manager*, accessible thro
 The most common use case for this object is to access it like a dictionnary. It maps addresses to `Function` objects, which can tell you properties about a function.
 
 ```python
->>> entry_func = cfg.kb.functions[b.entry]
+>>> entry_func = cfg.kb.functions[p.entry]
 ```
 
 Functions have several important properties!
@@ -161,3 +104,125 @@ Functions have several important properties!
 
 and many more !
 
+
+## CFGFast details
+
+CFGFast peforms a static control-flow and function recovery.
+Starting with the entry point (or any user-defined points) roughly the following procedure is performed:
+
+1) The basic block is lifted to VEX IR, and all its exits (jumps, calls, returns, or continuation to the next block) are collected
+2) For each exit, if this exit is a constant address, we add an edge to the CFG of the correct type, and add the destination block to the set of blocks to be analyzed.
+3) In the event of a function call, the destination block is also considered the start of a new function. If the target function is known to return, the block after the call is also analyzed.
+4) In the event of a return, the current function is marked as returning, and the appropriate edges in the callgraph and CFG are updated.
+4) For all indirect jumps (block exits with a non-constant destination) Indirect Jump Resolution is performed.
+
+### Finding function starts
+
+CFGFast supports multiple ways of deciding where a function starts and ends.
+
+First the binary's main entry point will be analyzed.
+For binaries with symbols (e.g., non-stripped ELF and PE binaries) all function symbols will be used as possible starting points.
+For binaries without symbols, such as stripped binaries, or binaries loaded using the `blob` loader backend, CFG will scan the binary for a set of function prologues defined for the binary's architecture.
+Finally, by default, the binary's entire code section will be scanned for executable contents, regardless of prologues or symbols.
+
+In addition to these, as with CFGEmulated, function starts will also be considered when they are the target of a "call" instruction on the given architecture.
+
+All of these options can be disabled
+
+### FakeRets and function returns
+
+When a function call is observed, we first assume that the callee function eventually returns, and treat the block after it as part of the caller function.
+This inferred control-flow edge is known as a "FakeRet".
+If, in analyzing the callee, we find this not to be true, we update the CFG, removing this "FakeRet", and updating the callgraph and function blocks accordingly.
+As such, the CFG is recovered *twice*.  In doing this, the set of blocks in each function, and whether the function returns, can be recovered and propagated directly.
+
+### Indirect Jump Resolution
+
+*TODO*
+
+
+### Options
+
+These are the most useful options when working with CFGFast:
+
+| Option | Description |
+|--------|-------------|
+| force_complete_scan | (Default: True) Treat the entire binary as code for the purposes of function detection.  If you have a blob (e.g., mixed code and data) *you want to turn this off*. |
+| function_starts | A list of addresses, to use as entry points into the analysis. |
+| normalize | Normalize the resulting functions (e.g., each basic block belongs to at most one function) |
+| collect_data_references | Find all references to data during CFG generation. The results can allow you to find cross-references to data. |
+| resolve_indirect_jumps | Perform additional analysis to attempt to find targets for every indirect jump found during CFG creation. | 
+| more! | Examine the docstring on p.analyses.CFGFast for more up-to-date options |
+
+
+## CFGEmulated details
+
+### Options
+The most common options for CFGEmulated include:
+
+| Option | Description |
+|--------|-------------|
+| context_sensitivity_level | This sets the context sensitivity level of the analysis. See the context sensitivity level section below for more information. This is 1 by default. |
+| starts | A list of addresses, to use as entry points into the analysis. |
+| avoid_runs | A list of addresses to ignore in the analysis. |
+| call_depth | Limit the depth of the analysis to some number calls. This is useful for checking which functions a specific function can directly jump to (by setting `call_depth` to 1).
+| initial_state | An initial state can be provided to the CFG, which it will use throughout its analysis. |
+| keep_state | To save memory, the state at each basic block is discarded by default. If `keep_state` is True, the state is saved in the CFGNode. |
+| enable_symbolic_back_traversal | Whether to enable an intensive technique for resolving indirect jumps |
+| enable_advanced_backward_slicing | Whether to enable another intensive technique for resolving direct jumps |
+| more! | Examine the docstring on p.analyses.CFGEmulated for more up-to-date options |
+
+
+### Context Sensitivity Level
+
+angr constructs a CFG by executing every basic block and seeing where it goes.
+This introduces some challenges: a basic block can act differently in different *contexts*.
+For example, if a block ends in a function return, the target of that return will be different, depending on different callers of the function containing that basic block.
+
+The context sensitivity level is, conceptually, the number of such callers to keep on the callstack.
+To explain this concept, let's look at the following code:
+
+```c
+void error(char *error)
+{
+	puts(error);
+}
+
+void alpha()
+{
+	puts("alpha");
+	error("alpha!");
+}
+
+void beta()
+{
+	puts("beta");
+	error("beta!");
+}
+
+void main()
+{
+	alpha();
+	beta();
+}
+```
+
+The above sample has four call chains: `main>alpha>puts`, `main>alpha>error>puts` and `main>beta>puts`, and `main>beta>error>puts`.
+While, in this case, angr can probably execute both call chains, this becomes unfeasible for larger binaries.
+Thus, angr executes the blocks with states limited by the context sensitivity level.
+That is, each function is re-analyzed for each unique context that it is called in.
+
+For example, the `puts()` function above will be analyzed with the following contexts, given different context sensitivity levels:
+
+| Level | Meaning | Contexts |
+|-------|---------|----------|
+| 0 | Callee-only | `puts` |
+| 1 | One caller, plus callee | `alpha>puts` `beta>puts` `error>puts` |
+| 2 | Two callers, plus callee | `alpha>error>puts` `main>alpha>puts` `beta>error>puts` `main>beta>puts` |
+| 3 | Three callers, plus callee | `main>alpha>error>puts` `main>alpha>puts` `main>beta>error>puts` `main>beta>puts` |
+
+The upside of increasing the context sensitivity level is that more information can be gleaned from the CFG.
+For example, with context sensitivity of 1, the CFG will show that, when called from `alpha`, `puts` returns to `alpha`, when called from `error`, `puts` returns to `error`, and so forth.
+With context sensitivity of 0, the CFG simply shows that `puts` returns to `alpha`, `beta`, and `error`.
+This, specifically, is the context sensitivity level used in IDA.
+The downside of increasing the context sensitivity level is that it exponentially increases the analysis time.
diff --git a/docs/analyses/identifier.md b/docs/analyses/identifier.md
index 9736400..a43e906 100644
--- a/docs/analyses/identifier.md
+++ b/docs/analyses/identifier.md
@@ -13,7 +13,7 @@ The information of about stack variables can be generally useful in other projec
 >>> idfer = p.analyses.Identifier()
 # note that .run() yields results so make sure to iterate through them or call list() etc
 >>> for addr, symbol in idfer.run():
-... 	print hex(addr), symbol
+... 	print(hex(addr), symbol)
 
 0x8048e60 memcmp
 0x8048ef0 memcpy
@@ -33,4 +33,4 @@ The information of about stack variables can be generally useful in other projec
 0x804aad0 free
 0x8048660 malloc
 0x80485b0 free
-```
\ No newline at end of file
+```
diff --git a/docs/analysis_writing.md b/docs/analysis_writing.md
index 500fc4a..f3c6a10 100644
--- a/docs/analysis_writing.md
+++ b/docs/analysis_writing.md
@@ -39,7 +39,7 @@ Use this to interact with your project and analyze it!
 >>> proj = angr.Project("/bin/true")
 
 >>> summary = proj.analyses.ProjectSummary()
->>> print summary.result
+>>> print(summary.result)
 This project is a AMD64 binary with an entry point at 0x401410.
 ```
 
@@ -58,7 +58,7 @@ Here's an example:
 ...     def __init__(self):
 ...         self._cfg = self.project.analyses.CFG()
 ...         self.results = { }
-...         for addr, func in self._cfg.function_manager.functions.iteritems():
+...         for addr, func in self._cfg.function_manager.functions.items():
 ...             with self._resilience():
 ...                 if addr % 2 == 0:
 ...                     raise ValueError("can't handle functions at even addresses")
diff --git a/docs/claripy.md b/docs/claripy.md
index 107ef7b..d2432a1 100644
--- a/docs/claripy.md
+++ b/docs/claripy.md
@@ -45,7 +45,7 @@ ASTs provide several useful operations.
 >>> assert bv.reversed.reversed is bv
 
 # Depth - you can get the depth of the AST
->>> print bv.depth
+>>> print(bv.depth)
 >>> assert bv.depth == 1
 >>> x = claripy.BVS('x', 32)
 >>> assert (x+bv).depth == 2
diff --git a/docs/courses/step0-basic_symbol_execution.md b/docs/courses/step0-basic_symbol_execution.md
index 07329c6..9cf716e 100644
--- a/docs/courses/step0-basic_symbol_execution.md
+++ b/docs/courses/step0-basic_symbol_execution.md
@@ -39,7 +39,7 @@ The binary and source code for this course can be found [here](./src/).
 # comparison and will progress independently from the other one
 >>> print(sm)
 >>> for i, s in enumerate(sm.active):
-...     print 'Active state %d: %s' % (i, hex(s.addr))
+...     print('Active state %d: %s' % (i, hex(s.addr)))
 >>> assert len(sm.active) == 2
 >>> assert sm.active[0].addr == first_branch_left
 >>> assert sm.active[1].addr == first_branch_right
@@ -51,7 +51,7 @@ The binary and source code for this course can be found [here](./src/).
 >>> sm.step()
 >>> print(sm)
 >>> for i, s in enumerate(sm.active):
-...     print 'Active state %d: %s' % (i, hex(s.addr))
+...     print('Active state %d: %s' % (i, hex(s.addr)))
 >>> assert len(sm.active) == 3
 >>> assert sm.active[0].addr == endpoint
 >>> assert sm.active[1].addr == second_branch_left
@@ -66,7 +66,7 @@ The binary and source code for this course can be found [here](./src/).
 >>> sm.step()
 >>> print(sm)
 >>> for i, s in enumerate(sm.active):
-...     print 'Active state %d: %s' % (i, hex(s.addr))
+...     print('Active state %d: %s' % (i, hex(s.addr)))
 >>> assert len(sm.active) == 1
 >>> assert sm.active[0].addr == endpoint
 
diff --git a/docs/file_system.md b/docs/file_system.md
index b41f77a..a907488 100644
--- a/docs/file_system.md
+++ b/docs/file_system.md
@@ -203,11 +203,11 @@ If left unspecified, short_reads is determined from a state option.
 Data in a SimPackets is stored as tuples of (packet data, packet size) in `.content`.
 
 ```python
->>> print simfile.content
+>>> print(simfile.content)
 [(<BV160 packet_0_mypackets>, <BV64 packetsize_0_mypackets>)]
 
 >>> simfile.read(0, 1, short_reads=False)
->>> print simfile.content
+>>> print(simfile.content)
 [(<BV160 packet_0_mypackets>, <BV64 packetsize_0_mypackets>), (<BV8 packet_1_mypackets>, <BV64 0x1>)]
 ```
 
diff --git a/docs/ir.md b/docs/ir.md
index c743cea..f67b498 100644
--- a/docs/ir.md
+++ b/docs/ir.md
@@ -79,10 +79,10 @@ Let's play with PyVEX:
 >>> irsb.pp()
 
 # this is the IR Expression of the jump target of the unconditional exit at the end of the basic block
->>> print irsb.next
+>>> print(irsb.next)
 
 # this is the type of the unconditional exit (e.g., a call, ret, syscall, etc)
->>> print irsb.jumpkind
+>>> print(irsb.jumpkind)
 
 # you can also pretty-print it
 >>> irsb.next.pp()
@@ -95,28 +95,28 @@ Let's play with PyVEX:
 >>> import pyvex
 >>> for stmt in irsb.statements:
 ...     if isinstance(stmt, pyvex.IRStmt.Store):
-...         print "Data:",
+...         print("Data:",)
 ...         stmt.data.pp()
-...         print ""
-...         print "Type:",
-...         print stmt.data.result_type
-...         print ""
+...         print("")
+...         print("Type:",)
+...         print(stmt.data.result_type)
+...         print("")
 
 # pretty-print the condition and jump target of every conditional exit from the basic block
 >>> for stmt in irsb.statements:
 ...     if isinstance(stmt, pyvex.IRStmt.Exit):
-...         print "Condition:",
+...         print("Condition:",)
 ...         stmt.guard.pp()
-...         print ""
-...         print "Target:",
+...         print("")
+...         print("Target:",)
 ...         stmt.dst.pp()
-...         print ""
+...         print("")
 
 # these are the types of every temp in the IRSB
->>> print irsb.tyenv.types
+>>> print(irsb.tyenv.types)
 
 # here is one way to get the type of temp 0
->>> print irsb.tyenv.types[0]
+>>> print(irsb.tyenv.types[0])
 ```
 
 ## Condition flags computation (for x86 and ARM)
diff --git a/docs/loading.md b/docs/loading.md
index dfa7bf6..aa9a7b5 100644
--- a/docs/loading.md
+++ b/docs/loading.md
@@ -199,7 +199,7 @@ We've discussed `auto_load_libs` already - it enables or disables CLE's attempt
 Additionally, there is the opposite, `except_missing_libs`, which, if set to true, will cause an exception to be thrown whenever a binary has a shared library dependency that cannot be resolved.
 
 You can pass a list of strings to `force_load_libs` and anything listed will be treated as an unresolved shared library dependency right out of the gate, or you can pass a list of strings to `skip_libs` to prevent any library of that name from being resolved as a dependency.
-Additionally, you can pass a list of strings \(or a single string\) to `custom_ld_path`, which will be used as an additional search path for shared libraries, before any of the defaults: the same directory as the loaded program, the current working directory, and your system libraries.
+Additionally, you can pass a list of strings \(or a single string\) to `ld_path`, which will be used as an additional search path for shared libraries, before any of the defaults: the same directory as the loaded program, the current working directory, and your system libraries.
 
 #### Per-Binary Options
 
@@ -208,25 +208,25 @@ If you want to specify some options that only apply to a specific binary object,
 The options that you can use vary from backend to backend, but some common ones are:
 
 * `backend` - which backend to use, as either a class or a name
-* `custom_base_addr` - a base address to use
-* `custom_entry_point` - an entry point to use
-* `custom_arch` - the name of an architecture to use
+* `base_addr` - a base address to use
+* `entry_point` - an entry point to use
+* `arch` - the name of an architecture to use
 
 Example:
 
 ```python
-angr.Project(main_opts={'backend': 'ida', 'custom_arch': 'i386'}, lib_opts={'libc.so.6': {'backend': 'elf'}})
+angr.Project(main_opts={'backend': 'ida', 'arch': 'i386'}, lib_opts={'libc.so.6': {'backend': 'elf'}})
 ```
 
 ### Backends
 
 CLE currently has backends for statically loading ELF, PE, CGC, Mach-O and ELF core dump files, as well as loading binaries with IDA and loading files into a flat address space. CLE will automatically detect the correct backend to use in most cases, so you shouldn't need to specify which backend you're using unless you're doing some pretty weird stuff.
 
-You can force CLE to use a specific backend for an object by by including a key in its options dictionary, as described above. Some backends cannot autodetect which architecture to use and _must_ have a `custom_arch` specified. The key doesn't need to match any list of architectures; angr will identify which architecture you mean given almost any common identifier for any supported arch.
+You can force CLE to use a specific backend for an object by by including a key in its options dictionary, as described above. Some backends cannot autodetect which architecture to use and _must_ have a `arch` specified. The key doesn't need to match any list of architectures; angr will identify which architecture you mean given almost any common identifier for any supported arch.
 
 To refer to a backend, use the name from this table:
 
-| backend name | description | requires `custom_arch`? |
+| backend name | description | requires `arch`? |
 | --- | --- | --- |
 | elf | Static loader for ELF files based on PyELFTools | no |
 | pe | Static loader for PE files based on PEFile | no |
diff --git a/docs/migration-7.md b/docs/migration-7.md
new file mode 100644
index 0000000..8c2b7d6
--- /dev/null
+++ b/docs/migration-7.md
@@ -0,0 +1,158 @@
+# Migrating to angr 7
+
+The release of angr 7 introduces several departures from long-standing angr-isms.
+While the community has created a compatibility layer to give external code written for angr 6 a good chance of working on angr 7, the best thing to do is to port it to the new version.
+This document serves as a guide for this.
+
+## SimuVEX is gone
+
+angr versions up through angr 6 split the program analysis into two modules: `simuvex`, which was responsible for analyzing the effects of a single piece of code (whether a basic block or a SimProcedure) on a program state, and `angr`, which aggregated analyses of these basic blocks into program-level analysis such as control-flow recovery, symbolic execution, and so forth.
+In theory, this would encourage for the encapsulation of block-level analyses, and allow other program analysis frameworks to build upon `simuvex` for their needs.
+In practice, no one (to our knowledge) used `simuvex` without `angr`, and the separation introduced frustrating limitations (such as not being able to reference the history of a state from a SimInspect breakpoint) and duplication of code (such as the need to synchronize data from `state.scratch` into `path.history`).
+
+Realizing that SimuVEX wasn't a usable independent package, we brainstormed about merging it into angr and further noticed that this would allow us to address the frustrations resulting from their separation.
+
+All of the SimuVEX concepts (SimStates, SimProcedures, calling conventions, types, etc) have been migrated into angr.
+The migration guide for common classes is bellow:
+
+| Before | After |
+|--------|-------|
+| simuvex.SimState | angr.SimState |
+| simuvex.SimProcedure | angr.SimProcedure |
+| simuvex.SimEngine | angr.SimEngine |
+| simuvex.SimCC | angr.SimCC |
+
+And for common modules:
+
+| Before | After |
+|--------|-------|
+| simuvex.s_cc | angr.calling_conventions |
+| simuvex.s_state | angr.sim_state |
+| simuvex.s_procedure | angr.sim_procedure |
+| simuvex.plugins | angr.state_plugins |
+| simuvex.engines | angr.engines |
+| simuvex.concretization_strategies | angr.concretization_strategies |
+
+Additionally, `simuvex.SimProcedures` has been renamed to `angr.SIM_PROCEDURES`, since it is a global variable and not a class.
+There have been some other changes to its semantics, see the section on SimProcedures for details.
+
+## Removal of angr.Path
+
+In angr, a Path object maintained references to a SimState and its history.
+The fact that the history was separated from the state caused a lot of headaches when trying to analyze states inside a breakpoint, and caused overhead in synchronizing data from the state to its history.
+
+In the new model, a state's history is maintained in a SimState plugin: `state.history`.
+Since the path would now simply point to the state, we got rid of it.
+The mapping of concepts is roughly as follows:
+
+| Before | After |
+|--------|-------|
+| path | state |
+| path.state | state |
+| path.history | state.history |
+| path.callstack | state.callstack |
+| path.trace | state.history.descriptions |
+| path.addr_trace | state.history.bbl_addrs |
+| path.jumpkinds | state.history.jumpkinds |
+| path.guards | state.history.guards |
+| path.actions | state.history.actions |
+| path.events | state.history.events |
+| path.recent_actions | state.history.recent_actions |
+
+An important behavior change about `path.actions` and `path.recent_actions` - actions are no longer tracked by default.
+If you would like them to be tracked again, please add `angr.options.refs` to your state.
+
+### Path Group -> Simulation Manager
+
+Since there are no paths, there cannot be a path group.
+Instead, we have a Simulation Manager now (we recommend using the abbreviation "simgr" in places you were previously using "pg"), which is exactly the same as a path group except it holds states instead of paths.
+You can make one with `project.factory.simulation_manager(...)`.
+
+### Errored Paths
+
+Before, error resilience was handled at the path level, where stepping a path that caused an error would return a subclass of Path called ErroredPath, and these paths would be put in the `errored` stash of a path group.
+Now, error resilience is handled at the simulation manager level, and any state that throws an error during stepping will be wrapped in an ErrorRecord object, which is _not_ a subclass of SimState, and put into the `errored` list attribute of the simulation manager, which is _not_ a stash.
+
+An ErrorRecord object has attributes for `.state` (the initial state that caused the error), `.error` (the error that was thrown), and `.traceback` (the traceback from the error).
+To debug these errors you can call `.debug()`.
+
+These changes are because we were uncomfortable making a subclass of SimState, and the ErrorRecord class then has sufficiently different semantics from a normal state that it cannot be placed in a stash.
+
+## Changes to SimProcedures
+
+The most noticeable difference from the old version to the new version is that the catalog of built-in simprocedures are no longer organized strictly according to which library they live in.
+Now, they are organized according to which _standards_ they conform to, which helps with re-using procedures between different libraries.
+For instance, the old `SimProcedures['libc.so.6']` has been split up between `SIM_PROCEDURES['libc']`, `SIM_PROCEDURES['posix']`, and `SIM_PROCEDURES['glibc']`, depending on what specifications each function conforms to.
+This allows us to reuse the `libc` catalog in `msvcrt.dll` and the MUSL libc, for example.
+
+In order to group SimProcedures together by libraries, we have introduced a new abstraction called the SimLibrary, the definitions for which are stored in `angr.procedures.definitions`.
+Each SimLibrary object stores information about a single shared library, and can contain SimProcedure implementations, calling convention information, and type information.
+SimLibraries are scraped from the filesystem at import time, just like SimProcedures, and placed into `angr.SIM_LIBRARIES`.
+
+Syscalls are now categorized through a subclass of SimLibrary called SimSyscallLibrary.
+The API for managing syscalls through SimOS has been changed - check the API docs for the SimUserspace class.
+
+One important implication of this change is that if you previously used a trick where you changed one of the SimProcedures present in the `SimProcedures` dict in order to change which SimProcedures would be used to hook over library functions by default, this will no longer work.
+Instead of `SimProcedures[lib][func_name] = proc`, you now need to say `SIM_LIBRARIES[lib].add(func_name, proc)`.
+But really you should just be using `hook_symbol` anyway.
+
+## Changes to hooking
+
+The `Hook` class is gone.
+Instead, we now can hook with individual instances of SimProcedure objects, as opposed to just the classes.
+A shallow copy of the SimProcedure will be made at runtime to preserve thread safety.
+
+So, previously, where you would have done `project.hook(addr, Hook(proc, ...))` or `project.hook(addr, proc)`, you can now do `project.hook(addr, proc(...))`.
+In order to use simple functions as hooks, you can either say `project.hook(addr, func)` or decorate the declaration of your function with `@project.hook(addr)`.
+
+Having simprocedures as instances and letting them have access to the project cleans up a lot of other hacks that were present in the codebase, mostly related to the `self.call(...)` SimProcedure continuation system.
+It is no longer required to set `IS_FUNCTION = True` if you intend to use `self.call()` while writing a SimProcedure, and each call-return target you use will have a unique address associated with it.
+These addresses will be allocated lazily, which does have the side effect of making address allocation nondeterministic, sometimes based on dictionary-iteration order.
+
+## Changes to loading
+
+The `hook_symbol` method will no longer attempt to redo relocations for the given symbol, instead just hooking directly over the address of the symbol in whatever library it comes from.
+This speeds up loading substancially and ensures more consistent behavior for when mixing and matching native library code and SimProcedure summaries.
+
+The angr externs object has been moved into CLE, which will ALWAYS make sure that every dependency is resolved to something, never left unrelocated.
+Similarly, CLE provides the "kernel object" used to provide addresses for syscalls now.
+
+| Before | After |
+|--------|-------|
+| `project._extern_obj` | `loader.extern_object` |
+| `project._syscall_obj` | `loader.kernel_object` |
+
+Several properties and methods have been renamed in CLE in order to maintain a more consistent and explicit API.
+The most common changes are listed below:
+
+| Before | After |
+|--------|-------|
+| `loader.whats_at()` | `loader.describe_addr` |
+| `loader.addr_belongs_to_object()` | `loader.find_object_containing()` |
+| `loader.find_symbol_name()` | `loader.find_symbol().name` |
+| whatever the hell you were doing before to look up a symbol | `loader.find_symbol(name or addr)`
+| `loader.find_module_name()` | `loader.find_object_containing().provides` |
+| `loader.find_symbol_got_entry()` | `loader.find_relevant_relocations()` |
+| `loader.main_bin` | `loader.main_object` |
+| `anything.get_min_addr()` | `anything.min_addr` |
+| `symbol.addr` | `symbol.linked_addr` |
+
+## Changes to the solver interface
+
+We cleaned up the menagerie of functions present on `state.solver` (if you're still referring to it as `state.se` you should stop) and simplified it into a cleaner interface:
+
+- `solver.eval(expression)` will give you one possible solution to the given expression.
+- `solver.eval_one(expression)` will give you the solution to the given expression, or throw an error if more than one solution is possible.
+- `solver.eval_upto(expression, n)` will give you up to n solutions to the given expression, returning fewer than n if fewer than n are possible.
+- `solver.eval_atleast(expression, n)` will give you n solutions to the given expression, throwing an error if fewer than n are possible.
+- `solver.eval_exact(expression, n)` will give you n solutions to the given expression, throwing an error if fewer or more than are possible.
+- `solver.min(expression)` will give you the minimum possible solution to the given expression.
+- `solver.max(expression)` will give you the maximum possible solution to the given expression.
+
+Additionally, all of these methods can take the following keyword arguments:
+
+- `extra_constraints` can be passed as a tuple of constraints.
+  These constraints will be taken into account for this evaluation, but will not be added to the state.
+- `cast_to` can be passed a data type to cast the result to.
+  Currently, this can only be `str`, which will cause the method to return the byte representation of the underlying data.
+  For example, `state.solver.eval(state.solver.BVV(0x41424344, 32, cast_to=str)` will return `"ABCD"`.
diff --git a/docs/pathgroups.md b/docs/pathgroups.md
index 684e466..d89e6dc 100644
--- a/docs/pathgroups.md
+++ b/docs/pathgroups.md
@@ -56,7 +56,7 @@ To move states between stashes, use `.move()`,  which takes `from_stash`, `to_st
 For example, let's move everything that has a certain string in its output:
 
 ```python
->>> simgr.move(from_stash='deadended', to_stash='authenticated', filter_func=lambda s: 'Welcome' in s.posix.dumps(1))
+>>> simgr.move(from_stash='deadended', to_stash='authenticated', filter_func=lambda s: b'Welcome' in s.posix.dumps(1))
 >>> simgr
 <SimulationManager with 2 authenticated, 1 deadended>
 ```
@@ -70,7 +70,7 @@ If you prepend the name of a stash with `mp_`, you will be given a [mulpyplexed]
 
 ```python
 >>> for s in simgr.deadended + simgr.authenticated:
-...     print hex(s.addr)
+...     print(hex(s.addr))
 0x1000030
 0x1000078
 0x1000078
@@ -134,14 +134,14 @@ Next, we create a SimulationManager.
 
 Now, we symbolically execute until we find a state that matches our condition (i.e., the "win" condition).
 ```python
->>> simgr.explore(find=lambda s: "Congrats" in s.posix.dumps(1))
+>>> simgr.explore(find=lambda s: b"Congrats" in s.posix.dumps(1))
 <SimulationManager with 1 active, 1 found>
 ```
 
 Now, we can get the flag out of that state!
 ```python
 >>> s = simgr.found[0]
->>> print s.posix.dumps(1)
+>>> print(s.posix.dumps(1))
 Enter password: Congrats!
 
 >>> flag = s.posix.dumps(0)
diff --git a/docs/paths.md b/docs/paths.md
index 41e99ae..729b187 100644
--- a/docs/paths.md
+++ b/docs/paths.md
@@ -36,7 +36,7 @@ We can see that the callstack and the state's history are blank:
 # we can also look at the current backtrace of program execution
 # contains only the dummy frame for execution start
 >>> assert len(s.callstack) == 1
->>> print s.callstack
+>>> print(s.callstack)
 Backtrace:
 Func 0x401410, sp=0x7fffffffffeffd8, ret=0x0
 ```
@@ -49,7 +49,7 @@ Most of the time, a path will have one or two successors. When there are two suc
 
 ```python
 >>> new_states = b.factory.successors(s).flat_successors
->>> print "The path has", len(new_states), "successors!"
+>>> print("The path has", len(new_states), "successors!")
 
 # each successor is a path, keeping track of an execution history
 >>> new_state = new_states[0]
@@ -72,25 +72,25 @@ These are stored (as strings representing VEX exit type enums), in the `jumpkind
 
 ```python
 # recall: s is the path created when we stepped forward the initial path once
->>> print s.history.jumpkinds
+>>> print(s.history.jumpkinds)
 <angr.path.JumpkindIter object at 0x7f8161e584d0>
 
 >>> assert s.history.jumpkinds[-1] == 'Ijk_Call'
->>> print s.history.jumpkinds.hardcopy
+>>> print(s.history.jumpkinds.hardcopy)
 ['Ijk_Call']
 
 # Don't do this! This will throw an exception
->>> # for jk in ss.jumpkinds: print jk
+>>> # for jk in ss.jumpkinds: print(jk)
 
 # Do this instead:
->>> for jk in reversed(ss.history.jumpkinds): print jk
+>>> for jk in reversed(ss.history.jumpkinds): print(jk)
 Ijk_Call
 Ijk_Call
 Ijk_Boring
 Ijk_Call
 
 # Or, if you really need to iterate in forward order:
->>> for jk in ss.history.jumpkinds.hardcopy: print jk
+>>> for jk in ss.history.jumpkinds.hardcopy: print(jk)
 Ijk_Call
 Ijk_Boring
 Ijk_Call
@@ -131,10 +131,10 @@ For example, let's say that we have a branch:
 s = b.factory.entry_state()
 next = b.factory.successors(s).flat_successors
 while len(b.factory.successors(s).flat_successors) == 1:
-    print 'step'
+    print('step')
     s = b.factory.successors(s).flat_successors[0]
 
-print s
+print(s)
 branched_left = b.factory.successors(s).flat_successors[0]
 branched_right = b.factory.successors(s).flat_successors[1]
 assert branched_left.addr != branched_right.addr
diff --git a/docs/simprocedures.md b/docs/simprocedures.md
index a10ba9d..ab5f491 100644
--- a/docs/simprocedures.md
+++ b/docs/simprocedures.md
@@ -16,7 +16,7 @@ Here's an example that will remove all bugs from any program:
 
 >>> class BugFree(SimProcedure):
 ...    def run(self, argc, argv):
-...        print 'Program running with argc=%s and argv=%s' % (argc, argv)
+...        print('Program running with argc=%s and argv=%s' % (argc, argv))
 ...        return 0
 
 # this assumes we have symbols for the binary
diff --git a/docs/simulation.md b/docs/simulation.md
index d39ed07..9905ce5 100644
--- a/docs/simulation.md
+++ b/docs/simulation.md
@@ -46,7 +46,7 @@ Like any decent execution engine, angr supports breakpoints. This is pretty cool
 # on the other hand, we can have a breakpoint trigger right *after* a memory write happens. 
 # we can also have a callback function run instead of opening ipdb.
 >>> def debug_func(state):
-...     print "State %s is about to do a memory write!"
+...     print("State %s is about to do a memory write!")
 
 >>> s.inspect.b('mem_write', when=angr.BP_AFTER, action=debug_func)
 
@@ -118,7 +118,7 @@ You can even modify these value to modify further uses of the values!
 
 ```python
 >>> def track_reads(state):
-...     print 'Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address
+...     print('Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address)
 ...
 >>> s.inspect.b('mem_read', when=angr.BP_AFTER, action=track_reads)
 ```
diff --git a/docs/states.md b/docs/states.md
index 2156eca..a922eb1 100644
--- a/docs/states.md
+++ b/docs/states.md
@@ -78,11 +78,11 @@ We'll go over how our file and input subsystems work later on this very page, bu
 ```python
 >>> input_data = state1.posix.stdin.load(0, state.posix.stdin.size)
 
->>> state1.solver.eval(input_data, cast_to=str)
-'\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00\x00\x00'
+>>> state1.solver.eval(input_data, cast_to=bytes)
+b'\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00\x00\x00'
 
->>> state2.solver.eval(input_data, cast_to=str)
-'\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x00\x80N\x00\x00 \x00\x00\x00\x00'
+>>> state2.solver.eval(input_data, cast_to=bytes)
+b'\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x00\x80N\x00\x00 \x00\x00\x00\x00'
 ```
 
 As you can see, in order to go down the `state1` path, you must have given as a password the backdoor string "SOSNEAKY".
diff --git a/docs/surveyors.md b/docs/surveyors.md
index 1880025..6c25da3 100644
--- a/docs/surveyors.md
+++ b/docs/surveyors.md
@@ -32,10 +32,10 @@ You have to see it for yourself:
 
 # Now we can take a few steps! Printing an Explorer will tell you how
 # many active paths it currently has.
->>> print e.step()
+>>> print(e.step())
 
 # You can use `Explorer.run` to step multiple times.
->>> print e.run(10)
+>>> print(e.run(10))
 
 # Or even forever. By default, an Explorer will not stop running until
 # it runs out of paths (which will likely be never, for most programs),
@@ -47,11 +47,11 @@ You have to see it for yourself:
 # (i.e., provided no valid exits), and which have errored out. Note that,
 # in some instances, a given path could be in multiple lists (i.e., if it
 # errored out *and* did not produce any valid exits)
->>> print "%d paths are still running" % len(e.active)
->>> print "%d paths are backgrounded due to lack of resources" % len(e.spilled)
->>> print "%d paths are suspended due to user action" % len(e.suspended)
->>> print "%d paths had errors" % len(e.errored)
->>> print "%d paths deadended" % len(e.deadended)
+>>> print("%d paths are still running" % len(e.active))
+>>> print("%d paths are backgrounded due to lack of resources" % len(e.spilled))
+>>> print("%d paths are suspended due to user action" % len(e.suspended))
+>>> print("%d paths had errors" % len(e.errored))
+>>> print("%d paths deadended" % len(e.deadended))
 ```
 
 So far, everything we have discussed applies to all `Surveyors`.
@@ -67,15 +67,15 @@ For example, in the `fauxware` sample, we can try to find the "authentication su
 
 # Print our found backdoor, and how many paths we avoided!
 >>> if len(e.found) > 0:
-...     print "Found backdoor path:", e.found[0]
+...     print("Found backdoor path:", e.found[0])
 
->>> print "Avoided %d paths" % len(e.avoided)
+>>> print("Avoided %d paths" % len(e.avoided))
 ```
 
 Some helper properties are provided for easier access to paths from IPython:
 
 ```python
->>> print "The first found path is", e._f
+>>> print("The first found path is", e._f)
 # Also available are _d (deadended), _spl (spilled), and _e (errored)
 ```
 
@@ -99,10 +99,10 @@ It can be used as so:
 >>>#c = proj.surveyors.Caller(0x400664, (0x1000,0x2000), start=s)
 
 # look at the different paths that can return. This should print 3 paths:
->>>#print tuple(c.iter_returns())
+>>>#print(tuple(c.iter_returns()))
 
 # two of those paths return 1 (authenticated):
->>>#print tuple(c.iter_returns(solution=1))
+>>>#print(tuple(c.iter_returns(solution=1)))
 
 # now let's see the required username and password to reach that point. `c.map_se`
 # calls state.se.eval_upto (or whatever other function is provided) for the provided
diff --git a/docs/toplevel.md b/docs/toplevel.md
index d81f4aa..22dc5d2 100644
--- a/docs/toplevel.md
+++ b/docs/toplevel.md
@@ -212,7 +212,7 @@ angr comes pre-packaged with several built-in analyses that you can use to extra
  proj.analyses.BoyScout             proj.analyses.Disassembly          proj.analyses.VariableRecoveryFast  
  proj.analyses.CDG                  proj.analyses.GirlScout            proj.analyses.Veritesting           
  proj.analyses.CFG                  proj.analyses.Identifier           proj.analyses.VFG                   
- proj.analyses.CFGAccurate          proj.analyses.LoopFinder           proj.analyses.VSA_DDG               
+ proj.analyses.CFGEmulated          proj.analyses.LoopFinder           proj.analyses.VSA_DDG               
  proj.analyses.CFGFast              proj.analyses.Reassembler
 ```
 
diff --git a/examples/0ctf_momo_3/solve.py b/examples/0ctf_momo_3/solve.py
index 535451c..6f9b3fb 100644
--- a/examples/0ctf_momo_3/solve.py
+++ b/examples/0ctf_momo_3/solve.py
@@ -24,14 +24,13 @@
 
 
 def main():
-    p = angr.Project('./momo', load_options={'auto_load_libs': False})
+    p = angr.Project('./momo', auto_load_libs=False)
 
     addr = after_fgets
     size = mov_congrats - after_fgets
 
     # let's disasm with capstone to search targets
-    insn_bytes = ''.join(
-        p.loader.memory.read_bytes(addr, size))
+    insn_bytes = p.loader.memory.load(addr, size)
 
     insns = []
     for cs_insn in p.arch.capstone.disasm(insn_bytes, addr):
@@ -56,19 +55,18 @@ def main():
                 targets.append(ins.address + ins.size)
                 state = 0
 
-    print "found {:d} targets".format(len(targets))
+    print("found {:d} targets".format(len(targets)))
     assert len(targets) == 28
 
-    flag_arr = ['0', 'c', 't', 'f', '{']
+    flag_arr = bytearray(b'0ctf{')
 
     for target in targets[5:]:
-        print "\nexamining target {:#x}:".format(target)
+        print("\nexamining target {:#x}:".format(target))
         for trychar in string.printable:
-            print trychar,
+            print(trychar,)
             sys.stdout.flush()
-            flag = ''.join(flag_arr)+trychar
-            state = p.factory.entry_state()
-            state.posix.files[0].content.store(0, flag + "\n")
+            flag = bytes(flag_arr)+trychar.encode()
+            state = p.factory.entry_state(stdin=flag + b"\n")
 
             e = p.surveyors.Explorer(start=state, find=(target,))
             e.run()
@@ -76,7 +74,7 @@ def main():
             assert len(e.found) == 1
             np = e.found[0]
 
-            while(True):
+            while True:
                 nb_size = target - np.addr
                 if nb_size <= 0:
                     break
@@ -92,11 +90,11 @@ def main():
                 flag_arr.append(trychar)
                 break
 
-    return ''.join(flag_arr)
+    return bytes(flag_arr)
 
 
 def test():
-    assert main() == '0ctf{m0V_I5_tUr1N9_c0P1Et3!}'
+    assert main() == b'0ctf{m0V_I5_tUr1N9_c0P1Et3!}'
 
 if __name__ == '__main__':
-    print main()
+    print(main())
diff --git a/examples/0ctf_trace/solve.py b/examples/0ctf_trace/solve.py
index 12f09d5..9d43927 100755
--- a/examples/0ctf_trace/solve.py
+++ b/examples/0ctf_trace/solve.py
@@ -50,8 +50,8 @@ def main():
     project = angr.Project("./data.bin", load_options={
         'main_opts': {
             'backend': 'blob',
-            'custom_base_addr': 0x400770,
-            'custom_arch': 'mipsel',
+            'base_addr': 0x400770,
+            'arch': 'mipsel',
         },
     })
 
@@ -89,7 +89,7 @@ def main():
 
     print("Running solver...")
 
-    solution = state.solver.eval(state.memory.load(FLAG_LOCATION, 32), cast_to=str).rstrip(b'\0').decode('ascii')
+    solution = state.solver.eval(state.memory.load(FLAG_LOCATION, 32), cast_to=bytes).rstrip(b'\0').decode('ascii')
     print("The flag is", solution)
 
     return solution
diff --git a/examples/9447_nobranch/solve.py b/examples/9447_nobranch/solve.py
index 2a0cda8..48fa069 100644
--- a/examples/9447_nobranch/solve.py
+++ b/examples/9447_nobranch/solve.py
@@ -34,7 +34,7 @@ def main():
     i = 0
     while state.history.jumpkind == 'Ijk_Boring':                                                   # symbolically execute until we hit the syscall at the end
         i += 1
-        print i
+        print(i)
         ss = p.factory.successors(state, num_inst=1)                                                # only step one instruction at a time
         state = ss.successors[0]
         reg_names = ['rax', 'rbx', 'rcx', 'rdx', 'rsi', 'rdi', 'rbp', 'rsp', 'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15']
@@ -48,7 +48,7 @@ def main():
                 state.solver.add(newval == val)                                                    # easier for z3 to bite into in smaller chunks. It might also indicate that there
                 state.registers.store(reg_name, newval)                                        # some issues with angr's current usage of z3 :-)
 
-        for mem_addr in range(outaddr, outaddr + 0x1f) + [state.regs.rsp - x for x in xrange(0x40)]:
+        for mem_addr in list(range(outaddr, outaddr + 0x1f)) + [state.regs.rsp - x for x in range(0x40)]:
             val = state.memory.load(mem_addr, 1)
             if val.symbolic and val.depth > 3:
                 newval = claripy.BVS('replacement', len(val))
@@ -60,15 +60,15 @@ def main():
     for i, c in enumerate(shouldbe):
         fstate.solver.add(fstate.memory.load(0x616050 + i, 1) == ord(c))                                # constrain the output to what we were told it should be
 
-    cflag = hex(fstate.solver.eval(flag))[2:-1].decode('hex')                                        # solve for the flag!
+    cflag = bytes.fromhex(hex(fstate.solver.eval(flag))[2:])                                        # solve for the flag!
     return cflag
 
 def test():
     f = main()
-    assert f.startswith('9447{') and f.endswith('}')
+    assert f.startswith(b'9447{') and f.endswith(b'}')
     # lol I don't have the flag onhand and I don't want to wait hours for it to re-solve :P
     # you can verify it by running ./nobranch `cat flag`
     # and verifying that it prints out the shouldbe value at the top
 
 if __name__ == '__main__':
-    print main()
+    print(main())
diff --git a/examples/CADET_00001/.gitignore b/examples/CADET_00001/.gitignore
new file mode 100644
index 0000000..a8a0dce
--- /dev/null
+++ b/examples/CADET_00001/.gitignore
@@ -0,0 +1 @@
+*.bin
diff --git a/examples/CADET_00001/solve.py b/examples/CADET_00001/solve.py
index 83875eb..8ef30fb 100755
--- a/examples/CADET_00001/solve.py
+++ b/examples/CADET_00001/solve.py
@@ -24,7 +24,7 @@ def main():
 
     #by default angr discards unconstrained paths, so we need to specify the  
     #save_unconstrained option
-    print "finding the buffer overflow..."
+    print("finding the buffer overflow...")
     sm = project.factory.simulation_manager(save_unconstrained=True)
     #symbolically execute the binary until an unconstrained path is reached
     while len(sm.unconstrained)==0:
@@ -34,8 +34,8 @@ def main():
     #cat crash_input.bin | ./CADET_00001.adapted will segfault
     with open('crash_input.bin', 'wb') as fp:
         fp.write(crashing_input)
-    print "buffer overflow found!"
-    print repr(crashing_input)
+    print("buffer overflow found!")
+    print(repr(crashing_input))
 
 
     #let's now find the easter egg (it takes about 2 minutes)
@@ -46,7 +46,7 @@ def main():
 
     #to disable "lazy solving" we generate a blank path and we change its options,
     #then we specify this path as the initial path of the path group
-    print "finding the easter egg..."
+    print("finding the easter egg...")
     sm = project.factory.simulation_manager(project.factory.entry_state())
 
     #at this point we just ask angr to reach the basic block where the easter egg 
@@ -54,17 +54,17 @@ def main():
     sm.explore(find=0x804833E)
     found = sm.found[0]
     solution1 = found.posix.dumps(0)
-    print "easter egg found!"
-    print repr(solution1)
+    print("easter egg found!")
+    print(repr(solution1))
     with open('easteregg_input1.bin', 'wb') as fp:
         fp.write(solution1)
     #you can even check if the easter egg has been found by checking stdout
     stdout1 = found.posix.dumps(1)
-    print repr(stdout1)
+    print(repr(stdout1))
 
     #an alternative way to avoid unfeasible paths (paths that contain an unsatisfiable set
     #of constraints) is to "manually" step the path group execution and call prune()
-    print "finding the easter egg (again)..."
+    print("finding the easter egg (again)...")
     sm = project.factory.simulation_manager()
     while True:
         sm.step()
@@ -74,21 +74,21 @@ def main():
             break
     found = found_list[0]
     solution2 = found.posix.dumps(0)
-    print "easter egg found!"
-    print repr(solution2)
+    print("easter egg found!")
+    print(repr(solution2))
     with open('easteregg_input2.bin', 'wb') as fp:
         fp.write(solution2)
     #you can even check if the easter egg has been found by checking stdout
     stdout2 = found.posix.dumps(1)
-    print repr(stdout2)
+    print(repr(stdout2))
 
     return (crashing_input, solution1, stdout1, solution2, stdout2)
 
 
 def test():
     crashing_input, solution1, stdout1, solution2, stdout2 = main()
-    assert len(crashing_input) >= 92 and solution1.startswith("^") and solution2.startswith("^") and \
-            "EASTER EGG!" in stdout1 and "EASTER EGG!" in stdout2
+    assert len(crashing_input) >= 92 and solution1.startswith(b"^") and solution2.startswith(b"^") and \
+            b"EASTER EGG!" in stdout1 and b"EASTER EGG!" in stdout2
 
 
 if __name__ == '__main__':
diff --git a/examples/CSCI-4968-MBE/.gitignore b/examples/CSCI-4968-MBE/.gitignore
new file mode 100644
index 0000000..3f9177e
--- /dev/null
+++ b/examples/CSCI-4968-MBE/.gitignore
@@ -0,0 +1 @@
+input
diff --git a/examples/CSCI-4968-MBE/challenges/crackme0x00a/solve.py b/examples/CSCI-4968-MBE/challenges/crackme0x00a/solve.py
index cbbfffe..9c96017 100755
--- a/examples/CSCI-4968-MBE/challenges/crackme0x00a/solve.py
+++ b/examples/CSCI-4968-MBE/challenges/crackme0x00a/solve.py
@@ -14,10 +14,10 @@ def main():
 	proj = angr.Project('crackme0x00a', load_options={"auto_load_libs": False})
 	sm = proj.factory.simulation_manager()
 	sm.explore(find=FIND_ADDR, avoid=AVOID_ADDR)
-	return sm.found[0].posix.dumps(0).split('\0')[0] # stdin
+	return sm.found[0].posix.dumps(0).split(b'\0')[0] # stdin
 
 def test():
-	assert main() == 'g00dJ0B!'
+	assert main() == b'g00dJ0B!'
 
 if __name__ == '__main__':
 	print(main())
diff --git a/examples/CSCI-4968-MBE/challenges/crackme0x01/solve.py b/examples/CSCI-4968-MBE/challenges/crackme0x01/solve.py
index abf7271..6994887 100755
--- a/examples/CSCI-4968-MBE/challenges/crackme0x01/solve.py
+++ b/examples/CSCI-4968-MBE/challenges/crackme0x01/solve.py
@@ -16,10 +16,10 @@ def main():
 	sm = proj.factory.simulation_manager()
 	sm.explore(find=FIND_ADDR, avoid=AVOID_ADDR)
 
-	return sm.found[0].posix.dumps(0).lstrip('+0').rstrip('B\n')
+	return sm.found[0].posix.dumps(0).lstrip(b'+0').rstrip(b'B\n')
 
 def test():
-	assert main() == '5274'
+	assert main() == b'5274'
 
 if __name__ == '__main__':
 	print(repr(main()))
diff --git a/examples/CSCI-4968-MBE/challenges/crackme0x02/solve.py b/examples/CSCI-4968-MBE/challenges/crackme0x02/solve.py
index 2e8e347..5d87e58 100755
--- a/examples/CSCI-4968-MBE/challenges/crackme0x02/solve.py
+++ b/examples/CSCI-4968-MBE/challenges/crackme0x02/solve.py
@@ -16,10 +16,10 @@ def main():
 	sm = proj.factory.simulation_manager()
 	sm.explore(find=FIND_ADDR, avoid=AVOID_ADDR)
 
-	return sm.found[0].posix.dumps(0).lstrip('+0').rstrip('B\n\n')
+	return sm.found[0].posix.dumps(0).lstrip(b'+0').rstrip(b'B\n\n')
 
 def test():
-	assert main() == '338724'
+	assert main() == b'338724'
 
 if __name__ == '__main__':
     print(repr(main()))
diff --git a/examples/CSCI-4968-MBE/challenges/crackme0x03/solve.py b/examples/CSCI-4968-MBE/challenges/crackme0x03/solve.py
index ae60b85..0ea79f5 100755
--- a/examples/CSCI-4968-MBE/challenges/crackme0x03/solve.py
+++ b/examples/CSCI-4968-MBE/challenges/crackme0x03/solve.py
@@ -16,10 +16,10 @@ def main():
 	sm = proj.factory.simulation_manager()
 	sm.explore(find=FIND_ADDR, avoid=AVOID_ADDR)
 
-	return sm.found[0].posix.dumps(0).lstrip('+0').rstrip('B\n\0')
+	return sm.found[0].posix.dumps(0).lstrip(b'+0').rstrip(b'B\n\0')
 
 def test():
-	assert main() == '338724'
+	assert main() == b'338724'
 
 if __name__ == '__main__':
     print(repr(main()))
diff --git a/examples/CSCI-4968-MBE/challenges/crackme0x04/solve.py b/examples/CSCI-4968-MBE/challenges/crackme0x04/solve.py
index 8d790c4..8f527ad 100755
--- a/examples/CSCI-4968-MBE/challenges/crackme0x04/solve.py
+++ b/examples/CSCI-4968-MBE/challenges/crackme0x04/solve.py
@@ -30,7 +30,7 @@ def test():
 	with open('input', 'wb') as fp:
 		fp.write(main())
 
-	assert subprocess.check_output('./crackme0x04 < input', shell=True) == 'IOLI Crackme Level 0x04\nPassword: Password OK!\n'
+	assert subprocess.check_output('./crackme0x04 < input', shell=True) == b'IOLI Crackme Level 0x04\nPassword: Password OK!\n'
 
 if __name__ == '__main__':
 	print(repr(main()))
diff --git a/examples/CSCI-4968-MBE/challenges/crackme0x05/solve.py b/examples/CSCI-4968-MBE/challenges/crackme0x05/solve.py
index 231e0cb..20a2e3c 100755
--- a/examples/CSCI-4968-MBE/challenges/crackme0x05/solve.py
+++ b/examples/CSCI-4968-MBE/challenges/crackme0x05/solve.py
@@ -13,13 +13,13 @@ def main():
 
     def correct(state):
         try:
-            return 'Password OK' in state.posix.dumps(1)
+            return b'Password OK' in state.posix.dumps(1)
         except:
             return False
 
     def wrong(state):
         try:
-            return 'Password Incorrect' in state.posix.dumps(1)
+            return b'Password Incorrect' in state.posix.dumps(1)
         except:
             return False
 
@@ -35,7 +35,7 @@ def test():
 	with open('input', 'wb') as fp:
 		fp.write(main())
 
-	assert subprocess.check_output('./crackme0x05 < input', shell=True) == 'IOLI Crackme Level 0x05\nPassword: Password OK!\n'
+	assert subprocess.check_output('./crackme0x05 < input', shell=True) == b'IOLI Crackme Level 0x05\nPassword: Password OK!\n'
 
 if __name__ == '__main__':
 	print(repr(main()))
diff --git a/examples/ais3_crackme/solve.py b/examples/ais3_crackme/solve.py
index b271236..45b3421 100755
--- a/examples/ais3_crackme/solve.py
+++ b/examples/ais3_crackme/solve.py
@@ -22,23 +22,22 @@ def main():
     sm = project.factory.simulation_manager(initial_state)
 
     #symbolically execute the program until we reach the wanted value of the instruction pointer
-    sm.explore(find=0x400602) #at this instruction the binary will print the "correct" message
+    sm.explore(find=0x400602) #at this instruction the binary will print(the "correct" message)
 
     found = sm.found[0]
     #ask to the symbolic solver to get the value of argv1 in the reached state as a string
-    solution = found.solver.eval(argv1, cast_to=str)
+    solution = found.solver.eval(argv1, cast_to=bytes)
 
-    print repr(solution)
-    solution = solution[:solution.find("\x00")]
-    print solution
+    print(repr(solution))
+    solution = solution[:solution.find(b"\x00")]
+    print(solution)
     return solution
 
 def test():
     res = main()
-    assert res == "ais3{I_tak3_g00d_n0t3s}"
+    assert res == b"ais3{I_tak3_g00d_n0t3s}"
 
 
 if __name__ == '__main__':
     print(repr(main()))
 
-
diff --git a/examples/android_arm_license_validation/solve.py b/examples/android_arm_license_validation/solve.py
index d22f593..7047851 100644
--- a/examples/android_arm_license_validation/solve.py
+++ b/examples/android_arm_license_validation/solve.py
@@ -16,7 +16,7 @@ def main():
     load_options = {}
 
     # Android NDK library path:
-    # load_options['custom_ld_path'] = ['/Users/berndt/Tools/android-ndk-r10e/platforms/android-21/arch-arm/usr/lib']
+    # load_options['ld_path'] = ['/Users/berndt/Tools/android-ndk-r10e/platforms/android-21/arch-arm/usr/lib']
 
     b = angr.Project("./validate", load_options = load_options)
 
@@ -40,9 +40,9 @@ def main():
 
     # Get the solution string from *(R11 - 0x20).
 
-    solution = found.solver.eval(code, cast_to=str)
+    solution = found.solver.eval(code, cast_to=bytes)
 
-    print base64.b32encode(solution)
+    print(base64.b32encode(solution))
     return code, found
 
 def test():
@@ -52,9 +52,10 @@ def test():
     found.solver.add(user_input.get_byte(4) == ord('L'))
     found.solver.add(user_input.get_byte(6) == ord('Z'))
     found.solver.add(user_input.get_byte(8) == ord('!'))
-    solution = found.solver.eval(user_input, cast_to=str)
+    solution = found.solver.eval(user_input, cast_to=bytes)
     assert found.solver.satisfiable() == True
-    assert base64.b32encode(solution) == 'JQAE6ACMABNAAIIA'
+    # why does b32encode produce bytes and not str? great quesiton!
+    assert base64.b32encode(solution) == b'JQAE6ACMABNAAIIA'
 
 if __name__ == '__main__':
     main()
diff --git a/examples/asisctffinals2015_fake/solve.py b/examples/asisctffinals2015_fake/solve.py
index e95dcb1..d21e36e 100644
--- a/examples/asisctffinals2015_fake/solve.py
+++ b/examples/asisctffinals2015_fake/solve.py
@@ -1,4 +1,5 @@
 import angr
+import binascii
 
 def main():
     p = angr.Project("fake", auto_load_libs=False)
@@ -13,11 +14,11 @@ def main():
 
     # We know the flag starts with "ASIS{"
     flag_addr = found.regs.rdi
-    found.add_constraints(found.memory.load(flag_addr, 5) == int("ASIS{".encode("hex"), 16))
+    found.add_constraints(found.memory.load(flag_addr, 5) == int(binascii.hexlify(b"ASIS{"), 16))
 
     # More constraints: the whole flag should be printable
     flag = found.memory.load(flag_addr, 40)
-    for i in xrange(5, 5+32):
+    for i in range(5, 5+32):
         cond_0 = flag.get_byte(i) >= ord('0')
         cond_1 = flag.get_byte(i) <= ord('9')
         cond_2 = flag.get_byte(i) >= ord('a')
@@ -34,20 +35,20 @@ def main():
     # if there are less constraints. I added all constraints just to stay on the 
     # safe side.
 
-    flag_str = found.solver.eval(flag, cast_to=str)
-    return flag_str.rstrip('\0')
+    flag_str = found.solver.eval(flag, cast_to=bytes)
+    return flag_str.rstrip(b'\0')
 
-    #print "The number to input: ", found.solver.eval(inp)
-    #print "Flag:", flag
+    #print("The number to input: ", found.solver.eval(inp))
+    #print("Flag:", flag)
 
     # The number to input:  25313971399
     # Flag: ASIS{f5f7af556bd6973bd6f2687280a243d9}
 
 def test():
     a = main()
-    assert a == 'ASIS{f5f7af556bd6973bd6f2687280a243d9}'
+    assert a == b'ASIS{f5f7af556bd6973bd6f2687280a243d9}'
 
 if __name__ == '__main__':
     import logging
     logging.getLogger('angr.sim_manager').setLevel(logging.DEBUG)
-    print main()
+    print(main())
diff --git a/examples/asisctffinals2015_license/solve.py b/examples/asisctffinals2015_license/solve.py
index ed5ce78..19eff36 100644
--- a/examples/asisctffinals2015_license/solve.py
+++ b/examples/asisctffinals2015_license/solve.py
@@ -17,15 +17,15 @@ def main():
     # will spent much more time in path trimming.
 
     bytestring = None
-    for i in xrange(5):
+    for i in range(5):
         line = [ ]
-        for j in xrange(6):
+        for j in range(6):
             line.append(state.solver.BVS('license_file_byte_%d_%d' % (i, j), 8))
-            state.add_constraints(line[-1] != '\n')
+            state.add_constraints(line[-1] != b'\n')
         if bytestring is None:
             bytestring = claripy.Concat(*line)
         else:
-            bytestring = bytestring.concat(state.solver.BVV('\n'), *line)
+            bytestring = bytestring.concat(state.solver.BVV(b'\n'), *line)
 
     license_file = angr.storage.file.SimFile(license_name, bytestring)
     state.fs.insert(license_name, license_file)
@@ -54,12 +54,12 @@ def main():
     flag_length_int = min(found.solver.eval_upto(flag_length, 3))
     # Read out the flag!
     flag_int = found.solver.eval(found.memory.load(flag_addr, flag_length_int))
-    flag = hex(flag_int)[2:-1].decode("hex")
+    flag = bytes.fromhex(hex(flag_int)[2:])
     return flag
 
 def test():
-    assert main() == 'ASIS{8d2cc30143831881f94cb05dcf0b83e0}'
+    assert main() == b'ASIS{8d2cc30143831881f94cb05dcf0b83e0}'
 
 if __name__ == '__main__':
-    print main()
+    print(main())
 
diff --git a/examples/cmu_binary_bomb/solve.py b/examples/cmu_binary_bomb/solve.py
index 7ca5fa2..ded0e57 100755
--- a/examples/cmu_binary_bomb/solve.py
+++ b/examples/cmu_binary_bomb/solve.py
@@ -49,8 +49,8 @@ def solve_flag_1():
 
     if simgr.found:
         found = simgr.found[0]
-        flag = found.solver.eval(arg, cast_to=str)
-        return flag[:flag.index('\x00')] # remove everyting after \x00 because they won't be compared
+        flag = found.solver.eval(arg, cast_to=bytes)
+        return flag[:flag.index(b'\x00')].decode() # remove everyting after \x00 because they won't be compared
     else:
         raise Exception("angr failed to find a path to the solution :(")
 
@@ -64,7 +64,7 @@ def solve_flag_2():
 
     # Sscanf is looking for '%d %d %d %d %d %d' which ends up dropping 6 ints onto the stack
     # We will create 6 symbolic values onto the stack to mimic this
-    for i in xrange(6):
+    for i in range(6):
         state.stack_push(state.solver.BVS('int{}'.format(i), 4*8))
 
     # Attempt to find a path to the end of the phase_2 function while avoiding the bomb_explode
@@ -78,7 +78,7 @@ def solve_flag_2():
 
         answer = []
 
-        for _ in xrange(3):
+        for _ in range(3):
             curr_int = found.solver.eval(found.stack_pop())
 
             # We are popping off 8 bytes at a time
@@ -106,7 +106,7 @@ def solve_flag_3():
     while len(queue) > 0:
 
         state = queue.pop()
-        #print "\nStarting symbolic execution..."
+        #print("\nStarting symbolic execution...")
 
         ex = proj.surveyors.Explorer(start=state, find=(end,),
                                      avoid=(bomb_explode,),
@@ -114,12 +114,12 @@ def solve_flag_3():
                                      max_active=8)
         ex.run()
 
-        #print "Inserting in queue " + str(len(ex.active)) + " paths (not yet finished)"
+        #print("Inserting in queue " + str(len(ex.active)) + " paths (not yet finished)")
         for p in ex.active:
             queue.append(p)
 
-        #print "Found states are " + str(len(ex.found))
-        #print "Enumerating up to 10 solutions for each found state"
+        #print("Found states are " + str(len(ex.found)))
+        #print("Enumerating up to 10 solutions for each found state")
 
         if ex.found:
             for p in ex.found:
@@ -135,7 +135,7 @@ def solve_flag_3():
                     a = sol & 0xffffffff
                     b = (sol >> 32) & 0xffffffff
 
-                    #print "Solution: " + str(a) + " " + str(b)
+                    #print("Solution: " + str(a) + " " + str(b))
                     args.append(str(a) + " " + str(b))
 
     return args
@@ -161,8 +161,8 @@ def solve_flag_4():
     simgr.explore(find=find, avoid=avoid)
 
     found = simgr.found[0]
-    ans1 = found.solver.eval(var1, cast_to=str)
-    ans2 = found.solver.eval(var2, cast_to=str)
+    ans1 = found.solver.eval(var1, cast_to=bytes)
+    ans2 = found.solver.eval(var2, cast_to=bytes)
     return ' '.join([str(unpack('<I', ans1)[0]), str(unpack('<I', ans2)[0])])
 
 def solve_flag_5():
@@ -202,9 +202,9 @@ def is_alnum(state, c):
     found = sm.found[0]
 
     mem = found.memory.load(string_addr, 32)
-    for i in xrange(32):
+    for i in range(32):
         found.add_constraints(is_alnum(found, mem.get_byte(i)))
-    return found.solver.eval(mem, cast_to=str).split('\x00')[0]
+    return found.solver.eval(mem, cast_to=bytes).split(b'\x00')[0].decode()
     # more than one solution could, for example, be returned like this:
     # return map(lambda s: s.split('\x00')[0], found.solver.eval_upto(mem, 10, cast_to=str))
 
@@ -243,7 +243,7 @@ def solve_flag_6():
     # dive further to part2
     found_list = sm.found
     for found in found_list:
-        sm = p.factory.simgr(found)
+        sm = p.factory.simulation_manager(found)
         sm.explore(find=find2, avoid=avoid)
         if len(sm.found) > 0:
             found = sm.found[0]
@@ -273,39 +273,39 @@ def solve_secret():
     return str(found.solver.eval(flag))
 
 def main():
-    print "Flag    1: " + solve_flag_1()
-    print "Flag    2: " + solve_flag_2()
-    print "Flag(s) 3: " + str(solve_flag_3())
-    print "Flag    4: " + solve_flag_4()
-    print "Flag    5: " + solve_flag_5()
-    print "Flag    6: " + solve_flag_6()
-    print "Secret   : " + solve_secret()
+    print("Flag    1: " + solve_flag_1())
+    print("Flag    2: " + solve_flag_2())
+    print("Flag(s) 3: " + str(solve_flag_3()))
+    print("Flag    4: " + solve_flag_4())
+    print("Flag    5: " + solve_flag_5())
+    print("Flag    6: " + solve_flag_6())
+    print("Secret   : " + solve_secret())
 
 def test():
     assert solve_flag_1() == 'Border relations with Canada have never been better.'
-    print "Stage 1 ok!"
+    print("Stage 1 ok!")
 
     assert solve_flag_2() == '1 2 4 8 16 32'
-    print "Stage 2 ok!"
+    print("Stage 2 ok!")
 
     args_3 = ["0 207", "1 311", "2 707", "3 256", "4 389", "5 206", "6 682", "7 327"]
     res_3 = solve_flag_3()
     assert len(res_3) == len(args_3)
     for s in args_3:
         assert s in res_3
-    print "Stage 3 ok!"
+    print("Stage 3 ok!")
 
     assert solve_flag_4() == '7 0'
-    print "Stage 4 ok!"
+    print("Stage 4 ok!")
 
     assert solve_flag_5().lower() == 'ionefg'
-    print "Stage 5 ok!"
+    print("Stage 5 ok!")
 
     assert solve_flag_6() == '4 3 2 1 6 5'
-    print "Stage 6 ok!"
+    print("Stage 6 ok!")
 
     assert solve_secret() == '22'
-    print "Secret stage ok!"
+    print("Secret stage ok!")
 
 if __name__ == '__main__':
 
diff --git a/examples/codegate_2017-angrybird/solve.py b/examples/codegate_2017-angrybird/solve.py
index 0d9ef99..08953ce 100755
--- a/examples/codegate_2017-angrybird/solve.py
+++ b/examples/codegate_2017-angrybird/solve.py
@@ -9,31 +9,37 @@
 FIND_ADDR = 0x404fab  # This is right before the printf
 
 def main():
-	proj = angr.Project('angrybird')
-	# There's a couple anti-run instructions in this binary.
-	# Yes, anti-run. That's not a typo.
-
-	# Because I'm not interested in fixing a weird binary, I'm going to skip all the beginning of the program.
-	# this also skips a bunch of initialization, so let's fix that:
-	state = proj.factory.entry_state(addr=START_ADDR)
-	state.regs.rbp = state.regs.rsp
-        state.mem[state.regs.rbp - 0x74].int = 0x40       # this is the length for the read
-	# using the same values as the binary doesn't work for these variables, I think because they point to the GOT and the binary is using that to try to fingerprint that it's loaded in angr. Setting them to pointers to symbolic memory works fine.
-	state.mem[state.regs.rbp - 0x70].long = 0x1000
-	state.mem[state.regs.rbp - 0x68].long = 0x1008
-	state.mem[state.regs.rbp - 0x60].long = 0x1010
-	state.mem[state.regs.rbp - 0x58].long = 0x1018
-
-	sm = proj.factory.simulation_manager(state)  # Create the SimulationManager.
-	sm.explore(find=FIND_ADDR)  # This will take a couple minutes. Ignore the warning message(s), it's fine.
-	found = sm.found[-1]
-	flag = found.posix.dumps(0)
-
-	# This trims off anything that's not printable.
-	return flag[:20]
+    proj = angr.Project('angrybird')
+    # There's a couple anti-run instructions in this binary.
+    # Yes, anti-run. That's not a typo.
+
+    # Because I'm not interested in fixing a weird binary, I'm going to skip
+    # all the beginning of the program.
+    # this also skips a bunch of initialization, so let's fix that:
+    state = proj.factory.entry_state(addr=START_ADDR)
+    state.regs.rbp = state.regs.rsp
+    # this is the length for the read
+    state.mem[state.regs.rbp - 0x74].int = 0x40
+
+    # using the same values as the binary doesn't work for these variables, I
+    # think because they point to the GOT and the binary is using that to try
+    # to fingerprint that it's loaded in angr. Setting them to pointers to
+    # symbolic memory works fine.
+    state.mem[state.regs.rbp - 0x70].long = 0x1000
+    state.mem[state.regs.rbp - 0x68].long = 0x1008
+    state.mem[state.regs.rbp - 0x60].long = 0x1010
+    state.mem[state.regs.rbp - 0x58].long = 0x1018
+
+    sm = proj.factory.simulation_manager(state)  # Create the SimulationManager.
+    sm.explore(find=FIND_ADDR)  # This will take a couple minutes. Ignore the warning message(s), it's fine.
+    found = sm.found[-1]
+    flag = found.posix.dumps(0)
+
+    # This trims off anything that's not printable.
+    return flag[:20]
 
 def test():
-	assert main() == 'Im_so_cute&pretty_:)'
+    assert main() == b'Im_so_cute&pretty_:)'
 
 if __name__ == '__main__':
-	print(main())
+    print(main())
diff --git a/examples/csaw_wyvern/solve.py b/examples/csaw_wyvern/solve.py
index 47f4014..f5d0c1a 100644
--- a/examples/csaw_wyvern/solve.py
+++ b/examples/csaw_wyvern/solve.py
@@ -1,54 +1,54 @@
 #!/usr/bin/env python
 # coding: utf-8
 import angr
+import claripy
 import time
 
 def main():
     # Load the binary. This is a 64-bit C++ binary, pretty heavily obfuscated.
     p = angr.Project('wyvern')
 
+    # It's reasonably easy to tell from looking at the program in IDA that the key will
+    # be 29 bytes long, and the last byte is a newline. Let's construct a value of several
+    # symbols that we can add constraints on once we have a state.
+
+    flag_chars = [claripy.BVS('flag_%d' % i, 8) for i in range(28)]
+    flag = claripy.Concat(*flag_chars + [claripy.BVV(b'\n')])
+
     # This block constructs the initial program state for analysis.
     # Because we're going to have to step deep into the C++ standard libraries
     # for this to work, we need to run everyone's initializers. The full_init_state
     # will do that. In order to do this peformantly, we will use the unicorn engine!
-    st = p.factory.full_init_state(args=['./wyvern'], add_options=angr.options.unicorn)
-
-    # It's reasonably easy to tell from looking at the program in IDA that the key will
-    # be 29 bytes long, and the last byte is a newline.
+    st = p.factory.full_init_state(
+            args=['./wyvern'],
+            add_options=angr.options.unicorn,
+            stdin=flag,
+    )
 
     # Constrain the first 28 bytes to be non-null and non-newline:
-    for _ in xrange(28):
-        k = st.posix.files[0].read_from(1)
+    for k in flag_chars:
         st.solver.add(k != 0)
         st.solver.add(k != 10)
 
-    # Constrain the last byte to be a newline
-    k = st.posix.files[0].read_from(1)
-    st.solver.add(k == 10)
-
-    # Reset the symbolic stdin's properties and set its length.
-    st.posix.files[0].seek(0)
-    st.posix.files[0].length = 29
-
     # Construct a SimulationManager to perform symbolic execution.
     # Step until there is nothing left to be stepped.
     sm = p.factory.simulation_manager(st)
     sm.run()
 
     # Get the stdout of every path that reached an exit syscall. The flag should be in one of these!
-    out = ''
+    out = b''
     for pp in sm.deadended:
         out = pp.posix.dumps(1)
-        if 'flag{' in out:
-            return filter(lambda s: 'flag{' in s, out.split())[0]
+        if b'flag{' in out:
+            return next(filter(lambda s: b'flag{' in s, out.split()))
 
     # Runs in about 15 minutes!
 
 def test():
-    assert main() == 'flag{dr4g0n_or_p4tric1an_it5_LLVM}'
+    assert main() == b'flag{dr4g0n_or_p4tric1an_it5_LLVM}'
 
 if __name__ == "__main__":
     before = time.time()
-    print main()
+    print(main())
     after = time.time()
-    print "Time elapsed: {}".format(after - before)
+    print("Time elapsed: {}".format(after - before))
diff --git a/examples/csgames2018/solve.py b/examples/csgames2018/solve.py
index c43cb92..1d0533e 100755
--- a/examples/csgames2018/solve.py
+++ b/examples/csgames2018/solve.py
@@ -20,59 +20,59 @@
 # logging.getLogger('angr').setLevel(logging.DEBUG)
 
 def main():
-	project = angr.Project('./KeygenMe', load_options={"auto_load_libs": False})
+    project = angr.Project('./KeygenMe', load_options={"auto_load_libs": False})
 
-	def correct(state):
-		try:
-			return 'correct!' in state.posix.dumps(1)
-		except Exception as e:
-			return False
+    def correct(state):
+        try:
+            return b'correct!' in state.posix.dumps(1)
+        except Exception as e:
+            return False
 
-	def wrong(state):
-		try:
-			return 'incorrect' in state.posix.dumps(1)
-		except Exception as e:
-			return False
+    def wrong(state):
+        try:
+            return b'incorrect' in state.posix.dumps(1)
+        except Exception as e:
+            return False
 
-	input_key = claripy.BVS("input_key", 16*8) # As seen in 0x699, keys are 0x10 (16) characters long.
+    input_key = claripy.BVS("input_key", 16*8) # As seen in 0x699, keys are 0x10 (16) characters long.
 
-	state = project.factory.entry_state(args=["./KeygenMe", input_key], add_options=angr.options.unicorn) # Unicorn Engine is not needed, but will speed up the process
+    state = project.factory.entry_state(args=["./KeygenMe", input_key], add_options=angr.options.unicorn) # Unicorn Engine is not needed, but will speed up the process
 
-	simulation_manager = project.factory.simulation_manager(state)
+    simulation_manager = project.factory.simulation_manager(state)
 
-	# (•_•) ( •_•)>⌐■-■ (⌐■_■)
-	simulation_manager.explore(find=correct, avoid=wrong) # We could alternatively use addresses here, like find=0x400000 + 0x8f3.
+    # (•_•) ( •_•)>⌐■-■ (⌐■_■)
+    simulation_manager.explore(find=correct, avoid=wrong) # We could alternatively use addresses here, like find=0x400000 + 0x8f3.
 
-	# For troubleshooting/development, drop into IPython
-	# IPython.embed()
+    # For troubleshooting/development, drop into IPython
+    # IPython.embed()
 
-	found = simulation_manager.found[-1]
+    found = simulation_manager.found[-1]
 
-	# At this point, we've actually found "correct" flags, but they contain symbols that probably aren't on all keyboards. Ideally we only want to find alphanumeric keys.
+    # At this point, we've actually found "correct" flags, but they contain symbols that probably aren't on all keyboards. Ideally we only want to find alphanumeric keys.
 
-	def is_alphanumeric(state, byte):
-		is_num = state.solver.And(byte >= "0", byte <= "9")
-		is_alpha_lower = state.solver.And(byte >= "a", byte <= "z")
-		is_alpha_upper = state.solver.And(byte >= "A", byte <= "Z")
-		return state.solver.Or(is_num, is_alpha_lower, is_alpha_upper)
+    def is_alphanumeric(state, byte):
+        is_num = state.solver.And(byte >= b"0", byte <= b"9")
+        is_alpha_lower = state.solver.And(byte >= b"a", byte <= b"z")
+        is_alpha_upper = state.solver.And(byte >= b"A", byte <= b"Z")
+        return state.solver.Or(is_num, is_alpha_lower, is_alpha_upper)
 
-	# XXXX-XX-XXX-XXXX
-	for i in range(0, 4) + range(5, 7) + range(8, 11) + range(12, 16):
-		found.add_constraints(is_alphanumeric(found, input_key.chop(8)[i]))
+    # XXXX-XX-XXX-XXXX
+    for i in list(range(0, 4)) + list(range(5, 7)) + list(range(8, 11)) + list(range(12, 16)):
+        found.add_constraints(is_alphanumeric(found, input_key.chop(8)[i]))
 
-	min_solutions = found.solver.min(input_key)
+    min_solutions = found.solver.min(input_key)
 
-	keys = found.solver.eval_atleast(input_key, 100, cast_to=str)
+    keys = found.solver.eval_atleast(input_key, 100, cast_to=bytes)
 
-	print("We found at least " + str(min_solutions) + " keys! The Recording Industry Association of Space Penguins says their entire galaxy is now bankrupt, so we might as well have 100 of their keys:")
+    print("We found at least " + str(min_solutions) + " keys! The Recording Industry Association of Space Penguins says their entire galaxy is now bankrupt, so we might as well have 100 of their keys:")
 
-	for key in keys:
-		print(key)
+    for key in keys:
+        print(key)
 
-	return min_solutions
+    return min_solutions
 
 def test():
-	assert main() >= 100
+    assert main() >= 100
 
 if __name__ == '__main__':
-	main()
+    main()
diff --git a/examples/defcamp_r100/solve.py b/examples/defcamp_r100/solve.py
index 19d2156..7d5852b 100644
--- a/examples/defcamp_r100/solve.py
+++ b/examples/defcamp_r100/solve.py
@@ -5,10 +5,10 @@ def main():
     simgr = p.factory.simulation_manager(p.factory.full_init_state())
     simgr.explore(find=0x400844, avoid=0x400855)
 
-    return simgr.found[0].posix.dumps(0).strip('\0\n')
+    return simgr.found[0].posix.dumps(0).strip(b'\0\n')
 
 def test():
-    assert main().startswith('Code_Talkers')
+    assert main().startswith(b'Code_Talkers')
 
 if __name__ == '__main__':
-    print main()
+    print(main())
diff --git a/examples/defcon2016quals_baby-re/solve.py b/examples/defcon2016quals_baby-re/solve.py
index 71ce63a..fc866b4 100644
--- a/examples/defcon2016quals_baby-re/solve.py
+++ b/examples/defcon2016quals_baby-re/solve.py
@@ -16,7 +16,7 @@ def main():
     proj = angr.Project('./baby-re', auto_load_libs=False)
 
     # let's provide the exact variables received through the scanf so we don't have to worry about parsing stdin into a bunch of ints.
-    flag_chars = [claripy.BVS('flag_%d' % i, 32) for i in xrange(13)]
+    flag_chars = [claripy.BVS('flag_%d' % i, 32) for i in range(13)]
     class my_scanf(angr.SimProcedure):
         def run(self, fmt, ptr): # pylint: disable=arguments-differ,unused-argument
             self.state.mem[ptr].dword = flag_chars[self.state.globals['scanf_count']]
diff --git a/examples/defcon2017quals_crackme2000/enlightenment/classify.py b/examples/defcon2017quals_crackme2000/enlightenment/classify.py
index edb79f7..7466b8c 100644
--- a/examples/defcon2017quals_crackme2000/enlightenment/classify.py
+++ b/examples/defcon2017quals_crackme2000/enlightenment/classify.py
@@ -24,8 +24,8 @@
     libraries[k].append(f)
     ldds[k] = ldd_out
 
-print libraries.keys()
-print ldds
+print(list(libraries))
+print(ldds)
 
 # ['libchicken.so.7', 'libutil.so.1', 'libstdc++.so.6', 'librt.so.1', 'libgcc_s.so.1', 'libm.so.6', 'libpthread.so.0', 'libswiftCore.so', 'libdl.so.2', 'linux-vdso.so.1', 'libc.so.6', 'libswiftGlibc.so']
 for k in libraries.keys():
diff --git a/examples/defcon2017quals_crackme2000/enlightenment/solve_chicken.py b/examples/defcon2017quals_crackme2000/enlightenment/solve_chicken.py
index ce86334..5649c1e 100644
--- a/examples/defcon2017quals_crackme2000/enlightenment/solve_chicken.py
+++ b/examples/defcon2017quals_crackme2000/enlightenment/solve_chicken.py
@@ -69,7 +69,7 @@ def solve(s):
 
     for o, check_func in enumerate(all_checkers):
 
-        print o, len(all_checkers)
+        print(o, len(all_checkers))
 
         # parse basic blocks in this function to figure out the char offset
         char_offset = None
@@ -117,11 +117,11 @@ def solve(s):
 
         chars[char_offset] = the_char
 
-    print chars
-    return "".join([ chr(v/2) for k, v in sorted(chars.items()) ])
+    print(chars)
+    return "".join([ chr(v//2) for k, v in sorted(chars.items()) ])
 
 def main():
-    print solve("df8737d9d5aee3cee6320e7313414458fdfb10552a8e6c8ea45753102ba4509a")
+    print(solve("df8737d9d5aee3cee6320e7313414458fdfb10552a8e6c8ea45753102ba4509a"))
     return
     import os
     for i, filename in enumerate(os.listdir("bc9cd8ff91a55ecee73caf85c3d55e45")):
@@ -130,18 +130,18 @@ def main():
         solution_file = "%s.solution" % filename
         if os.path.exists(solution_file):
             continue
-        print i, filename
+        print(i, filename)
         try:
             sol = solve(filename)
             if not sol:
                 continue
         except ValueError:
-            print "oops failed on %s" % filename
+            print("oops failed on %s" % filename)
             continue
         # data = sol.encode("base64")
         with open(solution_file, "wb") as f:
             f.write(sol)
-        #print "Send this:" + data
+        #print("Send this:" + data)
         #sock.send(data + "\n")
 
 
diff --git a/examples/defcon2017quals_crackme2000/enlightenment/solve_crystal.py b/examples/defcon2017quals_crackme2000/enlightenment/solve_crystal.py
index 417a310..add3839 100644
--- a/examples/defcon2017quals_crackme2000/enlightenment/solve_crystal.py
+++ b/examples/defcon2017quals_crackme2000/enlightenment/solve_crystal.py
@@ -31,7 +31,7 @@ def solve(filename):
 
     really_good = sorted(good, key=lambda x: x.insns[-3].insn.operands[1].mem.disp)
 
-    # print map(str, really_good)
+    # print(map(str, really_good))
 
     solution = ''.join(chr(k.insns[-2].insn.operands[1].imm) for k in really_good)
 
@@ -43,7 +43,7 @@ def main():
             continue
         if "." in filename:
             continue
-        print i, filename, '"%s"' % solve(filename)
+        print(i, filename, '"%s"' % solve(filename))
 
 if __name__ == "__main__":
     main()
diff --git a/examples/defcon2017quals_crackme2000/enlightenment/solve_rust.py b/examples/defcon2017quals_crackme2000/enlightenment/solve_rust.py
index 9fa39eb..b6245e1 100644
--- a/examples/defcon2017quals_crackme2000/enlightenment/solve_rust.py
+++ b/examples/defcon2017quals_crackme2000/enlightenment/solve_rust.py
@@ -53,7 +53,7 @@ def main():
             continue
         if "." in filename:
             continue
-        print i, filename, '"%s"' % solve(filename)
+        print(i, filename, '"%s"' % solve(filename))
 
 if __name__ == "__main__":
     main()
diff --git a/examples/defcon2017quals_crackme2000/magic.py b/examples/defcon2017quals_crackme2000/magic.py
index cc20faf..cd36754 100644
--- a/examples/defcon2017quals_crackme2000/magic.py
+++ b/examples/defcon2017quals_crackme2000/magic.py
@@ -1,37 +1,37 @@
-
-import logging
-
-#l = logging.getLogger('angr.manager').setLevel(logging.DEBUG)
-
-import angr
-
-def solve(s):
-    p = angr.Project("challs/magic_dist/%s" % s,
-            auto_load_libs=False
-            )
-    cfg = p.analyses.CFG()
-
-    state = p.factory.blank_state(addr=0x400770)
-    sm = p.factory.simulation_manager(state)
-    sm.explore()
-    sol = sm.deadended[-1].posix.dumps(0).replace("\x00", "").replace("\n", "")
-    return sol
-
-def main():
-    #solve("65cb596908789372c2d6fbeb0ac3a0e3a1089039138711a016ec3994ad5c7f10")
-    import pwn
-    host, port = "cm2k-magic_b46299df0752c152a8e0c5f0a9e5b8f0.quals.shallweplayaga.me", 12001
-    r = pwn.remote(host, port)
-    print r.readuntil("newline\n")
-    while True:
-        filename = r.readuntil("\n").strip("\n")
-        print filename
-        sol = solve(filename)
-        print repr(sol)
-        data = sol.encode("base64")
-        print "Send this:" + data
-        r.send(data)
-
-
-if __name__ == "__main__":
-    main()
+
+import logging
+
+#l = logging.getLogger('angr.manager').setLevel(logging.DEBUG)
+
+import angr
+
+def solve(s):
+    p = angr.Project("challs/magic_dist/%s" % s,
+            auto_load_libs=False
+            )
+    cfg = p.analyses.CFG()
+
+    state = p.factory.blank_state(addr=0x400770)
+    sm = p.factory.simulation_manager(state)
+    sm.explore()
+    sol = sm.deadended[-1].posix.dumps(0).replace("\x00", "").replace("\n", "")
+    return sol
+
+def main():
+    #solve("65cb596908789372c2d6fbeb0ac3a0e3a1089039138711a016ec3994ad5c7f10")
+    import pwn
+    host, port = "cm2k-magic_b46299df0752c152a8e0c5f0a9e5b8f0.quals.shallweplayaga.me", 12001
+    r = pwn.remote(host, port)
+    print(r.readuntil("newline\n"))
+    while True:
+        filename = r.readuntil("\n").strip("\n")
+        print(filename)
+        sol = solve(filename)
+        print(repr(sol))
+        data = sol.encode("base64")
+        print("Send this:" + data)
+        r.send(data)
+
+
+if __name__ == "__main__":
+    main()
diff --git a/examples/defcon2017quals_crackme2000/occult.py b/examples/defcon2017quals_crackme2000/occult.py
index ee7c901..5bd698d 100644
--- a/examples/defcon2017quals_crackme2000/occult.py
+++ b/examples/defcon2017quals_crackme2000/occult.py
@@ -1,4 +1,3 @@
-
 import logging
 import sys
 
@@ -84,7 +83,7 @@ def solve(s):
 
     for o, check_func in enumerate(all_checkers):
 
-        print o, len(all_checkers)
+        print(o, len(all_checkers))
 
         # parse basic blocks in this function to figure out the char offset
         char_offset = None
@@ -127,7 +126,7 @@ def solve(s):
 
         chars[char_offset] = the_char
 
-    return "".join([ chr(v/2) for k, v in sorted(chars.items()) ])
+    return "".join([ chr(v//2) for k, v in sorted(chars.items()) ])
 
 def main():
     import os
@@ -137,16 +136,16 @@ def main():
         solution_file = "%s.solution" % filename
         if os.path.exists(solution_file):
             continue
-        print i, filename
+        print(i, filename)
         try:
             sol = solve(filename)
         except ValueError:
-            print "oops failed on %s" % filename
+            print("oops failed on %s" % filename)
             continue
         # data = sol.encode("base64")
         with open(solution_file, "wb") as f:
             f.write(sol)
-        #print "Send this:" + data
+        #print("Send this:" + data)
         #sock.send(data + "\n")
 
 
diff --git a/examples/defcon2017quals_crackme2000/sorcery.py b/examples/defcon2017quals_crackme2000/sorcery.py
index 5ade37f..1d3999c 100644
--- a/examples/defcon2017quals_crackme2000/sorcery.py
+++ b/examples/defcon2017quals_crackme2000/sorcery.py
@@ -1,45 +1,45 @@
-
-import logging
-
-#l = logging.getLogger('angr.manager').setLevel(logging.DEBUG)
-
-import angr
-
-def solve(s):
-    p = angr.Project("sorcery_dist/%s" % s,
-            auto_load_libs=False
-            )
-    cfg = p.analyses.CFG(show_progressbar=True)
-
-    func = cfg.functions[0x4030fc]
-    # dump all cmp cls
-    s = ""
-    for block in sorted(func.blocks, key=lambda b: b.addr):
-        insns = [ insn for insn in block.capstone.insns if insn.mnemonic == 'cmp' and insn.operands[0].type == 1 and insn.operands[0].reg in (2, 10) ]
-        if not insns:
-            continue
-        insn = insns[0]
-        imm = insn.operands[1].imm
-        s += chr(imm)
-    return s
-
-
-def main():
-    import pwn
-    host, port = "cm2k-sorcery_13de8e6bf26e435fc43efaf46b488eae.quals.shallweplayaga.me", 12002
-    r = pwn.remote(host, port)
-    print r.readuntil("newline\n")
-    while True:
-        filename = r.readuntil("\n").strip("\n")
-        print filename
-        sol = solve(filename)
-        print repr(sol)
-        data = sol.encode("base64")
-        print "Send this:" + data
-        r.send(data)
-
-
-if __name__ == "__main__":
-    main()
-
-# The flag is: don't forget me when you're famous Klousovnec
+
+import logging
+
+#l = logging.getLogger('angr.manager').setLevel(logging.DEBUG)
+
+import angr
+
+def solve(s):
+    p = angr.Project("sorcery_dist/%s" % s,
+            auto_load_libs=False
+            )
+    cfg = p.analyses.CFG(show_progressbar=True)
+
+    func = cfg.functions[0x4030fc]
+    # dump all cmp cls
+    s = ""
+    for block in sorted(func.blocks, key=lambda b: b.addr):
+        insns = [ insn for insn in block.capstone.insns if insn.mnemonic == 'cmp' and insn.operands[0].type == 1 and insn.operands[0].reg in (2, 10) ]
+        if not insns:
+            continue
+        insn = insns[0]
+        imm = insn.operands[1].imm
+        s += chr(imm)
+    return s
+
+
+def main():
+    import pwn
+    host, port = "cm2k-sorcery_13de8e6bf26e435fc43efaf46b488eae.quals.shallweplayaga.me", 12002
+    r = pwn.remote(host, port)
+    print(r.readuntil("newline\n"))
+    while True:
+        filename = r.readuntil("\n").strip("\n")
+        print(filename)
+        sol = solve(filename)
+        print(repr(sol))
+        data = sol.encode("base64")
+        print("Send this:" + data)
+        r.send(data)
+
+
+if __name__ == "__main__":
+    main()
+
+# The flag is: don't forget me when you're famous Klousovnec
diff --git a/examples/defcon2017quals_crackme2000/witchcraft.py b/examples/defcon2017quals_crackme2000/witchcraft.py
index 73d1016..fba7abf 100644
--- a/examples/defcon2017quals_crackme2000/witchcraft.py
+++ b/examples/defcon2017quals_crackme2000/witchcraft.py
@@ -1,87 +1,87 @@
-
-import logging
-import sys
-
-l = logging.getLogger('angr.manager').setLevel(logging.DEBUG)
-
-import angr
-
-pos = 0xd000000
-
-def recvuntil(sock, s):
-    data = ""
-    while True:
-        char = sock.recv(1)
-        if not char:
-            break
-        data += char
-        if data.endswith(s):
-            break
-    return data
-
-class Alloca(angr.SimProcedure):
-    def run(self):
-        return self.state.solver.BVV(pos, 64)
-
-def solve(s):
-    p = angr.Project("witchcraft_dist/%s" % s,
-            auto_load_libs=False
-            )
-    cfg = p.analyses.CFG(show_progressbar=True)
-
-    # determine the function address
-    callers = cfg.functions.callgraph.predecessors(cfg.functions.function(name='_TTSfq4n_s___TFVs11_StringCore15_encodeSomeUTF8fT4fromSi_TSiVs6UInt64_', plt=True).addr)
-    caller_funcs = [ cfg.functions[caller_addr] for caller_addr in callers ]
-    caller_func = sorted(caller_funcs, key=lambda f: f.size)[-1]
-
-    print hex(caller_func.addr)
-    state = p.factory.blank_state(addr=caller_func.addr, add_options={angr.options.LAZY_SOLVES})
-    state.regs.rbx = 0
-
-    # get the function to hook
-    ctr = 0
-    alloca = None
-    for block in sorted(caller_func.blocks, key=lambda b: b.addr):
-        if block.vex.jumpkind == 'Ijk_Call':
-            ctr += 1
-            if ctr == 1:
-                swift_retain = cfg.get_any_node(block.addr).successors[0].addr
-            if ctr == 3:
-                alloca = cfg.get_any_node(block.addr).successors[0].addr
-                break
-
-    if alloca is None:
-        return ""
-
-    print "swift_retain:", hex(swift_retain)
-    print "Alloca:", hex(alloca)
-    p.hook(swift_retain, angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'])
-    p.hook(alloca, Alloca)
-
-    sm = p.factory.simulation_manager(state)
-    sm.explore()
-
-    state = sm.deadended[-1]
-    mem = state.memory.load(pos + 0x20, 60)
-    mem_str = state.solver.eval(mem, cast_to=str).replace("\x00", "")
-    return mem_str
-
-def main():
-    import os
-    for i, filename in enumerate(os.listdir("witchcraft_dist")):
-        if i % 8 != int(sys.argv[1]):
-            continue
-        solution_file = "%s.solution" % filename
-        if os.path.exists(solution_file):
-            continue
-        print i, filename
-        sol = solve(filename)
-        # data = sol.encode("base64")
-        with open(solution_file, "wb") as f:
-            f.write(sol)
-        #print "Send this:" + data
-        #sock.send(data + "\n")
-
-
-if __name__ == "__main__":
-    main()
+
+import logging
+import sys
+
+l = logging.getLogger('angr.manager').setLevel(logging.DEBUG)
+
+import angr
+
+pos = 0xd000000
+
+def recvuntil(sock, s):
+    data = ""
+    while True:
+        char = sock.recv(1)
+        if not char:
+            break
+        data += char
+        if data.endswith(s):
+            break
+    return data
+
+class Alloca(angr.SimProcedure):
+    def run(self):
+        return self.state.solver.BVV(pos, 64)
+
+def solve(s):
+    p = angr.Project("witchcraft_dist/%s" % s,
+            auto_load_libs=False
+            )
+    cfg = p.analyses.CFG(show_progressbar=True)
+
+    # determine the function address
+    callers = cfg.functions.callgraph.predecessors(cfg.functions.function(name='_TTSfq4n_s___TFVs11_StringCore15_encodeSomeUTF8fT4fromSi_TSiVs6UInt64_', plt=True).addr)
+    caller_funcs = [ cfg.functions[caller_addr] for caller_addr in callers ]
+    caller_func = sorted(caller_funcs, key=lambda f: f.size)[-1]
+
+    print(hex(caller_func.addr))
+    state = p.factory.blank_state(addr=caller_func.addr, add_options={angr.options.LAZY_SOLVES})
+    state.regs.rbx = 0
+
+    # get the function to hook
+    ctr = 0
+    alloca = None
+    for block in sorted(caller_func.blocks, key=lambda b: b.addr):
+        if block.vex.jumpkind == 'Ijk_Call':
+            ctr += 1
+            if ctr == 1:
+                swift_retain = cfg.get_any_node(block.addr).successors[0].addr
+            if ctr == 3:
+                alloca = cfg.get_any_node(block.addr).successors[0].addr
+                break
+
+    if alloca is None:
+        return ""
+
+    print("swift_retain:", hex(swift_retain))
+    print("Alloca:", hex(alloca))
+    p.hook(swift_retain, angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'])
+    p.hook(alloca, Alloca)
+
+    sm = p.factory.simulation_manager(state)
+    sm.explore()
+
+    state = sm.deadended[-1]
+    mem = state.memory.load(pos + 0x20, 60)
+    mem_str = state.solver.eval(mem, cast_to=bytes).replace(b"\x00", b"")
+    return mem_str
+
+def main():
+    import os
+    for i, filename in enumerate(os.listdir("witchcraft_dist")):
+        if i % 8 != int(sys.argv[1]):
+            continue
+        solution_file = "%s.solution" % filename
+        if os.path.exists(solution_file):
+            continue
+        print(i, filename)
+        sol = solve(filename)
+        # data = sol.encode("base64")
+        with open(solution_file, "wb") as f:
+            f.write(sol)
+        #print("Send this:" + data)
+        #sock.send(data + "\n")
+
+
+if __name__ == "__main__":
+    main()
diff --git a/examples/ekopartyctf2015_rev100/solve.py b/examples/ekopartyctf2015_rev100/solve.py
index b33b961..4fedb04 100644
--- a/examples/ekopartyctf2015_rev100/solve.py
+++ b/examples/ekopartyctf2015_rev100/solve.py
@@ -12,7 +12,7 @@
 def prepare_state(state, known_passwords):
     state = state.copy()
     password = [ ]
-    for i in xrange(0, len(known_passwords) + 1):
+    for i in range(0, len(known_passwords) + 1):
         password.append(state.solver.BVS('password_%d' % i, 8))
         state.memory.store(0xd0000000 + i, password[-1])
 
@@ -183,7 +183,7 @@ def main():
     # The last one must be '4'...
     known_passwords += [ '4' ]
     password = "".join(known_passwords)
-    print "Flag: EKO{%s}" % password
+    print("Flag: EKO{%s}" % password)
 
     return password
 
diff --git a/examples/ekopartyctf2016_rev250/solve.py b/examples/ekopartyctf2016_rev250/solve.py
index 58fc498..1c1bdd5 100644
--- a/examples/ekopartyctf2016_rev250/solve.py
+++ b/examples/ekopartyctf2016_rev250/solve.py
@@ -2,7 +2,7 @@
 
 """
 In this challenge we are given a binary that checks an input given from stdin.
-If it is correct, it will call get_flag in a separate library and print it.
+If it is correct, it will call get_flag in a separate library and print(it.)
 However, we don't have the library so need to find the correct input and input
 it over netcat. If it is incorrect, only 'Goodbye' is printed.
 
@@ -16,6 +16,8 @@
 """
 
 import angr
+import claripy
+import subprocess
 
 START = 0x400B30 # start of main
 FIND = 0x403A40 # part of program that prints the flag
@@ -31,17 +33,13 @@ def main():
     p = angr.Project('FUck_binary')
 
     print('creating state')
-    state = p.factory.blank_state(addr=START)
+    flag = claripy.BVS('flag', BUF_LEN*8)
+    state = p.factory.blank_state(addr=START, stdin=flag)
 
     print('adding constaints to stdin')
-    for i in range(BUF_LEN):
-        c = state.posix.files[0].read_from(1)
+    for c in flag.chop(8):
         state.solver.add(char(state, c))
 
-    # even though we mark stdin as 100 long angr can still chose to cut it off 
-    state.posix.files[0].seek(0)
-    state.posix.files[0].length = 100
-
     print('creating path and explorer')
     ex = p.surveyors.Explorer(start=state, find=FIND, avoid=AVOID)
 
@@ -50,20 +48,14 @@ def main():
 
     print('found solution')
     correct_input = ex._f.posix.dumps(0) # ex._f is equiv. to ex.found[0]
-
-    # we didn't know how long the input had to be except < 100 bytes
-    team_name = correct_input[:correct_input.index('\x00')]
-
-    print('found correct input/team name: {}'.format(repr(team_name)))
-
-    return team_name
+    return correct_input
 
 def test():
-    team = '@@@(h@@@@f@v@ @@/@vCo@&D@ACHP@@@@@@@@D@@ @X@@@@@B@h@]@@@W@UB@"(@Lq@@@@@,FBtH@?6@@" * k[Q@@@@@@@@@I@@'
-    import subprocess
+    team = main()
     p = subprocess.Popen(["./FUck_binary"], env={"LD_LIBRARY_PATH": "."}, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-    out, err = p.communicate(input=team + "\n")
-    assert "BOOM" in out
+    out, err = p.communicate(input=team + b"\n")
+    assert b"BOOM" in out
 
 if __name__ == '__main__':
-    main()
+    team = main()
+    print('found correct input/team name: {}'.format(repr(team)))
diff --git a/examples/ekopartyctf2016_sokohashv2/sokosolver.py b/examples/ekopartyctf2016_sokohashv2/sokosolver.py
index 5a7b3c0..80b301e 100644
--- a/examples/ekopartyctf2016_sokohashv2/sokosolver.py
+++ b/examples/ekopartyctf2016_sokohashv2/sokosolver.py
@@ -15,7 +15,7 @@ def to_asmstring(state, addr, length):
     try:
         conc = state.solver.eval
         addr =  conc(addr)
-        code = "".join(project.loader.memory.read_bytes(addr,length))
+        code = project.loader.memory.load(addr,length)
         md = project.arch.capstone
         inst = "; ".join(["%s %s" %(i.mnemonic, i.op_str) for i in md.disasm(code,addr)])
         return "%x: %s" %(addr, inst.split(";")[0])
@@ -25,10 +25,10 @@ def to_asmstring(state, addr, length):
 
 
 def debug_func(state):
-    print to_asmstring(state, state.regs.eip, 10)
+    print(to_asmstring(state, state.regs.eip, 10))
 
     addr = state.solver.eval(state.regs.eip)
-    print hex(addr)
+    print(hex(addr))
 
 #######################################
 
@@ -36,7 +36,7 @@ def debug_func(state):
 
 #WIN_HASH = "BF3666668F5581A7EC65F192388BD64D4CC3B3610000275DAC894722C10986F6".decode("hex")
 
-WIN_HASH = "C03922D0206DC3A33016010D6C66936E953ABAB9000010AE805CE8463CBE9A2D".decode("hex")
+WIN_HASH = bytes.fromhex("C03922D0206DC3A33016010D6C66936E953ABAB9000010AE805CE8463CBE9A2D")
 
 def get_hash_map(init_addr):
     """
@@ -51,10 +51,10 @@ def get_hash_map(init_addr):
 	"""
     addr = init_addr
     hash_map = []
-    for i in xrange(0, len(WIN_HASH), 2):
+    for i in range(0, len(WIN_HASH), 2):
         pair = WIN_HASH[i:i+2]
-        hash_map.append((addr, ord(pair[1])))
-        hash_map.append((addr+1, ord(pair[0])))
+        hash_map.append((addr, pair[1]))
+        hash_map.append((addr+1, pair[0]))
         addr += 8
 
     return hash_map
@@ -98,7 +98,7 @@ def get_table(state):
 p.hook(0x00401243, hook_printf,length=5)
 p.hook(0x00401253, hook_security_check_cookie,length=5)
 
-print "Initiating state"
+print("Initiating state")
 
 #we are not starting from 401000 because it is not working properly.
 #probably due to we are calling the function directly (it's mean creating an
@@ -114,7 +114,7 @@ def get_table(state):
 #    In this case, the restrictions are asociated to values of the sokohash table.
 #    (the parameters must be included in the sokohash universe numbers)
 ##############################################
-print "Setting params restrictions (precontions)"
+print("Setting params restrictions (precontions)")
 #first of all we will set the restrictions for out parameters in the initial
 #state. to set that, we will load the addresses (this load will return a
 #symbolic memory (another alternative can be use BVS and memory.store these bit
@@ -177,7 +177,7 @@ def get_table(state):
 
 for addr, value in get_hash_map(0x04216C0):
     memory = found_s.memory.load(addr, 1, endness=p.arch.memory_endness)
-    print "Addr: %x --> %s" % (addr, hex(value))
+    print("Addr: %x --> %s" % (addr, hex(value)))
     conds.append((memory == value))
 
 found_s.add_constraints(found_s.solver.And(*conds))
@@ -193,16 +193,16 @@ def get_table(state):
 
 import binascii
 solution1 = found_s.solver.eval(r1)
-print "x: ", hex(solution1)
+print("x: ", hex(solution1))
 
 solution2 = found_s.solver.eval(r2)
-print "y: ", hex(solution2)
+print("y: ", hex(solution2))
 
 solution3 = found_s.solver.eval(r3)
-print "z:", hex(solution3)
+print("z:", hex(solution3))
 
 solution4 = found_s.solver.eval(r4)
-print "w:", hex(solution4)
+print("w:", hex(solution4))
 ##############################################
 
 sys.stdout.flush()
diff --git a/examples/ekopartyctf2016_sokohashv2/sokosolver_facuman.py b/examples/ekopartyctf2016_sokohashv2/sokosolver_facuman.py
index 4436466..f2b5f47 100644
--- a/examples/ekopartyctf2016_sokohashv2/sokosolver_facuman.py
+++ b/examples/ekopartyctf2016_sokohashv2/sokosolver_facuman.py
@@ -3,7 +3,7 @@
 import struct
 from itertools import combinations, product
 
-WIN_HASH = "C03922D0206DC3A33016010D6C66936E953ABAB9000010AE805CE8463CBE9A2D".decode("hex")
+WIN_HASH = bytes.fromhex("C03922D0206DC3A33016010D6C66936E953ABAB9000010AE805CE8463CBE9A2D")
 
 
 def get_valid_coords():
@@ -49,14 +49,12 @@ def do_memset(state):
     addr = 0x417490
     with open("matrix.bin","rb") as f:
         content = f.read()
-        for i in content:
-            state.memory.store(addr, state.solver.BVV(ord(i), 8 * 1))
-            addr += 1
+        state.memory.store(addr, content)
 
     start_off = 0x41d450 - addr
     end_off = 0x41e0c8 - addr
     coords = []
-    for i in xrange(start_off, end_off+8, 8):
+    for i in range(start_off, end_off+8, 8):
         coords.append(struct.unpack("<Q", content[i:i+8])[0])
 
     return coords
@@ -73,10 +71,10 @@ def do_nothing(state):
 def get_hash_map(init_addr):
     addr = init_addr
     hash_map = []
-    for i in xrange(0, len(WIN_HASH), 2):
+    for i in range(0, len(WIN_HASH), 2):
         pair = WIN_HASH[i:i+2]
-        hash_map.append((addr, ord(pair[1])))
-        hash_map.append((addr+1, ord(pair[0])))
+        hash_map.append((addr, pair[1]))
+        hash_map.append((addr+1, pair[0]))
         addr += 8
 
     return hash_map
@@ -112,7 +110,7 @@ def main():
     coord_dict = {}
     count = 0
     for i in get_valid_coords():
-        #print "%s = %.16x" % (i, pos[count])
+        #print("%s = %.16x" % (i, pos[count]))
         coord_dict[coords[count]] = i
         count += 1
 
@@ -120,7 +118,7 @@ def main():
 
     # search only for possible coords
     variables = []
-    for i in xrange(0, 4):
+    for i in range(0, 4):
         var = init.memory.load(init.regs.ebp + 0x8 + (0x8*i), 0x8, endness=proj.arch.memory_endness)
         variables.append(var)
         conds = []
@@ -148,7 +146,7 @@ def main():
         memory = found.memory.load(addr, 1, endness=proj.arch.memory_endness)
         conds.append((memory == value))
         expected.append((hex(addr), hex(value)))
-    print "Expected is '%s'\n\n" % expected
+    print("Expected is '%s'\n\n" % expected)
 
     found.add_constraints(init.solver.And(*conds))
 
@@ -158,7 +156,7 @@ def main():
         buf_ptr = found.memory.load(addr, 1)
         possible = found.solver.eval(buf_ptr)
         result.append((hex(addr), "0x%x" % possible))
-    print "Result is '%s'\n\n" % result
+    print("Result is '%s'\n\n" % result)
 
 
     # Print solutions
@@ -170,12 +168,12 @@ def main():
 
         names = ["x","y","z","w"]
         values = []
-        for j in xrange(0, len(out), 16):
+        for j in range(0, len(out), 16):
             value = out[j:j+16]
-            unpk_value = struct.unpack("<Q", value.decode("hex"))[0]
+            unpk_value = struct.unpack("<Q", bytes.fromhex(value))[0]
 
             values.append((names[j//16], coord_dict[unpk_value]))
-        print "\tSolution %d: %s" % (i, values)
+        print("\tSolution %d: %s" % (i, values))
 
 
 if __name__ == '__main__':
diff --git a/examples/ekopartyctf2016_sokohashv2/solve.py b/examples/ekopartyctf2016_sokohashv2/solve.py
index 5c51488..c1c5b33 100644
--- a/examples/ekopartyctf2016_sokohashv2/solve.py
+++ b/examples/ekopartyctf2016_sokohashv2/solve.py
@@ -2,17 +2,17 @@
 import subprocess
 
 def test():
-    print >>sys.stderr, "Checking sokosolver_facuman.py solution..."
+    print("Checking sokosolver_facuman.py solution...", file=sys.stderr)
     p = subprocess.Popen([ sys.executable, "sokosolver_facuman.py" ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
     p.wait()
     out = p.stdout.read()
-    assert "[('x', (7, 22)), ('y', (18, 13)), ('z', (2, 5)), ('w', (4, 1))]" in out
+    assert b"[('x', (7, 22)), ('y', (18, 13)), ('z', (2, 5)), ('w', (4, 1))]" in out
 
-    print >>sys.stderr, "Checking sokosolver.py solution..."
+    print("Checking sokosolver.py solution...", file=sys.stdout)
     p = subprocess.Popen([ sys.executable, "sokosolver.py" ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
     p.wait()
     out = p.stdout.read()
-    assert "x:  0xf5b57de9c00229bdL\ny:  0x24b17a4c0132a01L\nz: 0x17c2b7a986200088L\nw: 0x32b0dffbfc485d1eL" in out
+    assert b"x:  0xf5b57de9c00229bd\ny:  0x24b17a4c0132a01\nz: 0x17c2b7a986200088\nw: 0x32b0dffbfc485d1e" in out
 
 if __name__ == '__main__':
     test()
diff --git a/examples/fauxware/solve.py b/examples/fauxware/solve.py
index b896d67..6a2fa17 100644
--- a/examples/fauxware/solve.py
+++ b/examples/fauxware/solve.py
@@ -75,7 +75,7 @@ def test():
     pass        # appease our CI infrastructure which expects this file to do something lmao
 
 if __name__ == '__main__':
-    print basic_symbolic_execution()
+    print(basic_symbolic_execution())
 
 # You should be able to run this program and pipe its into fauxware in order to
 # produce a "sucessfully authenticated" message
diff --git a/examples/flareon2015_10/solve.py b/examples/flareon2015_10/solve.py
index 53743f4..96a85c7 100644
--- a/examples/flareon2015_10/solve.py
+++ b/examples/flareon2015_10/solve.py
@@ -20,12 +20,11 @@
 def before_tea_decrypt(state):
     # Here we want to set the value of the byte array starting from 0x29f210
     # I got those bytes by using cross-reference in IDA
-    all_bytes = [0x56, 0x7f, 0xdc, 0xfa, 0xaa, 0x27, 0x99, 0xc4, 0x6c, 0x7c,
+    all_bytes = bytes([0x56, 0x7f, 0xdc, 0xfa, 0xaa, 0x27, 0x99, 0xc4, 0x6c, 0x7c,
              0xfc, 0x92, 0x61, 0x61, 0x47, 0x1a, 0x19, 0xb9, 0x63, 0xfd,
              0xc, 0xf2, 0xb6, 0x20, 0xc0, 0x2d, 0x5c, 0xfd, 0xd9, 0x71,
-             0x54, 0x96, 0x4f, 0x43, 0xf7, 0xff, 0xbb, 0x4c, 0x5d, 0x31]
-    mem_bytes = "".join([ chr(i) for i in all_bytes ])
-    state.memory.store(ARRAY_ADDRESS, mem_bytes)
+             0x54, 0x96, 0x4f, 0x43, 0xf7, 0xff, 0xbb, 0x4c, 0x5d, 0x31])
+    state.memory.store(ARRAY_ADDRESS, all_bytes)
 
 def main():
     p = angr.Project('challenge-7.sys', load_options={'auto_load_libs': False})
@@ -43,13 +42,13 @@ def main():
     proc_big_68.perform_call(0)
     state = proc_big_68.result_state
     # Load the string from memory
-    return hex(state.solver.eval(state.memory.load(ARRAY_ADDRESS, 40)))[2:-1].decode('hex').strip('\0')
+    return state.solver.eval(state.memory.load(ARRAY_ADDRESS, 40), cast_to=bytes).strip(b'\0')
 
 def test():
-    assert main() == "unconditional_conditions@flare-on.com"
+    assert main() == b"unconditional_conditions@flare-on.com"
 
 if __name__ == "__main__":
     # Turn on logging so we know what's going on...
     # It's up to you to set up a logging handler beforehand
     logging.getLogger('angr.manager').setLevel(logging.DEBUG)
-    print main()
+    print(main())
diff --git a/examples/flareon2015_2/solve.py b/examples/flareon2015_2/solve.py
index b51d85d..df944bd 100644
--- a/examples/flareon2015_2/solve.py
+++ b/examples/flareon2015_2/solve.py
@@ -17,12 +17,12 @@ def main():
     # explore for success state, avoiding failure
     sm = b.factory.simulation_manager(s, immutable=False)
     sm.explore(find=0x40106b, avoid=0x401072)
-    # print the string
+    # print(the string)
     found_state = sm.found[0]
-    return found_state.solver.eval(found_state.memory.load(0x402159, 40), cast_to=str).strip('\0')
+    return found_state.solver.eval(found_state.memory.load(0x402159, 40), cast_to=bytes).strip(b'\0')
 
 def test():
-    assert main() == 'a_Little_b1t_harder_plez@flare-on.com'
+    assert main() == b'a_Little_b1t_harder_plez@flare-on.com'
 
 if __name__ == '__main__':
-    print main()
+    print(main())
diff --git a/examples/flareon2015_5/solve.py b/examples/flareon2015_5/solve.py
index b68e646..e1894c0 100644
--- a/examples/flareon2015_5/solve.py
+++ b/examples/flareon2015_5/solve.py
@@ -12,7 +12,7 @@
 
 
 def hook_duplicate_pw_buf(state):
-    for i in xrange(LEN_PW):
+    for i in range(LEN_PW):
         char_ori = state.memory.load(ADDR_PW_ORI + i, 1)
         state.memory.store(ADDR_PW_ENC + i, char_ori)
     state.regs.ebx = ADDR_PW_ENC
@@ -40,7 +40,7 @@ def main():
 
     # Setup stack to simulate the state after which the "key.txt" is read
     state.regs.esi = LEN_PW
-    for i in xrange(LEN_PW):
+    for i in range(LEN_PW):
         state.mem[ADDR_PW_ORI+i:].byte = state.solver.BVS('pw', 8)
 
     # Hook instructions to use a separate buffer for the XOR-ing function
@@ -58,18 +58,18 @@ def main():
     # Add constraints to make final hash equal to the one we want
     # Also restrict the hash to only printable bytes
     found_s = sm.found[0]
-    for i in xrange(len(GOAL_HASH)):
+    for i in range(len(GOAL_HASH)):
         char = found_s.memory.load(ADDR_HASH + i, 1)
         found_s.add_constraints(char >= 0x21,
                                 char <= 0x7e,
                                 char == ord(GOAL_HASH[i]))
 
     # Solve for password that will result in the required hash
-    return found_s.solver.eval(found_s.memory.load(ADDR_PW_ORI+0, 1), cast_to=str) + \
-          found_s.solver.eval(found_s.memory.load(ADDR_PW_ORI+1, LEN_PW-1), cast_to=str)
+    return found_s.solver.eval(found_s.memory.load(ADDR_PW_ORI+0, 1), cast_to=bytes) + \
+          found_s.solver.eval(found_s.memory.load(ADDR_PW_ORI+1, LEN_PW-1), cast_to=bytes)
 
 def test():
-    assert main() == 'Sp1cy_7_layer_OSI_dip@flare-on.com'
+    assert main() == b'Sp1cy_7_layer_OSI_dip@flare-on.com'
 
 if __name__ == '__main__':
-    print main()
+    print(main())
diff --git a/examples/google2016_unbreakable_0/solve.py b/examples/google2016_unbreakable_0/solve.py
index 3632b63..0e539ac 100755
--- a/examples/google2016_unbreakable_0/solve.py
+++ b/examples/google2016_unbreakable_0/solve.py
@@ -43,12 +43,12 @@ def main():
 
     found = sm.found[0] # In our case, there's only one printable solution.
 
-    solution = found.solver.eval(argv1, cast_to=str)
-    solution = solution[:solution.find("}")+1] # Trim off the null bytes at the end of the flag (if any).
+    solution = found.solver.eval(argv1, cast_to=bytes)
+    solution = solution[:solution.find(b"}")+1] # Trim off the null bytes at the end of the flag (if any).
     return solution
 
 def test():
-    assert main() == 'CTF{0The1Quick2Brown3Fox4Jumped5Over6The7Lazy8Fox9}'
+    assert main() == b'CTF{0The1Quick2Brown3Fox4Jumped5Over6The7Lazy8Fox9}'
 
 if __name__ == '__main__':
     print(repr(main()))
diff --git a/examples/google2016_unbreakable_1/solve.py b/examples/google2016_unbreakable_1/solve.py
index 7afdb1a..060648e 100644
--- a/examples/google2016_unbreakable_1/solve.py
+++ b/examples/google2016_unbreakable_1/solve.py
@@ -27,7 +27,7 @@
 
 def extract_memory(state):
     """Convience method that returns the flag input memory."""
-    return state.solver.eval(state.memory.load(INPUT_ADDR, INPUT_LENGTH), cast_to=str)
+    return state.solver.eval(state.memory.load(INPUT_ADDR, INPUT_LENGTH), cast_to=bytes)
 
 def char(state, n):
     """Returns a symbolic BitVector and contrains it to printable chars for a given state."""
@@ -58,7 +58,7 @@ def main():
     return flag
 
 def test():
-    assert main() == 'CTF{0The1Quick2Brown3Fox4Jumped5Over6The7Lazy8Fox9}'
+    assert main() == b'CTF{0The1Quick2Brown3Fox4Jumped5Over6The7Lazy8Fox9}'
 
 if __name__ == '__main__':
     main()
diff --git a/examples/grub/solve.py b/examples/grub/solve.py
index eb921f2..9ec3127 100755
--- a/examples/grub/solve.py
+++ b/examples/grub/solve.py
@@ -8,7 +8,7 @@ class CheckUniqueness(angr.ExplorationTechnique):
     def __init__(self):
         self.unique_states = set()
 
-    def filter(self, state):
+    def filter(self, simgr, state, filter_func=None):
         vals = []
         for reg in ('eax', 'ebx', 'ecx', 'edx', 'esi', 'edi', 'ebp', 'esp', 'eip'):
             val = state.registers.load(reg)
@@ -22,7 +22,7 @@ def filter(self, state):
             return 'not_unique'
 
         self.unique_states.add(vals)
-        return None
+        return simgr.filter(state, filter_func=filter_func)
 
 
 class SearchForNull(angr.ExplorationTechnique):
@@ -30,10 +30,10 @@ def setup(self, simgr):
         if 'found' not in simgr.stashes:
             simgr.stashes['found'] = []
 
-    def filter(self, state):
+    def filter(self, simgr, state, filter_func=None):
         if state.addr == 0:
             return 'found'
-        return None
+        return simgr.filter(state, filter_func=filter_func)
 
     def complete(self, simgr):
         return len(simgr.found)
@@ -53,7 +53,7 @@ def setup_project():
     xputs_pointer_addr = project.loader.find_symbol('grub_xputs').rebased_addr
     xputs_func_addr = project.loader.extern_object.allocate()
     project.hook(xputs_func_addr, do_nothing())
-    project.loader.memory.write_addr_at(xputs_pointer_addr, xputs_func_addr)
+    project.loader.memory.pack_word(xputs_pointer_addr, xputs_func_addr)
 
     return project
 
@@ -68,15 +68,15 @@ def find_bug(project, function, args):
     simgr.use_technique(CheckUniqueness())
     simgr.run()
 
-    print 'we found a crashing input!'
-    print 'crashing state:', simgr.found[0]
-    print 'input:', repr(simgr.found[0].posix.dumps(0))
+    print('we found a crashing input!')
+    print('crashing state:', simgr.found[0])
+    print('input:', repr(simgr.found[0].posix.dumps(0)))
     return simgr.found[0].posix.dumps(0)
 
 def test():
-    assert find_bug(setup_project(), 'grub_password_get', (angr.PointerWrapper('\0'*64), 64)) == '\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\r'
+    assert find_bug(setup_project(), 'grub_password_get', (angr.PointerWrapper(b'\0'*64), 64)) == b'\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\r'
 
 if __name__ == '__main__':
-    logging.getLogger('angr.manager').setLevel('DEBUG')
+    logging.getLogger('angr.sim_manager').setLevel('DEBUG')
     p = setup_project()
     find_bug(p, 'grub_password_get', (angr.PointerWrapper('\0'*64), 64))
diff --git a/examples/hackcon2016_angry-reverser/solve.py b/examples/hackcon2016_angry-reverser/solve.py
index 8dc3eb8..36659f3 100644
--- a/examples/hackcon2016_angry-reverser/solve.py
+++ b/examples/hackcon2016_angry-reverser/solve.py
@@ -32,16 +32,16 @@ def main():
         state.solver.add(flag.get_byte(i) >= 0x30)
         state.solver.add(flag.get_byte(i) <= 0x7f)
 
-    simgr = proj.factory.simgr(state)
+    simgr = proj.factory.simulation_manager(state)
 
     simgr.explore(find=find, avoid=avoids)
     found = simgr.found[0]
-    return found.solver.eval(flag, cast_to=str)
+    return found.solver.eval(flag, cast_to=bytes)
 
 def test():
-    assert main() == "HACKCON{VVhYS04ngrY}"
+    assert main() == b"HACKCON{VVhYS04ngrY}"
 
 if __name__ in '__main__':
     import logging
     logging.getLogger('angr.sim_manager').setLevel(logging.DEBUG)
-    print main()
+    print(main())
diff --git a/examples/hitcon2017_sakura/solve.py b/examples/hitcon2017_sakura/solve.py
index 72e601e..675ce4a 100755
--- a/examples/hitcon2017_sakura/solve.py
+++ b/examples/hitcon2017_sakura/solve.py
@@ -14,7 +14,7 @@ def main():
     index = 0
     while True:
         # avoid asm('mov byte ptr [rbp-0x1E49], 0')
-        index = e.find('\xc6\x85\xb7\xe1\xff\xff\x00', index+1)
+        index = e.find(b'\xc6\x85\xb7\xe1\xff\xff\x00', index+1)
         if index == -1:
             break
         addr = 0x400000 + index
@@ -25,31 +25,31 @@ def main():
     index = 0
     while True:
         # find asm('mov rdi, rax')
-        index = e.find('H\x89\xc7', index+1)
+        index = e.find(b'H\x89\xc7', index+1)
         if index == -1 or index > 0x10ff5:
             break
         addr = 0x400000 + index
         finds.append(addr)
 
         # skip a addr we don't want to find
-        index = e.find('H\x89\xc7', index+1)
+        index = e.find(b'H\x89\xc7', index+1)
 
     # initialize project
     proj = angr.Project('./sakura')
     state = proj.factory.entry_state()
-    simgr = proj.factory.simgr(state)
+    simgr = proj.factory.simulation_manager(state)
 
     # find ans stage by stage
     for find in finds:
         simgr.explore(find=find, avoid=avoids)
         found = simgr.found[0]
-        simgr = proj.factory.simgr(found)
+        simgr = proj.factory.simulation_manager(found)
 
     # evaluate text
-    text = found.solver.eval(found.memory.load(0x612040, 400), cast_to=str)
+    text = found.solver.eval(found.memory.load(0x612040, 400), cast_to=bytes)
 
     h = hashlib.sha256(text)
-    flag = 'hitcon{'+h.digest().encode('hex')+'}'
+    flag = 'hitcon{'+h.hexdigest()+'}'
     return flag
 
 def test():
@@ -59,4 +59,4 @@ def test():
     import logging
     logging.getLogger('angr.sim_manager').setLevel(logging.DEBUG)
 
-    print main()
+    print(main())
diff --git a/examples/insomnihack_aeg/.gitignore b/examples/insomnihack_aeg/.gitignore
new file mode 100644
index 0000000..be229ab
--- /dev/null
+++ b/examples/insomnihack_aeg/.gitignore
@@ -0,0 +1 @@
+demo_bin-exploit
diff --git a/examples/insomnihack_aeg/solve.py b/examples/insomnihack_aeg/solve.py
index 81e1946..143a9a4 100644
--- a/examples/insomnihack_aeg/solve.py
+++ b/examples/insomnihack_aeg/solve.py
@@ -10,7 +10,7 @@
 
 
 # shellcraft i386.linux.sh
-shellcode = "6a68682f2f2f73682f62696e89e331c96a0b5899cd80".decode('hex')
+shellcode = bytes.fromhex("6a68682f2f2f73682f62696e89e331c96a0b5899cd80")
 
 def fully_symbolic(state, variable):
     '''
@@ -65,7 +65,7 @@ def main(binary):
     l.info("looking for vulnerability in '%s'", binary_name)
     exploitable_state = None
     while exploitable_state is None:
-        print sm
+        print(sm)
         sm.step()
         if len(sm.unconstrained) > 0:
             l.info("found some unconstrained states, checking exploitability")
@@ -102,16 +102,16 @@ def main(binary):
         return 1
 
     filename = '%s-exploit' % binary_name
-    with open(filename, 'w') as f:
+    with open(filename, 'wb') as f:
         f.write(ep.posix.dumps(0))
 
-    print "%s exploit in %s" % (binary_name, filename)
-    print "run with `(cat %s; cat -) | %s`" % (filename, binary)
+    print("%s exploit in %s" % (binary_name, filename))
+    print("run with `(cat %s; cat -) | %s`" % (filename, binary))
     return 0
 
 def test():
     main('./demo_bin')
-    assert subprocess.check_output('(cat ./demo_bin-exploit; echo echo BUMO) | ./demo_bin', shell=True) == 'BUMO\n'
+    assert subprocess.check_output('(cat ./demo_bin-exploit; echo echo BUMO) | ./demo_bin', shell=True) == b'BUMO\n'
 
 if __name__ == '__main__':
     # silence some annoying logs
@@ -121,4 +121,4 @@ def test():
     if len(sys.argv) > 1:
         sys.exit(main(sys.argv[1]))
     else:
-        print "%s: <binary>" % sys.argv[0]
+        print("%s: <binary>" % sys.argv[0])
diff --git a/examples/layer7_onlyone/solve.py b/examples/layer7_onlyone/solve.py
index 771a9e0..64dea67 100644
--- a/examples/layer7_onlyone/solve.py
+++ b/examples/layer7_onlyone/solve.py
@@ -37,7 +37,7 @@ def main():
 
     # Load our input string, and make sure there is no null byte inside
     content = initial_state.memory.load(str_ptr, len(encrypted))
-    for i in xrange(0, len(content), 8):
+    for i in range(0, len(content), 8):
         initial_state.add_constraints(content[i + 7 : i] != 0)
 
     # Make sure the input string ends with a null byte
@@ -54,7 +54,7 @@ def main():
     # Call explorer to execute the function
     # Note that Veritesting is important since we want to avoid unnecessary branching
     ex = angr.surveyors.Explorer(p, start=initial_state, find=(0x4010c9, ), enable_veritesting=True)
-    print "Executing..."
+    print("Executing...")
     angr.surveyors.explorer.l.setLevel(logging.DEBUG)
     angr.surveyors.surveyor.l.setLevel(logging.DEBUG)
     r = ex.run()
@@ -66,12 +66,12 @@ def main():
 
     # Load the final encrypted string, add constraints to make the string be equal to encrypted data
     buf_ptr = final_state.memory.load(final_state.regs.ebp - 0x18, 4, endness=p.arch.memory_endness)
-    for i in xrange(0, len(encrypted)):
+    for i in range(0, len(encrypted)):
         final_state.add_constraints(final_state.memory.load(buf_ptr + i, 1) == ord(encrypted[i]))
 
     # Our input - solve it!
     input_string = final_state.memory.load(str_ptr, 10)
-    print "Solving..."
+    print("Solving...")
     candidates = final_state.solver.eval_upto(input_string, 2)
 
     assert len(candidates) == 1
@@ -81,4 +81,4 @@ def test():
     assert main() == 'I_H4TE_X0r'
 
 if __name__ == "__main__":
-    print main()
+    print(main())
diff --git a/examples/mma_howtouse/solve.py b/examples/mma_howtouse/solve.py
index 590cbe0..e035558 100644
--- a/examples/mma_howtouse/solve.py
+++ b/examples/mma_howtouse/solve.py
@@ -16,7 +16,7 @@
 def main():
     # Load the binary. Base addresses are weird when loading binaries directly, so
     # we specify it explicitly.
-    p = angr.Project('howtouse.dll', load_options={'main_opts': {'custom_base_addr': 0x10000000}})
+    p = angr.Project('howtouse.dll', load_options={'main_opts': {'base_addr': 0x10000000}})
 
     # A "Callable" is angr's FFI-equivalent. It allows you to call binary functions
     # from Python. Here, we use it to call the `howtouse` function.
@@ -27,10 +27,10 @@ def main():
     getch = lambda i: chr(claripy.backends.concrete.convert(howtouse(i)).value)
 
     # Let's call this 45 times, and that's the result!
-    return ''.join(getch(i) for i in xrange(45))
+    return ''.join(getch(i) for i in range(45))
 
 def test():
     assert main() == 'MMA{fc7d90ca001fc8712497d88d9ee7efa9e9b32ed8}'
 
 if __name__ == '__main__':
-    print main()
+    print(main())
diff --git a/examples/mma_simplehash/solve.py b/examples/mma_simplehash/solve.py
index 54ef2ec..4e7f0d7 100644
--- a/examples/mma_simplehash/solve.py
+++ b/examples/mma_simplehash/solve.py
@@ -1,102 +1,110 @@
-#!/usr/bin/env python
-
-#
-# simple_hash was a reversing challenge in the first MMA CTF, held in 2015.
-# This binary implemented a hash function. To get the flag, the hacker needed
-# to provide an input that hashed to a specific value.
-#
-# This provided a number of challenges to angr:
-#
-# 1. Because we need to automatically break a hash, constraint solves can be
-#    extremely slow. This means that we need to adjust Z3's timeout so that
-#    constraint solves will succeed.
-# 2. The optimized way in which modular multiplication is implemented in the
-#    binary causes problems for angr's symbolic execution engine and results
-#    in a path explosion. To get around this, we need to hook the `mm` and
-#    `moddi3` functions with python summaries.
-# 3. There is a bug in angr's environment model, causing global data used by
-#    `isalnum` to be improperly initialized. As a temporary fix, we need to
-#    hook the `isalnum` function with a python summary.
-# 4. One of the initializers in the binary causes a path explosion in the
-#    symbolic execution engine. This is also likely due to a faulty environment
-#    model. Our solution was to simply begin execution from within `main()`,
-#    manually specifying the user input.
-#
-# Once these issues are addressed, things go fairly smoothly! Keep in mind that
-# this is still a tough problem for symbolic execution, so the solution takes
-# about an hour to run.
-
-#
-# Go go go!
-#
-
-import angr
-
-#
-# These are our symbolic summary functions for modular multiplication, modulo,
-# and isalnum.
-#
-
-class mm(angr.SimProcedure):
-    def run(self, low1, high1, low2, high2):
-        first = high1.concat(low1)
-        second = high2.concat(low2)
-        result = (first * second) % 1000000000000037
-        self.state.regs.edx = self.state.solver.Extract(63, 32, result)
-        return self.state.solver.Extract(31, 0, result)
-
-class moddi3(angr.SimProcedure):
-    def run(self, a, a2, b, b2):
-        first = a2.concat(a)
-        second = b2.concat(b)
-        result = first % second
-        self.state.regs.edx = self.state.solver.Extract(63, 32, result)
-        return self.state.solver.Extract(31, 0, result)
-
-class isalnum(angr.SimProcedure):
-    def run(self, c):
-        is_num = self.state.solver.And(c >= ord("0"), c <= ord("9"))
-        is_alpha_lower = self.state.solver.And(c >= ord("a"), c <= ord("z"))
-        is_alpha_upper = self.state.solver.And(c >= ord("A"), c <= ord("Z"))
-        isalphanum = self.state.solver.Or(is_num, is_alpha_lower, is_alpha_upper)
-        return self.state.solver.If(isalphanum, self.state.solver.BVV(1, self.state.arch.bits), self.state.solver.BVV(0, self.state.arch.bits))
-
-def main():
-    # Let's load the file and hook the problem functions to get around issues 3
-    # and 4.
-    b = angr.Project("simple_hash")
-    b.hook(0x80487EC, mm)
-    b.hook(0x8048680, moddi3)
-    b.hook(0x80486E0, isalnum)
-
-    # Here, we create a new symbolic state. To get around issue 5, we start
-    # execution partway through `main()`.
-    s = b.factory.blank_state(addr=0x8048A63)
-
-    # To get around issue 1, we raise the solver timeout (specified in
-    # milliseconds) to avoid situations where Z3 times out. Without this, with the
-    # current way Z3 is used in angr, valid solutions end up being discarded
-    # because Z3 can't find them fast enough.
-    s.solver._solver.timeout=30000000
-
-    # Since we started execution partway through main(), after the user input was
-    # read, we need to manually set the user input.
-    s.memory.store(0x080491A0, s.solver.BVS("ans", 999*8))
-
-    # Now, we start the symbolic execution. We create a PathGroup and set up some
-    # logging (so that we can see what's happening).
-    sm = b.factory.simulation_manager(s, immutable=False)
-    angr.manager.l.setLevel("DEBUG")
-
-    # We want to explore to the "success" state (0x8048A94) while avoiding the
-    # "failure" state (0x8048AF6). This takes a loong time (about an hour).
-    sm.explore(find=0x8048A94, avoid=0x8048AF6)
-
-    # We're done!
-    return sm.found[0].solver.eval(sm.found[0].memory.load(0x080491A0, 100), cast_to=str).strip('\0\n')
-
-def test():
-    assert main() == 'EwgHWpyND'
-
-if __name__ == '__main__':
-    print main()
+#!/usr/bin/env python
+
+#
+# simple_hash was a reversing challenge in the first MMA CTF, held in 2015.
+# This binary implemented a hash function. To get the flag, the hacker needed
+# to provide an input that hashed to a specific value.
+#
+# This provided a number of challenges to angr:
+#
+# 1. Because we need to automatically break a hash, constraint solves can be
+#    extremely slow. This means that we need to adjust Z3's timeout so that
+#    constraint solves will succeed.
+# 2. The optimized way in which modular multiplication is implemented in the
+#    binary causes problems for angr's symbolic execution engine and results
+#    in a path explosion. To get around this, we need to hook the `mm` and
+#    `moddi3` functions with python summaries.
+# 3. There is a bug in angr's environment model, causing global data used by
+#    `isalnum` to be improperly initialized. As a temporary fix, we need to
+#    hook the `isalnum` function with a python summary.
+# 4. One of the initializers in the binary causes a path explosion in the
+#    symbolic execution engine. This is also likely due to a faulty environment
+#    model. Our solution was to simply begin execution from within `main()`,
+#    manually specifying the user input.
+#
+# Once these issues are addressed, things go fairly smoothly! Keep in mind that
+# this is still a tough problem for symbolic execution, so the solution takes
+# about an hour to run.
+
+#
+# Go go go!
+#
+
+import angr
+import subprocess
+
+#
+# These are our symbolic summary functions for modular multiplication, modulo,
+# and isalnum.
+#
+
+class mm(angr.SimProcedure):
+    def run(self, low1, high1, low2, high2):
+        first = high1.concat(low1)
+        second = high2.concat(low2)
+        result = (first * second) % 1000000000000037
+        self.state.regs.edx = self.state.solver.Extract(63, 32, result)
+        return self.state.solver.Extract(31, 0, result)
+
+class moddi3(angr.SimProcedure):
+    def run(self, a, a2, b, b2):
+        first = a2.concat(a)
+        second = b2.concat(b)
+        result = first % second
+        self.state.regs.edx = self.state.solver.Extract(63, 32, result)
+        return self.state.solver.Extract(31, 0, result)
+
+class isalnum(angr.SimProcedure):
+    def run(self, c):
+        is_num = self.state.solver.And(c >= ord("0"), c <= ord("9"))
+        is_alpha_lower = self.state.solver.And(c >= ord("a"), c <= ord("z"))
+        is_alpha_upper = self.state.solver.And(c >= ord("A"), c <= ord("Z"))
+        isalphanum = self.state.solver.Or(is_num, is_alpha_lower, is_alpha_upper)
+        return self.state.solver.If(isalphanum, self.state.solver.BVV(1, self.state.arch.bits), self.state.solver.BVV(0, self.state.arch.bits))
+
+def main():
+    # Let's load the file and hook the problem functions to get around issues 3
+    # and 4.
+    b = angr.Project("simple_hash")
+    b.hook(0x80487EC, mm)
+    b.hook(0x8048680, moddi3)
+    b.hook(0x80486E0, isalnum)
+
+    # Here, we create a new symbolic state. To get around issue 5, we start
+    # execution partway through `main()`.
+    s = b.factory.blank_state(addr=0x8048A63)
+
+    # To get around issue 1, we raise the solver timeout (specified in
+    # milliseconds) to avoid situations where Z3 times out. Without this, with the
+    # current way Z3 is used in angr, valid solutions end up being discarded
+    # because Z3 can't find them fast enough.
+    s.solver._solver.timeout=30000000
+
+    # Since we started execution partway through main(), after the user input was
+    # read, we need to manually set the user input.
+    s.memory.store(0x080491A0, s.solver.BVS("ans", 999*8))
+
+    # Now, we start the symbolic execution. We create a PathGroup and set up some
+    # logging (so that we can see what's happening).
+    sm = b.factory.simulation_manager(s, immutable=False)
+    angr.manager.l.setLevel("DEBUG")
+
+    # We want to explore to the "success" state (0x8048A94) while avoiding the
+    # "failure" state (0x8048AF6). This takes a loong time (about an hour).
+    sm.explore(find=0x8048A94, avoid=0x8048AF6)
+
+    # We're done!
+    flag_state = sm.found[0]
+    flag_data = flag_state.memory.load(0x080491A0, 100)
+    return flag_state.solver.eval(flag_data, cast_to=bytes).strip(b'\0\n')
+
+def test():
+    flag = main()
+    p = subprocess.Popen(['./simple_hash'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+    p.stdin.write(flag + b'\n')
+    p.stdin.flush()
+    p.wait()
+    assert b'Correct' in p.stdout.read()
+
+if __name__ == '__main__':
+    print(main())
diff --git a/examples/secconquals2016_ropsynth/.gitignore b/examples/secconquals2016_ropsynth/.gitignore
new file mode 100644
index 0000000..3efef76
--- /dev/null
+++ b/examples/secconquals2016_ropsynth/.gitignore
@@ -0,0 +1 @@
+gadgets.elf
diff --git a/examples/secconquals2016_ropsynth/solve.py b/examples/secconquals2016_ropsynth/solve.py
index 77c8922..58cab81 100644
--- a/examples/secconquals2016_ropsynth/solve.py
+++ b/examples/secconquals2016_ropsynth/solve.py
@@ -26,14 +26,14 @@ def make_elf(gadgets):
     """
     the_bytes = base64.b64decode(gadgets)
     for i in reversed(range(2, 20)):
-        the_bytes = the_bytes.replace('\xf4'*i, '\xcc'*i)
-    the_bytes = the_bytes.replace('\xc3\xf4', '\xc3\xcc')
-    print "gadgets length:", len(the_bytes)
-    the_bytes = the_bytes.ljust(4096, "\xcc")
-    print "gadgets: %r" % the_bytes[:100]
-    the_nops = open('nop.elf').read()
-    the_gadgets = the_nops.replace("\x90"*4096, the_bytes)
-    open('gadgets.elf', 'w').write(the_gadgets)
+        the_bytes = the_bytes.replace(b'\xf4'*i, b'\xcc'*i)
+    the_bytes = the_bytes.replace(b'\xc3\xf4', b'\xc3\xcc')
+    print("gadgets length:", len(the_bytes))
+    the_bytes = the_bytes.ljust(4096, b"\xcc")
+    print("gadgets: %r" % the_bytes[:100])
+    the_nops = open('nop.elf', 'rb').read()
+    the_gadgets = the_nops.replace(b"\x90"*4096, the_bytes)
+    open('gadgets.elf', 'wb').write(the_gadgets)
 
 def postprocess_chain(chain, guard_solutions):
     """
@@ -132,7 +132,7 @@ def get_gadgets():
         # we save off inputs needed to pass the checks for any given gadget before the start of the checks.
         # Since the checks pop data in order, we can just concat all the checked input.
         for a in range(f.addr, start_of_checks):
-            guard_solutions[a] = good_state.solver.eval(claripy.Concat(*symbolic_guard_guys), cast_to=str)
+            guard_solutions[a] = good_state.solver.eval(claripy.Concat(*symbolic_guard_guys), cast_to=bytes)
 
         #
         # With the checks recovered, we now overwrite them with a ret, so that angrop considers the gadgets
@@ -193,13 +193,13 @@ def test():
     try:
         for _ in range(5):
             r.stdout.read(6)
-            print "STAGE:", r.stdout.read(1)
+            print("STAGE:", r.stdout.read(1))
             r.stdout.read(3)
 
             # Get the gadgets
             time.sleep(1)
-            gadgets = ""
-            while not gadgets.endswith('\n'):
+            gadgets = b""
+            while not gadgets.endswith(b'\n'):
                 read = r.stdout.read(1)
                 if not read:
                     raise Exception("server terminated unexpectedly")
@@ -213,16 +213,16 @@ def test():
             chain = get_gadgets()
 
             # Send the gadgets
-            r.stdin.write(base64.b64encode(chain) + "\n")
+            r.stdin.write(base64.b64encode(chain).encode() + b"\n")
 
             # Make sure things are good
             status = r.stdout.read(3).strip()
-            assert status == "OK"
+            assert status == b"OK"
 
         # After 5 successful rop synths, the binary sends up the flag.
         flag = r.stdout.read(128).strip()
-        print "LOCAL FLAG:", flag
-        assert flag == 'SECCON{HAHAHHAHAHAAHA}'
+        print("LOCAL FLAG:", flag)
+        assert flag == b'SECCON{HAHAHHAHAHAAHA}'
     finally:
         r.kill()
 
diff --git a/examples/secuinside2016mbrainfuzz/solve.py b/examples/secuinside2016mbrainfuzz/solve.py
index 6cf7d1d..8cc9242 100644
--- a/examples/secuinside2016mbrainfuzz/solve.py
+++ b/examples/secuinside2016mbrainfuzz/solve.py
@@ -14,7 +14,7 @@
 
 
 def static_analyses(p):
-    print '[*] Analyzing %s...' % p.filename
+    print('[*] Analyzing %s...' % p.filename)
 
     #This part is done with r2 in the original writeup.
     #However, it is also possible to do the same with angr! :)
@@ -27,9 +27,9 @@ def static_analyses(p):
 
     #As the main function doesn't get identified automatically, let's use a small trick here:
     #We take a function which is only called in main (e.g. sscanf) and resolve its predecessor
-    for address,function in cfg.functions.iteritems():
+    for address,function in cfg.functions.items():
         if function.name == '__isoc99_sscanf' and function.is_plt:
-            addr = cfg.functions.callgraph.predecessors(address)[0]
+            addr = next(iter(cfg.functions.callgraph.predecessors(address)))
             break
 
     #Now, let's go down all the way to the target function
@@ -72,7 +72,7 @@ def static_analyses(p):
 #pylint:disable=redefined-builtin
 
 def generate_input(p, to_find, to_avoid, byte_addresses):
-    print '[*] Generating input ....'
+    print('[*] Generating input ....')
 
     byte_map = {}
 
@@ -108,13 +108,13 @@ def generate_input(p, to_find, to_avoid, byte_addresses):
 
 def format_input(byte_map):
     res = ''
-    for i in xrange(min(byte_map), max(byte_map) + 1):
+    for i in range(min(byte_map), max(byte_map) + 1):
         res += "%02x" % byte_map[i]
     return res
 
 
 def generate_exploit(byte_string):
-    print '[*] Crafting final exploit'
+    print('[*] Crafting final exploit')
 
     #In essence, the magic consists of:
     #   - static padding between input and the memcpy'ed buffer
@@ -133,8 +133,8 @@ def main(binary):
     (to_find, to_avoid, byte_addresses) = static_analyses(p)
     byte_map = generate_input(p, to_find, to_avoid, byte_addresses)
     exploit = generate_exploit(format_input(byte_map))
-    print '[+] Exploit generated!'
-    print '[!] Please run `%s %s`' % (binary,exploit)
+    print('[+] Exploit generated!')
+    print('[!] Please run `%s %s`' % (binary,exploit))
     return exploit
 
 def test():
@@ -142,7 +142,7 @@ def test():
 
     for b in binaries:
         p = main(b)
-        assert subprocess.check_output([b,p]) == 'SUCCESS\n'
+        assert subprocess.check_output([b,p]) == b'SUCCESS\n'
 
 if __name__ == '__main__':
     main(sys.argv[1])
diff --git a/examples/securityfest_fairlight/solve.py b/examples/securityfest_fairlight/solve.py
index 18d81ad..84dace6 100644
--- a/examples/securityfest_fairlight/solve.py
+++ b/examples/securityfest_fairlight/solve.py
@@ -21,13 +21,13 @@ def main():
     sm = proj.factory.simulation_manager(initial_state)
     sm.explore(find=0x4018f7, avoid=0x4018f9)
     found = sm.found[0]
-    return found.solver.eval(argv1, cast_to=str)
+    return found.solver.eval(argv1, cast_to=bytes)
 
 
 def test():
     res = main()
-    print repr(res)
-    assert res == '4ngrman4gem3nt'
+    print(repr(res))
+    assert res == b'4ngrman4gem3nt'
 
 
 if __name__ == '__main__':
diff --git a/examples/sharif7_rev50/solve.py b/examples/sharif7_rev50/solve.py
index a68b762..f5cf649 100644
--- a/examples/sharif7_rev50/solve.py
+++ b/examples/sharif7_rev50/solve.py
@@ -71,8 +71,8 @@
 #//////////////////////////////////////////////////////////////////////////////
 # Core functions
 #
-FLAG = "SharifCTF{b70c59275fcfa8aebf2d5911223c6589}"
-FLAG_STR = "SharifCTF{????????????????????????????????}"
+FLAG = b"SharifCTF{b70c59275fcfa8aebf2d5911223c6589}"
+FLAG_STR = b"SharifCTF{????????????????????????????????}"
 #
 def solve(_file):
 
@@ -106,7 +106,7 @@ def solve(_file):
     # retrieve the 43 bytes (e.g. len(flag)) at flag_addr
     solve_var = sm.found[0].memory.load(flag_addr, len(FLAG_STR))
     # and convert it into a string:
-    solved_flag = sm.found[0].solver.eval(solve_var, cast_to=str)
+    solved_flag = sm.found[0].solver.eval(solve_var, cast_to=bytes)
 
     return solved_flag
 
@@ -119,7 +119,7 @@ def test():
     assert solve(challenge) == FLAG
 
 def main(_args):
-    print solve(_args.input)
+    print(solve(_args.input))
 
 #
 #//////////////////////////////////////////////////////////////////////////////
diff --git a/examples/simple_heap_overflow/solve.py b/examples/simple_heap_overflow/solve.py
index c1fee19..6f3b258 100755
--- a/examples/simple_heap_overflow/solve.py
+++ b/examples/simple_heap_overflow/solve.py
@@ -23,7 +23,7 @@ def main():
     # By default, angr will use a sim procedure instead of going through malloc
     # This will tell angr to go ahead and use libc's calloc
     proj = angr.Project("./simple_heap_overflow", exclude_sim_procedures_list=["calloc"],
-            custom_ld_path=os.path.join(DIR, '../../../binaries/tests/x86_64'))
+            ld_path=os.path.join(DIR, '../../../binaries/tests/x86_64'))
 
     # The extra option here is due to a feature not yet in angr for handling
     # underconstraining 0 initialization of certain memory allocations
@@ -37,7 +37,7 @@ def main():
     while sm.active and not sm.unconstrained:
         sm.step()
 
-    print sm
+    print(sm)
     # In [9]: sm
     # Out[9]: <PathGroup with 1 deadended, 1 unconstrained>
 
@@ -50,11 +50,11 @@ def main():
     # win function to give us execution
     s.add_constraints(s.regs.rip == proj.loader.find_symbol('win').rebased_addr)
 
-    print s.solver.constraints
+    print(s.solver.constraints)
     assert s.satisfiable()
 
     # Call the solving engine and write the solution out to a file called "exploit"
-    print "Writing exploit as \"exploit\""
+    print("Writing exploit as \"exploit\"")
     with open('exploit', 'wb') as fp:
         fp.write(s.posix.dumps(0))
 
@@ -62,7 +62,6 @@ def main():
     # ./simple_heap_overflow < exploit
 
 def test():
-
     # Generate the exploit
     main()
 
@@ -74,17 +73,8 @@ def test():
         ,shell=True)
 
     # Assert we got to the printing of Win
-    assert "Win" in out
+    assert b"Win" in out
 
 
 if __name__ == '__main__':
-    main()
-
-    run_result = subprocess.check_output("{0} < {1}".format(
-        os.path.join(DIR,"simple_heap_overflow"),
-        os.path.join(DIR,"exploit"),
-        )
-        ,shell=True)
-
-    # Assert we got to the printing of Win
-    assert "Win" in run_result
+    test()
diff --git a/examples/strcpy_find/solve.py b/examples/strcpy_find/solve.py
index c768286..378367a 100755
--- a/examples/strcpy_find/solve.py
+++ b/examples/strcpy_find/solve.py
@@ -27,18 +27,18 @@ def main():
     '''
     def getFuncAddress( funcName, plt=None ):
         found = [
-            addr for addr,func in cfg.kb.functions.iteritems()
+            addr for addr,func in cfg.kb.functions.items()
             if funcName == func.name and (plt is None or func.is_plt == plt)
             ]
         if len( found ) > 0:
-            print "Found "+funcName+"'s address at "+hex(found[0])+"!"
+            print("Found "+funcName+"'s address at "+hex(found[0])+"!")
             return found[0]
         else:
             raise Exception("No address found for function : "+funcName)
 
 
     def get_byte(s, i):
-        pos = s.size() / 8 - 1 - i
+        pos = s.size() // 8 - 1 - i
         return s[pos * 8 + 7 : pos * 8]
 
     '''
@@ -113,13 +113,13 @@ def check(state):
              vector, we grab its string representation using the current state's
              solver engine's function "eval" with cast_to set to str so we get a python string.
             '''
-            strCpySrc = state.solver.eval( BV_strCpySrc , cast_to=str )
+            strCpySrc = state.solver.eval( BV_strCpySrc , cast_to=bytes )
             '''
              Now we simply return True (found path) if we've found a path to strcpy
              where we control the source buffer, or False (keep looking for paths) if we
              don't control the source buffer
             '''
-            return True if argv[2] in strCpySrc else False
+            return True if argv[2].encode() in strCpySrc else False
         else:
             '''
              If we aren't in the strcpy function, we need to tell angr to keep looking
@@ -145,11 +145,11 @@ def check(state):
      able to strcpy() any string you want into the destination buffer and
      cause a segmentation fault if it is too large :)
     '''
-    if ( len( found ) > 0 ):    #   Make sure we found a path before giving the solution
+    if len(found) > 0:    #   Make sure we found a path before giving the solution
         found = sm.found[0]
-        result = found.solver.eval(argv[1], cast_to=str)
+        result = found.solver.eval(argv[1], cast_to=bytes)
         try:
-            result = result[:result.index('\0')]
+            result = result[:result.index(b'\0')]
         except ValueError:
             pass
     else:   # Aww somehow we didn't find a path.  Time to work on that check() function!
@@ -158,8 +158,8 @@ def check(state):
 
 def test():
     output = main()
-    target = "Totally not the password..."
+    target = b"Totally not the password..."
     assert output[:len(target)] == target
 
 if __name__ == "__main__":
-    print 'The password is "%s"' % main()
+    print('The password is "%s"' % main())
diff --git a/examples/sym-write/solve.py b/examples/sym-write/solve.py
index a3dc6b4..3df5409 100644
--- a/examples/sym-write/solve.py
+++ b/examples/sym-write/solve.py
@@ -25,14 +25,14 @@ def main():
 
 	def correct(state):
 		try:
-			return 'win' in state.posix.dumps(1)
+			return b'win' in state.posix.dumps(1)
 		except:
 			return False
 	def wrong(state):
-	 	try:
-	 		return 'lose' in state.posix.dumps(1)
-	 	except:
-	 		return False
+		try:
+			return b'lose' in state.posix.dumps(1)
+		except:
+			return False
 
 	sm.explore(find=correct, avoid=wrong)
 
diff --git a/examples/tumctf2016_zwiebel/solve.py b/examples/tumctf2016_zwiebel/solve.py
index 0baa32b..3e3d779 100644
--- a/examples/tumctf2016_zwiebel/solve.py
+++ b/examples/tumctf2016_zwiebel/solve.py
@@ -1,4 +1,3 @@
-
 import angr
 
 def main():
@@ -8,44 +7,41 @@ def main():
     # import logging
     # logging.getLogger('angr.manager').setLevel(logging.DEBUG)
 
-    p = angr.Project("zwiebel",
-                     support_selfmodifying_code=True, # this is important! this binary unpacks its code
-                     load_options={'auto_load_libs': False}
-                     )
+    p = angr.Project("zwiebel", support_selfmodifying_code=True) # this is important! this binary unpacks its code
+    p.hook_symbol('ptrace', angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'](return_value=0))
 
     # unicorn support makes execution, especially code unpacking, way faster
-    state = p.factory.entry_state(add_options=angr.options.unicorn)
+    state = p.factory.full_init_state(add_options=angr.options.unicorn)
     sm = p.factory.simulation_manager(state)
 
     while sm.active:
         # in order to save memory, we only keep the recent 20 deadended or
         # errored states
+        #print(len(sm.active))
         sm.run(n=20)
-        print len(sm.active)
         if 'deadended' in sm.stashes and sm.deadended:
             sm.stashes['deadended'] = sm.deadended[-20:]
         if sm.errored:
             sm.errored = sm.errored[-20:]
 
     assert sm.deadended
-    flag = sm.deadended[-1].posix.dumps(0).split("\n")[0]
+    flag = sm.deadended[-1].posix.dumps(0).split(b"\n")[0]
+    import ipdb; ipdb.set_trace()
     return flag
 
-    # import ipdb; ipdb.set_trace()
-
 def test():
     flag = main()
-    assert flag.startswith('hxp{1_h0p3_y0u_d1dnt_p33l_th3_0ni0n_by_h4nd}')
+    assert flag.startswith(b'hxp{1_h0p3_y0u_d1dnt_p33l_th3_0ni0n_by_h4nd}')
 
 if __name__ == "__main__":
-    print main()
+    print(main())
 
 # Here is the output (after 2 hours and 31 minutes on my machine running Pypy):
 # 
-# ipdb> print sm
+# ipdb> print(sm)
 # <PathGroup with 20 errored, 21 deadended>
-# ipdb> print sm.deadended[-1]
+# ipdb> print(sm.deadended[-1])
 # <Path with 160170 runs (at 0x20001e0)>
-# ipdb> print sm.deadended[-1].state.posix.dumps(0)
+# ipdb> print(sm.deadended[-1].state.posix.dumps(0))
 # hxp{1_h0p3_y0u_d1dnt_p33l_th3_0ni0n_by_h4nd}
 # :)
diff --git a/examples/unmapped_analysis/solve.py b/examples/unmapped_analysis/solve.py
index 2f964c8..c5ab44d 100755
--- a/examples/unmapped_analysis/solve.py
+++ b/examples/unmapped_analysis/solve.py
@@ -14,30 +14,30 @@
 # logging.getLogger('angr').setLevel(logging.DEBUG)
 
 def main():
-	project = angr.Project('./unmap', load_options={"auto_load_libs": False})
-	state = project.factory.entry_state(add_options={angr.options.STRICT_PAGE_ACCESS})
+    project = angr.Project('./unmap', load_options={"auto_load_libs": False})
+    state = project.factory.entry_state(add_options={angr.options.STRICT_PAGE_ACCESS})
 
-	simulation_manager = project.factory.simulation_manager(state)
+    simulation_manager = project.factory.simulation_manager(state)
 
-	# (•_•) ( •_•)>⌐■-■ (⌐■_■)
-	simulation_manager.explore()
+    # (•_•) ( •_•)>⌐■-■ (⌐■_■)
+    simulation_manager.explore()
 
-	keys = []
+    keys = []
 
-	for deadended in simulation_manager.deadended:
-		print("Valid memory access triggered by %s" % repr(deadended.posix.dumps(0)))
+    for deadended in simulation_manager.deadended:
+        print("Valid memory access triggered by %s" % repr(deadended.posix.dumps(0)))
 
-	for errored in simulation_manager.errored:
-		stdin = errored.state.posix.dumps(0)
-		keys.append(stdin)
-		print("%s caused by %s" % (errored.error, repr(stdin)))
+    for errored in simulation_manager.errored:
+        stdin = errored.state.posix.dumps(0)
+        keys.append(stdin)
+        print("%s caused by %s" % (errored.error, repr(stdin)))
 
-	keys.sort()
-	return keys
+    return keys
 
 def test():
-	keys = sorted(['e6dba991c1745128787fbc7a9843306cb2bcc63e', '275edf0657388c3a1197cdadfad7b96da0f977a3'])
-	assert main() == keys
+    answer = [b'275edf0657388c3a1197cdadfad7b96da0f977a3', b'e6dba991c1745128787fbc7a9843306cb2bcc63e']
+    keys = main()
+    assert sorted(keys) == sorted(answer)
 
 if __name__ == '__main__':
-	main()
+    main()
diff --git a/examples/whitehat_crypto400/solve.py b/examples/whitehat_crypto400/solve.py
index 29d67c2..6cc4f44 100644
--- a/examples/whitehat_crypto400/solve.py
+++ b/examples/whitehat_crypto400/solve.py
@@ -15,11 +15,9 @@
 import angr
 import claripy
 
-from angr.procedures.stubs.UserHook import UserHook
-
 def get_possible_flags():
     # load the binary
-    print '[*] loading the binary'
+    print('[*] loading the binary')
     p = angr.Project("whitehat_crypto400")
 
     # this is a statically-linked binary, and it's easer for angr if we use Python
@@ -36,8 +34,8 @@ def get_possible_flags():
     # string
     def hook_length(state):
         state.regs.rax = 8
-    p.hook(0x40168e, UserHook(user_func=hook_length, length=5))
-    p.hook(0x4016BE, UserHook(user_func=hook_length, length=5))
+    p.hook(0x40168e, hook_length, length=5)
+    p.hook(0x4016BE, hook_length, length=5)
 
     # here, we create the initial state to start execution. argv[1] is our 8-byte
     # string, and we add an angr option to gracefully handle unsupported syscalls
@@ -48,15 +46,15 @@ def hook_length(state):
     for b in arg1.chop(8):
         initial_state.add_constraints(b != 0)
 
-    # PathGroups are a basic building block of the symbolic execution engine. They
-    # track a group of paths as the binary is executed, and allows for easier
-    # management, pruning, and so forth of those paths
+    # Simulation managers are a basic building block of the symbolic execution engine.
+    # They track a group of states as the binary is executed, and allows for easier
+    # management, pruning, and so forth of those states
     sm = p.factory.simulation_manager(initial_state, immutable=False)
 
-    # here, we get to stage 2 using the PathGroup's find() functionality. This
-    # executes until at least one path reaches the specified address, and can
+    # here, we get to stage 2 using the simulation manager's explore() functionality.
+    # This executes until at least one path reaches the specified address, and can
     # discard paths that hit certain other addresses.
-    print '[*] executing'
+    print('[*] executing')
     sm.explore(find=0x4016A3).unstash(from_stash='found', to_stash='active')
     sm.explore(find=0x4016B7, avoid=[0x4017D6, 0x401699, 0x40167D]).unstash(from_stash='found', to_stash='active')
     sm.explore(find=0x4017CF, avoid=[0x4017D6, 0x401699, 0x40167D]).unstash(from_stash='found', to_stash='active')
@@ -76,28 +74,27 @@ def hook_length(state):
     # for all 8 bytes pushes a lot of complexity to the SAT solver, and it chokes.
     # To avoid this, we're going to get the solutions to 2 bytes at a time, and
     # brute force the combinations.
-    possible_values = [ s.solver.eval_upto(s.memory.load(0x6C4B20 + i, 2), 65536, cast_to=str) for i in range(0, 8, 2) ]
+    possible_values = [ s.solver.eval_upto(s.memory.load(0x6C4B20 + i, 2), 65536, cast_to=bytes) for i in range(0, 8, 2) ]
     possibilities = tuple(itertools.product(*possible_values))
     return possibilities
 
 def bruteforce_possibilities(possibilities):
     # let's try those values!
-    print '[*] example guess: %r' % ''.join(possibilities[0])
-    print '[*] brute-forcing %d possibilities' % len(possibilities)
+    print('[*] example guess: %r' % b''.join(possibilities[0]))
+    print('[*] brute-forcing %d possibilities' % len(possibilities))
     for guess in progressbar.ProgressBar(widgets=[progressbar.Counter(), ' ', progressbar.Percentage(), ' ', progressbar.Bar(), ' ', progressbar.ETA()])(possibilities):
-        stdout,_ = subprocess.Popen(["./whitehat_crypto400", ''.join(guess)], stdout=subprocess.PIPE, stderr=subprocess.STDOUT).communicate()
-        if 'FLAG IS' in stdout:
-            return filter(lambda s: ''.join(guess) in s, stdout.split())[0]
+        guess_str = b''.join(guess)
+        stdout,_ = subprocess.Popen(["./whitehat_crypto400", guess_str], stdout=subprocess.PIPE, stderr=subprocess.STDOUT).communicate()
+        if b'FLAG IS' in stdout:
+            return next(filter(lambda s: guess_str in s, stdout.split()))
 
 def main():
     return bruteforce_possibilities(get_possible_flags())
 
 def test():
-    assert 'nytEaTBU' in [ ''.join(p) for p in get_possible_flags() ]
+    assert b'nytEaTBU' in [ b''.join(p) for p in get_possible_flags() ]
 
 if __name__ == '__main__':
     # set some debug messages so that we know what's going on
-    logging.basicConfig()
-    angr.manager.l.setLevel('DEBUG')
-
-    print main()
+    logging.getLogger('angr.sim_manager').setLevel('DEBUG')
+    print(main())
diff --git a/examples/whitehatvn2015_re400/solve.py b/examples/whitehatvn2015_re400/solve.py
index b6b6607..bf32239 100644
--- a/examples/whitehatvn2015_re400/solve.py
+++ b/examples/whitehatvn2015_re400/solve.py
@@ -15,7 +15,7 @@ def main():
     p.hook(0x402b5d, patch_0, length=0x402b91-0x402b5d)
 
     state = p.factory.blank_state(addr=0x401f30)
-    argv=['re400.exe', state.solver.BVS('arg1', 37 * 8)]
+    argv=[b're400.exe', state.solver.BVS('arg1', 37 * 8)]
 
 
     # Add previous conditions got from debugging the part of code that is patched out
@@ -36,10 +36,10 @@ def main():
     state.add_constraints(argv[1].get_byte(32) >= argv[1].get_byte(33))
     state.add_constraints(argv[1].get_byte(32) ^ argv[1].get_byte(33) == 0x1e)
 
-    for i in xrange(36):
+    for i in range(36):
         # We want those flags to be printable characters
         state.add_constraints(argv[1].get_byte(i) >= 0x20)
-        state.add_constraints(argv[1].get_byte(i) <= '}')
+        state.add_constraints(argv[1].get_byte(i) <= 0x7e)
     state.add_constraints(argv[1].get_byte(36) == 0)
 
     # Prepare the argc and argv
@@ -60,11 +60,11 @@ def main():
     )
     ex.run()
 
-    possible_flags = ex.found[0].solver.eval_upto(argv[1], 20)
+    possible_flags = ex.found[0].solver.eval_upto(argv[1], 20, cast_to=bytes)
     for i, f in enumerate(possible_flags):
-        print "Flag %d:" % i, hex(f)[2:-1].decode("hex")
+        print("Flag %d:" % i, f)
 
-    return [hex(f)[2:-1].decode("hex") for f in possible_flags]
+    return possible_flags
 
 
 def test():
@@ -73,10 +73,9 @@ def test():
     res = main()
     assert len(res) == 20
     for f in res:
-        f = f[:f.find("\x00")]
+        f = f[:f.find(b"\x00")]
         assert len(f) == 36
-        assert all([ord(c) >= 0x20 and ord(c) <= "}" for c in f])
+        assert all(20 <= c <= 0x7e for c in f)
 
 if __name__ == "__main__":
     main()
-
diff --git a/tests/test_apidoc.py b/tests/test_apidoc.py
index e0447fd..176caab 100644
--- a/tests/test_apidoc.py
+++ b/tests/test_apidoc.py
@@ -14,7 +14,7 @@ def test_api_coverage():
         module_list = subprocess.check_output(['find', '.', '-name', '*.py'], cwd=module_dir).split()
         api_list = [x.split()[-1] for x in open(docs_file).readlines() if 'automodule' in x]
         for partial in module_list:
-            full = module + '.' + partial[2:-3].replace('/', '.')
+            full = module + '.' + partial[2:-3].decode().replace('/', '.')
             if full.endswith('.__init__'):
                 full = full[:-9]
 
@@ -35,12 +35,11 @@ def test_lint_docstrings():
 
     # Filter the deprecation warning from the cryptography package
     if stderr:
-        stderr_lines = stderr.split("\n")
-        stderr = "\n".join([ l for l in stderr_lines if
-            'CryptographyDeprecationWarning' not in l and 'DeprecatedIn23' not in l ])
+        stderr_lines = stderr.split(b"\n")
+        stderr = b"\n".join(l for l in stderr_lines if b'MIPS instruction groups' not in l)
 
     if stderr:
-        raise Exception("The following warnings were generated while building the API documentation:\n\n" + stderr)
+        raise Exception("The following warnings were generated while building the API documentation:\n\n%s" % stderr.decode())
 
 if __name__ == '__main__':
     test_api_coverage()
diff --git a/tests/test_examples.py b/tests/test_examples.py
index 08d7b88..58cf1d9 100644
--- a/tests/test_examples.py
+++ b/tests/test_examples.py
@@ -1,6 +1,7 @@
 import os
 import sys
 import subprocess
+from importlib import reload
 
 from nose.plugins.attrib import attr
 from flaky import flaky
@@ -11,7 +12,7 @@ def _path(d):
 def exampletest_single(example_dir):
     init_pwd = os.getcwd()
     os.chdir(_path('examples/') + example_dir)
-    print os.getcwd()
+    print(os.getcwd())
     if '.' not in sys.path:
         sys.path.append('.')
     try:
@@ -87,12 +88,12 @@ def test_csgames2018(): exampletest_single('csgames2018')
 ## END EXAMPLE TESTS
 
 def test_example_inclusion():
-    to_test = subprocess.check_output(['/bin/bash', '-c', 'for c in $(find -name solve.py | cut -c 3-); do echo ${c%/solve.py}; done'], cwd=_path('examples'))
+    to_test = subprocess.check_output(['/bin/bash', '-c', 'for c in $(find -name solve.py | cut -c 3-); do echo ${c%/solve.py}; done'], cwd=_path('examples')).decode()
     if __file__.endswith('.pyc'):
         sourcefile = __file__[:-1]
     else:
         sourcefile = __file__
-    with open(sourcefile) as fp:
+    with open(sourcefile, 'r') as fp:
         test_source = fp.read()
     example_tests = test_source[test_source.find('## BEGIN EXAMPLE TESTS'):test_source.find('## END EXAMPLE TESTS')]
 
diff --git a/tests/test_gitbook.py b/tests/test_gitbook.py
index 0866207..1070104 100644
--- a/tests/test_gitbook.py
+++ b/tests/test_gitbook.py
@@ -5,19 +5,15 @@
 import itertools
 import claripy
 
+filepath = __file__
+
 def _path(d):
-    return os.path.join(os.path.dirname(__file__), '..', d)
+    return os.path.join(os.path.dirname(filepath), '..', d)
 
-md_files = filter(lambda s: s.endswith('.md'), [
-    os.path.join(_path('docs'), t) for t in os.listdir(_path('docs'))
-])
-md_files += filter(lambda s: s.endswith('.md'), [
-    os.path.join(_path('docs/analyses'), t) for t in os.listdir(_path('docs/analyses'))
-])
-md_files += filter(lambda s: s.endswith('.md'), [
-    os.path.join(_path('docs/courses'), t) for t in os.listdir(_path('docs/courses'))
-])
-example_dirs = filter(lambda s: '.' not in s, os.listdir(_path('examples')))
+md_files = []
+for _p in ('docs', 'docs/analyses', 'docs/courses'):
+    md_files += [os.path.join(_p, t) for t in os.listdir(_path(_p)) if t.endswith('.md')]
+example_dirs = [s for s in os.listdir(_path('examples')) if '.' not in s]
 
 sys.path.append('.')
 
@@ -34,9 +30,9 @@ def doctest_single(md_file):
 
         def try_running(line, i):
             try:
-                exec line in env
+                exec(line, env)
             except Exception as e:
-                print 'Error on line %d of %s: %s' % (i+1, md_file, e)
+                print('Error on line %d of %s: %s' % (i+1, md_file, e))
                 traceback.print_exc()
                 raise Exception('Error on line %d of %s: %s' % (i+1, md_file, e))
 
diff --git a/windows-install/README.md b/windows-install/README.md
deleted file mode 100644
index eecb3fa..0000000
--- a/windows-install/README.md
+++ /dev/null
@@ -1,18 +0,0 @@
-# Install angr on Windows
-
-## Requirements
-
-* The Visual C++ components from [Visual Studio
-  2015](https://www.visualstudio.com/downloads/)
-* [MVC++ Compiler for Python
-  2.7](https://www.microsoft.com/en-us/download/details.aspx?id=44266)
-* Python 2.7, and a properly configured `PATH` environment variable.
-* `g++`/`cpp` and `cmake` via [Cygwin](https://cygwin.com/install.html)
-
-## Instructions
-
-* Run `install_angr.bat` from a Visual Studio Developer Command Prompt.
-
-See [Installing angr in
-Windows](https://blog.spirotot.com/2016/11/05/installing-angr-in-windows/) for
-more help/details.
diff --git a/windows-install/install_angr.bat b/windows-install/install_angr.bat
deleted file mode 100644
index 1a5398a..0000000
--- a/windows-install/install_angr.bat
+++ /dev/null
@@ -1,27 +0,0 @@
-;@echo off
-
-powershell -Command "wget https://github.com/angr/archinfo/archive/master.zip -OutFile archinfo-master.zip"
-powershell -Command "wget https://github.com/angr/pyvex/archive/master.zip -OutFile pyvex-master.zip"
-powershell -Command "wget https://github.com/angr/angr/archive/master.zip -OutFile angr-master.zip"
-powershell -Command "Expand-Archive archinfo-master.zip ."
-powershell -Command "Expand-Archive pyvex-master.zip ."
-powershell -Command "Expand-Archive angr-master.zip ."
-
-pip install capstone-windows
-
-cd archinfo-master
-mv requirements.txt requirements.txt.bak
-powershell -Command "wget https://raw.githubusercontent.com/Spirotot/angr_windows_install/master/requirements/archinfo_requirements.txt -OutFile requirements.txt"
-python setup.py install
-
-cd ..\pyvex-master
-mv requirements.txt requirements.txt.bak
-powershell -Command "wget https://raw.githubusercontent.com/Spirotot/angr_windows_install/master/requirements/pyvex_requirements.txt -OutFile requirements.txt"
-python setup.py install
-python setup.py install
-
-cd ..\angr-master
-mv requirements.txt requirements.txt.bak
-powershell -Command "wget https://raw.githubusercontent.com/Spirotot/angr_windows_install/master/requirements/angr_requirements.txt -OutFile requirements.txt"
-pip install -r requirements.txt
-python setup.py install
diff --git a/windows-install/requirements/angr_requirements.txt b/windows-install/requirements/angr_requirements.txt
deleted file mode 100644
index 216f46d..0000000
--- a/windows-install/requirements/angr_requirements.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-cachetools
-networkx
-rpyc
-futures
-progressbar
-mulpyplexer
-cooldict
-ana
-archinfo
-pyvex
-claripy
-simuvex
-cle
diff --git a/windows-install/requirements/archinfo_requirements.txt b/windows-install/requirements/archinfo_requirements.txt
deleted file mode 100644
index 300f495..0000000
--- a/windows-install/requirements/archinfo_requirements.txt
+++ /dev/null
@@ -1 +0,0 @@
-pyelftools
diff --git a/windows-install/requirements/pyvex_requirements.txt b/windows-install/requirements/pyvex_requirements.txt
deleted file mode 100644
index 5e5711b..0000000
--- a/windows-install/requirements/pyvex_requirements.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-pycparser
-cffi>=1.0.3
-archinfo
