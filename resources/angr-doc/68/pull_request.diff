diff --git a/api-doc/MAINTENENCE.txt b/api-doc/MAINTENANCE.txt
similarity index 100%
rename from api-doc/MAINTENENCE.txt
rename to api-doc/MAINTENANCE.txt
diff --git a/docs/analyses/cfg_accurate.md b/docs/analyses/cfg_accurate.md
index ebf4a24..edb3456 100644
--- a/docs/analyses/cfg_accurate.md
+++ b/docs/analyses/cfg_accurate.md
@@ -146,15 +146,15 @@ The most common use case for this object is to access it like a dictionnary. It
 ```
 
 Functions have several important properties!
-- `entry_func.basic_blocks` is a set of addresses at which basic blocks belonging to the function begin.
+- `entry_func.block_addrs` is a set of addresses at which basic blocks belonging to the function begin.
+- `entry_func.blocks` is the set of basic blocks belonging to the function, that you can explore and disassemble using capstone.
 - `entry_func.string_references()` returns a list of all the constant strings that were referred to at any point in the function.
   They are formatted as `(addr, string)` tuples, where addr is the address in the binary's data section the string lives, and string is a python string that contains the value of the string.
 - `entry_func.returning` is a boolean value signifying whether or not the function can return.
   `False` indicates that all paths do not return.
 - `entry_func.callable` is an angr Callable object referring to this function.
   You can call it like a python function with python arguments and get back an actual result (may be symbolic) as if you ran the function with those arguments!
-- `entry_func.local_transition_graph` is a NetworkX DiGraph describing control flow within the function itself.
-  It resembles the control-flow graphs IDA displays on a per-function level.
+- `entry_func.transition_graph` is a NetworkX DiGraph describing control flow within the function itself. It resembles the control-flow graphs IDA displays on a per-function level.
 - `entry_func.name` is the name of the function.
 - `entry_func.has_unresolved_calls` and `entry.has_unresolved_jumps` have to do with detecting imprecision within the CFG.
   Sometimes, the analysis cannot detect what the possible target of an indirect call or jump could be.
@@ -163,3 +163,5 @@ Functions have several important properties!
 - `entry_func.get_call_target(callsite_addr)` will, given `callsite_addr` from the list of call site addresses, return where that callsite will call out to.
 - `entry_func.get_call_return(callsite_addr)` will, given `callsite_addr` from the list of call site addresses, return where that callsite should return to.
 
+and many more !
+
diff --git a/docs/claripy.md b/docs/claripy.md
index 3d1a37f..4379ac4 100644
--- a/docs/claripy.md
+++ b/docs/claripy.md
@@ -113,7 +113,7 @@ Some examples of frontend usage:
 >>> x = claripy.BVS('x', 8)
 
 # now let's add a constraint on x
->>> s.add(claripy.ULT(x, 5)) 
+>>> s.add(claripy.ULT(x, 5))
 
 >>> assert sorted(s.eval(x, 10)) == [0, 1, 2, 3, 4]
 >>> assert s.max(x) == 4
@@ -122,7 +122,7 @@ Some examples of frontend usage:
 # we can also get the values of complex expressions
 >>> y = claripy.BVV(65, 8)
 >>> z = claripy.If(x == 1, x, y)
->>> assert sorted(s.eval(z, 10)) == [1, 65] 
+>>> assert sorted(s.eval(z, 10)) == [1, 65]
 
 # and, of course, we can add constraints on complex expressions
 >>> s.add(z % 5 != 0)
@@ -153,7 +153,7 @@ All backends must also implement any functions of the base `Backend` abstract cl
 Claripy's contract with its backends is as follows: backends should be able to handle, in their private functions, any object that they return from their private *or* public functions.
 Claripy will never pass an object to any backend private function that did not originate as a return value from a private or public function of that backend.
 One exception to this is `convert()` and `_convert()`, as Claripy can try to stuff anything it feels like into _convert() to see if the backend can handle that type of object.
- 
+
 ### Model Objects
 
 To perform actual, useful computation on ASTs, Claripy uses model objects.
diff --git a/docs/pathgroups.md b/docs/pathgroups.md
index fa78a45..5fde037 100644
--- a/docs/pathgroups.md
+++ b/docs/pathgroups.md
@@ -3,17 +3,127 @@ Bulk Execution and Exploration - Path Groups
 
 Path groups are just a bunch of paths being executed at once. They are also the future.
 
+Path groups let you wrangle multiple paths in a slick way.
+Paths are organized into “stashes”, which you can step forward, filter, merge,
+and move around as you wish. There are different kind of stashes, which are
+specified in [Paths](./paths.md#path-types). This allows you to, for example,
+step two different stashes of paths at different rates, then merge them together.
+
+
+Here are some basic examples of pathgroups capabilities:
 ```python
-import angr
-p = angr.Project(whatever)
-pg = p.factory.path_group()
-while len(pg.active) == 1:
-    pg.step()
+>>> import angr
+
 
-print 'Symbolic execution branched at block %#x' % pg.active[0].addr_trace[-1]
-print 'Guard condition:', pg.active[0].actions[-1].condition
-for i, path in enumerate(pg.active):
-    print '- Child %d at %#x' % (i, path.addr)
+>>> p = angr.Project('/bin/ls', load_options={'auto_load_libs': False})
+>>> pg = p.factory.path_group()
 ```
 
-HUGE TODO!
+Exploring a path:
+```python
+# While there are active path, we step
+>>> while len(pg.active) > 0:
+...    pg.step()
+
+>>> print(pg)
+<PathGroup with 1 deadended>
+```
+
+We now have a deadended path, let's see what we can do with it
+```python
+>>> path = pg.deadended[0]
+>>> print('Path length: {0} steps'.format(path.length))
+Path length: 23 steps
+```
+
+Get path trace:
+```python
+>>> print('Trace:')
+>>> for step in path.trace:
+...    print(step)
+Trace:
+<SimIRSB 0x4049a0>
+<SimIRSB 0x402650>
+<SimProcedure __libc_start_main>
+<SimIRSB 0x413930>
+<SimIRSB 0x4022d0>
+<SimIRSB 0x4022e5>
+<SimIRSB 0x413961>
+<SimIRSB 0x413966>
+<SimIRSB 0x404a70>
+<SimIRSB 0x404a7b>
+<SimIRSB 0x404a10>
+<SimIRSB 0x404a48>
+<SimIRSB 0x41397d>
+<SimIRSB 0x413986>
+<SimProcedure __libc_start_main>
+<SimIRSB 0x402a00>
+<SimIRSB 0x40da70>
+<SimIRSB 0x40dae3>
+<SimIRSB 0x402950>
+<SimProcedure fwrite>
+<SimIRSB 0x40dafe>
+<SimIRSB 0x402390>
+<SimProcedure abort>
+```
+
+Get constraints applied to the path:
+```python
+>>> print('Constraints:')
+>>> for c in path.state.se.constraints:
+...    print(c)
+Constraints:
+<Bool mem_70_7_32 == 0x0>
+```
+
+Get memory state at the end of the traversal:
+```python
+>>> print('rax: {0}'.format(path.state.regs.rax))
+rax: <BV64 0x37>
+>>> assert path.state.regs.rip.args[0] == path.addr  # regs are BitVectors
+```
+
+### PathGroup.Explorer()
+Pathgroups are supposed to replace `surveyors.Explorer`, being more clever and
+efficient. When launching path_group.Explore with a `find` argument, multiple
+paths will be launched and step until one of them finds one of the address we
+are looking for. Paths reaching the `avoid`ed addresses, if any, will be put
+into the `avoided` stash. If an active path reaches an interesting address, it
+will be stashed into the `found` stash, and the other ones will remain active.
+You can then explore the found path, or decide to discard it and continue with
+the other ones.
+
+Example from a DefconCTF Quals [exercise](./examples.md#reverseme-example-defcon-quals-2016---baby-re):
+
+```python
+>>> p = angr.Project('examples/defcon2016quals_baby-re_1/baby-re')
+```
+
+Setting the environment (state)
+```python
+>>> main = 0x4025e7 # Beginning of function we want to explore
+>>> win = 0x4028e9  # Address we want to reach
+>>> fail = 0x402941 # Address we want to avoid
+>>> flag_addr = 0x7fffffffffeff98
+[...]
+>>> init = p.factory.blank_state(addr=main)
+```
+
+Creating and lauching the explorer
+```python
+>>> pgp = p.factory.path_group(init)
+>>> ex = pgp.explore(find=win, avoid=fail)
+>>> print(ex)
+<PathGroup with 11 avoid, 2 active, 1 found>
+>>> s = ex.found[0].state
+>>> flag = s.se.any_str(s.memory.load(flag_addr, 50))
+>>> print(flag)
+Math is hard!
+```
+
+Pretty simple, isn't it ?
+
+Other examples can be found by browsing the [examples](./examples.md).
+
+
+## TODO: STASHES
diff --git a/docs/paths.md b/docs/paths.md
index 05ee08e..60d7910 100644
--- a/docs/paths.md
+++ b/docs/paths.md
@@ -36,6 +36,19 @@ Backtrace:
 Func 0x401410, sp=0x7fffffffffeffd8, ret=0x0
 ```
 
+## Path types
+| Path type     | Description |
+|---------------|-------------|
+| Deadended     | A path goes to deadended when it cannot continue the execution for some reason, including no more valid instructions, unsat state, or an invalid instruction pointer. |
+| Found         | A path goes to found when the execution reaches a basic block which begins at the address specified with the find argument. |
+| Pruned        | TODO |
+| Active        | TODO |
+| Errored       | TODO |
+| Unconstrained | TODO |
+| Unsat         | TODO |
+
+
+
 ## Moving Forward
 
 Of course, we can't be stuck at the entry point forever. call `p.step()` to run the single block of symbolic execution.
diff --git a/docs/simuvex.md b/docs/simuvex.md
index e6c8b3a..c736a25 100644
--- a/docs/simuvex.md
+++ b/docs/simuvex.md
@@ -27,7 +27,7 @@ To create a SimIRSB directly, use the `sim_block(state)` constructor in the proj
 # This creates a symbolic state with execution starting at 0x400664,
 # and then symbolically executes the IRSB at its instruction pointer.
 >>> import angr, simuvex
->>> b = angr.Project('/home/angr/angr/binaries/tests/x86_64/fauxware')
+>>> b = angr.Project('examples/fauxware/fauxware')
 >>> state = b.factory.blank_state(addr=0x400664)
 >>> sirsb = b.factory.sim_block(state)
 
diff --git a/docs/structured_data.md b/docs/structured_data.md
index 70662a5..d48334b 100644
--- a/docs/structured_data.md
+++ b/docs/structured_data.md
@@ -70,7 +70,7 @@ This allows you to specify the type of the data you're looking at.
 
 ```python
 >>> import angr
->>> b = angr.Project('/home/angr/angr/binaries/tests/x86_64/fauxware')
+>>> b = angr.Project('examples/fauxware/fauxware')
 >>> s = b.factory.entry_state()
 >>> s.mem[0x601048]
 <<untyped> <unresolvable> at 0x601048>
@@ -158,7 +158,7 @@ All the interaction with the state happens with the aid of a `SimCC`, to tell wh
 By default, it uses a sane default for the archetecture, but if you'd like to customize it, you can pass a `SimCC` object in the `cc` keyword argument when constructing the callable.
 
 You can pass symbolic data as function arguments, and everything will work fine.
-You can even pass more complicated data, like strings, lists, and structures as native python data (use tuples for structures), and it'll be serialized as cleanly as possible into the state.  
+You can even pass more complicated data, like strings, lists, and structures as native python data (use tuples for structures), and it'll be serialized as cleanly as possible into the state.
 If you'd like to specify a pointer to a certain value, you can wrap it in a `PointerWrapper` object, available as `b.factory.callable.PointerWrapper`.
 The exact semantics of how pointer-wrapping work are a little confusing, but they can be boiled down to "unless you specify it with a PointerWrapper or a specific SimArrayType, nothing will be wrapped in a pointer automatically unless it gets to the end and it hasn't yet been wrapped in a pointer yet and the original type is a string, array, or tuple."
 The relevant code is actually in SimCC - it's the `setup_callsite` function.
diff --git a/docs/surveyors.md b/docs/surveyors.md
index ea27b76..6afd02b 100644
--- a/docs/surveyors.md
+++ b/docs/surveyors.md
@@ -4,7 +4,7 @@ At heart, angr is a symbolic execution engine.
 angr exposes a standard way to write and perform dynamic symbolic execution: the `Surveyor` class.
 A `Surveyor` is the *engine* that drives symbolic execution: it tracks what paths are active, identifies which paths to step forward and which paths to prune, and optimizes resource allocation.
 
-`Surveyors` are an old API that is rather unweildy. It's recommended to use `PathGroups` instead.
+/!\ `Surveyors` are an old API that is rather unweildy. It's recommended to use [PathGroups](./pathgroups.md) instead. /!\
 
 The `Surveyor` class is not meant to be used directly.
 Rather, it should be subclassed by developers to implement their own analyses.
@@ -21,7 +21,7 @@ You have to see it for yourself:
 
 ```python
 >>> import angr
->>> b = angr.Project("/home/angr/angr/binaries/tests/x86_64/fauxware")
+>>> b = angr.Project('examples/fauxware/fauxware')
 
 # By default, a Surveyor starts at the entry point of the program, with
 # an exit created by calling `Project.initial_exit` with default arguments.
@@ -86,7 +86,7 @@ It can be used as so:
 
 ```python
 # load fauxware
->>> b = angr.Project("/home/angr/angr/binaries/tests/x86_64/fauxware")
+>>> b = angr.Project('examples/fauxware/fauxware')
 
 # get the state ready, and grab our username and password symbolic expressions for later
 # checking. Here, we'll cheat a bit since we know that username and password should both
diff --git a/docs/symbolic.md b/docs/symbolic.md
index c72301c..88677ba 100644
--- a/docs/symbolic.md
+++ b/docs/symbolic.md
@@ -1,7 +1,11 @@
 Symbolic Execution
 ==================
 
-TODO: would someone write an intro to the concept of symbolic execution, maybe just copy paste it from some paper
+Symbolic execution allows at a time T to determine for a branch all conditions
+necessary to take the branch or not. Every varaible is represented as a symbolic
+value, and each branch as a constraint. Thus, symbolic execution allows us to
+see which conditions allows the program to go from a point A to a point B, by
+resolving the constraints.
 
 Basic archetecture of angr's symbolic execution:
 
