diff --git a/examples/ekopartyctf2016_sokohashv2/README b/examples/ekopartyctf2016_sokohashv2/README
new file mode 100644
index 0000000..397828c
--- /dev/null
+++ b/examples/ekopartyctf2016_sokohashv2/README
@@ -0,0 +1,3 @@
+This repo contains solutions for the sokohash challenge.
+One solution was developed by me and the other solution was developed and documented by facuman (http://immunityservices.blogspot.com.ar/2016/11/solving-sokohashv20-full-of-angr-on.html)
+
diff --git a/examples/ekopartyctf2016_sokohashv2/matrix.bin b/examples/ekopartyctf2016_sokohashv2/matrix.bin
new file mode 100755
index 0000000..0cef6ae
Binary files /dev/null and b/examples/ekopartyctf2016_sokohashv2/matrix.bin differ
diff --git a/examples/ekopartyctf2016_sokohashv2/sokohashv2.0.exe b/examples/ekopartyctf2016_sokohashv2/sokohashv2.0.exe
new file mode 100755
index 0000000..61b5e96
Binary files /dev/null and b/examples/ekopartyctf2016_sokohashv2/sokohashv2.0.exe differ
diff --git a/examples/ekopartyctf2016_sokohashv2/sokosolver.py b/examples/ekopartyctf2016_sokohashv2/sokosolver.py
new file mode 100644
index 0000000..2f19b1b
--- /dev/null
+++ b/examples/ekopartyctf2016_sokohashv2/sokosolver.py
@@ -0,0 +1,205 @@
+import logging
+import struct
+import simuvex
+import logging
+import angr
+
+
+########################################
+# helper functions for debugging
+#######################################
+def to_asmstring(state, addr, length):
+    global p
+    project = p
+    try:
+        conc = state.se.any_int
+        addr =  conc(addr)
+        code = "".join(project.loader.memory.read_bytes(addr,length))
+        md = project.arch.capstone
+        inst = "; ".join(["%s %s" %(i.mnemonic, i.op_str) for i in md.disasm(code,addr)])
+        return "%x: %s" %(addr, inst.split(";")[0])
+    except TypeError:
+        # pypy seems to throw a TypeError in Capstone :(
+        return ""
+
+
+def debug_func(state):
+    print to_asmstring(state, state.regs.eip, 10)
+
+    addr = state.se.any_int(state.regs.eip) 
+    print hex(addr)
+
+#######################################
+
+#WIN_HASH = "D5C0E6E33E3C16853457C96C11C626F3628E95480000160ABFE0AA76C108E671".decode("hex")
+
+#WIN_HASH = "BF3666668F5581A7EC65F192388BD64D4CC3B3610000275DAC894722C10986F6".decode("hex")
+
+WIN_HASH = "C03922D0206DC3A33016010D6C66936E953ABAB9000010AE805CE8463CBE9A2D".decode("hex")
+
+def get_hash_map(init_addr):
+    """
+		This function will return the winnig hash but in the expected shape to win. it means
+        the expected hash must be like the following table.
+
+	for instance:
+		c0d5000000000000
+		e3e6000000000000
+		:
+		:
+	"""
+    addr = init_addr
+    hash_map = []
+    for i in xrange(0, len(WIN_HASH), 2):
+        pair = WIN_HASH[i:i+2]
+        hash_map.append((addr, ord(pair[1])))
+        hash_map.append((addr+1, ord(pair[0])))
+        addr += 8    
+
+    return hash_map
+    
+logging.getLogger('angr').setLevel(logging.DEBUG)
+logging.getLogger('angr.path_group').setLevel(logging.DEBUG)
+
+def hook_printf(state):
+    pass 
+
+def hook_security_check_cookie(state):
+    pass
+
+def get_table(state):
+	#this function will return the table of numbers used in the board
+	base_addr_table = 0x41D450
+	current_addr = base_addr_table
+	end_addr = 0x0041E0D0
+
+	t = []
+	conc = state.se.any_int
+	while current_addr < end_addr:
+		n = conc(state.memory.load(current_addr, 8))
+		pn = struct.unpack(">Q", struct.pack("<Q", n))[0]
+		t.append(pn)
+		current_addr += 8
+	
+	return t	
+
+
+###############################################
+#step 0:
+#   initializing state. In this step we crate the exe sym emulation
+#   hook functions embedded in the binary (not OS call)
+##############################################
+load_options={}
+p = angr.Project("sokohashv2.0.exe")
+
+p.hook(0x0040103E, hook_printf,length=5)
+p.hook(0x00401225, hook_printf,length=5)
+p.hook(0x00401243, hook_printf,length=5)
+p.hook(0x00401253, hook_security_check_cookie,length=5)
+
+print "Initiating state"
+
+#we are not starting from 401000 because it is not working properly.
+#probably due to we are calling the function directly (it's mean creating an
+#blank_state and setting addr manually
+initial_state = p.factory.blank_state(addr=0x401003)
+start = initial_state.regs.ebp
+################################################
+
+
+###############################################
+#step 1:
+#    this step is to identify what are we controling, and set restrictions for these, controlled, mem areas
+#    In this case, the restrictions are asociated to values of the sokohash table.
+#    (the parameters must be included in the sokohash universe numbers)
+##############################################
+print "Setting params restrictions (precontions)"
+#first of all we will set the restrictions for out parameters in the initial
+#state. to set that, we will load the addresses (this load will return a
+#symbolic memory (another alternative can be use BVS and memory.store these bit
+#vectors 
+
+r1 = initial_state.memory.load(start+0x08, 8, endness=p.arch.memory_endness)
+r2 = initial_state.memory.load(start+0x10, 8, endness=p.arch.memory_endness)
+r3 = initial_state.memory.load(start+0x18, 8, endness=p.arch.memory_endness)
+r4 = initial_state.memory.load(start+0x20, 8, endness=p.arch.memory_endness)
+    
+list_cons_v1 = []
+list_cons_v2 = []
+list_cons_v3 = []
+list_cons_v4 = []
+for i in get_table(initial_state):
+	list_cons_v1.append(r1==i)
+	list_cons_v2.append(r2==i)
+	list_cons_v3.append(r3==i)
+	list_cons_v4.append(r4==i)
+	
+or_v1 = initial_state.se.Or(*list_cons_v1)
+or_v2 = initial_state.se.Or(*list_cons_v2)
+or_v3 = initial_state.se.Or(*list_cons_v3)
+or_v4 = initial_state.se.Or(*list_cons_v4)
+
+
+initial_state.add_constraints(initial_state.se.And(or_v1,or_v2,or_v3,or_v4))
+##############################################
+
+#for debugging only
+#initial_state.inspect.b('instruction', when=simuvex.BP_BEFORE, action=debug_func)
+
+# Explore the paths until after the hash is computed
+#path = p.factory.path(initial_state)
+
+#FIND=0x00402CCB
+#ex = p.surveyors.Explorer(start=path, find=FIND)
+#ex.run()
+
+#we will run until the end. We are using path_group becouse the angr-doc
+#recommends use it instead of p.surveyors. (aparently, it is the feature)
+
+#############################################
+#step 2:
+#	simbolic execute until the expected address is reach. This step will generate
+#	the model to ask about values.
+
+##############################################
+FIND=0x40123E
+#run sym execute
+pg = p.factory.path_group(initial_state, threads=8)
+pg.explore(find=FIND)
+
+#now we will get the supposed final state (the state after the symbolic execution)
+found_s = pg.found[0].state
+
+conds=[]
+
+conc = initial_state.se.any_int #this is used to concrete an symbolic value
+
+for addr, value in get_hash_map(0x04216C0):
+    memory = found_s.memory.load(addr, 1, endness=p.arch.memory_endness)
+    print "Addr: %x --> %s" % (addr, hex(value))
+    conds.append((memory == value))
+
+found_s.add_constraints(found_s.se.And(*conds))
+##############################################
+
+
+
+##############################################
+#step 3:
+#	This step is used to ask the model differents thinks. In this case
+#	we will ask about the values in the init state (r1, r2, r3, r4), and the 
+#	model will returns the values expected to reath the model in found_s state
+
+import binascii
+solution1 = found_s.se.any_int(r1)
+print "x: ", hex(solution1)
+
+solution2 = found_s.se.any_int(r2)
+print "y: ", hex(solution2)
+
+solution3 = found_s.se.any_int(r3)
+print "z:", hex(solution3)
+
+solution4 = found_s.se.any_int(r4)
+print "w:", hex(solution4)
+##############################################
diff --git a/examples/ekopartyctf2016_sokohashv2/sokosolver_facuman.py b/examples/ekopartyctf2016_sokohashv2/sokosolver_facuman.py
new file mode 100644
index 0000000..24221b8
--- /dev/null
+++ b/examples/ekopartyctf2016_sokohashv2/sokosolver_facuman.py
@@ -0,0 +1,185 @@
+import angr
+import sys
+import struct
+from itertools import combinations, product
+
+WIN_HASH = "C03922D0206DC3A33016010D6C66936E953ABAB9000010AE805CE8463CBE9A2D".decode("hex")
+
+
+def get_valid_coords():
+    var = """#                            #
+#            O               #
+#         x                  #
+#                   w        #
+#           *                #
+# ##    ####   ######   ###  #
+##  #  ##  ##  ##  ##  ##    #
+##     ##  ##  ##  ##  ##    #
+##     ##  ##  #####   ####  #
+##     ##  ##  ## ##   ##    #
+##  #  ##  ##  ##  ##  ##    #
+# ##    ####   ##  ##   ###  #
+#                            #
+#                            #
+#                      yz    #
+#                     O      #
+/                            #
+#                            #
+"""
+
+    valid = []
+    invalid = (list(product(range(7,12),[9,10])) +
+               list(product([7,8],[17,18])) )
+
+    x = 1
+    for line in var.splitlines():
+        line = line.strip()
+        line = line[1:len(line)-1]
+        y = 1
+        for i in line:
+            if i not in ["O", "#", "/"]:
+                if (x,y) not in invalid:
+                    valid.append((x,y))
+            y += 1
+        x += 1   
+
+    return valid
+
+def do_memset(state):
+    addr = 0x417490
+    with open("matrix.bin","rb") as f:
+        content = f.read()
+        for i in content:            
+            state.memory.store(addr, state.se.BVV(ord(i), 8 * 1))
+            addr += 1
+
+    start_off = 0x41d450 - addr
+    end_off = 0x41e0c8 - addr
+    coords = []
+    for i in xrange(start_off, end_off+8, 8):        
+        coords.append(struct.unpack("<Q", content[i:i+8])[0])
+
+    return coords
+
+def do_repmovsd(state):
+    # angr does not like rep movsd
+    # we do it by hand
+    buffer = state.memory.load(state.regs.esi, 8 * 4)
+    state.memory.store(state.regs.edi, buffer)
+
+def do_nothing(state):
+    pass
+
+def get_hash_map(init_addr):
+    addr = init_addr
+    hash_map = []
+    for i in xrange(0, len(WIN_HASH), 2):
+        pair = WIN_HASH[i:i+2]
+        hash_map.append((addr, ord(pair[1])))
+        hash_map.append((addr+1, ord(pair[0])))
+        addr += 8    
+
+    return hash_map
+
+
+def main():
+    proj = angr.Project('sokohashv2.0.exe', use_sim_procedures=True, load_options={"auto_load_libs": False})
+
+    # addrs 
+    main = 0x401013
+    to_find = 0x0040123E
+    hash_addr = 0x04216C0
+
+    # hooks
+    func_hooks = [0x0040102C, 0x0401033]
+    for addr in func_hooks:
+        proj.hook(addr, do_nothing, length=6) 
+
+    func_hooks = [0x401215, 0x40121E, 0x401239, 0x40123C]
+    for addr in func_hooks:
+        proj.hook(addr, do_nothing, length=2) 
+
+    proj.hook(0x0401028, do_repmovsd, length=2)
+    proj.hook(0x0401253, do_nothing, length=5) 
+    proj.hook(0x040103E, do_nothing, length=5) 
+    proj.hook(0x0401225, do_nothing, length=5) 
+    proj.hook(0x0401243, do_nothing, length=5) 
+
+    # initial state
+    init = proj.factory.blank_state(addr=main)
+    
+    coords = do_memset(init)
+    coord_dict = {}
+    count = 0
+    for i in get_valid_coords():
+        #print "%s = %.16x" % (i, pos[count])
+        coord_dict[coords[count]] = i
+        count += 1
+
+    init.regs.ebp = init.regs.esp + 0x78
+
+    # search only for possible coords
+    variables = []
+    for i in xrange(0, 4):
+        var = init.memory.load(init.regs.ebp + 0x8 + (0x8*i), 0x8, endness=proj.arch.memory_endness) 
+        variables.append(var)
+        conds = []
+        for p in coords:
+            conds.append(p == var)
+        init.add_constraints(init.se.Or(*conds))
+
+    # each coordinate must be distinct
+    for v1,v2 in combinations(variables, 2):
+        init.add_constraints(v1 != v2)
+
+    buffer = init.memory.load(init.regs.ebp + 0x8, 0x20)
+        
+    pg = proj.factory.path_group(init, threads=8, save_unconstrained=True)
+    pg.explore(find=to_find)
+
+    path = pg.found[0]
+
+    found = path.state
+
+    # Resulting hash must be winning hash
+    # Print expected hash and resulting hash for verification
+    conds = []
+    expected = []
+    hash_map = get_hash_map(hash_addr)
+    for addr, value in hash_map:       
+        memory = found.memory.load(addr, 1, endness=proj.arch.memory_endness) 
+        conds.append((memory == value))
+        expected.append((hex(addr), hex(value)))
+    print "Expected is '%s'\n\n" % expected
+
+    found.add_constraints(init.se.And(*conds))
+
+    result = []
+    hash_map = get_hash_map(hash_addr)
+    for addr, value in hash_map:       
+        buf_ptr = found.memory.load(addr, 1)
+        possible = found.se.any_int(buf_ptr)
+        result.append((hex(addr), "0x%x" % possible))
+    print "Result is '%s'\n\n" % result
+
+
+    # Print solutions
+    possible = found.se.any_n_int(buffer, 1)
+    for i, f in enumerate(possible):
+        out = "%x" % f
+        if len(out) < (0x20*2):
+            continue
+
+        names = ["x","y","z","w"]
+        values = []
+        for j in xrange(0, len(out), 16):
+            value = out[j:j+16]
+            unpk_value = struct.unpack("<Q", value.decode("hex"))[0]
+
+            values.append((names[j//16], coord_dict[unpk_value]))
+        print "\tSolution %d: %s" % (i, values)
+
+
+if __name__ == '__main__':
+    #angr.path_group.l.setLevel('DEBUG')
+    main()
diff --git a/examples/ekopartyctf2016_sokohashv2/solve.py b/examples/ekopartyctf2016_sokohashv2/solve.py
new file mode 100644
index 0000000..d1c7173
--- /dev/null
+++ b/examples/ekopartyctf2016_sokohashv2/solve.py
@@ -0,0 +1,14 @@
+import sys
+import subprocess
+
+def test():
+    print >>sys.stderr, "Checking sokosolver.py solution..."
+    out = subprocess.check_output([ sys.executable, "sokosolver_facuman.py" ])
+    assert "[('x', (7, 22)), ('y', (18, 13)), ('z', (2, 5)), ('w', (4, 1))]" in out
+
+    print >>sys.stderr, "Checking sokosolver_facuman.py solution..."
+    out = subprocess.check_output([ sys.executable, "sokosolver.py" ])
+    assert "x:  0xf5b57de9c00229bdL\ny:  0x24b17a4c0132a01L\nz: 0x17c2b7a986200088L\nw: 0x32b0dffbfc485d1eL" in out
+
+if __name__ == '__main__':
+    test()
diff --git a/test.py b/test.py
index d513ed2..f7168aa 100644
--- a/test.py
+++ b/test.py
@@ -87,6 +87,7 @@ def test_defcamp_r100(): exampletest_single('defcamp_r100')
 #def test_defcamp_r200(): exampletest_single('defcamp_r200')
 def test_ekopartyctf2015_rev100(): exampletest_single('ekopartyctf2015_rev100')
 def test_ekopartyctf2016_rev250(): exampletest_single('ekopartyctf2016_rev250')
+def test_ekopartyctf2016_sokohashv2(): exampletest_single('ekopartyctf2016_sokohashv2')
 def test_fauxware(): exampletest_single('fauxware')
 def test_flareon2015_10(): exampletest_single('flareon2015_10')
 def test_flareon2015_2(): exampletest_single('flareon2015_2')
