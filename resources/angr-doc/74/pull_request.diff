diff --git a/README.md b/README.md
index 2757376..183ff2a 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 # How to be angry
 
-This is a collection of documentation for angr. 
+This is a collection of documentation for angr.
 By reading this, you'll become an angr pro and will be able to fold binaries to your whim.
 
 We've tried to make using angr as pain-free as possible - our goal is to create a user-friendly binary analysis suite, allowing a user to simply start up iPython and easily perform intensive binary analyses with a couple of commands.
@@ -49,3 +49,11 @@ To get help with angr, you can ask via:
 - the mailing list: angr@lists.cs.ucsb.edu
 - the IRC channel: **#angr** on [freenode](https://freenode.net/)
 - opening an issue on the appropriate github repository
+
+## Going further:
+
+You can read this [paper][paper], explaining some of the internals, algorithms,
+and used techniques to get a better understanding on what's going on under the
+hood.
+
+[paper]: https://www.cs.ucsb.edu/~vigna/publications/2016_SP_angrSoK.pdf
diff --git a/docs/analyses.md b/docs/analyses.md
index 89d5a17..256892a 100644
--- a/docs/analyses.md
+++ b/docs/analyses.md
@@ -13,7 +13,7 @@ angr comes with several built-in analyses:
 | [CFGAccurate](analyses/cfg_accurate.md)     | Constructs an accurate *Control Flow Graph* of the program. The simple way to do is via `b.analyses.CFGAccurate()`.                       |
 | VFG                                         | Performs VSA on every function of the program, creating a *Value Flow Graph* and detecting stack variables.                               |
 | DDG                                         | Calculates a data dependency graph, allowing one to determine what statements a given value depends on.                                   |
-| [DFG](../analyses/dfg.md)                      | Constructs a *Data Flow Graph* for each basic block present in the CFG                                                                    |
+| [DFG](analyses/dfg.md)                      | Constructs a *Data Flow Graph* for each basic block present in the CFG                                                                    |
 | [BackwardSlice](analyses/backward_slice.md) | Computes a backward slice of a program w.r.t. a certain target.                                                                           |
 | More!                                       | angr has quite a few analyses, most of which work! If you'd like to know how to use one, please submit an issue requesting documentation. |
 
diff --git a/analyses/dfg.md b/docs/analyses/dfg.md
similarity index 100%
rename from analyses/dfg.md
rename to docs/analyses/dfg.md
diff --git a/docs/claripy.md b/docs/claripy.md
index 4c1ae4e..04e67b6 100644
--- a/docs/claripy.md
+++ b/docs/claripy.md
@@ -13,7 +13,7 @@ However, for dealing with expressions, an understanding of Claripy might be usef
 ## Claripy ASTs
 
 Claripy ASTs abstract away the differences between the constructs that Claripy supports.
-They define a tree of operations (i.e., `(a+b)/c`) on any type of underlying data.
+They define a tree of operations (i.e., `(a + b) / c)` on any type of underlying data.
 Claripy handles the application of these operations on the underlying objects themselves by dispatching requests to the backends.
 
 Currently, Claripy supports the following types of ASTs:
@@ -106,9 +106,9 @@ There are several different frontends.
 |------|-------------|
 | FullFrontend | This is analogous to a `z3.Solver()`. It is a frontend that tracks constraints on symbolic variables and uses a constraint solver (currently, Z3) to evaluate symbolic expressions. |
 | LightFrontend | This frontend uses VSA to reason about values. It is an *approximating* frontend, but produces values without performing constraint solves. |
-| HybridFrontend | This frontend combines VSA and Z3 to allow for *approximating* values. You can specify whether or not you want an exact result from your evaluations, and this frontend does the rest. |
+| ReplacementFrontend | This frontend expands the LightFrontend by allowing the replacement of expressions on-the-fly. It is used as a helper by other frontends and can be used directly to implement exotic analyses. |
+| HybridFrontend | This frontend combines the ReplacementFrontend and the FullFrontend (VSA and Z3) to allow for *approximating* values. You can specify whether or not you want an exact result from your evaluations, and this frontend does the rest. |
 | CompositeFrontend | This frontend implements optimizations that solve smaller sets of constraints to speed up constraint solving. |
-| ReplacementFrontend | This frontend allows the replacement of expressions on-the-fly. It is used as a helper by other frontends and can be used directly to implement exotic analyses. |
 
 Some examples of frontend usage:
 
diff --git a/docs/courses/src/step0.bin b/docs/courses/src/step0.bin
new file mode 100755
index 0000000..e5da279
Binary files /dev/null and b/docs/courses/src/step0.bin differ
diff --git a/docs/courses/src/step0.c b/docs/courses/src/step0.c
new file mode 100644
index 0000000..00cb30d
--- /dev/null
+++ b/docs/courses/src/step0.c
@@ -0,0 +1,18 @@
+int main(int argc, char **argv)
+{
+
+    argc -= 1;
+
+    if (argc == 0)
+            return 0;
+    else
+    {
+            switch (argc)
+            {
+                    case 1:
+                            return 1;
+                    default:
+                            return 2;
+            }
+    }
+}
diff --git a/docs/courses/step0-basic_symbol_execution.md b/docs/courses/step0-basic_symbol_execution.md
new file mode 100644
index 0000000..a35eeb7
--- /dev/null
+++ b/docs/courses/step0-basic_symbol_execution.md
@@ -0,0 +1,78 @@
+# angr courses - Step 0 - Basic symbolic execution
+
+The first thing you are going to do with angr is executing symbolicaly your
+program. As a reminder, you can check what symbolic execution is [here](symbolic.md).
+
+The binary and source code for this course can be found [here](./src/).
+
+```python
+import angr
+
+# We load the binary in angr
+project = angr.Project('src/step0.bin')
+
+# Let's make things more readable
+addr_main = 0x4004a6
+first_jmp = 0x4004b9
+endpoint = 0x4004d6
+first_branch_left = 0x4004bb
+first_branch_right = 0x4004c2
+second_branch_left = 0x4004ca
+second_branch_right = 0x4004d1
+
+
+# We create a state so that angr starts at the beginning of the main function
+main_state = project.factory.blank_state(addr=addr_main)
+pg = project.factory.path_group(main_state)
+assert pg.active[0].addr == addr_main
+
+
+# Our path group hasn't done anything yet, so it only has one active path
+# which address is main
+# Let's step
+# The pathgroup.step functions accepts different arguments to regulate
+# the stepping. Here, let's try to step until we reach the first comparison
+pg.step(until=lambda p: p.active[0].addr >= first_jmp)
+
+
+# We know have two active paths. Each of them took a branch from the
+# comparison and will progress independently from the other one
+print(pg)
+for i, p in enumerate(pg.active):
+    print("Active path {0}: {1}".format(i, hex(p.addr)))
+assert len(pg.active) == 2
+assert pg.active[0].addr == first_branch_left
+assert pg.active[1].addr == first_branch_right
+
+
+# If we make the first path step, it will continue until reaching the endpoint
+# The other one, however, will reach another comparison and should
+# split again
+pg.step()
+print(pg)
+for i, p in enumerate(pg.active):
+    print("Active path {0}: {1}".format(i, hex(p.addr)))
+assert len(pg.active) == 3
+assert pg.active[0].addr == endpoint
+assert pg.active[1].addr == second_branch_left
+assert pg.active[2].addr == second_branch_right
+
+
+# Good We know have three paths
+# - The two first paths reached the endpoint, and thus became deadended
+# - The other one will have the same history thus stop stepping at the endpoint
+pg.step()
+print(pg)
+for i, p in enumerate(pg.active):
+    print("Active path {0}: {1}".format(i, hex(p.addr)))
+assert len(pg.active) == 1
+assert len(pg.deadended) == 2
+assert pg.active[0].addr == endpoint
+
+
+# The same effect can be done by using pathgroup.explore()
+# The explorer will step every path until no more paths are active
+pg = project.factory.path_group(main_state)
+pg.explore()
+assert len(pg.active) == 0
+```
diff --git a/docs/examples.md b/docs/examples.md
index b018769..c2f8603 100644
--- a/docs/examples.md
+++ b/docs/examples.md
@@ -15,15 +15,19 @@ Binary, source, and script are found [here.](https://github.com/angr/angr-doc/tr
 
 ### ReverseMe example: DEFCON Quals 2016 - baby-re
 
-Script 0 author: David Manouchehri (github: [@Manouchehri](https://github.com/Manouchehri))
+- Script 0
+
+    author: David Manouchehri (github: [@Manouchehri](https://github.com/Manouchehri))
+
+    Script runtime: 8 minutes
 
-Script runtime: 8 minutes
+- Script 1
 
-Script 1 author: Stanislas Lejay (github: [@P1kachu](https://github.com/P1kachu))
+    author: Stanislas Lejay (github: [@P1kachu](https://github.com/P1kachu))
 
-Script runtime: 11 sec
+    Script runtime: 11 sec
 
-Here is the [binary](https://github.com/angr/angr-doc/tree/master/examples/defcon2016quals_baby-re/baby-re) and the scripts:
+Here is the [binary](https://github.com/angr/angr-doc/blob/master/examples/defcon2016quals_baby-re_1/baby-re) and the scripts:
 * [script0](https://github.com/angr/angr-doc/tree/master/examples/defcon2016quals_baby-re_0/solve.py)
 * [script1](https://github.com/angr/angr-doc/tree/master/examples/defcon2016quals_baby-re_1/solve.py)
 
