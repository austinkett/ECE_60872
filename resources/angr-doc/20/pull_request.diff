diff --git a/examples.md b/examples.md
index 154cc03..7be0999 100644
--- a/examples.md
+++ b/examples.md
@@ -151,6 +151,12 @@ Angr cannot currently solve this problem naively, as the problem is too complex
 Formatting the constraints to z3 a little differently allows z3 to come up with an answer relatively quickly. (I was asleep while it was solving, so I don't know exactly how long!)
 The script for this is [here](./examples/9447_nobranch/solve.py) and the binary is [here](./examples/9447_nobranch/nobranch).
 
+### CrackMe example: ais3_crackme
+
+Author: Antonio Bianchi, Tyler Nighswander
+
+ais3_crackme has been developed by Tyler Nighswander (tylerni7) for ais3 summer school. It is an easy crackme challenge, checking its command line argument.
+
 ## Exploitation Examples
 ### Beginner Exploitation example: strcpy_find
 
diff --git a/examples/ais3_crackme/ais3_crackme b/examples/ais3_crackme/ais3_crackme
new file mode 100755
index 0000000..38f0c40
Binary files /dev/null and b/examples/ais3_crackme/ais3_crackme differ
diff --git a/examples/ais3_crackme/solve.py b/examples/ais3_crackme/solve.py
new file mode 100755
index 0000000..df19a0f
--- /dev/null
+++ b/examples/ais3_crackme/solve.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python
+
+
+'''
+ais3_crackme has been developed by Tyler Nighswander (tylerni7) for ais3.
+
+It is an easy crackme challenge. It checks the command line argument.
+'''
+
+import angr
+
+
+def main():
+    project = angr.Project("./ais3_crackme")
+
+    #create an initial state with a symbolic bit vector as argv1
+    argv1 = angr.claripy.BVS("argv1",100*8) #since we do not the length now, we just put 100 bytes
+    initial_state = project.factory.path(args=["./crackme1",argv1])
+
+    #create a path group using the created initial state 
+    pg = project.factory.path_group(initial_state)
+
+    #symbolically execute the program until we reach the wanted value of the instruction pointer
+    pg.explore(find=0x400602) #at this instruction the binary will print the "correct" message
+
+    found = pg.found[0]
+    #ask to the symbolic solver to get the value of argv1 in the reached state
+    solution = found.state.se.any_str(argv1)
+
+    print repr(solution)
+    solution = solution[:solution.find("\x00")]
+    print solution
+    return solution
+
+def test():
+    res = main()
+    assert res == "ais3{I_tak3_g00d_n0t3s}"
+
+
+if __name__ == '__main__':
+    print(repr(main()))
+
+
