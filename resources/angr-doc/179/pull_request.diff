diff --git a/api-doc/source/angr.rst b/api-doc/source/angr.rst
index dad97ec..3ecf01e 100644
--- a/api-doc/source/angr.rst
+++ b/api-doc/source/angr.rst
@@ -24,6 +24,7 @@ Program State
 .. automodule:: angr.state_plugins.inspect
 .. automodule:: angr.state_plugins.libc
 .. automodule:: angr.state_plugins.posix
+.. automodule:: angr.state_plugins.filesystem
 .. automodule:: angr.state_plugins.solver
 .. automodule:: angr.state_plugins.log
 .. automodule:: angr.state_plugins.callstack
diff --git a/docs/state_plugins.md b/docs/state_plugins.md
index 5663717..d3c96e1 100644
--- a/docs/state_plugins.md
+++ b/docs/state_plugins.md
@@ -11,7 +11,7 @@ Let's get started!
 All state plugins are implemented as subclasses of `angr.SimStatePlugin`.
 Once you've read this document, you can use the [API reference for this class](http://api.angr.io/) (TODO update this link when the class is actually part of the docs????) to quickly review the semantics of all the interfaces you should implement.
 
-The most important method you need to implement is `copy`---it should return a copy of the plugin.
+The most important method you need to implement is `copy`: it should be annotated with the `memo` staticmethod and take a dict called the "memo"---these'll be important later---and returns a copy of the plugin.
 Short of that, you can do whatever you want.
 Just make sure to call the superclass initializer!
 
@@ -22,7 +22,8 @@ Just make sure to call the superclass initializer!
 ...         super(MyFirstPlugin, self).__init__()
 ...         self.foo = foo
 ... 
-...     def copy(self):
+...     @angr.SimStatePlugin.memo
+...     def copy(self, memo):
 ...         return MyFirstPlugin(self.foo)
 
 >>> state = angr.SimState(arch='AMD64')
@@ -130,7 +131,9 @@ You're in luck! Things can be state plugins even if they aren't directly attache
 A great example of this is `SimFile`, which is a state plugin but is stored in the filesystem plugin, and is never used with `SimState.register_plugin`.
 When you're doing this, there are a handful of rules to remember which will keep your plugins safe and happy:
 
-- Make sure that _only one refernce to each plugin object exists_. This is a limitation which will be addressed in an upcoming release of angr.
+- Annotate your copy function with `@SimStatePlugin.memo`.
+- In order to prevent _divergence_ while copying multiple references to the same plugin, make sure you're passing the memo (the argument to copy) to the `.copy` of any subplugins. This with the previous point will preserve object identity.
+- In order to prevent _duplicate merging_ while merging multiple references to the same plugin, there should be a concept of the "owner" of each instance, and only the owner should run the merge routine.
 - While passing arguments down into sub-plugins `merge()` routines, make sure you unwrap `others` and `common_ancestor` into the appropriate types. For example, if `PluginA` contains a `PluginB`, the former should do the following:
 
 ```python
diff --git a/docs/states.md b/docs/states.md
index d1b84b6..5f40e6a 100644
--- a/docs/states.md
+++ b/docs/states.md
@@ -12,7 +12,7 @@ Additionally, you should now know how to work with ASTs, so you can now understa
 Here are some quick examples for copying and performing operations on data from the state:
 
 ```python
->>> import angr
+>>> import angr, claripy
 >>> proj = angr.Project('/bin/true')
 >>> state = proj.factory.entry_state()
 
@@ -55,7 +55,7 @@ The following snippet implements this:
 
 ```python
 >>> proj = angr.Project('examples/fauxware/fauxware')
->>> state = proj.factory.entry_state()
+>>> state = proj.factory.entry_state(stdin=angr.SimFile)  # ignore that argument for now - we're disabling a more complicated default setup for the sake of education
 >>> while True:
 ...     succ = state.step()
 ...     if len(succ.successors) == 2:
@@ -73,10 +73,10 @@ Don't look at the constraints on these states directly - the branch we just went
 
 The program we emulated took data from standard input, which angr treats as an infinite stream of symbolic data by default.
 To perform a constraint solve and get a possible value that input could have taken in order to satisfy the constraints, we'll need to get a reference to the actual contents of stdin.
-We'll go over how our file and input subsystems work later on this very page, but for now, just use `state.posix.files[0].all_bytes()` to retrieve a bitvector representing all the content read from stdin so far.
+We'll go over how our file and input subsystems work later on this very page, but for now, just use `state.posix.stdin.load(0, state.posix.stdin.size)` to retrieve a bitvector representing all the content read from stdin so far.
 
 ```python
->>> input_data = state1.posix.files[0].all_bytes()
+>>> input_data = state1.posix.stdin.load(0, state.posix.stdin.size)
 
 >>> state1.solver.eval(input_data, cast_to=str)
 '\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00\x00\x00'
@@ -225,36 +225,172 @@ If you just want the topmost frame, this is `state.callstack`.
 - `callstack.stack_ptr` is the value of the stack pointer from the beginning of the current function
 - `callstack.ret_addr` is the location that the current function will return to if it returns
 
-### The posix plugin
+## Working with the filesystem
+
+It's very important to be able to control the environment that emulated programs see, including how symbolic data is introduced from the environment!
+angr has a robust series of abstractions to help you set up the environment you want.
+
+The root of any interaction with the filesystem, sockets, pipes, or terminals is a SimFile object.
+A SimFile is a _storage_ abstraction that defines a sequence of bytes, symbolic or otherwise.
+There are several kinds of SimFiles which store their data very differently - the two easiest examples are `SimFile` (the base class is actually called `SimFileBase`), which stores files as a flat address-space of data, and `SimPackets`, which stores a sequence of variable-sized reads.
+The former is best for modeling programs that need to perform seeks on their files, and is the default storage for opened files, while the latter is best for modeling programs that depend on short-reads or use scanf, and is the default storage for stdin/stdout/stderr.
+
+Because SimFiles can have such diverse storage mechanisms, the interface for interacting with them is _very_ abstracted.
+You can read from the file from some position, you can write to the file at some position, you can ask how many bytes are currently stored in the file, and you can concretize the file, generating a testcase for it.
+If you know specifically which SimFile class you're working with, you can take much more powerful control over it, and as a result you're encouraged to manually create any files you want to work with when you create your initial state.
 
-TODO
+Specifically, each SimFile class creates its own abstraction of a "position" within the file - each read and write takes a position and returns a new position that you should use to continue from where you left off.
+If you're working with SimFiles of unknown type you have to treat this position as a totally opaque object with no semantics other than the contract with the read/write functions.
 
-## Working with the Filesystem
+However! This is a very poor match to how programs generally interact with files, so angr also has a SimFileDescriptor abstraction, which provides the familiar read/write/seek/tell interfaces but will also return error conditions when the underlying storage don't support the appropriate operations - just like normal file descriptors!
 
-TODO: Describe what a SimFile is
+### Just tell me how to do what I want to do!
 
-There are a number of options which can be passed to the state initialization routines which affect filesystem usage.
-These include the `fs`, `concrete_fs`, and `chroot` options.
+Okay okay!!
 
-The `fs` option allows you to pass in a dictionary of file names to preconfigured SimFile objects.
-This allows you to do things like set a concrete size limit on a file's content.
+To create a SimFile, you should just create an instance of the class you want to use.
+Refer to the [api docs](http://angr.io/api-doc/angr.html#module-angr.storage.file) for the full instructions.
+Here's a few examples:
+
+```python
+# create a file with concrete content
+>>> simfile = angr.SimFile('myconcretefile', content='hello world!\n')
+
+# here's a nuance - you can't use simfiles without a state attached, because reasons
+# you'll never have to do this in a real scenario but let's mock it up:
+>>> simfile.set_state(state)
+
+# to demonstrate the behavior of these files we're going to use the fact that the
+# default simfile position is just the number of bytes from the start of the file
+# simfile.read returns a tuple (bitvector data, actual size, new pos)
+>>> data, actual_size, new_pos = simfile.read(0, 5)
+>>> assert claripy.is_true(data == 'hello')
+>>> assert claripy.is_true(actual_size == 5)
+>>> assert claripy.is_true(new_pos == 5)
+
+# continue the read, trying to read way too much
+>>> data, actual_size, new_pos = simfile.read(new_pos, 1000)
+
+# angr doesn't try to sanitize the data returned, only the size - we returned 1000 bytes!
+# the intent is that you're only allowed to use up to actual_size of them.
+>>> assert len(data) == 1000*8  # bitvector sizes are in bits
+>>> assert claripy.is_true(actual_size == 8)
+>>> assert claripy.is_true(data.get_bytes(0, 8) == ' world!\n')
+>>> assert claripy.is_true(new_pos == 13)
+
+# create a file with symbolic content and a defined size
+>>> simfile = angr.SimFile('mysymbolicfile', size=0x20)
+>>> simfile.set_state(state)
+
+>>> data, actual_size, new_pos = simfile.read(0, 0x30)
+>>> assert data.symbolic
+>>> assert claripy.is_true(actual_size == 0x20)
+
+# the raw SimFile provides the same interface as `state.memory`, so you can load data directly:
+>>> assert simfile.load(0, actual_size) is data.get_bytes(0, 0x20)
+
+# create a file with some mixed concrete and symbolic content, but no EOF
+>>> variable = claripy.BVS('myvar', 10*8)
+>>> simfile = angr.SimFile('mymixedfile', content=variable.concat(claripy.BVV('\n')), has_end=False)
+>>> simfile.set_state(state)
+
+# we can always query the number of bytes stored in the file:
+>>> assert claripy.is_true(simfile.size == 11)
+
+# reads will generate additional symbolic data past the current frontier:
+>>> data, actual_size, new_pos = simfile.read(0, 15)
+>>> assert claripy.is_true(actual_size == 15)
+>>> assert claripy.is_true(new_pos == 15)
+
+>>> assert claripy.is_true(data.get_bytes(0, 10) == variable)
+>>> assert claripy.is_true(data.get_bytes(10, 1) == '\n')
+>>> assert data.get_bytes(11, 4).symbolic
+
+# create a file with a symbolic size (has_end is implicitly true here)
+>>> symsize = claripy.BVS('mysize', 64)
+>>> state.solver.add(symsize >= 10)
+>>> state.solver.add(symsize < 20)
+>>> simfile = angr.SimFile('mysymsizefile', size=symsize)
+>>> simfile.set_state(state)
+
+# reads will encode all possibilities.
+>>> data, actual_size, new_pos = simfile.read(0, 30)
+>>> assert set(state.solver.eval_upto(actual_size, 30)) == set(range(10, 20))
+
+# the maximum size can't be easily resolved, so the data returned is 30 bytes long,
+# and we're supposed to use it conjunction with actual_size.
+>>> assert len(data) == 30*8
+
+# symbolic read sizes work too!
+>>> symreadsize = claripy.BVS('myreadsize', 64)
+>>> state.solver.add(symreadsize >= 5)
+>>> state.solver.add(symreadsize < 30)
+>>> data, actual_size, new_pos = simfile.read(0, symreadsize)
+
+# all sizes between 5 and 20 should be possible:
+>>> assert set(state.solver.eval_upto(actual_size, 30)) == set(range(5, 20))
+
+# we can use SimPackets to automatically enable support for short reads
+# i.e. when you ask for n bytes but actually get back fewer bytes than that.
+>>> simfile = angr.SimPackets('mypackets')
+>>> simfile.set_state(state)
+
+# this'll just generate a single packet.
+# for SimPackets, the position is just a packet number!
+# if left unspecified, short_reads is determined from a state option
+>>> data, actual_size, new_pos = simfile.read(0, 20, short_reads=True)
+>>> assert len(data) == 20*8
+>>> assert set(state.solver.eval_upto(actual_size, 30)) == set(range(21))
+```
 
-Setting the `concrete_fs` option to `True` will cause angr to respect the files on disk.
-For example, if during simulation a program attempts to open 'banner.txt' when `concrete_fs` is set to `False` \(the default\), a SimFile with a symbolic memory backing will be created and simulation will continue as though the file exists.
-When `concrete_fs` mode is set to `True`, if 'banner.txt' exists a new SimFile object will be created with a concrete backing, reducing the resulting state explosion which would be caused by operating on a completely symbolic file.
-Additionally in `concrete_fs` mode if 'banner.txt' mode does not exist, a SimFile object will not be created upon calls to open during simulation and an error code will be returned.
-Additionally, it's important to note that attempts to open files whose path begins with '/dev/' will never be opened concretely even with `concrete_fs` set to `True`.
+So hopefully you understand sort of the kind of data that a SimFile can store and what'll happen when a program tries to interact with it with various combinations of symbolic and concrete data.
+Those examples only covered reads, but writes are pretty similar.
+
+### The filesystem, for real now
+
+If you want to make a SimFile available to the program, we need to either stick it in the filesystem or serve stdin/stdout from it.
+
+The simulated filesystem is the `state.fs` plugin.
+You can store, load, and delete files from the filesystem, with the `insert`, `get`, and `delete` methods.
+Refer to the [api docs](http://angr.io/api-doc/angr.html#module-angr.state_plugins.filesystem) for details.
+
+So to make our file available as `/tmp/myfile`:
+
+```python
+>>> state.fs.insert('/tmp/myfile', simfile)
+>>> assert state.fs.get('/tmp/myfile') is simfile
+```
+
+Then, after execution, we would extract the file from the result state and use `simfile.concretize()` to generate a testcase to reach that state.
+Keep in mind that `concretize()` returns different types depending on the file type - for a SimFile it's a bytestring and for SimPackets it's a list of bytestrings.
+
+The simulated filesystem supports a fun concept of "mounts", where you can designate a subtree as instrumented by a particular provider.
+The most common mount is to expose a part of the host filesystem to the guest, lazily importing file data when the program asks for it:
+
+```python
+>>> state.fs.mount('/', angr.SimHostFilesystem('./guest_chroot'))
+```
+
+You can write whatever kind of mount you want to instrument filesystem access by subclassing `angr.SimMount`!
+
+### Stdio streams
+
+For stdin and friends, it's a little more complicated.
+The relevant plugin is `state.posix`, which stores all abstractions relevant to a POSIX-compliant environment.
+You can always get a state's stdin SimFile with `state.posix.stdin`, but you can't just replace it - as soon as the state is created, references to this file are created in the file descriptors.
+Because of this you need to specify it at the time the POSIX plugin is created:
+
+```python
+>>> state.register_plugin('posix', angr.state_plugins.posix.SimSystemPosix(stdin=simfile, stdout=simfile, stderr=simfile))
+```
 
-The `chroot` option allows you to specify an optional root to use while using the `concrete_fs` option.
-This can be convenient if the program you're analyzing references files using an absolute path.
-For example, if the program you are analyzing attempts to open '/etc/passwd', you can set the chroot to your current working directory so that attempts to access '/etc/passwd' will read from '$CWD/etc/passwd'.
+Or, there's a nice shortcut while creating the state if you only need to specify stdin:
 
 ```python
->>> files = {'/dev/stdin': angr.storage.file.SimFile("/dev/stdin", "r", size=30)}
->>> s = proj.factory.entry_state(fs=files, concrete_fs=True, chroot="angr-chroot/")
+>>> state = proj.factory.entry_state(stdin=simfile)
 ```
 
-This example will create a state which constricts at most 30 symbolic bytes from being read from stdin and will cause references to files to be resolved concretely within the new root directory `angr-chroot`.
+Any of those places you can specify a simfile, you can also specify a string or a bitvector (a flat SimFile with fixed size will be created to hold it) or a SimFile type (it'll be instanciated for you).
 
 ## Copying and Merging
 
diff --git a/examples/CADET_00001/solve.py b/examples/CADET_00001/solve.py
index 6c61748..83875eb 100755
--- a/examples/CADET_00001/solve.py
+++ b/examples/CADET_00001/solve.py
@@ -32,7 +32,8 @@ def main():
     unconstrained_state = sm.unconstrained[0]
     crashing_input = unconstrained_state.posix.dumps(0)
     #cat crash_input.bin | ./CADET_00001.adapted will segfault
-    unconstrained_state.posix.dump(0,"crash_input.bin")
+    with open('crash_input.bin', 'wb') as fp:
+        fp.write(crashing_input)
     print "buffer overflow found!"
     print repr(crashing_input)
 
@@ -55,7 +56,8 @@ def main():
     solution1 = found.posix.dumps(0)
     print "easter egg found!"
     print repr(solution1)
-    found.posix.dump(0,"easteregg_input1.bin")
+    with open('easteregg_input1.bin', 'wb') as fp:
+        fp.write(solution1)
     #you can even check if the easter egg has been found by checking stdout
     stdout1 = found.posix.dumps(1)
     print repr(stdout1)
@@ -74,7 +76,8 @@ def main():
     solution2 = found.posix.dumps(0)
     print "easter egg found!"
     print repr(solution2)
-    found.posix.dump(0,"easteregg_input2.bin")
+    with open('easteregg_input2.bin', 'wb') as fp:
+        fp.write(solution2)
     #you can even check if the easter egg has been found by checking stdout
     stdout2 = found.posix.dumps(1)
     print repr(stdout2)
diff --git a/examples/CSCI-4968-MBE/challenges/crackme0x01/solve.py b/examples/CSCI-4968-MBE/challenges/crackme0x01/solve.py
index 46b8b07..abf7271 100755
--- a/examples/CSCI-4968-MBE/challenges/crackme0x01/solve.py
+++ b/examples/CSCI-4968-MBE/challenges/crackme0x01/solve.py
@@ -16,10 +16,10 @@ def main():
 	sm = proj.factory.simulation_manager()
 	sm.explore(find=FIND_ADDR, avoid=AVOID_ADDR)
 
-	return sm.found[0].posix.dumps(0).lstrip('+0').rstrip('B')
+	return sm.found[0].posix.dumps(0).lstrip('+0').rstrip('B\n')
 
 def test():
-	assert main() == '5274\n'
+	assert main() == '5274'
 
 if __name__ == '__main__':
 	print(repr(main()))
diff --git a/examples/CSCI-4968-MBE/challenges/crackme0x02/solve.py b/examples/CSCI-4968-MBE/challenges/crackme0x02/solve.py
index 187fe06..2e8e347 100755
--- a/examples/CSCI-4968-MBE/challenges/crackme0x02/solve.py
+++ b/examples/CSCI-4968-MBE/challenges/crackme0x02/solve.py
@@ -16,10 +16,10 @@ def main():
 	sm = proj.factory.simulation_manager()
 	sm.explore(find=FIND_ADDR, avoid=AVOID_ADDR)
 
-	return sm.found[0].posix.dumps(0).lstrip('+0').rstrip('B')
+	return sm.found[0].posix.dumps(0).lstrip('+0').rstrip('B\n\n')
 
 def test():
-	assert main() == '338724\00'
+	assert main() == '338724'
 
 if __name__ == '__main__':
     print(repr(main()))
diff --git a/examples/CSCI-4968-MBE/challenges/crackme0x03/solve.py b/examples/CSCI-4968-MBE/challenges/crackme0x03/solve.py
index e4e78fd..ae60b85 100755
--- a/examples/CSCI-4968-MBE/challenges/crackme0x03/solve.py
+++ b/examples/CSCI-4968-MBE/challenges/crackme0x03/solve.py
@@ -16,10 +16,10 @@ def main():
 	sm = proj.factory.simulation_manager()
 	sm.explore(find=FIND_ADDR, avoid=AVOID_ADDR)
 
-	return sm.found[0].posix.dumps(0).lstrip('+0').rstrip('B')
+	return sm.found[0].posix.dumps(0).lstrip('+0').rstrip('B\n\0')
 
 def test():
-	assert main() == '338724\00'
+	assert main() == '338724'
 
 if __name__ == '__main__':
     print(repr(main()))
diff --git a/examples/asisctffinals2015_license/solve.py b/examples/asisctffinals2015_license/solve.py
index f2eb353..23216c6 100644
--- a/examples/asisctffinals2015_license/solve.py
+++ b/examples/asisctffinals2015_license/solve.py
@@ -1,4 +1,5 @@
 import angr
+import claripy
 
 def main():
     p = angr.Project("license", load_options={'auto_load_libs': False})
@@ -15,29 +16,19 @@ def main():
     # may also work, but in that case, angr will produce many more paths, and we 
     # will spent much more time in path trimming.
 
-    bytes = None
-    constraints = [ ]
+    bytestring = None
     for i in xrange(5):
         line = [ ]
         for j in xrange(6):
             line.append(state.solver.BVS('license_file_byte_%d_%d' % (i, j), 8))
-            state.add_constraints(line[-1] != 0x0a)
-        if bytes is None:
-            bytes = state.solver.Concat(*line)
+            state.add_constraints(line[-1] != '\n')
+        if bytestring is None:
+            bytestring = claripy.Concat(*line)
         else:
-            bytes = state.solver.Concat(bytes, state.solver.BVV(0x0a, 8), *line)
-    content = angr.state_plugins.SimSymbolicMemory(memory_id="file_%s" % license_name)
-    content.set_state(state)
-    content.store(0, bytes)
+            bytestring = bytestring.concat(state.solver.BVV('\n'), *line)
 
-    license_file = angr.storage.SimFile(license_name, 'rw', content=content, size=len(bytes) / 8)
-
-    # Build the file system dict
-    # This interface might change in the near future
-    fs = {
-        license_name: license_file
-    }
-    state.posix.fs = fs
+    license_file = angr.storage.file.SimFile(license_name, bytestring)
+    state.fs.insert(license_name, license_file)
 
     ex = p.surveyors.Explorer(
                             start=state,
diff --git a/examples/codegate_2017-angrybird/solve.py b/examples/codegate_2017-angrybird/solve.py
index 2a4902f..0d9ef99 100755
--- a/examples/codegate_2017-angrybird/solve.py
+++ b/examples/codegate_2017-angrybird/solve.py
@@ -17,6 +17,7 @@ def main():
 	# this also skips a bunch of initialization, so let's fix that:
 	state = proj.factory.entry_state(addr=START_ADDR)
 	state.regs.rbp = state.regs.rsp
+        state.mem[state.regs.rbp - 0x74].int = 0x40       # this is the length for the read
 	# using the same values as the binary doesn't work for these variables, I think because they point to the GOT and the binary is using that to try to fingerprint that it's loaded in angr. Setting them to pointers to symbolic memory works fine.
 	state.mem[state.regs.rbp - 0x70].long = 0x1000
 	state.mem[state.regs.rbp - 0x68].long = 0x1008
diff --git a/examples/defcamp_r100/solve.py b/examples/defcamp_r100/solve.py
index 74411af..19d2156 100644
--- a/examples/defcamp_r100/solve.py
+++ b/examples/defcamp_r100/solve.py
@@ -1,14 +1,14 @@
 import angr
 
 def main():
-    p = angr.Project("r100", load_options={'auto_load_libs': False})
-    ex = p.surveyors.Explorer(find=(0x400844, ), avoid=(0x400855,))
-    ex.run()
+    p = angr.Project("r100")
+    simgr = p.factory.simulation_manager(p.factory.full_init_state())
+    simgr.explore(find=0x400844, avoid=0x400855)
 
-    return ex.found[0].posix.dumps(0).strip('\0\n')
+    return simgr.found[0].posix.dumps(0).strip('\0\n')
 
 def test():
-    assert main() == 'Code_Talkers'
+    assert main().startswith('Code_Talkers')
 
 if __name__ == '__main__':
     print main()
diff --git a/examples/insomnihack_aeg/solve.py b/examples/insomnihack_aeg/solve.py
index ede3e4f..81e1946 100644
--- a/examples/insomnihack_aeg/solve.py
+++ b/examples/insomnihack_aeg/solve.py
@@ -42,11 +42,11 @@ def find_symbolic_buffer(state, length):
     '''
 
     # get all the symbolic bytes from stdin
-    stdin_file = state.posix.get_file(0)
+    stdin = state.posix.stdin
 
     sym_addrs = [ ]
-    for var in stdin_file.variables():
-        sym_addrs.extend(state.memory.addrs_for_name(var))
+    for _, symbol in state.solver.get_variables('file', stdin.ident):
+        sym_addrs.extend(state.memory.addrs_for_name(next(iter(symbol.variables))))
 
     for addr in sym_addrs:
         if check_continuity(addr, sym_addrs, length):
diff --git a/examples/simple_heap_overflow/solve.py b/examples/simple_heap_overflow/solve.py
index 0b23e22..c1fee19 100755
--- a/examples/simple_heap_overflow/solve.py
+++ b/examples/simple_heap_overflow/solve.py
@@ -55,7 +55,8 @@ def main():
 
     # Call the solving engine and write the solution out to a file called "exploit"
     print "Writing exploit as \"exploit\""
-    s.posix.dump(0,"exploit")
+    with open('exploit', 'wb') as fp:
+        fp.write(s.posix.dumps(0))
 
     # Now you can run the program and feed it your exploit to gain execution
     # ./simple_heap_overflow < exploit
