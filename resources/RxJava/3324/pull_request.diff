diff --git a/src/main/java/io/reactivex/internal/operators/OperatorSwitchMap.java b/src/main/java/io/reactivex/internal/operators/OperatorSwitchMap.java
index 518f3156ac..9862d950fe 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorSwitchMap.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorSwitchMap.java
@@ -46,13 +46,6 @@ public OperatorSwitchMap(Function<? super T, ? extends Publisher<? extends R>> m
         final Function<? super T, ? extends Publisher<? extends R>> mapper;
         final int bufferSize;
         
-        long requested;
-
-        volatile long missedRequested;
-        @SuppressWarnings("rawtypes")
-        static final AtomicLongFieldUpdater<SwitchMapSubscriber> MISSED_REQUESTED =
-                AtomicLongFieldUpdater.newUpdater(SwitchMapSubscriber.class, "missedRequested");
-
         
         volatile boolean done;
         Throwable error;
@@ -61,12 +54,21 @@ public OperatorSwitchMap(Function<? super T, ? extends Publisher<? extends R>> m
         
         Subscription s;
         
-        volatile Publisher<? extends R> publisher;
+        volatile SwitchMapInnerSubscriber<T, R> active;
         @SuppressWarnings("rawtypes")
-        static final AtomicReferenceFieldUpdater<SwitchMapSubscriber, Publisher> PUBLISHER =
-                AtomicReferenceFieldUpdater.newUpdater(SwitchMapSubscriber.class, Publisher.class, "publisher");
+        static final AtomicReferenceFieldUpdater<SwitchMapSubscriber, SwitchMapInnerSubscriber> ACTIVE =
+                AtomicReferenceFieldUpdater.newUpdater(SwitchMapSubscriber.class, SwitchMapInnerSubscriber.class, "active");
         
-        SwitchMapInnerSubscriber<T, R> active;
+        volatile long requested;
+        @SuppressWarnings("rawtypes")
+        static final AtomicLongFieldUpdater<SwitchMapSubscriber> REQUESTED =
+                AtomicLongFieldUpdater.newUpdater(SwitchMapSubscriber.class, "requested");
+        
+        static final SwitchMapInnerSubscriber<Object, Object> CANCELLED;
+        static {
+            CANCELLED = new SwitchMapInnerSubscriber<>(null, -1L, 1);
+            CANCELLED.cancel();
+        }
         
         volatile long unique;
         
@@ -87,6 +89,14 @@ public void onSubscribe(Subscription s) {
         
         @Override
         public void onNext(T t) {
+            long c = unique + 1;
+            unique = c;
+            
+            SwitchMapInnerSubscriber<T, R> inner = active;
+            if (inner != null) {
+                inner.cancel();
+            }
+            
             Publisher<? extends R> p;
             try {
                 p = mapper.apply(t);
@@ -95,13 +105,33 @@ public void onNext(T t) {
                 onError(e);
                 return;
             }
+
+            if (p == null) {
+                s.cancel();
+                onError(new NullPointerException("The publisher returned is null"));
+                return;
+            }
             
-            PUBLISHER.lazySet(this, p);
-            drain();
+            SwitchMapInnerSubscriber<T, R> nextInner = new SwitchMapInnerSubscriber<>(this, c, bufferSize);
+            
+            for (;;) {
+                inner = active;
+                if (inner == CANCELLED) {
+                    break;
+                }
+                if (ACTIVE.compareAndSet(this, inner, nextInner)) {
+                    p.subscribe(nextInner);
+                    break;
+                }
+            }
         }
         
         @Override
         public void onError(Throwable t) {
+            if (done) {
+                RxJavaPlugins.onError(t);
+                return;
+            }
             error = t;
             done = true;
             drain();
@@ -109,6 +139,9 @@ public void onError(Throwable t) {
         
         @Override
         public void onComplete() {
+            if (done) {
+                return;
+            }
             done = true;
             drain();
         }
@@ -118,7 +151,7 @@ public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
-            BackpressureHelper.add(MISSED_REQUESTED, this, n);
+            BackpressureHelper.add(REQUESTED, this, n);
             if (unique == 0L) {
                 s.request(Long.MAX_VALUE);
             } else {
@@ -130,22 +163,22 @@ public void request(long n) {
         public void cancel() {
             if (!cancelled) {
                 cancelled = true;
-
-                if (getAndIncrement() == 0) {
-                    clear(active);
-                }
+                
+                disposeInner();
             }
         }
         
-        void clear(SwitchMapInnerSubscriber<T, R> inner) {
-            if (inner != null) {
-                inner.cancel();
+        @SuppressWarnings("unchecked")
+        void disposeInner() {
+            SwitchMapInnerSubscriber<T, R> a = active;
+            if (a != CANCELLED) {
+                a = ACTIVE.getAndSet(this, CANCELLED);
+                if (a != CANCELLED && a != null) {
+                    s.cancel();
+                }
             }
-            publisher = null;
-            s.cancel();
         }
         
-        @SuppressWarnings("unchecked")
         void drain() {
             if (getAndIncrement() != 0) {
                 return;
@@ -154,75 +187,78 @@ void drain() {
             final Subscriber<? super R> a = actual;
             
             int missing = 1;
-            
+
             for (;;) {
-                boolean d = done;
-                Publisher<? extends R> p = publisher;
-                SwitchMapInnerSubscriber<T, R> inner = active;
-                boolean empty = p == null && inner == null;
-                
-                if (checkTerminated(d, empty, a, inner)) {
-                    return;
-                }
 
-                // get the latest publisher
-                if (p != null) {
-                    p = PUBLISHER.getAndSet(this, null);
+                if (cancelled) {
+                    return;
                 }
                 
-                long c = unique;
-                if (p != null) {
-                    if (inner != null) {
-                        inner.cancel();
-                        inner = null;
+                if (done) {
+                    Throwable err = error;
+                    if (err != null) {
+                        disposeInner();
+                        s.cancel();
+                        a.onError(err);
+                        return;
+                    } else
+                    if (active == null) {
+                        a.onComplete();
+                        return;
                     }
-                    unique = ++c;
-                    inner = new SwitchMapInnerSubscriber<>(this, c, bufferSize);
-                    active = inner;
-                    
-                    p.subscribe(inner);
                 }
+                
+                SwitchMapInnerSubscriber<T, R> inner = active;
 
                 if (inner != null) {
-                    long r = requested;
-                    
-                    long mr = MISSED_REQUESTED.getAndSet(this, 0L);
-                    if (mr != 0L) {
-                        r = BackpressureHelper.addCap(r, mr);
-                        requested = r;
+                    Queue<R> q = inner.queue;
+
+                    if (inner.done) {
+                        Throwable err = inner.error;
+                        if (err != null) {
+                            s.cancel();
+                            disposeInner();
+                            a.onError(err);
+                            return;
+                        } else
+                        if (q.isEmpty()) {
+                            ACTIVE.compareAndSet(this, inner, null);
+                            continue;
+                        }
                     }
                     
+                    long r = requested;
                     boolean unbounded = r == Long.MAX_VALUE;
-    
-                    Queue<R> q = inner.queue;
-                    long e = 0;
+                    long e = 0L;
+                    boolean retry = false;
                     
                     while (r != 0L) {
-                        d = inner.done;
+                        boolean d = inner.done;
                         R v = q.poll();
-                        empty = v == null;
+                        boolean empty = v == null;
 
                         if (cancelled) {
-                            clear(active);
                             return;
                         }
+                        if (inner != active) {
+                            retry = true;
+                            break;
+                        }
+                        
                         if (d) {
                             Throwable err = inner.error;
                             if (err != null) {
-                                clear(active);
+                                s.cancel();
                                 a.onError(err);
                                 return;
                             } else
                             if (empty) {
-                                active = null;
+                                ACTIVE.compareAndSet(this, inner, null);
+                                retry = true;
                                 break;
                             }
                         }
                         
-                        if (publisher != null) {
-                            break;
-                        }
-                        
                         if (empty) {
                             break;
                         }
@@ -230,18 +266,23 @@ void drain() {
                         a.onNext(v);
                         
                         r--;
-                        e++;
+                        e--;
                     }
                     
                     if (e != 0L) {
-                        if (!unbounded) {
-                            requested -= e;
-                            inner.get().request(e);
+                        if (!cancelled) {
+                            if (!unbounded) {
+                                REQUESTED.addAndGet(this, e);
+                            }
+                            inner.get().request(-e);
                         }
-                        
+                    }
+                    
+                    if (retry) {
+                        continue;
                     }
                 }
-
+                
                 missing = addAndGet(-missing);
                 if (missing == 0) {
                     break;
@@ -249,16 +290,16 @@ void drain() {
             }
         }
         
-        boolean checkTerminated(boolean d, boolean empty, Subscriber<? super R> a, SwitchMapInnerSubscriber<T, R> inner) {
+        boolean checkTerminated(boolean d, boolean empty, Subscriber<? super R> a) {
             if (cancelled) {
-                clear(inner);
+                s.cancel();
                 return true;
             }
             if (d) {
                 Throwable e = error;
                 if (e != null) {
                     cancelled = true;
-                    clear(inner);
+                    s.cancel();
                     a.onError(e);
                     return true;
                 } else
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorSubscribeOnTest.java b/src/test/java/io/reactivex/internal/operators/OperatorSubscribeOnTest.java
new file mode 100644
index 0000000000..0199c8207f
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorSubscribeOnTest.java
@@ -0,0 +1,270 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.junit.Assert.*;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+
+import org.junit.*;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.Observable.Operator;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.subscriptions.*;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class OperatorSubscribeOnTest {
+
+    @Test(timeout = 2000)
+    public void testIssue813() throws InterruptedException {
+        // https://github.com/ReactiveX/RxJava/issues/813
+        final CountDownLatch scheduled = new CountDownLatch(1);
+        final CountDownLatch latch = new CountDownLatch(1);
+        final CountDownLatch doneLatch = new CountDownLatch(1);
+
+        TestSubscriber<Integer> observer = new TestSubscriber<>();
+
+        Observable
+        .create(new Publisher<Integer>() {
+            @Override
+            public void subscribe(
+                    final Subscriber<? super Integer> subscriber) {
+                subscriber.onSubscribe(EmptySubscription.INSTANCE);
+                scheduled.countDown();
+                try {
+                    try {
+                        latch.await();
+                    } catch (InterruptedException e) {
+                        // this means we were unsubscribed (Scheduler shut down and interrupts)
+                        // ... but we'll pretend we are like many Observables that ignore interrupts
+                    }
+
+                    subscriber.onComplete();
+                } catch (Throwable e) {
+                    subscriber.onError(e);
+                } finally {
+                    doneLatch.countDown();
+                }
+            }
+        }).subscribeOn(Schedulers.computation()).subscribe(observer);
+
+        // wait for scheduling
+        scheduled.await();
+        // trigger unsubscribe
+        observer.dispose();
+        latch.countDown();
+        doneLatch.await();
+        observer.assertNoErrors();
+        observer.assertComplete();
+    }
+
+    @Test
+    @Ignore("Publisher.subscribe can't throw")
+    public void testThrownErrorHandling() {
+        TestSubscriber<String> ts = new TestSubscriber<>();
+        Observable.create(new Publisher<String>() {
+
+            @Override
+            public void subscribe(Subscriber<? super String> s) {
+                throw new RuntimeException("fail");
+            }
+
+        }).subscribeOn(Schedulers.computation()).subscribe(ts);
+        ts.awaitTerminalEvent(1000, TimeUnit.MILLISECONDS);
+        ts.assertTerminated();
+    }
+
+    @Test
+    public void testOnError() {
+        TestSubscriber<String> ts = new TestSubscriber<>();
+        Observable.create(new Publisher<String>() {
+
+            @Override
+            public void subscribe(Subscriber<? super String> s) {
+                s.onSubscribe(EmptySubscription.INSTANCE);
+                s.onError(new RuntimeException("fail"));
+            }
+
+        }).subscribeOn(Schedulers.computation()).subscribe(ts);
+        ts.awaitTerminalEvent(1000, TimeUnit.MILLISECONDS);
+        ts.assertTerminated();
+    }
+
+    public static class SlowScheduler extends Scheduler {
+        final Scheduler actual;
+        final long delay;
+        final TimeUnit unit;
+
+        public SlowScheduler() {
+            this(Schedulers.computation(), 2, TimeUnit.SECONDS);
+        }
+
+        public SlowScheduler(Scheduler actual, long delay, TimeUnit unit) {
+            this.actual = actual;
+            this.delay = delay;
+            this.unit = unit;
+        }
+
+        @Override
+        public Worker createWorker() {
+            return new SlowInner(actual.createWorker());
+        }
+
+        private final class SlowInner extends Worker {
+
+            private final Scheduler.Worker actualInner;
+
+            private SlowInner(Worker actual) {
+                this.actualInner = actual;
+            }
+
+            @Override
+            public void dispose() {
+                actualInner.dispose();
+            }
+
+            // FIXME not available
+//            @Override
+//            public boolean isDisposed() {
+//                return actualInner.isDisposed();
+//            }
+
+            @Override
+            public Disposable schedule(final Runnable action) {
+                return actualInner.schedule(action, delay, unit);
+            }
+
+            @Override
+            public Disposable schedule(final Runnable action, final long delayTime, final TimeUnit delayUnit) {
+                TimeUnit common = delayUnit.compareTo(unit) < 0 ? delayUnit : unit;
+                long t = common.convert(delayTime, delayUnit) + common.convert(delay, unit);
+                return actualInner.schedule(action, t, common);
+            }
+
+        }
+
+    }
+
+    @Test(timeout = 5000)
+    public void testUnsubscribeInfiniteStream() throws InterruptedException {
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        final AtomicInteger count = new AtomicInteger();
+        Observable.create(new Publisher<Integer>() {
+
+            @Override
+            public void subscribe(Subscriber<? super Integer> sub) {
+                BooleanSubscription bs = new BooleanSubscription();
+                sub.onSubscribe(bs);
+                for (int i = 1; !bs.isCancelled(); i++) {
+                    count.incrementAndGet();
+                    sub.onNext(i);
+                }
+            }
+
+        }).subscribeOn(Schedulers.newThread()).take(10).subscribe(ts);
+
+        ts.awaitTerminalEvent(1000, TimeUnit.MILLISECONDS);
+        ts.dispose();
+        Thread.sleep(200); // give time for the loop to continue
+        ts.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+        assertEquals(10, count.get());
+    }
+
+    @Test
+    public void testBackpressureReschedulesCorrectly() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(10);
+        TestSubscriber<Integer> ts = new TestSubscriber<>(new Observer<Integer>() {
+
+            @Override
+            public void onComplete() {
+            }
+
+            @Override
+            public void onError(Throwable e) {
+            }
+
+            @Override
+            public void onNext(Integer t) {
+                latch.countDown();
+            }
+
+        });
+        ts.request(10);
+        Observable.range(1, 10000000).subscribeOn(Schedulers.newThread()).take(20).subscribe(ts);
+        latch.await();
+        Thread t = ts.lastThread();
+        System.out.println("First schedule: " + t);
+        assertTrue(t.getName().startsWith("Rx"));
+        ts.request(10);
+        ts.awaitTerminalEvent();
+        System.out.println("After reschedule: " + ts.lastThread());
+        assertEquals(t, ts.lastThread());
+    }
+
+    @Test
+    public void testSetProducerSynchronousRequest() {
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        Observable.just(1, 2, 3).lift(new Operator<Integer, Integer>() {
+
+            @Override
+            public Subscriber<? super Integer> apply(final Subscriber<? super Integer> child) {
+                final AtomicLong requested = new AtomicLong();
+                child.onSubscribe(new Subscription() {
+
+                    @Override
+                    public void request(long n) {
+                        if (!requested.compareAndSet(0, n)) {
+                            child.onError(new RuntimeException("Expected to receive request before onNext but didn't"));
+                        }
+                    }
+                    
+                    @Override
+                    public void cancel() {
+                        
+                    }
+
+                });
+                Subscriber<Integer> parent = new Observer<Integer>() {
+
+                    @Override
+                    public void onComplete() {
+                        child.onComplete();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        child.onError(e);
+                    }
+
+                    @Override
+                    public void onNext(Integer t) {
+                        if (requested.compareAndSet(0, -99)) {
+                            child.onError(new RuntimeException("Got values before requested"));
+                        }
+                    }
+                };
+
+                return parent;
+            }
+
+        }).subscribeOn(Schedulers.newThread()).subscribe(ts);
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorSwitchIfEmptyTest.java b/src/test/java/io/reactivex/internal/operators/OperatorSwitchIfEmptyTest.java
new file mode 100644
index 0000000000..758dc24948
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorSwitchIfEmptyTest.java
@@ -0,0 +1,210 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.junit.Assert.*;
+
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.junit.Test;
+import org.reactivestreams.*;
+
+
+import io.reactivex.*;
+import io.reactivex.internal.subscriptions.*;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subscribers.TestSubscriber;
+
+
+public class OperatorSwitchIfEmptyTest {
+
+    @Test
+    public void testSwitchWhenNotEmpty() throws Exception {
+        final AtomicBoolean subscribed = new AtomicBoolean(false);
+        final Observable<Integer> observable = Observable.just(4)
+                .switchIfEmpty(Observable.just(2)
+                .doOnSubscribe(s -> subscribed.set(true)));
+
+        assertEquals(4, observable.toBlocking().single().intValue());
+        assertFalse(subscribed.get());
+    }
+
+    @Test
+    public void testSwitchWhenEmpty() throws Exception {
+        final Observable<Integer> observable = Observable.<Integer>empty()
+                .switchIfEmpty(Observable.fromIterable(Arrays.asList(42)));
+
+        assertEquals(42, observable.toBlocking().single().intValue());
+    }
+
+    @Test
+    public void testSwitchWithProducer() throws Exception {
+        final AtomicBoolean emitted = new AtomicBoolean(false);
+        Observable<Long> withProducer = Observable.create(new Publisher<Long>() {
+            @Override
+            public void subscribe(final Subscriber<? super Long> subscriber) {
+                subscriber.onSubscribe(new Subscription() {
+                    @Override
+                    public void request(long n) {
+                        if (n > 0 && emitted.compareAndSet(false, true)) {
+                            emitted.set(true);
+                            subscriber.onNext(42L);
+                            subscriber.onComplete();
+                        }
+                    }
+                    
+                    @Override
+                    public void cancel() {
+                        
+                    }
+                });
+            }
+        });
+
+        final Observable<Long> observable = Observable.<Long>empty().switchIfEmpty(withProducer);
+        assertEquals(42, observable.toBlocking().single().intValue());
+    }
+
+    @Test
+    public void testSwitchTriggerUnsubscribe() throws Exception {
+
+        BooleanSubscription bs = new BooleanSubscription();
+        
+        Observable<Long> withProducer = Observable.create(new Publisher<Long>() {
+            @Override
+            public void subscribe(final Subscriber<? super Long> subscriber) {
+                subscriber.onSubscribe(bs);
+                subscriber.onNext(42L);
+            }
+        });
+
+        Observable.<Long>empty()
+                .switchIfEmpty(withProducer)
+                .lift(new Observable.Operator<Long, Long>() {
+            @Override
+            public Subscriber<? super Long> apply(final Subscriber<? super Long> child) {
+                return new Observer<Long>() {
+                    @Override
+                    public void onComplete() {
+
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+
+                    }
+
+                    @Override
+                    public void onNext(Long aLong) {
+                        cancel();
+                    }
+                    
+                };
+            }
+        }).subscribe();
+
+
+        assertTrue(bs.isCancelled());
+        // FIXME no longer assertable
+//        assertTrue(sub.isUnsubscribed());
+    }
+
+    @Test
+    public void testSwitchShouldTriggerUnsubscribe() {
+        BooleanSubscription bs = new BooleanSubscription();
+        
+        Observable.create(new Publisher<Long>() {
+            @Override
+            public void subscribe(final Subscriber<? super Long> subscriber) {
+                subscriber.onSubscribe(bs);
+                subscriber.onComplete();
+            }
+        }).switchIfEmpty(Observable.<Long>never()).subscribe();
+        assertTrue(bs.isCancelled());
+    }
+
+    @Test
+    public void testSwitchRequestAlternativeObservableWithBackpressure() {
+
+        TestSubscriber<Integer> ts = new TestSubscriber<>(1L);
+        
+        Observable.<Integer>empty().switchIfEmpty(Observable.just(1, 2, 3)).subscribe(ts);
+        
+        assertEquals(Arrays.asList(1), ts.values());
+        ts.assertNoErrors();
+        ts.request(1);
+        ts.assertValueCount(2);
+        ts.request(1);
+        ts.assertValueCount(3);
+    }
+    @Test
+    public void testBackpressureNoRequest() {
+        TestSubscriber<Integer> ts = new TestSubscriber<>((Long)null);
+        Observable.<Integer>empty().switchIfEmpty(Observable.just(1, 2, 3)).subscribe(ts);
+        ts.assertNoValues();
+        ts.assertNoErrors();
+    }
+    
+    @Test
+    public void testBackpressureOnFirstObservable() {
+        TestSubscriber<Integer> ts = new TestSubscriber<>((Long)null);
+        Observable.just(1,2,3).switchIfEmpty(Observable.just(4, 5, 6)).subscribe(ts);
+        ts.assertNotComplete();
+        ts.assertNoErrors();
+        ts.assertNoValues();
+    }
+    
+    @Test(timeout = 10000)
+    public void testRequestsNotLost() throws InterruptedException {
+        final TestSubscriber<Long> ts = new TestSubscriber<>((Long)null);
+        Observable.create(new Publisher<Long>() {
+
+            @Override
+            public void subscribe(final Subscriber<? super Long> subscriber) {
+                subscriber.onSubscribe(new Subscription() {
+                    final AtomicBoolean completed = new AtomicBoolean(false);
+                    @Override
+                    public void request(long n) {
+                        if (n > 0 && completed.compareAndSet(false, true)) {
+                            Schedulers.io().createWorker().schedule(new Runnable() {
+                                @Override
+                                public void run() {
+                                    subscriber.onComplete();
+                                }}, 100, TimeUnit.MILLISECONDS);
+                        }
+                    }
+                    
+                    @Override
+                    public void cancel() {
+                        
+                    }
+                });
+            }})
+          .switchIfEmpty(Observable.fromIterable(Arrays.asList(1L, 2L, 3L)))
+          .subscribeOn(Schedulers.computation())
+          .subscribe(ts);
+
+        Thread.sleep(50);
+        //request while first observable is still finishing (as empty)
+        ts.request(1);
+        ts.request(1);
+        Thread.sleep(500);
+        ts.assertNotComplete();
+        ts.assertNoErrors();
+        ts.assertValueCount(2);
+        ts.dispose();
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorSwitchTest.java b/src/test/java/io/reactivex/internal/operators/OperatorSwitchTest.java
new file mode 100644
index 0000000000..7aab5f369d
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorSwitchTest.java
@@ -0,0 +1,632 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.*;
+import static org.mockito.Mockito.*;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Function;
+
+import org.junit.*;
+import org.mockito.InOrder;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.subscriptions.*;
+import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.subjects.PublishSubject;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class OperatorSwitchTest {
+
+    private TestScheduler scheduler;
+    private Scheduler.Worker innerScheduler;
+    private Subscriber<String> observer;
+
+    @Before
+    public void before() {
+        scheduler = new TestScheduler();
+        innerScheduler = scheduler.createWorker();
+        observer = TestHelper.mockSubscriber();
+    }
+
+    @Test
+    public void testSwitchWhenOuterCompleteBeforeInner() {
+        Observable<Observable<String>> source = Observable.create(new Publisher<Observable<String>>() {
+            @Override
+            public void subscribe(Subscriber<? super Observable<String>> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                publishNext(observer, 50, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 70, "one");
+                        publishNext(observer, 100, "two");
+                        publishCompleted(observer, 200);
+                    }
+                }));
+                publishCompleted(observer, 60);
+            }
+        });
+
+        Observable<String> sampled = Observable.switchOnNext(source);
+        sampled.subscribe(observer);
+
+        InOrder inOrder = inOrder(observer);
+
+        scheduler.advanceTimeTo(350, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(2)).onNext(anyString());
+        inOrder.verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testSwitchWhenInnerCompleteBeforeOuter() {
+        Observable<Observable<String>> source = Observable.create(new Publisher<Observable<String>>() {
+            @Override
+            public void subscribe(Subscriber<? super Observable<String>> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                publishNext(observer, 10, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 0, "one");
+                        publishNext(observer, 10, "two");
+                        publishCompleted(observer, 20);
+                    }
+                }));
+
+                publishNext(observer, 100, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 0, "three");
+                        publishNext(observer, 10, "four");
+                        publishCompleted(observer, 20);
+                    }
+                }));
+                publishCompleted(observer, 200);
+            }
+        });
+
+        Observable<String> sampled = Observable.switchOnNext(source);
+        sampled.subscribe(observer);
+
+        InOrder inOrder = inOrder(observer);
+
+        scheduler.advanceTimeTo(150, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, never()).onComplete();
+        inOrder.verify(observer, times(1)).onNext("one");
+        inOrder.verify(observer, times(1)).onNext("two");
+        inOrder.verify(observer, times(1)).onNext("three");
+        inOrder.verify(observer, times(1)).onNext("four");
+
+        scheduler.advanceTimeTo(250, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, never()).onNext(anyString());
+        inOrder.verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testSwitchWithComplete() {
+        Observable<Observable<String>> source = Observable.create(new Publisher<Observable<String>>() {
+            @Override
+            public void subscribe(Subscriber<? super Observable<String>> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                publishNext(observer, 50, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(final Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 60, "one");
+                        publishNext(observer, 100, "two");
+                    }
+                }));
+
+                publishNext(observer, 200, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(final Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 0, "three");
+                        publishNext(observer, 100, "four");
+                    }
+                }));
+
+                publishCompleted(observer, 250);
+            }
+        });
+
+        Observable<String> sampled = Observable.switchOnNext(source);
+        sampled.subscribe(observer);
+
+        InOrder inOrder = inOrder(observer);
+
+        scheduler.advanceTimeTo(90, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, never()).onNext(anyString());
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(125, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(1)).onNext("one");
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(175, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(1)).onNext("two");
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(225, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(1)).onNext("three");
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(350, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(1)).onNext("four");
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+    }
+
+    @Test
+    public void testSwitchWithError() {
+        Observable<Observable<String>> source = Observable.create(new Publisher<Observable<String>>() {
+            @Override
+            public void subscribe(Subscriber<? super Observable<String>> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                publishNext(observer, 50, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(final Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 50, "one");
+                        publishNext(observer, 100, "two");
+                    }
+                }));
+
+                publishNext(observer, 200, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 0, "three");
+                        publishNext(observer, 100, "four");
+                    }
+                }));
+
+                publishError(observer, 250, new TestException());
+            }
+        });
+
+        Observable<String> sampled = Observable.switchOnNext(source);
+        sampled.subscribe(observer);
+
+        InOrder inOrder = inOrder(observer);
+
+        scheduler.advanceTimeTo(90, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, never()).onNext(anyString());
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(125, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(1)).onNext("one");
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(175, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(1)).onNext("two");
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(225, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(1)).onNext("three");
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(350, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, never()).onNext(anyString());
+        verify(observer, never()).onComplete();
+        verify(observer, times(1)).onError(any(TestException.class));
+    }
+
+    @Test
+    public void testSwitchWithSubsequenceComplete() {
+        Observable<Observable<String>> source = Observable.create(new Publisher<Observable<String>>() {
+            @Override
+            public void subscribe(Subscriber<? super Observable<String>> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                publishNext(observer, 50, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 50, "one");
+                        publishNext(observer, 100, "two");
+                    }
+                }));
+
+                publishNext(observer, 130, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishCompleted(observer, 0);
+                    }
+                }));
+
+                publishNext(observer, 150, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 50, "three");
+                    }
+                }));
+            }
+        });
+
+        Observable<String> sampled = Observable.switchOnNext(source);
+        sampled.subscribe(observer);
+
+        InOrder inOrder = inOrder(observer);
+
+        scheduler.advanceTimeTo(90, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, never()).onNext(anyString());
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(125, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(1)).onNext("one");
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(250, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(1)).onNext("three");
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+    }
+
+    @Test
+    public void testSwitchWithSubsequenceError() {
+        Observable<Observable<String>> source = Observable.create(new Publisher<Observable<String>>() {
+            @Override
+            public void subscribe(Subscriber<? super Observable<String>> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                publishNext(observer, 50, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 50, "one");
+                        publishNext(observer, 100, "two");
+                    }
+                }));
+
+                publishNext(observer, 130, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishError(observer, 0, new TestException());
+                    }
+                }));
+
+                publishNext(observer, 150, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 50, "three");
+                    }
+                }));
+
+            }
+        });
+
+        Observable<String> sampled = Observable.switchOnNext(source);
+        sampled.subscribe(observer);
+
+        InOrder inOrder = inOrder(observer);
+
+        scheduler.advanceTimeTo(90, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, never()).onNext(anyString());
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(125, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(1)).onNext("one");
+        verify(observer, never()).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+
+        scheduler.advanceTimeTo(250, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, never()).onNext("three");
+        verify(observer, never()).onComplete();
+        verify(observer, times(1)).onError(any(TestException.class));
+    }
+
+    private <T> void publishCompleted(final Subscriber<T> observer, long delay) {
+        innerScheduler.schedule(new Runnable() {
+            @Override
+            public void run() {
+                observer.onComplete();
+            }
+        }, delay, TimeUnit.MILLISECONDS);
+    }
+
+    private <T> void publishError(final Subscriber<T> observer, long delay, final Throwable error) {
+        innerScheduler.schedule(new Runnable() {
+            @Override
+            public void run() {
+                observer.onError(error);
+            }
+        }, delay, TimeUnit.MILLISECONDS);
+    }
+
+    private <T> void publishNext(final Subscriber<T> observer, long delay, final T value) {
+        innerScheduler.schedule(new Runnable() {
+            @Override
+            public void run() {
+                observer.onNext(value);
+            }
+        }, delay, TimeUnit.MILLISECONDS);
+    }
+
+    @Test
+    public void testSwitchIssue737() {
+        // https://github.com/ReactiveX/RxJava/issues/737
+        Observable<Observable<String>> source = Observable.create(new Publisher<Observable<String>>() {
+            @Override
+            public void subscribe(Subscriber<? super Observable<String>> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                publishNext(observer, 0, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 10, "1-one");
+                        publishNext(observer, 20, "1-two");
+                        // The following events will be ignored
+                        publishNext(observer, 30, "1-three");
+                        publishCompleted(observer, 40);
+                    }
+                }));
+                publishNext(observer, 25, Observable.create(new Publisher<String>() {
+                    @Override
+                    public void subscribe(Subscriber<? super String> observer) {
+                        observer.onSubscribe(EmptySubscription.INSTANCE);
+                        publishNext(observer, 10, "2-one");
+                        publishNext(observer, 20, "2-two");
+                        publishNext(observer, 30, "2-three");
+                        publishCompleted(observer, 40);
+                    }
+                }));
+                publishCompleted(observer, 30);
+            }
+        });
+
+        Observable<String> sampled = Observable.switchOnNext(source);
+        sampled.subscribe(observer);
+
+        scheduler.advanceTimeTo(1000, TimeUnit.MILLISECONDS);
+
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, times(1)).onNext("1-one");
+        inOrder.verify(observer, times(1)).onNext("1-two");
+        inOrder.verify(observer, times(1)).onNext("2-one");
+        inOrder.verify(observer, times(1)).onNext("2-two");
+        inOrder.verify(observer, times(1)).onNext("2-three");
+        inOrder.verify(observer, times(1)).onComplete();
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testBackpressure() {
+
+        PublishSubject<String> o1 = PublishSubject.create();
+        PublishSubject<String> o2 = PublishSubject.create();
+        PublishSubject<String> o3 = PublishSubject.create();
+        
+        PublishSubject<PublishSubject<String>> o = PublishSubject.create();
+
+        publishNext(o, 0, o1);
+        publishNext(o, 5, o2);
+        publishNext(o, 10, o3);
+        publishCompleted(o, 15);
+
+        for (int i = 0; i < 10; i++) {
+            publishNext(o1, i * 5, "a" + (i + 1));
+            publishNext(o2, 5 + i * 5, "b" + (i + 1));
+            publishNext(o3, 10 + i * 5, "c" + (i + 1));
+        }
+
+        publishCompleted(o1, 45);
+        publishCompleted(o2, 50);
+        publishCompleted(o3, 55);
+
+        
+        final TestSubscriber<String> testSubscriber = new TestSubscriber<>();
+        Observable.switchOnNext(o).subscribe(new Observer<String>() {
+
+            private int requested = 0;
+
+            @Override
+            public void onStart() {
+                requested = 3;
+                request(3);
+            }
+
+            @Override
+            public void onComplete() {
+                testSubscriber.onComplete();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                testSubscriber.onError(e);
+            }
+
+            @Override
+            public void onNext(String s) {
+                testSubscriber.onNext(s);
+                requested--;
+                if(requested == 0) {
+                    requested = 3;
+                    request(3);
+                }
+            }
+        });
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+        testSubscriber.assertValues("a1", "b1", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10");
+        testSubscriber.assertNoErrors();
+        testSubscriber.assertTerminated();
+    }
+
+    @Test
+    public void testUnsubscribe() {
+        final AtomicBoolean isUnsubscribed = new AtomicBoolean();
+        Observable.switchOnNext(
+                Observable.create(new Publisher<Observable<Integer>>() {
+                    @Override
+                    public void subscribe(final Subscriber<? super Observable<Integer>> subscriber) {
+                        BooleanSubscription bs = new BooleanSubscription();
+                        subscriber.onSubscribe(bs);
+                        subscriber.onNext(Observable.just(1));
+                        isUnsubscribed.set(bs.isCancelled());
+                    }
+                })
+        ).take(1).subscribe();
+        assertTrue("Switch doesn't propagate 'unsubscribe'", isUnsubscribed.get());
+    }
+    /** The upstream producer hijacked the switch producer stopping the requests aimed at the inner observables. */
+    @Test
+    public void testIssue2654() {
+        Observable<String> oneItem = Observable.just("Hello").mergeWith(Observable.<String>never());
+        
+        Observable<String> src = oneItem.switchMap(new Function<String, Observable<String>>() {
+            @Override
+            public Observable<String> apply(final String s) {
+                return Observable.just(s)
+                        .mergeWith(Observable.interval(10, TimeUnit.MILLISECONDS)
+                        .map(new Function<Long, String>() {
+                            @Override
+                            public String apply(Long i) {
+                                return s + " " + i;
+                            }
+                        })).take(250);
+            }
+        })
+        .share()
+        ;
+        
+        TestSubscriber<String> ts = new TestSubscriber<String>() {
+            @Override
+            public void onNext(String t) {
+                super.onNext(t);
+                if (valueCount() == 250) {
+                    onComplete();
+                    dispose();
+                }
+            }
+        };
+        src.subscribe(ts);
+        
+        ts.awaitTerminalEvent(10, TimeUnit.SECONDS);
+        
+        System.out.println("> testIssue2654: " + ts.valueCount());
+        
+        ts.assertTerminated();
+        ts.assertNoErrors();
+        
+        Assert.assertEquals(250, ts.valueCount());
+    }
+    
+    @Test(timeout = 10000)
+    public void testInitialRequestsAreAdditive() {
+        TestSubscriber<Long> ts = new TestSubscriber<>((Long)null);
+        Observable.switchOnNext(
+                Observable.interval(100, TimeUnit.MILLISECONDS)
+                          .map(
+                                new Function<Long, Observable<Long>>() {
+                                    @Override
+                                    public Observable<Long> apply(Long t) {
+                                        return Observable.just(1L, 2L, 3L);
+                                    }
+                                }
+                          ).take(3))
+                          .subscribe(ts);
+        ts.request(Long.MAX_VALUE - 100);
+        ts.request(1);
+        ts.awaitTerminalEvent();
+    }
+    
+    @Test(timeout = 10000)
+    public void testInitialRequestsDontOverflow() {
+        TestSubscriber<Long> ts = new TestSubscriber<>((Long)null);
+        Observable.switchOnNext(
+                Observable.interval(100, TimeUnit.MILLISECONDS)
+                        .map(new Function<Long, Observable<Long>>() {
+                            @Override
+                            public Observable<Long> apply(Long t) {
+                                return Observable.fromIterable(Arrays.asList(1L, 2L, 3L));
+                            }
+                        }).take(3)).subscribe(ts);
+        ts.request(Long.MAX_VALUE - 1);
+        ts.request(2);
+        ts.awaitTerminalEvent();
+        assertTrue(ts.valueCount() > 0);
+    }
+    
+    
+    @Test(timeout = 10000)
+    public void testSecondaryRequestsDontOverflow() throws InterruptedException {
+        TestSubscriber<Long> ts = new TestSubscriber<>((Long)null);
+        Observable.switchOnNext(
+                Observable.interval(100, TimeUnit.MILLISECONDS)
+                        .map(new Function<Long, Observable<Long>>() {
+                            @Override
+                            public Observable<Long> apply(Long t) {
+                                return Observable.fromIterable(Arrays.asList(1L, 2L, 3L));
+                            }
+                        }).take(3)).subscribe(ts);
+        ts.request(1);
+        //we will miss two of the first observable
+        Thread.sleep(250);
+        ts.request(Long.MAX_VALUE - 1);
+        ts.request(Long.MAX_VALUE - 1);
+        ts.awaitTerminalEvent();
+        ts.assertValueCount(7);
+    }
+    
+    @Test(timeout = 10000)
+    @Ignore("Request pattern changed and I can't decide if this is okay or not")
+    public void testSecondaryRequestsAdditivelyAreMoreThanLongMaxValueInducesMaxValueRequestFromUpstream()
+            throws InterruptedException {
+        final List<Long> requests = new CopyOnWriteArrayList<>();
+
+        TestSubscriber<Long> ts = new TestSubscriber<>(1L);
+        Observable.switchOnNext(
+                Observable.interval(100, TimeUnit.MILLISECONDS)
+                        .map(new Function<Long, Observable<Long>>() {
+                            @Override
+                            public Observable<Long> apply(Long t) {
+                                return Observable.fromIterable(Arrays.asList(1L, 2L, 3L))
+                                        .doOnRequest(v -> requests.add(v));
+                            }
+                        }).take(3)).subscribe(ts);
+        // we will miss two of the first observables
+        Thread.sleep(250);
+        ts.request(Long.MAX_VALUE - 1);
+        ts.request(Long.MAX_VALUE - 1);
+        ts.awaitTerminalEvent();
+        assertTrue(ts.valueCount() > 0);
+        System.out.println(requests);
+        assertEquals(5, requests.size());
+        assertEquals(Long.MAX_VALUE, (long) requests.get(requests.size()-1));
+    }
+
+}
\ No newline at end of file
