diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java
index b38f5302ac..8c8f7321b4 100644
--- a/src/main/java/io/reactivex/Observable.java
+++ b/src/main/java/io/reactivex/Observable.java
@@ -7966,7 +7966,7 @@ public final Completable ignoreElements() {
 
     /**
      * Modifies an ObservableSource to perform its emissions and notifications on a specified {@link Scheduler},
-     * asynchronously with a bounded buffer of {@link Flowable#bufferSize()} slots.
+     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size".
      *
      * <p>Note that onError notifications will cut ahead of onNext notifications on the emission thread if Scheduler is truly
      * asynchronous. If strict event ordering is required, consider using the {@link #observeOn(Scheduler, boolean)} overload.
@@ -7976,7 +7976,9 @@ public final Completable ignoreElements() {
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>You specify which {@link Scheduler} this operator will use</dd>
      * </dl>
-     *
+     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed
+     * on the other side of the asynchronous boundary.
+     * 
      * @param scheduler
      *            the {@link Scheduler} to notify {@link Observer}s on
      * @return the source ObservableSource modified so that its {@link Observer}s are notified on the specified
@@ -7994,13 +7996,15 @@ public final Completable ignoreElements() {
 
     /**
      * Modifies an ObservableSource to perform its emissions and notifications on a specified {@link Scheduler},
-     * asynchronously with a bounded buffer and optionally delays onError notifications.
+     * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size" and optionally delays onError notifications.
      * <p>
      * <img width="640" height="308" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>You specify which {@link Scheduler} this operator will use</dd>
      * </dl>
+     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed
+     * on the other side of the asynchronous boundary.
      *
      * @param scheduler
      *            the {@link Scheduler} to notify {@link Observer}s on
@@ -8023,13 +8027,15 @@ public final Completable ignoreElements() {
 
     /**
      * Modifies an ObservableSource to perform its emissions and notifications on a specified {@link Scheduler},
-     * asynchronously with a bounded buffer of configurable size and optionally delays onError notifications.
+     * asynchronously with an unbounded buffer of configurable "island size" and optionally delays onError notifications.
      * <p>
      * <img width="640" height="308" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>You specify which {@link Scheduler} this operator will use</dd>
      * </dl>
+     * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed
+     * on the other side of the asynchronous boundary. Values below 16 are not recommended in performance sensitive scenarios.
      *
      * @param scheduler
      *            the {@link Scheduler} to notify {@link Observer}s on
diff --git a/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java
index 45c3b9e83d..c83846f161 100644
--- a/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java
+++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java
@@ -121,6 +121,11 @@ public void drain(boolean delayError, Disposable dispose) {
             QueueDrainHelper.drainLoop(queue, actual, delayError, dispose, this);
         }
     }
+
+    @Override
+    public void accept(Observer<? super V> a, U v) {
+        // ignored by default
+    }
 }
 
 // -------------------------------------------------------------------
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
index 1b9b31a7ab..11d0b9cf3a 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
@@ -125,7 +125,9 @@ public void onComplete() {
             if (!DisposableHelper.isDisposed(d)) {
                 @SuppressWarnings("unchecked")
                 DebounceEmitter<T> de = (DebounceEmitter<T>)d;
-                de.emit();
+                if (de != null) {
+                    de.emit();
+                }
                 DisposableHelper.dispose(timer);
                 worker.dispose();
                 actual.onComplete();
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDematerialize.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDematerialize.java
index c64289861d..c975afbb4a 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDematerialize.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDematerialize.java
@@ -52,6 +52,9 @@ public void onSubscribe(Subscription s) {
         @Override
         public void onNext(Notification<T> t) {
             if (done) {
+                if (t.isOnError()) {
+                    RxJavaPlugins.onError(t.getError());
+                }
                 return;
             }
             if (t.isOnError()) {
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletable.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletable.java
index 390e746942..102b63adc2 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletable.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletable.java
@@ -150,14 +150,12 @@ public void onError(Throwable e) {
         @Override
         public void onComplete() {
             if (decrementAndGet() == 0) {
-                if (delayErrors) {
-                    Throwable ex = errors.terminate();
-                    if (ex != null) {
-                        actual.onError(ex);
-                        return;
-                    }
+                Throwable ex = errors.terminate();
+                if (ex != null) {
+                    actual.onError(ex);
+                } else {
+                    actual.onComplete();
                 }
-                actual.onComplete();
             } else {
                 if (maxConcurrency != Integer.MAX_VALUE) {
                     s.request(1);
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletableCompletable.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletableCompletable.java
index 2332b73f74..231f333e56 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletableCompletable.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletableCompletable.java
@@ -159,14 +159,12 @@ public void onError(Throwable e) {
         @Override
         public void onComplete() {
             if (decrementAndGet() == 0) {
-                if (delayErrors) {
-                    Throwable ex = errors.terminate();
-                    if (ex != null) {
-                        actual.onError(ex);
-                        return;
-                    }
+                Throwable ex = errors.terminate();
+                if (ex != null) {
+                    actual.onError(ex);
+                } else {
+                    actual.onComplete();
                 }
-                actual.onComplete();
             } else {
                 if (maxConcurrency != Integer.MAX_VALUE) {
                     s.request(1);
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java
index 9eb56adbb4..c06222ad47 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java
@@ -24,6 +24,7 @@
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.*;
 import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class FlowableObserveOn<T> extends AbstractFlowableWithUpstream<T, T> {
 final Scheduler scheduler;
@@ -99,6 +100,9 @@ public void subscribeActual(Subscriber<? super T> s) {
 
         @Override
         public final void onNext(T t) {
+            if (done) {
+                return;
+            }
             if (sourceMode == ASYNC) {
                 trySchedule();
                 return;
@@ -114,6 +118,10 @@ public final void onNext(T t) {
 
         @Override
         public final void onError(Throwable t) {
+            if (done) {
+                RxJavaPlugins.onError(t);
+                return;
+            }
             error = t;
             done = true;
             trySchedule();
@@ -121,8 +129,10 @@ public final void onError(Throwable t) {
 
         @Override
         public final void onComplete() {
-            done = true;
-            trySchedule();
+            if (!done) {
+                done = true;
+                trySchedule();
+            }
         }
 
         @Override
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
index e0349f47dc..dbfb65eabd 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
@@ -97,7 +97,7 @@ public void subscribe(Subscriber<? super T> child) {
                  * Note: although technically correct, concurrent disconnects can cause
                  * unexpected behavior such as child subscribers never receiving anything
                  * (unless connected again). An alternative approach, similar to
-                 * PublishSubject would be to immediately terminate such child
+                 * PublishProcessor would be to immediately terminate such child
                  * subscribers as well:
                  *
                  * Object term = r.terminalEvent;
@@ -172,7 +172,7 @@ public void connect(Consumer<? super Disposable> connection) {
          * Disposable as subscribe() may never return on its own.
          *
          * Note however, that asynchronously disconnecting a running source might leave
-         * child subscribers without any terminal event; PublishSubject does not have this
+         * child subscribers without any terminal event; PublishProcessor does not have this
          * issue because the cancellation was always triggered by the child subscribers
          * themselves.
          */
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
index 1d16b92392..5a119573af 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
@@ -227,17 +227,26 @@ public void subscribe(Subscriber<? super T> child) {
 
                     // create the backpressure-managing producer for this child
                     InnerSubscription<T> inner = new InnerSubscription<T>(r, child);
+                    // the producer has been registered with the current subscriber-to-source so
+                    // at least it will receive the next terminal event
+                    // setting the producer will trigger the first request to be considered by
+                    // the subscriber-to-source.
+                    child.onSubscribe(inner);
                     // we try to add it to the array of subscribers
                     // if it fails, no worries because we will still have its buffer
                     // so it is going to replay it for us
                     r.add(inner);
+
+                    if (inner.isDisposed()) {
+                        r.remove(inner);
+                        return;
+                    }
+
+                    r.manageRequests();
+
                     // trigger the capturing of the current node and total requested
                     r.buffer.replay(inner);
-                    // the producer has been registered with the current subscriber-to-source so
-                    // at least it will receive the next terminal event
-                    // setting the producer will trigger the first request to be considered by
-                    // the subscriber-to-source.
-                    child.onSubscribe(inner);
+
                     break; // NOPMD
                 }
             }
@@ -315,6 +324,9 @@ public void connect(Consumer<? super Disposable> connection) {
         try {
             connection.accept(ps);
         } catch (Throwable ex) {
+            if (doConnect) {
+                ps.shouldConnect.compareAndSet(true, false);
+            }
             Exceptions.throwIfFatal(ex);
             throw ExceptionHelper.wrapOrThrow(ex);
         }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicate.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicate.java
index a6f3bd42f2..f68d742a75 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicate.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicate.java
@@ -18,6 +18,7 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Predicate;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class FlowableTakeUntilPredicate<T> extends AbstractFlowableWithUpstream<T, T> {
     final Predicate<? super T> predicate;
@@ -75,6 +76,8 @@ public void onError(Throwable t) {
             if (!done) {
                 done = true;
                 actual.onError(t);
+            } else {
+                RxJavaPlugins.onError(t);
             }
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java
index 9590bfe3b6..98e1d9bfbb 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java
@@ -196,6 +196,11 @@ public void onNext(Object t) {
 
         @Override
         public void onError(Throwable t) {
+            if (done) {
+                RxJavaPlugins.onError(t);
+                return;
+            }
+            done = true;
             parent.onError(t);
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
index d31254d67a..991d743656 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
@@ -156,15 +156,14 @@ public void onComplete() {
             U b;
             synchronized (this) {
                 b = buffer;
-                if (b == null) {
-                    return;
-                }
                 buffer = null;
             }
-            queue.offer(b);
-            done = true;
-            if (enter()) {
-                QueueDrainHelper.drainLoop(queue, actual, false, this, this);
+            if (b != null) {
+                queue.offer(b);
+                done = true;
+                if (enter()) {
+                    QueueDrainHelper.drainLoop(queue, actual, false, this, this);
+                }
             }
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java
index 3682ad3a41..05a8532db3 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java
@@ -213,19 +213,6 @@ void removeInner(InnerObserver<T, U> inner) {
             }
         }
 
-        SimpleQueue<U> getMainQueue() {
-            SimpleQueue<U> q = queue;
-            if (q == null) {
-                if (maxConcurrency == Integer.MAX_VALUE) {
-                    q = new SpscLinkedArrayQueue<U>(bufferSize);
-                } else {
-                    q = new SpscArrayQueue<U>(maxConcurrency);
-                }
-                queue = q;
-            }
-            return q;
-        }
-
         void tryEmitScalar(Callable<? extends U> value) {
             U u;
             try {
@@ -248,7 +235,16 @@ void tryEmitScalar(Callable<? extends U> value) {
                     return;
                 }
             } else {
-                SimpleQueue<U> q = getMainQueue();
+                SimpleQueue<U> q = queue;
+                if (q == null) {
+                    if (maxConcurrency == Integer.MAX_VALUE) {
+                        q = new SpscLinkedArrayQueue<U>(bufferSize);
+                    } else {
+                        q = new SpscArrayQueue<U>(maxConcurrency);
+                    }
+                    queue = q;
+                }
+
                 if (!q.offer(u)) {
                     onError(new IllegalStateException("Scalar queue full?!"));
                     return;
@@ -260,15 +256,6 @@ void tryEmitScalar(Callable<? extends U> value) {
             drainLoop();
         }
 
-        SimpleQueue<U> getInnerQueue(InnerObserver<T, U> inner) {
-            SimpleQueue<U> q = inner.queue;
-            if (q == null) {
-                q = new SpscLinkedArrayQueue<U>(bufferSize);
-                inner.queue = q;
-            }
-            return q;
-        }
-
         void tryEmit(U value, InnerObserver<T, U> inner) {
             if (get() == 0 && compareAndSet(0, 1)) {
                 actual.onNext(value);
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletable.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletable.java
index 1a4df48f8c..de134b3813 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletable.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletable.java
@@ -128,14 +128,12 @@ public void onError(Throwable e) {
         @Override
         public void onComplete() {
             if (decrementAndGet() == 0) {
-                if (delayErrors) {
-                    Throwable ex = errors.terminate();
-                    if (ex != null) {
-                        actual.onError(ex);
-                        return;
-                    }
+                Throwable ex = errors.terminate();
+                if (ex != null) {
+                    actual.onError(ex);
+                } else {
+                    actual.onComplete();
                 }
-                actual.onComplete();
             }
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletableCompletable.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletableCompletable.java
index 6ac1c94456..59efef1603 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletableCompletable.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletableCompletable.java
@@ -13,7 +13,7 @@
 
 package io.reactivex.internal.operators.observable;
 
-import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.*;
 
 import io.reactivex.*;
 import io.reactivex.disposables.*;
@@ -22,7 +22,6 @@
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.FuseToObservable;
-import io.reactivex.internal.observers.BasicIntQueueDisposable;
 import io.reactivex.internal.util.AtomicThrowable;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -55,8 +54,7 @@ protected void subscribeActual(CompletableObserver observer) {
         return RxJavaPlugins.onAssembly(new ObservableFlatMapCompletable<T>(source, mapper, delayErrors));
     }
 
-    static final class FlatMapCompletableMainObserver<T> extends BasicIntQueueDisposable<T>
-    implements Observer<T> {
+    static final class FlatMapCompletableMainObserver<T> extends AtomicInteger implements Disposable, Observer<T> {
         private static final long serialVersionUID = 8443155186132538303L;
 
         final CompletableObserver actual;
@@ -136,14 +134,12 @@ public void onError(Throwable e) {
         @Override
         public void onComplete() {
             if (decrementAndGet() == 0) {
-                if (delayErrors) {
-                    Throwable ex = errors.terminate();
-                    if (ex != null) {
-                        actual.onError(ex);
-                        return;
-                    }
+                Throwable ex = errors.terminate();
+                if (ex != null) {
+                    actual.onError(ex);
+                } else {
+                    actual.onComplete();
                 }
-                actual.onComplete();
             }
         }
 
@@ -158,26 +154,6 @@ public boolean isDisposed() {
             return d.isDisposed();
         }
 
-        @Override
-        public T poll() throws Exception {
-            return null; // always empty
-        }
-
-        @Override
-        public boolean isEmpty() {
-            return true; // always empty
-        }
-
-        @Override
-        public void clear() {
-            // nothing to clear
-        }
-
-        @Override
-        public int requestFusion(int mode) {
-            return mode & ASYNC;
-        }
-
         void innerComplete(InnerObserver inner) {
             set.delete(inner);
             onComplete();
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableGroupBy.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableGroupBy.java
index f899bd6062..d63a948d62 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableGroupBy.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableGroupBy.java
@@ -254,12 +254,7 @@ public void subscribe(Observer<? super T> s) {
         }
 
         public void onNext(T t) {
-            if (t == null) {
-                error = new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
-                done = true;
-            } else {
-                queue.offer(t);
-            }
+            queue.offer(t);
             drain();
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableRange.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableRange.java
index f663a44169..de836d4ae2 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableRange.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRange.java
@@ -12,30 +12,30 @@
  */
 package io.reactivex.internal.operators.observable;
 
-import java.util.concurrent.atomic.AtomicInteger;
-
 import io.reactivex.*;
-import io.reactivex.internal.fuseable.QueueDisposable;
+import io.reactivex.internal.observers.BasicIntQueueDisposable;
 
+/**
+ * Emits a range of integer values from start to end.
+ */
 public final class ObservableRange extends Observable<Integer> {
     private final int start;
-    private final int count;
+    private final long end;
 
     public ObservableRange(int start, int count) {
         this.start = start;
-        this.count = count;
+        this.end = (long)start + count;
     }
 
     @Override
     protected void subscribeActual(Observer<? super Integer> o) {
-        RangeDisposable parent = new RangeDisposable(o, start, (long)start + count);
+        RangeDisposable parent = new RangeDisposable(o, start, end);
         o.onSubscribe(parent);
         parent.run();
     }
 
     static final class RangeDisposable
-    extends AtomicInteger
-    implements QueueDisposable<Integer> {
+    extends BasicIntQueueDisposable<Integer> {
 
         private static final long serialVersionUID = 396518478098735504L;
 
@@ -68,16 +68,6 @@ void run() {
             }
         }
 
-        @Override
-        public boolean offer(Integer value) {
-            throw new UnsupportedOperationException("Should not be called!");
-        }
-
-        @Override
-        public boolean offer(Integer v1, Integer v2) {
-            throw new UnsupportedOperationException("Should not be called!");
-        }
-
         @Override
         public Integer poll() throws Exception {
             long i = index;
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableScanSeed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableScanSeed.java
index 78b73de5e2..96638e020c 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableScanSeed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableScanSeed.java
@@ -87,6 +87,10 @@ public boolean isDisposed() {
 
         @Override
         public void onNext(T t) {
+            if (done) {
+                return;
+            }
+
             R v = value;
 
             R u;
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableSkipUntil.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableSkipUntil.java
index 3e2421c8b5..4c86c03377 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableSkipUntil.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSkipUntil.java
@@ -13,8 +13,6 @@
 
 package io.reactivex.internal.operators.observable;
 
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.*;
@@ -34,6 +32,8 @@ public void subscribeActual(Observer<? super T> child) {
 
         final ArrayCompositeDisposable frc = new ArrayCompositeDisposable(2);
 
+        serial.onSubscribe(frc);
+
         final SkipUntilObserver<T> sus = new SkipUntilObserver<T>(serial, frc);
 
         other.subscribe(new Observer<U>() {
@@ -55,12 +55,7 @@ public void onNext(U t) {
             @Override
             public void onError(Throwable t) {
                 frc.dispose();
-                // in case the other emits an onError before the main even sets a subscription
-                if (sus.compareAndSet(false, true)) {
-                    EmptyDisposable.error(t, serial);
-                } else {
-                    serial.onError(t);
-                }
+                serial.onError(t);
             }
 
             @Override
@@ -72,9 +67,8 @@ public void onComplete() {
         source.subscribe(sus);
     }
 
-    static final class SkipUntilObserver<T> extends AtomicBoolean implements Observer<T>, Disposable {
+    static final class SkipUntilObserver<T> implements Observer<T> {
 
-        private static final long serialVersionUID = -1113667257122396604L;
         final Observer<? super T> actual;
         final ArrayCompositeDisposable frc;
 
@@ -92,11 +86,7 @@ public void onComplete() {
         public void onSubscribe(Disposable s) {
             if (DisposableHelper.validate(this.s, s)) {
                 this.s = s;
-                if (frc.setResource(0, s)) {
-                    if (compareAndSet(false, true)) {
-                        actual.onSubscribe(this);
-                    }
-                }
+                frc.setResource(0, s);
             }
         }
 
@@ -122,15 +112,5 @@ public void onComplete() {
             frc.dispose();
             actual.onComplete();
         }
-
-        @Override
-        public void dispose() {
-            frc.dispose();
-        }
-
-        @Override
-        public boolean isDisposed() {
-            return frc.isDisposed();
-        }
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundary.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundary.java
index f6a30897d9..2a473ef60b 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundary.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundary.java
@@ -17,9 +17,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.disposables.DisposableHelper;
-import io.reactivex.internal.fuseable.SimpleQueue;
 import io.reactivex.internal.observers.QueueDrainObserver;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.util.NotificationLite;
@@ -116,7 +114,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
-                RxJavaPlugins.onError(error);
+                RxJavaPlugins.onError(t);
                 return;
             }
             error = t;
@@ -161,7 +159,7 @@ public boolean isDisposed() {
         }
 
         void drainLoop() {
-            final SimpleQueue<Object> q = queue;
+            final MpscLinkedQueue<Object> q = (MpscLinkedQueue<Object>)queue;
             final Observer<? super Observable<T>> a = actual;
             int missed = 1;
             UnicastSubject<T> w = window;
@@ -170,16 +168,7 @@ void drainLoop() {
                 for (;;) {
                     boolean d = done;
 
-                    Object o;
-
-                    try {
-                        o = q.poll();
-                    } catch (Throwable ex) {
-                        Exceptions.throwIfFatal(ex);
-                        DisposableHelper.dispose(boundary);
-                        w.onError(ex);
-                        return;
-                    }
+                    Object o = q.poll();
 
                     boolean empty = o == null;
 
@@ -237,11 +226,6 @@ void next() {
                 drainLoop();
             }
         }
-
-        @Override
-        public void accept(Observer<? super Observable<T>> a, Object v) {
-            // not used by this operator
-        }
     }
 
     static final class WindowBoundaryInnerObserver<T, B> extends DisposableObserver<B> {
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java
index 1d749909cf..d15a412558 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java
@@ -13,7 +13,6 @@
 
 package io.reactivex.internal.operators.observable;
 
-import io.reactivex.internal.functions.ObjectHelper;
 import java.util.*;
 import java.util.concurrent.atomic.*;
 
@@ -24,7 +23,7 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.disposables.DisposableHelper;
-import io.reactivex.internal.fuseable.SimpleQueue;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.observers.QueueDrainObserver;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.util.NotificationLite;
@@ -178,7 +177,7 @@ void disposeBoundary() {
         }
 
         void drainLoop() {
-            final SimpleQueue<Object> q = queue;
+            final MpscLinkedQueue<Object> q = (MpscLinkedQueue<Object>)queue;
             final Observer<? super Observable<T>> a = actual;
             final List<UnicastSubject<T>> ws = this.ws;
             int missed = 1;
@@ -188,18 +187,7 @@ void drainLoop() {
                 for (;;) {
                     boolean d = done;
 
-                    Object o;
-
-                    try {
-                        o = q.poll();
-                    } catch (Throwable ex) {
-                        Exceptions.throwIfFatal(ex);
-                        DisposableHelper.dispose(boundary);
-                        for (UnicastSubject<T> w : ws) {
-                            w.onError(ex);
-                        }
-                        return;
-                    }
+                    Object o = q.poll();
 
                     boolean empty = o == null;
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
index c5218df97d..c11f47ec7e 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
@@ -13,7 +13,6 @@
 
 package io.reactivex.internal.operators.observable;
 
-import io.reactivex.internal.functions.ObjectHelper;
 import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.*;
 
@@ -21,7 +20,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.disposables.DisposableHelper;
-import io.reactivex.internal.fuseable.SimpleQueue;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.observers.QueueDrainObserver;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.util.NotificationLite;
@@ -131,7 +130,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (done) {
-                RxJavaPlugins.onError(error);
+                RxJavaPlugins.onError(t);
                 return;
             }
             error = t;
@@ -176,7 +175,7 @@ public boolean isDisposed() {
         }
 
         void drainLoop() {
-            final SimpleQueue<Object> q = queue;
+            final MpscLinkedQueue<Object> q = (MpscLinkedQueue<Object>)queue;
             final Observer<? super Observable<T>> a = actual;
             int missed = 1;
             UnicastSubject<T> w = window;
@@ -185,16 +184,7 @@ void drainLoop() {
                 for (;;) {
                     boolean d = done;
 
-                    Object o;
-
-                    try {
-                        o = q.poll();
-                    } catch (Throwable ex) {
-                        Exceptions.throwIfFatal(ex);
-                        DisposableHelper.dispose(boundary);
-                        w.onError(ex);
-                        return;
-                    }
+                    Object o = q.poll();
                     boolean empty = o == null;
 
                     if (d && empty) {
@@ -268,11 +258,6 @@ void next() {
                 drainLoop();
             }
         }
-
-        @Override
-        public void accept(Observer<? super Observable<T>> a, Object v) {
-            // not used by this operator
-        }
     }
 
     static final class WindowBoundaryInnerObserver<T, B> extends DisposableObserver<B> {
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java
index 8b4c8a8932..490b54cccf 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java
@@ -24,7 +24,6 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.disposables.DisposableHelper;
-import io.reactivex.internal.fuseable.SimpleQueue;
 import io.reactivex.internal.observers.QueueDrainObserver;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.util.NotificationLite;
@@ -191,7 +190,7 @@ public void run() {
 
         void drainLoop() {
 
-            final SimpleQueue<Object> q = queue;
+            final MpscLinkedQueue<Object> q = (MpscLinkedQueue<Object>)queue;
             final Observer<? super Observable<T>> a = actual;
             UnicastSubject<T> w = window;
 
@@ -253,11 +252,6 @@ void drainLoop() {
                 }
             }
         }
-
-        @Override
-        public void accept(Observer<? super Observable<T>> a, Object v) {
-            // not used in this operator
-        }
     }
 
     static final class WindowExactBoundedObserver<T>
@@ -326,9 +320,7 @@ public void onSubscribe(Disposable s) {
                     d = scheduler.schedulePeriodicallyDirect(consumerIndexHolder, timespan, timespan, unit);
                 }
 
-                if (!timer.compareAndSet(null, d)) {
-                    d.dispose();
-                }
+                DisposableHelper.replace(timer, d);
             }
         }
 
@@ -358,9 +350,8 @@ public void onNext(T t) {
                         tm.dispose();
                         Disposable task = worker.schedulePeriodically(
                                 new ConsumerIndexHolder(producerIndex, this), timespan, timespan, unit);
-                        if (!timer.compareAndSet(tm, task)) {
-                            task.dispose();
-                        }
+
+                        DisposableHelper.replace(timer, task);
                     }
                 } else {
                     count = c;
@@ -415,13 +406,8 @@ void disposeTimer() {
             DisposableHelper.dispose(timer);
         }
 
-        @Override
-        public void accept(Observer<? super Observable<T>> a, Object v) {
-            // not needed in this operator
-        }
-
         void drainLoop() {
-            final SimpleQueue<Object> q = queue;
+            final MpscLinkedQueue<Object> q = (MpscLinkedQueue<Object>)queue;
             final Observer<? super Observable<T>> a = actual;
             UnicastSubject<T> w = window;
 
@@ -438,16 +424,7 @@ void drainLoop() {
 
                     boolean d = done;
 
-                    Object o;
-
-                    try {
-                        o = q.poll();
-                    } catch (Throwable ex) {
-                        Exceptions.throwIfFatal(ex);
-                        disposeTimer();
-                        w.onError(ex);
-                        return;
-                    }
+                    Object o = q.poll();
 
                     boolean empty = o == null;
                     boolean isHolder = o instanceof ConsumerIndexHolder;
@@ -650,11 +627,6 @@ void disposeWorker() {
             worker.dispose();
         }
 
-        @Override
-        public void accept(Observer<? super Observable<T>> a, Object v) {
-            // not used by this operator
-        }
-
         void complete(UnicastSubject<T> w) {
             queue.offer(new SubjectWork<T>(w, false));
             if (enter()) {
@@ -664,7 +636,7 @@ void complete(UnicastSubject<T> w) {
 
         @SuppressWarnings("unchecked")
         void drainLoop() {
-            final SimpleQueue<Object> q = queue;
+            final MpscLinkedQueue<Object> q = (MpscLinkedQueue<Object>)queue;
             final Observer<? super Observable<T>> a = actual;
             final List<UnicastSubject<T>> ws = windows;
 
@@ -683,18 +655,7 @@ void drainLoop() {
 
                     boolean d = done;
 
-                    Object v;
-
-                    try {
-                        v = q.poll();
-                    } catch (Throwable ex) {
-                        Exceptions.throwIfFatal(ex);
-                        disposeWorker();
-                        for (UnicastSubject<T> w : ws) {
-                            w.onError(ex);
-                        }
-                        return;
-                    }
+                    Object v = q.poll();
 
                     boolean empty = v == null;
                     boolean sw = v instanceof SubjectWork;
diff --git a/src/test/java/io/reactivex/TestHelper.java b/src/test/java/io/reactivex/TestHelper.java
index dcac3c99d9..f8b3c734c7 100644
--- a/src/test/java/io/reactivex/TestHelper.java
+++ b/src/test/java/io/reactivex/TestHelper.java
@@ -28,7 +28,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.*;
-import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.operators.maybe.MaybeToFlowable;
@@ -144,22 +144,37 @@ public void accept(Throwable t) {
     }
 
     public static void assertError(List<Throwable> list, int index, Class<? extends Throwable> clazz) {
-        assertTrue(list.get(index).toString(), clazz.isInstance(list.get(index)));
+        try {
+            assertTrue(list.get(index).toString(), clazz.isInstance(list.get(index)));
+        } catch (AssertionError e) {
+            list.get(index).printStackTrace();
+            throw e;
+        }
     }
 
     public static void assertError(List<Throwable> list, int index, Class<? extends Throwable> clazz, String message) {
-        assertTrue(list.get(index).toString(), clazz.isInstance(list.get(index)));
-        assertEquals(message, list.get(index).getMessage());
+        try {
+            assertTrue(list.get(index).toString(), clazz.isInstance(list.get(index)));
+            assertEquals(message, list.get(index).getMessage());
+        } catch (AssertionError e) {
+            list.get(index).printStackTrace();
+            throw e;
+        }
     }
 
     public static void assertError(TestObserver<?> ts, int index, Class<? extends Throwable> clazz) {
         Throwable ex = ts.errors().get(0);
-        if (ex instanceof CompositeException) {
-            CompositeException ce = (CompositeException) ex;
-            List<Throwable> cel = ce.getExceptions();
-            assertTrue(cel.get(index).toString(), clazz.isInstance(cel.get(index)));
-        } else {
-            fail(ex.toString() + ": not a CompositeException");
+        try {
+            if (ex instanceof CompositeException) {
+                CompositeException ce = (CompositeException) ex;
+                List<Throwable> cel = ce.getExceptions();
+                assertTrue(cel.get(index).toString(), clazz.isInstance(cel.get(index)));
+            } else {
+                fail(ex.toString() + ": not a CompositeException");
+            }
+        } catch (AssertionError e) {
+            ex.printStackTrace();
+            throw e;
         }
     }
 
@@ -586,7 +601,7 @@ public static void doubleOnSubscribe(MaybeObserver<?> subscriber) {
      * @param source the source to test
      */
     public static void checkDisposed(Flowable<?> source) {
-        // actually there is no way of testing this
+        source.test(0L, true).assertEmpty();
     }
     /**
      * Checks if the upstream's Disposable sent through the onSubscribe reports
@@ -2195,4 +2210,328 @@ public void onComplete() {
     public static List<Throwable> errorList(TestSubscriber<?> to) {
         return compositeList(to.errors().get(0));
     }
+
+    /**
+     * Tests the given mapping of a bad Observable by emitting the good values, then an error/completion and then
+     * a bad value followed by a TestException and and a completion.
+     * @param <T> the value type
+     * @param mapper the mapper that receives a bad Observable and returns a reactive base type (detected via reflection).
+     * @param error if true, the good value emission is followed by a TestException("error"), if false then onComplete is called
+     * @param badValue the bad value to emit if not null
+     * @param goodValue the good value to emit before turning bad, if not null
+     * @param expected the expected resulting values, null to ignore values received
+     */
+    public static <T> void checkBadSourceObservable(Function<Observable<T>, Object> mapper,
+            final boolean error, final T goodValue, final T badValue, final Object... expected) {
+        List<Throwable> errors = trackPluginErrors();
+        try {
+            Observable<T> bad = new Observable<T>() {
+                boolean once;
+                @Override
+                protected void subscribeActual(Observer<? super T> observer) {
+                    observer.onSubscribe(Disposables.empty());
+
+                    if (once) {
+                        return;
+                    }
+                    once = true;
+
+                    if (goodValue != null) {
+                        observer.onNext(goodValue);
+                    }
+
+                    if (error) {
+                        observer.onError(new TestException("error"));
+                    } else {
+                        observer.onComplete();
+                    }
+
+                    if (badValue != null) {
+                        observer.onNext(badValue);
+                    }
+                    observer.onError(new TestException("second"));
+                    observer.onComplete();
+                }
+            };
+
+            Object o = mapper.apply(bad);
+
+            if (o instanceof ObservableSource) {
+                ObservableSource<?> os = (ObservableSource<?>) o;
+                TestObserver<Object> to = new TestObserver<Object>();
+
+                os.subscribe(to);
+
+                to.awaitDone(5, TimeUnit.SECONDS);
+
+                to.assertSubscribed();
+
+                if (expected != null) {
+                    to.assertValues(expected);
+                }
+                if (error) {
+                    to.assertError(TestException.class)
+                    .assertErrorMessage("error")
+                    .assertNotComplete();
+                } else {
+                    to.assertNoErrors().assertComplete();
+                }
+            }
+
+            if (o instanceof Publisher) {
+                Publisher<?> os = (Publisher<?>) o;
+                TestSubscriber<Object> to = new TestSubscriber<Object>();
+
+                os.subscribe(to);
+
+                to.awaitDone(5, TimeUnit.SECONDS);
+
+                to.assertSubscribed();
+
+                if (expected != null) {
+                    to.assertValues(expected);
+                }
+                if (error) {
+                    to.assertError(TestException.class)
+                    .assertErrorMessage("error")
+                    .assertNotComplete();
+                } else {
+                    to.assertNoErrors().assertComplete();
+                }
+            }
+
+            if (o instanceof SingleSource) {
+                SingleSource<?> os = (SingleSource<?>) o;
+                TestObserver<Object> to = new TestObserver<Object>();
+
+                os.subscribe(to);
+
+                to.awaitDone(5, TimeUnit.SECONDS);
+
+                to.assertSubscribed();
+
+                if (expected != null) {
+                    to.assertValues(expected);
+                }
+                if (error) {
+                    to.assertError(TestException.class)
+                    .assertErrorMessage("error")
+                    .assertNotComplete();
+                } else {
+                    to.assertNoErrors().assertComplete();
+                }
+            }
+
+            if (o instanceof MaybeSource) {
+                MaybeSource<?> os = (MaybeSource<?>) o;
+                TestObserver<Object> to = new TestObserver<Object>();
+
+                os.subscribe(to);
+
+                to.awaitDone(5, TimeUnit.SECONDS);
+
+                to.assertSubscribed();
+
+                if (expected != null) {
+                    to.assertValues(expected);
+                }
+                if (error) {
+                    to.assertError(TestException.class)
+                    .assertErrorMessage("error")
+                    .assertNotComplete();
+                } else {
+                    to.assertNoErrors().assertComplete();
+                }
+            }
+
+            if (o instanceof CompletableSource) {
+                CompletableSource os = (CompletableSource) o;
+                TestObserver<Object> to = new TestObserver<Object>();
+
+                os.subscribe(to);
+
+                to.awaitDone(5, TimeUnit.SECONDS);
+
+                to.assertSubscribed();
+
+                if (expected != null) {
+                    to.assertValues(expected);
+                }
+                if (error) {
+                    to.assertError(TestException.class)
+                    .assertErrorMessage("error")
+                    .assertNotComplete();
+                } else {
+                    to.assertNoErrors().assertComplete();
+                }
+            }
+
+            assertError(errors, 0, TestException.class, "second");
+        } catch (AssertionError ex) {
+            throw ex;
+        } catch (Throwable ex) {
+            throw new RuntimeException(ex);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    /**
+     * Tests the given mapping of a bad Observable by emitting the good values, then an error/completion and then
+     * a bad value followed by a TestException and and a completion.
+     * @param <T> the value type
+     * @param mapper the mapper that receives a bad Observable and returns a reactive base type (detected via reflection).
+     * @param error if true, the good value emission is followed by a TestException("error"), if false then onComplete is called
+     * @param badValue the bad value to emit if not null
+     * @param goodValue the good value to emit before turning bad, if not null
+     * @param expected the expected resulting values, null to ignore values received
+     */
+    public static <T> void checkBadSourceFlowable(Function<Flowable<T>, Object> mapper,
+            final boolean error, final T goodValue, final T badValue, final Object... expected) {
+        List<Throwable> errors = trackPluginErrors();
+        try {
+            Flowable<T> bad = new Flowable<T>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super T> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+
+                    if (goodValue != null) {
+                        observer.onNext(goodValue);
+                    }
+
+                    if (error) {
+                        observer.onError(new TestException("error"));
+                    } else {
+                        observer.onComplete();
+                    }
+
+                    if (badValue != null) {
+                        observer.onNext(badValue);
+                    }
+                    observer.onError(new TestException("second"));
+                    observer.onComplete();
+                }
+            };
+
+            Object o = mapper.apply(bad);
+
+            if (o instanceof ObservableSource) {
+                ObservableSource<?> os = (ObservableSource<?>) o;
+                TestObserver<Object> to = new TestObserver<Object>();
+
+                os.subscribe(to);
+
+                to.awaitDone(5, TimeUnit.SECONDS);
+
+                to.assertSubscribed();
+
+                if (expected != null) {
+                    to.assertValues(expected);
+                }
+                if (error) {
+                    to.assertError(TestException.class)
+                    .assertErrorMessage("error")
+                    .assertNotComplete();
+                } else {
+                    to.assertNoErrors().assertComplete();
+                }
+            }
+
+            if (o instanceof Publisher) {
+                Publisher<?> os = (Publisher<?>) o;
+                TestSubscriber<Object> to = new TestSubscriber<Object>();
+
+                os.subscribe(to);
+
+                to.awaitDone(5, TimeUnit.SECONDS);
+
+                to.assertSubscribed();
+
+                if (expected != null) {
+                    to.assertValues(expected);
+                }
+                if (error) {
+                    to.assertError(TestException.class)
+                    .assertErrorMessage("error")
+                    .assertNotComplete();
+                } else {
+                    to.assertNoErrors().assertComplete();
+                }
+            }
+
+            if (o instanceof SingleSource) {
+                SingleSource<?> os = (SingleSource<?>) o;
+                TestObserver<Object> to = new TestObserver<Object>();
+
+                os.subscribe(to);
+
+                to.awaitDone(5, TimeUnit.SECONDS);
+
+                to.assertSubscribed();
+
+                if (expected != null) {
+                    to.assertValues(expected);
+                }
+                if (error) {
+                    to.assertError(TestException.class)
+                    .assertErrorMessage("error")
+                    .assertNotComplete();
+                } else {
+                    to.assertNoErrors().assertComplete();
+                }
+            }
+
+            if (o instanceof MaybeSource) {
+                MaybeSource<?> os = (MaybeSource<?>) o;
+                TestObserver<Object> to = new TestObserver<Object>();
+
+                os.subscribe(to);
+
+                to.awaitDone(5, TimeUnit.SECONDS);
+
+                to.assertSubscribed();
+
+                if (expected != null) {
+                    to.assertValues(expected);
+                }
+                if (error) {
+                    to.assertError(TestException.class)
+                    .assertErrorMessage("error")
+                    .assertNotComplete();
+                } else {
+                    to.assertNoErrors().assertComplete();
+                }
+            }
+
+            if (o instanceof CompletableSource) {
+                CompletableSource os = (CompletableSource) o;
+                TestObserver<Object> to = new TestObserver<Object>();
+
+                os.subscribe(to);
+
+                to.awaitDone(5, TimeUnit.SECONDS);
+
+                to.assertSubscribed();
+
+                if (expected != null) {
+                    to.assertValues(expected);
+                }
+                if (error) {
+                    to.assertError(TestException.class)
+                    .assertErrorMessage("error")
+                    .assertNotComplete();
+                } else {
+                    to.assertNoErrors().assertComplete();
+                }
+            }
+
+            assertError(errors, 0, TestException.class, "second");
+        } catch (AssertionError ex) {
+            throw ex;
+        } catch (Throwable ex) {
+            throw new RuntimeException(ex);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableAllTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableAllTest.java
index 02d4314a83..cac67a3e3b 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableAllTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableAllTest.java
@@ -24,7 +24,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
+import io.reactivex.disposables.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
@@ -413,4 +413,35 @@ public boolean test(Integer v) throws Exception {
             RxJavaPlugins.reset();
         }
     }
+
+    @Test
+    public void predicateThrowsObservable() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+
+                    observer.onNext(1);
+                    observer.onNext(2);
+                    observer.onError(new TestException());
+                    observer.onComplete();
+                }
+            }
+            .all(new Predicate<Integer>() {
+                @Override
+                public boolean test(Integer v) throws Exception {
+                    throw new TestException();
+                }
+            })
+            .toFlowable()
+            .test()
+            .assertFailure(TestException.class);
+
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableAnyTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableAnyTest.java
index 63c094d172..c5beccefcb 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableAnyTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableAnyTest.java
@@ -601,4 +601,29 @@ public boolean test(Integer v) throws Exception {
             RxJavaPlugins.reset();
         }
     }
+
+    @Test
+    public void badSourceSingle() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+                    observer.onError(new TestException("First"));
+
+                    observer.onNext(1);
+                    observer.onError(new TestException("Second"));
+                    observer.onComplete();
+                }
+            }
+            .any(Functions.alwaysTrue())
+            .test()
+            .assertFailureAndMessage(TestException.class, "First");
+
+            TestHelper.assertError(errors, 0, TestException.class, "Second");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
index 7db23a2e72..b7f36adf70 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
@@ -1522,7 +1522,6 @@ public void boundaryBoundaryError() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.range(1, 5).buffer(1, TimeUnit.DAYS, Schedulers.single()));
 
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
index 2cae36f9aa..da1ac51efd 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
@@ -299,7 +299,6 @@ public void take() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.range(1, 5).cache());
     }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
index 4aa69c7f84..f25fc7f437 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
@@ -1230,7 +1230,6 @@ public Object apply(Object a, Object b) throws Exception {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void disposed() {
         TestHelper.checkDisposed(Flowable.combineLatest(Flowable.never(), Flowable.never(), new BiFunction<Object, Object, Object>() {
             @Override
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
index 4e81cf44e7..8121964373 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
@@ -831,7 +831,6 @@ public void empty() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.just(1).hide().concatMapEager(new Function<Integer, Flowable<Integer>>() {
             @Override
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
index ecd5825233..b562216a75 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
@@ -13,8 +13,10 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 import org.junit.*;
@@ -22,9 +24,12 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.disposables.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Function;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.TestScheduler;
 import io.reactivex.subscribers.TestSubscriber;
@@ -211,7 +216,7 @@ public void debounceSelectorFuncThrows() {
     }
 
     @Test
-    public void debounceSelectorObservableThrows() {
+    public void debounceSelectorFlowableThrows() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         Function<Integer, Flowable<Integer>> debounceSel = new Function<Integer, Flowable<Integer>>() {
 
@@ -312,4 +317,76 @@ public void debounceDefault() throws Exception {
         .awaitDone(5, TimeUnit.SECONDS)
         .assertResult(1);
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().debounce(1, TimeUnit.SECONDS, new TestScheduler()));
+
+        TestHelper.checkDisposed(PublishProcessor.create().debounce(Functions.justFunction(Flowable.never())));
+
+        Disposable d = new FlowableDebounceTimed.DebounceEmitter<Integer>(1, 1, null);
+        assertFalse(d.isDisposed());
+
+        d.dispose();
+
+        assertTrue(d.isDisposed());
+    }
+
+    @Test
+    public void badSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+                    observer.onComplete();
+                    observer.onNext(1);
+                    observer.onError(new TestException());
+                    observer.onComplete();
+                }
+            }
+            .debounce(1, TimeUnit.SECONDS, new TestScheduler())
+            .test()
+            .assertResult();
+
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void badSourceSelector() {
+        TestHelper.checkBadSourceFlowable(new Function<Flowable<Integer>, Object>() {
+            @Override
+            public Object apply(Flowable<Integer> o) throws Exception {
+                return o.debounce(new Function<Integer, Flowable<Long>>() {
+                    @Override
+                    public Flowable<Long> apply(Integer v) throws Exception {
+                        return Flowable.timer(1, TimeUnit.SECONDS);
+                    }
+                });
+            }
+        }, false, 1, 1, 1);
+
+        TestHelper.checkBadSourceFlowable(new Function<Flowable<Integer>, Object>() {
+            @Override
+            public Object apply(final Flowable<Integer> o) throws Exception {
+                return Flowable.just(1).debounce(new Function<Integer, Flowable<Integer>>() {
+                    @Override
+                    public Flowable<Integer> apply(Integer v) throws Exception {
+                        return o;
+                    }
+                });
+            }
+        }, false, 1, 1, 1);
+    }
+
+    @Test
+    public void debounceWithEmpty() {
+        Flowable.just(1).debounce(Functions.justFunction(Flowable.empty()))
+        .test()
+        .assertResult(1);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java
index a9c11f2d2c..ab53fcced8 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java
@@ -13,14 +13,13 @@
 
 package io.reactivex.internal.operators.flowable;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.*;
+import static org.mockito.ArgumentMatchers.*;
 import static org.mockito.Mockito.*;
 
 import java.util.*;
 import java.util.concurrent.*;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.*;
 
 import org.junit.*;
 import org.mockito.InOrder;
@@ -29,9 +28,10 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.*;
-import io.reactivex.subscribers.TestSubscriber;
+import io.reactivex.subscribers.*;
 
 public class FlowableDelayTest {
     private Subscriber<Long> observer;
@@ -229,7 +229,7 @@ public void testDelaySubscriptionCancelBeforeTime() {
     }
 
     @Test
-    public void testDelayWithObservableNormal1() {
+    public void testDelayWithFlowableNormal1() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final List<PublishProcessor<Integer>> delays = new ArrayList<PublishProcessor<Integer>>();
         final int n = 10;
@@ -264,7 +264,7 @@ public void testDelayWithObservableNormal1() {
     }
 
     @Test
-    public void testDelayWithObservableSingleSend1() {
+    public void testDelayWithFlowableSingleSend1() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final PublishProcessor<Integer> delay = PublishProcessor.create();
 
@@ -290,7 +290,7 @@ public void testDelayWithObservableSingleSend1() {
     }
 
     @Test
-    public void testDelayWithObservableSourceThrows() {
+    public void testDelayWithFlowableSourceThrows() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final PublishProcessor<Integer> delay = PublishProcessor.create();
 
@@ -316,7 +316,7 @@ public void testDelayWithObservableSourceThrows() {
     }
 
     @Test
-    public void testDelayWithObservableDelayFunctionThrows() {
+    public void testDelayWithFlowableDelayFunctionThrows() {
         PublishProcessor<Integer> source = PublishProcessor.create();
 
         Function<Integer, Flowable<Integer>> delayFunc = new Function<Integer, Flowable<Integer>>() {
@@ -339,7 +339,7 @@ public void testDelayWithObservableDelayFunctionThrows() {
     }
 
     @Test
-    public void testDelayWithObservableDelayThrows() {
+    public void testDelayWithFlowableDelayThrows() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final PublishProcessor<Integer> delay = PublishProcessor.create();
 
@@ -364,7 +364,7 @@ public void testDelayWithObservableDelayThrows() {
     }
 
     @Test
-    public void testDelayWithObservableSubscriptionNormal() {
+    public void testDelayWithFlowableSubscriptionNormal() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final PublishProcessor<Integer> delay = PublishProcessor.create();
         Function<Integer, Flowable<Integer>> delayFunc = new Function<Integer, Flowable<Integer>>() {
@@ -393,7 +393,7 @@ public void testDelayWithObservableSubscriptionNormal() {
     }
 
     @Test
-    public void testDelayWithObservableSubscriptionFunctionThrows() {
+    public void testDelayWithFlowableSubscriptionFunctionThrows() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final PublishProcessor<Integer> delay = PublishProcessor.create();
         Callable<Flowable<Integer>> subFunc = new Callable<Flowable<Integer>>() {
@@ -427,7 +427,7 @@ public void testDelayWithObservableSubscriptionFunctionThrows() {
     }
 
     @Test
-    public void testDelayWithObservableSubscriptionThrows() {
+    public void testDelayWithFlowableSubscriptionThrows() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final PublishProcessor<Integer> delay = PublishProcessor.create();
         Callable<Flowable<Integer>> subFunc = new Callable<Flowable<Integer>>() {
@@ -461,7 +461,7 @@ public void testDelayWithObservableSubscriptionThrows() {
     }
 
     @Test
-    public void testDelayWithObservableEmptyDelayer() {
+    public void testDelayWithFlowableEmptyDelayer() {
         PublishProcessor<Integer> source = PublishProcessor.create();
 
         Function<Integer, Flowable<Integer>> delayFunc = new Function<Integer, Flowable<Integer>>() {
@@ -486,7 +486,7 @@ public void testDelayWithObservableEmptyDelayer() {
     }
 
     @Test
-    public void testDelayWithObservableSubscriptionRunCompletion() {
+    public void testDelayWithFlowableSubscriptionRunCompletion() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final PublishProcessor<Integer> sdelay = PublishProcessor.create();
         final PublishProcessor<Integer> delay = PublishProcessor.create();
@@ -522,7 +522,7 @@ public void testDelayWithObservableSubscriptionRunCompletion() {
     }
 
     @Test
-    public void testDelayWithObservableAsTimed() {
+    public void testDelayWithFlowableAsTimed() {
         Flowable<Long> source = Flowable.interval(1L, TimeUnit.SECONDS, scheduler).take(3);
 
         final Flowable<Long> delayer = Flowable.timer(500L, TimeUnit.MILLISECONDS, scheduler);
@@ -572,7 +572,7 @@ public void testDelayWithObservableAsTimed() {
     }
 
     @Test
-    public void testDelayWithObservableReorder() {
+    public void testDelayWithFlowableReorder() {
         int n = 3;
 
         PublishProcessor<Integer> source = PublishProcessor.create();
@@ -936,4 +936,86 @@ public void accept(Throwable throwable) throws Exception {
         assertNotEquals(Thread.currentThread(), thread.get());
     }
 
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().delay(1, TimeUnit.SECONDS));
+
+        TestHelper.checkDisposed(PublishProcessor.create().delay(Functions.justFunction(Flowable.never())));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.delay(1, TimeUnit.SECONDS);
+            }
+        });
+
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.delay(Functions.justFunction(Flowable.never()));
+            }
+        });
+    }
+
+    @Test
+    public void onCompleteFinal() {
+        TestScheduler scheduler = new TestScheduler();
+
+        Flowable.empty()
+        .delay(1, TimeUnit.MILLISECONDS, scheduler)
+        .subscribe(new DisposableSubscriber<Object>() {
+            @Override
+            public void onNext(Object value) {
+            }
+
+            @Override
+            public void onError(Throwable e) {
+            }
+
+            @Override
+            public void onComplete() {
+                throw new TestException();
+            }
+        });
+
+        try {
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+            fail("Should have thrown");
+        } catch (TestException ex) {
+            // expected
+        }
+    }
+
+    @Test
+    public void onErrorFinal() {
+        TestScheduler scheduler = new TestScheduler();
+
+        Flowable.error(new TestException())
+        .delay(1, TimeUnit.MILLISECONDS, scheduler)
+        .subscribe(new DisposableSubscriber<Object>() {
+            @Override
+            public void onNext(Object value) {
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                throw new TestException();
+            }
+
+            @Override
+            public void onComplete() {
+            }
+        });
+
+        try {
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+            fail("Should have thrown");
+        } catch (TestException ex) {
+            // expected
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDematerializeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDematerializeTest.java
index f1e27d4a69..db90387c1d 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDematerializeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDematerializeTest.java
@@ -13,13 +13,19 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
+import java.util.List;
+
 import org.junit.Test;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.Function;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableDematerializeTest {
@@ -130,4 +136,44 @@ public void testHonorsContractWhenThrows() {
         verify(o, never()).onComplete();
         verify(o).onError(any(TestException.class));
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Flowable.just(Notification.createOnComplete()).dematerialize());
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.dematerialize();
+            }
+        });
+    }
+
+    @Test
+    public void eventsAfterDematerializedTerminal() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Flowable<Object>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Object> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+                    observer.onNext(Notification.createOnComplete());
+                    observer.onNext(Notification.createOnNext(1));
+                    observer.onNext(Notification.createOnError(new TestException("First")));
+                    observer.onError(new TestException("Second"));
+                }
+            }
+            .dematerialize()
+            .test()
+            .assertResult();
+
+            TestHelper.assertError(errors, 0, TestException.class, "First");
+            TestHelper.assertError(errors, 1, TestException.class, "Second");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDetachTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDetachTest.java
index 6ee57e6281..f46e4f18b6 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDetachTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDetachTest.java
@@ -161,7 +161,6 @@ public void subscribe(Subscriber<? super Object> t) {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.never().onTerminateDetach());
     }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java
index 60302edafd..c5f178744d 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java
@@ -21,6 +21,9 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
@@ -239,9 +242,59 @@ protected void subscribeActual(Subscriber<? super Integer> subscriber) {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(PublishProcessor.create().elementAt(0).toFlowable());
         TestHelper.checkDisposed(PublishProcessor.create().elementAt(0, 1).toFlowable());
     }
+
+    @Test
+    public void badSourceObservable() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Observable<Integer>() {
+                @Override
+                protected void subscribeActual(Observer<? super Integer> observer) {
+                    observer.onSubscribe(Disposables.empty());
+
+                    observer.onNext(1);
+                    observer.onNext(2);
+                    observer.onError(new TestException());
+                    observer.onComplete();
+                }
+            }
+            .elementAt(0)
+            .toFlowable()
+            .test()
+            .assertResult(1);
+
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void badSource2() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+
+                    observer.onNext(1);
+                    observer.onNext(2);
+                    observer.onError(new TestException());
+                    observer.onComplete();
+                }
+            }
+            .elementAt(0, 1)
+            .test()
+            .assertResult(1);
+
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletableTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletableTest.java
index 6f1bba0889..a944b65aba 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletableTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletableTest.java
@@ -19,15 +19,16 @@
 import java.util.concurrent.TimeUnit;
 
 import org.junit.*;
+import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.disposables.*;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.fuseable.QueueDisposable;
+import io.reactivex.internal.fuseable.*;
 import io.reactivex.observers.*;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
-import io.reactivex.subjects.PublishSubject;
 import io.reactivex.subscribers.*;
 
 public class FlowableFlatMapCompletableTest {
@@ -216,7 +217,7 @@ public CompletableSource apply(Integer v) throws Exception {
 
     @Test
     public void mapperThrows() {
-        PublishSubject<Integer> ps = PublishSubject.create();
+        PublishProcessor<Integer> ps = PublishProcessor.create();
 
         TestObserver<Void> to = ps
         .flatMapCompletable(new Function<Integer, CompletableSource>() {
@@ -227,18 +228,18 @@ public CompletableSource apply(Integer v) throws Exception {
         })
         .test();
 
-        assertTrue(ps.hasObservers());
+        assertTrue(ps.hasSubscribers());
 
         ps.onNext(1);
 
         to.assertFailure(TestException.class);
 
-        assertFalse(ps.hasObservers());
+        assertFalse(ps.hasSubscribers());
     }
 
     @Test
     public void mapperReturnsNull() {
-        PublishSubject<Integer> ps = PublishSubject.create();
+        PublishProcessor<Integer> ps = PublishProcessor.create();
 
         TestObserver<Void> to = ps
         .flatMapCompletable(new Function<Integer, CompletableSource>() {
@@ -249,13 +250,13 @@ public CompletableSource apply(Integer v) throws Exception {
         })
         .test();
 
-        assertTrue(ps.hasObservers());
+        assertTrue(ps.hasSubscribers());
 
         ps.onNext(1);
 
         to.assertFailure(NullPointerException.class);
 
-        assertFalse(ps.hasObservers());
+        assertFalse(ps.hasSubscribers());
     }
 
     @Test
@@ -382,8 +383,7 @@ public CompletableSource apply(Integer v) throws Exception {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
-    public void disposedObservable() {
+    public void disposedFlowable() {
         TestHelper.checkDisposed(Flowable.range(1, 10)
         .flatMapCompletable(new Function<Integer, CompletableSource>() {
             @Override
@@ -392,4 +392,118 @@ public CompletableSource apply(Integer v) throws Exception {
             }
         }).toFlowable());
     }
+
+    @Test
+    public void badSource() {
+        TestHelper.checkBadSourceFlowable(new Function<Flowable<Integer>, Object>() {
+            @Override
+            public Object apply(Flowable<Integer> o) throws Exception {
+                return o.flatMapCompletable(new Function<Integer, CompletableSource>() {
+                    @Override
+                    public CompletableSource apply(Integer v) throws Exception {
+                        return Completable.complete();
+                    }
+                });
+            }
+        }, false, 1, null);
+    }
+
+    @Test
+    public void fusedInternalsFlowable() {
+        Flowable.range(1, 10)
+        .flatMapCompletable(new Function<Integer, CompletableSource>() {
+            @Override
+            public CompletableSource apply(Integer v) throws Exception {
+                return Completable.complete();
+            }
+        })
+        .toFlowable()
+        .subscribe(new Subscriber<Object>() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                QueueSubscription<?> qd = (QueueSubscription<?>)d;
+                try {
+                    assertNull(qd.poll());
+                } catch (Throwable ex) {
+                    throw new RuntimeException(ex);
+                }
+                assertTrue(qd.isEmpty());
+                qd.clear();
+            }
+
+            @Override
+            public void onNext(Object t) {
+            }
+
+            @Override
+            public void onError(Throwable t) {
+            }
+
+            @Override
+            public void onComplete() {
+            }
+        });
+    }
+
+    @Test
+    public void innerObserverFlowable() {
+        Flowable.range(1, 3)
+        .flatMapCompletable(new Function<Integer, CompletableSource>() {
+            @Override
+            public CompletableSource apply(Integer v) throws Exception {
+                return new Completable() {
+                    @Override
+                    protected void subscribeActual(CompletableObserver s) {
+                        s.onSubscribe(Disposables.empty());
+
+                        assertFalse(((Disposable)s).isDisposed());
+
+                        ((Disposable)s).dispose();
+
+                        assertTrue(((Disposable)s).isDisposed());
+                    }
+                };
+            }
+        })
+        .toFlowable()
+        .test();
+    }
+
+    @Test
+    public void badSourceFlowable() {
+        TestHelper.checkBadSourceFlowable(new Function<Flowable<Integer>, Object>() {
+            @Override
+            public Object apply(Flowable<Integer> o) throws Exception {
+                return o.flatMapCompletable(new Function<Integer, CompletableSource>() {
+                    @Override
+                    public CompletableSource apply(Integer v) throws Exception {
+                        return Completable.complete();
+                    }
+                }).toFlowable();
+            }
+        }, false, 1, null);
+    }
+
+    @Test
+    public void innerObserver() {
+        Flowable.range(1, 3)
+        .flatMapCompletable(new Function<Integer, CompletableSource>() {
+            @Override
+            public CompletableSource apply(Integer v) throws Exception {
+                return new Completable() {
+                    @Override
+                    protected void subscribeActual(CompletableObserver s) {
+                        s.onSubscribe(Disposables.empty());
+
+                        assertFalse(((Disposable)s).isDisposed());
+
+                        ((Disposable)s).dispose();
+
+                        assertTrue(((Disposable)s).isDisposed());
+                    }
+                };
+            }
+        })
+        .test();
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java
index d720b14135..d56e4796d8 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java
@@ -18,7 +18,7 @@
 
 import org.junit.*;
 
-import io.reactivex.Flowable;
+import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.processors.PublishProcessor;
@@ -558,4 +558,14 @@ public void flatMapIterablePrefetch() {
         .test()
         .assertResult(10, 20);
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().flatMapIterable(new Function<Object, Iterable<Integer>>() {
+            @Override
+            public Iterable<Integer> apply(Object v) throws Exception {
+                return Arrays.asList(10, 20);
+            }
+        }));
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableGenerateTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGenerateTest.java
index bec9359fb1..e306b95e6e 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableGenerateTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGenerateTest.java
@@ -113,7 +113,6 @@ public void accept(Object d) throws Exception {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.generate(new Callable<Object>() {
                 @Override
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java
index 0147fbdb01..dc404b22d5 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.flowable;
 
 import static org.junit.Assert.*;
+import static org.mockito.ArgumentMatchers.*;
 import static org.mockito.Mockito.*;
 
 import java.util.*;
@@ -31,6 +32,7 @@
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.fuseable.QueueSubscription;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
 
@@ -215,11 +217,11 @@ public Integer apply(Event e) {
         }).flatMap(new Function<GroupedFlowable<Integer, Event>, Flowable<String>>() {
 
             @Override
-            public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedObservable) {
-                System.out.println("GroupedObservable Key: " + eventGroupedObservable.getKey());
+            public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedFlowable) {
+                System.out.println("GroupedFlowable Key: " + eventGroupedFlowable.getKey());
                 groupCounter.incrementAndGet();
 
-                return eventGroupedObservable.map(new Function<Event, String>() {
+                return eventGroupedFlowable.map(new Function<Event, String>() {
 
                     @Override
                     public String apply(Event event) {
@@ -295,11 +297,11 @@ public Integer apply(Event e) {
                 .flatMap(new Function<GroupedFlowable<Integer, Event>, Flowable<String>>() {
 
                     @Override
-                    public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedObservable) {
-                        System.out.println("testUnsubscribe => GroupedObservable Key: " + eventGroupedObservable.getKey());
+                    public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedFlowable) {
+                        System.out.println("testUnsubscribe => GroupedFlowable Key: " + eventGroupedFlowable.getKey());
                         groupCounter.incrementAndGet();
 
-                        return eventGroupedObservable
+                        return eventGroupedFlowable
                                 .take(20) // limit to only 20 events on this group
                                 .map(new Function<Event, String>() {
 
@@ -360,8 +362,8 @@ public Integer apply(Event e) {
                 .flatMap(new Function<GroupedFlowable<Integer, Event>, Flowable<String>>() {
 
                     @Override
-                    public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedObservable) {
-                        return eventGroupedObservable
+                    public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedFlowable) {
+                        return eventGroupedFlowable
                                 .map(new Function<Event, String>() {
 
                                     @Override
@@ -406,14 +408,14 @@ public Integer apply(Event e) {
                 .flatMap(new Function<GroupedFlowable<Integer, Event>, Flowable<String>>() {
 
                     @Override
-                    public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedObservable) {
+                    public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedFlowable) {
                         int numToTake = 0;
-                        if (eventGroupedObservable.getKey() == 1) {
+                        if (eventGroupedFlowable.getKey() == 1) {
                             numToTake = 10;
-                        } else if (eventGroupedObservable.getKey() == 2) {
+                        } else if (eventGroupedFlowable.getKey() == 2) {
                             numToTake = 5;
                         }
-                        return eventGroupedObservable
+                        return eventGroupedFlowable
                                 .take(numToTake)
                                 .map(new Function<Event, String>() {
 
@@ -551,11 +553,11 @@ public Integer apply(Event e) {
                 .flatMap(new Function<GroupedFlowable<Integer, Event>, Flowable<String>>() {
 
                     @Override
-                    public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedObservable) {
-                        Flowable<Event> eventStream = eventGroupedObservable;
-                        if (eventGroupedObservable.getKey() >= 2) {
+                    public Flowable<String> apply(GroupedFlowable<Integer, Event> eventGroupedFlowable) {
+                        Flowable<Event> eventStream = eventGroupedFlowable;
+                        if (eventGroupedFlowable.getKey() >= 2) {
                             // filter these
-                            eventStream = eventGroupedObservable.filter(new Predicate<Event>() {
+                            eventStream = eventGroupedFlowable.filter(new Predicate<Event>() {
                                 @Override
                                 public boolean test(Event t1) {
                                     return false;
@@ -1201,7 +1203,7 @@ public void innerEscapeCompleted() {
     }
 
     /**
-     * Assert we get an IllegalStateException if trying to subscribe to an inner GroupedObservable more than once.
+     * Assert we get an IllegalStateException if trying to subscribe to an inner GroupedFlowable more than once.
      */
     @Test
     public void testExceptionIfSubscribeToChildMoreThanOnce() {
@@ -1361,9 +1363,9 @@ public String apply(String value) {
         }).subscribe(new Consumer<GroupedFlowable<String, String>>() {
 
             @Override
-            public void accept(GroupedFlowable<String, String> groupedObservable) {
-                key[0] = groupedObservable.getKey();
-                groupedObservable.subscribe(new Consumer<String>() {
+            public void accept(GroupedFlowable<String, String> groupedFlowable) {
+                key[0] = groupedFlowable.getKey();
+                groupedFlowable.subscribe(new Consumer<String>() {
 
                     @Override
                     public void accept(String s) {
@@ -1661,4 +1663,64 @@ public void keyAndValueSelectorAndDelayError() {
         .assertFailure(TestException.class, 1);
     }
 
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Flowable.just(1).groupBy(Functions.justFunction(1)));
+
+        Flowable.just(1)
+        .groupBy(Functions.justFunction(1))
+        .doOnNext(new Consumer<GroupedFlowable<Integer, Integer>>() {
+            @Override
+            public void accept(GroupedFlowable<Integer, Integer> g) throws Exception {
+                TestHelper.checkDisposed(g);
+            }
+        })
+        .test();
+    }
+
+    @Test
+    public void reentrantComplete() {
+        final PublishProcessor<Integer> ps = PublishProcessor.create();
+
+        TestSubscriber<Integer> to = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onComplete();
+                }
+            }
+        };
+
+        Flowable.merge(ps.groupBy(Functions.justFunction(1)))
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to.assertResult(1);
+    }
+
+    @Test
+    public void reentrantCompleteCancel() {
+        final PublishProcessor<Integer> ps = PublishProcessor.create();
+
+        TestSubscriber<Integer> to = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onComplete();
+                    dispose();
+                }
+            }
+        };
+
+        Flowable.merge(ps.groupBy(Functions.justFunction(1)))
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to.assertSubscribed().assertValue(1).assertNoErrors().assertNotComplete();
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java
index 0510593274..8f127b431b 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java
@@ -20,7 +20,7 @@
 import org.junit.Test;
 import org.reactivestreams.*;
 
-import io.reactivex.Flowable;
+import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.internal.fuseable.QueueSubscription;
@@ -323,4 +323,11 @@ public void onComplete() {
             }
         });
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Flowable.just(1).ignoreElements());
+
+        TestHelper.checkDisposed(Flowable.just(1).ignoreElements().toFlowable());
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableIntervalRangeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIntervalRangeTest.java
index 37b4a397bb..be4247240d 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableIntervalRangeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIntervalRangeTest.java
@@ -73,4 +73,9 @@ public void longOverflow() {
             assertEquals("Overflow! start + count is bigger than Long.MAX_VALUE", ex.getMessage());
         }
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Flowable.intervalRange(1, 2, 1, 1, TimeUnit.MILLISECONDS));
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableJoinTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableJoinTest.java
index 26efce905c..5b602f0a5c 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableJoinTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableJoinTest.java
@@ -15,15 +15,23 @@
  */
 package io.reactivex.internal.operators.flowable;
 
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
+import java.util.List;
+
 import org.junit.*;
 import org.mockito.MockitoAnnotations;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
+import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableJoinTest {
     Subscriber<Object> observer = TestHelper.mockSubscriber();
@@ -299,4 +307,143 @@ public Integer apply(Integer t1, Integer t2) {
         verify(observer, never()).onComplete();
         verify(observer, never()).onNext(any());
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.<Integer>create().join(Flowable.just(1),
+                Functions.justFunction(Flowable.never()),
+                Functions.justFunction(Flowable.never()), new BiFunction<Integer, Integer, Integer>() {
+                    @Override
+                    public Integer apply(Integer a, Integer b) throws Exception {
+                        return a + b;
+                    }
+                }));
+    }
+
+    @Test
+    public void take() {
+        Flowable.just(1).join(
+                Flowable.just(2),
+                Functions.justFunction(Flowable.never()),
+                Functions.justFunction(Flowable.never()),
+                new BiFunction<Integer, Integer, Integer>() {
+                    @Override
+                    public Integer apply(Integer a, Integer b) throws Exception {
+                        return a + b;
+                    }
+                })
+        .take(1)
+        .test()
+        .assertResult(3);
+    }
+
+    @Test
+    public void rightClose() {
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+
+        TestSubscriber<Integer> to = ps.join(Flowable.just(2),
+                Functions.justFunction(Flowable.never()),
+                Functions.justFunction(Flowable.empty()),
+                new BiFunction<Integer, Integer, Integer>() {
+                    @Override
+                    public Integer apply(Integer a, Integer b) throws Exception {
+                        return a + b;
+                    }
+            })
+        .test()
+        .assertEmpty();
+
+        ps.onNext(1);
+
+        to.assertEmpty();
+    }
+
+    @Test
+    public void resultSelectorThrows2() {
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+
+        TestSubscriber<Integer> to = ps.join(
+                Flowable.just(2),
+                Functions.justFunction(Flowable.never()),
+                Functions.justFunction(Flowable.never()),
+                new BiFunction<Integer, Integer, Integer>() {
+                    @Override
+                    public Integer apply(Integer a, Integer b) throws Exception {
+                        throw new TestException();
+                    }
+                })
+        .test();
+
+        ps.onNext(1);
+        ps.onComplete();
+
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void badOuterSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+                    observer.onError(new TestException("First"));
+                    observer.onError(new TestException("Second"));
+                }
+            }
+            .join(Flowable.just(2),
+                    Functions.justFunction(Flowable.never()),
+                    Functions.justFunction(Flowable.never()),
+                    new BiFunction<Integer, Integer, Integer>() {
+                        @Override
+                        public Integer apply(Integer a, Integer b) throws Exception {
+                            return a + b;
+                        }
+                })
+            .test()
+            .assertFailureAndMessage(TestException.class, "First");
+
+            TestHelper.assertError(errors, 0, TestException.class, "Second");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void badEndSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            @SuppressWarnings("rawtypes")
+            final Subscriber[] o = { null };
+
+            TestSubscriber<Integer> to = Flowable.just(1)
+            .join(Flowable.just(2),
+                    Functions.justFunction(Flowable.never()),
+                    Functions.justFunction(new Flowable<Integer>() {
+                        @Override
+                        protected void subscribeActual(Subscriber<? super Integer> observer) {
+                            o[0] = observer;
+                            observer.onSubscribe(new BooleanSubscription());
+                            observer.onError(new TestException("First"));
+                        }
+                    }),
+                    new BiFunction<Integer, Integer, Integer>() {
+                        @Override
+                        public Integer apply(Integer a, Integer b) throws Exception {
+                            return a + b;
+                        }
+                })
+            .test();
+
+            o[0].onError(new TestException("Second"));
+
+            to
+            .assertFailureAndMessage(TestException.class, "First");
+
+            TestHelper.assertError(errors, 0, TestException.class, "Second");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMaterializeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMaterializeTest.java
index be92e85737..0665a978f8 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMaterializeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMaterializeTest.java
@@ -22,7 +22,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
@@ -282,4 +282,19 @@ public void backpressure() {
         .assertNoErrors()
         .assertComplete();
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Flowable.just(1).materialize());
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Notification<Object>>>() {
+            @Override
+            public Flowable<Notification<Object>> apply(Flowable<Object> o) throws Exception {
+                return o.materialize();
+            }
+        });
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMulticastTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMulticastTest.java
index 6e3e42cb02..261c31c0dc 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMulticastTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMulticastTest.java
@@ -14,13 +14,11 @@
 package io.reactivex.internal.operators.flowable;
 
 public class FlowableMulticastTest {
-    // FIXME operator multicast not supported
-//
 //    @Test
 //    public void testMulticast() {
-//        Subject<String, String> source = PublishSubject.create();
+//        Processor<String, String> source = PublishProcessor.create();
 //
-//        ConnectableObservable<String> multicasted = new OperatorMulticast<String, String>(source, new PublishSubjectFactory());
+//        ConnectableObservable<String> multicasted = new OperatorMulticast<String, String>(source, new PublishProcessorFactory());
 //
 //        @SuppressWarnings("unchecked")
 //        Observer<String> observer = mock(Observer.class);
@@ -45,9 +43,9 @@
 //
 //    @Test
 //    public void testMulticastConnectTwice() {
-//        Subject<String, String> source = PublishSubject.create();
+//        Processor<String, String> source = PublishProcessor.create();
 //
-//        ConnectableObservable<String> multicasted = new OperatorMulticast<String, String>(source, new PublishSubjectFactory());
+//        ConnectableObservable<String> multicasted = new OperatorMulticast<String, String>(source, new PublishProcessorFactory());
 //
 //        @SuppressWarnings("unchecked")
 //        Observer<String> observer = mock(Observer.class);
@@ -71,9 +69,9 @@
 //
 //    @Test
 //    public void testMulticastDisconnect() {
-//        Subject<String, String> source = PublishSubject.create();
+//        Processor<String, String> source = PublishProcessor.create();
 //
-//        ConnectableObservable<String> multicasted = new OperatorMulticast<String, String>(source, new PublishSubjectFactory());
+//        ConnectableObservable<String> multicasted = new OperatorMulticast<String, String>(source, new PublishProcessorFactory());
 //
 //        @SuppressWarnings("unchecked")
 //        Observer<String> observer = mock(Observer.class);
@@ -102,11 +100,11 @@
 //
 //    }
 //
-//    private static final class PublishSubjectFactory implements Func0<Subject<String, String>> {
+//    private static final class PublishProcessorFactory implements Callable<Processor<String, String>> {
 //
 //        @Override
 //        public Subject<String, String> call() {
-//            return PublishSubject.<String> create();
+//            return PublishProcessor.<String> create();
 //        }
 //
 //    }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
index 4a9d19c0e5..2f5f1ec700 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
@@ -29,9 +29,11 @@
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
-import io.reactivex.internal.fuseable.QueueSubscription;
+import io.reactivex.internal.fuseable.*;
+import io.reactivex.internal.operators.flowable.FlowableObserveOn.BaseObserveOnSubscriber;
 import io.reactivex.internal.schedulers.ImmediateThinScheduler;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.*;
 import io.reactivex.schedulers.*;
 import io.reactivex.subscribers.*;
@@ -1138,4 +1140,258 @@ public boolean test(Integer v) throws Exception {
         .awaitDone(5, TimeUnit.SECONDS)
         .assertResult(2, 4);
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().observeOn(new TestScheduler()));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.observeOn(new TestScheduler());
+            }
+        });
+    }
+
+    @Test
+    public void badSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            TestScheduler scheduler = new TestScheduler();
+            TestSubscriber<Integer> to = new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+                    observer.onComplete();
+                    observer.onNext(1);
+                    observer.onError(new TestException());
+                    observer.onComplete();
+                }
+            }
+            .observeOn(scheduler)
+            .test();
+
+            scheduler.triggerActions();
+
+            to.assertResult();
+
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void inputSyncFused() {
+        Flowable.range(1, 5)
+        .observeOn(Schedulers.single())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void inputAsyncFused() {
+        UnicastProcessor<Integer> us = UnicastProcessor.create();
+
+        TestSubscriber<Integer> to = us.observeOn(Schedulers.single()).test();
+
+        TestHelper.emit(us, 1, 2, 3, 4, 5);
+
+        to
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void inputAsyncFusedError() {
+        UnicastProcessor<Integer> us = UnicastProcessor.create();
+
+        TestSubscriber<Integer> to = us.observeOn(Schedulers.single()).test();
+
+        us.onError(new TestException());
+
+        to
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void inputAsyncFusedErrorDelayed() {
+        UnicastProcessor<Integer> us = UnicastProcessor.create();
+
+        TestSubscriber<Integer> to = us.observeOn(Schedulers.single(), true).test();
+
+        us.onError(new TestException());
+
+        to
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void outputFused() {
+        TestSubscriber<Integer> to = SubscriberFusion.newTest(QueueSubscription.ANY);
+
+        Flowable.range(1, 5).hide()
+        .observeOn(Schedulers.single())
+        .subscribe(to);
+
+        SubscriberFusion.assertFusion(to, QueueSubscription.ASYNC)
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void outputFusedReject() {
+        TestSubscriber<Integer> to = SubscriberFusion.newTest(QueueSubscription.SYNC);
+
+        Flowable.range(1, 5).hide()
+        .observeOn(Schedulers.single())
+        .subscribe(to);
+
+        SubscriberFusion.assertFusion(to, QueueSubscription.NONE)
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void inputOutputAsyncFusedError() {
+        TestSubscriber<Integer> to = SubscriberFusion.newTest(QueueSubscription.ANY);
+
+        UnicastProcessor<Integer> us = UnicastProcessor.create();
+
+        us.observeOn(Schedulers.single())
+        .subscribe(to);
+
+        us.onError(new TestException());
+
+        to
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+
+        SubscriberFusion.assertFusion(to, QueueSubscription.ASYNC)
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void inputOutputAsyncFusedErrorDelayed() {
+        TestSubscriber<Integer> to = SubscriberFusion.newTest(QueueSubscription.ANY);
+
+        UnicastProcessor<Integer> us = UnicastProcessor.create();
+
+        us.observeOn(Schedulers.single(), true)
+        .subscribe(to);
+
+        us.onError(new TestException());
+
+        to
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+
+        SubscriberFusion.assertFusion(to, QueueSubscription.ASYNC)
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void outputFusedCancelReentrant() throws Exception {
+        final UnicastProcessor<Integer> us = UnicastProcessor.create();
+
+        final CountDownLatch cdl = new CountDownLatch(1);
+
+        us.observeOn(Schedulers.single())
+        .subscribe(new Subscriber<Integer>() {
+            Subscription d;
+            int count;
+            @Override
+            public void onSubscribe(Subscription d) {
+                this.d = d;
+                ((QueueSubscription<?>)d).requestFusion(QueueSubscription.ANY);
+            }
+
+            @Override
+            public void onNext(Integer value) {
+                if (++count == 1) {
+                    us.onNext(2);
+                    d.cancel();
+                    cdl.countDown();
+                }
+            }
+
+            @Override
+            public void onError(Throwable e) {
+
+            }
+
+            @Override
+            public void onComplete() {
+
+            }
+        });
+
+        us.onNext(1);
+
+        cdl.await();
+    }
+
+    @Test
+    public void nonFusedPollThrows() {
+        new Flowable<Integer>() {
+            @Override
+            protected void subscribeActual(Subscriber<? super Integer> observer) {
+                observer.onSubscribe(new BooleanSubscription());
+
+                @SuppressWarnings("unchecked")
+                BaseObserveOnSubscriber<Integer> oo = (BaseObserveOnSubscriber<Integer>)observer;
+
+                oo.queue = new SimpleQueue<Integer>() {
+
+                    @Override
+                    public boolean offer(Integer value) {
+                        return false;
+                    }
+
+                    @Override
+                    public boolean offer(Integer v1, Integer v2) {
+                        return false;
+                    }
+
+                    @Override
+                    public Integer poll() throws Exception {
+                        throw new TestException();
+                    }
+
+                    @Override
+                    public boolean isEmpty() {
+                        return false;
+                    }
+
+                    @Override
+                    public void clear() {
+                    }
+                };
+
+                oo.clear();
+
+                oo.trySchedule();
+            }
+        }
+        .observeOn(Schedulers.single())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void trampolineScheduler() {
+        Flowable.just(1)
+        .observeOn(Schedulers.trampoline())
+        .test()
+        .assertResult(1);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRangeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRangeTest.java
index c62b2e1f37..75428c9e6e 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRangeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRangeTest.java
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.flowable;
 
 import static org.junit.Assert.*;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
 import java.util.*;
@@ -24,6 +25,7 @@
 
 import io.reactivex.*;
 import io.reactivex.functions.Consumer;
+import io.reactivex.internal.fuseable.QueueDisposable;
 import io.reactivex.subscribers.*;
 
 public class FlowableRangeTest {
@@ -277,4 +279,15 @@ public void negativeCount() {
             assertEquals("count >= 0 required but it was -1", ex.getMessage());
         }
     }
+
+    @Test
+    public void requestWrongFusion() {
+        TestSubscriber<Integer> to = SubscriberFusion.newTest(QueueDisposable.ASYNC);
+
+        Flowable.range(1, 5)
+        .subscribe(to);
+
+        SubscriberFusion.assertFusion(to, QueueDisposable.NONE)
+        .assertResult(1, 2, 3, 4, 5);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java
index 05a8036e33..3f8c456b15 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java
@@ -595,7 +595,6 @@ public void accept(String t1) {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void disposed() {
         TestHelper.checkDisposed(Flowable.just(1).publish().refCount());
     }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
index 5f567f00bc..0cc237776c 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.flowable;
 
 import static org.junit.Assert.*;
+import static org.mockito.ArgumentMatchers.*;
 import static org.mockito.Mockito.*;
 
 import java.util.*;
@@ -25,15 +26,16 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.Flowable;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.flowables.ConnectableFlowable;
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
+import io.reactivex.internal.fuseable.HasUpstreamPublisher;
 import io.reactivex.internal.operators.flowable.FlowableReplay.*;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.*;
 import io.reactivex.subscribers.TestSubscriber;
@@ -1297,4 +1299,413 @@ public void replaySelectorTime() {
         .assertResult(1);
     }
 
+    @Test
+    public void source() {
+        Flowable<Integer> source = Flowable.range(1, 3);
+
+        assertSame(source, (((HasUpstreamPublisher<?>)source.replay())).source());
+    }
+
+    @Test
+    public void connectRace() {
+        for (int i = 0; i < 500; i++) {
+            final ConnectableFlowable<Integer> co = Flowable.range(1, 3).replay();
+
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    co.connect();
+                }
+            };
+
+            TestHelper.race(r, r);
+        }
+    }
+
+    @Test
+    public void subscribeRace() {
+        for (int i = 0; i < 500; i++) {
+            final ConnectableFlowable<Integer> co = Flowable.range(1, 3).replay();
+
+            final TestSubscriber<Integer> to1 = new TestSubscriber<Integer>();
+            final TestSubscriber<Integer> to2 = new TestSubscriber<Integer>();
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    co.subscribe(to1);
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    co.subscribe(to2);
+                }
+            };
+
+            TestHelper.race(r1, r2);
+        }
+    }
+
+    @Test
+    public void addRemoveRace() {
+        for (int i = 0; i < 500; i++) {
+            final ConnectableFlowable<Integer> co = Flowable.range(1, 3).replay();
+
+            final TestSubscriber<Integer> to1 = new TestSubscriber<Integer>();
+            final TestSubscriber<Integer> to2 = new TestSubscriber<Integer>();
+
+            co.subscribe(to1);
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    to1.cancel();
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    co.subscribe(to2);
+                }
+            };
+
+            TestHelper.race(r1, r2);
+        }
+    }
+
+    @Test
+    public void cancelOnArrival() {
+        Flowable.range(1, 2)
+        .replay(Integer.MAX_VALUE)
+        .autoConnect()
+        .test(Long.MAX_VALUE, true)
+        .assertEmpty();
+    }
+
+    @Test
+    public void cancelOnArrival2() {
+        ConnectableFlowable<Integer> co = PublishProcessor.<Integer>create()
+        .replay(Integer.MAX_VALUE);
+
+        co.test();
+
+        co
+        .autoConnect()
+        .test(Long.MAX_VALUE, true)
+        .assertEmpty();
+    }
+
+    @Test
+    public void connectConsumerThrows() {
+        ConnectableFlowable<Integer> co = Flowable.range(1, 2)
+        .replay();
+
+        try {
+            co.connect(new Consumer<Disposable>() {
+                @Override
+                public void accept(Disposable t) throws Exception {
+                    throw new TestException();
+                }
+            });
+            fail("Should have thrown");
+        } catch (TestException ex) {
+            // expected
+        }
+
+        co.test().assertEmpty().cancel();
+
+        co.connect();
+
+        co.test().assertResult(1, 2);
+    }
+
+    @Test
+    public void badSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+                    observer.onError(new TestException("First"));
+                    observer.onNext(1);
+                    observer.onError(new TestException("Second"));
+                    observer.onComplete();
+                }
+            }.replay()
+            .autoConnect()
+            .test()
+            .assertFailureAndMessage(TestException.class, "First");
+
+            TestHelper.assertError(errors, 0, TestException.class, "Second");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void subscribeOnNextRace() {
+        for (int i = 0; i < 500; i++) {
+            final PublishProcessor<Integer> ps = PublishProcessor.create();
+
+            final ConnectableFlowable<Integer> co = ps.replay();
+
+            final TestSubscriber<Integer> to1 = new TestSubscriber<Integer>();
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    co.subscribe(to1);
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    for (int j = 0; j < 1000; j++) {
+                        ps.onNext(j);
+                    }
+                }
+            };
+
+            TestHelper.race(r1, r2);
+        }
+    }
+
+    @Test
+    public void unsubscribeOnNextRace() {
+        for (int i = 0; i < 500; i++) {
+            final PublishProcessor<Integer> ps = PublishProcessor.create();
+
+            final ConnectableFlowable<Integer> co = ps.replay();
+
+            final TestSubscriber<Integer> to1 = new TestSubscriber<Integer>();
+
+            co.subscribe(to1);
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    to1.dispose();
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    for (int j = 0; j < 1000; j++) {
+                        ps.onNext(j);
+                    }
+                }
+            };
+
+            TestHelper.race(r1, r2);
+        }
+    }
+
+    @Test
+    public void unsubscribeReplayRace() {
+        for (int i = 0; i < 500; i++) {
+            final ConnectableFlowable<Integer> co = Flowable.range(1, 1000).replay();
+
+            final TestSubscriber<Integer> to1 = new TestSubscriber<Integer>();
+
+            co.connect();
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    co.subscribe(to1);
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    to1.dispose();
+                }
+            };
+
+            TestHelper.race(r1, r2);
+        }
+    }
+
+    @Test
+    public void reentrantOnNext() {
+        final PublishProcessor<Integer> ps = PublishProcessor.create();
+
+        TestSubscriber<Integer> to = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+                super.onNext(t);
+            }
+        };
+
+        ps.replay().autoConnect().subscribe(to);
+
+        ps.onNext(1);
+
+        to.assertResult(1, 2);
+    }
+
+    @Test
+    public void reentrantOnNextBound() {
+        final PublishProcessor<Integer> ps = PublishProcessor.create();
+
+        TestSubscriber<Integer> to = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+                super.onNext(t);
+            }
+        };
+
+        ps.replay(10).autoConnect().subscribe(to);
+
+        ps.onNext(1);
+
+        to.assertResult(1, 2);
+    }
+
+    @Test
+    public void reentrantOnNextCancel() {
+        final PublishProcessor<Integer> ps = PublishProcessor.create();
+
+        TestSubscriber<Integer> to = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                if (t == 1) {
+                    ps.onNext(2);
+                    cancel();
+                }
+                super.onNext(t);
+            }
+        };
+
+        ps.replay().autoConnect().subscribe(to);
+
+        ps.onNext(1);
+
+        to.assertValues(1);
+    }
+
+    @Test
+    public void reentrantOnNextCancelBounded() {
+        final PublishProcessor<Integer> ps = PublishProcessor.create();
+
+        TestSubscriber<Integer> to = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                if (t == 1) {
+                    ps.onNext(2);
+                    cancel();
+                }
+                super.onNext(t);
+            }
+        };
+
+        ps.replay(10).autoConnect().subscribe(to);
+
+        ps.onNext(1);
+
+        to.assertValues(1);
+    }
+
+    @Test
+    public void replayMaxInt() {
+        Flowable.range(1, 2)
+        .replay(Integer.MAX_VALUE)
+        .autoConnect()
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void testTimedAndSizedTruncationError() {
+        TestScheduler test = new TestScheduler();
+        SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test);
+
+        Assert.assertFalse(buf.hasCompleted());
+        Assert.assertFalse(buf.hasError());
+
+        List<Integer> values = new ArrayList<Integer>();
+
+        buf.next(1);
+        test.advanceTimeBy(1, TimeUnit.SECONDS);
+        buf.next(2);
+        test.advanceTimeBy(1, TimeUnit.SECONDS);
+        buf.collect(values);
+        Assert.assertEquals(Arrays.asList(1, 2), values);
+
+        buf.next(3);
+        buf.next(4);
+        values.clear();
+        buf.collect(values);
+        Assert.assertEquals(Arrays.asList(3, 4), values);
+
+        test.advanceTimeBy(2, TimeUnit.SECONDS);
+        buf.next(5);
+
+        values.clear();
+        buf.collect(values);
+        Assert.assertEquals(Arrays.asList(5), values);
+        Assert.assertFalse(buf.hasCompleted());
+        Assert.assertFalse(buf.hasError());
+
+        test.advanceTimeBy(2, TimeUnit.SECONDS);
+        buf.error(new TestException());
+
+        values.clear();
+        buf.collect(values);
+        Assert.assertTrue(values.isEmpty());
+
+        Assert.assertEquals(1, buf.size);
+        Assert.assertFalse(buf.hasCompleted());
+        Assert.assertTrue(buf.hasError());
+    }
+
+    @Test
+    public void testSizedTruncation() {
+        SizeBoundReplayBuffer<Integer> buf = new SizeBoundReplayBuffer<Integer>(2);
+        List<Integer> values = new ArrayList<Integer>();
+
+        buf.next(1);
+        buf.next(2);
+        buf.collect(values);
+        Assert.assertEquals(Arrays.asList(1, 2), values);
+
+        buf.next(3);
+        buf.next(4);
+        values.clear();
+        buf.collect(values);
+        Assert.assertEquals(Arrays.asList(3, 4), values);
+
+        buf.next(5);
+
+        values.clear();
+        buf.collect(values);
+        Assert.assertEquals(Arrays.asList(4, 5), values);
+        Assert.assertFalse(buf.hasCompleted());
+
+        buf.complete();
+
+        values.clear();
+        buf.collect(values);
+        Assert.assertEquals(Arrays.asList(4, 5), values);
+
+        Assert.assertEquals(3, buf.size);
+        Assert.assertTrue(buf.hasCompleted());
+        Assert.assertFalse(buf.hasError());
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java
index 18346eb1fb..ef88b0e8f0 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java
@@ -354,7 +354,7 @@ public void testRetrySubscribesAgainAfterError() throws Exception {
         Consumer<Integer> throwException = mock(Consumer.class);
         doThrow(new RuntimeException()).when(throwException).accept(Mockito.anyInt());
 
-        // create a retrying observable based on a PublishSubject
+        // create a retrying observable based on a PublishProcessor
         PublishProcessor<Integer> subject = PublishProcessor.create();
         subject
         // record item
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSampleTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSampleTest.java
index 52551d2a44..53cb136584 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSampleTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSampleTest.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
 import java.util.concurrent.TimeUnit;
@@ -22,6 +23,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.TestScheduler;
@@ -275,4 +277,19 @@ public void subscribe(Subscriber<? super Integer> subscriber) {
         o.throttleLast(1, TimeUnit.MILLISECONDS).subscribe().dispose();
         verify(s).cancel();
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().sample(1, TimeUnit.SECONDS, new TestScheduler()));
+
+        TestHelper.checkDisposed(PublishProcessor.create().sample(Flowable.never()));
+    }
+
+    @Test
+    public void error() {
+        Flowable.error(new TestException())
+        .sample(1, TimeUnit.SECONDS)
+        .test()
+        .assertFailure(TestException.class);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableScanTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableScanTest.java
index 6fc7f9254d..b1dc93f806 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableScanTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableScanTest.java
@@ -24,6 +24,8 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.subscribers.*;
@@ -398,4 +400,76 @@ public Integer apply(Integer t1, Integer t2) {
         ts.assertNotComplete();
         ts.assertValue(0);
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().scan(new BiFunction<Object, Object, Object>() {
+            @Override
+            public Object apply(Object a, Object b) throws Exception {
+                return a;
+            }
+        }));
+
+        TestHelper.checkDisposed(PublishProcessor.<Integer>create().scan(0, new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.scan(new BiFunction<Object, Object, Object>() {
+                    @Override
+                    public Object apply(Object a, Object b) throws Exception {
+                        return a;
+                    }
+                });
+            }
+        });
+
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.scan(0, new BiFunction<Object, Object, Object>() {
+                    @Override
+                    public Object apply(Object a, Object b) throws Exception {
+                        return a;
+                    }
+                });
+            }
+        });
+    }
+
+    @Test
+    public void error() {
+        Flowable.error(new TestException())
+        .scan(new BiFunction<Object, Object, Object>() {
+            @Override
+            public Object apply(Object a, Object b) throws Exception {
+                return a;
+            }
+        })
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void badSource() {
+        TestHelper.checkBadSourceFlowable(new Function<Flowable<Object>, Object>() {
+            @Override
+            public Object apply(Flowable<Object> o) throws Exception {
+                return o.scan(0, new BiFunction<Object, Object, Object>() {
+                    @Override
+                    public Object apply(Object a, Object b) throws Exception {
+                        return a;
+                    }
+                });
+            }
+        }, false, 1, 1, 0, 0);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualTest.java
index d77e89deab..5b959fdd91 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualTest.java
@@ -359,7 +359,6 @@ public void run() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void disposedFlowable() {
         TestHelper.checkDisposed(Flowable.sequenceEqual(Flowable.just(1), Flowable.just(2)).toFlowable());
     }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTest.java
index 0881768a03..84bd938a52 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTest.java
@@ -109,7 +109,6 @@ public void testSkipLastWithNegativeCount() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.just(1).skipLast(1));
     }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java
index 49ddbc6edd..f238963b08 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
 import java.util.concurrent.TimeUnit;
@@ -23,8 +24,10 @@
 
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.Function;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.*;
+import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableSkipLastTimedTest {
 
@@ -175,4 +178,53 @@ public void skipLastTimedCustomSchedulerDelayError() {
         .assertResult(1);
     }
 
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().skipLast(1, TimeUnit.DAYS));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.skipLast(1, TimeUnit.DAYS);
+            }
+        });
+    }
+
+    @Test
+    public void onNextDisposeRace() {
+        TestScheduler scheduler = new TestScheduler();
+        for (int i = 0; i < 500; i++) {
+            final PublishProcessor<Integer> ps = PublishProcessor.create();
+
+            final TestSubscriber<Integer> to = ps.skipLast(1, TimeUnit.DAYS, scheduler).test();
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    ps.onComplete();
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    to.cancel();
+                }
+            };
+
+            TestHelper.race(r1, r2);
+        }
+    }
+
+    @Test
+    public void errorDelayed() {
+        Flowable.error(new TestException())
+        .skipLast(1, TimeUnit.DAYS, new TestScheduler(), true)
+        .test()
+        .assertFailure(TestException.class);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipTest.java
index 682b17d0e2..8cdf78661a 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipTest.java
@@ -170,4 +170,9 @@ public void testRequestOverflowDoesNotOccur() {
         assertEquals(Arrays.asList(6,7,8,9,10), ts.values());
     }
 
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Flowable.just(1).skip(2));
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipUntilTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipUntilTest.java
index 717714d30b..173573f754 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipUntilTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipUntilTest.java
@@ -19,6 +19,7 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.functions.Function;
 import io.reactivex.processors.PublishProcessor;
 
 public class FlowableSkipUntilTest {
@@ -152,4 +153,26 @@ public void otherThrowsImmediately() {
         verify(observer, times(1)).onError(any(Throwable.class));
         verify(observer, never()).onComplete();
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().skipUntil(PublishProcessor.create()));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.skipUntil(Flowable.never());
+            }
+        });
+
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return Flowable.never().skipUntil(o);
+            }
+        });
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipWhileTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipWhileTest.java
index b5823018e6..725db23aef 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipWhileTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipWhileTest.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import static org.mockito.ArgumentMatchers.*;
 import static org.mockito.Mockito.*;
 
 import org.junit.Test;
@@ -20,7 +21,10 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
-import io.reactivex.functions.Predicate;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.processors.PublishProcessor;
 
 public class FlowableSkipWhileTest {
 
@@ -129,4 +133,27 @@ public void testSkipManySubscribers() {
             verify(o, never()).onError(any(Throwable.class));
         }
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().skipWhile(Functions.alwaysFalse()));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.skipWhile(Functions.alwaysFalse());
+            }
+        });
+    }
+
+    @Test
+    public void error() {
+        Flowable.error(new TestException())
+        .skipWhile(Functions.alwaysFalse())
+        .test()
+        .assertFailure(TestException.class);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTest.java
index 95b8b3f3bb..fb8540b50b 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTest.java
@@ -24,6 +24,8 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
@@ -316,4 +318,36 @@ public void onNext(Integer t) {
             }});
         assertEquals(50, list.size());
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Flowable.range(1, 10).takeLast(5));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.takeLast(5);
+            }
+        });
+    }
+
+    @Test
+    public void error() {
+        Flowable.error(new TestException())
+        .takeLast(5)
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void takeLastTake() {
+        Flowable.range(1, 10)
+        .takeLast(5)
+        .take(2)
+        .test()
+        .assertResult(6, 7);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTest.java
index 207e439846..e292fee6c2 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTest.java
@@ -158,7 +158,7 @@ public void subscribe(Subscriber<? super String> observer) {
 
     @Test
     public void testUnsubscribeAfterTake() {
-        TestObservableFunc f = new TestObservableFunc("one", "two", "three");
+        TestFlowableFunc f = new TestFlowableFunc("one", "two", "three");
         Flowable<String> w = Flowable.unsafeCreate(f);
 
         Subscriber<String> observer = TestHelper.mockSubscriber();
@@ -166,7 +166,7 @@ public void testUnsubscribeAfterTake() {
         Flowable<String> take = w.take(1);
         take.subscribe(observer);
 
-        // wait for the Observable to complete
+        // wait for the Flowable to complete
         try {
             f.t.join();
         } catch (Throwable e) {
@@ -174,7 +174,7 @@ public void testUnsubscribeAfterTake() {
             fail(e.getMessage());
         }
 
-        System.out.println("TestObservable thread finished");
+        System.out.println("TestFlowable thread finished");
         verify(observer).onSubscribe((Subscription)notNull());
         verify(observer, times(1)).onNext("one");
         verify(observer, never()).onNext("two");
@@ -186,7 +186,7 @@ public void testUnsubscribeAfterTake() {
     }
 
     @Test(timeout = 2000)
-    public void testUnsubscribeFromSynchronousInfiniteObservable() {
+    public void testUnsubscribeFromSynchronousInfiniteFlowable() {
         final AtomicLong count = new AtomicLong();
         INFINITE_OBSERVABLE.take(10).subscribe(new Consumer<Long>() {
 
@@ -228,27 +228,27 @@ public void accept(Integer t1) {
         assertEquals(1, count.get());
     }
 
-    static class TestObservableFunc implements Publisher<String> {
+    static class TestFlowableFunc implements Publisher<String> {
 
         final String[] values;
         Thread t;
 
-        TestObservableFunc(String... values) {
+        TestFlowableFunc(String... values) {
             this.values = values;
         }
 
         @Override
         public void subscribe(final Subscriber<? super String> observer) {
             observer.onSubscribe(new BooleanSubscription());
-            System.out.println("TestObservable subscribed to ...");
+            System.out.println("TestFlowable subscribed to ...");
             t = new Thread(new Runnable() {
 
                 @Override
                 public void run() {
                     try {
-                        System.out.println("running TestObservable thread");
+                        System.out.println("running TestFlowable thread");
                         for (String s : values) {
-                            System.out.println("TestObservable onNext: " + s);
+                            System.out.println("TestFlowable onNext: " + s);
                             observer.onNext(s);
                         }
                         observer.onComplete();
@@ -258,9 +258,9 @@ public void run() {
                 }
 
             });
-            System.out.println("starting TestObservable thread");
+            System.out.println("starting TestFlowable thread");
             t.start();
-            System.out.println("done starting TestObservable thread");
+            System.out.println("done starting TestFlowable thread");
         }
     }
 
@@ -448,4 +448,27 @@ public void takeNegative() {
         }
     }
 
+    @Test
+    public void takeZero() {
+        Flowable.just(1)
+        .take(0)
+        .test()
+        .assertResult();
+    }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().take(2));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.take(2);
+            }
+        });
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicateTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicateTest.java
index 3a16f3747b..e2c477befb 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicateTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilPredicateTest.java
@@ -13,14 +13,21 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
+import java.util.List;
+
 import org.junit.Test;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.functions.Predicate;
+import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.subscribers.TestSubscriber;
 ;
 
@@ -161,4 +168,43 @@ public boolean test(String t) {
         // FIXME last cause value is not saved
 //        assertTrue(ts.errors().get(0).getCause().getMessage().contains("abc"));
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().takeUntil(Functions.alwaysFalse()));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.takeUntil(Functions.alwaysFalse());
+            }
+        });
+    }
+
+    @Test
+    public void badSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+                    observer.onComplete();
+                    observer.onNext(1);
+                    observer.onError(new TestException());
+                    observer.onComplete();
+                }
+            }
+            .takeUntil(Functions.alwaysFalse())
+            .test()
+            .assertResult();
+
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java
index d785e5384f..12a168ed1f 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java
@@ -277,4 +277,9 @@ public void testBackpressure() {
         assertFalse("Until still has observers", until.hasSubscribers());
         assertFalse("TestSubscriber is unsubscribed", ts.isCancelled());
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().takeUntil(Flowable.never()));
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeWhileTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeWhileTest.java
index 043f8c05dd..bb1984dbef 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeWhileTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeWhileTest.java
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.flowable;
 
 import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
 import org.junit.*;
@@ -21,7 +22,8 @@
 
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.functions.Predicate;
+import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.processors.*;
 import io.reactivex.subscribers.TestSubscriber;
@@ -118,7 +120,7 @@ public boolean test(String s) {
 
     @Test
     public void testTakeWhileProtectsPredicateCall() {
-        TestObservable source = new TestObservable(mock(Subscription.class), "one");
+        TestFlowable source = new TestFlowable(mock(Subscription.class), "one");
         final RuntimeException testException = new RuntimeException("test exception");
 
         Subscriber<String> observer = TestHelper.mockSubscriber();
@@ -131,7 +133,7 @@ public boolean test(String s) {
         });
         take.subscribe(observer);
 
-        // wait for the Observable to complete
+        // wait for the Flowable to complete
         try {
             source.t.join();
         } catch (Throwable e) {
@@ -146,7 +148,7 @@ public boolean test(String s) {
     @Test
     public void testUnsubscribeAfterTake() {
         Subscription s = mock(Subscription.class);
-        TestObservable w = new TestObservable(s, "one", "two", "three");
+        TestFlowable w = new TestFlowable(s, "one", "two", "three");
 
         Subscriber<String> observer = TestHelper.mockSubscriber();
         Flowable<String> take = Flowable.unsafeCreate(w)
@@ -160,7 +162,7 @@ public boolean test(String s) {
         });
         take.subscribe(observer);
 
-        // wait for the Observable to complete
+        // wait for the Flowable to complete
         try {
             w.t.join();
         } catch (Throwable e) {
@@ -168,36 +170,36 @@ public boolean test(String s) {
             fail(e.getMessage());
         }
 
-        System.out.println("TestObservable thread finished");
+        System.out.println("TestFlowable thread finished");
         verify(observer, times(1)).onNext("one");
         verify(observer, never()).onNext("two");
         verify(observer, never()).onNext("three");
         verify(s, times(1)).cancel();
     }
 
-    private static class TestObservable implements Publisher<String> {
+    private static class TestFlowable implements Publisher<String> {
 
         final Subscription s;
         final String[] values;
         Thread t;
 
-        TestObservable(Subscription s, String... values) {
+        TestFlowable(Subscription s, String... values) {
             this.s = s;
             this.values = values;
         }
 
         @Override
         public void subscribe(final Subscriber<? super String> observer) {
-            System.out.println("TestObservable subscribed to ...");
+            System.out.println("TestFlowable subscribed to ...");
             observer.onSubscribe(s);
             t = new Thread(new Runnable() {
 
                 @Override
                 public void run() {
                     try {
-                        System.out.println("running TestObservable thread");
+                        System.out.println("running TestFlowable thread");
                         for (String s : values) {
-                            System.out.println("TestObservable onNext: " + s);
+                            System.out.println("TestFlowable onNext: " + s);
                             observer.onNext(s);
                         }
                         observer.onComplete();
@@ -207,9 +209,9 @@ public void run() {
                 }
 
             });
-            System.out.println("starting TestObservable thread");
+            System.out.println("starting TestFlowable thread");
             t.start();
-            System.out.println("done starting TestObservable thread");
+            System.out.println("done starting TestFlowable thread");
         }
     }
 
@@ -269,4 +271,34 @@ public boolean test(String t1) {
 //        assertTrue(ts.getOnErrorEvents().get(0).getCause().getMessage().contains("abc"));
     }
 
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().takeWhile(Functions.alwaysTrue()));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.takeWhile(Functions.alwaysTrue());
+            }
+        });
+    }
+
+    @Test
+    public void badSource() {
+        new Flowable<Integer>() {
+            @Override
+            protected void subscribeActual(Subscriber<? super Integer> observer) {
+                observer.onSubscribe(new BooleanSubscription());
+                observer.onComplete();
+                observer.onComplete();
+            }
+        }
+        .takeWhile(Functions.alwaysTrue())
+        .test()
+        .assertResult();
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java
index 67d905b2f0..5187d99ee1 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java
@@ -163,7 +163,6 @@ public void throttleFirstDefaultScheduler() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.just(1).throttleFirst(1, TimeUnit.DAYS));
     }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeIntervalTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeIntervalTest.java
index f093973d1d..ce78e0a9c6 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeIntervalTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeIntervalTest.java
@@ -124,7 +124,6 @@ public Long apply(Timed<Integer> v) throws Exception {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void dispose() {
         TestHelper.checkDisposed(Flowable.just(1).timeInterval());
     }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java
index 209de9ab73..64dc5c912b 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java
@@ -387,7 +387,6 @@ public void timedAndOther() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void disposed() {
         TestHelper.checkDisposed(PublishProcessor.create().timeout(1, TimeUnit.DAYS));
 
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutWithSelectorTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutWithSelectorTest.java
index e5a96f8779..f08b438647 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutWithSelectorTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutWithSelectorTest.java
@@ -14,9 +14,10 @@
 package io.reactivex.internal.operators.flowable;
 
 import static org.junit.Assert.assertFalse;
+import static org.mockito.ArgumentMatchers.*;
 import static org.mockito.Mockito.*;
 
-import java.util.Arrays;
+import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -29,7 +30,9 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Function;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
@@ -154,7 +157,7 @@ public void testTimeoutSelectorSubsequentThrows() {
     }
 
     @Test
-    public void testTimeoutSelectorFirstObservableThrows() {
+    public void testTimeoutSelectorFirstFlowableThrows() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final PublishProcessor<Integer> timeout = PublishProcessor.create();
 
@@ -178,7 +181,7 @@ public void testTimeoutSelectorFirstObservableThrows() {
     }
 
     @Test
-    public void testTimeoutSelectorSubsequentObservableThrows() {
+    public void testTimeoutSelectorSubsequentFlowableThrows() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final PublishProcessor<Integer> timeout = PublishProcessor.create();
 
@@ -205,7 +208,7 @@ public void testTimeoutSelectorSubsequentObservableThrows() {
     }
 
     @Test
-    public void testTimeoutSelectorWithFirstTimeoutFirstAndNoOtherObservable() {
+    public void testTimeoutSelectorWithFirstTimeoutFirstAndNoOtherFlowable() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final PublishProcessor<Integer> timeout = PublishProcessor.create();
 
@@ -227,7 +230,7 @@ public void testTimeoutSelectorWithFirstTimeoutFirstAndNoOtherObservable() {
     }
 
     @Test
-    public void testTimeoutSelectorWithTimeoutFirstAndNoOtherObservable() {
+    public void testTimeoutSelectorWithTimeoutFirstAndNoOtherFlowable() {
         PublishProcessor<Integer> source = PublishProcessor.create();
         final PublishProcessor<Integer> timeout = PublishProcessor.create();
 
@@ -367,4 +370,143 @@ public void run() {
         inOrder.verify(o).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().timeout(Functions.justFunction(Flowable.never())));
+
+        TestHelper.checkDisposed(PublishProcessor.create().timeout(Functions.justFunction(Flowable.never()), Flowable.never()));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.timeout(Functions.justFunction(Flowable.never()));
+            }
+        });
+
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Object> o) throws Exception {
+                return o.timeout(Functions.justFunction(Flowable.never()), Flowable.never());
+            }
+        });
+    }
+
+    @Test
+    public void empty() {
+        Flowable.empty()
+        .timeout(Functions.justFunction(Flowable.never()))
+        .test()
+        .assertResult();
+    }
+
+    @Test
+    public void error() {
+        Flowable.error(new TestException())
+        .timeout(Functions.justFunction(Flowable.never()))
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void emptyInner() {
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+
+        TestSubscriber<Integer> to = ps
+        .timeout(Functions.justFunction(Flowable.empty()))
+        .test();
+
+        ps.onNext(1);
+
+        to.assertFailure(TimeoutException.class, 1);
+    }
+
+    @Test
+    public void badInnerSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            PublishProcessor<Integer> ps = PublishProcessor.create();
+
+            TestSubscriber<Integer> to = ps
+            .timeout(Functions.justFunction(new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+                    observer.onError(new TestException("First"));
+                    observer.onNext(2);
+                    observer.onError(new TestException("Second"));
+                    observer.onComplete();
+                }
+            }))
+            .test();
+
+            ps.onNext(1);
+
+            to.assertFailureAndMessage(TestException.class, "First", 1);
+
+            TestHelper.assertError(errors, 0, TestException.class, "Second");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void badInnerSourceOther() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            PublishProcessor<Integer> ps = PublishProcessor.create();
+
+            TestSubscriber<Integer> to = ps
+            .timeout(Functions.justFunction(new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+                    observer.onError(new TestException("First"));
+                    observer.onNext(2);
+                    observer.onError(new TestException("Second"));
+                    observer.onComplete();
+                }
+            }), Flowable.just(2))
+            .test();
+
+            ps.onNext(1);
+
+            to.assertFailureAndMessage(TestException.class, "First", 1);
+
+            TestHelper.assertError(errors, 0, TestException.class, "Second");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void withOtherMainError() {
+        Flowable.error(new TestException())
+        .timeout(Functions.justFunction(Flowable.never()), Flowable.never())
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void badSourceTimeout() {
+        new Flowable<Integer>() {
+            @Override
+            protected void subscribeActual(Subscriber<? super Integer> observer) {
+                observer.onSubscribe(new BooleanSubscription());
+                observer.onNext(1);
+                observer.onNext(2);
+                observer.onError(new TestException("First"));
+                observer.onNext(3);
+                observer.onComplete();
+                observer.onError(new TestException("Second"));
+            }
+        }
+        .timeout(Functions.justFunction(Flowable.never()), Flowable.<Integer>never())
+        .take(1)
+        .test()
+        .assertResult(1);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimerTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimerTest.java
index c09f4a738e..4fc4cecb32 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimerTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimerTest.java
@@ -284,7 +284,6 @@ public void onComplete() {
     }
 
     @Test
-    @Ignore("RS Subscription no isCancelled")
     public void disposed() {
         TestHelper.checkDisposed(Flowable.timer(1, TimeUnit.DAYS));
     }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java
index fa86917e6f..79d62a44ab 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java
@@ -121,7 +121,7 @@ public void testBackpressureHonoredFlowable() {
         ts.assertComplete();
     }
     @Test(timeout = 2000)
-    @Ignore("PublishSubject no longer emits without requests so this test fails due to the race of onComplete and request")
+    @Ignore("PublishProcessor no longer emits without requests so this test fails due to the race of onComplete and request")
     public void testAsyncRequestedFlowable() {
         Scheduler.Worker w = Schedulers.newThread().createWorker();
         try {
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToSortedListTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToSortedListTest.java
index 81bd033889..c2423f8a5f 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToSortedListTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToSortedListTest.java
@@ -92,7 +92,7 @@ public void testBackpressureHonoredFlowable() {
     }
 
     @Test(timeout = 2000)
-    @Ignore("PublishSubject no longer emits without requests so this test fails due to the race of onComplete and request")
+    @Ignore("PublishProcessor no longer emits without requests so this test fails due to the race of onComplete and request")
     public void testAsyncRequestedFlowable() {
         Scheduler.Worker w = Schedulers.newThread().createWorker();
         try {
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithSizeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithSizeTest.java
index 4022e89732..cfc0985f99 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithSizeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithSizeTest.java
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.flowable;
 
 import static org.junit.Assert.*;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
 import java.util.*;
@@ -24,8 +25,10 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
 
@@ -326,4 +329,121 @@ public void testBackpressureOuterInexact() {
         ts.assertNoErrors();
         ts.assertComplete();
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().window(1));
+
+        TestHelper.checkDisposed(PublishProcessor.create().window(2, 1));
+
+        TestHelper.checkDisposed(PublishProcessor.create().window(1, 2));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Flowable<Object>>>() {
+            @Override
+            public Flowable<Flowable<Object>> apply(Flowable<Object> o) throws Exception {
+                return o.window(1);
+            }
+        });
+
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Flowable<Object>>>() {
+            @Override
+            public Flowable<Flowable<Object>> apply(Flowable<Object> o) throws Exception {
+                return o.window(2, 1);
+            }
+        });
+
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Flowable<Object>>>() {
+            @Override
+            public Flowable<Flowable<Object>> apply(Flowable<Object> o) throws Exception {
+                return o.window(1, 2);
+            }
+        });
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void errorExact() {
+        Flowable.error(new TestException())
+        .window(1)
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void errorSkip() {
+        Flowable.error(new TestException())
+        .window(1, 2)
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void errorOverlap() {
+        Flowable.error(new TestException())
+        .window(2, 1)
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void errorExactInner() {
+        @SuppressWarnings("rawtypes")
+        final TestSubscriber[] to = { null };
+        Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
+        .window(2)
+        .doOnNext(new Consumer<Flowable<Integer>>() {
+            @Override
+            public void accept(Flowable<Integer> w) throws Exception {
+                to[0] = w.test();
+            }
+        })
+        .test()
+        .assertError(TestException.class);
+
+        to[0].assertFailure(TestException.class, 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void errorSkipInner() {
+        @SuppressWarnings("rawtypes")
+        final TestSubscriber[] to = { null };
+        Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
+        .window(2, 3)
+        .doOnNext(new Consumer<Flowable<Integer>>() {
+            @Override
+            public void accept(Flowable<Integer> w) throws Exception {
+                to[0] = w.test();
+            }
+        })
+        .test()
+        .assertError(TestException.class);
+
+        to[0].assertFailure(TestException.class, 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void errorOverlapInner() {
+        @SuppressWarnings("rawtypes")
+        final TestSubscriber[] to = { null };
+        Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
+        .window(3, 2)
+        .doOnNext(new Consumer<Flowable<Integer>>() {
+            @Override
+            public void accept(Flowable<Integer> w) throws Exception {
+                to[0] = w.test();
+            }
+        })
+        .test()
+        .assertError(TestException.class);
+
+        to[0].assertFailure(TestException.class, 1);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
index 5dcc2b973f..aebf555ba0 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
@@ -23,12 +23,11 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.Flowable;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
-import io.reactivex.processors.PublishProcessor;
+import io.reactivex.processors.*;
 import io.reactivex.schedulers.*;
 import io.reactivex.subscribers.*;
 
@@ -499,14 +498,14 @@ public void overlapBackpressure2() {
 
     @Test
     public void dispose() {
-        TestHelper.checkDisposed(Flowable.range(1, 5).window(1, TimeUnit.DAYS, Schedulers.single()));
+        TestHelper.checkDisposed(Flowable.range(1, 5).window(1, TimeUnit.DAYS, Schedulers.single()).onBackpressureDrop());
 
-        TestHelper.checkDisposed(Flowable.range(1, 5).window(2, 1, TimeUnit.DAYS, Schedulers.single()));
+        TestHelper.checkDisposed(Flowable.range(1, 5).window(2, 1, TimeUnit.DAYS, Schedulers.single()).onBackpressureDrop());
 
-        TestHelper.checkDisposed(Flowable.range(1, 5).window(1, 2, TimeUnit.DAYS, Schedulers.single()));
+        TestHelper.checkDisposed(Flowable.range(1, 5).window(1, 2, TimeUnit.DAYS, Schedulers.single()).onBackpressureDrop());
 
         TestHelper.checkDisposed(Flowable.never()
-                .window(1, TimeUnit.DAYS, Schedulers.single(), 2, true));
+                .window(1, TimeUnit.DAYS, Schedulers.single(), 2, true).onBackpressureDrop());
     }
 
     @Test
@@ -541,4 +540,136 @@ public void restartTimerMany() {
         .assertNoErrors()
         .assertComplete();
     }
+
+    @Test
+    public void exactUnboundedReentrant() {
+        TestScheduler scheduler = new TestScheduler();
+
+        final FlowableProcessor<Integer> ps = PublishProcessor.<Integer>create();
+
+        TestSubscriber<Integer> to = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+            }
+        };
+
+        ps.window(1, TimeUnit.MILLISECONDS, scheduler)
+        .flatMap(new Function<Flowable<Integer>, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Flowable<Integer> v) throws Exception {
+                return v;
+            }
+        })
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to
+        .awaitDone(1, TimeUnit.SECONDS)
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void exactBoundedReentrant() {
+        TestScheduler scheduler = new TestScheduler();
+
+        final FlowableProcessor<Integer> ps = PublishProcessor.<Integer>create();
+
+        TestSubscriber<Integer> to = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+            }
+        };
+
+        ps.window(1, TimeUnit.MILLISECONDS, scheduler, 10, true)
+        .flatMap(new Function<Flowable<Integer>, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Flowable<Integer> v) throws Exception {
+                return v;
+            }
+        })
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to
+        .awaitDone(1, TimeUnit.SECONDS)
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void exactBoundedReentrant2() {
+        TestScheduler scheduler = new TestScheduler();
+
+        final FlowableProcessor<Integer> ps = PublishProcessor.<Integer>create();
+
+        TestSubscriber<Integer> to = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+            }
+        };
+
+        ps.window(1, TimeUnit.MILLISECONDS, scheduler, 2, true)
+        .flatMap(new Function<Flowable<Integer>, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Flowable<Integer> v) throws Exception {
+                return v;
+            }
+        })
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to
+        .awaitDone(1, TimeUnit.SECONDS)
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void skipReentrant() {
+        TestScheduler scheduler = new TestScheduler();
+
+        final FlowableProcessor<Integer> ps = PublishProcessor.<Integer>create();
+
+        TestSubscriber<Integer> to = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+            }
+        };
+
+        ps.window(1, 2, TimeUnit.MILLISECONDS, scheduler)
+        .flatMap(new Function<Flowable<Integer>, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Flowable<Integer> v) throws Exception {
+                return v;
+            }
+        })
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to
+        .awaitDone(1, TimeUnit.SECONDS)
+        .assertResult(1, 2);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java
index 5664ae5dbb..9226624db3 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.flowable;
 
 import static org.junit.Assert.*;
+import static org.mockito.ArgumentMatchers.*;
 import static org.mockito.Mockito.*;
 
 import java.util.*;
@@ -25,6 +26,9 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.internal.util.CrashingMappedIterable;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.subscribers.TestSubscriber;
 
@@ -576,4 +580,79 @@ public void with4Others() {
         ts.assertComplete();
     }
 
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Flowable.just(1).withLatestFrom(Flowable.just(2), new BiFunction<Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b) throws Exception {
+                return a;
+            }
+        }));
+
+        TestHelper.checkDisposed(Flowable.just(1).withLatestFrom(Flowable.just(2), Flowable.just(3), new Function3<Integer, Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b, Integer c) throws Exception {
+                return a;
+            }
+        }));
+    }
+
+    @Test
+    public void manyIteratorThrows() {
+        Flowable.just(1)
+        .withLatestFrom(new CrashingMappedIterable<Flowable<Integer>>(1, 100, 100, new Function<Integer, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer v) throws Exception {
+                return Flowable.just(2);
+            }
+        }), new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return a;
+            }
+        })
+        .test()
+        .assertFailureAndMessage(TestException.class, "iterator()");
+    }
+
+    @Test
+    public void manyCombinerThrows() {
+        Flowable.just(1).withLatestFrom(Flowable.just(2), Flowable.just(3), new Function3<Integer, Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b, Integer c) throws Exception {
+                throw new TestException();
+            }
+        })
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void manyErrors() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+                    observer.onError(new TestException("First"));
+                    observer.onNext(1);
+                    observer.onError(new TestException("Second"));
+                    observer.onComplete();
+                }
+            }.withLatestFrom(Flowable.just(2), Flowable.just(3), new Function3<Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c) throws Exception {
+                    return a;
+                }
+            })
+            .test()
+            .assertFailureAndMessage(TestException.class, "First");
+
+            TestHelper.assertError(errors, 0, TestException.class, "Second");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipIterableTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipIterableTest.java
index 101b79995b..cb809ad4c0 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipIterableTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipIterableTest.java
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.flowable;
 
 import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
 import java.util.*;
@@ -26,6 +27,9 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.internal.util.CrashingIterable;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
 
 public class FlowableZipIterableTest {
@@ -358,4 +362,71 @@ public void testTake2() {
 
         assertEquals(2, squareStr.counter.get());
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Flowable.just(1).zipWith(Arrays.asList(1), new BiFunction<Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Integer>, Flowable<Object>>() {
+            @Override
+            public Flowable<Object> apply(Flowable<Integer> o) throws Exception {
+                return o.zipWith(Arrays.asList(1), new BiFunction<Integer, Integer, Object>() {
+                    @Override
+                    public Object apply(Integer a, Integer b) throws Exception {
+                        return a + b;
+                    }
+                });
+            }
+        });
+    }
+
+    @Test
+    public void iteratorThrows() {
+        Flowable.just(1).zipWith(new CrashingIterable(100, 1, 100), new BiFunction<Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        })
+        .test()
+        .assertFailureAndMessage(TestException.class, "hasNext()");
+    }
+
+    @Test
+    public void badSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Flowable<Integer>() {
+                @Override
+                protected void subscribeActual(Subscriber<? super Integer> observer) {
+                    observer.onSubscribe(new BooleanSubscription());
+                    observer.onNext(1);
+                    observer.onComplete();
+                    observer.onNext(2);
+                    observer.onError(new TestException());
+                    observer.onComplete();
+                }
+            }
+            .zipWith(Arrays.asList(1), new BiFunction<Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b) throws Exception {
+                    return a + b;
+                }
+            })
+            .test()
+            .assertResult(2);
+
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java
index dd22f4f442..7692811aae 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java
@@ -26,6 +26,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
@@ -82,12 +83,12 @@ public void testCollectionSizeDifferentThanFunction() {
     }
 
     @Test
-    public void testStartpingDifferentLengthObservableSequences1() {
+    public void testStartpingDifferentLengthFlowableSequences1() {
         Subscriber<String> w = TestHelper.mockSubscriber();
 
-        TestObservable w1 = new TestObservable();
-        TestObservable w2 = new TestObservable();
-        TestObservable w3 = new TestObservable();
+        TestFlowable w1 = new TestFlowable();
+        TestFlowable w2 = new TestFlowable();
+        TestFlowable w3 = new TestFlowable();
 
         Flowable<String> zipW = Flowable.zip(
                 Flowable.unsafeCreate(w1), Flowable.unsafeCreate(w2),
@@ -117,12 +118,12 @@ public void testStartpingDifferentLengthObservableSequences1() {
     }
 
     @Test
-    public void testStartpingDifferentLengthObservableSequences2() {
+    public void testStartpingDifferentLengthFlowableSequences2() {
         Subscriber<String> w = TestHelper.mockSubscriber();
 
-        TestObservable w1 = new TestObservable();
-        TestObservable w2 = new TestObservable();
-        TestObservable w3 = new TestObservable();
+        TestFlowable w1 = new TestFlowable();
+        TestFlowable w2 = new TestFlowable();
+        TestFlowable w3 = new TestFlowable();
 
         Flowable<String> zipW = Flowable.zip(Flowable.unsafeCreate(w1), Flowable.unsafeCreate(w2), Flowable.unsafeCreate(w3), getConcat3StringsZipr());
         zipW.subscribe(w);
@@ -179,7 +180,7 @@ public void testAggregatorSimple() {
 
         Flowable.zip(r1, r2, zipr2).subscribe(observer);
 
-        /* simulate the Observables pushing data into the aggregator */
+        /* simulate the Flowables pushing data into the aggregator */
         r1.onNext("hello");
         r2.onNext("world");
 
@@ -205,7 +206,7 @@ public void testAggregatorSimple() {
 
     @Test
     public void testAggregatorDifferentSizedResultsWithOnComplete() {
-        /* create the aggregator which will execute the zip function when all Observables provide values */
+        /* create the aggregator which will execute the zip function when all Flowables provide values */
         /* define a Subscriber to receive aggregated events */
         PublishProcessor<String> r1 = PublishProcessor.create();
         PublishProcessor<String> r2 = PublishProcessor.create();
@@ -213,7 +214,7 @@ public void testAggregatorDifferentSizedResultsWithOnComplete() {
         Subscriber<String> observer = TestHelper.mockSubscriber();
         Flowable.zip(r1, r2, zipr2).subscribe(observer);
 
-        /* simulate the Observables pushing data into the aggregator */
+        /* simulate the Flowables pushing data into the aggregator */
         r1.onNext("hello");
         r2.onNext("world");
         r2.onComplete();
@@ -241,7 +242,7 @@ public void testAggregateMultipleTypes() {
 
         Flowable.zip(r1, r2, zipr2).subscribe(observer);
 
-        /* simulate the Observables pushing data into the aggregator */
+        /* simulate the Flowables pushing data into the aggregator */
         r1.onNext("hello");
         r2.onNext(1);
         r2.onComplete();
@@ -270,7 +271,7 @@ public void testAggregate3Types() {
 
         Flowable.zip(r1, r2, r3, zipr3).subscribe(observer);
 
-        /* simulate the Observables pushing data into the aggregator */
+        /* simulate the Flowables pushing data into the aggregator */
         r1.onNext("hello");
         r2.onNext(2);
         r3.onNext(Arrays.asList(5, 6, 7));
@@ -289,7 +290,7 @@ public void testAggregatorsWithDifferentSizesAndTiming() {
 
         Flowable.zip(r1, r2, zipr2).subscribe(observer);
 
-        /* simulate the Observables pushing data into the aggregator */
+        /* simulate the Flowables pushing data into the aggregator */
         r1.onNext("one");
         r1.onNext("two");
         r1.onNext("three");
@@ -324,7 +325,7 @@ public void testAggregatorError() {
 
         Flowable.zip(r1, r2, zipr2).subscribe(observer);
 
-        /* simulate the Observables pushing data into the aggregator */
+        /* simulate the Flowables pushing data into the aggregator */
         r1.onNext("hello");
         r2.onNext("world");
 
@@ -352,7 +353,7 @@ public void testAggregatorUnsubscribe() {
 
         Flowable.zip(r1, r2, zipr2).subscribe(ts);
 
-        /* simulate the Observables pushing data into the aggregator */
+        /* simulate the Flowables pushing data into the aggregator */
         r1.onNext("hello");
         r2.onNext("world");
 
@@ -379,7 +380,7 @@ public void testAggregatorEarlyCompletion() {
 
         Flowable.zip(r1, r2, zipr2).subscribe(observer);
 
-        /* simulate the Observables pushing data into the aggregator */
+        /* simulate the Flowables pushing data into the aggregator */
         r1.onNext("one");
         r1.onNext("two");
         r1.onComplete();
@@ -614,7 +615,7 @@ private static String getStringValue(Object o) {
         }
     }
 
-    private static class TestObservable implements Publisher<String> {
+    private static class TestFlowable implements Publisher<String> {
 
         Subscriber<? super String> observer;
 
@@ -808,9 +809,9 @@ public String apply(Integer a, Integer b) {
     @Test
     public void testStartInfiniteAndFinite() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
-        final CountDownLatch infiniteObservable = new CountDownLatch(1);
+        final CountDownLatch infiniteFlowable = new CountDownLatch(1);
         Flowable<String> os = OBSERVABLE_OF_5_INTEGERS
-                .zipWith(ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS(infiniteObservable), new BiFunction<Integer, Integer, String>() {
+                .zipWith(ASYNC_OBSERVABLE_OF_INFINITE_INTEGERS(infiniteFlowable), new BiFunction<Integer, Integer, String>() {
 
                     @Override
                     public String apply(Integer a, Integer b) {
@@ -840,7 +841,7 @@ public void onNext(String s) {
         });
 
         latch.await(1000, TimeUnit.MILLISECONDS);
-        if (!infiniteObservable.await(2000, TimeUnit.MILLISECONDS)) {
+        if (!infiniteFlowable.await(2000, TimeUnit.MILLISECONDS)) {
             throw new RuntimeException("didn't unsubscribe");
         }
 
@@ -930,7 +931,7 @@ public void accept(String s) {
     }
 
     @Test
-    public void testStartEmptyObservables() {
+    public void testStartEmptyFlowables() {
 
         Flowable<String> o = Flowable.zip(Flowable.<Integer> empty(), Flowable.<String> empty(), new BiFunction<Integer, String, String>() {
 
@@ -999,8 +1000,8 @@ public Object apply(final Object[] args) {
     public void testBackpressureSync() {
         AtomicInteger generatedA = new AtomicInteger();
         AtomicInteger generatedB = new AtomicInteger();
-        Flowable<Integer> o1 = createInfiniteObservable(generatedA);
-        Flowable<Integer> o2 = createInfiniteObservable(generatedB);
+        Flowable<Integer> o1 = createInfiniteFlowable(generatedA);
+        Flowable<Integer> o2 = createInfiniteFlowable(generatedB);
 
         TestSubscriber<String> ts = new TestSubscriber<String>();
         Flowable.zip(o1, o2, new BiFunction<Integer, Integer, String>() {
@@ -1023,8 +1024,8 @@ public String apply(Integer t1, Integer t2) {
     public void testBackpressureAsync() {
         AtomicInteger generatedA = new AtomicInteger();
         AtomicInteger generatedB = new AtomicInteger();
-        Flowable<Integer> o1 = createInfiniteObservable(generatedA).subscribeOn(Schedulers.computation());
-        Flowable<Integer> o2 = createInfiniteObservable(generatedB).subscribeOn(Schedulers.computation());
+        Flowable<Integer> o1 = createInfiniteFlowable(generatedA).subscribeOn(Schedulers.computation());
+        Flowable<Integer> o2 = createInfiniteFlowable(generatedB).subscribeOn(Schedulers.computation());
 
         TestSubscriber<String> ts = new TestSubscriber<String>();
         Flowable.zip(o1, o2, new BiFunction<Integer, Integer, String>() {
@@ -1044,11 +1045,11 @@ public String apply(Integer t1, Integer t2) {
     }
 
     @Test
-    public void testDownstreamBackpressureRequestsWithFiniteSyncObservables() {
+    public void testDownstreamBackpressureRequestsWithFiniteSyncFlowables() {
         AtomicInteger generatedA = new AtomicInteger();
         AtomicInteger generatedB = new AtomicInteger();
-        Flowable<Integer> o1 = createInfiniteObservable(generatedA).take(Flowable.bufferSize() * 2);
-        Flowable<Integer> o2 = createInfiniteObservable(generatedB).take(Flowable.bufferSize() * 2);
+        Flowable<Integer> o1 = createInfiniteFlowable(generatedA).take(Flowable.bufferSize() * 2);
+        Flowable<Integer> o2 = createInfiniteFlowable(generatedB).take(Flowable.bufferSize() * 2);
 
         TestSubscriber<String> ts = new TestSubscriber<String>();
         Flowable.zip(o1, o2, new BiFunction<Integer, Integer, String>() {
@@ -1069,11 +1070,11 @@ public String apply(Integer t1, Integer t2) {
     }
 
     @Test
-    public void testDownstreamBackpressureRequestsWithInfiniteAsyncObservables() {
+    public void testDownstreamBackpressureRequestsWithInfiniteAsyncFlowables() {
         AtomicInteger generatedA = new AtomicInteger();
         AtomicInteger generatedB = new AtomicInteger();
-        Flowable<Integer> o1 = createInfiniteObservable(generatedA).subscribeOn(Schedulers.computation());
-        Flowable<Integer> o2 = createInfiniteObservable(generatedB).subscribeOn(Schedulers.computation());
+        Flowable<Integer> o1 = createInfiniteFlowable(generatedA).subscribeOn(Schedulers.computation());
+        Flowable<Integer> o2 = createInfiniteFlowable(generatedB).subscribeOn(Schedulers.computation());
 
         TestSubscriber<String> ts = new TestSubscriber<String>();
         Flowable.zip(o1, o2, new BiFunction<Integer, Integer, String>() {
@@ -1094,11 +1095,11 @@ public String apply(Integer t1, Integer t2) {
     }
 
     @Test
-    public void testDownstreamBackpressureRequestsWithInfiniteSyncObservables() {
+    public void testDownstreamBackpressureRequestsWithInfiniteSyncFlowables() {
         AtomicInteger generatedA = new AtomicInteger();
         AtomicInteger generatedB = new AtomicInteger();
-        Flowable<Integer> o1 = createInfiniteObservable(generatedA);
-        Flowable<Integer> o2 = createInfiniteObservable(generatedB);
+        Flowable<Integer> o1 = createInfiniteFlowable(generatedA);
+        Flowable<Integer> o2 = createInfiniteFlowable(generatedB);
 
         TestSubscriber<String> ts = new TestSubscriber<String>();
         Flowable.zip(o1, o2, new BiFunction<Integer, Integer, String>() {
@@ -1118,7 +1119,7 @@ public String apply(Integer t1, Integer t2) {
         assertTrue(generatedB.get() < (Flowable.bufferSize() * 4));
     }
 
-    private Flowable<Integer> createInfiniteObservable(final AtomicInteger generated) {
+    private Flowable<Integer> createInfiniteFlowable(final AtomicInteger generated) {
         Flowable<Integer> observable = Flowable.fromIterable(new Iterable<Integer>() {
             @Override
             public Iterator<Integer> iterator() {
@@ -1587,4 +1588,31 @@ public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integ
     }
 
 
+    @Test
+    public void zipArrayMany() {
+        @SuppressWarnings("unchecked")
+        Flowable<Integer>[] arr = new Flowable[10];
+
+        Arrays.fill(arr, Flowable.just(1));
+
+        Flowable.zip(Arrays.asList(arr), new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return Arrays.toString(a);
+            }
+        })
+        .test()
+        .assertResult("[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]");
+    }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Flowable.zip(Flowable.just(1), Flowable.just(1), new BiFunction<Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }));
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
index 658b271488..e3809667ed 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
@@ -22,9 +22,9 @@
 
 import org.junit.Test;
 
+import io.reactivex.*;
 import io.reactivex.Observable;
-import io.reactivex.Single;
-import io.reactivex.functions.BiConsumer;
+import io.reactivex.functions.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ObservableCollectTest {
@@ -274,4 +274,88 @@ public void accept(HashSet<Integer> s, Integer v) throws Exception {
         .test()
         .assertResult(new HashSet<Integer>(Arrays.asList(1, 2)));
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Observable.range(1, 3).collect(new Callable<List<Integer>>() {
+            @Override
+            public List<Integer> call() throws Exception {
+                return new ArrayList<Integer>();
+            }
+        }, new BiConsumer<List<Integer>, Integer>() {
+            @Override
+            public void accept(List<Integer> a, Integer b) throws Exception {
+                a.add(b);
+            }
+        }));
+
+        TestHelper.checkDisposed(Observable.range(1, 3).collect(new Callable<List<Integer>>() {
+            @Override
+            public List<Integer> call() throws Exception {
+                return new ArrayList<Integer>();
+            }
+        }, new BiConsumer<List<Integer>, Integer>() {
+            @Override
+            public void accept(List<Integer> a, Integer b) throws Exception {
+                a.add(b);
+            }
+        }).toObservable());
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeObservableToSingle(new Function<Observable<Integer>, SingleSource<List<Integer>>>() {
+            @Override
+            public SingleSource<List<Integer>> apply(Observable<Integer> o) throws Exception {
+                return o.collect(new Callable<List<Integer>>() {
+                    @Override
+                    public List<Integer> call() throws Exception {
+                        return new ArrayList<Integer>();
+                    }
+                }, new BiConsumer<List<Integer>, Integer>() {
+                    @Override
+                    public void accept(List<Integer> a, Integer b) throws Exception {
+                        a.add(b);
+                    }
+                });
+            }
+        });
+
+        TestHelper.checkDoubleOnSubscribeObservable(new Function<Observable<Integer>, ObservableSource<List<Integer>>>() {
+            @Override
+            public ObservableSource<List<Integer>> apply(Observable<Integer> o) throws Exception {
+                return o.collect(new Callable<List<Integer>>() {
+                    @Override
+                    public List<Integer> call() throws Exception {
+                        return new ArrayList<Integer>();
+                    }
+                }, new BiConsumer<List<Integer>, Integer>() {
+                    @Override
+                    public void accept(List<Integer> a, Integer b) throws Exception {
+                        a.add(b);
+                    }
+                }).toObservable();
+            }
+        });
+    }
+
+    @Test
+    public void badSource() {
+        TestHelper.checkBadSourceObservable(new Function<Observable<Integer>, Object>() {
+            @Override
+            public Object apply(Observable<Integer> o) throws Exception {
+                return o.collect(new Callable<List<Integer>>() {
+                    @Override
+                    public List<Integer> call() throws Exception {
+                        return new ArrayList<Integer>();
+                    }
+                }, new BiConsumer<List<Integer>, Integer>() {
+                    @Override
+                    public void accept(List<Integer> a, Integer b) throws Exception {
+                        a.add(b);
+                    }
+                }).toObservable();
+            }
+        }, false, 1, 2, Arrays.asList(1));
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java
index a8092651f3..103e48c4a2 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java
@@ -342,4 +342,38 @@ protected void subscribeActual(Observer<? super Integer> observer) {
             RxJavaPlugins.reset();
         }
     }
+
+    @Test
+    public void badSourceSelector() {
+        TestHelper.checkBadSourceObservable(new Function<Observable<Integer>, Object>() {
+            @Override
+            public Object apply(Observable<Integer> o) throws Exception {
+                return o.debounce(new Function<Integer, ObservableSource<Long>>() {
+                    @Override
+                    public ObservableSource<Long> apply(Integer v) throws Exception {
+                        return Observable.timer(1, TimeUnit.SECONDS);
+                    }
+                });
+            }
+        }, false, 1, 1, 1);
+
+        TestHelper.checkBadSourceObservable(new Function<Observable<Integer>, Object>() {
+            @Override
+            public Object apply(final Observable<Integer> o) throws Exception {
+                return Observable.just(1).debounce(new Function<Integer, ObservableSource<Integer>>() {
+                    @Override
+                    public ObservableSource<Integer> apply(Integer v) throws Exception {
+                        return o;
+                    }
+                });
+            }
+        }, false, 1, 1, 1);
+    }
+
+    @Test
+    public void debounceWithEmpty() {
+        Observable.just(1).debounce(Functions.justFunction(Observable.empty()))
+        .test()
+        .assertResult(1);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletableTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletableTest.java
index b436c2770d..fa900d537c 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletableTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapCompletableTest.java
@@ -13,13 +13,15 @@
 
 package io.reactivex.internal.operators.observable;
 
+import static org.junit.Assert.*;
+
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
-import static org.junit.Assert.*;
 import org.junit.Test;
 
 import io.reactivex.*;
+import io.reactivex.disposables.*;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.fuseable.QueueDisposable;
@@ -342,6 +344,7 @@ public CompletableSource apply(Integer v) throws Exception {
                 return Completable.complete();
             }
         })
+        .<Integer>toObservable()
         .subscribe(to);
 
         to
@@ -360,4 +363,118 @@ public CompletableSource apply(Integer v) throws Exception {
             }
         }));
     }
+
+    @Test
+    public void innerObserver() {
+        Observable.range(1, 3)
+        .flatMapCompletable(new Function<Integer, CompletableSource>() {
+            @Override
+            public CompletableSource apply(Integer v) throws Exception {
+                return new Completable() {
+                    @Override
+                    protected void subscribeActual(CompletableObserver s) {
+                        s.onSubscribe(Disposables.empty());
+
+                        assertFalse(((Disposable)s).isDisposed());
+
+                        ((Disposable)s).dispose();
+
+                        assertTrue(((Disposable)s).isDisposed());
+                    }
+                };
+            }
+        })
+        .test();
+    }
+
+    @Test
+    public void badSource() {
+        TestHelper.checkBadSourceObservable(new Function<Observable<Integer>, Object>() {
+            @Override
+            public Object apply(Observable<Integer> o) throws Exception {
+                return o.flatMapCompletable(new Function<Integer, CompletableSource>() {
+                    @Override
+                    public CompletableSource apply(Integer v) throws Exception {
+                        return Completable.complete();
+                    }
+                });
+            }
+        }, false, 1, null);
+    }
+
+    @Test
+    public void fusedInternalsObservable() {
+        Observable.range(1, 10)
+        .flatMapCompletable(new Function<Integer, CompletableSource>() {
+            @Override
+            public CompletableSource apply(Integer v) throws Exception {
+                return Completable.complete();
+            }
+        })
+        .toObservable()
+        .subscribe(new Observer<Object>() {
+            @Override
+            public void onSubscribe(Disposable d) {
+                QueueDisposable<?> qd = (QueueDisposable<?>)d;
+                try {
+                    assertNull(qd.poll());
+                } catch (Throwable ex) {
+                    throw new RuntimeException(ex);
+                }
+                assertTrue(qd.isEmpty());
+                qd.clear();
+            }
+
+            @Override
+            public void onNext(Object t) {
+            }
+
+            @Override
+            public void onError(Throwable t) {
+            }
+
+            @Override
+            public void onComplete() {
+            }
+        });
+    }
+
+    @Test
+    public void innerObserverObservable() {
+        Observable.range(1, 3)
+        .flatMapCompletable(new Function<Integer, CompletableSource>() {
+            @Override
+            public CompletableSource apply(Integer v) throws Exception {
+                return new Completable() {
+                    @Override
+                    protected void subscribeActual(CompletableObserver s) {
+                        s.onSubscribe(Disposables.empty());
+
+                        assertFalse(((Disposable)s).isDisposed());
+
+                        ((Disposable)s).dispose();
+
+                        assertTrue(((Disposable)s).isDisposed());
+                    }
+                };
+            }
+        })
+        .toObservable()
+        .test();
+    }
+
+    @Test
+    public void badSourceObservable() {
+        TestHelper.checkBadSourceObservable(new Function<Observable<Integer>, Object>() {
+            @Override
+            public Object apply(Observable<Integer> o) throws Exception {
+                return o.flatMapCompletable(new Function<Integer, CompletableSource>() {
+                    @Override
+                    public CompletableSource apply(Integer v) throws Exception {
+                        return Completable.complete();
+                    }
+                }).toObservable();
+            }
+        }, false, 1, null);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java
index 1ba29dcfcf..203548b4e5 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java
@@ -32,6 +32,8 @@
 import io.reactivex.observables.GroupedObservable;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subjects.PublishSubject;
+
 import org.mockito.Mockito;
 
 public class ObservableGroupByTest {
@@ -1471,4 +1473,63 @@ public void keyAndValueSelectorAndDelayError() {
         .assertFailure(TestException.class, 1);
     }
 
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Observable.just(1).groupBy(Functions.justFunction(1)));
+
+        Observable.just(1)
+        .groupBy(Functions.justFunction(1))
+        .doOnNext(new Consumer<GroupedObservable<Integer, Integer>>() {
+            @Override
+            public void accept(GroupedObservable<Integer, Integer> g) throws Exception {
+                TestHelper.checkDisposed(g);
+            }
+        })
+        .test();
+    }
+
+    @Test
+    public void reentrantComplete() {
+        final PublishSubject<Integer> ps = PublishSubject.create();
+
+        TestObserver<Integer> to = new TestObserver<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onComplete();
+                }
+            }
+        };
+
+        Observable.merge(ps.groupBy(Functions.justFunction(1)))
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to.assertResult(1);
+    }
+
+    @Test
+    public void reentrantCompleteCancel() {
+        final PublishSubject<Integer> ps = PublishSubject.create();
+
+        TestObserver<Integer> to = new TestObserver<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onComplete();
+                    dispose();
+                }
+            }
+        };
+
+        Observable.merge(ps.groupBy(Functions.justFunction(1)))
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to.assertSubscribed().assertValue(1).assertNoErrors().assertNotComplete();
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableIgnoreElementsTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableIgnoreElementsTest.java
index 97a02fa96c..c4940a68e1 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableIgnoreElementsTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableIgnoreElementsTest.java
@@ -169,4 +169,11 @@ public void cancel() {
 
         TestHelper.checkDisposed(pp.ignoreElements().<Integer>toObservable());
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Observable.just(1).ignoreElements());
+
+        TestHelper.checkDisposed(Observable.just(1).ignoreElements().toObservable());
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableIntervalRangeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableIntervalRangeTest.java
index 18b7e12077..f7b3e78d47 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableIntervalRangeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableIntervalRangeTest.java
@@ -71,4 +71,9 @@ public void longOverflow() {
             assertEquals("Overflow! start + count is bigger than Long.MAX_VALUE", ex.getMessage());
         }
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Observable.intervalRange(1, 2, 1, 1, TimeUnit.MILLISECONDS));
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableMaterializeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableMaterializeTest.java
index 98ce6a8921..34407b41b6 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableMaterializeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableMaterializeTest.java
@@ -24,7 +24,7 @@
 import io.reactivex.Observable;
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposables;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.observers.*;
 
 public class ObservableMaterializeTest {
@@ -176,4 +176,19 @@ public void run() {
             t.start();
         }
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Observable.just(1).materialize());
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeObservable(new Function<Observable<Object>, ObservableSource<Notification<Object>>>() {
+            @Override
+            public ObservableSource<Notification<Object>> apply(Observable<Object> o) throws Exception {
+                return o.materialize();
+            }
+        });
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableRangeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableRangeTest.java
index 00c85ccb27..6752f334d4 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableRangeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableRangeTest.java
@@ -23,6 +23,7 @@
 
 import io.reactivex.*;
 import io.reactivex.functions.Consumer;
+import io.reactivex.internal.fuseable.QueueDisposable;
 import io.reactivex.observers.*;
 
 public class ObservableRangeTest {
@@ -153,4 +154,14 @@ public void negativeCount() {
         }
     }
 
+    @Test
+    public void requestWrongFusion() {
+        TestObserver<Integer> to = ObserverFusion.newTest(QueueDisposable.ASYNC);
+
+        Observable.range(1, 5)
+        .subscribe(to);
+
+        ObserverFusion.assertFusion(to, QueueDisposable.NONE)
+        .assertResult(1, 2, 3, 4, 5);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableScanTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableScanTest.java
index 1e5e6f0796..7bcecd4e66 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableScanTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableScanTest.java
@@ -237,6 +237,13 @@ public Object apply(Object a, Object b) throws Exception {
                 return a;
             }
         }));
+
+        TestHelper.checkDisposed(PublishSubject.<Integer>create().scan(0, new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }));
     }
 
     @Test
@@ -252,6 +259,18 @@ public Object apply(Object a, Object b) throws Exception {
                 });
             }
         });
+
+        TestHelper.checkDoubleOnSubscribeObservable(new Function<Observable<Object>, ObservableSource<Object>>() {
+            @Override
+            public ObservableSource<Object> apply(Observable<Object> o) throws Exception {
+                return o.scan(0, new BiFunction<Object, Object, Object>() {
+                    @Override
+                    public Object apply(Object a, Object b) throws Exception {
+                        return a;
+                    }
+                });
+            }
+        });
     }
 
     @Test
@@ -266,4 +285,19 @@ public Object apply(Object a, Object b) throws Exception {
         .test()
         .assertFailure(TestException.class);
     }
+
+    @Test
+    public void badSource() {
+        TestHelper.checkBadSourceObservable(new Function<Observable<Object>, Object>() {
+            @Override
+            public Object apply(Observable<Object> o) throws Exception {
+                return o.scan(0, new BiFunction<Object, Object, Object>() {
+                    @Override
+                    public Object apply(Object a, Object b) throws Exception {
+                        return a;
+                    }
+                });
+            }
+        }, false, 1, 1, 0, 0);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipTest.java
index 49fa8514f2..ffcb2639bd 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipTest.java
@@ -144,4 +144,8 @@ public void testRequestOverflowDoesNotOccur() {
         assertEquals(Arrays.asList(6,7,8,9,10), ts.values());
     }
 
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Observable.just(1).skip(2));
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipUntilTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipUntilTest.java
index 2d6e59c037..b9d71c3dce 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipUntilTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipUntilTest.java
@@ -18,6 +18,7 @@
 import org.junit.*;
 
 import io.reactivex.*;
+import io.reactivex.functions.Function;
 import io.reactivex.subjects.PublishSubject;
 
 public class ObservableSkipUntilTest {
@@ -151,4 +152,26 @@ public void otherThrowsImmediately() {
         verify(observer, times(1)).onError(any(Throwable.class));
         verify(observer, never()).onComplete();
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishSubject.create().skipUntil(PublishSubject.create()));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeObservable(new Function<Observable<Object>, ObservableSource<Object>>() {
+            @Override
+            public ObservableSource<Object> apply(Observable<Object> o) throws Exception {
+                return o.skipUntil(Observable.never());
+            }
+        });
+
+        TestHelper.checkDoubleOnSubscribeObservable(new Function<Observable<Object>, ObservableSource<Object>>() {
+            @Override
+            public ObservableSource<Object> apply(Observable<Object> o) throws Exception {
+                return Observable.never().skipUntil(o);
+            }
+        });
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithObservableTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithObservableTest.java
index 1d692cd0af..cd620f6251 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithObservableTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithObservableTest.java
@@ -18,18 +18,19 @@
 import static org.mockito.Mockito.*;
 
 import java.util.*;
-import java.util.concurrent.Callable;
+import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Test;
 
+import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
-import io.reactivex.TestHelper;
 import io.reactivex.exceptions.*;
+import io.reactivex.functions.Function;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.observers.*;
-import io.reactivex.subjects.PublishSubject;
+import io.reactivex.subjects.*;
 
 public class ObservableWindowWithObservableTest {
 
@@ -450,4 +451,133 @@ public void mainError() {
         .test()
         .assertError(TestException.class);
     }
+
+    @Test
+    public void innerBadSource() {
+        TestHelper.checkBadSourceObservable(new Function<Observable<Integer>, Object>() {
+            @Override
+            public Object apply(Observable<Integer> o) throws Exception {
+                return Observable.just(1).window(o).flatMap(new Function<Observable<Integer>, ObservableSource<Integer>>() {
+                    @Override
+                    public ObservableSource<Integer> apply(Observable<Integer> v) throws Exception {
+                        return v;
+                    }
+                });
+            }
+        }, false, 1, 1, (Object[])null);
+
+        TestHelper.checkBadSourceObservable(new Function<Observable<Integer>, Object>() {
+            @Override
+            public Object apply(Observable<Integer> o) throws Exception {
+                return Observable.just(1).window(Functions.justCallable(o)).flatMap(new Function<Observable<Integer>, ObservableSource<Integer>>() {
+                    @Override
+                    public ObservableSource<Integer> apply(Observable<Integer> v) throws Exception {
+                        return v;
+                    }
+                });
+            }
+        }, false, 1, 1, (Object[])null);
+    }
+
+    @Test
+    public void reentrant() {
+        final Subject<Integer> ps = PublishSubject.<Integer>create();
+
+        TestObserver<Integer> to = new TestObserver<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+            }
+        };
+
+        ps.window(BehaviorSubject.createDefault(1))
+        .flatMap(new Function<Observable<Integer>, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Observable<Integer> v) throws Exception {
+                return v;
+            }
+        })
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to
+        .awaitDone(1, TimeUnit.SECONDS)
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void reentrantCallable() {
+        final Subject<Integer> ps = PublishSubject.<Integer>create();
+
+        TestObserver<Integer> to = new TestObserver<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+            }
+        };
+
+        ps.window(new Callable<Observable<Integer>>() {
+            boolean once;
+            @Override
+            public Observable<Integer> call() throws Exception {
+                if (!once) {
+                    once = true;
+                    return BehaviorSubject.createDefault(1);
+                }
+                return Observable.never();
+            }
+        })
+        .flatMap(new Function<Observable<Integer>, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Observable<Integer> v) throws Exception {
+                return v;
+            }
+        })
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to
+        .awaitDone(1, TimeUnit.SECONDS)
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void badSource() {
+        TestHelper.checkBadSourceObservable(new Function<Observable<Object>, Object>() {
+            @Override
+            public Object apply(Observable<Object> o) throws Exception {
+                return o.window(Observable.never()).flatMap(new Function<Observable<Object>, ObservableSource<Object>>() {
+                    @Override
+                    public ObservableSource<Object> apply(Observable<Object> v) throws Exception {
+                        return v;
+                    }
+                });
+            }
+        }, false, 1, 1, 1);
+    }
+
+    @Test
+    public void badSourceCallable() {
+        TestHelper.checkBadSourceObservable(new Function<Observable<Object>, Object>() {
+            @Override
+            public Object apply(Observable<Object> o) throws Exception {
+                return o.window(Functions.justCallable(Observable.never())).flatMap(new Function<Observable<Object>, ObservableSource<Object>>() {
+                    @Override
+                    public ObservableSource<Object> apply(Observable<Object> v) throws Exception {
+                        return v;
+                    }
+                });
+            }
+        }, false, 1, 1, 1);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithStartEndObservableTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithStartEndObservableTest.java
index cd9f4d6dc2..14e4c06434 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithStartEndObservableTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithStartEndObservableTest.java
@@ -29,7 +29,7 @@
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.TestScheduler;
-import io.reactivex.subjects.PublishSubject;
+import io.reactivex.subjects.*;
 
 public class ObservableWindowWithStartEndObservableTest {
 
@@ -344,4 +344,50 @@ public void endError() {
         assertFalse("Start has observers!", start.hasObservers());
         assertFalse("End has observers!", end.hasObservers());
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Observable.just(1).window(Observable.just(2), Functions.justFunction(Observable.never())));
+    }
+
+    @Test
+    public void reentrant() {
+        final Subject<Integer> ps = PublishSubject.<Integer>create();
+
+        TestObserver<Integer> to = new TestObserver<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+            }
+        };
+
+        ps.window(BehaviorSubject.createDefault(1), Functions.justFunction(Observable.never()))
+        .flatMap(new Function<Observable<Integer>, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Observable<Integer> v) throws Exception {
+                return v;
+            }
+        })
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to
+        .awaitDone(1, TimeUnit.SECONDS)
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void badSourceCallable() {
+        TestHelper.checkBadSourceObservable(new Function<Observable<Object>, Object>() {
+            @Override
+            public Object apply(Observable<Object> o) throws Exception {
+                return o.window(Observable.just(1), Functions.justFunction(Observable.never()));
+            }
+        }, false, 1, 1, (Object[])null);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
index ce6985d190..1da81e7810 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
@@ -30,7 +30,7 @@
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.*;
-import io.reactivex.subjects.PublishSubject;
+import io.reactivex.subjects.*;
 
 
 public class ObservableWindowWithTimeTest {
@@ -453,4 +453,136 @@ public void restartTimerMany() {
         .assertNoErrors()
         .assertComplete();
     }
+
+    @Test
+    public void exactUnboundedReentrant() {
+        TestScheduler scheduler = new TestScheduler();
+
+        final Subject<Integer> ps = PublishSubject.<Integer>create();
+
+        TestObserver<Integer> to = new TestObserver<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+            }
+        };
+
+        ps.window(1, TimeUnit.MILLISECONDS, scheduler)
+        .flatMap(new Function<Observable<Integer>, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Observable<Integer> v) throws Exception {
+                return v;
+            }
+        })
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to
+        .awaitDone(1, TimeUnit.SECONDS)
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void exactBoundedReentrant() {
+        TestScheduler scheduler = new TestScheduler();
+
+        final Subject<Integer> ps = PublishSubject.<Integer>create();
+
+        TestObserver<Integer> to = new TestObserver<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+            }
+        };
+
+        ps.window(1, TimeUnit.MILLISECONDS, scheduler, 10, true)
+        .flatMap(new Function<Observable<Integer>, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Observable<Integer> v) throws Exception {
+                return v;
+            }
+        })
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to
+        .awaitDone(1, TimeUnit.SECONDS)
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void exactBoundedReentrant2() {
+        TestScheduler scheduler = new TestScheduler();
+
+        final Subject<Integer> ps = PublishSubject.<Integer>create();
+
+        TestObserver<Integer> to = new TestObserver<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+            }
+        };
+
+        ps.window(1, TimeUnit.MILLISECONDS, scheduler, 2, true)
+        .flatMap(new Function<Observable<Integer>, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Observable<Integer> v) throws Exception {
+                return v;
+            }
+        })
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to
+        .awaitDone(1, TimeUnit.SECONDS)
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void skipReentrant() {
+        TestScheduler scheduler = new TestScheduler();
+
+        final Subject<Integer> ps = PublishSubject.<Integer>create();
+
+        TestObserver<Integer> to = new TestObserver<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                if (t == 1) {
+                    ps.onNext(2);
+                    ps.onComplete();
+                }
+            }
+        };
+
+        ps.window(1, 2, TimeUnit.MILLISECONDS, scheduler)
+        .flatMap(new Function<Observable<Integer>, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Observable<Integer> v) throws Exception {
+                return v;
+            }
+        })
+        .subscribe(to);
+
+        ps.onNext(1);
+
+        to
+        .awaitDone(1, TimeUnit.SECONDS)
+        .assertResult(1, 2);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableZipIterableTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableZipIterableTest.java
index 77deb7466f..7c64d8413f 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableZipIterableTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableZipIterableTest.java
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.observable;
 
 import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
 import java.util.*;
@@ -22,11 +23,14 @@
 import org.junit.*;
 import org.mockito.InOrder;
 
+import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
-import io.reactivex.TestHelper;
+import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.internal.util.CrashingIterable;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subjects.PublishSubject;
 
 public class ObservableZipIterableTest {
@@ -359,4 +363,71 @@ public void testTake2() {
 
         assertEquals(2, squareStr.counter.get());
     }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Observable.just(1).zipWith(Arrays.asList(1), new BiFunction<Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeObservable(new Function<Observable<Integer>, ObservableSource<Object>>() {
+            @Override
+            public ObservableSource<Object> apply(Observable<Integer> o) throws Exception {
+                return o.zipWith(Arrays.asList(1), new BiFunction<Integer, Integer, Object>() {
+                    @Override
+                    public Object apply(Integer a, Integer b) throws Exception {
+                        return a + b;
+                    }
+                });
+            }
+        });
+    }
+
+    @Test
+    public void iteratorThrows() {
+        Observable.just(1).zipWith(new CrashingIterable(100, 1, 100), new BiFunction<Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        })
+        .test()
+        .assertFailureAndMessage(TestException.class, "hasNext()");
+    }
+
+    @Test
+    public void badSource() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new Observable<Integer>() {
+                @Override
+                protected void subscribeActual(Observer<? super Integer> observer) {
+                    observer.onSubscribe(Disposables.empty());
+                    observer.onNext(1);
+                    observer.onComplete();
+                    observer.onNext(2);
+                    observer.onError(new TestException());
+                    observer.onComplete();
+                }
+            }
+            .zipWith(Arrays.asList(1), new BiFunction<Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b) throws Exception {
+                    return a + b;
+                }
+            })
+            .test()
+            .assertResult(2);
+
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/tck/BaseTck.java b/src/test/java/io/reactivex/tck/BaseTck.java
index 7f75b719d1..9a0631e835 100644
--- a/src/test/java/io/reactivex/tck/BaseTck.java
+++ b/src/test/java/io/reactivex/tck/BaseTck.java
@@ -32,7 +32,11 @@
 public abstract class BaseTck<T> extends PublisherVerification<T> {
 
     public BaseTck() {
-        super(new TestEnvironment(25L));
+        this(25L);
+    }
+
+    public BaseTck(long timeout) {
+        super(new TestEnvironment(timeout));
     }
 
     @Override
diff --git a/src/test/java/io/reactivex/tck/ObserveOnTckTest.java b/src/test/java/io/reactivex/tck/ObserveOnTckTest.java
index 09687e11f6..7e5f142100 100644
--- a/src/test/java/io/reactivex/tck/ObserveOnTckTest.java
+++ b/src/test/java/io/reactivex/tck/ObserveOnTckTest.java
@@ -22,6 +22,10 @@
 @Test
 public class ObserveOnTckTest extends BaseTck<Integer> {
 
+    public ObserveOnTckTest() {
+        super(100L);
+    }
+
     @Override
     public Publisher<Integer> createPublisher(long elements) {
         return FlowableTck.wrap(
