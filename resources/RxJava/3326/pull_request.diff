diff --git a/src/main/java/io/reactivex/internal/operators/OperatorThrottleFirstTimed.java b/src/main/java/io/reactivex/internal/operators/OperatorThrottleFirstTimed.java
index cd955fc319..35d38bb314 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorThrottleFirstTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorThrottleFirstTimed.java
@@ -45,7 +45,8 @@ public OperatorThrottleFirstTimed(long timeout, TimeUnit unit, Scheduler schedul
                 timeout, unit, scheduler.createWorker());
     }
     
-    static final class DebounceTimedSubscriber<T> extends AtomicInteger 
+    static final class DebounceTimedSubscriber<T>
+    extends AtomicLong
     implements Subscriber<T>, Subscription, Runnable {
         /** */
         private static final long serialVersionUID = -9102637559663639004L;
@@ -59,7 +60,7 @@ public OperatorThrottleFirstTimed(long timeout, TimeUnit unit, Scheduler schedul
         volatile Disposable timer;
         @SuppressWarnings("rawtypes")
         static final AtomicReferenceFieldUpdater<DebounceTimedSubscriber, Disposable> TIMER =
-                AtomicReferenceFieldUpdater.newUpdater(DebounceTimedSubscriber.class, Disposable.class, "debouncer");
+                AtomicReferenceFieldUpdater.newUpdater(DebounceTimedSubscriber.class, Disposable.class, "timer");
 
         static final Disposable CANCELLED = () -> { };
 
@@ -67,21 +68,13 @@ public OperatorThrottleFirstTimed(long timeout, TimeUnit unit, Scheduler schedul
 
         volatile boolean gate;
         
-        volatile long requested;
-        @SuppressWarnings("rawtypes")
-        static final AtomicLongFieldUpdater<DebounceTimedSubscriber> REQUESTED =
-                AtomicLongFieldUpdater.newUpdater(DebounceTimedSubscriber.class, "requested");
-
         boolean done;
         
-        T value;
-        
         public DebounceTimedSubscriber(Subscriber<? super T> actual, long timeout, TimeUnit unit, Worker worker) {
             this.actual = actual;
             this.timeout = timeout;
             this.unit = unit;
             this.worker = worker;
-            lazySet(1);
         }
         
         public void disposeTimer() {
@@ -109,50 +102,42 @@ public void onNext(T t) {
             if (done) {
                 return;
             }
-            
-            if (gate) {
-                value = t;
-                gate = false;
-            }
-            
-            Disposable d = timer;
-            if (d != null) {
-                d.dispose();
-            }
-            
-            if (TIMER.compareAndSet(this, null, NEW_TIMER)) {
-                d = worker.schedule(this, timeout, unit);
-                if (!TIMER.compareAndSet(this, NEW_TIMER, d)) {
-                    d.dispose();
-                    value = null;
-                }
-            }
-        }
-        
-        @Override
-        public void run() {
+
             if (!gate) {
-                T v = value;
-                value = null;
-                
-                long r = requested;
+                gate = true;
+                long r = get();
                 if (r != 0L) {
-                    actual.onNext(v);
+                    actual.onNext(t);
                     if (r != Long.MAX_VALUE) {
-                        REQUESTED.decrementAndGet(this);
-                    }
-                    if (decrementAndGet() == 0) {
-                        disposeTimer();
-                        worker.dispose();
-                        actual.onComplete();
-                        return;
+                        decrementAndGet();
                     }
-                    gate = true;
                 } else {
+                    done = true;
                     cancel();
                     actual.onError(new IllegalStateException("Could not deliver value due to lack of requests"));
+                    return;
+                }
+                
+                // FIXME should this be a periodic blocking or a value-relative blocking?
+                Disposable d = timer;
+                if (d != null) {
+                    d.dispose();
+                }
+                
+                if (TIMER.compareAndSet(this, d, NEW_TIMER)) {
+                    d = worker.schedule(this, timeout, unit);
+                    if (!TIMER.compareAndSet(this, NEW_TIMER, d)) {
+                        d.dispose();
+                    }
                 }
             }
+            
+            
+        }
+        
+        @Override
+        public void run() {
+            gate = false;
         }
         
         @Override
@@ -172,11 +157,9 @@ public void onComplete() {
                 return;
             }
             done = true;
-            if (decrementAndGet() == 0) {
-                disposeTimer();
-                worker.dispose();
-                actual.onComplete();
-            }
+            disposeTimer();
+            worker.dispose();
+            actual.onComplete();
         }
         
         @Override
@@ -184,7 +167,7 @@ public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
-            BackpressureHelper.add(REQUESTED, this, n);
+            BackpressureHelper.add(this, n);
         }
         
         @Override
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorTimeout.java b/src/main/java/io/reactivex/internal/operators/OperatorTimeout.java
index ad785bcab5..419942c525 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorTimeout.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorTimeout.java
@@ -89,25 +89,29 @@ public void onSubscribe(Subscription s) {
             
             Publisher<U> p;
             
-            try {
-                p = firstTimeoutSelector.get();
-            } catch (Exception ex) {
-                cancel();
-                EmptySubscription.error(ex, a);
-                return;
-            }
-            
-            if (p == null) {
-                cancel();
-                EmptySubscription.error(new NullPointerException("The first timeout publisher is null"), a);
-                return;
-            }
-            
-            TimeoutInnerSubscriber<T, U, V> tis = new TimeoutInnerSubscriber<>(this, 0);
-            
-            if (TIMEOUT.compareAndSet(this, null, tis)) {
+            if (firstTimeoutSelector != null) {
+                try {
+                    p = firstTimeoutSelector.get();
+                } catch (Exception ex) {
+                    cancel();
+                    EmptySubscription.error(ex, a);
+                    return;
+                }
+                
+                if (p == null) {
+                    cancel();
+                    EmptySubscription.error(new NullPointerException("The first timeout publisher is null"), a);
+                    return;
+                }
+                
+                TimeoutInnerSubscriber<T, U, V> tis = new TimeoutInnerSubscriber<>(this, 0);
+                
+                if (TIMEOUT.compareAndSet(this, null, tis)) {
+                    a.onSubscribe(s);
+                    p.subscribe(tis);
+                }
+            } else {
                 a.onSubscribe(s);
-                p.subscribe(tis);
             }
         }
         
@@ -272,27 +276,31 @@ public void onSubscribe(Subscription s) {
             }
             Subscriber<? super T> a = actual;
             
-            Publisher<U> p;
-            
-            try {
-                p = firstTimeoutSelector.get();
-            } catch (Exception ex) {
-                dispose();
-                EmptySubscription.error(ex, a);
-                return;
-            }
-            
-            if (p == null) {
-                dispose();
-                EmptySubscription.error(new NullPointerException("The first timeout publisher is null"), a);
-                return;
-            }
-            
-            TimeoutInnerSubscriber<T, U, V> tis = new TimeoutInnerSubscriber<>(this, 0);
-            
-            if (TIMEOUT.compareAndSet(this, null, tis)) {
+            if (firstTimeoutSelector != null) {
+                Publisher<U> p;
+                
+                try {
+                    p = firstTimeoutSelector.get();
+                } catch (Exception ex) {
+                    dispose();
+                    EmptySubscription.error(ex, a);
+                    return;
+                }
+                
+                if (p == null) {
+                    dispose();
+                    EmptySubscription.error(new NullPointerException("The first timeout publisher is null"), a);
+                    return;
+                }
+                
+                TimeoutInnerSubscriber<T, U, V> tis = new TimeoutInnerSubscriber<>(this, 0);
+                
+                if (TIMEOUT.compareAndSet(this, null, tis)) {
+                    a.onSubscribe(arbiter);
+                    p.subscribe(tis);
+                }
+            } else {
                 a.onSubscribe(arbiter);
-                p.subscribe(tis);
             }
         }
         
diff --git a/src/main/java/io/reactivex/internal/subscriptions/FullArbiter.java b/src/main/java/io/reactivex/internal/subscriptions/FullArbiter.java
index be1f688123..bd887469c7 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/FullArbiter.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/FullArbiter.java
@@ -33,7 +33,20 @@
     final SpscLinkedArrayQueue<Object> queue;
 
     long requested;
-    Subscription s;
+    
+    volatile Subscription s;
+    static final Subscription INITIAL = new Subscription() {
+        @Override
+        public void request(long n) {
+            
+        }
+        @Override
+        public void cancel() {
+            // TODO Auto-generated method stub
+            
+        }
+    };
+    
     
     Disposable resource;
 
@@ -45,6 +58,7 @@ public FullArbiter(Subscriber<? super T> actual, Disposable resource, int capaci
         this.actual = actual;
         this.resource = resource;
         this.queue = new SpscLinkedArrayQueue<>(capacity);
+        this.s = INITIAL;
     }
 
     @Override
@@ -78,7 +92,7 @@ public boolean setSubscription(Subscription s) {
             return false;
         }
 
-        queue.offer(s, NotificationLite.subscription(s));
+        queue.offer(this.s, NotificationLite.subscription(s));
         drain();
         return true;
     }
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorThrottleFirstTest.java b/src/test/java/io/reactivex/internal/operators/OperatorThrottleFirstTest.java
new file mode 100644
index 0000000000..62286d0321
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorThrottleFirstTest.java
@@ -0,0 +1,153 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
+
+import java.util.concurrent.TimeUnit;
+
+import org.junit.*;
+import org.mockito.InOrder;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.subjects.PublishSubject;
+
+public class OperatorThrottleFirstTest {
+
+    private TestScheduler scheduler;
+    private Scheduler.Worker innerScheduler;
+    private Subscriber<String> observer;
+
+    @Before
+    public void before() {
+        scheduler = new TestScheduler();
+        innerScheduler = scheduler.createWorker();
+        observer = TestHelper.mockSubscriber();
+    }
+
+    @Test
+    public void testThrottlingWithCompleted() {
+        Observable<String> source = Observable.create(new Publisher<String>() {
+            @Override
+            public void subscribe(Subscriber<? super String> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                publishNext(observer, 100, "one");    // publish as it's first
+                publishNext(observer, 300, "two");    // skip as it's last within the first 400
+                publishNext(observer, 900, "three");   // publish
+                publishNext(observer, 905, "four");   // skip
+                publishCompleted(observer, 1000);     // Should be published as soon as the timeout expires.
+            }
+        });
+
+        Observable<String> sampled = source.throttleFirst(400, TimeUnit.MILLISECONDS, scheduler);
+        sampled.subscribe(observer);
+
+        InOrder inOrder = inOrder(observer);
+
+        scheduler.advanceTimeTo(1000, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer, times(1)).onNext("one");
+        inOrder.verify(observer, times(0)).onNext("two");
+        inOrder.verify(observer, times(1)).onNext("three");
+        inOrder.verify(observer, times(0)).onNext("four");
+        inOrder.verify(observer, times(1)).onComplete();
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testThrottlingWithError() {
+        Observable<String> source = Observable.create(new Publisher<String>() {
+            @Override
+            public void subscribe(Subscriber<? super String> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                Exception error = new TestException();
+                publishNext(observer, 100, "one");    // Should be published since it is first
+                publishNext(observer, 200, "two");    // Should be skipped since onError will arrive before the timeout expires
+                publishError(observer, 300, error);   // Should be published as soon as the timeout expires.
+            }
+        });
+
+        Observable<String> sampled = source.throttleFirst(400, TimeUnit.MILLISECONDS, scheduler);
+        sampled.subscribe(observer);
+
+        InOrder inOrder = inOrder(observer);
+
+        scheduler.advanceTimeTo(400, TimeUnit.MILLISECONDS);
+        inOrder.verify(observer).onNext("one");
+        inOrder.verify(observer).onError(any(TestException.class));
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    private <T> void publishCompleted(final Subscriber<T> observer, long delay) {
+        innerScheduler.schedule(new Runnable() {
+            @Override
+            public void run() {
+                observer.onComplete();
+            }
+        }, delay, TimeUnit.MILLISECONDS);
+    }
+
+    private <T> void publishError(final Subscriber<T> observer, long delay, final Exception error) {
+        innerScheduler.schedule(new Runnable() {
+            @Override
+            public void run() {
+                observer.onError(error);
+            }
+        }, delay, TimeUnit.MILLISECONDS);
+    }
+
+    private <T> void publishNext(final Subscriber<T> observer, long delay, final T value) {
+        innerScheduler.schedule(new Runnable() {
+            @Override
+            public void run() {
+                observer.onNext(value);
+            }
+        }, delay, TimeUnit.MILLISECONDS);
+    }
+
+    @Test
+    public void testThrottle() {
+        Subscriber<Integer> observer = TestHelper.mockSubscriber();
+        TestScheduler s = new TestScheduler();
+        PublishSubject<Integer> o = PublishSubject.create();
+        o.throttleFirst(500, TimeUnit.MILLISECONDS, s).subscribe(observer);
+
+        // send events with simulated time increments
+        s.advanceTimeTo(0, TimeUnit.MILLISECONDS);
+        o.onNext(1); // deliver
+        o.onNext(2); // skip
+        s.advanceTimeTo(501, TimeUnit.MILLISECONDS);
+        o.onNext(3); // deliver
+        s.advanceTimeTo(600, TimeUnit.MILLISECONDS);
+        o.onNext(4); // skip
+        s.advanceTimeTo(700, TimeUnit.MILLISECONDS);
+        o.onNext(5); // skip
+        o.onNext(6); // skip
+        s.advanceTimeTo(1001, TimeUnit.MILLISECONDS);
+        o.onNext(7); // deliver
+        s.advanceTimeTo(1501, TimeUnit.MILLISECONDS);
+        o.onComplete();
+
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer).onNext(1);
+        inOrder.verify(observer).onNext(3);
+        inOrder.verify(observer).onNext(7);
+        inOrder.verify(observer).onComplete();
+        inOrder.verifyNoMoreInteractions();
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorTimeIntervalTest.java b/src/test/java/io/reactivex/internal/operators/OperatorTimeIntervalTest.java
new file mode 100644
index 0000000000..7d4884b42b
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorTimeIntervalTest.java
@@ -0,0 +1,68 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.mockito.Mockito.*;
+
+import java.util.concurrent.TimeUnit;
+
+import org.junit.*;
+import org.mockito.InOrder;
+import org.reactivestreams.Subscriber;
+
+import io.reactivex.*;
+import io.reactivex.schedulers.*;
+import io.reactivex.subjects.PublishSubject;
+
+public class OperatorTimeIntervalTest {
+
+    private static final TimeUnit TIME_UNIT = TimeUnit.MILLISECONDS;
+
+    private Subscriber<Timed<Integer>> observer;
+
+    private TestScheduler testScheduler;
+    private PublishSubject<Integer> subject;
+    private Observable<Timed<Integer>> observable;
+
+    @Before
+    public void setUp() {
+        observer = TestHelper.mockSubscriber();
+        testScheduler = new TestScheduler();
+        subject = PublishSubject.create();
+        observable = subject.timeInterval(testScheduler);
+    }
+
+    @Test
+    public void testTimeInterval() {
+        InOrder inOrder = inOrder(observer);
+        observable.subscribe(observer);
+
+        testScheduler.advanceTimeBy(1000, TIME_UNIT);
+        subject.onNext(1);
+        testScheduler.advanceTimeBy(2000, TIME_UNIT);
+        subject.onNext(2);
+        testScheduler.advanceTimeBy(3000, TIME_UNIT);
+        subject.onNext(3);
+        subject.onComplete();
+
+        inOrder.verify(observer, times(1)).onNext(
+                new Timed<>(1, 1000, TIME_UNIT));
+        inOrder.verify(observer, times(1)).onNext(
+                new Timed<>(2, 2000, TIME_UNIT));
+        inOrder.verify(observer, times(1)).onNext(
+                new Timed<>(3, 3000, TIME_UNIT));
+        inOrder.verify(observer, times(1)).onComplete();
+        inOrder.verifyNoMoreInteractions();
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorTimeoutTests.java b/src/test/java/io/reactivex/internal/operators/OperatorTimeoutTests.java
new file mode 100644
index 0000000000..a58396462e
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorTimeoutTests.java
@@ -0,0 +1,360 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.mockito.Matchers.*;
+import static org.mockito.Mockito.*;
+
+import java.io.IOException;
+import java.util.concurrent.*;
+
+import org.junit.*;
+import org.mockito.InOrder;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.subjects.PublishSubject;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class OperatorTimeoutTests {
+    private PublishSubject<String> underlyingSubject;
+    private TestScheduler testScheduler;
+    private Observable<String> withTimeout;
+    private static final long TIMEOUT = 3;
+    private static final TimeUnit TIME_UNIT = TimeUnit.SECONDS;
+
+    @Before
+    public void setUp() {
+
+        underlyingSubject = PublishSubject.create();
+        testScheduler = new TestScheduler();
+        withTimeout = underlyingSubject.timeout(TIMEOUT, TIME_UNIT, testScheduler);
+    }
+
+    @Test
+    public void shouldNotTimeoutIfOnNextWithinTimeout() {
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        
+        withTimeout.subscribe(ts);
+        
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        underlyingSubject.onNext("One");
+        verify(observer).onNext("One");
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        verify(observer, never()).onError(any(Throwable.class));
+        ts.cancel();
+    }
+
+    @Test
+    public void shouldNotTimeoutIfSecondOnNextWithinTimeout() {
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        
+        withTimeout.subscribe(ts);
+        
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        underlyingSubject.onNext("One");
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        underlyingSubject.onNext("Two");
+        verify(observer).onNext("Two");
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        verify(observer, never()).onError(any(Throwable.class));
+        ts.dispose();
+    }
+
+    @Test
+    public void shouldTimeoutIfOnNextNotWithinTimeout() {
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        
+        withTimeout.subscribe(ts);
+        
+        testScheduler.advanceTimeBy(TIMEOUT + 1, TimeUnit.SECONDS);
+        verify(observer).onError(any(TimeoutException.class));
+        ts.dispose();
+    }
+
+    @Test
+    public void shouldTimeoutIfSecondOnNextNotWithinTimeout() {
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        withTimeout.subscribe(observer);
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        underlyingSubject.onNext("One");
+        verify(observer).onNext("One");
+        testScheduler.advanceTimeBy(TIMEOUT + 1, TimeUnit.SECONDS);
+        verify(observer).onError(any(TimeoutException.class));
+        ts.dispose();
+    }
+
+    @Test
+    public void shouldCompleteIfUnderlyingComletes() {
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        withTimeout.subscribe(observer);
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        underlyingSubject.onComplete();
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        verify(observer).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+        ts.dispose();
+    }
+
+    @Test
+    public void shouldErrorIfUnderlyingErrors() {
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        withTimeout.subscribe(observer);
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        underlyingSubject.onError(new UnsupportedOperationException());
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        verify(observer).onError(any(UnsupportedOperationException.class));
+        ts.dispose();
+    }
+
+    @Test
+    public void shouldSwitchToOtherIfOnNextNotWithinTimeout() {
+        Observable<String> other = Observable.just("a", "b", "c");
+        Observable<String> source = underlyingSubject.timeout(TIMEOUT, TIME_UNIT, other, testScheduler);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        source.subscribe(ts);
+
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        underlyingSubject.onNext("One");
+        testScheduler.advanceTimeBy(4, TimeUnit.SECONDS);
+        underlyingSubject.onNext("Two");
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, times(1)).onNext("One");
+        inOrder.verify(observer, times(1)).onNext("a");
+        inOrder.verify(observer, times(1)).onNext("b");
+        inOrder.verify(observer, times(1)).onNext("c");
+        inOrder.verify(observer, times(1)).onComplete();
+        inOrder.verifyNoMoreInteractions();
+        ts.dispose();
+    }
+
+    @Test
+    public void shouldSwitchToOtherIfOnErrorNotWithinTimeout() {
+        Observable<String> other = Observable.just("a", "b", "c");
+        Observable<String> source = underlyingSubject.timeout(TIMEOUT, TIME_UNIT, other, testScheduler);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        source.subscribe(ts);
+
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        underlyingSubject.onNext("One");
+        testScheduler.advanceTimeBy(4, TimeUnit.SECONDS);
+        underlyingSubject.onError(new UnsupportedOperationException());
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, times(1)).onNext("One");
+        inOrder.verify(observer, times(1)).onNext("a");
+        inOrder.verify(observer, times(1)).onNext("b");
+        inOrder.verify(observer, times(1)).onNext("c");
+        inOrder.verify(observer, times(1)).onComplete();
+        inOrder.verifyNoMoreInteractions();
+        ts.dispose();
+    }
+
+    @Test
+    public void shouldSwitchToOtherIfOnCompletedNotWithinTimeout() {
+        Observable<String> other = Observable.just("a", "b", "c");
+        Observable<String> source = underlyingSubject.timeout(TIMEOUT, TIME_UNIT, other, testScheduler);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        source.subscribe(ts);
+
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        underlyingSubject.onNext("One");
+        testScheduler.advanceTimeBy(4, TimeUnit.SECONDS);
+        underlyingSubject.onComplete();
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, times(1)).onNext("One");
+        inOrder.verify(observer, times(1)).onNext("a");
+        inOrder.verify(observer, times(1)).onNext("b");
+        inOrder.verify(observer, times(1)).onNext("c");
+        inOrder.verify(observer, times(1)).onComplete();
+        inOrder.verifyNoMoreInteractions();
+        ts.dispose();
+    }
+
+    @Test
+    public void shouldSwitchToOtherAndCanBeUnsubscribedIfOnNextNotWithinTimeout() {
+        PublishSubject<String> other = PublishSubject.create();
+        Observable<String> source = underlyingSubject.timeout(TIMEOUT, TIME_UNIT, other, testScheduler);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        source.subscribe(ts);
+
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+        underlyingSubject.onNext("One");
+        testScheduler.advanceTimeBy(4, TimeUnit.SECONDS);
+        underlyingSubject.onNext("Two");
+
+        other.onNext("a");
+        other.onNext("b");
+        ts.dispose();
+
+        // The following messages should not be delivered.
+        other.onNext("c");
+        other.onNext("d");
+        other.onComplete();
+
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, times(1)).onNext("One");
+        inOrder.verify(observer, times(1)).onNext("a");
+        inOrder.verify(observer, times(1)).onNext("b");
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void shouldTimeoutIfSynchronizedObservableEmitFirstOnNextNotWithinTimeout()
+            throws InterruptedException {
+        final CountDownLatch exit = new CountDownLatch(1);
+        final CountDownLatch timeoutSetuped = new CountDownLatch(1);
+
+        final Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+
+        new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                Observable.create(new Publisher<String>() {
+
+                    @Override
+                    public void subscribe(Subscriber<? super String> subscriber) {
+                        subscriber.onSubscribe(EmptySubscription.INSTANCE);
+                        try {
+                            timeoutSetuped.countDown();
+                            exit.await();
+                        } catch (InterruptedException e) {
+                            e.printStackTrace();
+                        }
+                        subscriber.onNext("a");
+                        subscriber.onComplete();
+                    }
+
+                }).timeout(1, TimeUnit.SECONDS, testScheduler)
+                        .subscribe(ts);
+            }
+        }).start();
+
+        timeoutSetuped.await();
+        testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, times(1)).onError(isA(TimeoutException.class));
+        inOrder.verifyNoMoreInteractions();
+
+        exit.countDown(); // exit the thread
+    }
+
+    @Test
+    public void shouldUnsubscribeFromUnderlyingSubscriptionOnTimeout() throws InterruptedException {
+        // From https://github.com/ReactiveX/RxJava/pull/951
+        final Subscription s = mock(Subscription.class);
+
+        Observable<String> never = Observable.create(new Publisher<String>() {
+            @Override
+            public void subscribe(Subscriber<? super String> subscriber) {
+                subscriber.onSubscribe(s);
+            }
+        });
+
+        TestScheduler testScheduler = new TestScheduler();
+        Observable<String> observableWithTimeout = never.timeout(1000, TimeUnit.MILLISECONDS, testScheduler);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        observableWithTimeout.subscribe(ts);
+
+        testScheduler.advanceTimeBy(2000, TimeUnit.MILLISECONDS);
+
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer).onError(isA(TimeoutException.class));
+        inOrder.verifyNoMoreInteractions();
+
+        verify(s, times(1)).cancel();
+    }
+
+    @Test
+    @Ignore("s should be considered cancelled upon executing onComplete and not expect downstream to call cancel")
+    public void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyComplete() {
+        // From https://github.com/ReactiveX/RxJava/pull/951
+        final Subscription s = mock(Subscription.class);
+
+        Observable<String> immediatelyComplete = Observable.create(new Publisher<String>() {
+            @Override
+            public void subscribe(Subscriber<? super String> subscriber) {
+                subscriber.onSubscribe(s);
+                subscriber.onComplete();
+            }
+        });
+
+        TestScheduler testScheduler = new TestScheduler();
+        Observable<String> observableWithTimeout = immediatelyComplete.timeout(1000, TimeUnit.MILLISECONDS,
+                testScheduler);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        observableWithTimeout.subscribe(ts);
+
+        testScheduler.advanceTimeBy(2000, TimeUnit.MILLISECONDS);
+
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer).onComplete();
+        inOrder.verifyNoMoreInteractions();
+
+        verify(s, times(1)).cancel();
+    }
+
+    @Test
+    @Ignore("s should be considered cancelled upon executing onError and not expect downstream to call cancel")
+    public void shouldUnsubscribeFromUnderlyingSubscriptionOnImmediatelyErrored() throws InterruptedException {
+        // From https://github.com/ReactiveX/RxJava/pull/951
+        final Subscription s = mock(Subscription.class);
+
+        Observable<String> immediatelyError = Observable.create(new Publisher<String>() {
+            @Override
+            public void subscribe(Subscriber<? super String> subscriber) {
+                subscriber.onSubscribe(s);
+                subscriber.onError(new IOException("Error"));
+            }
+        });
+
+        TestScheduler testScheduler = new TestScheduler();
+        Observable<String> observableWithTimeout = immediatelyError.timeout(1000, TimeUnit.MILLISECONDS,
+                testScheduler);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        observableWithTimeout.subscribe(ts);
+
+        testScheduler.advanceTimeBy(2000, TimeUnit.MILLISECONDS);
+
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer).onError(isA(IOException.class));
+        inOrder.verifyNoMoreInteractions();
+
+        verify(s, times(1)).cancel();
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorTimeoutWithSelectorTest.java b/src/test/java/io/reactivex/internal/operators/OperatorTimeoutWithSelectorTest.java
new file mode 100644
index 0000000000..69586d5fdd
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorTimeoutWithSelectorTest.java
@@ -0,0 +1,417 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.junit.Assert.assertFalse;
+import static org.mockito.Matchers.*;
+import static org.mockito.Mockito.*;
+
+import java.util.Arrays;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.*;
+
+import org.junit.Test;
+import org.mockito.InOrder;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subjects.PublishSubject;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class OperatorTimeoutWithSelectorTest {
+    @Test(timeout = 2000)
+    public void testTimeoutSelectorNormal1() {
+        PublishSubject<Integer> source = PublishSubject.create();
+        final PublishSubject<Integer> timeout = PublishSubject.create();
+
+        Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {
+            @Override
+            public Observable<Integer> apply(Integer t1) {
+                return timeout;
+            }
+        };
+
+        Supplier<Observable<Integer>> firstTimeoutFunc = new Supplier<Observable<Integer>>() {
+            @Override
+            public Observable<Integer> get() {
+                return timeout;
+            }
+        };
+
+        Observable<Integer> other = Observable.fromIterable(Arrays.asList(100));
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        InOrder inOrder = inOrder(o);
+
+        source.timeout(firstTimeoutFunc, timeoutFunc, other).subscribe(o);
+
+        source.onNext(1);
+        source.onNext(2);
+        source.onNext(3);
+        timeout.onNext(1);
+
+        inOrder.verify(o).onNext(1);
+        inOrder.verify(o).onNext(2);
+        inOrder.verify(o).onNext(3);
+        inOrder.verify(o).onNext(100);
+        inOrder.verify(o).onComplete();
+        verify(o, never()).onError(any(Throwable.class));
+
+    }
+
+    @Test
+    public void testTimeoutSelectorTimeoutFirst() throws InterruptedException {
+        Observable<Integer> source = Observable.<Integer>never();
+        final PublishSubject<Integer> timeout = PublishSubject.create();
+
+        Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {
+            @Override
+            public Observable<Integer> apply(Integer t1) {
+                return timeout;
+            }
+        };
+
+        Supplier<Observable<Integer>> firstTimeoutFunc = new Supplier<Observable<Integer>>() {
+            @Override
+            public Observable<Integer> get() {
+                return timeout;
+            }
+        };
+
+        Observable<Integer> other = Observable.fromIterable(Arrays.asList(100));
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        InOrder inOrder = inOrder(o);
+
+        source.timeout(firstTimeoutFunc, timeoutFunc, other).subscribe(o);
+        
+        timeout.onNext(1);
+        
+        inOrder.verify(o).onNext(100);
+        inOrder.verify(o).onComplete();
+        verify(o, never()).onError(any(Throwable.class));
+
+    }
+
+    @Test
+    public void testTimeoutSelectorFirstThrows() {
+        Observable<Integer> source = Observable.<Integer>never();
+        final PublishSubject<Integer> timeout = PublishSubject.create();
+
+        Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {
+            @Override
+            public Observable<Integer> apply(Integer t1) {
+                return timeout;
+            }
+        };
+
+        Supplier<Observable<Integer>> firstTimeoutFunc = new Supplier<Observable<Integer>>() {
+            @Override
+            public Observable<Integer> get() {
+                throw new TestException();
+            }
+        };
+
+        Observable<Integer> other = Observable.fromIterable(Arrays.asList(100));
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+
+        source.timeout(firstTimeoutFunc, timeoutFunc, other).subscribe(o);
+
+        verify(o).onError(any(TestException.class));
+        verify(o, never()).onNext(any());
+        verify(o, never()).onComplete();
+
+    }
+
+    @Test
+    public void testTimeoutSelectorSubsequentThrows() {
+        PublishSubject<Integer> source = PublishSubject.create();
+        final PublishSubject<Integer> timeout = PublishSubject.create();
+
+        Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {
+            @Override
+            public Observable<Integer> apply(Integer t1) {
+                throw new TestException();
+            }
+        };
+
+        Supplier<Observable<Integer>> firstTimeoutFunc = new Supplier<Observable<Integer>>() {
+            @Override
+            public Observable<Integer> get() {
+                return timeout;
+            }
+        };
+
+        Observable<Integer> other = Observable.fromIterable(Arrays.asList(100));
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        InOrder inOrder = inOrder(o);
+
+        source.timeout(firstTimeoutFunc, timeoutFunc, other).subscribe(o);
+
+        source.onNext(1);
+
+        inOrder.verify(o).onNext(1);
+        inOrder.verify(o).onError(any(TestException.class));
+        verify(o, never()).onComplete();
+
+    }
+
+    @Test
+    public void testTimeoutSelectorFirstObservableThrows() {
+        PublishSubject<Integer> source = PublishSubject.create();
+        final PublishSubject<Integer> timeout = PublishSubject.create();
+
+        Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {
+            @Override
+            public Observable<Integer> apply(Integer t1) {
+                return timeout;
+            }
+        };
+
+        Supplier<Observable<Integer>> firstTimeoutFunc = new Supplier<Observable<Integer>>() {
+            @Override
+            public Observable<Integer> get() {
+                return Observable.<Integer> error(new TestException());
+            }
+        };
+
+        Observable<Integer> other = Observable.fromIterable(Arrays.asList(100));
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+
+        source.timeout(firstTimeoutFunc, timeoutFunc, other).subscribe(o);
+
+        verify(o).onError(any(TestException.class));
+        verify(o, never()).onNext(any());
+        verify(o, never()).onComplete();
+
+    }
+
+    @Test
+    public void testTimeoutSelectorSubsequentObservableThrows() {
+        PublishSubject<Integer> source = PublishSubject.create();
+        final PublishSubject<Integer> timeout = PublishSubject.create();
+
+        Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {
+            @Override
+            public Observable<Integer> apply(Integer t1) {
+                return Observable.<Integer> error(new TestException());
+            }
+        };
+
+        Supplier<Observable<Integer>> firstTimeoutFunc = new Supplier<Observable<Integer>>() {
+            @Override
+            public Observable<Integer> get() {
+                return timeout;
+            }
+        };
+
+        Observable<Integer> other = Observable.fromIterable(Arrays.asList(100));
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        InOrder inOrder = inOrder(o);
+
+        source.timeout(firstTimeoutFunc, timeoutFunc, other).subscribe(o);
+
+        source.onNext(1);
+
+        inOrder.verify(o).onNext(1);
+        inOrder.verify(o).onError(any(TestException.class));
+        verify(o, never()).onComplete();
+
+    }
+
+    @Test
+    public void testTimeoutSelectorWithFirstTimeoutFirstAndNoOtherObservable() {
+        PublishSubject<Integer> source = PublishSubject.create();
+        final PublishSubject<Integer> timeout = PublishSubject.create();
+
+        Supplier<Observable<Integer>> firstTimeoutFunc = new Supplier<Observable<Integer>>() {
+            @Override
+            public Observable<Integer> get() {
+                return timeout;
+            }
+        };
+
+        Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {
+            @Override
+            public Observable<Integer> apply(Integer t1) {
+                return PublishSubject.create();
+            }
+        };
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        source.timeout(firstTimeoutFunc, timeoutFunc).subscribe(o);
+
+        timeout.onNext(1);
+
+        InOrder inOrder = inOrder(o);
+        inOrder.verify(o).onError(isA(TimeoutException.class));
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testTimeoutSelectorWithTimeoutFirstAndNoOtherObservable() {
+        PublishSubject<Integer> source = PublishSubject.create();
+        final PublishSubject<Integer> timeout = PublishSubject.create();
+
+        Supplier<Observable<Integer>> firstTimeoutFunc = new Supplier<Observable<Integer>>() {
+            @Override
+            public Observable<Integer> get() {
+                return PublishSubject.create();
+            }
+        };
+
+        Function<Integer, Observable<Integer>> timeoutFunc = new Function<Integer, Observable<Integer>>() {
+            @Override
+            public Observable<Integer> apply(Integer t1) {
+                return timeout;
+            }
+        };
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        source.timeout(firstTimeoutFunc, timeoutFunc).subscribe(o);
+        source.onNext(1);
+
+        timeout.onNext(1);
+
+        InOrder inOrder = inOrder(o);
+        inOrder.verify(o).onNext(1);
+        inOrder.verify(o).onError(isA(TimeoutException.class));
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testTimeoutSelectorWithTimeoutAndOnNextRaceCondition() throws InterruptedException {
+        // Thread 1                                    Thread 2
+        //
+        // observer.onNext(1)
+        // start timeout
+        // unsubscribe timeout in thread 2          start to do some long-time work in "unsubscribe"
+        // observer.onNext(2)
+        // timeout.onNext(1)
+        //                                          "unsubscribe" done
+        //
+        //
+        // In the above case, the timeout operator should ignore "timeout.onNext(1)"
+        // since "observer" has already seen 2.
+        final CountDownLatch observerReceivedTwo = new CountDownLatch(1);
+        final CountDownLatch timeoutEmittedOne = new CountDownLatch(1);
+        final CountDownLatch observerCompleted = new CountDownLatch(1);
+        final CountDownLatch enteredTimeoutOne = new CountDownLatch(1);
+        final AtomicBoolean latchTimeout = new AtomicBoolean(false);
+
+        final Function<Integer, Observable<Integer>> timeoutFunc = t1 -> {
+            if (t1 == 1) {
+                // Force "unsubscribe" run on another thread
+                return Observable.create(new Publisher<Integer>() {
+                    @Override
+                    public void subscribe(Subscriber<? super Integer> subscriber) {
+                        subscriber.onSubscribe(EmptySubscription.INSTANCE);
+                        enteredTimeoutOne.countDown();
+                        // force the timeout message be sent after observer.onNext(2)
+                        while (true) {
+                            try {
+                                if (!observerReceivedTwo.await(30, TimeUnit.SECONDS)) {
+                                    // CountDownLatch timeout
+                                    // There should be something wrong
+                                    latchTimeout.set(true);
+                                }
+                                break;
+                            } catch (InterruptedException e) {
+                                // Since we just want to emulate a busy method,
+                                // we ignore the interrupt signal from Scheduler.
+                            }
+                        }
+                        subscriber.onNext(1);
+                        timeoutEmittedOne.countDown();
+                    }
+                }).subscribeOn(Schedulers.newThread());
+            } else {
+                return PublishSubject.create();
+            }
+        };
+
+        final Subscriber<Integer> o = TestHelper.mockSubscriber();
+        doAnswer(new Answer<Void>() {
+
+            @Override
+            public Void answer(InvocationOnMock invocation) throws Throwable {
+                observerReceivedTwo.countDown();
+                return null;
+            }
+
+        }).when(o).onNext(2);
+        doAnswer(new Answer<Void>() {
+
+            @Override
+            public Void answer(InvocationOnMock invocation) throws Throwable {
+                observerCompleted.countDown();
+                return null;
+            }
+
+        }).when(o).onComplete();
+
+        final TestSubscriber<Integer> ts = new TestSubscriber<>(o);
+
+        new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                PublishSubject<Integer> source = PublishSubject.create();
+                source.timeout(timeoutFunc, Observable.just(3)).subscribe(ts);
+                source.onNext(1); // start timeout
+                try {
+                    if(!enteredTimeoutOne.await(30, TimeUnit.SECONDS)) {
+                        latchTimeout.set(true);
+                    }
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                source.onNext(2); // disable timeout
+                try {
+                    if(!timeoutEmittedOne.await(30, TimeUnit.SECONDS)) {
+                        latchTimeout.set(true);
+                    }
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                source.onComplete();
+            }
+
+        }).start();
+
+        if(!observerCompleted.await(30, TimeUnit.SECONDS)) {
+            latchTimeout.set(true);
+        }
+
+        assertFalse("CoundDownLatch timeout", latchTimeout.get());
+
+        InOrder inOrder = inOrder(o);
+        inOrder.verify(o).onSubscribe((Subscription)notNull());
+        inOrder.verify(o).onNext(1);
+        inOrder.verify(o).onNext(2);
+        inOrder.verify(o, never()).onNext(3);
+        inOrder.verify(o).onComplete();
+        inOrder.verifyNoMoreInteractions();
+    }
+}
\ No newline at end of file
