diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java
index a35dad54d7..be5507ba65 100644
--- a/src/main/java/io/reactivex/Completable.java
+++ b/src/main/java/io/reactivex/Completable.java
@@ -1331,15 +1331,15 @@ public final Completable startWith(CompletableSource other) {
     }
 
     /**
-     * Returns an NbpObservable which first delivers the events
-     * of the other NbpObservable then runs this CompletableConsumable.
+     * Returns an Observable which first delivers the events
+     * of the other Observable then runs this CompletableConsumable.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * @param <T> the value type
-     * @param other the other NbpObservable to run first
-     * @return the new NbpObservable instance
+     * @param other the other Observable to run first
+     * @return the new Observable instance
      * @throws NullPointerException if other is null
      */
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -1641,14 +1641,14 @@ private Completable timeout0(long timeout, TimeUnit unit, Scheduler scheduler, C
     }
 
     /**
-     * Returns an NbpObservable which when subscribed to subscribes to this Completable and
+     * Returns an Observable which when subscribed to subscribes to this Completable and
      * relays the terminal events to the subscriber.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code toObservable} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * @param <T> the value type
-     * @return the new NbpObservable created
+     * @return the new Observable created
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <T> Observable<T> toObservable() {
diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java
index 17b462f3b6..2d7dc54c53 100644
--- a/src/main/java/io/reactivex/Flowable.java
+++ b/src/main/java/io/reactivex/Flowable.java
@@ -17,6 +17,7 @@
 
 import org.reactivestreams.*;
 
+import io.reactivex.Observable;
 import io.reactivex.annotations.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
@@ -164,7 +165,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
-    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<Object[], ? extends R> combiner) {
+    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super T[], ? extends R> combiner) {
         return combineLatest(sources, combiner, bufferSize());
     }
 
@@ -195,7 +196,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
-    public static <T, R> Flowable<R> combineLatest(Function<Object[], ? extends R> combiner, Publisher<? extends T>... sources) {
+    public static <T, R> Flowable<R> combineLatest(Function<? super T[], ? extends R> combiner, Publisher<? extends T>... sources) {
         return combineLatest(sources, combiner, bufferSize());
     }
 
@@ -228,13 +229,13 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
-    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<Object[], ? extends R> combiner, int bufferSize) {
+    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super T[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
-        ObjectHelper.requireNonNull(combiner, "combiner is null");
-        ObjectHelper.verifyPositive(bufferSize, "bufferSize");
         if (sources.length == 0) {
             return empty();
         }
+        ObjectHelper.requireNonNull(combiner, "combiner is null");
+        ObjectHelper.verifyPositive(bufferSize, "bufferSize");
         return RxJavaPlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false));
     }
 
@@ -266,7 +267,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources, 
-            Function<Object[], ? extends R> combiner) {
+            Function<? super T[], ? extends R> combiner) {
         return combineLatest(sources, combiner, bufferSize());
     }
 
@@ -300,7 +301,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources, 
-            Function<Object[], ? extends R> combiner, int bufferSize) {
+            Function<? super T[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
         ObjectHelper.requireNonNull(combiner, "combiner is null");
         ObjectHelper.verifyPositive(bufferSize, "bufferSize");
@@ -335,7 +336,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources, 
-            Function<Object[], ? extends R> combiner) {
+            Function<? super T[], ? extends R> combiner) {
         return combineLatestDelayError(sources, combiner, bufferSize());
     }
 
@@ -368,11 +369,42 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
-    public static <T, R> Flowable<R> combineLatestDelayError(Function<Object[], ? extends R> combiner, 
+    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super T[], ? extends R> combiner, 
             Publisher<? extends T>... sources) {
         return combineLatestDelayError(sources, combiner, bufferSize());
     }
 
+    /**
+     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
+     * the source ObservableSources each time an item is received from any of the source Publisher, where this
+     * aggregation is defined by a specified function and delays any error from the sources until
+     * all source Publishers terminate.
+     * 
+     * <dl>
+     *  <dt><b>Scheduler:</b></dt>
+     *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.</dd>
+     * </dl>
+     *
+     * @param <T>
+     *            the common base type of source values
+     * @param <R>
+     *            the result type
+     * @param sources
+     *            the collection of source Publishers
+     * @param combiner
+     *            the aggregation function used to combine the items emitted by the source Publishers
+     * @param bufferSize 
+     *            the internal buffer size and prefetch amount applied to every source Publisher
+     * @return a Flowable that emits items that are the result of combining the items emitted by the source
+     *         Publishers by means of the given aggregation function
+     * @see <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
+     */
+    @SchedulerSupport(SchedulerSupport.NONE)
+    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super T[], ? extends R> combiner, 
+            int bufferSize, Publisher<? extends T>... sources) {
+        return combineLatestDelayError(sources, combiner, bufferSize);
+    }
+
     /**
      * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
      * the source Publishers each time an item is received from any of the source Publishers, where this
@@ -405,7 +437,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources, 
-            Function<Object[], ? extends R> combiner, int bufferSize) {
+            Function<? super T[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
         ObjectHelper.requireNonNull(combiner, "combiner is null");
         ObjectHelper.verifyPositive(bufferSize, "bufferSize");
@@ -445,7 +477,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources, 
-            Function<Object[], ? extends R> combiner) {
+            Function<? super T[], ? extends R> combiner) {
         return combineLatestDelayError(sources, combiner, bufferSize());
     }
 
@@ -481,7 +513,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources, 
-            Function<Object[], ? extends R> combiner, int bufferSize) {
+            Function<? super T[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
         ObjectHelper.requireNonNull(combiner, "combiner is null");
         ObjectHelper.verifyPositive(bufferSize, "bufferSize");
@@ -522,6 +554,8 @@ public static int bufferSize() {
     public static <T1, T2, R> Flowable<R> combineLatest(
             Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
             BiFunction<? super T1, ? super T2, ? extends R> combiner) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
         Function<Object[], R> f = Functions.toFunction(combiner);
         return combineLatest(f, source1, source2);
     }
@@ -564,6 +598,9 @@ public static int bufferSize() {
             Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
             Publisher<? extends T3> source3, 
             Function3<? super T1, ? super T2, ? super T3, ? extends R> combiner) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
         return combineLatest(Functions.toFunction(combiner), source1, source2, source3);
     }
 
@@ -608,6 +645,10 @@ public static int bufferSize() {
             Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
             Publisher<? extends T3> source3, Publisher<? extends T4> source4,
             Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> combiner) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
         return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4);
     }
 
@@ -656,6 +697,11 @@ public static int bufferSize() {
             Publisher<? extends T3> source3, Publisher<? extends T4> source4,
             Publisher<? extends T5> source5,
             Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> combiner) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
         return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5);
     }
 
@@ -707,6 +753,12 @@ public static int bufferSize() {
             Publisher<? extends T3> source3, Publisher<? extends T4> source4,
             Publisher<? extends T5> source5, Publisher<? extends T6> source6,
             Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> combiner) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
         return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6);
     }
 
@@ -762,6 +814,13 @@ public static int bufferSize() {
             Publisher<? extends T5> source5, Publisher<? extends T6> source6,
             Publisher<? extends T7> source7,
             Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> combiner) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
+        ObjectHelper.requireNonNull(source7, "source7 is null");
         return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7);
     }
 
@@ -820,6 +879,14 @@ public static int bufferSize() {
             Publisher<? extends T5> source5, Publisher<? extends T6> source6,
             Publisher<? extends T7> source7, Publisher<? extends T8> source8,
             Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> combiner) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
+        ObjectHelper.requireNonNull(source7, "source7 is null");
+        ObjectHelper.requireNonNull(source8, "source8 is null");
         return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8);
     }
 
@@ -882,6 +949,15 @@ public static int bufferSize() {
             Publisher<? extends T7> source7, Publisher<? extends T8> source8,
             Publisher<? extends T9> source9,
             Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> combiner) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
+        ObjectHelper.requireNonNull(source7, "source7 is null");
+        ObjectHelper.requireNonNull(source8, "source8 is null");
+        ObjectHelper.requireNonNull(source9, "source9 is null");
         return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8, source9);
     }
 
@@ -1416,6 +1492,8 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.SPECIAL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Flowable<T> create(FlowableOnSubscribe<T> source, FlowableEmitter.BackpressureMode mode) {
+        ObjectHelper.requireNonNull(source, "source is null");
+        ObjectHelper.requireNonNull(mode, "mode is null");
         return RxJavaPlugins.onAssembly(new FlowableCreate<T>(source, mode));
     }
 
@@ -1881,8 +1959,7 @@ public static int bufferSize() {
     public static <T, S> Flowable<T> generate(Callable<S> initialState, final BiConsumer<S, Emitter<T>> generator, 
             Consumer<? super S> disposeState) {
         ObjectHelper.requireNonNull(generator, "generator is null");
-        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), 
-                disposeState);
+        return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), disposeState);
     }
 
     /**
@@ -2003,16 +2080,9 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public static Flowable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {
-        if (initialDelay < 0) {
-            initialDelay = 0L;
-        }
-        if (period < 0) {
-            period = 0L;
-        }
         ObjectHelper.requireNonNull(unit, "unit is null");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
-
-        return RxJavaPlugins.onAssembly(new FlowableInterval(initialDelay, period, unit, scheduler));
+        return RxJavaPlugins.onAssembly(new FlowableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));
     }
 
     /**
@@ -2110,25 +2180,21 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {
-        ObjectHelper.requireNonNull(unit, "unit is null");
-        ObjectHelper.requireNonNull(scheduler, "scheduler is null");
+        if (count < 0L) {
+            throw new IllegalArgumentException("count >= 0 required but it was " + count);
+        }
         if (count == 0L) {
-            return RxJavaPlugins.onAssembly(Flowable.<Long>empty().delay(initialDelay, unit, scheduler));
+            return Flowable.<Long>empty().delay(initialDelay, unit, scheduler);
         }
         
         long end = start + (count - 1);
-        if (end < 0) {
+        if (start > 0 && end < 0) {
             throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");
         }
+        ObjectHelper.requireNonNull(unit, "unit is null");
+        ObjectHelper.requireNonNull(scheduler, "scheduler is null");
 
-        if (initialDelay < 0) {
-            initialDelay = 0L;
-        }
-        if (period < 0) {
-            period = 0L;
-        }
-
-        return RxJavaPlugins.onAssembly(new FlowableIntervalRange(start, end, initialDelay, period, unit, scheduler));
+        return RxJavaPlugins.onAssembly(new FlowableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));
     }
 
     /**
@@ -3644,13 +3710,10 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public static Flowable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {
-        if (delay < 0) {
-            delay = 0L;
-        }
         ObjectHelper.requireNonNull(unit, "unit is null");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
 
-        return RxJavaPlugins.onAssembly(new FlowableTimer(delay, unit, scheduler));
+        return RxJavaPlugins.onAssembly(new FlowableTimer(Math.max(0L, delay), unit, scheduler));
     }
 
     /**
@@ -3911,6 +3974,8 @@ public static int bufferSize() {
     public static <T1, T2, R> Flowable<R> zip(
             Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
             BiFunction<? super T1, ? super T2, ? extends R> zipper) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
         return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2);
     }
 
@@ -3969,6 +4034,8 @@ public static int bufferSize() {
     public static <T1, T2, R> Flowable<R> zip(
             Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
             BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
         return zipArray(Functions.toFunction(zipper), delayError, bufferSize(), source1, source2);
     }
 
@@ -4029,6 +4096,8 @@ public static int bufferSize() {
     public static <T1, T2, R> Flowable<R> zip(
             Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
             BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError, int bufferSize) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
         return zipArray(Functions.toFunction(zipper), delayError, bufferSize, source1, source2);
     }
 
@@ -4090,6 +4159,9 @@ public static int bufferSize() {
     public static <T1, T2, T3, R> Flowable<R> zip(
             Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3, 
             Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
         return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3);
     }
 
@@ -4155,6 +4227,10 @@ public static int bufferSize() {
             Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,
             Publisher<? extends T4> source4,
             Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> zipper) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
         return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4);
     }
 
@@ -4223,6 +4299,11 @@ public static int bufferSize() {
             Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,
             Publisher<? extends T4> source4, Publisher<? extends T5> source5,
             Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> zipper) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
         return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5);
     }
 
@@ -4293,6 +4374,12 @@ public static int bufferSize() {
             Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,
             Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,
             Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> zipper) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
         return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6);
     }
 
@@ -4367,6 +4454,13 @@ public static int bufferSize() {
             Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,
             Publisher<? extends T7> source7,
             Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> zipper) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
+        ObjectHelper.requireNonNull(source7, "source7 is null");
         return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7);
     }
 
@@ -4444,6 +4538,14 @@ public static int bufferSize() {
             Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,
             Publisher<? extends T7> source7, Publisher<? extends T8> source8,
             Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> zipper) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
+        ObjectHelper.requireNonNull(source7, "source7 is null");
+        ObjectHelper.requireNonNull(source8, "source8 is null");
         return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8);
     }
 
@@ -4524,6 +4626,16 @@ public static int bufferSize() {
             Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,
             Publisher<? extends T7> source7, Publisher<? extends T8> source8, Publisher<? extends T9> source9,
             Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> zipper) {
+        
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
+        ObjectHelper.requireNonNull(source7, "source7 is null");
+        ObjectHelper.requireNonNull(source8, "source8 is null");
+        ObjectHelper.requireNonNull(source9, "source9 is null");
         return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8, source9);
     }
 
@@ -6743,7 +6855,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
         ObjectHelper.requireNonNull(unit, "unit is null");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
         
-        return RxJavaPlugins.onAssembly(new FlowableDelay<T>(this, delay, unit, scheduler, delayError));
+        return RxJavaPlugins.onAssembly(new FlowableDelay<T>(this, Math.max(0L, delay), unit, scheduler, delayError));
     }
 
     /**
@@ -9780,7 +9892,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
      *  <dd>{@code repeat} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param count
+     * @param times
      *            the number of times the source Publisher items are repeated, a count of 0 will yield an empty
      *            sequence
      * @return a Flowable that repeats the sequence of items emitted by the source Publisher at most
@@ -9791,14 +9903,14 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> repeat(long count) {
-        if (count < 0) {
-            throw new IllegalArgumentException("count >= 0 required but it was " + count);
+    public final Flowable<T> repeat(long times) {
+        if (times < 0) {
+            throw new IllegalArgumentException("times >= 0 required but it was " + times);
         }
-        if (count == 0) {
+        if (times == 0) {
             return empty();
         }
-        return RxJavaPlugins.onAssembly(new FlowableRepeat<T>(this, count));
+        return RxJavaPlugins.onAssembly(new FlowableRepeat<T>(this, times));
     }
 
     /**
@@ -10025,9 +10137,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public final <R> Flowable<R> replay(Function<? super Flowable<T>, ? extends Publisher<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
-        if (bufferSize < 0) {
-            throw new IllegalArgumentException("bufferSize < 0");
-        }
+        ObjectHelper.verifyPositive(bufferSize, "bufferSize");
         ObjectHelper.requireNonNull(selector, "selector is null");
         return FlowableReplay.multicastSelector(
                 FlowableInternalHelper.replayCallable(this, bufferSize, time, unit, scheduler), selector);
@@ -10277,9 +10387,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
     public final ConnectableFlowable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
         ObjectHelper.requireNonNull(unit, "unit is null");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
-        if (bufferSize < 0) {
-            throw new IllegalArgumentException("bufferSize < 0");
-        }
+        ObjectHelper.verifyPositive(bufferSize, "bufferSize");
         return FlowableReplay.create(this, time, unit, scheduler, bufferSize);
     }
 
@@ -11657,9 +11765,7 @@ public final void subscribe(Subscriber<? super T> s) {
         try {
             s = RxJavaPlugins.onSubscribe(this, s);
 
-            if (s == null) {
-                throw new NullPointerException("Plugin returned null Subscriber");
-            }
+            ObjectHelper.requireNonNull(s, "Plugin returned null Subscriber");
             
             subscribeActual(s);
         } catch (NullPointerException e) { // NOPMD
@@ -11939,7 +12045,7 @@ public final void subscribe(Subscriber<? super T> s) {
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Flowable<T> take(long count) {
         if (count < 0) {
-            throw new IllegalArgumentException("n >= required but it was " + count);
+            throw new IllegalArgumentException("count >= 0 required but it was " + count);
         }
         return RxJavaPlugins.onAssembly(new FlowableTake<T>(this, count));
     }
@@ -12050,7 +12156,7 @@ public final void subscribe(Subscriber<? super T> s) {
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Flowable<T> takeLast(int count) {
         if (count < 0) {
-            throw new IndexOutOfBoundsException("n >= required but it was " + count);
+            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);
         } else
         if (count == 0) {
             return ignoreElements();
@@ -13931,6 +14037,8 @@ public final Completable toCompletable() {
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {
         ObjectHelper.verifyPositive(bufferSize, "bufferSize");
+        ObjectHelper.verifyPositive(timespan, "timespan");
+        ObjectHelper.verifyPositive(timeskip, "timeskip");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
         ObjectHelper.requireNonNull(unit, "unit is null");
         return RxJavaPlugins.onAssembly(new FlowableWindowTimed<T>(this, timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false));
diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java
index b437a6b322..8824ec63f3 100644
--- a/src/main/java/io/reactivex/Observable.java
+++ b/src/main/java/io/reactivex/Observable.java
@@ -269,6 +269,9 @@ public static int bufferSize() {
     public static <T, R> Observable<R> combineLatest(ObservableSource<? extends T>[] sources, 
             Function<? super T[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
+        if (sources.length == 0) {
+            return empty();
+        }
         ObjectHelper.requireNonNull(combiner, "combiner is null");
         ObjectHelper.verifyPositive(bufferSize, "bufferSize");
         
@@ -954,7 +957,7 @@ public static int bufferSize() {
      * Note: named this way because of overload conflict with concat(ObservableSource&lt;ObservableSource&gt;)
      * @param sources the array of sources
      * @param <T> the common base value type
-     * @return the new NbpObservable instance
+     * @return the new Observable instance
      * @throws NullPointerException if sources is null
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
@@ -1832,9 +1835,16 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {
-
+        if (count < 0) {
+            throw new IllegalArgumentException("count >= 0 required but it was " + count);
+        }
+        
+        if (count == 0L) {
+            return Observable.<Long>empty().delay(initialDelay, unit, scheduler);
+        }
+        
         long end = start + (count - 1);
-        if (end < 0) {
+        if (start > 0 && end < 0) {
             throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");
         }
         ObjectHelper.requireNonNull(unit, "unit is null");
@@ -9818,11 +9828,25 @@ public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super T
 
     @Override
     public final void subscribe(Observer<? super T> observer) {
-        ObjectHelper.requireNonNull(observer, "observer is null");
-        
-        observer = RxJavaPlugins.onSubscribe(this, observer);
-        
-        subscribeActual(observer);
+        ObjectHelper.requireNonNull(observer, "s is null");
+        try {
+            observer = RxJavaPlugins.onSubscribe(this, observer);
+
+            ObjectHelper.requireNonNull(observer, "Plugin returned null Observer");
+            
+            subscribeActual(observer);
+        } catch (NullPointerException e) { // NOPMD
+            throw e;
+        } catch (Throwable e) {
+            Exceptions.throwIfFatal(e);
+            // can't call onError because no way to know if a Disposable has been set or not
+            // can't call onSubscribe because the call might have set a Subscription already
+            RxJavaPlugins.onError(e);
+            
+            NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS");
+            npe.initCause(e);
+            throw npe;
+        }
     }
     
     /**
@@ -10151,7 +10175,7 @@ public final void subscribe(Observer<? super T> observer) {
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Observable<T> takeLast(int count) {
         if (count < 0) {
-            throw new IndexOutOfBoundsException("count >= required but it was " + count);
+            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);
         } else
         if (count == 0) {
             return ignoreElements();
diff --git a/src/main/java/io/reactivex/internal/functions/Functions.java b/src/main/java/io/reactivex/internal/functions/Functions.java
index b95574163a..f0994c2390 100644
--- a/src/main/java/io/reactivex/internal/functions/Functions.java
+++ b/src/main/java/io/reactivex/internal/functions/Functions.java
@@ -31,15 +31,15 @@ private Functions() {
     }
     
     @SuppressWarnings("unchecked")
-    public static <T1, T2, R> Function<Object[], R> toFunction(final BiFunction<? super T1, ? super T2, ? extends R> biFunction) {
-        ObjectHelper.requireNonNull(biFunction, "biFunction is null");
+    public static <T1, T2, R> Function<Object[], R> toFunction(final BiFunction<? super T1, ? super T2, ? extends R> f) {
+        ObjectHelper.requireNonNull(f, "f is null");
         return new Function<Object[], R>() {
             @Override
             public R apply(Object[] a) throws Exception {
                 if (a.length != 2) {
                     throw new IllegalArgumentException("Array of size 2 expected but got " + a.length);
                 }
-                return ((BiFunction<Object, Object, R>)biFunction).apply(a[0], a[1]);
+                return ((BiFunction<Object, Object, R>)f).apply(a[0], a[1]);
             }
         };
     }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java
index 442090dbf1..c3f73c6327 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java
@@ -77,6 +77,8 @@ public void subscribeActual(Subscriber<? super C> s) {
         Subscription s;
 
         boolean done;
+        
+        int index;
 
         public PublisherBufferExactSubscriber(Subscriber<? super C> actual, int size, Callable<C> bufferSupplier) {
             this.actual = actual;
@@ -133,10 +135,14 @@ public void onNext(T t) {
             }
 
             b.add(t);
-
-            if (b.size() == size) {
+            
+            int i = index + 1;
+            if (i == size) {
+                index = 0;
                 buffer = null;
                 actual.onNext(b);
+            } else {
+                index = i;
             }
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
index 3449ed7a4c..3af9de521a 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
@@ -40,14 +40,14 @@
 
     final Iterable<? extends Publisher<? extends T>> iterable;
 
-    final Function<Object[], ? extends R> combiner;
+    final Function<? super T[], ? extends R> combiner;
     
     final int bufferSize;
     
     final boolean delayErrors;
 
     public FlowableCombineLatest(Publisher<? extends T>[] array,
-            Function<Object[], ? extends R> combiner,
+            Function<? super T[], ? extends R> combiner,
                     int bufferSize, boolean delayErrors) {
         if (bufferSize <= 0) {
             throw new IllegalArgumentException("BUFFER_SIZE > 0 required but it was " + bufferSize);
@@ -61,7 +61,7 @@ public FlowableCombineLatest(Publisher<? extends T>[] array,
     }
     
     public FlowableCombineLatest(Iterable<? extends Publisher<? extends T>> iterable,
-            Function<Object[], ? extends R> combiner,
+            Function<? super T[], ? extends R> combiner,
                     int bufferSize, boolean delayErrors) {
         if (bufferSize <= 0) {
             throw new IllegalArgumentException("BUFFER_SIZE > 0 required but it was " + bufferSize);
@@ -150,7 +150,7 @@ public void subscribeActual(Subscriber<? super R> s) {
             new FlowableMap<T, R>((Publisher<T>)a[0], new Function<T, R>() {
                 @Override
                 public R apply(T t) throws Exception {
-                    return combiner.apply(new Object[] { t });
+                    return combiner.apply((T[])new Object[] { t });
                 }
             }).subscribe(s);
             return;
@@ -173,7 +173,7 @@ public R apply(T t) throws Exception {
 
         final Subscriber<? super R> actual;
         
-        final Function<Object[], ? extends R> combiner;
+        final Function<? super T[], ? extends R> combiner;
         
         final CombineLatestInnerSubscriber<T>[] subscribers;
         
@@ -198,7 +198,7 @@ public R apply(T t) throws Exception {
         final AtomicReference<Throwable> error;
         
         public CombineLatestCoordinator(Subscriber<? super R> actual, 
-                Function<Object[], ? extends R> combiner, int n,
+                Function<? super T[], ? extends R> combiner, int n,
                 int bufferSize, boolean delayErrors) {
             this.actual = actual;
             this.combiner = combiner;
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java
index 97526d2e2d..6fe5508974 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java
@@ -273,87 +273,88 @@ public void drain() {
                 
                 if (inner != null) {
                     SimpleQueue<R> q = inner.queue();
-                    
-                    while (e != r) {
-                        if (cancelled) {
-                            cancelAll();
-                            return;
-                        }
-                        
-                        if (em == ErrorMode.IMMEDIATE) {
-                            Throwable ex = error.get();
-                            if (ex != null) {
-                                current = null;
-                                inner.cancel();
+                    if (q != null) {
+                        while (e != r) {
+                            if (cancelled) {
                                 cancelAll();
-                                
-                                a.onError(ex);
                                 return;
                             }
-                        }
-                        
-                        boolean d = inner.isDone();
-                        
-                        R v;
-                        
-                        try {
-                            v = q.poll();
-                        } catch (Throwable ex) {
-                            Exceptions.throwIfFatal(ex);
-                            current = null;
-                            inner.cancel();
-                            cancelAll();
-                            a.onError(ex);
-                            return;
-                        }
-                        
-                        boolean empty = v == null;
-                        
-                        if (d && empty) {
-                            inner = null;
-                            current = null;
-                            s.request(1);
-                            continue outer;
-                        }
-                        
-                        if (empty) {
-                            break;
-                        }
-                        
-                        a.onNext(v);
-                        
-                        e++;
-                        
-                        inner.requestOne();
-                    }
-
-                    if (e == r) {
-                        if (cancelled) {
-                            cancelAll();
-                            return;
-                        }
-                        
-                        if (em == ErrorMode.IMMEDIATE) {
-                            Throwable ex = error.get();
-                            if (ex != null) {
+                            
+                            if (em == ErrorMode.IMMEDIATE) {
+                                Throwable ex = error.get();
+                                if (ex != null) {
+                                    current = null;
+                                    inner.cancel();
+                                    cancelAll();
+                                    
+                                    a.onError(ex);
+                                    return;
+                                }
+                            }
+                            
+                            boolean d = inner.isDone();
+                            
+                            R v;
+                            
+                            try {
+                                v = q.poll();
+                            } catch (Throwable ex) {
+                                Exceptions.throwIfFatal(ex);
                                 current = null;
                                 inner.cancel();
                                 cancelAll();
-                                
                                 a.onError(ex);
                                 return;
                             }
+                            
+                            boolean empty = v == null;
+                            
+                            if (d && empty) {
+                                inner = null;
+                                current = null;
+                                s.request(1);
+                                continue outer;
+                            }
+                            
+                            if (empty) {
+                                break;
+                            }
+                            
+                            a.onNext(v);
+                            
+                            e++;
+                            
+                            inner.requestOne();
                         }
-                        
-                        boolean d = inner.isDone();
-                        
-                        boolean empty = inner.queue().isEmpty();
-                        
-                        if (d && empty) {
-                            inner = null;
-                            current = null;
-                            s.request(1);
-                            continue;
+    
+                        if (e == r) {
+                            if (cancelled) {
+                                cancelAll();
+                                return;
+                            }
+                            
+                            if (em == ErrorMode.IMMEDIATE) {
+                                Throwable ex = error.get();
+                                if (ex != null) {
+                                    current = null;
+                                    inner.cancel();
+                                    cancelAll();
+                                    
+                                    a.onError(ex);
+                                    return;
+                                }
+                            }
+                            
+                            boolean d = inner.isDone();
+                            
+                            boolean empty = q.isEmpty();
+                            
+                            if (d && empty) {
+                                inner = null;
+                                current = null;
+                                s.request(1);
+                                continue;
+                            }
                         }
                     }
                 }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBuffer.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBuffer.java
index 28907fad1a..2474b0485c 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBuffer.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBuffer.java
@@ -179,6 +179,15 @@ void drain() {
                         e++;
                     }
                     
+                    if (e == r) {
+                        boolean d = done;
+                        boolean empty = q.isEmpty();
+                        
+                        if (checkTerminated(d, empty, a)) {
+                            return;
+                        }
+                    }
+                    
                     if (e != 0L) {
                         if (r != Long.MAX_VALUE) {
                             requested.addAndGet(-e);
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
index 97258951f3..66cb59edeb 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
@@ -180,7 +180,7 @@ protected void subscribeActual(Subscriber<? super T> s) {
      * @param unit the unit of measure of the age amount
      * @param scheduler the target scheduler providing the current time
      * @param bufferSize the maximum number of elements to hold
-     * @return the new NbpConnectableObservable instance
+     * @return the new ConnectableFlowable instance
      */
     public static <T> ConnectableFlowable<T> create(Flowable<T> source,
             final long maxAge, final TimeUnit unit, final Scheduler scheduler, final int bufferSize) {
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java
index 9eac524db5..c1c4ada107 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java
@@ -18,214 +18,205 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Flowable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.BiPredicate;
+import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.*;
+import io.reactivex.internal.util.AtomicThrowable;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class FlowableSequenceEqual<T> extends Flowable<Boolean> {
     final Publisher<? extends T> first;
     final Publisher<? extends T> second;
     final BiPredicate<? super T, ? super T> comparer;
-    final int bufferSize;
+    final int prefetch;
     
     public FlowableSequenceEqual(Publisher<? extends T> first, Publisher<? extends T> second,
-            BiPredicate<? super T, ? super T> comparer, int bufferSize) {
+            BiPredicate<? super T, ? super T> comparer, int prefetch) {
         this.first = first;
         this.second = second;
         this.comparer = comparer;
-        this.bufferSize = bufferSize;
+        this.prefetch = prefetch;
     }
     
     @Override
     public void subscribeActual(Subscriber<? super Boolean> s) {
-        EqualCoordinator<T> ec = new EqualCoordinator<T>(s, bufferSize, first, second, comparer);
-        ec.subscribe();
+        EqualCoordinator<T> parent = new EqualCoordinator<T>(s, prefetch, comparer);
+        s.onSubscribe(parent);
+        parent.subscribe(first, second);
     }
     
-    static final class EqualCoordinator<T> extends AtomicInteger implements Subscription {
+    static final class EqualCoordinator<T> extends DeferredScalarSubscription<Boolean> {
         /** */
         private static final long serialVersionUID = -6178010334400373240L;
-        final Subscriber<? super Boolean> actual;
+        
         final BiPredicate<? super T, ? super T> comparer;
-        final ArrayCompositeSubscription resources;
-        final Publisher<? extends T> first;
-        final Publisher<? extends T> second;
-        final EqualSubscriber<T>[] subscribers;
         
-        volatile boolean cancelled;
+        final int prefetch;
+        
+        final EqualSubscriber<T> first;
+        
+        final EqualSubscriber<T> second;
         
-        final AtomicBoolean once = new AtomicBoolean();
+        final AtomicThrowable error;
+        
+        final AtomicInteger wip;
         
         T v1;
         
         T v2;
         
-        public EqualCoordinator(Subscriber<? super Boolean> actual, int bufferSize,
-                Publisher<? extends T> first, Publisher<? extends T> second,
-                BiPredicate<? super T, ? super T> comparer) {
-            this.actual = actual;
-            this.first = first;
-            this.second = second;
+        public EqualCoordinator(Subscriber<? super Boolean> actual, int prefetch, BiPredicate<? super T, ? super T> comparer) {
+            super(actual);
+            this.prefetch = prefetch;
             this.comparer = comparer;
-            @SuppressWarnings("unchecked")
-            EqualSubscriber<T>[] as = new EqualSubscriber[2];
-            this.subscribers = as;
-            as[0] = new EqualSubscriber<T>(this, 0, bufferSize);
-            as[1] = new EqualSubscriber<T>(this, 1, bufferSize);
-            this.resources = new ArrayCompositeSubscription(2);
-        }
-        
-        boolean setSubscription(Subscription s, int index) {
-            return resources.setResource(index, s);
+            this.wip = new AtomicInteger();
+            this.first = new EqualSubscriber<T>(this, prefetch);
+            this.second = new EqualSubscriber<T>(this, prefetch);
+            this.error = new AtomicThrowable();
         }
         
-        void subscribe() {
-            EqualSubscriber<T>[] as = subscribers;
-            first.subscribe(as[0]);
-            second.subscribe(as[1]);
+        void subscribe(Publisher<? extends T> source1, Publisher<? extends T> source2) {
+            source1.subscribe(first);
+            source2.subscribe(second);
         }
 
-        @Override
-        public void request(long n) {
-            if (!SubscriptionHelper.validate(n)) {
-                return;
-            }
-            if (once.compareAndSet(false, true)) {
-                EqualSubscriber<T>[] as = subscribers;
-                first.subscribe(as[0]);
-                second.subscribe(as[1]);
-            }
-        }
-        
         @Override
         public void cancel() {
-            if (!cancelled) {
-                cancelled = true;
-                resources.dispose();
-                
-                if (getAndIncrement() == 0) {
-                    EqualSubscriber<T>[] as = subscribers;
-                    as[0].queue.clear();
-                    as[1].queue.clear();
-                }
+            super.cancel();
+            first.cancel();
+            second.cancel();
+            if (wip.getAndIncrement() == 0) {
+                first.clear();
+                second.clear();
             }
         }
         
-        void cancel(SpscArrayQueue<T> q1, SpscArrayQueue<T> q2) {
-            cancelled = true;
-            q1.clear();
-            q2.clear();
+        void cancelAndClear() {
+            first.cancel();
+            first.clear();
+            second.cancel();
+            second.clear();
         }
         
         void drain() {
-            if (getAndIncrement() != 0) {
+            if (wip.getAndIncrement() != 0) {
                 return;
             }
-            
+
             int missed = 1;
-            EqualSubscriber<T>[] as = subscribers;
-            
-            final EqualSubscriber<T> s1 = as[0];
-            final SpscArrayQueue<T> q1 = s1.queue;
-            final EqualSubscriber<T> s2 = as[1];
-            final SpscArrayQueue<T> q2 = s2.queue;
             
             for (;;) {
+                SimpleQueue<T> q1 = first.queue;
+                SimpleQueue<T> q2 = second.queue;
                 
-                long r = 0L;
-                for (;;) {
-                    if (cancelled) {
-                        q1.clear();
-                        q2.clear();
-                        return;
-                    }
-                    
-                    boolean d1 = s1.done;
-                    
-                    if (d1) {
-                        Throwable e = s1.error;
-                        if (e != null) {
-                            cancel(q1, q2);
-                            
-                            actual.onError(e);
+                if (q1 != null && q2 != null) {
+                    for (;;) {
+                        if (isCancelled()) {
+                            first.clear();
+                            second.clear();
                             return;
                         }
-                    }
-                    
-                    boolean d2 = s2.done;
-
-                    if (d2) {
-                        Throwable e = s2.error;
-                        if (e != null) {
-                            cancel(q1, q2);
+                        
+                        Throwable ex = error.get();
+                        if (ex != null) {
+                            cancelAndClear();
                             
-                            actual.onError(e);
+                            actual.onError(error.terminate());
                             return;
                         }
-                    }
 
-                    if (v1 == null) {
-                        v1 = q1.poll();
-                    }
-                    boolean e1 = v1 == null;
-                    
-                    if (v2 == null) {
-                        v2 = q2.poll();
-                    }
-                    boolean e2 = v2 == null;
+                        boolean d1 = first.done;
+                        
+                        T a = v1;
+                        if (a == null) {
+                            try {
+                                a = q1.poll();
+                            } catch (Throwable exc) {
+                                Exceptions.throwIfFatal(exc);
+                                cancelAndClear();
+                                error.addThrowable(exc);
+                                actual.onError(error.terminate());
+                                return;
+                            }
+                            v1 = a;
+                        }
+                        boolean e1 = a == null;
+                        
+                        boolean d2 = second.done;
+                        T b = v2;
+                        if (b == null) {
+                            try {
+                                b = q2.poll();
+                            } catch (Throwable exc) {
+                                Exceptions.throwIfFatal(exc);
+                                cancelAndClear();
+                                error.addThrowable(exc);
+                                actual.onError(error.terminate());
+                                return;
+                            }
+                            v2 = b;
+                        }
 
-                    if (d1 && d2 && e1 && e2) {
-                        actual.onNext(true);
-                        actual.onComplete();
-                        return;
-                    }
-                    if ((d1 && d2) && (e1 != e2)) {
-                        cancel(q1, q2);
+                        boolean e2 = b == null;
+                        
+                        if (d1 && d2 && e1 && e2) {
+                            complete(true);
+                            return;
+                        }
+                        if ((d1 && d2) && (e1 != e2)) {
+                            cancelAndClear();
+                            complete(false);
+                            return;
+                        }
+                        
+                        if (e1 || e2) {
+                            break;
+                        }
                         
-                        actual.onNext(false);
-                        actual.onComplete();
-                        return;
-                    }
-                    
-                    if (!e1 && !e2) {
                         boolean c;
                         
                         try {
-                            c = comparer.test(v1, v2);
-                        } catch (Throwable ex) {
-                            Exceptions.throwIfFatal(ex);
-                            cancel(q1, q2);
-                            
-                            actual.onError(ex);
+                            c = comparer.test(a, b);
+                        } catch (Throwable exc) {
+                            Exceptions.throwIfFatal(exc);
+                            cancelAndClear();
+                            error.addThrowable(exc);
+                            actual.onError(error.terminate());
                             return;
                         }
                         
                         if (!c) {
-                            cancel(q1, q2);
-                            
-                            actual.onNext(false);
-                            actual.onComplete();
+                            cancelAndClear();
+                            complete(false);
                             return;
                         }
-                        r++;
                         
                         v1 = null;
                         v2 = null;
+                        
+                        first.request();
+                        second.request();
                     }
                     
-                    if (e1 || e2) {
-                        break;
+                } else {
+                    if (isCancelled()) {
+                        first.clear();
+                        second.clear();
+                        return;
+                    }
+                    
+                    Throwable ex = error.get();
+                    if (ex != null) {
+                        cancelAndClear();
+                        
+                        actual.onError(error.terminate());
+                        return;
                     }
                 }
                 
-                if (r != 0L) {
-                    s1.s.request(r);
-                    s2.s.request(r);
-                }
-                
-                
-                missed = addAndGet(-missed);
+                missed = wip.addAndGet(-missed);
                 if (missed == 0) {
                     break;
                 }
@@ -233,46 +224,80 @@ void drain() {
         }
     }
     
-    static final class EqualSubscriber<T> implements Subscriber<T> {
+    static final class EqualSubscriber<T> 
+    extends AtomicReference<Subscription>
+    implements Subscriber<T> {
+        /** */
+        private static final long serialVersionUID = 4804128302091633067L;
+        
         final EqualCoordinator<T> parent;
-        final SpscArrayQueue<T> queue;
-        final int index;
-        final int bufferSize;
         
+        final int prefetch;
+        
+        final int limit;
+        
+        long produced;
+
+        volatile SimpleQueue<T> queue;
+
         volatile boolean done;
-        Throwable error;
         
-        Subscription s;
+        int sourceMode;
         
-        public EqualSubscriber(EqualCoordinator<T> parent, int index, int bufferSize) {
+        public EqualSubscriber(EqualCoordinator<T> parent, int prefetch) {
             this.parent = parent;
-            this.bufferSize = bufferSize;
-            this.index = index;
-            this.queue = new SpscArrayQueue<T>(bufferSize);
+            this.limit = prefetch - (prefetch >> 2);
+            this.prefetch = prefetch;
         }
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (parent.setSubscription(s, index)) {
-                this.s = s;
-                s.request(bufferSize);
+            if (SubscriptionHelper.setOnce(this, s)) {
+                if (s instanceof QueueSubscription) {
+                    @SuppressWarnings("unchecked")
+                    QueueSubscription<T> qs = (QueueSubscription<T>) s;
+                    
+                    int m = qs.requestFusion(QueueSubscription.ANY);
+                    if (m == QueueSubscription.SYNC) {
+                        sourceMode = m;
+                        queue = qs;
+                        done = true;
+                        parent.drain();
+                        return;
+                    }
+                    if (m == QueueSubscription.ASYNC) {
+                        sourceMode = m;
+                        queue = qs;
+                        s.request(prefetch);
+                        return;
+                    }
+                }
+                
+                queue = new SpscArrayQueue<T>(prefetch);
+                
+                s.request(prefetch);
             }
         }
         
         @Override
         public void onNext(T t) {
-            if (!queue.offer(t)) {
-                onError(new IllegalStateException("Queue full?!"));
-                return;
+            if (sourceMode == QueueSubscription.NONE) {
+                if (!queue.offer(t)) {
+                    onError(new MissingBackpressureException());
+                    return;
+                }
             }
             parent.drain();
         }
         
         @Override
         public void onError(Throwable t) {
-            error = t;
-            done = true;
-            parent.drain();
+            EqualCoordinator<T> p = parent;
+            if (p.error.addThrowable(t)) {
+                p.drain();
+            } else {
+                RxJavaPlugins.onError(t);
+            }
         }
         
         @Override
@@ -280,5 +305,28 @@ public void onComplete() {
             done = true;
             parent.drain();
         }
+        
+        public void request() {
+            if (sourceMode != QueueSubscription.SYNC) {
+                long p = produced + 1;
+                if (p >= limit) {
+                    produced = 0;
+                    get().request(p);
+                } else {
+                    produced = p;
+                }
+            }
+        }
+        
+        public void cancel() {
+            SubscriptionHelper.cancel(this);
+        }
+        
+        void clear() {
+            SimpleQueue<T> sq = queue;
+            if (sq != null) {
+                sq.clear();
+            }
+        }
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
index 65377a3479..893ee57204 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
@@ -21,6 +21,7 @@
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.*;
@@ -71,7 +72,7 @@ public void subscribeActual(Subscriber<? super R> s) {
             return;
         }
 
-        ZipCoordinator<T, R> coordinator = new ZipCoordinator<T, R>(s, zipper, count, bufferSize);
+        ZipCoordinator<T, R> coordinator = new ZipCoordinator<T, R>(s, zipper, count, bufferSize, delayError);
 
         s.onSubscribe(coordinator);
 
@@ -93,7 +94,9 @@ public void subscribeActual(Subscriber<? super R> s) {
 
         final AtomicLong requested;
 
-        final AtomicReference<Throwable> error;
+        final AtomicThrowable errors;
+        
+        final boolean delayErrors;
 
         volatile boolean done;
 
@@ -102,9 +105,10 @@ public void subscribeActual(Subscriber<? super R> s) {
         final Object[] current;
 
         public ZipCoordinator(Subscriber<? super R> actual, 
-                Function<? super Object[], ? extends R> zipper, int n, int prefetch) {
+                Function<? super Object[], ? extends R> zipper, int n, int prefetch, boolean delayErrors) {
             this.actual = actual;
             this.zipper = zipper;
+            this.delayErrors = delayErrors;
             @SuppressWarnings("unchecked")
             ZipSubscriber<T, R>[] a = new ZipSubscriber[n];
             for (int i = 0; i < n; i++) {
@@ -113,13 +117,13 @@ public ZipCoordinator(Subscriber<? super R> actual,
             this.current = new Object[n];
             this.subscribers = a;
             this.requested = new AtomicLong();
-            this.error = new AtomicReference<Throwable>();
+            this.errors = new AtomicThrowable();
         }
 
         void subscribe(Publisher<? extends T>[] sources, int n) {
             ZipSubscriber<T, R>[] a = subscribers;
             for (int i = 0; i < n; i++) {
-                if (done || cancelled || error.get() != null) {
+                if (done || cancelled || (!delayErrors && errors.get() != null)) {
                     return;
                 }
                 sources[i].subscribe(a[i]);
@@ -143,8 +147,9 @@ public void cancel() {
             }
         }
 
-        void error(Throwable e) {
-            if (ExceptionHelper.addThrowable(error, e)) {
+        void error(ZipSubscriber<T, R> inner, Throwable e) {
+            if (errors.addThrowable(e)) {
+                inner.done = true;
                 drain();
             } else {
                 RxJavaPlugins.onError(e);
@@ -181,13 +186,9 @@ void drain() {
                         return;
                     }
 
-                    if (error.get() != null) {
+                    if (!delayErrors && errors.get() != null) {
                         cancelAll();
-
-                        Throwable ex = ExceptionHelper.terminate(error);
-
-                        a.onError(ex);
-
+                        a.onError(errors.terminate());
                         return;
                     }
 
@@ -205,8 +206,12 @@ void drain() {
                                 boolean sourceEmpty = v == null;
                                 if (d && sourceEmpty) {
                                     cancelAll();
-
-                                    a.onComplete();
+                                    Throwable ex = errors.get();
+                                    if (ex != null) {
+                                        a.onError(errors.terminate());
+                                    } else {
+                                        a.onComplete();
+                                    }
                                     return;
                                 }
                                 if (!sourceEmpty) {
@@ -217,14 +222,13 @@ void drain() {
                             } catch (Throwable ex) {
                                 Exceptions.throwIfFatal(ex);
 
-                                cancelAll();
-
-                                ExceptionHelper.addThrowable(error, ex);
-                                ex = ExceptionHelper.terminate(error);
-
-                                a.onError(ex);
-
-                                return;
+                                errors.addThrowable(ex);
+                                if (!delayErrors) {
+                                    cancelAll();
+                                    a.onError(errors.terminate());
+                                    return;
+                                }
+                                empty = true;
                             }
                         }
                     }
@@ -236,30 +240,12 @@ void drain() {
                     R v;
 
                     try {
-                        v = zipper.apply(values.clone());
+                        v = ObjectHelper.requireNonNull(zipper.apply(values.clone()), "The zipper returned a null value");
                     } catch (Throwable ex) {
                         Exceptions.throwIfFatal(ex);
-
                         cancelAll();
-
-                        ExceptionHelper.addThrowable(error, ex);
-                        ex = ExceptionHelper.terminate(error);
-
-                        a.onError(ex);
-
-                        return;
-                    }
-
-                    if (v == null) {
-                        cancelAll();
-
-                        Throwable ex = new NullPointerException("The zipper returned a null value");
-
-                        ExceptionHelper.addThrowable(error, ex);
-                        ex = ExceptionHelper.terminate(error);
-
-                        a.onError(ex);
-
+                        errors.addThrowable(ex);
+                        a.onError(errors.terminate());
                         return;
                     }
 
@@ -275,13 +261,9 @@ void drain() {
                         return;
                     }
 
-                    if (error.get() != null) {
+                    if (!delayErrors && errors.get() != null) {
                         cancelAll();
-
-                        Throwable ex = ExceptionHelper.terminate(error);
-
-                        a.onError(ex);
-
+                        a.onError(errors.terminate());
                         return;
                     }
 
@@ -296,8 +278,12 @@ void drain() {
                                 boolean empty = v == null;
                                 if (d && empty) {
                                     cancelAll();
-
-                                    a.onComplete();
+                                    Throwable ex = errors.get();
+                                    if (ex != null) {
+                                        a.onError(errors.terminate());
+                                    } else {
+                                        a.onComplete();
+                                    }
                                     return;
                                 }
                                 if (!empty) {
@@ -305,15 +291,12 @@ void drain() {
                                 }
                             } catch (Throwable ex) {
                                 Exceptions.throwIfFatal(ex);
-
-                                cancelAll();
-
-                                ExceptionHelper.addThrowable(error, ex);
-                                ex = ExceptionHelper.terminate(error);
-
-                                a.onError(ex);
-
-                                return;
+                                errors.addThrowable(ex);
+                                if (!delayErrors) {
+                                    cancelAll();
+                                    a.onError(errors.terminate());
+                                    return;
+                                }
                             }
                         }
                     }
@@ -408,7 +391,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (sourceMode != QueueSubscription.ASYNC) {
-                parent.error(t);
+                parent.error(this, t);
             }
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java
index 5fa67f90f2..ac58707a32 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java
@@ -55,7 +55,7 @@ public Object call() {
      * @param <R> the result value type
      * @param connectableFactory the factory that returns a ConnectableObservable for each individual subscriber
      * @param selector the function that receives a Observable and should return another Observable that will be subscribed to
-     * @return the new NbpObservable instance
+     * @return the new Observable instance
      */
     public static <U, R> Observable<R> multicastSelector(
             final Callable<? extends ConnectableObservable<U>> connectableFactory,
@@ -94,7 +94,7 @@ public void accept(Disposable r) {
      * @param <T> the value type
      * @param co the connectable observable instance
      * @param scheduler the target scheduler
-     * @return the new NbpConnectableObservable instance
+     * @return the new ConnectableObservable instance
      */
     public static <T> ConnectableObservable<T> observeOn(final ConnectableObservable<T> co, final Scheduler scheduler) {
         final Observable<T> observable = co.observeOn(scheduler);
@@ -115,7 +115,7 @@ protected void subscribeActual(Observer<? super T> observer) {
      * Creates a replaying ConnectableObservable with an unbounded buffer.
      * @param <T> the value type
      * @param source the source observable
-     * @return the new NbpConnectableObservable instance
+     * @return the new ConnectableObservable instance
      */
     @SuppressWarnings("unchecked")
     public static <T> ConnectableObservable<T> createFrom(Observable<? extends T> source) {
@@ -127,7 +127,7 @@ protected void subscribeActual(Observer<? super T> observer) {
      * @param <T> the value type
      * @param source the source Flowable to use
      * @param bufferSize the maximum number of elements to hold
-     * @return the new NbpConnectableObservable instance
+     * @return the new ConnectableObservable instance
      */
     public static <T> ConnectableObservable<T> create(Observable<T> source,
             final int bufferSize) {
@@ -149,7 +149,7 @@ protected void subscribeActual(Observer<? super T> observer) {
      * @param maxAge the maximum age of entries
      * @param unit the unit of measure of the age amount
      * @param scheduler the target scheduler providing the current time
-     * @return the new NbpConnectableObservable instance
+     * @return the new ConnectableObservable instance
      */
     public static <T> ConnectableObservable<T> create(Observable<T> source,
             long maxAge, TimeUnit unit, Scheduler scheduler) {
@@ -164,7 +164,7 @@ protected void subscribeActual(Observer<? super T> observer) {
      * @param unit the unit of measure of the age amount
      * @param scheduler the target scheduler providing the current time
      * @param bufferSize the maximum number of elements to hold
-     * @return the new NbpConnectableObservable instance
+     * @return the new ConnectableObservable instance
      */
     public static <T> ConnectableObservable<T> create(Observable<T> source,
             final long maxAge, final TimeUnit unit, final Scheduler scheduler, final int bufferSize) {
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeout.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeout.java
index f01492d592..7f67e2a6e6 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeout.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeout.java
@@ -95,7 +95,7 @@ public void onSubscribe(Disposable s) {
                     
                     if (p == null) {
                         dispose();
-                        EmptyDisposable.error(new NullPointerException("The first timeout NbpObservable is null"), a);
+                        EmptyDisposable.error(new NullPointerException("The first timeout Observable is null"), a);
                         return;
                     }
                     
@@ -136,7 +136,7 @@ public void onNext(T t) {
             
             if (p == null) {
                 dispose();
-                actual.onError(new NullPointerException("The NbpObservable returned is null"));
+                actual.onError(new NullPointerException("The ObservableSource returned is null"));
                 return;
             }
             
@@ -273,7 +273,7 @@ public void onSubscribe(Disposable s) {
                     
                     if (p == null) {
                         dispose();
-                        EmptyDisposable.error(new NullPointerException("The first timeout NbpObservable is null"), a);
+                        EmptyDisposable.error(new NullPointerException("The first timeout Observable is null"), a);
                         return;
                     }
                     
@@ -317,7 +317,7 @@ public void onNext(T t) {
             }
             
             if (p == null) {
-                actual.onError(new NullPointerException("The NbpObservable returned is null"));
+                actual.onError(new NullPointerException("The ObservableSource returned is null"));
                 return;
             }
             
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java
index e3550cfb98..5b98ec310b 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java
@@ -276,7 +276,7 @@ void drainLoop() {
                         
                         if (p == null) {
                             cancelled = true;
-                            a.onError(new NullPointerException("The NbpObservable supplied is null"));
+                            a.onError(new NullPointerException("The ObservableSource supplied is null"));
                             continue;
                         }
                         
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
index 66dcb2d87e..6d6b3f13d2 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
@@ -95,7 +95,7 @@ public void onSubscribe(Disposable s) {
                 
                 if (p == null) {
                     s.dispose();
-                    a.onError(new NullPointerException("The first window NbpObservable supplied is null"));
+                    a.onError(new NullPointerException("The first window ObservableSource supplied is null"));
                     return;
                 }
                 
@@ -242,7 +242,7 @@ void drainLoop() {
                         
                         if (p == null) {
                             DisposableHelper.dispose(boundary);
-                            a.onError(new NullPointerException("The NbpObservable supplied is null"));
+                            a.onError(new NullPointerException("The ObservableSource supplied is null"));
                             return;
                         }
                         
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/InnerQueuedSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/InnerQueuedSubscriber.java
index 19f3e4a621..008da70183 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/InnerQueuedSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/InnerQueuedSubscriber.java
@@ -40,7 +40,7 @@
     
     final int limit;
 
-    SimpleQueue<T> queue;
+    volatile SimpleQueue<T> queue;
     
     volatile boolean done;
     
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/QueueDrainObserver.java b/src/main/java/io/reactivex/internal/subscribers/observable/QueueDrainObserver.java
index c031a0ff18..7bd82e45ac 100644
--- a/src/main/java/io/reactivex/internal/subscribers/observable/QueueDrainObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/QueueDrainObserver.java
@@ -28,7 +28,7 @@
  * @param <U> the value type in the queue
  * @param <V> the value type the child subscriber accepts
  */
-public abstract class QueueDrainObserver<T, U, V> extends QueueDrainSubscriberPad2 implements Observer<T>, NbpQueueDrain<U, V> {
+public abstract class QueueDrainObserver<T, U, V> extends QueueDrainSubscriberPad2 implements Observer<T>, ObservableQueueDrain<U, V> {
     protected final Observer<? super V> actual;
     protected final SimpleQueue<U> queue;
     
diff --git a/src/main/java/io/reactivex/internal/util/NotificationLite.java b/src/main/java/io/reactivex/internal/util/NotificationLite.java
index c028a1ccc2..2f834fe2c3 100644
--- a/src/main/java/io/reactivex/internal/util/NotificationLite.java
+++ b/src/main/java/io/reactivex/internal/util/NotificationLite.java
@@ -226,11 +226,11 @@ public static Disposable getDisposable(Object o) {
     }
 
     /**
-     * Calls the appropriate NbpSubscriber method based on the type of the notification.
+     * Calls the appropriate Observer method based on the type of the notification.
      * <p>Does not check for a subscription notification.
      * @param <T> the expected value type when unwrapped
      * @param o the notification object
-     * @param s the NbpSubscriber to call methods on
+     * @param s the Observer to call methods on
      * @return true if the notification was a terminal event (i.e., complete or error)
      */
     @SuppressWarnings("unchecked")
@@ -274,7 +274,7 @@ public static Disposable getDisposable(Object o) {
     }
     
     /**
-     * Calls the appropriate NbpSubscriber method based on the type of the notification.
+     * Calls the appropriate Observer method based on the type of the notification.
      * @param <T> the expected value type when unwrapped
      * @param o the notification object
      * @param s the subscriber to call methods on
diff --git a/src/main/java/io/reactivex/internal/util/NbpQueueDrain.java b/src/main/java/io/reactivex/internal/util/ObservableQueueDrain.java
similarity index 96%
rename from src/main/java/io/reactivex/internal/util/NbpQueueDrain.java
rename to src/main/java/io/reactivex/internal/util/ObservableQueueDrain.java
index 27e8762914..428184befc 100644
--- a/src/main/java/io/reactivex/internal/util/NbpQueueDrain.java
+++ b/src/main/java/io/reactivex/internal/util/ObservableQueueDrain.java
@@ -15,7 +15,7 @@
 
 import io.reactivex.Observer;
 
-public interface NbpQueueDrain<T, U> {
+public interface ObservableQueueDrain<T, U> {
     
     boolean cancelled();
     
diff --git a/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
index 1ed4712020..a0e6d3149c 100644
--- a/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
+++ b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
@@ -183,7 +183,7 @@ private QueueDrainHelper() {
         return false;
     }
     
-    public static <T, U> void drainLoop(SimpleQueue<T> q, Observer<? super U> a, boolean delayError, Disposable dispose, NbpQueueDrain<T, U> qd) {
+    public static <T, U> void drainLoop(SimpleQueue<T> q, Observer<? super U> a, boolean delayError, Disposable dispose, ObservableQueueDrain<T, U> qd) {
         
         int missed = 1;
         
@@ -225,7 +225,7 @@ private QueueDrainHelper() {
     }
 
     public static <T, U> boolean checkTerminated(boolean d, boolean empty, 
-            Observer<?> s, boolean delayError, SimpleQueue<?> q, Disposable disposable, NbpQueueDrain<T, U> qd) {
+            Observer<?> s, boolean delayError, SimpleQueue<?> q, Disposable disposable, ObservableQueueDrain<T, U> qd) {
         if (qd.cancelled()) {
             q.clear();
             disposable.dispose();
diff --git a/src/main/java/io/reactivex/subjects/AsyncSubject.java b/src/main/java/io/reactivex/subjects/AsyncSubject.java
index dc3afb17e0..0473ab5e1e 100644
--- a/src/main/java/io/reactivex/subjects/AsyncSubject.java
+++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java
@@ -22,10 +22,10 @@
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
- * An NbpSubject that emits the very last value followed by a completion event or the received error to NbpSubscribers.
+ * An Subject that emits the very last value followed by a completion event or the received error to Observers.
  *
  * <p>The implementation of onXXX methods are technically thread-safe but non-serialized calls
- * to them may lead to undefined state in the currently subscribed NbpSubscribers.
+ * to them may lead to undefined state in the currently subscribed Observers.
  * 
  * @param <T> the value type
  */
diff --git a/src/main/java/io/reactivex/subjects/Subject.java b/src/main/java/io/reactivex/subjects/Subject.java
index 5b1e793d58..194a98ebb0 100644
--- a/src/main/java/io/reactivex/subjects/Subject.java
+++ b/src/main/java/io/reactivex/subjects/Subject.java
@@ -16,7 +16,7 @@
 import io.reactivex.*;
 
 /**
- * Represents a NbpSubscriber and a NbpObservable at the same time, allowing
+ * Represents an Observer and a Observable at the same time, allowing
  * multicasting events from a single source to multiple child Subscribers.
  * <p>All methods except the onSubscribe, onNext, onError and onComplete are thread-safe.
  * Use {@link #toSerialized()} to make these methods thread-safe as well.
diff --git a/src/perf/java/io/reactivex/RxVsStreamPerf.java b/src/perf/java/io/reactivex/RxVsStreamPerf.java
index 97b62e2e57..3801fec1e6 100644
--- a/src/perf/java/io/reactivex/RxVsStreamPerf.java
+++ b/src/perf/java/io/reactivex/RxVsStreamPerf.java
@@ -34,15 +34,15 @@
     
     Flowable<Integer> range;
     
-    Observable<Integer> rangeNbp;
+    Observable<Integer> rangeObservable;
 
     Flowable<Integer> rangeFlatMap;
 
-    Observable<Integer> rangeNbpFlatMap;
+    Observable<Integer> rangeObservableFlatMap;
 
     Flowable<Integer> rangeFlatMapJust;
 
-    Observable<Integer> rangeNbpFlatMapJust;
+    Observable<Integer> rangeObservableFlatMapJust;
 
     List<Integer> values;
 
@@ -64,16 +64,16 @@ public void setup() {
             }
         });
         
-        rangeNbp = Observable.range(1, times);
+        rangeObservable = Observable.range(1, times);
 
-        rangeNbpFlatMapJust = rangeNbp.flatMap(new Function<Integer, Observable<Integer>>() {
+        rangeObservableFlatMapJust = rangeObservable.flatMap(new Function<Integer, Observable<Integer>>() {
             @Override
             public Observable<Integer> apply(Integer v) {
                 return Observable.just(v);
             }
         });
         
-        rangeNbpFlatMap = rangeNbp.flatMap(new Function<Integer, Observable<Integer>>() {
+        rangeObservableFlatMap = rangeObservable.flatMap(new Function<Integer, Observable<Integer>>() {
             @Override
             public Observable<Integer> apply(Integer v) {
                 return Observable.range(v, 2);
@@ -89,8 +89,8 @@ public void range(Blackhole bh) {
     }
 
     @Benchmark
-    public void rangeNbp(Blackhole bh) {
-        rangeNbp.subscribe(new PerfObserver(bh));
+    public void rangeObservable(Blackhole bh) {
+        rangeObservable.subscribe(new PerfObserver(bh));
     }
 
     @Benchmark
@@ -99,8 +99,8 @@ public void rangeFlatMap(Blackhole bh) {
     }
 
     @Benchmark
-    public void rangeNbpFlatMap(Blackhole bh) {
-        rangeNbpFlatMap.subscribe(new PerfObserver(bh));
+    public void rangeObservableFlatMap(Blackhole bh) {
+        rangeObservableFlatMap.subscribe(new PerfObserver(bh));
     }
     
     @Benchmark
@@ -109,8 +109,8 @@ public void rangeFlatMapJust(Blackhole bh) {
     }
 
     @Benchmark
-    public void rangeNbpFlatMapJust(Blackhole bh) {
-        rangeNbpFlatMapJust.subscribe(new PerfObserver(bh));
+    public void rangeObservableFlatMapJust(Blackhole bh) {
+        rangeObservableFlatMapJust.subscribe(new PerfObserver(bh));
     }
 
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/completable/CompletableTest.java b/src/test/java/io/reactivex/completable/CompletableTest.java
index 147f64fd68..3c2b45ebba 100644
--- a/src/test/java/io/reactivex/completable/CompletableTest.java
+++ b/src/test/java/io/reactivex/completable/CompletableTest.java
@@ -578,19 +578,19 @@ public Throwable call() {
     }
     
     @Test(expected = NullPointerException.class)
-    public void fromNbpObservableNull() {
+    public void fromObservableNull() {
         Completable.fromObservable(null);
     }
     
     @Test(timeout = 1000)
-    public void fromNbpObservableEmpty() {
+    public void fromObservableEmpty() {
         Completable c = Completable.fromObservable(Observable.empty());
         
         c.blockingAwait();
     }
 
     @Test(timeout = 5000)
-    public void fromNbpObservableSome() {
+    public void fromObservableSome() {
         for (int n = 1; n < 10000; n *= 10) {
             Completable c = Completable.fromObservable(Observable.range(1, n));
             
@@ -599,7 +599,7 @@ public void fromNbpObservableSome() {
     }
     
     @Test(timeout = 1000, expected = TestException.class)
-    public void fromNbpObservableError() {
+    public void fromObservableError() {
         Completable c = Completable.fromObservable(Observable.error(new Callable<Throwable>() {
             @Override
             public Throwable call() {
@@ -2585,7 +2585,7 @@ public void run() { }
     }
     
     @Test(timeout = 1000)
-    public void subscribeNbpSubscriberNormal() {
+    public void subscribeObserverNormal() {
         TestObserver<Object> ts = new TestObserver<Object>();
         
         normal.completable.toObservable().subscribe(ts);
@@ -2596,7 +2596,7 @@ public void subscribeNbpSubscriberNormal() {
     }
 
     @Test(timeout = 1000)
-    public void subscribeNbpSubscriberError() {
+    public void subscribeObserverError() {
         TestObserver<Object> ts = new TestObserver<Object>();
         
         error.completable.toObservable().subscribe(ts);
@@ -2645,7 +2645,7 @@ public void subscribeSubscriberNull() {
     }
     
     @Test(expected = NullPointerException.class)
-    public void subscribeNbpSubscriberNull() {
+    public void subscribeObserverNull() {
         normal.completable.toObservable().subscribe((Observer<Object>)null);
     }
     
@@ -2799,12 +2799,12 @@ public void toFlowableError() {
     }
 
     @Test(timeout = 1000)
-    public void toNbpObservableNormal() {
+    public void toObservableNormal() {
         normal.completable.toObservable().blockingForEach(Functions.emptyConsumer());
     }
     
     @Test(timeout = 1000, expected = TestException.class)
-    public void toNbpObservableError() {
+    public void toObservableError() {
         error.completable.toObservable().blockingForEach(Functions.emptyConsumer());
     }
     
@@ -3354,7 +3354,7 @@ public void startWithFlowableError() {
     }
     
     @Test(timeout = 1000)
-    public void startWithNbpObservableNormal() {
+    public void startWithObservableNormal() {
         final AtomicBoolean run = new AtomicBoolean();
         Observable<Object> c = normal.completable
                 .startWith(Observable.fromCallable(new Callable<Object>() {
@@ -3378,7 +3378,7 @@ public Object call() throws Exception {
     }
     
     @Test(timeout = 1000)
-    public void startWithNbpObservableError() {
+    public void startWithObservableError() {
         Observable<Object> c = normal.completable
                 .startWith(Observable.error(new TestException()));
         
@@ -3404,7 +3404,7 @@ public void startWithFlowableNull() {
     }
 
     @Test(expected = NullPointerException.class)
-    public void startWithNbpObservableNull() {
+    public void startWithObservableNull() {
         normal.completable.startWith((Observable<Object>)null);
     }
 
@@ -3703,34 +3703,6 @@ public void andThenSingleSubscribeOn() {
         ts.assertNoErrors();
     }
     
-    @Test(expected = NullPointerException.class)
-    public void fromObservableNull() {
-        Completable.fromObservable(null);
-    }
-    
-    @Test(timeout = 5000)
-    public void fromObservableEmpty() {
-        Completable c = Completable.fromObservable(Observable.empty());
-        
-        c.blockingAwait();
-    }
-    
-    @Test(timeout = 5000)
-    public void fromObservableSome() {
-        for (int n = 1; n < 10000; n *= 10) {
-            Completable c = Completable.fromObservable(Observable.range(1, n));
-            
-            c.blockingAwait();
-        }
-    }
-    
-    @Test(timeout = 5000, expected = TestException.class)
-    public void fromObservableError() {
-        Completable c = Completable.fromObservable(Observable.error(new TestException()));
-        
-        c.blockingAwait();
-    }
-
     private Function<Completable, Completable> onCreate;
     
     private BiFunction<Completable, CompletableObserver, CompletableObserver> onStart;
@@ -3915,22 +3887,6 @@ public void run() {
         });
     }
     
-    @Test(timeout = 5000)
-    public void toObservableNormal() {
-        normal.completable.toObservable().blockingForEach(new Consumer<Object>() {
-            @Override
-            public void accept(Object e) { }
-        });
-    }
-    
-    @Test(timeout = 5000, expected = TestException.class)
-    public void toObservableError() {
-        error.completable.toObservable().blockingForEach(new Consumer<Object>() {
-            @Override
-            public void accept(Object e) { }
-        });
-    }
-    
     @Test(expected = NullPointerException.class)
     public void andThenCompletableNull() {
         normal.completable.andThen((Completable)null);
diff --git a/src/test/java/io/reactivex/flowable/FlowableBackpressureTests.java b/src/test/java/io/reactivex/flowable/FlowableBackpressureTests.java
index d42c0af4bb..37fa438e18 100644
--- a/src/test/java/io/reactivex/flowable/FlowableBackpressureTests.java
+++ b/src/test/java/io/reactivex/flowable/FlowableBackpressureTests.java
@@ -260,9 +260,9 @@ public void testFlatMapAsync() {
         ts.assertNoErrors();
         System.out.println("testFlatMapAsync => Received: " + ts.valueCount() + "  Emitted: " + c.get() + " Size: " + Flowable.bufferSize());
         assertEquals(NUM, ts.valueCount());
-        // even though we only need 10, it will request at least Observable.bufferSize(), and then as it drains keep requesting more
+        // even though we only need 10, it will request at least Flowable.bufferSize(), and then as it drains keep requesting more
         // and then it will be non-deterministic when the take() causes the unsubscribe as it is scheduled on 10 different schedulers (threads)
-        // normally this number is ~250 but can get up to ~1200 when Observable.bufferSize() == 1024
+        // normally this number is ~250 but can get up to ~1200 when Flowable.bufferSize() == 1024
         assertTrue(c.get() <= Flowable.bufferSize() * 2);
     }
 
diff --git a/src/test/java/io/reactivex/flowable/FlowableCollectTest.java b/src/test/java/io/reactivex/flowable/FlowableCollectTest.java
index 6ef997c1e7..e90d183546 100644
--- a/src/test/java/io/reactivex/flowable/FlowableCollectTest.java
+++ b/src/test/java/io/reactivex/flowable/FlowableCollectTest.java
@@ -13,17 +13,11 @@
 
 package io.reactivex.flowable;
 
-import static io.reactivex.internal.util.TestingHelper.addToList;
-import static io.reactivex.internal.util.TestingHelper.biConsumerThrows;
-import static io.reactivex.internal.util.TestingHelper.callableListCreator;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CopyOnWriteArrayList;
+import static io.reactivex.internal.util.TestingHelper.*;
+import static org.junit.Assert.*;
+
+import java.util.*;
+import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.junit.Test;
@@ -167,4 +161,19 @@ public void accept(Object o, Integer t) {
         assertFalse(added.get());
     }
 
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void collectInto() {
+        Flowable.just(1, 1, 1, 1, 2)
+        .collectInto(new HashSet<Integer>(), new BiConsumer<HashSet<Integer>, Integer>() {
+            @Override
+            public void accept(HashSet<Integer> s, Integer v) throws Exception {
+                s.add(v);
+            }
+        })
+        .test()
+        .assertResult(new HashSet<Integer>(Arrays.asList(1, 2)));
+    }
+
 }
diff --git a/src/test/java/io/reactivex/flowable/FlowableConcatTests.java b/src/test/java/io/reactivex/flowable/FlowableConcatTests.java
index c512056e79..c723cbd334 100644
--- a/src/test/java/io/reactivex/flowable/FlowableConcatTests.java
+++ b/src/test/java/io/reactivex/flowable/FlowableConcatTests.java
@@ -38,7 +38,7 @@ public void testConcatSimple() {
     }
 
     @Test
-    public void testConcatWithObservableOfObservable() {
+    public void testConcatWithFlowableOfFlowable() {
         Flowable<String> o1 = Flowable.just("one", "two");
         Flowable<String> o2 = Flowable.just("three", "four");
         Flowable<String> o3 = Flowable.just("five", "six");
@@ -56,7 +56,7 @@ public void testConcatWithObservableOfObservable() {
     }
 
     @Test
-    public void testConcatWithIterableOfObservable() {
+    public void testConcatWithIterableOfFlowable() {
         Flowable<String> o1 = Flowable.just("one", "two");
         Flowable<String> o2 = Flowable.just("three", "four");
         Flowable<String> o3 = Flowable.just("five", "six");
diff --git a/src/test/java/io/reactivex/flowable/FlowableDoOnTest.java b/src/test/java/io/reactivex/flowable/FlowableDoOnTest.java
index 674b7e9577..d3026ddeff 100644
--- a/src/test/java/io/reactivex/flowable/FlowableDoOnTest.java
+++ b/src/test/java/io/reactivex/flowable/FlowableDoOnTest.java
@@ -19,7 +19,8 @@
 
 import org.junit.Test;
 
-import io.reactivex.Flowable;
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 
 public class FlowableDoOnTest {
@@ -72,4 +73,33 @@ public void run() {
         assertEquals("one", output);
         assertTrue(r.get());
     }
+    
+    @Test
+    public void doOnTerminateError() {
+        final AtomicBoolean r = new AtomicBoolean();
+        Flowable.<String>error(new TestException()).doOnTerminate(new Action() {
+            @Override
+            public void run() {
+                r.set(true);
+            }
+        })
+        .test()
+        .assertFailure(TestException.class);
+        assertTrue(r.get());
+    }
+    
+    @Test
+    public void doOnTerminateComplete() {
+        final AtomicBoolean r = new AtomicBoolean();
+        String output = Flowable.just("one").doOnTerminate(new Action() {
+            @Override
+            public void run() {
+                r.set(true);
+            }
+        }).blockingSingle();
+
+        assertEquals("one", output);
+        assertTrue(r.get());
+        
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/flowable/FlowableNullTests.java b/src/test/java/io/reactivex/flowable/FlowableNullTests.java
index 1bb3302b48..fc149fdf96 100644
--- a/src/test/java/io/reactivex/flowable/FlowableNullTests.java
+++ b/src/test/java/io/reactivex/flowable/FlowableNullTests.java
@@ -603,7 +603,7 @@ public void usingResourceSupplierNull() {
     }
     
     @Test(expected = NullPointerException.class)
-    public void usingObservableSupplierNull() {
+    public void usingFlowableSupplierNull() {
         Flowable.using(new Callable<Object>() {
             @Override
             public Object call() {
@@ -613,7 +613,7 @@ public Object call() {
     }
     
     @Test(expected = NullPointerException.class)
-    public void usingObservableSupplierReturnsNull() {
+    public void usingFlowableSupplierReturnsNull() {
         Flowable.using(new Callable<Object>() {
             @Override
             public Object call() {
@@ -2803,5 +2803,183 @@ public void serializedSubjectOnErrorNull() {
         subject.onError(null);
         subject.blockingSubscribe();
     }
+    
+    @Test(expected = NullPointerException.class)
+    public void doOnLifecycleOnDisposeNull() {
+        just1.doOnLifecycle(new Consumer<Subscription>() {
+            @Override
+            public void accept(Subscription s) { }
+        },
+        new LongConsumer() {
+            @Override
+            public void accept(long v) throws Exception { }
+        },
+        null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void zipWithFlowableNull() {
+        just1.zipWith((Flowable<Integer>)null, new BiFunction<Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b) {
+                return 1;
+            }
+        });
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void unsafeSubscribeNull() {
+        just1.subscribe((Subscriber<Object>)null);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test(expected = NullPointerException.class)
+    public void combineLatestDelayErrorIterableFunctionReturnsNull() {
+        Flowable.combineLatestDelayError(Arrays.asList(just1), new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] v) {
+                return null;
+            }
+        }, 128).blockingLast();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test(expected = NullPointerException.class)
+    public void combineLatestDelayErrorIterableFunctionNull() {
+        Flowable.combineLatestDelayError(Arrays.asList(just1), null, 128);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test(expected = NullPointerException.class)
+    public void combineLatestDelayErrorVarargsFunctionNull() {
+        Flowable.combineLatestDelayError(null, 128, Flowable.never());
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void zipFlowableNull() {
+        Flowable.zip((Flowable<Flowable<Object>>)null, new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) {
+                return 1;
+            }
+        });
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void zipFlowableFunctionNull() {
+        Flowable.zip((Flowable.just(just1)), null);
+    }
 
+    @Test(expected = NullPointerException.class)
+    public void zipFlowableFunctionReturnsNull() {
+        Flowable.zip((Flowable.just(just1)), new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) {
+                return null;
+            }
+        }).blockingLast();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void concatFlowableNull() {
+        Flowable.concat((Flowable<Flowable<Object>>)null);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void combineLatestDelayErrorVarargsNull() {
+        Flowable.combineLatestDelayError(new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] v) {
+                return 1;
+            }
+        }, 128, (Flowable<Object>[])null);
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test(expected = NullPointerException.class)
+    public void combineLatestDelayErrorVarargsOneIsNull() {
+        Flowable.combineLatestDelayError(new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] v) {
+                return 1;
+            }
+        }, 128, Flowable.never(), null).blockingLast();
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void combineLatestDelayErrorIterableNull() {
+        Flowable.combineLatestDelayError((Iterable<Flowable<Object>>)null, new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] v) {
+                return 1;
+            }
+        }, 128);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void combineLatestDelayErrorIterableIteratorNull() {
+        Flowable.combineLatestDelayError(new Iterable<Flowable<Object>>() {
+            @Override
+            public Iterator<Flowable<Object>> iterator() {
+                return null;
+            }
+        }, new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] v) {
+                return 1;
+            }
+        }, 128).blockingLast();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void doOnDisposeNull() {
+        just1.doOnCancel(null);
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test(expected = NullPointerException.class)
+    public void combineLatestDelayErrorIterableOneIsNull() {
+        Flowable.combineLatestDelayError(Arrays.asList(Flowable.never(), null), new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] v) {
+                return 1;
+            }
+        }, 128).blockingLast();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void takeUntilFlowableNull() {
+        just1.takeUntil((Flowable<Integer>)null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void startWithFlowableNull() {
+        just1.startWith((Flowable<Integer>)null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void delaySubscriptionOtherNull() {
+        just1.delaySubscription((Flowable<Object>)null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void sampleFlowableNull() {
+        just1.sample(null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void onErrorResumeNextFlowableNull() {
+        just1.onErrorResumeNext((Flowable<Integer>)null);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test(expected = NullPointerException.class)
+    public void combineLatestDelayErrorVarargsFunctionReturnsNull() {
+        Flowable.combineLatestDelayError(new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] v) {
+                return null;
+            }
+        }, 128, just1).blockingLast();
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/flowable/FlowableStartWithTests.java b/src/test/java/io/reactivex/flowable/FlowableStartWithTests.java
index 1e69dbabf3..54911a245b 100644
--- a/src/test/java/io/reactivex/flowable/FlowableStartWithTests.java
+++ b/src/test/java/io/reactivex/flowable/FlowableStartWithTests.java
@@ -61,4 +61,9 @@ public void startWithObservable() {
         assertEquals("two", values.get(3));
     }
 
+    @Test
+    public void startWithEmpty() {
+        Flowable.just(1).startWithArray().test().assertResult(1);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java b/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
index 89eba5d179..33132eda7f 100644
--- a/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
+++ b/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
@@ -262,7 +262,7 @@ public void cancel() {
     }
 
     @Test
-    public void testRequestToObservable() {
+    public void testRequestToFlowable() {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
         ts.request(3);
         final AtomicLong requested = new AtomicLong();
@@ -731,4 +731,117 @@ public void run() throws Exception {
         }
     }
 
+    @Test
+    public void subscribeConsumerConsumerWithError() {
+        final List<Integer> list = new ArrayList<Integer>();
+        
+        Flowable.<Integer>error(new TestException()).subscribe(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        }, new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) throws Exception {
+                list.add(100);
+            }
+        });
+        
+        assertEquals(Arrays.asList(100), list);
+    }
+
+    @Test
+    public void methodTestCancelled() {
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+        
+        ps.test(Long.MAX_VALUE, true);
+        
+        assertFalse(ps.hasSubscribers());
+    }
+    
+    @Test
+    public void safeSubscriberAlreadySafe() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        Flowable.just(1).safeSubscribe(new SafeSubscriber<Integer>(ts));
+        
+        ts.assertResult(1);
+    }
+
+
+    @Test
+    public void methodTestNoCancel() {
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+        
+        ps.test(Long.MAX_VALUE, false);
+        
+        assertTrue(ps.hasSubscribers());
+    }
+    
+    @Test
+    public void subscribeConsumerConsumer() {
+        final List<Integer> list = new ArrayList<Integer>();
+        
+        Flowable.just(1).subscribe(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        }, new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) throws Exception {
+                list.add(100);
+            }
+        });
+        
+        assertEquals(Arrays.asList(1), list);
+    }
+
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void pluginNull() {
+        RxJavaPlugins.setOnFlowableSubscribe(new BiFunction<Flowable, Subscriber, Subscriber>() {
+            @Override
+            public Subscriber apply(Flowable a, Subscriber b) throws Exception {
+                return null;
+            }
+        });
+        
+        try {
+            try {
+                
+                Flowable.just(1).test();
+                fail("Should have thrown");
+            } catch (NullPointerException ex) {
+                assertEquals("Plugin returned null Subscriber", ex.getMessage());
+            }
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    static final class BadFlowable extends Flowable<Integer> {
+        @Override
+        protected void subscribeActual(Subscriber<? super Integer> s) {
+            throw new IllegalArgumentException();
+        }
+    }
+    
+    @Test
+    public void subscribeActualThrows() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        try {
+            try {
+                new BadFlowable().test();
+                fail("Should have thrown!");
+            } catch (NullPointerException ex) {
+                if (!(ex.getCause() instanceof IllegalArgumentException)) {
+                    fail(ex.toString() + ": Should be NPE(IAE)");
+                }
+            }
+            
+            TestHelper.assertError(list, 0, IllegalArgumentException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/flowable/FlowableTests.java b/src/test/java/io/reactivex/flowable/FlowableTests.java
index 7992cd0893..3073316993 100644
--- a/src/test/java/io/reactivex/flowable/FlowableTests.java
+++ b/src/test/java/io/reactivex/flowable/FlowableTests.java
@@ -26,8 +26,8 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.FlowableTransformer;
 import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.flowables.ConnectableFlowable;
 import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
@@ -1038,4 +1038,24 @@ public Object apply(Flowable<Object> onSubscribe) {
                 }
         });
     }
+    
+    @Test
+    public void toObservableEmpty() {
+        Flowable.empty().toObservable().test().assertResult();
+    }
+
+    @Test
+    public void toObservableJust() {
+        Flowable.just(1).toObservable().test().assertResult(1);
+    }
+    
+    @Test
+    public void toObservableRange() {
+        Flowable.range(1, 5).toObservable().test().assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void toObservableError() {
+        Flowable.error(new TestException()).toObservable().test().assertFailure(TestException.class);
+    }
 }
diff --git a/src/test/java/io/reactivex/flowable/FlowableThrottleWithTimeoutTests.java b/src/test/java/io/reactivex/flowable/FlowableThrottleWithTimeoutTests.java
index df11e6b7be..6a2065b7ea 100644
--- a/src/test/java/io/reactivex/flowable/FlowableThrottleWithTimeoutTests.java
+++ b/src/test/java/io/reactivex/flowable/FlowableThrottleWithTimeoutTests.java
@@ -21,7 +21,7 @@
 import org.mockito.InOrder;
 import org.reactivestreams.Subscriber;
 
-import io.reactivex.TestHelper;
+import io.reactivex.*;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.TestScheduler;
 
@@ -59,4 +59,12 @@ public void testThrottle() {
         inOrder.verify(observer).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
+
+    @Test
+    public void throttleFirstDefaultScheduler() {
+        Flowable.just(1).throttleWithTimeout(100, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/flowable/FlowableZipTests.java b/src/test/java/io/reactivex/flowable/FlowableZipTests.java
index 702531279f..8d8dfde4cd 100644
--- a/src/test/java/io/reactivex/flowable/FlowableZipTests.java
+++ b/src/test/java/io/reactivex/flowable/FlowableZipTests.java
@@ -124,4 +124,31 @@ public void accept(ExtendedResult t1) {
             System.out.println("Result: " + t1);
         }
     };
+
+    
+    @Test
+    public void zipWithDelayError() {
+        Flowable.just(1)
+        .zipWith(Flowable.just(2), new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }, true)
+        .test()
+        .assertResult(3);
+    }
+    
+    @Test
+    public void zipWithDelayErrorBufferSize() {
+        Flowable.just(1)
+        .zipWith(Flowable.just(2), new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }, true, 16)
+        .test()
+        .assertResult(3);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableAmbTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableAmbTest.java
index 3be1f7c83e..96f1dd2e73 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableAmbTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableAmbTest.java
@@ -519,4 +519,17 @@ public void ambManyComplete() throws Exception {
             }
         }
     }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void ambArrayEmpty() {
+        assertSame(Flowable.empty(), Flowable.ambArray());
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void ambArraySingleElement() {
+        assertSame(Flowable.never(), Flowable.ambArray(Flowable.never()));
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
index 15b9768647..797a1d6ad7 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
@@ -157,7 +157,7 @@ public void subscribe(Subscriber<? super String> observer) {
                 push(observer, "two", 98);
                 /**
                  * Changed from 100. Because scheduling the cut to 100ms happens before this
-                 * Observable even runs due how lift works, pushing at 100ms would execute after the
+                 * Flowable even runs due how lift works, pushing at 100ms would execute after the
                  * buffer cut.
                  */
                 push(observer, "three", 99);
@@ -1268,4 +1268,53 @@ public Scheduler apply(Scheduler t) {
             RxJavaPlugins.reset();
         }
     }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void bufferBoundaryHint() {
+        Flowable.range(1, 5).buffer(Flowable.timer(1, TimeUnit.MINUTES), 2)
+        .test()
+        .assertResult(Arrays.asList(1, 2, 3, 4, 5));
+    }
+
+    static HashSet<Integer> set(Integer... values) {
+        return new HashSet<Integer>(Arrays.asList(values));
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void bufferIntoCustomCollection() {
+        Flowable.just(1, 1, 2, 2, 3, 3, 4, 4)
+        .buffer(3, new Callable<Collection<Integer>>() {
+            @Override
+            public Collection<Integer> call() throws Exception {
+                return new HashSet<Integer>();
+            }
+        })
+        .test()
+        .assertResult(set(1, 2), set(2, 3), set(4));
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void bufferSkipIntoCustomCollection() {
+        Flowable.just(1, 1, 2, 2, 3, 3, 4, 4)
+        .buffer(3, 3, new Callable<Collection<Integer>>() {
+            @Override
+            public Collection<Integer> call() throws Exception {
+                return new HashSet<Integer>();
+            }
+        })
+        .test()
+        .assertResult(set(1, 2), set(2, 3), set(4));
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void bufferTimeSkipDefault() {
+        Flowable.range(1, 5).buffer(1, 1, TimeUnit.MINUTES)
+        .test()
+        .assertResult(Arrays.asList(1, 2, 3, 4, 5));
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
index 3d28aee953..de9f5b9904 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java
@@ -17,17 +17,21 @@
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
 
+import java.lang.reflect.*;
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;
 
 import org.junit.*;
 import org.mockito.*;
-import org.reactivestreams.Subscriber;
+import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.internal.operators.flowable.FlowableZipTest.ArgsToString;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
@@ -1047,4 +1051,169 @@ public Integer apply(Object[] args) {
         ts.assertError(CompositeException.class);
         ts.assertNotComplete();
     }
+    
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void combineLatestNArguments() throws Exception {
+        Flowable source = Flowable.just(1);
+        
+        for (int i = 2; i < 10; i++) {
+            Class<?>[] types = new Class[i + 1];
+            Arrays.fill(types, Publisher.class);
+            types[i] = i == 2 ? BiFunction.class : Class.forName("io.reactivex.functions.Function" + i);
+            
+            Method m = Flowable.class.getMethod("combineLatest", types);
+            
+            Object[] params = new Object[i + 1];
+            Arrays.fill(params, source);
+            params[i] = ArgsToString.INSTANCE;
+            
+            StringBuilder b = new StringBuilder();
+            for (int j = 0; j < i; j++) {
+                b.append('1');
+            }
+            
+            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());
+            
+            for (int j = 0; j < params.length; j++) {
+                Object[] params0 = params.clone();
+                params0[j] = null;
+                
+                try {
+                    m.invoke(null, params0);
+                    fail("Should have thrown @ " + m);
+                } catch (InvocationTargetException ex) {
+                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);
+                    
+                    if (j < i) {
+                        assertEquals("source" + (j + 1) + " is null", ex.getCause().getMessage());
+                    } else {
+                        assertEquals("f is null", ex.getCause().getMessage());
+                    }
+                }
+            }
+        }
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void combineLatestNSources() {
+        for (int i = 1; i < 100; i++) {
+            Flowable<Integer>[] sources = new Flowable[i];
+            Arrays.fill(sources, Flowable.just(1));
+            List<Object> expected = new ArrayList<Object>(i);
+            for (int j = 1; j <= i; j++) {
+                expected.add(1);
+            }
+            
+            Flowable.combineLatest(sources, new Function<Object[], List<Object>>() {
+                @Override
+                public List<Object> apply(Object[] t) throws Exception {
+                    return Arrays.asList(t);
+                }
+            })
+            .test()
+            .assertResult(expected);
+            
+            Flowable.combineLatestDelayError(sources, new Function<Object[], List<Object>>() {
+                @Override
+                public List<Object> apply(Object[] t) throws Exception {
+                    return Arrays.asList(t);
+                }
+            })
+            .test()
+            .assertResult(expected);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void combineLatestArrayOfSources() {
+        
+        Flowable.combineLatest(new Flowable[] {
+                Flowable.just(1), Flowable.just(2)
+        }, new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return Arrays.toString(a);
+            }
+        })
+        .test()
+        .assertResult("[1, 2]");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void combineLatestDelayErrorArrayOfSources() {
+        
+        Flowable.combineLatestDelayError(new Flowable[] {
+                Flowable.just(1), Flowable.just(2)
+        }, new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return Arrays.toString(a);
+            }
+        })
+        .test()
+        .assertResult("[1, 2]");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void combineLatestDelayErrorArrayOfSourcesWithError() {
+        
+        Flowable.combineLatestDelayError(new Flowable[] {
+                Flowable.just(1), Flowable.just(2).concatWith(Flowable.<Integer>error(new TestException()))
+        }, new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return Arrays.toString(a);
+            }
+        })
+        .test()
+        .assertFailure(TestException.class, "[1, 2]");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void combineLatestDelayErrorIterableOfSources() {
+        
+        Flowable.combineLatestDelayError(Arrays.asList(
+                Flowable.just(1), Flowable.just(2)
+        ), new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return Arrays.toString(a);
+            }
+        })
+        .test()
+        .assertResult("[1, 2]");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void combineLatestDelayErrorIterableOfSourcesWithError() {
+        
+        Flowable.combineLatestDelayError(Arrays.asList(
+                Flowable.just(1), Flowable.just(2).concatWith(Flowable.<Integer>error(new TestException()))
+        ), new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return Arrays.toString(a);
+            }
+        })
+        .test()
+        .assertFailure(TestException.class, "[1, 2]");
+    }
+    @SuppressWarnings("unchecked")
+    @Test
+    public void combineLatestEmpty() {
+        assertSame(Flowable.empty(), Flowable.combineLatest(new Flowable[0], Functions.<Object[]>identity(), 16));
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void combineLatestDelayErrorEmpty() {
+        assertSame(Flowable.empty(), Flowable.combineLatestDelayError(new Flowable[0], Functions.<Object[]>identity(), 16));
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
index 01ab2d07dc..817403ee2b 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
@@ -761,4 +761,60 @@ public void mappingBadCapacityHint() throws Exception {
         }
         
     }
+    
+    @Test
+    public void concatEagerZero() {
+        Flowable.concatEager(Collections.<Flowable<Integer>>emptyList())
+        .test()
+        .assertResult();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatEagerOne() {
+        Flowable.concatEager(Arrays.asList(Flowable.just(1)))
+        .test()
+        .assertResult(1);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatEagerTwo() {
+        Flowable.concatEager(Arrays.asList(Flowable.just(1), Flowable.just(2)))
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void Flowable() {
+        Flowable<Integer> source = Flowable.just(1);
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        Flowable.concatEager(Flowable.just(source, source, source)).subscribe(ts);
+        
+        ts.assertValues(1, 1, 1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @Test
+    public void ObservableCapacityHint() {
+        Flowable<Integer> source = Flowable.just(1);
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        Flowable.concatEager(Flowable.just(source, source, source), 1, 1).subscribe(ts);
+        
+        ts.assertValues(1, 1, 1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatEagerIterable() {
+        Flowable.concatEager(Arrays.asList(Flowable.just(1), Flowable.just(2)))
+        .test()
+        .assertResult(1, 2);
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
index d56353e1ea..0c69afcd67 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
@@ -27,6 +27,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Function;
@@ -141,7 +142,7 @@ public void testNestedAsyncConcatLoop() throws Throwable {
     }
     
     /**
-     * Test an async Observable that emits more async Observables
+     * Test an async Flowable that emits more async Observables
      * @throws InterruptedException if the test is interrupted
      */
     @Test
@@ -203,7 +204,7 @@ public void run() {
                         } catch (Throwable e) {
                             observer.onError(e);
                         } finally {
-                            System.out.println("Done parent Observable");
+                            System.out.println("Done parent Flowable");
                             observer.onComplete();
                             parentHasFinished.countDown();
                         }
@@ -394,7 +395,7 @@ public void subscribe(Subscriber<? super Flowable<String>> observer) {
     }
 
     /**
-     * Test unsubscribing the concatenated Observable in a single thread.
+     * Test unsubscribing the concatenated Flowable in a single thread.
      */
     @Test
     public void testConcatUnsubscribe() {
@@ -682,7 +683,7 @@ public void testInnerBackpressureWithAlignedBoundaries() {
 
     /*
      * Testing without counts aligned with buffer sizes because concat must prevent the subscription
-     * to the next Observable if request == 0 which can happen at the end of a subscription
+     * to the next Flowable if request == 0 which can happen at the end of a subscription
      * if the request size == emitted size. It needs to delay subscription until the next request when aligned, 
      * when not aligned, it just subscribesNext with the outstanding request amount.
      */
@@ -1038,4 +1039,205 @@ public void veryLongTake() {
         .test()
         .assertResult(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
     }
+    
+    @Test
+    public void concat3() {
+        Flowable<Integer> source = Flowable.just(1);
+        
+        Flowable.concat(source, source, source)
+        .test()
+        .assertResult(1, 1, 1);
+    }
+
+    @Test
+    public void concat4() {
+        Flowable<Integer> source = Flowable.just(1);
+        
+        Flowable.concat(source, source, source, source)
+        .test()
+        .assertResult(1, 1, 1, 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatArrayDelayError() {
+        Flowable.concatArrayDelayError(Flowable.just(1), Flowable.just(2), 
+                Flowable.just(3), Flowable.just(4))
+        .test()
+        .assertResult(1, 2, 3, 4);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatArrayDelayErrorWithError() {
+        Flowable.concatArrayDelayError(Flowable.just(1), Flowable.just(2), 
+                Flowable.just(3).concatWith(Flowable.<Integer>error(new TestException())), 
+                Flowable.just(4))
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3, 4);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatIterableDelayError() {
+        Flowable.concatDelayError(
+                Arrays.asList(Flowable.just(1), Flowable.just(2), 
+                Flowable.just(3), Flowable.just(4)))
+        .test()
+        .assertResult(1, 2, 3, 4);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatIterableDelayErrorWithError() {
+        Flowable.concatDelayError(
+                Arrays.asList(Flowable.just(1), Flowable.just(2), 
+                Flowable.just(3).concatWith(Flowable.<Integer>error(new TestException())), 
+                Flowable.just(4)))
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3, 4);
+    }
+
+    @Test
+    public void concatObservableDelayError() {
+        Flowable.concatDelayError(
+                Flowable.just(Flowable.just(1), Flowable.just(2), 
+                Flowable.just(3), Flowable.just(4)))
+        .test()
+        .assertResult(1, 2, 3, 4);
+    }
+
+    @Test
+    public void concatObservableDelayErrorWithError() {
+        Flowable.concatDelayError(
+                Flowable.just(Flowable.just(1), Flowable.just(2), 
+                Flowable.just(3).concatWith(Flowable.<Integer>error(new TestException())), 
+                Flowable.just(4)))
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3, 4);
+    }
+
+    @Test
+    public void concatObservableDelayErrorBoundary() {
+        Flowable.concatDelayError(
+                Flowable.just(Flowable.just(1), Flowable.just(2), 
+                Flowable.just(3).concatWith(Flowable.<Integer>error(new TestException())), 
+                Flowable.just(4)), 2, false)
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3);
+    }
+
+    @Test
+    public void concatObservableDelayErrorTillEnd() {
+        Flowable.concatDelayError(
+                Flowable.just(Flowable.just(1), Flowable.just(2), 
+                Flowable.just(3).concatWith(Flowable.<Integer>error(new TestException())), 
+                Flowable.just(4)), 2, true)
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3, 4);
+    }
+
+    @Test
+    public void concatMapDelayError() {
+        Flowable.just(Flowable.just(1), Flowable.just(2))
+        .concatMapDelayError(Functions.<Flowable<Integer>>identity())
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void concatMapDelayErrorWithError() {
+        Flowable.just(Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException())), Flowable.just(2))
+        .concatMapDelayError(Functions.<Flowable<Integer>>identity())
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+    
+    @Test
+    public void concatMapIterableBufferSize() {
+        
+        Flowable.just(1, 2).concatMapIterable(new Function<Integer, Iterable<Integer>>() {
+            @Override
+            public Iterable<Integer> apply(Integer v) throws Exception {
+                return Arrays.asList(1, 2, 3, 4, 5);
+            }
+        }, 1)
+        .test()
+        .assertResult(1, 2, 3, 4, 5, 1, 2, 3, 4, 5);
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void emptyArray() {
+        assertSame(Flowable.empty(), Flowable.concatArrayDelayError());
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void singleElementArray() {
+        assertSame(Flowable.never(), Flowable.concatArrayDelayError(Flowable.never()));
+    }
+    
+    @Test
+    public void concatMapDelayErrorEmptySource() {
+        assertSame(Flowable.empty(), Flowable.<Object>empty()
+                .concatMapDelayError(new Function<Object, Flowable<Integer>>() {
+                    @Override
+                    public Flowable<Integer> apply(Object v) throws Exception {
+                        return Flowable.just(1);
+                    }
+                }, 16, true));
+    }
+
+    @Test
+    public void concatMapDelayErrorJustSource() {
+        Flowable.just(0)
+        .concatMapDelayError(new Function<Object, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Object v) throws Exception {
+                return Flowable.just(1);
+            }
+        }, 16, true)
+        .test()
+        .assertResult(1);
+    
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatArrayEmpty() {
+        assertSame(Flowable.empty(), Flowable.concatArray());
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatArraySingleElement() {
+        assertSame(Flowable.never(), Flowable.concatArray(Flowable.never()));
+    }
+
+    @Test
+    public void concatMapErrorEmptySource() {
+        assertSame(Flowable.empty(), Flowable.<Object>empty()
+                .concatMap(new Function<Object, Flowable<Integer>>() {
+                    @Override
+                    public Flowable<Integer> apply(Object v) throws Exception {
+                        return Flowable.just(1);
+                    }
+                }, 16));
+    }
+
+    @Test
+    public void concatMapJustSource() {
+        Flowable.just(0)
+        .concatMap(new Function<Object, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Object v) throws Exception {
+                return Flowable.just(1);
+            }
+        }, 16)
+        .test()
+        .assertResult(1);
+    
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCreateTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCreateTest.java
new file mode 100644
index 0000000000..d36b610be4
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCreateTest.java
@@ -0,0 +1,184 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.flowable;
+
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+
+public class FlowableCreateTest {
+
+    @Test(expected = NullPointerException.class)
+    public void sourceNull() {
+        Flowable.create(null, FlowableEmitter.BackpressureMode.BUFFER);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void modeNull() {
+        Flowable.create(new FlowableOnSubscribe<Object>() {
+            @Override
+            public void subscribe(FlowableEmitter<Object> s) throws Exception { }
+        }, null);
+    }
+
+    @Test
+    public void basic() {
+        final Disposable d = Disposables.empty();
+        
+        Flowable.<Integer>create(new FlowableOnSubscribe<Integer>() {
+            @Override
+            public void subscribe(FlowableEmitter<Integer> e) throws Exception {
+                e.setDisposable(d);
+                
+                e.onNext(1);
+                e.onNext(2);
+                e.onNext(3);
+                e.onComplete();
+                e.onError(new TestException());
+                e.onNext(4);
+                e.onError(new TestException());
+                e.onComplete();
+            }
+        }, FlowableEmitter.BackpressureMode.BUFFER)
+        .test()
+        .assertResult(1, 2, 3);
+        
+        assertTrue(d.isDisposed());
+    }
+    
+    @Test
+    public void basicWithError() {
+        final Disposable d = Disposables.empty();
+        
+        Flowable.<Integer>create(new FlowableOnSubscribe<Integer>() {
+            @Override
+            public void subscribe(FlowableEmitter<Integer> e) throws Exception {
+                e.setDisposable(d);
+                
+                e.onNext(1);
+                e.onNext(2);
+                e.onNext(3);
+                e.onError(new TestException());
+                e.onComplete();
+                e.onNext(4);
+                e.onError(new TestException());
+            }
+        }, FlowableEmitter.BackpressureMode.BUFFER)
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3);
+        
+        assertTrue(d.isDisposed());
+    }
+    
+    @Test
+    public void basicSerialized() {
+        final Disposable d = Disposables.empty();
+        
+        Flowable.<Integer>create(new FlowableOnSubscribe<Integer>() {
+            @Override
+            public void subscribe(FlowableEmitter<Integer> e) throws Exception {
+                e = e.serialize();
+                
+                e.setDisposable(d);
+                
+                e.onNext(1);
+                e.onNext(2);
+                e.onNext(3);
+                e.onComplete();
+                e.onError(new TestException());
+                e.onNext(4);
+                e.onError(new TestException());
+                e.onComplete();
+            }
+        }, FlowableEmitter.BackpressureMode.BUFFER)
+        .test()
+        .assertResult(1, 2, 3);
+        
+        assertTrue(d.isDisposed());
+    }
+    
+    @Test
+    public void basicWithErrorSerialized() {
+        final Disposable d = Disposables.empty();
+        
+        Flowable.<Integer>create(new FlowableOnSubscribe<Integer>() {
+            @Override
+            public void subscribe(FlowableEmitter<Integer> e) throws Exception {
+                e = e.serialize();
+
+                e.setDisposable(d);
+                
+                e.onNext(1);
+                e.onNext(2);
+                e.onNext(3);
+                e.onError(new TestException());
+                e.onComplete();
+                e.onNext(4);
+                e.onError(new TestException());
+            }
+        }, FlowableEmitter.BackpressureMode.BUFFER)
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3);
+        
+        assertTrue(d.isDisposed());
+    }
+
+    @Test
+    public void wrap() {
+        Flowable.fromPublisher(new Publisher<Integer>() {
+            @Override
+            public void subscribe(Subscriber<? super Integer> observer) {
+                observer.onSubscribe(new BooleanSubscription());
+                observer.onNext(1);
+                observer.onNext(2);
+                observer.onNext(3);
+                observer.onNext(4);
+                observer.onNext(5);
+                observer.onComplete();
+            }
+        })
+        .test()
+        .assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void unsafe() {
+        Flowable.unsafeCreate(new Publisher<Integer>() {
+            @Override
+            public void subscribe(Subscriber<? super Integer> observer) {
+                observer.onSubscribe(new BooleanSubscription());
+                observer.onNext(1);
+                observer.onNext(2);
+                observer.onNext(3);
+                observer.onNext(4);
+                observer.onNext(5);
+                observer.onComplete();
+            }
+        })
+        .test()
+        .assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void unsafeWithFlowable() {
+        Flowable.unsafeCreate(Flowable.just(1));
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
index cb67934b62..5982612178 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
@@ -304,4 +304,13 @@ public void debounceDefaultScheduler() throws Exception {
         ts.assertNoErrors();
         ts.assertComplete();
     }
+    
+    @Test
+    public void debounceDefault() throws Exception {
+        
+        Flowable.just(1).debounce(1, TimeUnit.SECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java
index cec4bf5bba..0984a3888b 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java
@@ -885,4 +885,30 @@ public void accept(Object o) {
 
         Assert.assertFalse(subscribed.get());
     }
+
+    @Test
+    public void delayWithTimeDelayError() throws Exception {
+        Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
+        .delay(100, TimeUnit.MILLISECONDS, true)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class, 1);
+    }
+    
+    @Test
+    public void testDelaySubscriptionDisposeBeforeTime() {
+        Flowable<Integer> result = Flowable.just(1, 2, 3).delaySubscription(100, TimeUnit.MILLISECONDS, scheduler);
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        TestSubscriber<Object> ts = new TestSubscriber<Object>(o);
+
+        result.subscribe(ts);
+        ts.dispose();
+        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);
+
+        verify(o, never()).onNext(any());
+        verify(o, never()).onComplete();
+        verify(o, never()).onError(any(Throwable.class));
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java
index 66a5aab611..a3dc66b658 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java
@@ -13,7 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
@@ -25,6 +25,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.processors.PublishProcessor;
@@ -678,4 +679,69 @@ public Integer apply(Integer t1, Integer t2) {
         
         ts.assertError(TestException.class);
     }
+    
+    @Test
+    public void flatMapBiMapper() {
+        Flowable.just(1)
+        .flatMap(new Function<Integer, Publisher<Integer>>() {
+            @Override
+            public Publisher<Integer> apply(Integer v) throws Exception {
+                return Flowable.just(v * 10);
+            }
+        }, new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }, true)
+        .test()
+        .assertResult(11);
+    }
+
+    @Test
+    public void flatMapBiMapperWithError() {
+        Flowable.just(1)
+        .flatMap(new Function<Integer, Publisher<Integer>>() {
+            @Override
+            public Publisher<Integer> apply(Integer v) throws Exception {
+                return Flowable.just(v * 10).concatWith(Flowable.<Integer>error(new TestException()));
+            }
+        }, new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }, true)
+        .test()
+        .assertFailure(TestException.class, 11);
+    }
+
+    @Test
+    public void flatMapBiMapperMaxConcurrency() {
+        Flowable.just(1, 2)
+        .flatMap(new Function<Integer, Publisher<Integer>>() {
+            @Override
+            public Publisher<Integer> apply(Integer v) throws Exception {
+                return Flowable.just(v * 10);
+            }
+        }, new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }, true, 1)
+        .test()
+        .assertResult(11, 22);
+    }
+
+    @Test
+    public void flatMapEmpty() {
+        assertSame(Flowable.empty(), Flowable.empty().flatMap(new Function<Object, Publisher<Object>>() {
+            @Override
+            public Publisher<Object> apply(Object v) throws Exception {
+                return Flowable.just(v);
+            }
+        }));
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableForEachTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableForEachTest.java
new file mode 100644
index 0000000000..5a9a3bc069
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableForEachTest.java
@@ -0,0 +1,75 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.flowable;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.*;
+
+import org.junit.Test;
+
+import io.reactivex.Flowable;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.*;
+
+public class FlowableForEachTest {
+
+    @Test
+    public void forEachWile() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        Flowable.range(1, 5)
+        .doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        })
+        .forEachWhile(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) throws Exception {
+                return v < 3;
+            }
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3), list);
+    }
+
+    @Test
+    public void forEachWileWithError() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        Flowable.range(1, 5).concatWith(Flowable.<Integer>error(new TestException()))
+        .doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        })
+        .forEachWhile(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) throws Exception {
+                return true;
+            }
+        }, new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) throws Exception {
+                list.add(100);
+            }
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 100), list);
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromArrayTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromArrayTest.java
index c12ee66ed8..f269aefd24 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromArrayTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromArrayTest.java
@@ -76,4 +76,10 @@ public void just() {
         Assert.assertTrue(source.getClass().toString(), source instanceof ScalarCallable);
     }
 
+    @Test
+    public void just10Arguments() {
+        Flowable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
+        .test()
+        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromIterableTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromIterableTest.java
index 0272e2ece4..346e09148d 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromIterableTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromIterableTest.java
@@ -27,6 +27,7 @@
 
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.Function;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
 
@@ -543,4 +544,21 @@ public void remove() {
         ts.assertNotComplete();
         
     }
+
+    @Test
+    public void fusionWithConcatMap() {
+        TestSubscriber<Integer> to = new TestSubscriber<Integer>();
+        
+        Flowable.fromIterable(Arrays.asList(1, 2, 3, 4)).concatMap(
+        new Function<Integer, Flowable  <Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer v) {
+                return Flowable.range(v, 2);
+            }
+        }).subscribe(to);
+        
+        to.assertValues(1, 2, 2, 3, 3, 4, 4, 5);
+        to.assertNoErrors();
+        to.assertComplete();
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableGenerateTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGenerateTest.java
new file mode 100644
index 0000000000..7a744a8a74
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGenerateTest.java
@@ -0,0 +1,47 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.flowable;
+
+import java.util.concurrent.Callable;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.functions.*;
+
+public class FlowableGenerateTest {
+
+    @Test
+    public void statefulBiconsumer() {
+        Flowable.generate(new Callable<Object>() {
+            @Override
+            public Object call() throws Exception {
+                return 10;
+            }
+        }, new BiConsumer<Object, Emitter<Object>>() {
+            @Override
+            public void accept(Object s, Emitter<Object> e) throws Exception {
+                e.onNext(s);
+            }
+        }, new Consumer<Object>() {
+            @Override
+            public void accept(Object d) throws Exception { 
+                
+            }
+        })
+        .take(5)
+        .test()
+        .assertResult(10, 10, 10, 10, 10);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java
index dcaf06545b..ee9e60e88f 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java
@@ -29,6 +29,7 @@
 import io.reactivex.exceptions.TestException;
 import io.reactivex.flowables.GroupedFlowable;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.fuseable.QueueSubscription;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.schedulers.Schedulers;
@@ -1631,4 +1632,34 @@ public void accept(GroupedFlowable<Integer, Integer> g) {
         .assertNoErrors()
         .assertComplete();
     }
+    
+    
+    @Test
+    public void keySelectorAndDelayError() {
+        Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
+        .groupBy(Functions.identity(), true)
+        .flatMap(new Function<GroupedFlowable<Object, Integer>, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(GroupedFlowable<Object, Integer> g) throws Exception {
+                return g;
+            }
+        })
+        .test()
+        .assertFailure(TestException.class, 1);
+    }
+
+    @Test
+    public void keyAndValueSelectorAndDelayError() {
+        Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
+        .groupBy(Functions.identity(), Functions.<Integer>identity(), true)
+        .flatMap(new Function<GroupedFlowable<Object, Integer>, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(GroupedFlowable<Object, Integer> g) throws Exception {
+                return g;
+            }
+        })
+        .test()
+        .assertFailure(TestException.class, 1);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableIntervalRangeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIntervalRangeTest.java
new file mode 100644
index 0000000000..24a28f55b4
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIntervalRangeTest.java
@@ -0,0 +1,76 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.reactivex.internal.operators.flowable;
+
+import static org.junit.Assert.*;
+
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.schedulers.Schedulers;
+
+public class FlowableIntervalRangeTest {
+    @Test
+    public void simple() throws Exception {
+        Flowable.intervalRange(5, 5, 50, 50, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(5L, 6L, 7L, 8L, 9L);
+    }
+
+    @Test
+    public void customScheduler() {
+        Flowable.intervalRange(1, 5, 1, 1, TimeUnit.MILLISECONDS, Schedulers.single())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1L, 2L, 3L, 4L, 5L);
+    }
+    
+    @Test
+    public void countZero() {
+        Flowable.intervalRange(1, 0, 1, 1, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult();
+    }    
+
+    @Test
+    public void countNegative() {
+        try {
+            Flowable.intervalRange(1, -1, 1, 1, TimeUnit.MILLISECONDS);
+            fail("Should have thrown!");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("count >= 0 required but it was -1", ex.getMessage());
+        }
+    }
+    
+    @Test
+    public void longOverflow() {
+        Flowable.intervalRange(Long.MAX_VALUE - 1, 2, 1, 1, TimeUnit.MILLISECONDS);
+
+        Flowable.intervalRange(Long.MIN_VALUE, Long.MAX_VALUE, 1, 1, TimeUnit.MILLISECONDS);
+
+        try {
+            Flowable.intervalRange(Long.MAX_VALUE - 1, 3, 1, 1, TimeUnit.MILLISECONDS);
+            fail("Should have thrown!");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("Overflow! start + count is bigger than Long.MAX_VALUE", ex.getMessage());
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java
index ebc2bdb1b4..2e0638c03f 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java
@@ -26,6 +26,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.LongConsumer;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
@@ -719,4 +720,126 @@ public void mergeManyError() throws Exception {
         }
     }
 
+    @Test
+    public void array() {
+        for (int i = 1; i < 100; i++) {
+            
+            @SuppressWarnings("unchecked")
+            Flowable<Integer>[] sources = new Flowable[i];
+            Arrays.fill(sources, Flowable.just(1));
+            Integer[] expected = new Integer[i];
+            for (int j = 0; j < i; j++) {
+                expected[j] = 1;
+            }
+
+            Flowable.mergeArrayDelayError(sources)
+            .test()
+            .assertResult(expected);
+        }
+    }
+
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeArrayDelayError() {
+        Flowable.mergeArrayDelayError(Flowable.just(1), Flowable.just(2))
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeIterableDelayErrorWithError() {
+        Flowable.mergeDelayError(
+                Arrays.asList(Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException())), 
+                Flowable.just(2)))
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
+    @Test
+    public void mergeDelayError() {
+        Flowable.mergeDelayError(
+                Flowable.just(Flowable.just(1), 
+                Flowable.just(2)))
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void mergeDelayErrorWithError() {
+        Flowable.mergeDelayError(
+                Flowable.just(Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException())), 
+                Flowable.just(2)))
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
+    @Test
+    public void mergeDelayErrorMaxConcurrency() {
+        Flowable.mergeDelayError(
+                Flowable.just(Flowable.just(1), 
+                Flowable.just(2)), 1)
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void mergeDelayErrorWithErrorMaxConcurrency() {
+        Flowable.mergeDelayError(
+                Flowable.just(Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException())), 
+                Flowable.just(2)), 1)
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeIterableDelayErrorMaxConcurrency() {
+        Flowable.mergeDelayError(
+                Arrays.asList(Flowable.just(1), 
+                Flowable.just(2)), 1)
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeIterableDelayErrorWithErrorMaxConcurrency() {
+        Flowable.mergeDelayError(
+                Arrays.asList(Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException())), 
+                Flowable.just(2)), 1)
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
+    @Test
+    public void mergeDelayError3() {
+        Flowable.mergeDelayError(
+                Flowable.just(1), 
+                Flowable.just(2),
+                Flowable.just(3)
+        )
+        .test()
+        .assertResult(1, 2, 3);
+    }
+
+    @Test
+    public void mergeDelayError3WithError() {
+        Flowable.mergeDelayError(
+                Flowable.just(1), 
+                Flowable.just(2).concatWith(Flowable.<Integer>error(new TestException())),
+                Flowable.just(3)
+        )
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeIterableDelayError() {
+        Flowable.mergeDelayError(Arrays.asList(Flowable.just(1), Flowable.just(2)))
+        .test()
+        .assertResult(1, 2);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
index 683bd82d44..112c5d1624 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
@@ -27,6 +27,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
@@ -1594,4 +1595,31 @@ public void noOuterScalarReordering() {
         
         ts.assertValues(1, 2);
     }
+    
+    @Test
+    public void array() {
+        for (int i = 1; i < 100; i++) {
+            
+            @SuppressWarnings("unchecked")
+            Flowable<Integer>[] sources = new Flowable[i];
+            Arrays.fill(sources, Flowable.just(1));
+            Integer[] expected = new Integer[i];
+            for (int j = 0; j < i; j++) {
+                expected[j] = 1;
+            }
+
+            Flowable.mergeArray(sources)
+            .test()
+            .assertResult(expected);
+        }
+    }
+    
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeArray() {
+        Flowable.mergeArray(Flowable.just(1), Flowable.just(2))
+        .test()
+        .assertResult(1, 2);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
index 5fb7f9b49e..2666c33885 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
@@ -26,6 +26,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.schedulers.ImmediateThinScheduler;
@@ -946,4 +947,22 @@ public void rebatchRequestsArgumentCheck() {
             assertEquals("bufferSize > 0 required but it was -99", ex.getMessage());
         }
     }
+    
+    @Test
+    public void delayError() {
+        Flowable.range(1, 5).concatWith(Flowable.<Integer>error(new TestException()))
+        .observeOn(Schedulers.computation(), true)
+        .doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                if (v == 1) {
+                    Thread.sleep(100);
+                }
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class, 1, 2, 3, 4, 5);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferTest.java
index 30f19632b0..2ef926455e 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferTest.java
@@ -22,7 +22,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Flowable;
-import io.reactivex.exceptions.MissingBackpressureException;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.schedulers.Schedulers;
@@ -216,4 +216,35 @@ public void run() { }
         }, null);
     }
 
+    @Test
+    public void noDelayError() {
+        
+        Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
+        .onBackpressureBuffer(false)
+        .test(0L)
+        .assertFailure(TestException.class);
+    }
+    
+    @Test
+    public void delayError() {
+        TestSubscriber<Integer> ts = Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
+        .onBackpressureBuffer(true)
+        .test(0L)
+        .assertEmpty();
+        
+        ts.request(1);
+        ts.assertFailure(TestException.class, 1);
+        
+    }
+    
+    @Test
+    public void delayErrorBuffer() {
+        TestSubscriber<Integer> ts = Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
+        .onBackpressureBuffer(16, true)
+        .test(0L)
+        .assertEmpty();
+
+        ts.request(1);
+        ts.assertFailure(TestException.class, 1);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturnTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturnTest.java
index ef0421a388..c5abbae77b 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturnTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnErrorReturnTest.java
@@ -23,7 +23,7 @@
 import org.mockito.Mockito;
 import org.reactivestreams.*;
 
-import io.reactivex.Flowable;
+import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
@@ -246,4 +246,12 @@ public Integer apply(Throwable e) {
     }
     
     
+    @Test
+    public void returnItem() {
+        Flowable.error(new TestException())
+        .onErrorReturnItem(1)
+        .test()
+        .assertResult(1);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java
index 7a19cd5914..c2ce53b5a5 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java
@@ -25,8 +25,9 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.functions.Function;
+import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
@@ -242,5 +243,29 @@ public Flowable apply(Flowable o) {
         ts.assertNoErrors();
         ts.assertComplete();
     }
+    
+    @Test
+    public void repeatUntil() {
+        Flowable.just(1)
+        .repeatUntil(new BooleanSupplier() {
+            @Override
+            public boolean getAsBoolean() throws Exception {
+                return false;
+            }
+        })
+        .take(5)
+        .test()
+        .assertResult(1, 1, 1, 1, 1);
+    }
+
+    @Test
+    public void repeatLongPredicateInvalid() {
+        try {
+            Flowable.just(1).repeat(-99);
+            fail("Should have thrown");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("times >= 0 required but it was -99", ex.getMessage());
+        }
+    }
 
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
index 15c9c38ccb..a107c8674a 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java
@@ -26,11 +26,13 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.flowables.ConnectableFlowable;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.operators.flowable.FlowableReplay.*;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.processors.PublishProcessor;
@@ -516,7 +518,7 @@ public void testIssue2191_UnsubscribeSource() throws Exception {
         Subscriber<Integer> spiedSubscriberBeforeConnect = TestHelper.mockSubscriber();
         Subscriber<Integer> spiedSubscriberAfterConnect = TestHelper.mockSubscriber();
 
-        // Observable under test
+        // Flowable under test
         Flowable<Integer> source = Flowable.just(1,2);
 
         ConnectableFlowable<Integer> replay = source
@@ -571,7 +573,7 @@ public void testIssue2191_SchedulerUnsubscribe() throws Exception {
 
         when(mockScheduler.createWorker()).thenReturn(spiedWorker);
 
-        // Observable under test
+        // Flowable under test
         ConnectableFlowable<Integer> replay = Flowable.just(1, 2, 3)
                 .doOnNext(sourceNext)
                 .doOnCancel(sourceUnsubscribed)
@@ -634,7 +636,7 @@ public void testIssue2191_SchedulerUnsubscribeOnError() throws Exception {
 
         when(mockScheduler.createWorker()).thenReturn(spiedWorker);
 
-        // Observable under test
+        // Flowable under test
         Function<Integer, Integer> mockFunc = mock(Function.class);
         IllegalArgumentException illegalArgumentException = new IllegalArgumentException();
         when(mockFunc.apply(1)).thenReturn(1);
@@ -1234,4 +1236,66 @@ public void testSubscribersComeAndGoAtRequestBoundaries2() {
         ts3.assertComplete();
     }
 
+    @Test
+    public void replayScheduler() {
+        
+        Flowable.just(1).replay(Schedulers.computation())
+        .autoConnect()
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+    
+    @Test
+    public void replayTime() {
+        Flowable.just(1).replay(1, TimeUnit.MINUTES)
+        .autoConnect()
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void replaySizeScheduler() {
+        
+        Flowable.just(1).replay(1, Schedulers.computation())
+        .autoConnect()
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void replaySizeAndTime() {
+        Flowable.just(1).replay(1, 1, TimeUnit.MILLISECONDS)
+        .autoConnect()
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+    
+    @Test
+    public void replaySelectorSizeScheduler() {
+        Flowable.just(1).replay(Functions.<Flowable<Integer>>identity(), 1, Schedulers.io())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void replaySelectorScheduler() {
+        Flowable.just(1).replay(Functions.<Flowable<Integer>>identity(), Schedulers.io())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void replaySelectorTime() {
+        Flowable.just(1).replay(Functions.<Flowable<Integer>>identity(), 1, TimeUnit.MINUTES)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java
index 9b77060871..e928503b3c 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRetryTest.java
@@ -662,7 +662,7 @@ public void testUnsubscribeAfterError() {
         @SuppressWarnings("unchecked")
         DefaultSubscriber<Long> observer = mock(DefaultSubscriber.class);
 
-        // Observable that always fails after 100ms
+        // Flowable that always fails after 100ms
         SlowObservable so = new SlowObservable(100, 0);
         Flowable<Long> o = Flowable.unsafeCreate(so).retry(5);
 
@@ -687,7 +687,7 @@ public void testTimeoutWithRetry() {
         @SuppressWarnings("unchecked")
         DefaultSubscriber<Long> observer = mock(DefaultSubscriber.class);
 
-        // Observable that sends every 100ms (timeout fails instead)
+        // Flowable that sends every 100ms (timeout fails instead)
         SlowObservable so = new SlowObservable(100, 10);
         Flowable<Long> o = Flowable.unsafeCreate(so).timeout(80, TimeUnit.MILLISECONDS).retry(5);
 
@@ -955,4 +955,46 @@ public Flowable apply(Flowable o) {
         ts.assertComplete();
     }
 
+    @Test
+    public void retryPredicate() {
+        Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
+        .retry(new Predicate<Throwable>() {
+            @Override
+            public boolean test(Throwable v) throws Exception {
+                return true;
+            }
+        })
+        .take(5)
+        .test()
+        .assertResult(1, 1, 1, 1, 1);
+    }
+
+    @Test
+    public void retryLongPredicateInvalid() {
+        try {
+            Flowable.just(1).retry(-99, new Predicate<Throwable>() {
+                @Override
+                public boolean test(Throwable e) throws Exception {
+                    return true;
+                }
+            });
+            fail("Should have thrown");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("times >= 0 required but it was -99", ex.getMessage());
+        }
+    }
+
+    @Test
+    public void retryUntil() {
+        Flowable.just(1).concatWith(Flowable.<Integer>error(new TestException()))
+        .retryUntil(new BooleanSupplier() {
+            @Override
+            public boolean getAsBoolean() throws Exception {
+                return false;
+            }
+        })
+        .take(5)
+        .test()
+        .assertResult(1, 1, 1, 1, 1);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualTest.java
index 171f5bf3fe..c8302b97ee 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqualTest.java
@@ -149,4 +149,12 @@ private void verifyError(Flowable<Boolean> observable) {
         inOrder.verify(observer, times(1)).onError(isA(TestException.class));
         inOrder.verifyNoMoreInteractions();
     }
+    
+    @Test
+    public void prefetch() {
+        
+        Flowable.sequenceEqual(Flowable.range(1, 20), Flowable.range(1, 20), 2)
+        .test()
+        .assertResult(true);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java
index adb53c9d84..38d9fbe850 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java
@@ -151,7 +151,7 @@ public void testSkipLastTimedWhenAllElementsAreValid() {
     
     @Test
     public void skipLastTimedDefaultScheduler() {
-        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        Flowable.just(1).concatWith(Flowable.just(2).delay(500, TimeUnit.MILLISECONDS))
         .skipLast(300, TimeUnit.MILLISECONDS)
         .test()
         .awaitDone(5, TimeUnit.SECONDS)
@@ -160,7 +160,7 @@ public void skipLastTimedDefaultScheduler() {
 
     @Test
     public void skipLastTimedDefaultSchedulerDelayError() {
-        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        Flowable.just(1).concatWith(Flowable.just(2).delay(500, TimeUnit.MILLISECONDS))
         .skipLast(300, TimeUnit.MILLISECONDS, true)
         .test()
         .awaitDone(5, TimeUnit.SECONDS)
@@ -169,7 +169,7 @@ public void skipLastTimedDefaultSchedulerDelayError() {
 
     @Test
     public void skipLastTimedCustomSchedulerDelayError() {
-        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        Flowable.just(1).concatWith(Flowable.just(2).delay(500, TimeUnit.MILLISECONDS))
         .skipLast(300, TimeUnit.MILLISECONDS, Schedulers.io(), true)
         .test()
         .awaitDone(5, TimeUnit.SECONDS)
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipTimedTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipTimedTest.java
index 81f575328c..cdfd697866 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipTimedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipTimedTest.java
@@ -157,4 +157,12 @@ public void testSkipTimedErrorAfterTime() {
         verify(o, never()).onComplete();
 
     }
+
+    @Test
+    public void skipTimedDefaultScheduler() {
+        Flowable.just(1).skip(1, TimeUnit.MINUTES)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult();
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java
index 0ccc272c6e..0b254b0877 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java
@@ -668,4 +668,133 @@ public void delayErrors() {
         TestHelper.assertError(errors, 1, TestException.class, "Forced failure 2");
         TestHelper.assertError(errors, 2, TestException.class, "Forced failure 3");
     }
+    
+    @Test
+    public void switchOnNextPrefetch() {
+        final List<Integer> list = new ArrayList<Integer>();
+        
+        Flowable<Integer> source = Flowable.range(1, 10).doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        });
+        
+        Flowable.switchOnNext(Flowable.just(source).hide(), 2)
+        .test(1);
+        
+        assertEquals(Arrays.asList(1, 2, 3), list);
+    }
+    
+    @Test
+    public void switchOnNextDelayError() {
+        final List<Integer> list = new ArrayList<Integer>();
+        
+        Flowable<Integer> source = Flowable.range(1, 10).doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        });
+        
+        Flowable.switchOnNextDelayError(Flowable.just(source).hide())
+        .test(1);
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), list);
+    }
+    
+    @Test
+    public void switchOnNextDelayErrorPrefetch() {
+        final List<Integer> list = new ArrayList<Integer>();
+        
+        Flowable<Integer> source = Flowable.range(1, 10).doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        });
+        
+        Flowable.switchOnNextDelayError(Flowable.just(source).hide(), 2)
+        .test(1);
+        
+        assertEquals(Arrays.asList(1, 2, 3), list);
+    }
+
+    @Test
+    public void switchOnNextDelayErrorWithError() {
+        PublishProcessor<Flowable<Integer>> ps = PublishProcessor.create();
+        
+        TestSubscriber<Integer> ts = Flowable.switchOnNextDelayError(ps).test();
+        
+        ps.onNext(Flowable.just(1));
+        ps.onNext(Flowable.<Integer>error(new TestException()));
+        ps.onNext(Flowable.range(2, 4));
+        ps.onComplete();
+        
+        ts.assertFailure(TestException.class, 1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void switchOnNextDelayErrorBufferSize() {
+        PublishProcessor<Flowable<Integer>> ps = PublishProcessor.create();
+        
+        TestSubscriber<Integer> ts = Flowable.switchOnNextDelayError(ps, 2).test();
+        
+        ps.onNext(Flowable.just(1));
+        ps.onNext(Flowable.range(2, 4));
+        ps.onComplete();
+        
+        ts.assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void switchMapDelayErrorEmptySource() {
+        assertSame(Flowable.empty(), Flowable.<Object>empty()
+                .switchMapDelayError(new Function<Object, Publisher<Integer>>() {
+                    @Override
+                    public Publisher<Integer> apply(Object v) throws Exception {
+                        return Flowable.just(1);
+                    }
+                }, 16));
+    }
+
+    @Test
+    public void switchMapDelayErrorJustSource() {
+        Flowable.just(0)
+        .switchMapDelayError(new Function<Object, Publisher<Integer>>() {
+            @Override
+            public Publisher<Integer> apply(Object v) throws Exception {
+                return Flowable.just(1);
+            }
+        }, 16)
+        .test()
+        .assertResult(1);
+    
+    }
+
+    @Test
+    public void switchMapErrorEmptySource() {
+        assertSame(Flowable.empty(), Flowable.<Object>empty()
+                .switchMap(new Function<Object, Publisher<Integer>>() {
+                    @Override
+                    public Publisher<Integer> apply(Object v) throws Exception {
+                        return Flowable.just(1);
+                    }
+                }, 16));
+    }
+
+    @Test
+    public void switchMapJustSource() {
+        Flowable.just(0)
+        .switchMap(new Function<Object, Publisher<Integer>>() {
+            @Override
+            public Publisher<Integer> apply(Object v) throws Exception {
+                return Flowable.just(1);
+            }
+        }, 16)
+        .test()
+        .assertResult(1);
+    
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTimedTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTimedTest.java
index 804c82249a..81473bca50 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTimedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeLastTimedTest.java
@@ -237,4 +237,37 @@ public void testContinuousDelivery() {
         ts.assertNoErrors();
         
     }
+    
+    @Test
+    public void takeLastTimeAndSize() {
+        Flowable.just(1, 2)
+        .takeLast(1, 1, TimeUnit.MINUTES)
+        .test()
+        .assertResult(2);
+    }
+
+    @Test
+    public void takeLastTime() {
+        Flowable.just(1, 2)
+        .takeLast(1, TimeUnit.MINUTES)
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void takeLastTimeDelayError() {
+        Flowable.just(1, 2).concatWith(Flowable.<Integer>error(new TestException()))
+        .takeLast(1, TimeUnit.MINUTES, true)
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
+    @Test
+    public void takeLastTimeDelayErrorCustomScheduler() {
+        Flowable.just(1, 2).concatWith(Flowable.<Integer>error(new TestException()))
+        .takeLast(1, TimeUnit.MINUTES, Schedulers.io(), true)
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTest.java
index 6799fae721..ea6f1152ab 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTest.java
@@ -437,4 +437,16 @@ public void accept(Integer v) {
         ts.assertNoErrors();
         ts.assertComplete();
     }
+
+    
+    @Test
+    public void takeNegative() {
+        try {
+            Flowable.just(1).take(-99);
+            fail("Should have thrown");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("count >= 0 required but it was -99", ex.getMessage());
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTimedTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTimedTest.java
index 4e0974e6ab..470d03ab8a 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTimedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTimedTest.java
@@ -126,7 +126,7 @@ public void testTakeTimedErrorAfterTime() {
     
     @Test
     public void timedDefaultScheduler() {
-        Observable.range(1, 5).take(1, TimeUnit.MINUTES)
+        Flowable.range(1, 5).take(1, TimeUnit.MINUTES)
         .test()
         .awaitDone(5, TimeUnit.SECONDS)
         .assertResult(1, 2, 3, 4, 5);
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java
index c014a2aea2..f65ae5fee0 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTest.java
@@ -150,4 +150,14 @@ public void testThrottle() {
         inOrder.verify(observer).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
+    
+    
+    @Test
+    public void throttleFirstDefaultScheduler() {
+        Flowable.just(1).throttleFirst(100, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeIntervalTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeIntervalTest.java
index e6e4352385..67bcfcab0c 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeIntervalTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeIntervalTest.java
@@ -22,6 +22,8 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.functions.Function;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.*;
 
@@ -65,4 +67,59 @@ public void testTimeInterval() {
         inOrder.verify(observer, times(1)).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
+    
+    @Test
+    public void timeIntervalDefault() {
+        final TestScheduler scheduler = new TestScheduler();
+        
+        RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler, Scheduler>() {
+            @Override
+            public Scheduler apply(Scheduler v) throws Exception {
+                return scheduler;
+            }
+        });
+        
+        try {
+            Flowable.range(1, 5)
+            .timeInterval()
+            .map(new Function<Timed<Integer>, Long>() {
+                @Override
+                public Long apply(Timed<Integer> v) throws Exception {
+                    return v.time();
+                }
+            })
+            .test()
+            .assertResult(0L, 0L, 0L, 0L, 0L);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void timeIntervalDefaultSchedulerCustomUnit() {
+        final TestScheduler scheduler = new TestScheduler();
+        
+        RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler, Scheduler>() {
+            @Override
+            public Scheduler apply(Scheduler v) throws Exception {
+                return scheduler;
+            }
+        });
+        
+        try {
+            Flowable.range(1, 5)
+            .timeInterval(TimeUnit.SECONDS)
+            .map(new Function<Timed<Integer>, Long>() {
+                @Override
+                public Long apply(Timed<Integer> v) throws Exception {
+                    return v.time();
+                }
+            })
+            .test()
+            .assertResult(0L, 0L, 0L, 0L, 0L);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java
index 438595d54d..409673d3a4 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java
@@ -357,4 +357,14 @@ public void subscribe(Subscriber<? super String> subscriber) {
 
         verify(s, times(1)).cancel();
     }
+
+    
+    @Test
+    public void timedAndOther() {
+        Flowable.never().timeout(100, TimeUnit.MILLISECONDS, Flowable.just(1))
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimestampTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimestampTest.java
index a461e55bb8..41959d1e65 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimestampTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimestampTest.java
@@ -23,6 +23,8 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.functions.Function;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.*;
 
@@ -81,4 +83,59 @@ public void timestampWithScheduler2() {
         verify(observer, never()).onError(any(Throwable.class));
         verify(observer, never()).onComplete();
     }
+
+    @Test
+    public void timeIntervalDefault() {
+        final TestScheduler scheduler = new TestScheduler();
+        
+        RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler, Scheduler>() {
+            @Override
+            public Scheduler apply(Scheduler v) throws Exception {
+                return scheduler;
+            }
+        });
+        
+        try {
+            Flowable.range(1, 5)
+            .timestamp()
+            .map(new Function<Timed<Integer>, Long>() {
+                @Override
+                public Long apply(Timed<Integer> v) throws Exception {
+                    return v.time();
+                }
+            })
+            .test()
+            .assertResult(0L, 0L, 0L, 0L, 0L);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void timeIntervalDefaultSchedulerCustomUnit() {
+        final TestScheduler scheduler = new TestScheduler();
+        
+        RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler, Scheduler>() {
+            @Override
+            public Scheduler apply(Scheduler v) throws Exception {
+                return scheduler;
+            }
+        });
+        
+        try {
+            Flowable.range(1, 5)
+            .timestamp(TimeUnit.SECONDS)
+            .map(new Function<Timed<Integer>, Long>() {
+                @Override
+                public Long apply(Timed<Integer> v) throws Exception {
+                    return v.time();
+                }
+            })
+            .test()
+            .assertResult(0L, 0L, 0L, 0L, 0L);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableFutureTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToFutureTest.java
similarity index 99%
rename from src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableFutureTest.java
rename to src/test/java/io/reactivex/internal/operators/flowable/FlowableToFutureTest.java
index 2e66a6c118..f5efe7c1a5 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableFutureTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToFutureTest.java
@@ -26,7 +26,7 @@
 import io.reactivex.schedulers.*;
 import io.reactivex.subscribers.TestSubscriber;
 
-public class FlowableToObservableFutureTest {
+public class FlowableToFutureTest {
 
     @Test
     public void testSuccess() throws Exception {
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableListTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java
similarity index 95%
rename from src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableListTest.java
rename to src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java
index a7eb65d00d..64caa80933 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableListTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java
@@ -28,7 +28,7 @@
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 
-public class FlowableToObservableListTest {
+public class FlowableToListTest {
 
     @Test
     public void testList() {
@@ -162,4 +162,13 @@ static void await(CyclicBarrier cb) {
             ex.printStackTrace();
         }
     }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void capacityHint() {
+        Flowable.range(1, 10)
+        .toList(4)
+        .test()
+        .assertResult(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableSortedListTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToSortedListTest.java
similarity index 80%
rename from src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableSortedListTest.java
rename to src/test/java/io/reactivex/internal/operators/flowable/FlowableToSortedListTest.java
index 2ef297b14f..3b445611d5 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableSortedListTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToSortedListTest.java
@@ -25,11 +25,12 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 
-public class FlowableToObservableSortedListTest {
+public class FlowableToSortedListTest {
 
     @Test
     public void testSortedList() {
@@ -133,4 +134,44 @@ static void await(CyclicBarrier cb) {
             ex.printStackTrace();
         }
     }
+    
+    @Test
+    public void sorted() {
+        Flowable.just(5, 1, 2, 4, 3).sorted()
+        .test()
+        .assertResult(1, 2, 3, 4, 5);
+    }
+    
+    @Test
+    public void sortedComparator() {
+        Flowable.just(5, 1, 2, 4, 3).sorted(new Comparator<Integer>() {
+            @Override
+            public int compare(Integer a, Integer b) {
+                return b - a;
+            }
+        })
+        .test()
+        .assertResult(5, 4, 3, 2, 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void toSortedListCapacity() {
+        Flowable.just(5, 1, 2, 4, 3).toSortedList(4)
+        .test()
+        .assertResult(Arrays.asList(1, 2, 3, 4, 5));
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void toSortedListComparatorCapacity() {
+        Flowable.just(5, 1, 2, 4, 3).toSortedList(new Comparator<Integer>() {
+            @Override
+            public int compare(Integer a, Integer b) {
+                return b - a;
+            }
+        }, 4)
+        .test()
+        .assertResult(Arrays.asList(5, 4, 3, 2, 1));
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
index f907cd732c..c6edc54ec9 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
@@ -13,7 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 
 import java.util.*;
 import java.util.concurrent.TimeUnit;
@@ -23,9 +23,11 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Flowable;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
-import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.schedulers.*;
 import io.reactivex.subscribers.*;
 
 
@@ -217,5 +219,66 @@ public void accept(Integer pv) {
         ts.assertComplete();
         Assert.assertTrue(ts.valueCount() != 0);
     }
-    
+
+
+    @Test
+    public void timespanTimeskipCustomSchedulerBufferSize() {
+        Flowable.range(1, 10)
+        .window(1, 1, TimeUnit.MINUTES, Schedulers.io(), 2)
+        .flatMap(Functions.<Flowable<Integer>>identity())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+    }
+
+    @Test
+    public void timespanDefaultSchedulerSize() {
+        Flowable.range(1, 10)
+        .window(1, TimeUnit.MINUTES, 20)
+        .flatMap(Functions.<Flowable<Integer>>identity())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+    }
+
+    @Test
+    public void timespanDefaultSchedulerSizeRestart() {
+        Flowable.range(1, 10)
+        .window(1, TimeUnit.MINUTES, 20, true)
+        .flatMap(Functions.<Flowable<Integer>>identity(), true)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+    }
+
+    @Test
+    public void invalidSpan() {
+        try {
+            Flowable.just(1).window(-99, 1, TimeUnit.SECONDS);
+            fail("Should have thrown!");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("timespan > 0 required but it was -99", ex.getMessage());
+        }
+    }
+
+    @Test
+    public void timespanTimeskipDefaultScheduler() {
+        Flowable.just(1)
+        .window(1, 1, TimeUnit.MINUTES)
+        .flatMap(Functions.<Flowable<Integer>>identity())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void timespanTimeskipCustomScheduler() {
+        Flowable.just(1)
+        .window(1, 1, TimeUnit.MINUTES, Schedulers.io())
+        .flatMap(Functions.<Flowable<Integer>>identity())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java
index 9b08ff32c1..7f7e4663b0 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableZipTest.java
@@ -17,6 +17,7 @@
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
 
+import java.lang.reflect.*;
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -26,6 +27,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
@@ -1283,4 +1285,304 @@ public Integer apply(Integer t1, Integer t2) {
         ts.assertNoErrors();
         ts.assertValue(11);
     }
+    
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void zipNArguments() throws Exception {
+        Flowable source = Flowable.just(1);
+        
+        for (int i = 2; i < 10; i++) {
+            Class<?>[] types = new Class[i + 1];
+            Arrays.fill(types, Publisher.class);
+            types[i] = i == 2 ? BiFunction.class : Class.forName("io.reactivex.functions.Function" + i);
+            
+            Method m = Flowable.class.getMethod("zip", types);
+            
+            Object[] params = new Object[i + 1];
+            Arrays.fill(params, source);
+            params[i] = ArgsToString.INSTANCE;
+            
+            StringBuilder b = new StringBuilder();
+            for (int j = 0; j < i; j++) {
+                b.append('1');
+            }
+            
+            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());
+            
+            for (int j = 0; j < params.length; j++) {
+                Object[] params0 = params.clone();
+                params0[j] = null;
+                
+                try {
+                    m.invoke(null, params0);
+                    fail("Should have thrown @ " + m);
+                } catch (InvocationTargetException ex) {
+                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);
+                    
+                    if (j < i) {
+                        assertEquals("source" + (j + 1) + " is null", ex.getCause().getMessage());
+                    } else {
+                        assertEquals("f is null", ex.getCause().getMessage());
+                    }
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("rawtypes")
+    enum ArgsToString implements Function, BiFunction, Function3, Function4, Function5, Function6, Function7, Function8, Function9 {
+        INSTANCE;
+
+        @Override
+        public Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6, Object t7, Object t8,
+                Object t9) throws Exception {
+            return "" + t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9;
+        }
+
+        @Override
+        public Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6, Object t7, Object t8)
+                throws Exception {
+            return "" + t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;
+        }
+
+        @Override
+        public Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6, Object t7)
+                throws Exception {
+            return "" + t1 + t2 + t3 + t4 + t5 + t6 + t7;
+        }
+
+        @Override
+        public Object apply(Object t1, Object t2, Object t3, Object t4, Object t5, Object t6) throws Exception {
+            return "" + t1 + t2 + t3 + t4 + t5 + t6;
+        }
+
+        @Override
+        public Object apply(Object t1, Object t2, Object t3, Object t4, Object t5) throws Exception {
+            return "" + t1 + t2 + t3 + t4 + t5;
+        }
+
+        @Override
+        public Object apply(Object t1, Object t2, Object t3, Object t4) throws Exception {
+            return "" + t1 + t2 + t3 + t4;
+        }
+
+        @Override
+        public Object apply(Object t1, Object t2, Object t3) throws Exception {
+            return "" + t1 + t2 + t3;
+        }
+
+        @Override
+        public Object apply(Object t1, Object t2) throws Exception {
+            return "" + t1 + t2;
+        }
+
+        @Override
+        public Object apply(Object t1) throws Exception {
+            return "" + t1;
+        }
+    }
+    
+    @Test
+    public void zip2DelayError() {
+        Flowable<Integer> error1 = Flowable.error(new TestException("One"));
+        Flowable<Integer> source1 = Flowable.range(1, 3).concatWith(error1);
+
+        Flowable<Integer> error2 = Flowable.error(new TestException("Two"));
+        Flowable<Integer> source2 = Flowable.range(1, 2).concatWith(error2);
+        
+        TestSubscriber<Object> ts = Flowable.zip(source1, source2, new BiFunction<Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b) throws Exception {
+                return "" + a + b;
+            }
+        }, true)
+        .test()
+        .assertFailure(CompositeException.class, "11", "22");
+        
+        List<Throwable> errors = TestHelper.compositeList(ts.errors().get(0));
+        TestHelper.assertError(errors, 0, TestException.class, "One");
+        TestHelper.assertError(errors, 1, TestException.class, "Two");
+        assertEquals(2, errors.size());
+    }
+
+    @Test
+    public void zip2DelayErrorPrefetch() {
+        Flowable<Integer> error1 = Flowable.error(new TestException("One"));
+        Flowable<Integer> source1 = Flowable.range(1, 3).concatWith(error1);
+
+        Flowable<Integer> error2 = Flowable.error(new TestException("Two"));
+        Flowable<Integer> source2 = Flowable.range(1, 2).concatWith(error2);
+        
+        TestSubscriber<Object> ts = Flowable.zip(source1, source2, new BiFunction<Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b) throws Exception {
+                return "" + a + b;
+            }
+        }, true, 1)
+        .test()
+        .assertFailure(CompositeException.class, "11", "22");
+        
+        List<Throwable> errors = TestHelper.compositeList(ts.errors().get(0));
+        TestHelper.assertError(errors, 0, TestException.class, "One");
+        TestHelper.assertError(errors, 1, TestException.class, "Two");
+        assertEquals(2, errors.size());
+    }
+    
+    @Test
+    public void zip2Prefetch() {
+        Flowable.zip(Flowable.range(1, 9),
+                Flowable.range(21, 9),
+            new BiFunction<Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b) throws Exception {
+                    return "" + a + b;
+                }
+            }, false, 2
+        )
+        .takeLast(1)
+        .test()
+        .assertResult("929");
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void zipArrayEmpty() {
+        assertSame(Flowable.empty(), Flowable.zipArray(Functions.<Object[]>identity(), false, 16));
+    }
+    
+    @Test
+    public void zip2() {
+        Flowable.zip(Flowable.just(1),
+                Flowable.just(2),
+            new BiFunction<Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b) throws Exception {
+                    return "" + a + b;
+                }
+            }
+        )
+        .test()
+        .assertResult("12");
+    }
+
+    @Test
+    public void zip3() {
+        Flowable.zip(Flowable.just(1),
+                Flowable.just(2), Flowable.just(3),
+            new Function3<Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c) throws Exception {
+                    return "" + a + b + c;
+                }
+            }
+        )
+        .test()
+        .assertResult("123");
+    }
+
+    @Test
+    public void zip4() {
+        Flowable.zip(Flowable.just(1),
+                Flowable.just(2), Flowable.just(3),
+                Flowable.just(4),
+            new Function4<Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d) throws Exception {
+                    return "" + a + b + c + d;
+                }
+            }
+        )
+        .test()
+        .assertResult("1234");
+    }
+
+    @Test
+    public void zip5() {
+        Flowable.zip(Flowable.just(1),
+                Flowable.just(2), Flowable.just(3),
+                Flowable.just(4), Flowable.just(5),
+            new Function5<Integer, Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e) throws Exception {
+                    return "" + a + b + c + d + e;
+                }
+            }
+        )
+        .test()
+        .assertResult("12345");
+    }
+
+    @Test
+    public void zip6() {
+        Flowable.zip(Flowable.just(1),
+                Flowable.just(2), Flowable.just(3),
+                Flowable.just(4), Flowable.just(5),
+                Flowable.just(6),
+            new Function6<Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f) throws Exception {
+                    return "" + a + b + c + d + e + f;
+                }
+            }
+        )
+        .test()
+        .assertResult("123456");
+    }
+
+    @Test
+    public void zip7() {
+        Flowable.zip(Flowable.just(1),
+                Flowable.just(2), Flowable.just(3),
+                Flowable.just(4), Flowable.just(5),
+                Flowable.just(6), Flowable.just(7),
+            new Function7<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g)
+                        throws Exception {
+                    return "" + a + b + c + d + e + f + g;
+                }
+            }
+        )
+        .test()
+        .assertResult("1234567");
+    }
+
+    @Test
+    public void zip8() {
+        Flowable.zip(Flowable.just(1),
+                Flowable.just(2), Flowable.just(3),
+                Flowable.just(4), Flowable.just(5),
+                Flowable.just(6), Flowable.just(7),
+                Flowable.just(8), 
+            new Function8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g,
+                        Integer h) throws Exception {
+                    return "" + a + b + c + d + e + f + g + h;
+                }
+            }
+        )
+        .test()
+        .assertResult("12345678");
+    }
+    @Test
+    public void zip9() {
+        Flowable.zip(Flowable.just(1),
+                Flowable.just(2), Flowable.just(3),
+                Flowable.just(4), Flowable.just(5),
+                Flowable.just(6), Flowable.just(7),
+                Flowable.just(8), Flowable.just(9),
+            new Function9<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g,
+                        Integer h, Integer i) throws Exception {
+                    return "" + a + b + c + d + e + f + g + h + i;
+                }
+            }
+        )
+        .test()
+        .assertResult("123456789");
+    }
+
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
index de861b4beb..ee9b8830c6 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
@@ -148,6 +148,5 @@ public void accept(HashSet<Integer> s, Integer v) throws Exception {
         })
         .test()
         .assertResult(new HashSet<Integer>(Arrays.asList(1, 2)));
-        
     }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java
index 68c898b2ec..b717f3d822 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java
@@ -850,6 +850,12 @@ public Object apply(Object[] a) throws Exception {
         .assertFailure(TestException.class, "[1, 2]");
     }
 
+    @SuppressWarnings("unchecked")
+    @Test
+    public void combineLatestEmpty() {
+        assertSame(Observable.empty(), Observable.combineLatest(new ObservableSource[0], Functions.<Object[]>identity(), 16));
+    }
+
     @SuppressWarnings("unchecked")
     @Test
     public void combineLatestDelayErrorEmpty() {
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableFromIterableTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableFromIterableTest.java
index af014c22f8..1c5d856973 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableFromIterableTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFromIterableTest.java
@@ -227,7 +227,7 @@ public void onNext(Integer t) {
         });
         assertFalse(called.get());
     }
- 
+
     @Test
     public void fusionWithConcatMap() {
         TestObserver<Integer> to = new TestObserver<Integer>();
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableIntervalRangeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableIntervalRangeTest.java
index fc5dca5d99..1a121a55c3 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableIntervalRangeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableIntervalRangeTest.java
@@ -13,11 +13,14 @@
 
 package io.reactivex.internal.operators.observable;
 
+import static org.junit.Assert.*;
+
 import java.util.concurrent.TimeUnit;
 
 import org.junit.Test;
 
-import io.reactivex.Observable;
+import io.reactivex.*;
+import io.reactivex.schedulers.Schedulers;
 
 public class ObservableIntervalRangeTest {
 
@@ -30,12 +33,42 @@ public void simple() throws Exception {
     }
 
     @Test
-    public void noOverflow() {
-        Observable.intervalRange(Long.MAX_VALUE - 1, 2, 1, 1, TimeUnit.SECONDS);
+    public void customScheduler() {
+        Observable.intervalRange(1, 5, 1, 1, TimeUnit.MILLISECONDS, Schedulers.single())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1L, 2L, 3L, 4L, 5L);
     }
 
-    @Test(expected = IllegalArgumentException.class)
+    @Test
+    public void countZero() {
+        Observable.intervalRange(1, 0, 1, 1, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult();
+    }    
+
+    @Test
+    public void countNegative() {
+        try {
+            Observable.intervalRange(1, -1, 1, 1, TimeUnit.MILLISECONDS);
+            fail("Should have thrown!");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("count >= 0 required but it was -1", ex.getMessage());
+        }
+    }
+
+    @Test
     public void longOverflow() {
-        Observable.intervalRange(Long.MAX_VALUE - 1, 3, 1, 1, TimeUnit.SECONDS);
+        Observable.intervalRange(Long.MAX_VALUE - 1, 2, 1, 1, TimeUnit.MILLISECONDS);
+
+        Observable.intervalRange(Long.MIN_VALUE, Long.MAX_VALUE, 1, 1, TimeUnit.MILLISECONDS);
+
+        try {
+            Observable.intervalRange(Long.MAX_VALUE - 1, 3, 1, 1, TimeUnit.MILLISECONDS);
+            fail("Should have thrown!");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("Overflow! start + count is bigger than Long.MAX_VALUE", ex.getMessage());
+        }
     }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSequenceEqualTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSequenceEqualTest.java
index b8b577adec..bb1f92d56c 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSequenceEqualTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSequenceEqualTest.java
@@ -150,7 +150,7 @@ private void verifyError(Observable<Boolean> NbpObservable) {
     }
     
     @Test
-    public void sequenceEqualBufferSize() {
+    public void prefetch() {
         Observable.sequenceEqual(Observable.range(1, 20), Observable.range(1, 20), 2)
         .test()
         .assertResult(true);
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipLastTimedTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipLastTimedTest.java
index 135743fc8f..85a20a59ee 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipLastTimedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipLastTimedTest.java
@@ -23,7 +23,7 @@
 
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.schedulers.*;
 import io.reactivex.subjects.PublishSubject;
 
 public class ObservableSkipLastTimedTest {
@@ -147,4 +147,32 @@ public void testSkipLastTimedWhenAllElementsAreValid() {
         inOrder.verify(o).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
+
+    @Test
+    public void skipLastTimedDefaultScheduler() {
+        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        .skipLast(300, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void skipLastTimedDefaultSchedulerDelayError() {
+        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        .skipLast(300, TimeUnit.MILLISECONDS, true)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void skipLastTimedCustomSchedulerDelayError() {
+        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        .skipLast(300, TimeUnit.MILLISECONDS, Schedulers.io(), true)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeTimedTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeTimedTest.java
index 4e792081fe..354394b8f1 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeTimedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeTimedTest.java
@@ -122,4 +122,12 @@ public void testTakeTimedErrorAfterTime() {
         verify(o, never()).onNext(4);
         verify(o, never()).onError(any(TestException.class));
     }
+    
+    @Test
+    public void timedDefaultScheduler() {
+        Observable.range(1, 5).take(1, TimeUnit.MINUTES)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableListTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableToListTest.java
similarity index 98%
rename from src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableListTest.java
rename to src/test/java/io/reactivex/internal/operators/observable/ObservableToListTest.java
index 45f5ee1eb2..233784fbef 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableListTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableToListTest.java
@@ -26,7 +26,7 @@
 import io.reactivex.Observer;
 import io.reactivex.TestHelper;
 
-public class ObservableToObservableListTest {
+public class ObservableToListTest {
 
     @Test
     public void testList() {
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableSortedListTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableToSortedListTest.java
similarity index 98%
rename from src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableSortedListTest.java
rename to src/test/java/io/reactivex/internal/operators/observable/ObservableToSortedListTest.java
index 0cfe73ce66..9e9afc2f1b 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableSortedListTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableToSortedListTest.java
@@ -27,7 +27,7 @@
 import io.reactivex.Observer;
 import io.reactivex.TestHelper;
 
-public class ObservableToObservableSortedListTest {
+public class ObservableToSortedListTest {
 
     @Test
     public void testSortedList() {
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleConcatTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleConcatTest.java
index cff61e1d5d..78ff1ceba5 100644
--- a/src/test/java/io/reactivex/internal/operators/single/SingleConcatTest.java
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleConcatTest.java
@@ -13,6 +13,8 @@
 
 package io.reactivex.internal.operators.single;
 
+import java.util.Arrays;
+
 import org.junit.Test;
 
 import io.reactivex.Single;
@@ -45,4 +47,21 @@ public void concat4() {
         .test()
         .assertResult(1, 2, 3, 4);
     }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatArray() {
+        for (int i = 1; i < 100; i++) {
+            Single<Integer>[] array = new Single[i];
+            
+            Arrays.fill(array, Single.just(1));
+            
+            Single.concatArray(array)
+            .test()
+            .assertSubscribed()
+            .assertValueCount(i)
+            .assertNoErrors()
+            .assertComplete();
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/util/ObservableToFlowabeTestSync.java b/src/test/java/io/reactivex/internal/util/ObservableToFlowabeTestSync.java
new file mode 100644
index 0000000000..ae007da4db
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/util/ObservableToFlowabeTestSync.java
@@ -0,0 +1,93 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.util;
+
+/**
+ * Utility class that lists tests related to Observable that is not present in Flowable tests.
+ */
+public class ObservableToFlowabeTestSync {
+// Uses Java 8 and is generally not relevant
+//    static void list(String basepath, String basepackage) throws Exception {
+//        File[] observables = new File(basepath + "observable/").listFiles();
+//
+//        int count = 0;
+//        
+//        for (File f : observables) {
+//            if (!f.getName().endsWith(".java")) {
+//                continue;
+//            }
+//            Class<?> clazz = Class.forName(basepackage + "observable." + f.getName().replace(".java", ""));
+//
+//            String cn = f.getName().replace(".java", "").replace("Observable", "Flowable");
+//            
+//            File f2 = new File(basepath + "/flowable/" + cn + ".java");
+//            
+//            if (!f2.exists()) {
+//                continue;
+//            }
+//            
+//            Class<?> clazz2 = Class.forName(basepackage + "flowable." + cn);
+//            
+//            Set<String> methods2 = new HashSet<String>();
+//            
+//            for (Method m : clazz2.getMethods()) {
+//                methods2.add(m.getName());
+//            }
+//            
+//            for (Method m : clazz.getMethods()) {
+//                if (!methods2.contains(m.getName()) && !methods2.contains(m.getName().replace("Observable", "Flowable"))) {
+//                    count++;
+//                    System.out.println();
+//                    System.out.print("java.lang.RuntimeException: missing > ");
+//                    System.out.println(m.getName());
+//                    System.out.print(" at ");
+//                    System.out.print(clazz.getName());
+//                    System.out.print(" (");
+//                    System.out.print(clazz.getSimpleName());
+//                    System.out.print(".java:");
+//                    
+//                    List<String> lines = Files.readAllLines(f.toPath());
+//                    
+//                    int j = 1;
+//                    for (int i = 1; i <= lines.size(); i++) {
+//                        if (lines.get(i - 1).contains("public void " + m.getName() + "(")) {
+//                            j = i;
+//                        }
+//                    }
+//                    System.out.print(j);
+//                    System.out.println(")");
+//                    
+//                    System.out.print(" at ");
+//                    System.out.print(clazz2.getName());
+//                    System.out.print(" (");
+//                    System.out.print(clazz2.getSimpleName());
+//                    
+//                    lines = Files.readAllLines(f2.toPath());
+//                    
+//                    System.out.print(".java:");
+//                    System.out.print(lines.size() - 1);
+//                    System.out.println(")");
+//                }
+//            }
+//        }
+//
+//        System.out.println();
+//        System.out.println(count);
+//    }
+//    
+//    public static void main(String[] args) throws Exception {
+////        list("src/test/java/io/reactivex/internal/operators/", "io.reactivex.internal.operators.");
+//        list("src/test/java/io/reactivex/", "io.reactivex.");
+//    }
+}
diff --git a/src/test/java/io/reactivex/observable/ObservableConcatTests.java b/src/test/java/io/reactivex/observable/ObservableConcatTests.java
index 0acc6c3a09..a4aa15dd56 100644
--- a/src/test/java/io/reactivex/observable/ObservableConcatTests.java
+++ b/src/test/java/io/reactivex/observable/ObservableConcatTests.java
@@ -39,7 +39,7 @@ public void testConcatSimple() {
     }
 
     @Test
-    public void testConcatWithNbpObservableOfNbpObservable() {
+    public void testConcatWithObservableOfObservable() {
         Observable<String> o1 = Observable.just("one", "two");
         Observable<String> o2 = Observable.just("three", "four");
         Observable<String> o3 = Observable.just("five", "six");
@@ -57,7 +57,7 @@ public void testConcatWithNbpObservableOfNbpObservable() {
     }
 
     @Test
-    public void testConcatWithIterableOfNbpObservable() {
+    public void testConcatWithIterableOfObservable() {
         Observable<String> o1 = Observable.just("one", "two");
         Observable<String> o2 = Observable.just("three", "four");
         Observable<String> o3 = Observable.just("five", "six");
diff --git a/src/test/java/io/reactivex/observable/ObservableDoOnTest.java b/src/test/java/io/reactivex/observable/ObservableDoOnTest.java
index 1318896001..da71aa5b46 100644
--- a/src/test/java/io/reactivex/observable/ObservableDoOnTest.java
+++ b/src/test/java/io/reactivex/observable/ObservableDoOnTest.java
@@ -101,6 +101,5 @@ public void run() {
         .test()
         .assertFailure(TestException.class);
         assertTrue(r.get());
-        
     }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/observable/ObservableNullTests.java b/src/test/java/io/reactivex/observable/ObservableNullTests.java
index c67b970e47..0a940ee83d 100644
--- a/src/test/java/io/reactivex/observable/ObservableNullTests.java
+++ b/src/test/java/io/reactivex/observable/ObservableNullTests.java
@@ -276,9 +276,8 @@ public void concatIterableOneIsNull() {
     }
     
     @Test(expected = NullPointerException.class)
-    public void concatNbpObservableNull() {
+    public void concatObservableNull() {
         Observable.concat((Observable<Observable<Object>>)null);
-
     }
 
     @Test(expected = NullPointerException.class)
@@ -688,7 +687,7 @@ public void accept(Object d) { }
     }
     
     @Test(expected = NullPointerException.class)
-    public void usingNbpObservableSupplierNull() {
+    public void usingObservableSupplierNull() {
         Observable.using(new Callable<Object>() {
             @Override
             public Object call() {
@@ -701,7 +700,7 @@ public void accept(Object d) { }
     }
     
     @Test(expected = NullPointerException.class)
-    public void usingNbpObservableSupplierReturnsNull() {
+    public void usingObservableSupplierReturnsNull() {
         Observable.using(new Callable<Object>() {
             @Override
             public Object call() {
@@ -776,7 +775,7 @@ public Object apply(Object[] a) {
     }
     
     @Test(expected = NullPointerException.class)
-    public void zipNbpObservableNull() {
+    public void zipObservableNull() {
         Observable.zip((Observable<Observable<Object>>)null, new Function<Object[], Object>() {
             @Override
             public Object apply(Object[] a) {
@@ -786,12 +785,12 @@ public Object apply(Object[] a) {
     }
     
     @Test(expected = NullPointerException.class)
-    public void zipNbpObservableFunctionNull() {
+    public void zipObservableFunctionNull() {
         Observable.zip((Observable.just(just1)), null);
     }
 
     @Test(expected = NullPointerException.class)
-    public void zipNbpObservableFunctionReturnsNull() {
+    public void zipObservableFunctionReturnsNull() {
         Observable.zip((Observable.just(just1)), new Function<Object[], Object>() {
             @Override
             public Object apply(Object[] a) {
@@ -1712,7 +1711,7 @@ public void onErrorResumeNextFunctionReturnsNull() {
     }
     
     @Test(expected = NullPointerException.class)
-    public void onErrorResumeNextNbpObservableNull() {
+    public void onErrorResumeNextObservableNull() {
         just1.onErrorResumeNext((Observable<Integer>)null);
     }
     
@@ -2007,7 +2006,7 @@ public void sampleSchedulerNull() {
     }
     
     @Test(expected = NullPointerException.class)
-    public void sampleNbpObservableNull() {
+    public void sampleObservableNull() {
         just1.sample(null);
     }
     
@@ -2162,7 +2161,7 @@ public void startWithSingleNull() {
     }
     
     @Test(expected = NullPointerException.class)
-    public void startWithNbpObservableNull() {
+    public void startWithObservableNull() {
         just1.startWith((Observable<Integer>)null);
     }
     
@@ -2282,7 +2281,7 @@ public void takeUntilPredicateNull() {
     }
     
     @Test(expected = NullPointerException.class)
-    public void takeUntilNbpObservableNull() {
+    public void takeUntilObservableNull() {
         just1.takeUntil((Observable<Integer>)null);
     }
     
@@ -2782,7 +2781,7 @@ public Object apply(Integer a, Integer b) {
     }
     
     @Test(expected = NullPointerException.class)
-    public void zipWithNbpObservableNull() {
+    public void zipWithObservableNull() {
         just1.zipWith((Observable<Integer>)null, new BiFunction<Integer, Integer, Object>() {
             @Override
             public Object apply(Integer a, Integer b) {
diff --git a/src/test/java/io/reactivex/observable/ObservableReduceTests.java b/src/test/java/io/reactivex/observable/ObservableReduceTests.java
index 1d0af7401f..96cc0e6f1f 100644
--- a/src/test/java/io/reactivex/observable/ObservableReduceTests.java
+++ b/src/test/java/io/reactivex/observable/ObservableReduceTests.java
@@ -83,13 +83,13 @@ public Movie apply(Movie t1, Movie t2) {
     public void reduceCovariance() {
         // must type it to <Movie>
         Observable<Movie> horrorMovies = Observable.<Movie> just(new HorrorMovie());
-        libraryFunctionActingOnMovieNbpObservables(horrorMovies);
+        libraryFunctionActingOnMovieObservables(horrorMovies);
     }
 
     /*
      * This accepts <Movie> instead of <? super Movie> since `reduce` can't handle covariants
      */
-    public void libraryFunctionActingOnMovieNbpObservables(Observable<Movie> obs) {
+    public void libraryFunctionActingOnMovieObservables(Observable<Movie> obs) {
 
         obs.reduce(new BiFunction<Movie, Movie, Movie>() {
             @Override
diff --git a/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java b/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
index c35a050796..f2b1db2629 100644
--- a/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
+++ b/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
@@ -20,12 +20,13 @@
 
 import org.junit.Test;
 
+import io.reactivex.*;
 import io.reactivex.Observable;
-import io.reactivex.ObservableOperator;
 import io.reactivex.Observer;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.observers.*;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subjects.PublishSubject;
 
 public class ObservableSubscriberTest {
@@ -189,4 +190,53 @@ public void methodTestNoCancel() {
         assertTrue(ps.hasObservers());
     }
 
-}
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void pluginNull() {
+        RxJavaPlugins.setOnObservableSubscribe(new BiFunction<Observable, Observer, Observer>() {
+            @Override
+            public Observer apply(Observable a, Observer b) throws Exception {
+                return null;
+            }
+        });
+        
+        try {
+            try {
+                
+                Observable.just(1).test();
+                fail("Should have thrown");
+            } catch (NullPointerException ex) {
+                assertEquals("Plugin returned null Observer", ex.getMessage());
+            }
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    static final class BadObservable extends Observable<Integer> {
+        @Override
+        protected void subscribeActual(Observer<? super Integer> s) {
+            throw new IllegalArgumentException();
+        }
+    }
+    
+    @Test
+    public void subscribeActualThrows() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        try {
+            try {
+                new BadObservable().test();
+                fail("Should have thrown!");
+            } catch (NullPointerException ex) {
+                if (!(ex.getCause() instanceof IllegalArgumentException)) {
+                    fail(ex.toString() + ": Should be NPE(IAE)");
+                }
+            }
+            
+            TestHelper.assertError(list, 0, IllegalArgumentException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/observable/ObservableTests.java b/src/test/java/io/reactivex/observable/ObservableTests.java
index 70e4941bb2..564b559271 100644
--- a/src/test/java/io/reactivex/observable/ObservableTests.java
+++ b/src/test/java/io/reactivex/observable/ObservableTests.java
@@ -214,10 +214,10 @@ public Integer apply(Integer t1, Integer t2) {
     }
 
     /**
-     * A reduce should fail with an NoSuchElementException if done on an empty NbpObservable.
+     * A reduce should fail with an NoSuchElementException if done on an empty Observable.
      */
     @Test(expected = NoSuchElementException.class)
-    public void testReduceWithEmptyNbpObservable() {
+    public void testReduceWithEmptyObservable() {
         Observable<Integer> o = Observable.range(1, 0);
         o.reduce(new BiFunction<Integer, Integer, Integer>() {
             @Override
@@ -236,12 +236,12 @@ public void accept(Integer t1) {
     }
 
     /**
-     * A reduce on an empty NbpObservable and a seed should just pass the seed through.
+     * A reduce on an empty Observable and a seed should just pass the seed through.
      * 
      * This is confirmed at https://github.com/ReactiveX/RxJava/issues/423#issuecomment-27642456
      */
     @Test
-    public void testReduceWithEmptyNbpObservableAndSeed() {
+    public void testReduceWithEmptyObservableAndSeed() {
         Observable<Integer> o = Observable.range(1, 0);
         int value = o.reduce(1, new BiFunction<Integer, Integer, Integer>() {
             @Override
@@ -309,7 +309,7 @@ public void testMaterializeDematerializeChaining() {
      * @throws InterruptedException if the test is interrupted
      */
     @Test
-    public void testCustomNbpObservableWithErrorInObserverAsynchronous() throws InterruptedException {
+    public void testCustomObservableWithErrorInObserverAsynchronous() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
         final AtomicInteger count = new AtomicInteger();
         final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
@@ -358,7 +358,7 @@ public void onNext(String v) {
      * Result: Passes
      */
     @Test
-    public void testCustomNbpObservableWithErrorInObserverSynchronous() {
+    public void testCustomObservableWithErrorInObserverSynchronous() {
         final AtomicInteger count = new AtomicInteger();
         final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
         
@@ -395,13 +395,13 @@ public void onNext(String v) {
     }
 
     /**
-     * The error from the user provided NbpObservable is handled by the subscribe try/catch because this is synchronous
+     * The error from the user provided Observable is handled by the subscribe try/catch because this is synchronous
      * 
      * 
      * Result: Passes
      */
     @Test
-    public void testCustomNbpObservableWithErrorInNbpObservableSynchronous() {
+    public void testCustomObservableWithErrorInObservableSynchronous() {
         final AtomicInteger count = new AtomicInteger();
         final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
         // FIXME custom built???
@@ -626,7 +626,7 @@ public void accept(String v) {
      * Rx Design Guidelines 5.2
      * 
      * "when calling the Subscribe method that only has an onNext argument, the OnError behavior will be
-     * to rethrow the exception on the thread that the message comes out from the NbpObservable.
+     * to rethrow the exception on the thread that the message comes out from the Observable.
      * The OnCompleted behavior in this case is to do nothing."
      */
     @Test
@@ -647,7 +647,7 @@ public void testErrorThrownWithoutErrorHandlerSynchronous() {
      * Rx Design Guidelines 5.2
      * 
      * "when calling the Subscribe method that only has an onNext argument, the OnError behavior will be
-     * to rethrow the exception on the thread that the message comes out from the NbpObservable.
+     * to rethrow the exception on the thread that the message comes out from the Observable.
      * The OnCompleted behavior in this case is to do nothing."
      * 
      * @throws InterruptedException
@@ -801,7 +801,7 @@ public void testContainsWithNull() {
     }
 
     @Test
-    public void testContainsWithEmptyNbpObservable() {
+    public void testContainsWithEmptyObservable() {
         Observable<Boolean> o = Observable.<String> empty().contains("a");
 
         Observer<Object> observer = TestHelper.mockObserver();
@@ -909,10 +909,10 @@ public void testAmbWith() {
 // FIXME Subscribers can't throw
 //    @Test(expected = OnErrorNotImplementedException.class)
 //    public void testSubscribeWithoutOnError() {
-//        NbpObservable<String> o = NbpObservable.just("a", "b").flatMap(new Func1<String, NbpObservable<String>>() {
+//        Observable<String> o = Observable.just("a", "b").flatMap(new Func1<String, Observable<String>>() {
 //            @Override
-//            public NbpObservable<String> call(String s) {
-//                return NbpObservable.error(new Exception("test"));
+//            public Observable<String> call(String s) {
+//                return Observable.error(new Exception("test"));
 //            }
 //        });
 //        o.subscribe();
@@ -997,7 +997,7 @@ public void testEmptyIsEmpty() {
 //    @Test // cf. https://github.com/ReactiveX/RxJava/issues/2599
 //    public void testSubscribingSubscriberAsObserverMaintainsSubscriptionChain() {
 //        NbpTestSubscriber<Object> subscriber = new NbpTestSubscriber<T>();
-//        Subscription subscription = NbpObservable.just("event").subscribe((Observer<Object>) subscriber);
+//        Subscription subscription = Observable.just("event").subscribe((Observer<Object>) subscriber);
 //        subscription.unsubscribe();
 //
 //        subscriber.assertUnsubscribed();
@@ -1006,7 +1006,7 @@ public void testEmptyIsEmpty() {
 // FIXME subscribers can't throw
 //    @Test(expected=OnErrorNotImplementedException.class)
 //    public void testForEachWithError() {
-//        NbpObservable.error(new Exception("boo"))
+//        Observable.error(new Exception("boo"))
 //        //
 //        .forEach(new Action1<Object>() {
 //            @Override
diff --git a/src/test/java/io/reactivex/observable/ObservableZipTests.java b/src/test/java/io/reactivex/observable/ObservableZipTests.java
index fea218f038..eb60badc7a 100644
--- a/src/test/java/io/reactivex/observable/ObservableZipTests.java
+++ b/src/test/java/io/reactivex/observable/ObservableZipTests.java
@@ -28,7 +28,7 @@
 public class ObservableZipTests {
 
     @Test
-    public void testZipNbpObservableOfNbpObservables() {
+    public void testZipObservableOfObservables() {
         ObservableEventStream.getEventStream("HTTP-ClusterB", 20)
                 .groupBy(new Function<Event, String>() {
                     @Override
@@ -79,19 +79,19 @@ public void testCovarianceOfZip() {
     }
 
     /**
-     * Occasionally zip may be invoked with 0 NbpObservables. Test that we don't block indefinitely instead
+     * Occasionally zip may be invoked with 0 observables. Test that we don't block indefinitely instead
      * of immediately invoking zip with 0 argument.
      * 
      * We now expect an NoSuchElementException since last() requires at least one value and nothing will be emitted.
      */
     @Test(expected = NoSuchElementException.class)
-    public void nonBlockingNbpObservable() {
+    public void nonBlockingObservable() {
 
         final Object invoked = new Object();
 
-        Collection<Observable<Object>> NbpObservables = Collections.emptyList();
+        Collection<Observable<Object>> observables = Collections.emptyList();
 
-        Observable<Object> result = Observable.zip(NbpObservables, new Function<Object[], Object>() {
+        Observable<Object> result = Observable.zip(observables, new Function<Object[], Object>() {
             @Override
             public Object apply(Object[] args) {
                 System.out.println("received: " + args);
