diff --git a/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
index f63a60858f..8f032748b6 100644
--- a/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
+++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
@@ -122,9 +122,9 @@ public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, Time
         Future<?> f;
         try {
             if (delayTime <= 0) {
-                f = executor.submit(run);
+                f = executor.submit(sr);
             } else {
-                f = executor.schedule(run, delayTime, unit);
+                f = executor.schedule(sr, delayTime, unit);
             }
             sr.setFuture(f);
         } catch (RejectedExecutionException ex) {
diff --git a/src/main/java/io/reactivex/subjects/AsyncSubject.java b/src/main/java/io/reactivex/subjects/AsyncSubject.java
index ef05b9fcc6..b409e17b66 100644
--- a/src/main/java/io/reactivex/subjects/AsyncSubject.java
+++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java
@@ -120,7 +120,8 @@ public boolean hasValue() {
     
     @Override
     public boolean hasComplete() {
-        return state.subscribers() == State.TERMINATED;
+        Object o = state.get();
+        return state.subscribers() == State.TERMINATED && !NotificationLite.isError(o);
     }
     
     @Override
@@ -132,7 +133,7 @@ public boolean hasThrowable() {
     public Throwable getThrowable() {
         Object o = state.get();
         if (NotificationLite.isError(o)) {
-            return (Throwable)o;
+            return NotificationLite.getError(o);
         }
         return null;
     }
@@ -151,7 +152,7 @@ public T getValue() {
     @SuppressWarnings("unchecked")
     public T[] getValues(T[] array) {
         Object o = state.get();
-        if (o != null && !NotificationLite.isError(o)) {
+        if (o != null && !NotificationLite.isError(o) && !NotificationLite.isComplete(o)) {
             int n = array.length;
             if (n == 0) {
                 array = Arrays.copyOf(array, 1);
@@ -160,6 +161,10 @@ public T getValue() {
             if (array.length > 1) {
                 array[1] = null;
             }
+        } else {
+            if (array.length != 0) {
+                array[0] = null;
+            }
         }
         return array;
     }
@@ -292,7 +297,9 @@ public void setValue(T value) {
                 } else
                 if (s == HAS_REQUEST_NO_VALUE) {
                     lazySet(HAS_REQUEST_HAS_VALUE); // setValue is called once, no need for CAS
-                    actual.onNext(value);
+                    if (value != null) {
+                        actual.onNext(value);
+                    }
                     actual.onComplete();
                 }
             }
@@ -332,7 +339,9 @@ public void request(long n) {
                     if (compareAndSet(NO_REQUEST_HAS_VALUE, HAS_REQUEST_HAS_VALUE)) {
                         @SuppressWarnings("unchecked")
                         T v = (T)state.get();
-                        actual.onNext(v);
+                        if (v != null) {
+                            actual.onNext(v);
+                        }
                         actual.onComplete();
                         return;
                     }
diff --git a/src/main/java/io/reactivex/subjects/BehaviorSubject.java b/src/main/java/io/reactivex/subjects/BehaviorSubject.java
index 106c8eb27c..e0ad51b7cb 100644
--- a/src/main/java/io/reactivex/subjects/BehaviorSubject.java
+++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.subjects;
 
+import java.lang.reflect.Array;
 import java.util.Objects;
 import java.util.concurrent.atomic.*;
 import java.util.concurrent.locks.StampedLock;
@@ -75,11 +76,16 @@ public void onComplete() {
     public boolean hasSubscribers() {
         return state.subscribers.length != 0;
     }
+    
+    
+    /* test support*/ int subscriberCount() {
+        return state.subscribers.length;
+    }
 
     @Override
     public Throwable getThrowable() {
         Object o = state.get();
-        if (NotificationLite.isComplete(o)) {
+        if (NotificationLite.isError(o)) {
             return NotificationLite.getError(o);
         }
         return null;
@@ -95,9 +101,10 @@ public T getValue() {
     }
     
     @Override
+    @SuppressWarnings("unchecked")
     public T[] getValues(T[] array) {
         Object o = state.get();
-        if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {
+        if (o == null || NotificationLite.isComplete(o) || NotificationLite.isError(o)) {
             if (array.length != 0) {
                 array[0] = null;
             }
@@ -109,6 +116,9 @@ public T getValue() {
             if (array.length != 1) {
                 array[1] = null;
             }
+        } else {
+            array = (T[])Array.newInstance(array.getClass().getComponentType(), 1);
+            array[0] = v;
         }
         return array;
     }
diff --git a/src/main/java/io/reactivex/subjects/ReplaySubject.java b/src/main/java/io/reactivex/subjects/ReplaySubject.java
index 892acd8db9..22718694ad 100644
--- a/src/main/java/io/reactivex/subjects/ReplaySubject.java
+++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java
@@ -55,6 +55,11 @@
         return createWithBuffer(buffer);
     }
 
+    /* test */ static <T> ReplaySubject<T> createUnbounded() {
+        SizeBoundReplayBuffer<T> buffer = new SizeBoundReplayBuffer<>(Integer.MAX_VALUE);
+        return createWithBuffer(buffer);
+    }
+
     public static <T> ReplaySubject<T> createWithTime(long maxAge, TimeUnit unit) {
         return createWithTime(maxAge, unit, Schedulers.trampoline());
     }
@@ -118,6 +123,10 @@ public boolean hasSubscribers() {
         return state.subscribers.length != 0;
     }
 
+    /* test */ int subscriberCount() {
+        return state.subscribers.length;
+    }
+
     @Override
     public Throwable getThrowable() {
         Object o = state.get();
@@ -154,6 +163,10 @@ public boolean hasValue() {
         return state.buffer.size() != 0;
     }
     
+    /* test*/ int size() {
+        return state.buffer.size();
+    }
+    
     static final class State<T> extends AtomicReference<Object> implements Publisher<T>, Subscriber<T> {
         /** */
         private static final long serialVersionUID = -4673197222000219014L;
@@ -187,8 +200,10 @@ public void subscribe(Subscriber<? super T> s) {
                 if (add(rs)) {
                     if (rs.cancelled) {
                         remove(rs);
+                        return;
                     }
                 }
+                buffer.replay(rs);
             }
         }
         
@@ -585,6 +600,7 @@ public SizeBoundReplayBuffer(int maxSize) {
 
         void trim() {
             if (size > maxSize) {
+                size--;
                 Node<Object> h = head;
                 head = h.get();
             }
@@ -598,7 +614,12 @@ public void add(T value) {
 
             tail = n;
             size++;
-            t.lazySet(n); // releases both the tail and size
+            /*
+             *  FIXME not sure why lazySet doesn't work here
+             *  (testReplaySubjectEmissionSubscriptionRace hangs) 
+             *  must be the lack of StoreLoad barrier?
+             */
+            t.set(n); // releases both the tail and size
             
             trim();
         }
@@ -664,6 +685,9 @@ public T getValue() {
                     i++;
                     h = next;
                 }
+                if (array.length > s) {
+                    array[s] = null;
+                }
             }
             
             return array;
@@ -737,9 +761,12 @@ public void replay(ReplaySubscription<T> rs) {
                     index = n;
                 }
                 
-                if (!unbounded) {
-                    r = ReplaySubscription.REQUESTED.addAndGet(rs, e);
+                if (e != 0L) {
+                    if (!unbounded) {
+                        r = ReplaySubscription.REQUESTED.addAndGet(rs, e);
+                    }
                 }
+                
                 if (index.get() != null && r != 0L) {
                     continue;
                 }
@@ -760,6 +787,10 @@ public int size() {
             while (s != Integer.MAX_VALUE) {
                 Node<Object> next = h.get();
                 if (next == null) {
+                    Object o = h.value;
+                    if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {
+                        s--;
+                    }
                     break;
                 }
                 s++;
@@ -796,6 +827,7 @@ public SizeAndTimeBoundReplayBuffer(int maxSize, long maxAge, TimeUnit unit, Sch
 
         void trim() {
             if (size > maxSize) {
+                size--;
                 TimedNode<Object> h = head;
                 head = h.get();
             }
@@ -849,7 +881,12 @@ public void add(T value) {
 
             tail = n;
             size++;
-            t.lazySet(n); // releases both the tail and size
+            /*
+             *  FIXME not sure why lazySet doesn't work here
+             *  (testReplaySubjectEmissionSubscriptionRace hangs) 
+             *  must be the lack of StoreLoad barrier?
+             */
+            t.set(n); // releases both the tail and size
             
             trim();
         }
@@ -916,6 +953,9 @@ public T getValue() {
                     i++;
                     h = next;
                 }
+                if (array.length > s) {
+                    array[s] = null;
+                }
             }
             
             return array;
@@ -934,6 +974,19 @@ public void replay(ReplaySubscription<T> rs) {
             TimedNode<Object> index = (TimedNode<Object>)rs.index;
             if (index == null) {
                 index = head;
+                if (!done) {
+                    // skip old entries
+                    long limit = scheduler.now(unit) - maxAge;
+                    TimedNode<Object> next = index.get();
+                    while (next != null) {
+                        long ts = next.time;
+                        if (ts > limit) {
+                            break;
+                        }
+                        index = next;
+                        next = index.get();
+                    }
+                }
             }
 
             for (;;) {
@@ -989,9 +1042,12 @@ public void replay(ReplaySubscription<T> rs) {
                     index = n;
                 }
                 
-                if (!unbounded) {
-                    r = ReplaySubscription.REQUESTED.addAndGet(rs, e);
+                if (e != 0L) {
+                    if (!unbounded) {
+                        r = ReplaySubscription.REQUESTED.addAndGet(rs, e);
+                    }
                 }
+                
                 if (index.get() != null && r != 0L) {
                     continue;
                 }
@@ -1012,6 +1068,10 @@ public int size() {
             while (s != Integer.MAX_VALUE) {
                 TimedNode<Object> next = h.get();
                 if (next == null) {
+                    Object o = h.value;
+                    if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {
+                        s--;
+                    }
                     break;
                 }
                 s++;
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java b/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java
index d8fb67ec5d..4f57b89862 100644
--- a/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java
+++ b/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java
@@ -131,8 +131,10 @@ public void testSimpleAsyncConcat() {
 
     @Test
     public void testNestedAsyncConcatLoop() throws Throwable {
-        for (int i = 0; i < 100; i++) {
-            System.out.println("testNestedAsyncConcat >> " + i);
+        for (int i = 0; i < 500; i++) {
+            if (i % 10 == 0) {
+                System.out.println("testNestedAsyncConcat >> " + i);
+            }
             testNestedAsyncConcat();
         }
     }
@@ -151,6 +153,9 @@ public void testNestedAsyncConcat() throws Throwable {
 
         final AtomicReference<Thread> parent = new AtomicReference<>();
         final CountDownLatch parentHasStarted = new CountDownLatch(1);
+        final CountDownLatch parentHasFinished = new CountDownLatch(1);
+        
+        
         Observable<Observable<String>> observableOfObservables = Observable.create(new Publisher<Observable<String>>() {
 
             @Override
@@ -198,6 +203,7 @@ public void run() {
                         } finally {
                             System.out.println("Done parent Observable");
                             observer.onComplete();
+                            parentHasFinished.countDown();
                         }
                     }
                 }));
@@ -246,6 +252,15 @@ public void run() {
             throw new RuntimeException("failed waiting on threads", e);
         }
 
+        try {
+            // wait for the parent to complete
+            if (!parentHasFinished.await(5, TimeUnit.SECONDS)) {
+                fail("Parent didn't finish within the time limit");
+            }
+        } catch (Throwable e) {
+            throw new RuntimeException("failed waiting on threads", e);
+        }
+        
         inOrder.verify(observer, times(1)).onNext("seven");
         inOrder.verify(observer, times(1)).onNext("eight");
         inOrder.verify(observer, times(1)).onNext("nine");
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorZipTest.java b/src/test/java/io/reactivex/internal/operators/OperatorZipTest.java
index fea8b7d942..7c7f4f594c 100644
--- a/src/test/java/io/reactivex/internal/operators/OperatorZipTest.java
+++ b/src/test/java/io/reactivex/internal/operators/OperatorZipTest.java
@@ -1,3 +1,16 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
 package io.reactivex.internal.operators;
 
 import static org.junit.Assert.*;
diff --git a/src/test/java/io/reactivex/subjects/AsyncSubjectTest.java b/src/test/java/io/reactivex/subjects/AsyncSubjectTest.java
new file mode 100644
index 0000000000..a1bb4db56b
--- /dev/null
+++ b/src/test/java/io/reactivex/subjects/AsyncSubjectTest.java
@@ -0,0 +1,382 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.subjects;
+
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.*;
+import static org.mockito.Mockito.*;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+
+import org.junit.*;
+import org.mockito.*;
+import org.reactivestreams.Subscriber;
+
+import io.reactivex.TestHelper;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class AsyncSubjectTest {
+
+    private final Throwable testException = new Throwable();
+
+    @Test
+    public void testNeverCompleted() {
+        AsyncSubject<String> subject = AsyncSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onNext("two");
+        subject.onNext("three");
+
+        verify(observer, Mockito.never()).onNext(anyString());
+        verify(observer, Mockito.never()).onError(testException);
+        verify(observer, Mockito.never()).onComplete();
+    }
+
+    @Test
+    public void testCompleted() {
+        AsyncSubject<String> subject = AsyncSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onNext("two");
+        subject.onNext("three");
+        subject.onComplete();
+
+        verify(observer, times(1)).onNext("three");
+        verify(observer, Mockito.never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    @Ignore("Null values not allowed")
+    public void testNull() {
+        AsyncSubject<String> subject = AsyncSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext(null);
+        subject.onComplete();
+
+        verify(observer, times(1)).onNext(null);
+        verify(observer, Mockito.never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testSubscribeAfterCompleted() {
+        AsyncSubject<String> subject = AsyncSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+
+        subject.onNext("one");
+        subject.onNext("two");
+        subject.onNext("three");
+        subject.onComplete();
+
+        subject.subscribe(observer);
+
+        verify(observer, times(1)).onNext("three");
+        verify(observer, Mockito.never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testSubscribeAfterError() {
+        AsyncSubject<String> subject = AsyncSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+
+        subject.onNext("one");
+        subject.onNext("two");
+        subject.onNext("three");
+
+        RuntimeException re = new RuntimeException("failed");
+        subject.onError(re);
+
+        subject.subscribe(observer);
+
+        verify(observer, times(1)).onError(re);
+        verify(observer, Mockito.never()).onNext(any(String.class));
+        verify(observer, Mockito.never()).onComplete();
+    }
+
+    @Test
+    public void testError() {
+        AsyncSubject<String> subject = AsyncSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onNext("two");
+        subject.onNext("three");
+        subject.onError(testException);
+        subject.onNext("four");
+        subject.onError(new Throwable());
+        subject.onComplete();
+
+        verify(observer, Mockito.never()).onNext(anyString());
+        verify(observer, times(1)).onError(testException);
+        verify(observer, Mockito.never()).onComplete();
+    }
+
+    @Test
+    public void testUnsubscribeBeforeCompleted() {
+        AsyncSubject<String> subject = AsyncSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        subject.subscribe(ts);
+
+        subject.onNext("one");
+        subject.onNext("two");
+
+        ts.dispose();
+
+        verify(observer, Mockito.never()).onNext(anyString());
+        verify(observer, Mockito.never()).onError(any(Throwable.class));
+        verify(observer, Mockito.never()).onComplete();
+
+        subject.onNext("three");
+        subject.onComplete();
+
+        verify(observer, Mockito.never()).onNext(anyString());
+        verify(observer, Mockito.never()).onError(any(Throwable.class));
+        verify(observer, Mockito.never()).onComplete();
+    }
+
+    @Test
+    public void testEmptySubjectCompleted() {
+        AsyncSubject<String> subject = AsyncSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onComplete();
+
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, never()).onNext(null);
+        inOrder.verify(observer, never()).onNext(any(String.class));
+        inOrder.verify(observer, times(1)).onComplete();
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    /**
+     * Can receive timeout if subscribe never receives an onError/onCompleted ... which reveals a race condition.
+     */
+    @Test(timeout = 10000)
+    public void testSubscribeCompletionRaceCondition() {
+        /*
+         * With non-threadsafe code this fails most of the time on my dev laptop and is non-deterministic enough
+         * to act as a unit test to the race conditions.
+         * 
+         * With the synchronization code in place I can not get this to fail on my laptop.
+         */
+        for (int i = 0; i < 50; i++) {
+            final AsyncSubject<String> subject = AsyncSubject.create();
+            final AtomicReference<String> value1 = new AtomicReference<>();
+
+            subject.subscribe(new Consumer<String>() {
+
+                @Override
+                public void accept(String t1) {
+                    try {
+                        // simulate a slow observer
+                        Thread.sleep(50);
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                    value1.set(t1);
+                }
+
+            });
+
+            Thread t1 = new Thread(new Runnable() {
+
+                @Override
+                public void run() {
+                    subject.onNext("value");
+                    subject.onComplete();
+                }
+            });
+
+            SubjectSubscriberThread t2 = new SubjectSubscriberThread(subject);
+            SubjectSubscriberThread t3 = new SubjectSubscriberThread(subject);
+            SubjectSubscriberThread t4 = new SubjectSubscriberThread(subject);
+            SubjectSubscriberThread t5 = new SubjectSubscriberThread(subject);
+
+            t2.start();
+            t3.start();
+            t1.start();
+            t4.start();
+            t5.start();
+            try {
+                t1.join();
+                t2.join();
+                t3.join();
+                t4.join();
+                t5.join();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+
+            assertEquals("value", value1.get());
+            assertEquals("value", t2.value.get());
+            assertEquals("value", t3.value.get());
+            assertEquals("value", t4.value.get());
+            assertEquals("value", t5.value.get());
+        }
+
+    }
+
+    private static class SubjectSubscriberThread extends Thread {
+
+        private final AsyncSubject<String> subject;
+        private final AtomicReference<String> value = new AtomicReference<>();
+
+        public SubjectSubscriberThread(AsyncSubject<String> subject) {
+            this.subject = subject;
+        }
+
+        @Override
+        public void run() {
+            try {
+                // a timeout exception will happen if we don't get a terminal state 
+                String v = subject.timeout(2000, TimeUnit.MILLISECONDS).toBlocking().single();
+                value.set(v);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+    
+    // FIXME subscriber methods are not allowed to throw
+//    @Test
+//    public void testOnErrorThrowsDoesntPreventDelivery() {
+//        AsyncSubject<String> ps = AsyncSubject.create();
+//
+//        ps.subscribe();
+//        TestSubscriber<String> ts = new TestSubscriber<>();
+//        ps.subscribe(ts);
+//
+//        try {
+//            ps.onError(new RuntimeException("an exception"));
+//            fail("expect OnErrorNotImplementedException");
+//        } catch (OnErrorNotImplementedException e) {
+//            // ignore
+//        }
+//        // even though the onError above throws we should still receive it on the other subscriber 
+//        assertEquals(1, ts.getOnErrorEvents().size());
+//    }
+    
+    
+    // FIXME subscriber methods are not allowed to throw
+//    /**
+//     * This one has multiple failures so should get a CompositeException
+//     */
+//    @Test
+//    public void testOnErrorThrowsDoesntPreventDelivery2() {
+//        AsyncSubject<String> ps = AsyncSubject.create();
+//
+//        ps.subscribe();
+//        ps.subscribe();
+//        TestSubscriber<String> ts = new TestSubscriber<>();
+//        ps.subscribe(ts);
+//        ps.subscribe();
+//        ps.subscribe();
+//        ps.subscribe();
+//
+//        try {
+//            ps.onError(new RuntimeException("an exception"));
+//            fail("expect OnErrorNotImplementedException");
+//        } catch (CompositeException e) {
+//            // we should have 5 of them
+//            assertEquals(5, e.getExceptions().size());
+//        }
+//        // even though the onError above throws we should still receive it on the other subscriber 
+//        assertEquals(1, ts.getOnErrorEvents().size());
+//    }
+
+    @Test
+    public void testCurrentStateMethodsNormal() {
+        AsyncSubject<Object> as = AsyncSubject.create();
+        
+        assertFalse(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getValue());
+        assertNull(as.getThrowable());
+        
+        as.onNext(1);
+        
+        assertTrue(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertEquals(1, as.getValue());
+        assertNull(as.getThrowable());
+        
+        as.onComplete();
+        assertTrue(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertTrue(as.hasComplete());
+        assertEquals(1, as.getValue());
+        assertNull(as.getThrowable());
+    }
+    
+    @Test
+    public void testCurrentStateMethodsEmpty() {
+        AsyncSubject<Object> as = AsyncSubject.create();
+        
+        assertFalse(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getValue());
+        assertNull(as.getThrowable());
+        
+        as.onComplete();
+        
+        assertFalse(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertTrue(as.hasComplete());
+        assertNull(as.getValue());
+        assertNull(as.getThrowable());
+    }
+    @Test
+    public void testCurrentStateMethodsError() {
+        AsyncSubject<Object> as = AsyncSubject.create();
+        
+        assertFalse(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getValue());
+        assertNull(as.getThrowable());
+        
+        as.onError(new TestException());
+        
+        assertFalse(as.hasValue());
+        assertTrue(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getValue());
+        assertTrue(as.getThrowable() instanceof TestException);
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/subjects/BehaviorSubjectTest.java b/src/test/java/io/reactivex/subjects/BehaviorSubjectTest.java
new file mode 100644
index 0000000000..f7d66d6b0e
--- /dev/null
+++ b/src/test/java/io/reactivex/subjects/BehaviorSubjectTest.java
@@ -0,0 +1,562 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.subjects;
+
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Function;
+
+import org.junit.*;
+import org.mockito.*;
+import org.reactivestreams.Subscriber;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class BehaviorSubjectTest {
+
+    private final Throwable testException = new Throwable();
+
+    @Test
+    public void testThatSubscriberReceivesDefaultValueAndSubsequentEvents() {
+        BehaviorSubject<String> subject = BehaviorSubject.createDefault("default");
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onNext("two");
+        subject.onNext("three");
+
+        verify(observer, times(1)).onNext("default");
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onNext("two");
+        verify(observer, times(1)).onNext("three");
+        verify(observer, Mockito.never()).onError(testException);
+        verify(observer, Mockito.never()).onComplete();
+    }
+
+    @Test
+    public void testThatSubscriberReceivesLatestAndThenSubsequentEvents() {
+        BehaviorSubject<String> subject = BehaviorSubject.createDefault("default");
+
+        subject.onNext("one");
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("two");
+        subject.onNext("three");
+
+        verify(observer, Mockito.never()).onNext("default");
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onNext("two");
+        verify(observer, times(1)).onNext("three");
+        verify(observer, Mockito.never()).onError(testException);
+        verify(observer, Mockito.never()).onComplete();
+    }
+
+    @Test
+    public void testSubscribeThenOnComplete() {
+        BehaviorSubject<String> subject = BehaviorSubject.createDefault("default");
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onComplete();
+
+        verify(observer, times(1)).onNext("default");
+        verify(observer, times(1)).onNext("one");
+        verify(observer, Mockito.never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testSubscribeToCompletedOnlyEmitsOnComplete() {
+        BehaviorSubject<String> subject = BehaviorSubject.createDefault("default");
+        subject.onNext("one");
+        subject.onComplete();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        verify(observer, never()).onNext("default");
+        verify(observer, never()).onNext("one");
+        verify(observer, Mockito.never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testSubscribeToErrorOnlyEmitsOnError() {
+        BehaviorSubject<String> subject = BehaviorSubject.createDefault("default");
+        subject.onNext("one");
+        RuntimeException re = new RuntimeException("test error");
+        subject.onError(re);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        verify(observer, never()).onNext("default");
+        verify(observer, never()).onNext("one");
+        verify(observer, times(1)).onError(re);
+        verify(observer, never()).onComplete();
+    }
+
+    @Test
+    public void testCompletedStopsEmittingData() {
+        BehaviorSubject<Integer> channel = BehaviorSubject.createDefault(2013);
+        Subscriber<Object> observerA = TestHelper.mockSubscriber();
+        Subscriber<Object> observerB = TestHelper.mockSubscriber();
+        Subscriber<Object> observerC = TestHelper.mockSubscriber();
+
+        TestSubscriber<Object> ts = new TestSubscriber<>(observerA);
+        
+        channel.subscribe(ts);
+        channel.subscribe(observerB);
+
+        InOrder inOrderA = inOrder(observerA);
+        InOrder inOrderB = inOrder(observerB);
+        InOrder inOrderC = inOrder(observerC);
+
+        inOrderA.verify(observerA).onNext(2013);
+        inOrderB.verify(observerB).onNext(2013);
+
+        channel.onNext(42);
+
+        inOrderA.verify(observerA).onNext(42);
+        inOrderB.verify(observerB).onNext(42);
+
+        ts.dispose();
+        inOrderA.verifyNoMoreInteractions();
+
+        channel.onNext(4711);
+
+        inOrderB.verify(observerB).onNext(4711);
+
+        channel.onComplete();
+
+        inOrderB.verify(observerB).onComplete();
+
+        channel.subscribe(observerC);
+
+        inOrderC.verify(observerC).onComplete();
+
+        channel.onNext(13);
+
+        inOrderB.verifyNoMoreInteractions();
+        inOrderC.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testCompletedAfterErrorIsNotSent() {
+        BehaviorSubject<String> subject = BehaviorSubject.createDefault("default");
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onError(testException);
+        subject.onNext("two");
+        subject.onComplete();
+
+        verify(observer, times(1)).onNext("default");
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onError(testException);
+        verify(observer, never()).onNext("two");
+        verify(observer, never()).onComplete();
+    }
+
+    @Test
+    public void testCompletedAfterErrorIsNotSent2() {
+        BehaviorSubject<String> subject = BehaviorSubject.createDefault("default");
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onError(testException);
+        subject.onNext("two");
+        subject.onComplete();
+
+        verify(observer, times(1)).onNext("default");
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onError(testException);
+        verify(observer, never()).onNext("two");
+        verify(observer, never()).onComplete();
+
+        Subscriber<Object> o2 = TestHelper.mockSubscriber();
+        subject.subscribe(o2);
+        verify(o2, times(1)).onError(testException);
+        verify(o2, never()).onNext(any());
+        verify(o2, never()).onComplete();
+    }
+
+    @Test
+    public void testCompletedAfterErrorIsNotSent3() {
+        BehaviorSubject<String> subject = BehaviorSubject.createDefault("default");
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onComplete();
+        subject.onNext("two");
+        subject.onComplete();
+
+        verify(observer, times(1)).onNext("default");
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onComplete();
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, never()).onNext("two");
+
+        Subscriber<Object> o2 = TestHelper.mockSubscriber();
+        subject.subscribe(o2);
+        verify(o2, times(1)).onComplete();
+        verify(o2, never()).onNext(any());
+        verify(observer, never()).onError(any(Throwable.class));
+    }
+    
+    @Test(timeout = 1000)
+    public void testUnsubscriptionCase() {
+        BehaviorSubject<String> src = BehaviorSubject.createDefault("null"); // FIXME was plain null which is not allowed
+        
+        for (int i = 0; i < 10; i++) {
+            final Subscriber<Object> o = TestHelper.mockSubscriber();
+            InOrder inOrder = inOrder(o);
+            String v = "" + i;
+            src.onNext(v);
+            System.out.printf("Turn: %d%n", i);
+            src.first()
+                .flatMap(new Function<String, Observable<String>>() {
+
+                    @Override
+                    public Observable<String> apply(String t1) {
+                        return Observable.just(t1 + ", " + t1);
+                    }
+                })
+                .subscribe(new Observer<String>() {
+                    @Override
+                    public void onNext(String t) {
+                        o.onNext(t);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        o.onError(e);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        o.onComplete();
+                    }
+                });
+            inOrder.verify(o).onNext(v + ", " + v);
+            inOrder.verify(o).onComplete();
+            verify(o, never()).onError(any(Throwable.class));
+        }
+    }
+    @Test
+    public void testStartEmpty() {
+        BehaviorSubject<Integer> source = BehaviorSubject.create();
+        final Subscriber<Object> o = TestHelper.mockSubscriber();
+        InOrder inOrder = inOrder(o);
+        
+        source.subscribe(o);
+        
+        inOrder.verify(o, never()).onNext(any());
+        inOrder.verify(o, never()).onComplete();
+        
+        source.onNext(1);
+        
+        source.onComplete();
+        
+        source.onNext(2);
+        
+        verify(o, never()).onError(any(Throwable.class));
+
+        inOrder.verify(o).onNext(1);
+        inOrder.verify(o).onComplete();
+        inOrder.verifyNoMoreInteractions();
+        
+        
+    }
+    @Test
+    public void testStartEmptyThenAddOne() {
+        BehaviorSubject<Integer> source = BehaviorSubject.create();
+        final Subscriber<Object> o = TestHelper.mockSubscriber();
+        InOrder inOrder = inOrder(o);
+
+        source.onNext(1);
+
+        source.subscribe(o);
+
+        inOrder.verify(o).onNext(1);
+
+        source.onComplete();
+
+        source.onNext(2);
+
+        inOrder.verify(o).onComplete();
+        inOrder.verifyNoMoreInteractions();
+        
+        verify(o, never()).onError(any(Throwable.class));
+        
+    }
+    @Test
+    public void testStartEmptyCompleteWithOne() {
+        BehaviorSubject<Integer> source = BehaviorSubject.create();
+        final Subscriber<Object> o = TestHelper.mockSubscriber();
+
+        source.onNext(1);
+        source.onComplete();
+
+        source.onNext(2);
+
+        source.subscribe(o);
+
+        verify(o).onComplete();
+        verify(o, never()).onError(any(Throwable.class));
+        verify(o, never()).onNext(any());
+    }
+    
+    @Test
+    public void testTakeOneSubscriber() {
+        BehaviorSubject<Integer> source = BehaviorSubject.createDefault(1);
+        final Subscriber<Object> o = TestHelper.mockSubscriber();
+        
+        source.take(1).subscribe(o);
+        
+        verify(o).onNext(1);
+        verify(o).onComplete();
+        verify(o, never()).onError(any(Throwable.class));
+        
+        assertEquals(0, source.subscriberCount());
+        assertFalse(source.hasSubscribers());
+    }
+    
+    // FIXME RS subscribers are not allowed to throw
+//    @Test
+//    public void testOnErrorThrowsDoesntPreventDelivery() {
+//        BehaviorSubject<String> ps = BehaviorSubject.create();
+//
+//        ps.subscribe();
+//        TestSubscriber<String> ts = new TestSubscriber<>();
+//        ps.subscribe(ts);
+//
+//        try {
+//            ps.onError(new RuntimeException("an exception"));
+//            fail("expect OnErrorNotImplementedException");
+//        } catch (OnErrorNotImplementedException e) {
+//            // ignore
+//        }
+//        // even though the onError above throws we should still receive it on the other subscriber 
+//        assertEquals(1, ts.getOnErrorEvents().size());
+//    }
+    
+    // FIXME RS subscribers are not allowed to throw
+//    /**
+//     * This one has multiple failures so should get a CompositeException
+//     */
+//    @Test
+//    public void testOnErrorThrowsDoesntPreventDelivery2() {
+//        BehaviorSubject<String> ps = BehaviorSubject.create();
+//
+//        ps.subscribe();
+//        ps.subscribe();
+//        TestSubscriber<String> ts = new TestSubscriber<String>();
+//        ps.subscribe(ts);
+//        ps.subscribe();
+//        ps.subscribe();
+//        ps.subscribe();
+//
+//        try {
+//            ps.onError(new RuntimeException("an exception"));
+//            fail("expect OnErrorNotImplementedException");
+//        } catch (CompositeException e) {
+//            // we should have 5 of them
+//            assertEquals(5, e.getExceptions().size());
+//        }
+//        // even though the onError above throws we should still receive it on the other subscriber 
+//        assertEquals(1, ts.getOnErrorEvents().size());
+//    }
+    @Test
+    public void testEmissionSubscriptionRace() throws Exception {
+        Scheduler s = Schedulers.io();
+        Scheduler.Worker worker = Schedulers.io().createWorker();
+        try {
+            for (int i = 0; i < 50000; i++) {
+                if (i % 1000 == 0) {
+                    System.out.println(i);
+                }
+                final BehaviorSubject<Object> rs = BehaviorSubject.create();
+                
+                final CountDownLatch finish = new CountDownLatch(1); 
+                final CountDownLatch start = new CountDownLatch(1); 
+                
+                worker.schedule(new Runnable() {
+                    @Override
+                    public void run() {
+                        try {
+                            start.await();
+                        } catch (Exception e1) {
+                            e1.printStackTrace();
+                        }
+                        rs.onNext(1);
+                    }
+                });
+                
+                final AtomicReference<Object> o = new AtomicReference<>();
+                
+                rs.subscribeOn(s).observeOn(Schedulers.io())
+                .subscribe(new Observer<Object>() {
+    
+                    @Override
+                    public void onComplete() {
+                        o.set(-1);
+                        finish.countDown();
+                    }
+    
+                    @Override
+                    public void onError(Throwable e) {
+                        o.set(e);
+                        finish.countDown();
+                    }
+    
+                    @Override
+                    public void onNext(Object t) {
+                        o.set(t);
+                        finish.countDown();
+                    }
+                    
+                });
+                start.countDown();
+                
+                if (!finish.await(5, TimeUnit.SECONDS)) {
+                    System.out.println(o.get());
+                    System.out.println(rs.hasSubscribers());
+                    rs.onComplete();
+                    Assert.fail("Timeout @ " + i);
+                    break;
+                } else {
+                    Assert.assertEquals(1, o.get());
+                    worker.schedule(new Runnable() {
+                        @Override
+                        public void run() {
+                            rs.onComplete();
+                        }
+                    });
+                }
+            }
+        } finally {
+            worker.dispose();
+        }
+    }
+    
+    @Test
+    public void testCurrentStateMethodsNormalEmptyStart() {
+        BehaviorSubject<Object> as = BehaviorSubject.create();
+        
+        assertFalse(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getValue());
+        assertNull(as.getThrowable());
+        
+        as.onNext(1);
+        
+        assertTrue(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertEquals(1, as.getValue());
+        assertNull(as.getThrowable());
+        
+        as.onComplete();
+        
+        assertFalse(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertTrue(as.hasComplete());
+        assertNull(as.getValue());
+        assertNull(as.getThrowable());
+    }
+    
+    @Test
+    public void testCurrentStateMethodsNormalSomeStart() {
+        BehaviorSubject<Object> as = BehaviorSubject.createDefault((Object)1);
+        
+        assertTrue(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertEquals(1, as.getValue());
+        assertNull(as.getThrowable());
+        
+        as.onNext(2);
+        
+        assertTrue(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertEquals(2, as.getValue());
+        assertNull(as.getThrowable());
+        
+        as.onComplete();
+        assertFalse(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertTrue(as.hasComplete());
+        assertNull(as.getValue());
+        assertNull(as.getThrowable());
+    }
+    
+    @Test
+    public void testCurrentStateMethodsEmpty() {
+        BehaviorSubject<Object> as = BehaviorSubject.create();
+        
+        assertFalse(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getValue());
+        assertNull(as.getThrowable());
+        
+        as.onComplete();
+        
+        assertFalse(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertTrue(as.hasComplete());
+        assertNull(as.getValue());
+        assertNull(as.getThrowable());
+    }
+    @Test
+    public void testCurrentStateMethodsError() {
+        BehaviorSubject<Object> as = BehaviorSubject.create();
+        
+        assertFalse(as.hasValue());
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getValue());
+        assertNull(as.getThrowable());
+        
+        as.onError(new TestException());
+        
+        assertFalse(as.hasValue());
+        assertTrue(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getValue());
+        assertTrue(as.getThrowable() instanceof TestException);
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/subjects/PublishSubjectTest.java b/src/test/java/io/reactivex/subjects/PublishSubjectTest.java
new file mode 100644
index 0000000000..3d9ee4464e
--- /dev/null
+++ b/src/test/java/io/reactivex/subjects/PublishSubjectTest.java
@@ -0,0 +1,429 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.subjects;
+
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
+
+import java.util.ArrayList;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.*;
+
+import org.junit.Test;
+import org.mockito.*;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class PublishSubjectTest {
+
+    @Test
+    public void testCompleted() {
+        PublishSubject<String> subject = PublishSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onNext("two");
+        subject.onNext("three");
+        subject.onComplete();
+
+        Subscriber<String> anotherSubscriber = TestHelper.mockSubscriber();
+        subject.subscribe(anotherSubscriber);
+
+        subject.onNext("four");
+        subject.onComplete();
+        subject.onError(new Throwable());
+
+        assertCompletedSubscriber(observer);
+        // todo bug?            assertNeverSubscriber(anotherSubscriber);
+    }
+
+    @Test
+    public void testCompletedStopsEmittingData() {
+        PublishSubject<Object> channel = PublishSubject.create();
+        Subscriber<Object> observerA = TestHelper.mockSubscriber();
+        Subscriber<Object> observerB = TestHelper.mockSubscriber();
+        Subscriber<Object> observerC = TestHelper.mockSubscriber();
+
+        TestSubscriber<Object> ts = new TestSubscriber<>(observerA);
+        
+        channel.subscribe(ts);
+        channel.subscribe(observerB);
+
+        InOrder inOrderA = inOrder(observerA);
+        InOrder inOrderB = inOrder(observerB);
+        InOrder inOrderC = inOrder(observerC);
+
+        channel.onNext(42);
+
+        inOrderA.verify(observerA).onNext(42);
+        inOrderB.verify(observerB).onNext(42);
+
+        ts.dispose();
+        inOrderA.verifyNoMoreInteractions();
+
+        channel.onNext(4711);
+
+        inOrderB.verify(observerB).onNext(4711);
+
+        channel.onComplete();
+
+        inOrderB.verify(observerB).onComplete();
+
+        channel.subscribe(observerC);
+
+        inOrderC.verify(observerC).onComplete();
+
+        channel.onNext(13);
+
+        inOrderB.verifyNoMoreInteractions();
+        inOrderC.verifyNoMoreInteractions();
+    }
+
+    private void assertCompletedSubscriber(Subscriber<String> observer) {
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onNext("two");
+        verify(observer, times(1)).onNext("three");
+        verify(observer, Mockito.never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testError() {
+        PublishSubject<String> subject = PublishSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onNext("two");
+        subject.onNext("three");
+        subject.onError(testException);
+
+        Subscriber<String> anotherSubscriber = TestHelper.mockSubscriber();
+        subject.subscribe(anotherSubscriber);
+
+        subject.onNext("four");
+        subject.onError(new Throwable());
+        subject.onComplete();
+
+        assertErrorSubscriber(observer);
+        // todo bug?            assertNeverSubscriber(anotherSubscriber);
+    }
+
+    private void assertErrorSubscriber(Subscriber<String> observer) {
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onNext("two");
+        verify(observer, times(1)).onNext("three");
+        verify(observer, times(1)).onError(testException);
+        verify(observer, Mockito.never()).onComplete();
+    }
+
+    @Test
+    public void testSubscribeMidSequence() {
+        PublishSubject<String> subject = PublishSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onNext("two");
+
+        assertObservedUntilTwo(observer);
+
+        Subscriber<String> anotherSubscriber = TestHelper.mockSubscriber();
+        subject.subscribe(anotherSubscriber);
+
+        subject.onNext("three");
+        subject.onComplete();
+
+        assertCompletedSubscriber(observer);
+        assertCompletedStartingWithThreeSubscriber(anotherSubscriber);
+    }
+
+    private void assertCompletedStartingWithThreeSubscriber(Subscriber<String> observer) {
+        verify(observer, Mockito.never()).onNext("one");
+        verify(observer, Mockito.never()).onNext("two");
+        verify(observer, times(1)).onNext("three");
+        verify(observer, Mockito.never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testUnsubscribeFirstSubscriber() {
+        PublishSubject<String> subject = PublishSubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        subject.subscribe(ts);
+
+        subject.onNext("one");
+        subject.onNext("two");
+
+        ts.dispose();
+        assertObservedUntilTwo(observer);
+
+        Subscriber<String> anotherSubscriber = TestHelper.mockSubscriber();
+        subject.subscribe(anotherSubscriber);
+
+        subject.onNext("three");
+        subject.onComplete();
+
+        assertObservedUntilTwo(observer);
+        assertCompletedStartingWithThreeSubscriber(anotherSubscriber);
+    }
+
+    private void assertObservedUntilTwo(Subscriber<String> observer) {
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onNext("two");
+        verify(observer, Mockito.never()).onNext("three");
+        verify(observer, Mockito.never()).onError(any(Throwable.class));
+        verify(observer, Mockito.never()).onComplete();
+    }
+
+    @Test
+    public void testNestedSubscribe() {
+        final PublishSubject<Integer> s = PublishSubject.create();
+
+        final AtomicInteger countParent = new AtomicInteger();
+        final AtomicInteger countChildren = new AtomicInteger();
+        final AtomicInteger countTotal = new AtomicInteger();
+
+        final ArrayList<String> list = new ArrayList<>();
+
+        s.flatMap(new Function<Integer, Observable<String>>() {
+
+            @Override
+            public Observable<String> apply(final Integer v) {
+                countParent.incrementAndGet();
+
+                // then subscribe to subject again (it will not receive the previous value)
+                return s.map(new Function<Integer, String>() {
+
+                    @Override
+                    public String apply(Integer v2) {
+                        countChildren.incrementAndGet();
+                        return "Parent: " + v + " Child: " + v2;
+                    }
+
+                });
+            }
+
+        }).subscribe(new Consumer<String>() {
+
+            @Override
+            public void accept(String v) {
+                countTotal.incrementAndGet();
+                list.add(v);
+            }
+
+        });
+
+        for (int i = 0; i < 10; i++) {
+            s.onNext(i);
+        }
+        s.onComplete();
+
+        //            System.out.println("countParent: " + countParent.get());
+        //            System.out.println("countChildren: " + countChildren.get());
+        //            System.out.println("countTotal: " + countTotal.get());
+
+        // 9+8+7+6+5+4+3+2+1+0 == 45
+        assertEquals(45, list.size());
+    }
+
+    /**
+     * Should be able to unsubscribe all Subscribers, have it stop emitting, then subscribe new ones and it start emitting again.
+     */
+    @Test
+    public void testReSubscribe() {
+        final PublishSubject<Integer> ps = PublishSubject.create();
+
+        Subscriber<Integer> o1 = TestHelper.mockSubscriber();
+        TestSubscriber<Integer> ts = new TestSubscriber<>(o1);
+        ps.subscribe(ts);
+
+        // emit
+        ps.onNext(1);
+
+        // validate we got it
+        InOrder inOrder1 = inOrder(o1);
+        inOrder1.verify(o1, times(1)).onNext(1);
+        inOrder1.verifyNoMoreInteractions();
+
+        // unsubscribe
+        ts.dispose();
+
+        // emit again but nothing will be there to receive it
+        ps.onNext(2);
+
+        Subscriber<Integer> o2 = TestHelper.mockSubscriber();
+        TestSubscriber<Integer> ts2 = new TestSubscriber<>(o2);
+        ps.subscribe(ts2);
+
+        // emit
+        ps.onNext(3);
+
+        // validate we got it
+        InOrder inOrder2 = inOrder(o2);
+        inOrder2.verify(o2, times(1)).onNext(3);
+        inOrder2.verifyNoMoreInteractions();
+
+        ts2.dispose();
+    }
+
+    private final Throwable testException = new Throwable();
+
+    @Test(timeout = 1000)
+    public void testUnsubscriptionCase() {
+        PublishSubject<String> src = PublishSubject.create();
+
+        for (int i = 0; i < 10; i++) {
+            final Subscriber<Object> o = TestHelper.mockSubscriber();
+            InOrder inOrder = inOrder(o);
+            String v = "" + i;
+            System.out.printf("Turn: %d%n", i);
+            src.first()
+                .flatMap(new Function<String, Observable<String>>() {
+
+                    @Override
+                    public Observable<String> apply(String t1) {
+                        return Observable.just(t1 + ", " + t1);
+                    }
+                })
+                .subscribe(new Observer<String>() {
+                    @Override
+                    public void onNext(String t) {
+                        o.onNext(t);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        o.onError(e);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        o.onComplete();
+                    }
+                });
+            src.onNext(v);
+            
+            inOrder.verify(o).onNext(v + ", " + v);
+            inOrder.verify(o).onComplete();
+            verify(o, never()).onError(any(Throwable.class));
+        }
+    }
+    
+    
+    // FIXME RS subscribers are not allowed to throw
+//    @Test
+//    public void testOnErrorThrowsDoesntPreventDelivery() {
+//        PublishSubject<String> ps = PublishSubject.create();
+//
+//        ps.subscribe();
+//        TestSubscriber<String> ts = new TestSubscriber<>();
+//        ps.subscribe(ts);
+//
+//        try {
+//            ps.onError(new RuntimeException("an exception"));
+//            fail("expect OnErrorNotImplementedException");
+//        } catch (OnErrorNotImplementedException e) {
+//            // ignore
+//        }
+//        // even though the onError above throws we should still receive it on the other subscriber 
+//        assertEquals(1, ts.getOnErrorEvents().size());
+//    }
+    
+    // FIXME RS subscribers are not allowed to throw
+//    /**
+//     * This one has multiple failures so should get a CompositeException
+//     */
+//    @Test
+//    public void testOnErrorThrowsDoesntPreventDelivery2() {
+//        PublishSubject<String> ps = PublishSubject.create();
+//
+//        ps.subscribe();
+//        ps.subscribe();
+//        TestSubscriber<String> ts = new TestSubscriber<String>();
+//        ps.subscribe(ts);
+//        ps.subscribe();
+//        ps.subscribe();
+//        ps.subscribe();
+//
+//        try {
+//            ps.onError(new RuntimeException("an exception"));
+//            fail("expect OnErrorNotImplementedException");
+//        } catch (CompositeException e) {
+//            // we should have 5 of them
+//            assertEquals(5, e.getExceptions().size());
+//        }
+//        // even though the onError above throws we should still receive it on the other subscriber 
+//        assertEquals(1, ts.getOnErrorEvents().size());
+//    }
+    @Test
+    public void testCurrentStateMethodsNormal() {
+        PublishSubject<Object> as = PublishSubject.create();
+        
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getThrowable());
+        
+        as.onNext(1);
+        
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getThrowable());
+        
+        as.onComplete();
+        
+        assertFalse(as.hasThrowable());
+        assertTrue(as.hasComplete());
+        assertNull(as.getThrowable());
+    }
+    
+    @Test
+    public void testCurrentStateMethodsEmpty() {
+        PublishSubject<Object> as = PublishSubject.create();
+        
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getThrowable());
+        
+        as.onComplete();
+        
+        assertFalse(as.hasThrowable());
+        assertTrue(as.hasComplete());
+        assertNull(as.getThrowable());
+    }
+    @Test
+    public void testCurrentStateMethodsError() {
+        PublishSubject<Object> as = PublishSubject.create();
+        
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getThrowable());
+        
+        as.onError(new TestException());
+        
+        assertTrue(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertTrue(as.getThrowable() instanceof TestException);
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/subjects/ReplaySubjectBoundedConcurrencyTest.java b/src/test/java/io/reactivex/subjects/ReplaySubjectBoundedConcurrencyTest.java
new file mode 100644
index 0000000000..9427771162
--- /dev/null
+++ b/src/test/java/io/reactivex/subjects/ReplaySubjectBoundedConcurrencyTest.java
@@ -0,0 +1,555 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.subjects;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+
+import org.junit.*;
+import org.reactivestreams.*;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.Scheduler;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class ReplaySubjectBoundedConcurrencyTest {
+
+    @Test(timeout = 4000)
+    public void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() throws InterruptedException {
+        final ReplaySubject<Long> replay = ReplaySubject.createUnbounded();
+        Thread source = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                Observable.create(new Publisher<Long>() {
+
+                    @Override
+                    public void subscribe(Subscriber<? super Long> o) {
+                        System.out.println("********* Start Source Data ***********");
+                        for (long l = 1; l <= 10000; l++) {
+                            o.onNext(l);
+                        }
+                        System.out.println("********* Finished Source Data ***********");
+                        o.onComplete();
+                    }
+                }).subscribe(replay);
+            }
+        });
+        source.start();
+
+        long v = replay.toBlocking().last();
+        assertEquals(10000, v);
+
+        // it's been played through once so now it will all be replays
+        final CountDownLatch slowLatch = new CountDownLatch(1);
+        Thread slowThread = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                Subscriber<Long> slow = new Observer<Long>() {
+
+                    @Override
+                    public void onComplete() {
+                        System.out.println("*** Slow Observer completed");
+                        slowLatch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                    }
+
+                    @Override
+                    public void onNext(Long args) {
+                        if (args == 1) {
+                            System.out.println("*** Slow Observer STARTED");
+                        }
+                        try {
+                            if (args % 10 == 0) {
+                                Thread.sleep(1);
+                            }
+                        } catch (InterruptedException e) {
+                            e.printStackTrace();
+                        }
+                    }
+                };
+                replay.subscribe(slow);
+                try {
+                    slowLatch.await();
+                } catch (InterruptedException e1) {
+                    e1.printStackTrace();
+                }
+            }
+        });
+        slowThread.start();
+
+        Thread fastThread = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                final CountDownLatch fastLatch = new CountDownLatch(1);
+                Subscriber<Long> fast = new Observer<Long>() {
+
+                    @Override
+                    public void onComplete() {
+                        System.out.println("*** Fast Observer completed");
+                        fastLatch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                    }
+
+                    @Override
+                    public void onNext(Long args) {
+                        if (args == 1) {
+                            System.out.println("*** Fast Observer STARTED");
+                        }
+                    }
+                };
+                replay.subscribe(fast);
+                try {
+                    fastLatch.await();
+                } catch (InterruptedException e1) {
+                    e1.printStackTrace();
+                }
+            }
+        });
+        fastThread.start();
+        fastThread.join();
+
+        // slow should not yet be completed when fast completes
+        assertEquals(1, slowLatch.getCount());
+
+        slowThread.join();
+    }
+
+    @Test
+    public void testReplaySubjectConcurrentSubscriptions() throws InterruptedException {
+        final ReplaySubject<Long> replay = ReplaySubject.createUnbounded();
+        Thread source = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                Observable.create(new Publisher<Long>() {
+
+                    @Override
+                    public void subscribe(Subscriber<? super Long> o) {
+                        System.out.println("********* Start Source Data ***********");
+                        for (long l = 1; l <= 10000; l++) {
+                            o.onNext(l);
+                        }
+                        System.out.println("********* Finished Source Data ***********");
+                        o.onComplete();
+                    }
+                }).subscribe(replay);
+            }
+        });
+
+        // used to collect results of each thread
+        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());
+        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());
+
+        for (int i = 1; i <= 200; i++) {
+            final int count = i;
+            if (count == 20) {
+                // start source data after we have some already subscribed
+                // and while others are in process of subscribing
+                source.start();
+            }
+            if (count == 100) {
+                // wait for source to finish then keep adding after it's done
+                source.join();
+            }
+            Thread t = new Thread(new Runnable() {
+
+                @Override
+                public void run() {
+                    List<Long> values = replay.toList().toBlocking().last();
+                    listOfListsOfValues.add(values);
+                    System.out.println("Finished thread: " + count);
+                }
+            });
+            t.start();
+            System.out.println("Started thread: " + i);
+            threads.add(t);
+        }
+
+        // wait for all threads to complete
+        for (Thread t : threads) {
+            t.join();
+        }
+
+        // assert all threads got the same results
+        List<Long> sums = new ArrayList<>();
+        for (List<Long> values : listOfListsOfValues) {
+            long v = 0;
+            for (long l : values) {
+                v += l;
+            }
+            sums.add(v);
+        }
+
+        long expected = sums.get(0);
+        boolean success = true;
+        for (long l : sums) {
+            if (l != expected) {
+                success = false;
+                System.out.println("FAILURE => Expected " + expected + " but got: " + l);
+            }
+        }
+
+        if (success) {
+            System.out.println("Success! " + sums.size() + " each had the same sum of " + expected);
+        } else {
+            throw new RuntimeException("Concurrency Bug");
+        }
+
+    }
+
+    /**
+     * Can receive timeout if subscribe never receives an onError/onCompleted ... which reveals a race condition.
+     */
+    @Test(timeout = 10000)
+    public void testSubscribeCompletionRaceCondition() {
+        for (int i = 0; i < 50; i++) {
+            final ReplaySubject<String> subject = ReplaySubject.createUnbounded();
+            final AtomicReference<String> value1 = new AtomicReference<>();
+
+            subject.subscribe(new Consumer<String>() {
+
+                @Override
+                public void accept(String t1) {
+                    try {
+                        // simulate a slow observer
+                        Thread.sleep(50);
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                    value1.set(t1);
+                }
+
+            });
+
+            Thread t1 = new Thread(new Runnable() {
+
+                @Override
+                public void run() {
+                    subject.onNext("value");
+                    subject.onComplete();
+                }
+            });
+
+            SubjectObserverThread t2 = new SubjectObserverThread(subject);
+            SubjectObserverThread t3 = new SubjectObserverThread(subject);
+            SubjectObserverThread t4 = new SubjectObserverThread(subject);
+            SubjectObserverThread t5 = new SubjectObserverThread(subject);
+
+            t2.start();
+            t3.start();
+            t1.start();
+            t4.start();
+            t5.start();
+            try {
+                t1.join();
+                t2.join();
+                t3.join();
+                t4.join();
+                t5.join();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+
+            assertEquals("value", value1.get());
+            assertEquals("value", t2.value.get());
+            assertEquals("value", t3.value.get());
+            assertEquals("value", t4.value.get());
+            assertEquals("value", t5.value.get());
+        }
+
+    }
+    
+    /**
+     * https://github.com/ReactiveX/RxJava/issues/1147
+     */
+    @Test
+    public void testRaceForTerminalState() {
+        final List<Integer> expected = Arrays.asList(1);
+        for (int i = 0; i < 100000; i++) {
+            TestSubscriber<Integer> ts = new TestSubscriber<>();
+            Observable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(ts);
+            ts.awaitTerminalEvent();
+            ts.assertValueSequence(expected);
+            ts.assertTerminated();
+        }
+    }
+
+    private static class SubjectObserverThread extends Thread {
+
+        private final ReplaySubject<String> subject;
+        private final AtomicReference<String> value = new AtomicReference<>();
+
+        public SubjectObserverThread(ReplaySubject<String> subject) {
+            this.subject = subject;
+        }
+
+        @Override
+        public void run() {
+            try {
+                // a timeout exception will happen if we don't get a terminal state 
+                String v = subject.timeout(2000, TimeUnit.MILLISECONDS).toBlocking().single();
+                value.set(v);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+    @Test
+    public void testReplaySubjectEmissionSubscriptionRace() throws Exception {
+        Scheduler s = Schedulers.io();
+        Scheduler.Worker worker = Schedulers.io().createWorker();
+        try {
+            for (int i = 0; i < 50_000; i++) {
+                if (i % 1000 == 0) {
+                    System.out.println(i);
+                }
+                final ReplaySubject<Object> rs = ReplaySubject.createWithSize(2);
+                
+                final CountDownLatch finish = new CountDownLatch(1); 
+                final CountDownLatch start = new CountDownLatch(1); 
+
+//                int j = i;
+
+                worker.schedule(new Runnable() {
+                    @Override
+                    public void run() {
+                        try {
+                            start.await();
+                        } catch (Exception e1) {
+                            e1.printStackTrace();
+                        }
+//                        System.out.println("> " + j);
+                        rs.onNext(1);
+                    }
+                });
+                
+                final AtomicReference<Object> o = new AtomicReference<>();
+                
+                rs
+//                .doOnSubscribe(v -> System.out.println("!! " + j))
+//                .doOnNext(e -> System.out.println(">> " + j))
+                .subscribeOn(s)
+                .observeOn(Schedulers.io())
+//                .doOnNext(e -> System.out.println(">>> " + j))
+                .subscribe(new Observer<Object>() {
+    
+                    @Override
+                    protected void onStart() {
+                        super.onStart();
+                    }
+                    
+                    @Override
+                    public void onComplete() {
+                        o.set(-1);
+                        finish.countDown();
+                    }
+    
+                    @Override
+                    public void onError(Throwable e) {
+                        o.set(e);
+                        finish.countDown();
+                    }
+    
+                    @Override
+                    public void onNext(Object t) {
+                        o.set(t);
+                        finish.countDown();
+                    }
+                    
+                });
+                start.countDown();
+                
+                if (!finish.await(5, TimeUnit.SECONDS)) {
+                    System.out.println(o.get());
+                    System.out.println(rs.hasSubscribers());
+                    rs.onComplete();
+                    Assert.fail("Timeout @ " + i);
+                    break;
+                } else {
+                    Assert.assertEquals(1, o.get());
+                    worker.schedule(new Runnable() {
+                        @Override
+                        public void run() {
+                            rs.onComplete();
+                        }
+                    });
+                }
+            }
+        } finally {
+            worker.dispose();
+        }
+    }
+    @Test(timeout = 5000)
+    public void testConcurrentSizeAndHasAnyValue() throws InterruptedException {
+        final ReplaySubject<Object> rs = ReplaySubject.createUnbounded();
+        final CyclicBarrier cb = new CyclicBarrier(2);
+        
+        Thread t = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    cb.await();
+                } catch (InterruptedException e) {
+                    return;
+                } catch (BrokenBarrierException e) {
+                    return;
+                }
+                for (int i = 0; i < 1000000; i++) {
+                    rs.onNext(i);
+                }
+                rs.onComplete();
+                System.out.println("Replay fill Thread finished!");
+            }
+        });
+        t.start();
+        try {
+            cb.await();
+        } catch (InterruptedException e) {
+            return;
+        } catch (BrokenBarrierException e) {
+            return;
+        }
+        int lastSize = 0;
+        for (; !rs.hasThrowable() && !rs.hasComplete();) {
+            int size = rs.size();
+            boolean hasAny = rs.hasValue();
+            Object[] values = rs.getValues();
+            if (size < lastSize) {
+                Assert.fail("Size decreased! " + lastSize + " -> " + size);
+            }
+            if ((size > 0) && !hasAny) {
+                Assert.fail("hasAnyValue reports emptyness but size doesn't");
+            }
+            if (size > values.length) {
+                Assert.fail("Got fewer values than size! " + size + " -> " + values.length);
+            }
+            for (int i = 0; i < values.length - 1; i++) {
+                Integer v1 = (Integer)values[i];
+                Integer v2 = (Integer)values[i + 1];
+                assertEquals(1, v2 - v1);
+            }
+            lastSize = size;
+        }
+        
+        t.join();
+    }
+    @Test(timeout = 5000)
+    public void testConcurrentSizeAndHasAnyValueBounded() throws InterruptedException {
+        final ReplaySubject<Object> rs = ReplaySubject.createWithSize(3);
+        final CyclicBarrier cb = new CyclicBarrier(2);
+        
+        Thread t = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    cb.await();
+                } catch (InterruptedException e) {
+                    return;
+                } catch (BrokenBarrierException e) {
+                    return;
+                }
+                for (int i = 0; i < 1000000; i++) {
+                    rs.onNext(i);
+                }
+                rs.onComplete();
+                System.out.println("Replay fill Thread finished!");
+            }
+        });
+        t.start();
+        try {
+            cb.await();
+        } catch (InterruptedException e) {
+            return;
+        } catch (BrokenBarrierException e) {
+            return;
+        }
+        for (; !rs.hasThrowable() && !rs.hasComplete();) {
+            rs.size(); // can't use value so just call to detect hangs
+            rs.hasValue(); // can't use value so just call to detect hangs
+            Object[] values = rs.getValues();
+            for (int i = 0; i < values.length - 1; i++) {
+                Integer v1 = (Integer)values[i];
+                Integer v2 = (Integer)values[i + 1];
+                assertEquals(1, v2 - v1);
+            }
+        }
+        
+        t.join();
+    }
+    @Test(timeout = 10000)
+    public void testConcurrentSizeAndHasAnyValueTimeBounded() throws InterruptedException {
+        final ReplaySubject<Object> rs = ReplaySubject.createWithTime(1, TimeUnit.MILLISECONDS, Schedulers.computation());
+        final CyclicBarrier cb = new CyclicBarrier(2);
+        
+        Thread t = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    cb.await();
+                } catch (InterruptedException e) {
+                    return;
+                } catch (BrokenBarrierException e) {
+                    return;
+                }
+                for (int i = 0; i < 1000000; i++) {
+                    rs.onNext(i);
+                    if (i % 10000 == 0) {
+                        try {
+                            Thread.sleep(1);
+                        } catch (InterruptedException e) {
+                            return;
+                        }
+                    }
+                }
+                rs.onComplete();
+                System.out.println("Replay fill Thread finished!");
+            }
+        });
+        t.start();
+        try {
+            cb.await();
+        } catch (InterruptedException e) {
+            return;
+        } catch (BrokenBarrierException e) {
+            return;
+        }
+        for (; !rs.hasThrowable() && !rs.hasComplete();) {
+            rs.size(); // can't use value so just call to detect hangs
+            rs.hasValue(); // can't use value so just call to detect hangs
+            Object[] values = rs.getValues();
+            for (int i = 0; i < values.length - 1; i++) {
+                Integer v1 = (Integer)values[i];
+                Integer v2 = (Integer)values[i + 1];
+                assertEquals(1, v2 - v1);
+            }
+        }
+        
+        t.join();
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/subjects/ReplaySubjectConcurrencyTest.java b/src/test/java/io/reactivex/subjects/ReplaySubjectConcurrencyTest.java
new file mode 100644
index 0000000000..11ff488b03
--- /dev/null
+++ b/src/test/java/io/reactivex/subjects/ReplaySubjectConcurrencyTest.java
@@ -0,0 +1,445 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.subjects;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+
+import org.junit.*;
+import org.reactivestreams.*;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.Scheduler;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class ReplaySubjectConcurrencyTest {
+
+    @Test(timeout = 4000)
+    public void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() throws InterruptedException {
+        final ReplaySubject<Long> replay = ReplaySubject.create();
+        Thread source = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                Observable.create(new Publisher<Long>() {
+
+                    @Override
+                    public void subscribe(Subscriber<? super Long> o) {
+                        System.out.println("********* Start Source Data ***********");
+                        for (long l = 1; l <= 10000; l++) {
+                            o.onNext(l);
+                        }
+                        System.out.println("********* Finished Source Data ***********");
+                        o.onComplete();
+                    }
+                }).subscribe(replay);
+            }
+        });
+        source.start();
+
+        long v = replay.toBlocking().last();
+        assertEquals(10000, v);
+
+        // it's been played through once so now it will all be replays
+        final CountDownLatch slowLatch = new CountDownLatch(1);
+        Thread slowThread = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                Subscriber<Long> slow = new Observer<Long>() {
+
+                    @Override
+                    public void onComplete() {
+                        System.out.println("*** Slow Observer completed");
+                        slowLatch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                    }
+
+                    @Override
+                    public void onNext(Long args) {
+                        if (args == 1) {
+                            System.out.println("*** Slow Observer STARTED");
+                        }
+                        try {
+                            if (args % 10 == 0) {
+                                Thread.sleep(1);
+                            }
+                        } catch (InterruptedException e) {
+                            e.printStackTrace();
+                        }
+                    }
+                };
+                replay.subscribe(slow);
+                try {
+                    slowLatch.await();
+                } catch (InterruptedException e1) {
+                    e1.printStackTrace();
+                }
+            }
+        });
+        slowThread.start();
+
+        Thread fastThread = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                final CountDownLatch fastLatch = new CountDownLatch(1);
+                Subscriber<Long> fast = new Observer<Long>() {
+
+                    @Override
+                    public void onComplete() {
+                        System.out.println("*** Fast Observer completed");
+                        fastLatch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                    }
+
+                    @Override
+                    public void onNext(Long args) {
+                        if (args == 1) {
+                            System.out.println("*** Fast Observer STARTED");
+                        }
+                    }
+                };
+                replay.subscribe(fast);
+                try {
+                    fastLatch.await();
+                } catch (InterruptedException e1) {
+                    e1.printStackTrace();
+                }
+            }
+        });
+        fastThread.start();
+        fastThread.join();
+
+        // slow should not yet be completed when fast completes
+        assertEquals(1, slowLatch.getCount());
+
+        slowThread.join();
+    }
+
+    @Test
+    public void testReplaySubjectConcurrentSubscriptions() throws InterruptedException {
+        final ReplaySubject<Long> replay = ReplaySubject.create();
+        Thread source = new Thread(new Runnable() {
+
+            @Override
+            public void run() {
+                Observable.create(new Publisher<Long>() {
+
+                    @Override
+                    public void subscribe(Subscriber<? super Long> o) {
+                        System.out.println("********* Start Source Data ***********");
+                        for (long l = 1; l <= 10000; l++) {
+                            o.onNext(l);
+                        }
+                        System.out.println("********* Finished Source Data ***********");
+                        o.onComplete();
+                    }
+                }).subscribe(replay);
+            }
+        });
+
+        // used to collect results of each thread
+        final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>());
+        final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());
+
+        for (int i = 1; i <= 200; i++) {
+            final int count = i;
+            if (count == 20) {
+                // start source data after we have some already subscribed
+                // and while others are in process of subscribing
+                source.start();
+            }
+            if (count == 100) {
+                // wait for source to finish then keep adding after it's done
+                source.join();
+            }
+            Thread t = new Thread(new Runnable() {
+
+                @Override
+                public void run() {
+                    List<Long> values = replay.toList().toBlocking().last();
+                    listOfListsOfValues.add(values);
+                    System.out.println("Finished thread: " + count);
+                }
+            });
+            t.start();
+            System.out.println("Started thread: " + i);
+            threads.add(t);
+        }
+
+        // wait for all threads to complete
+        for (Thread t : threads) {
+            t.join();
+        }
+
+        // assert all threads got the same results
+        List<Long> sums = new ArrayList<>();
+        for (List<Long> values : listOfListsOfValues) {
+            long v = 0;
+            for (long l : values) {
+                v += l;
+            }
+            sums.add(v);
+        }
+
+        long expected = sums.get(0);
+        boolean success = true;
+        for (long l : sums) {
+            if (l != expected) {
+                success = false;
+                System.out.println("FAILURE => Expected " + expected + " but got: " + l);
+            }
+        }
+
+        if (success) {
+            System.out.println("Success! " + sums.size() + " each had the same sum of " + expected);
+        } else {
+            throw new RuntimeException("Concurrency Bug");
+        }
+
+    }
+
+    /**
+     * Can receive timeout if subscribe never receives an onError/onCompleted ... which reveals a race condition.
+     */
+    @Test(timeout = 10000)
+    public void testSubscribeCompletionRaceCondition() {
+        for (int i = 0; i < 50; i++) {
+            final ReplaySubject<String> subject = ReplaySubject.create();
+            final AtomicReference<String> value1 = new AtomicReference<>();
+
+            subject.subscribe(new Consumer<String>() {
+
+                @Override
+                public void accept(String t1) {
+                    try {
+                        // simulate a slow observer
+                        Thread.sleep(50);
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                    value1.set(t1);
+                }
+
+            });
+
+            Thread t1 = new Thread(new Runnable() {
+
+                @Override
+                public void run() {
+                    subject.onNext("value");
+                    subject.onComplete();
+                }
+            });
+
+            SubjectObserverThread t2 = new SubjectObserverThread(subject);
+            SubjectObserverThread t3 = new SubjectObserverThread(subject);
+            SubjectObserverThread t4 = new SubjectObserverThread(subject);
+            SubjectObserverThread t5 = new SubjectObserverThread(subject);
+
+            t2.start();
+            t3.start();
+            t1.start();
+            t4.start();
+            t5.start();
+            try {
+                t1.join();
+                t2.join();
+                t3.join();
+                t4.join();
+                t5.join();
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
+            }
+
+            assertEquals("value", value1.get());
+            assertEquals("value", t2.value.get());
+            assertEquals("value", t3.value.get());
+            assertEquals("value", t4.value.get());
+            assertEquals("value", t5.value.get());
+        }
+
+    }
+    
+    /**
+     * https://github.com/ReactiveX/RxJava/issues/1147
+     */
+    @Test
+    public void testRaceForTerminalState() {
+        final List<Integer> expected = Arrays.asList(1);
+        for (int i = 0; i < 100000; i++) {
+            TestSubscriber<Integer> ts = new TestSubscriber<>();
+            Observable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(ts);
+            ts.awaitTerminalEvent();
+            ts.assertValueSequence(expected);
+            ts.assertTerminated();
+        }
+    }
+
+    private static class SubjectObserverThread extends Thread {
+
+        private final ReplaySubject<String> subject;
+        private final AtomicReference<String> value = new AtomicReference<>();
+
+        public SubjectObserverThread(ReplaySubject<String> subject) {
+            this.subject = subject;
+        }
+
+        @Override
+        public void run() {
+            try {
+                // a timeout exception will happen if we don't get a terminal state 
+                String v = subject.timeout(2000, TimeUnit.MILLISECONDS).toBlocking().single();
+                value.set(v);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+    @Test
+    public void testReplaySubjectEmissionSubscriptionRace() throws Exception {
+        Scheduler s = Schedulers.io();
+        Scheduler.Worker worker = Schedulers.io().createWorker();
+        try {
+            for (int i = 0; i < 50000; i++) {
+                if (i % 1000 == 0) {
+                    System.out.println(i);
+                }
+                final ReplaySubject<Object> rs = ReplaySubject.create();
+                
+                final CountDownLatch finish = new CountDownLatch(1); 
+                final CountDownLatch start = new CountDownLatch(1); 
+                
+                worker.schedule(new Runnable() {
+                    @Override
+                    public void run() {
+                        try {
+                            start.await();
+                        } catch (Exception e1) {
+                            e1.printStackTrace();
+                        }
+                        rs.onNext(1);
+                    }
+                });
+                
+                final AtomicReference<Object> o = new AtomicReference<>();
+                
+                rs.subscribeOn(s).observeOn(Schedulers.io())
+                .subscribe(new Observer<Object>() {
+    
+                    @Override
+                    public void onComplete() {
+                        o.set(-1);
+                        finish.countDown();
+                    }
+    
+                    @Override
+                    public void onError(Throwable e) {
+                        o.set(e);
+                        finish.countDown();
+                    }
+    
+                    @Override
+                    public void onNext(Object t) {
+                        o.set(t);
+                        finish.countDown();
+                    }
+                    
+                });
+                start.countDown();
+                
+                if (!finish.await(5, TimeUnit.SECONDS)) {
+                    System.out.println(o.get());
+                    System.out.println(rs.hasSubscribers());
+                    rs.onComplete();
+                    Assert.fail("Timeout @ " + i);
+                    break;
+                } else {
+                    Assert.assertEquals(1, o.get());
+                    worker.schedule(new Runnable() {
+                        @Override
+                        public void run() {
+                            rs.onComplete();
+                        }
+                    });
+                    
+                }
+            }
+        } finally {
+            worker.dispose();
+        }
+    }
+    @Test(timeout = 10000)
+    public void testConcurrentSizeAndHasAnyValue() throws InterruptedException {
+        final ReplaySubject<Object> rs = ReplaySubject.create();
+        final CyclicBarrier cb = new CyclicBarrier(2);
+        
+        Thread t = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    cb.await();
+                } catch (InterruptedException e) {
+                    return;
+                } catch (BrokenBarrierException e) {
+                    return;
+                }
+                for (int i = 0; i < 1000000; i++) {
+                    rs.onNext(i);
+                }
+                rs.onComplete();
+                System.out.println("Replay fill Thread finished!");
+            }
+        });
+        t.start();
+        try {
+            cb.await();
+        } catch (InterruptedException e) {
+            return;
+        } catch (BrokenBarrierException e) {
+            return;
+        }
+        int lastSize = 0;
+        for (; !rs.hasThrowable() && !rs.hasComplete();) {
+            int size = rs.size();
+            boolean hasAny = rs.hasValue();
+            Object[] values = rs.getValues();
+            if (size < lastSize) {
+                Assert.fail("Size decreased! " + lastSize + " -> " + size);
+            }
+            if ((size > 0) && !hasAny) {
+                Assert.fail("hasAnyValue reports emptyness but size doesn't");
+            }
+            if (size > values.length) {
+                Assert.fail("Got fewer values than size! " + size + " -> " + values.length);
+            }
+            lastSize = size;
+        }
+        
+        t.join();
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java b/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java
new file mode 100644
index 0000000000..c34ee59266
--- /dev/null
+++ b/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java
@@ -0,0 +1,823 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.subjects;
+
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.*;
+import static org.mockito.Mockito.*;
+
+import java.util.Arrays;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Function;
+
+import org.junit.Test;
+import org.mockito.*;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.schedulers.*;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class ReplaySubjectTest {
+
+    private final Throwable testException = new Throwable();
+
+    @Test
+    public void testCompleted() {
+        ReplaySubject<String> subject = ReplaySubject.create();
+
+        Subscriber<String> o1 = TestHelper.mockSubscriber();
+        subject.subscribe(o1);
+
+        subject.onNext("one");
+        subject.onNext("two");
+        subject.onNext("three");
+        subject.onComplete();
+
+        subject.onNext("four");
+        subject.onComplete();
+        subject.onError(new Throwable());
+
+        assertCompletedSubscriber(o1);
+
+        // assert that subscribing a 2nd time gets the same data
+        Subscriber<String> o2 = TestHelper.mockSubscriber();
+        subject.subscribe(o2);
+        assertCompletedSubscriber(o2);
+    }
+
+    @Test
+    public void testCompletedStopsEmittingData() {
+        ReplaySubject<Integer> channel = ReplaySubject.create();
+        Subscriber<Object> observerA = TestHelper.mockSubscriber();
+        Subscriber<Object> observerB = TestHelper.mockSubscriber();
+        Subscriber<Object> observerC = TestHelper.mockSubscriber();
+        Subscriber<Object> observerD = TestHelper.mockSubscriber();
+        TestSubscriber<Object> ts = new TestSubscriber<>(observerA);
+
+        channel.subscribe(ts);
+        channel.subscribe(observerB);
+
+        InOrder inOrderA = inOrder(observerA);
+        InOrder inOrderB = inOrder(observerB);
+        InOrder inOrderC = inOrder(observerC);
+        InOrder inOrderD = inOrder(observerD);
+
+        channel.onNext(42);
+
+        // both A and B should have received 42 from before subscription
+        inOrderA.verify(observerA).onNext(42);
+        inOrderB.verify(observerB).onNext(42);
+
+        ts.dispose();
+
+        // a should receive no more
+        inOrderA.verifyNoMoreInteractions();
+
+        channel.onNext(4711);
+
+        // only be should receive 4711 at this point
+        inOrderB.verify(observerB).onNext(4711);
+
+        channel.onComplete();
+
+        // B is subscribed so should receive onCompleted
+        inOrderB.verify(observerB).onComplete();
+
+        channel.subscribe(observerC);
+
+        // when C subscribes it should receive 42, 4711, onCompleted
+        inOrderC.verify(observerC).onNext(42);
+        inOrderC.verify(observerC).onNext(4711);
+        inOrderC.verify(observerC).onComplete();
+
+        // if further events are propagated they should be ignored
+        channel.onNext(13);
+        channel.onNext(14);
+        channel.onNext(15);
+        channel.onError(new RuntimeException());
+
+        // a new subscription should only receive what was emitted prior to terminal state onCompleted
+        channel.subscribe(observerD);
+
+        inOrderD.verify(observerD).onNext(42);
+        inOrderD.verify(observerD).onNext(4711);
+        inOrderD.verify(observerD).onComplete();
+
+        verify(observerA).onSubscribe((Subscription)notNull());
+        verify(observerB).onSubscribe((Subscription)notNull());
+        verify(observerC).onSubscribe((Subscription)notNull());
+        verify(observerD).onSubscribe((Subscription)notNull());
+        Mockito.verifyNoMoreInteractions(observerA);
+        Mockito.verifyNoMoreInteractions(observerB);
+        Mockito.verifyNoMoreInteractions(observerC);
+        Mockito.verifyNoMoreInteractions(observerD);
+
+    }
+
+    @Test
+    public void testCompletedAfterError() {
+        ReplaySubject<String> subject = ReplaySubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+
+        subject.onNext("one");
+        subject.onError(testException);
+        subject.onNext("two");
+        subject.onComplete();
+        subject.onError(new RuntimeException());
+
+        subject.subscribe(observer);
+        verify(observer).onSubscribe((Subscription)notNull());
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onError(testException);
+        verifyNoMoreInteractions(observer);
+    }
+
+    private void assertCompletedSubscriber(Subscriber<String> observer) {
+        InOrder inOrder = inOrder(observer);
+
+        inOrder.verify(observer, times(1)).onNext("one");
+        inOrder.verify(observer, times(1)).onNext("two");
+        inOrder.verify(observer, times(1)).onNext("three");
+        inOrder.verify(observer, Mockito.never()).onError(any(Throwable.class));
+        inOrder.verify(observer, times(1)).onComplete();
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testError() {
+        ReplaySubject<String> subject = ReplaySubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onNext("two");
+        subject.onNext("three");
+        subject.onError(testException);
+
+        subject.onNext("four");
+        subject.onError(new Throwable());
+        subject.onComplete();
+
+        assertErrorSubscriber(observer);
+
+        observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+        assertErrorSubscriber(observer);
+    }
+
+    private void assertErrorSubscriber(Subscriber<String> observer) {
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onNext("two");
+        verify(observer, times(1)).onNext("three");
+        verify(observer, times(1)).onError(testException);
+        verify(observer, Mockito.never()).onComplete();
+    }
+
+    @Test
+    public void testSubscribeMidSequence() {
+        ReplaySubject<String> subject = ReplaySubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        subject.subscribe(observer);
+
+        subject.onNext("one");
+        subject.onNext("two");
+
+        assertObservedUntilTwo(observer);
+
+        Subscriber<String> anotherSubscriber = TestHelper.mockSubscriber();
+        subject.subscribe(anotherSubscriber);
+        assertObservedUntilTwo(anotherSubscriber);
+
+        subject.onNext("three");
+        subject.onComplete();
+
+        assertCompletedSubscriber(observer);
+        assertCompletedSubscriber(anotherSubscriber);
+    }
+
+    @Test
+    public void testUnsubscribeFirstSubscriber() {
+        ReplaySubject<String> subject = ReplaySubject.create();
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        TestSubscriber<String> ts = new TestSubscriber<>(observer);
+        subject.subscribe(ts);
+
+        subject.onNext("one");
+        subject.onNext("two");
+
+        ts.dispose();
+        assertObservedUntilTwo(observer);
+
+        Subscriber<String> anotherSubscriber = TestHelper.mockSubscriber();
+        subject.subscribe(anotherSubscriber);
+        assertObservedUntilTwo(anotherSubscriber);
+
+        subject.onNext("three");
+        subject.onComplete();
+
+        assertObservedUntilTwo(observer);
+        assertCompletedSubscriber(anotherSubscriber);
+    }
+
+    private void assertObservedUntilTwo(Subscriber<String> observer) {
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onNext("two");
+        verify(observer, Mockito.never()).onNext("three");
+        verify(observer, Mockito.never()).onError(any(Throwable.class));
+        verify(observer, Mockito.never()).onComplete();
+    }
+
+    @Test(timeout = 2000)
+    public void testNewSubscriberDoesntBlockExisting() throws InterruptedException {
+
+        final AtomicReference<String> lastValueForSubscriber1 = new AtomicReference<>();
+        Subscriber<String> observer1 = new Observer<String>() {
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+
+            }
+
+            @Override
+            public void onNext(String v) {
+                System.out.println("observer1: " + v);
+                lastValueForSubscriber1.set(v);
+            }
+
+        };
+
+        final AtomicReference<String> lastValueForSubscriber2 = new AtomicReference<>();
+        final CountDownLatch oneReceived = new CountDownLatch(1);
+        final CountDownLatch makeSlow = new CountDownLatch(1);
+        final CountDownLatch completed = new CountDownLatch(1);
+        Subscriber<String> observer2 = new Observer<String>() {
+
+            @Override
+            public void onComplete() {
+                completed.countDown();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+
+            }
+
+            @Override
+            public void onNext(String v) {
+                System.out.println("observer2: " + v);
+                if (v.equals("one")) {
+                    oneReceived.countDown();
+                } else {
+                    try {
+                        makeSlow.await();
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                    lastValueForSubscriber2.set(v);
+                }
+            }
+
+        };
+
+        ReplaySubject<String> subject = ReplaySubject.create();
+        subject.subscribe(observer1);
+        subject.onNext("one");
+        assertEquals("one", lastValueForSubscriber1.get());
+        subject.onNext("two");
+        assertEquals("two", lastValueForSubscriber1.get());
+
+        // use subscribeOn to make this async otherwise we deadlock as we are using CountDownLatches
+        subject.subscribeOn(Schedulers.newThread()).subscribe(observer2);
+
+        System.out.println("before waiting for one");
+
+        // wait until observer2 starts having replay occur
+        oneReceived.await();
+
+        System.out.println("after waiting for one");
+
+        subject.onNext("three");
+        
+        System.out.println("sent three");
+        
+        // if subscription blocked existing subscribers then 'makeSlow' would cause this to not be there yet 
+        assertEquals("three", lastValueForSubscriber1.get());
+        
+        System.out.println("about to send onCompleted");
+        
+        subject.onComplete();
+
+        System.out.println("completed subject");
+        
+        // release 
+        makeSlow.countDown();
+        
+        System.out.println("makeSlow released");
+        
+        completed.await();
+        // all of them should be emitted with the last being "three"
+        assertEquals("three", lastValueForSubscriber2.get());
+
+    }
+    @Test
+    public void testSubscriptionLeak() {
+        ReplaySubject<Object> replaySubject = ReplaySubject.create();
+        
+        Disposable s = replaySubject.subscribe();
+
+        assertEquals(1, replaySubject.subscriberCount());
+
+        s.dispose();
+        
+        assertEquals(0, replaySubject.subscriberCount());
+    }
+    @Test(timeout = 1000)
+    public void testUnsubscriptionCase() {
+        ReplaySubject<String> src = ReplaySubject.create();
+        
+        for (int i = 0; i < 10; i++) {
+            final Subscriber<Object> o = TestHelper.mockSubscriber();
+            InOrder inOrder = inOrder(o);
+            String v = "" + i;
+            src.onNext(v);
+            System.out.printf("Turn: %d%n", i);
+            src.first()
+                .flatMap(new Function<String, Observable<String>>() {
+
+                    @Override
+                    public Observable<String> apply(String t1) {
+                        return Observable.just(t1 + ", " + t1);
+                    }
+                })
+                .subscribe(new Observer<String>() {
+                    @Override
+                    public void onNext(String t) {
+                        System.out.println(t);
+                        o.onNext(t);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        o.onError(e);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        o.onComplete();
+                    }
+                });
+            inOrder.verify(o).onNext("0, 0");
+            inOrder.verify(o).onComplete();
+            verify(o, never()).onError(any(Throwable.class));
+        }
+    }
+    @Test
+    public void testTerminateOnce() {
+        ReplaySubject<Integer> source = ReplaySubject.create();
+        source.onNext(1);
+        source.onNext(2);
+        source.onComplete();
+        
+        final Subscriber<Integer> o = TestHelper.mockSubscriber();
+        
+        source.unsafeSubscribe(new Observer<Integer>() {
+
+            @Override
+            public void onNext(Integer t) {
+                o.onNext(t);
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                o.onError(e);
+            }
+
+            @Override
+            public void onComplete() {
+                o.onComplete();
+            }
+        });
+        
+        verify(o).onNext(1);
+        verify(o).onNext(2);
+        verify(o).onComplete();
+        verify(o, never()).onError(any(Throwable.class));
+    }
+    
+    @Test
+    public void testReplay1AfterTermination() {
+        ReplaySubject<Integer> source = ReplaySubject.createWithSize(1);
+        
+        source.onNext(1);
+        source.onNext(2);
+        source.onComplete();
+        
+        for (int i = 0; i < 1; i++) {
+            Subscriber<Integer> o = TestHelper.mockSubscriber();
+
+            source.subscribe(o);
+
+            verify(o, never()).onNext(1);
+            verify(o).onNext(2);
+            verify(o).onComplete();
+            verify(o, never()).onError(any(Throwable.class));
+        }
+    }
+    @Test
+    public void testReplay1Directly() {
+        ReplaySubject<Integer> source = ReplaySubject.createWithSize(1);
+
+        Subscriber<Integer> o = TestHelper.mockSubscriber();
+
+        source.onNext(1);
+        source.onNext(2);
+
+        source.subscribe(o);
+
+        source.onNext(3);
+        source.onComplete();
+
+        verify(o, never()).onNext(1);
+        verify(o).onNext(2);
+        verify(o).onNext(3);
+        verify(o).onComplete();
+        verify(o, never()).onError(any(Throwable.class));
+    }
+    
+    @Test
+    public void testReplayTimestampedAfterTermination() {
+        TestScheduler scheduler = new TestScheduler();
+        ReplaySubject<Integer> source = ReplaySubject.createWithTime(1, TimeUnit.SECONDS, scheduler);
+        
+        source.onNext(1);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        source.onNext(2);
+
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        source.onNext(3);
+        source.onComplete();
+
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        Subscriber<Integer> o = TestHelper.mockSubscriber();
+
+        source.subscribe(o);
+        
+        verify(o, never()).onNext(1);
+        verify(o, never()).onNext(2);
+        verify(o).onNext(3);
+        verify(o).onComplete();
+        verify(o, never()).onError(any(Throwable.class));
+    }
+    
+    @Test
+    public void testReplayTimestampedDirectly() {
+        TestScheduler scheduler = new TestScheduler();
+        ReplaySubject<Integer> source = ReplaySubject.createWithTime(1, TimeUnit.SECONDS, scheduler);
+
+        source.onNext(1);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        Subscriber<Integer> o = TestHelper.mockSubscriber();
+
+        source.subscribe(o);
+
+        source.onNext(2);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        source.onNext(3);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        source.onComplete();
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        verify(o, never()).onError(any(Throwable.class));
+        verify(o, never()).onNext(1);
+        verify(o).onNext(2);
+        verify(o).onNext(3);
+        verify(o).onComplete();
+    }
+    
+    // FIXME RS subscribers can't throw
+//    @Test
+//    public void testOnErrorThrowsDoesntPreventDelivery() {
+//        ReplaySubject<String> ps = ReplaySubject.create();
+//
+//        ps.subscribe();
+//        TestSubscriber<String> ts = new TestSubscriber<>();
+//        ps.subscribe(ts);
+//
+//        try {
+//            ps.onError(new RuntimeException("an exception"));
+//            fail("expect OnErrorNotImplementedException");
+//        } catch (OnErrorNotImplementedException e) {
+//            // ignore
+//        }
+//        // even though the onError above throws we should still receive it on the other subscriber 
+//        assertEquals(1, ts.errors().size());
+//    }
+    
+    // FIXME RS subscribers can't throw
+//    /**
+//     * This one has multiple failures so should get a CompositeException
+//     */
+//    @Test
+//    public void testOnErrorThrowsDoesntPreventDelivery2() {
+//        ReplaySubject<String> ps = ReplaySubject.create();
+//
+//        ps.subscribe();
+//        ps.subscribe();
+//        TestSubscriber<String> ts = new TestSubscriber<String>();
+//        ps.subscribe(ts);
+//        ps.subscribe();
+//        ps.subscribe();
+//        ps.subscribe();
+//
+//        try {
+//            ps.onError(new RuntimeException("an exception"));
+//            fail("expect OnErrorNotImplementedException");
+//        } catch (CompositeException e) {
+//            // we should have 5 of them
+//            assertEquals(5, e.getExceptions().size());
+//        }
+//        // even though the onError above throws we should still receive it on the other subscriber 
+//        assertEquals(1, ts.getOnErrorEvents().size());
+//    }
+    
+    @Test
+    public void testCurrentStateMethodsNormal() {
+        ReplaySubject<Object> as = ReplaySubject.create();
+        
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getThrowable());
+        
+        as.onNext(1);
+        
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getThrowable());
+        
+        as.onComplete();
+        
+        assertFalse(as.hasThrowable());
+        assertTrue(as.hasComplete());
+        assertNull(as.getThrowable());
+    }
+    
+    @Test
+    public void testCurrentStateMethodsEmpty() {
+        ReplaySubject<Object> as = ReplaySubject.create();
+        
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getThrowable());
+        
+        as.onComplete();
+        
+        assertFalse(as.hasThrowable());
+        assertTrue(as.hasComplete());
+        assertNull(as.getThrowable());
+    }
+    @Test
+    public void testCurrentStateMethodsError() {
+        ReplaySubject<Object> as = ReplaySubject.create();
+        
+        assertFalse(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertNull(as.getThrowable());
+        
+        as.onError(new TestException());
+        
+        assertTrue(as.hasThrowable());
+        assertFalse(as.hasComplete());
+        assertTrue(as.getThrowable() instanceof TestException);
+    }
+    @Test
+    public void testSizeAndHasAnyValueUnbounded() {
+        ReplaySubject<Object> rs = ReplaySubject.create();
+        
+        assertEquals(0, rs.size());
+        assertFalse(rs.hasValue());
+        
+        rs.onNext(1);
+        
+        assertEquals(1, rs.size());
+        assertTrue(rs.hasValue());
+        
+        rs.onNext(1);
+
+        assertEquals(2, rs.size());
+        assertTrue(rs.hasValue());
+        
+        rs.onComplete();
+
+        assertEquals(2, rs.size());
+        assertTrue(rs.hasValue());
+    }
+    @Test
+    public void testSizeAndHasAnyValueEffectivelyUnbounded() {
+        ReplaySubject<Object> rs = ReplaySubject.createUnbounded();
+        
+        assertEquals(0, rs.size());
+        assertFalse(rs.hasValue());
+        
+        rs.onNext(1);
+        
+        assertEquals(1, rs.size());
+        assertTrue(rs.hasValue());
+        
+        rs.onNext(1);
+
+        assertEquals(2, rs.size());
+        assertTrue(rs.hasValue());
+        
+        rs.onComplete();
+
+        assertEquals(2, rs.size());
+        assertTrue(rs.hasValue());
+    }
+    
+    @Test
+    public void testSizeAndHasAnyValueUnboundedError() {
+        ReplaySubject<Object> rs = ReplaySubject.create();
+        
+        assertEquals(0, rs.size());
+        assertFalse(rs.hasValue());
+        
+        rs.onNext(1);
+        
+        assertEquals(1, rs.size());
+        assertTrue(rs.hasValue());
+        
+        rs.onNext(1);
+
+        assertEquals(2, rs.size());
+        assertTrue(rs.hasValue());
+        
+        rs.onError(new TestException());
+
+        assertEquals(2, rs.size());
+        assertTrue(rs.hasValue());
+    }
+    @Test
+    public void testSizeAndHasAnyValueEffectivelyUnboundedError() {
+        ReplaySubject<Object> rs = ReplaySubject.createUnbounded();
+        
+        assertEquals(0, rs.size());
+        assertFalse(rs.hasValue());
+        
+        rs.onNext(1);
+        
+        assertEquals(1, rs.size());
+        assertTrue(rs.hasValue());
+        
+        rs.onNext(1);
+
+        assertEquals(2, rs.size());
+        assertTrue(rs.hasValue());
+        
+        rs.onError(new TestException());
+
+        assertEquals(2, rs.size());
+        assertTrue(rs.hasValue());
+    }
+    
+    @Test
+    public void testSizeAndHasAnyValueUnboundedEmptyError() {
+        ReplaySubject<Object> rs = ReplaySubject.create();
+        
+        rs.onError(new TestException());
+
+        assertEquals(0, rs.size());
+        assertFalse(rs.hasValue());
+    }
+    @Test
+    public void testSizeAndHasAnyValueEffectivelyUnboundedEmptyError() {
+        ReplaySubject<Object> rs = ReplaySubject.createUnbounded();
+        
+        rs.onError(new TestException());
+
+        assertEquals(0, rs.size());
+        assertFalse(rs.hasValue());
+    }
+    
+    @Test
+    public void testSizeAndHasAnyValueUnboundedEmptyCompleted() {
+        ReplaySubject<Object> rs = ReplaySubject.create();
+        
+        rs.onComplete();
+
+        assertEquals(0, rs.size());
+        assertFalse(rs.hasValue());
+    }
+    @Test
+    public void testSizeAndHasAnyValueEffectivelyUnboundedEmptyCompleted() {
+        ReplaySubject<Object> rs = ReplaySubject.createUnbounded();
+        
+        rs.onComplete();
+
+        assertEquals(0, rs.size());
+        assertFalse(rs.hasValue());
+    }
+    
+    @Test
+    public void testSizeAndHasAnyValueSizeBounded() {
+        ReplaySubject<Object> rs = ReplaySubject.createWithSize(1);
+        
+        assertEquals(0, rs.size());
+        assertFalse(rs.hasValue());
+        
+        for (int i = 0; i < 1000; i++) {
+            rs.onNext(i);
+
+            assertEquals(1, rs.size());
+            assertTrue(rs.hasValue());
+        }
+        
+        rs.onComplete();
+
+        assertEquals(1, rs.size());
+        assertTrue(rs.hasValue());
+    }
+    
+    @Test
+    public void testSizeAndHasAnyValueTimeBounded() {
+        TestScheduler ts = new TestScheduler();
+        ReplaySubject<Object> rs = ReplaySubject.createWithTime(1, TimeUnit.SECONDS, ts);
+        
+        assertEquals(0, rs.size());
+        assertFalse(rs.hasValue());
+        
+        for (int i = 0; i < 1000; i++) {
+            rs.onNext(i);
+            ts.advanceTimeBy(2, TimeUnit.SECONDS);
+            assertEquals(1, rs.size());
+            assertTrue(rs.hasValue());
+        }
+        
+        rs.onComplete();
+
+        assertEquals(0, rs.size());
+        assertFalse(rs.hasValue());
+    }
+    @Test
+    public void testGetValues() {
+        ReplaySubject<Object> rs = ReplaySubject.create();
+        Object[] expected = new Object[10];
+        for (int i = 0; i < expected.length; i++) {
+            expected[i] = i;
+            rs.onNext(i);
+            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());
+        }
+        rs.onComplete();
+        
+        assertArrayEquals(expected, rs.getValues());
+        
+    }
+    @Test
+    public void testGetValuesUnbounded() {
+        ReplaySubject<Object> rs = ReplaySubject.createUnbounded();
+        Object[] expected = new Object[10];
+        for (int i = 0; i < expected.length; i++) {
+            expected[i] = i;
+            rs.onNext(i);
+            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());
+        }
+        rs.onComplete();
+        
+        assertArrayEquals(expected, rs.getValues());
+        
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/subjects/SerializedSubjectTest.java b/src/test/java/io/reactivex/subjects/SerializedSubjectTest.java
new file mode 100644
index 0000000000..1b428c03a8
--- /dev/null
+++ b/src/test/java/io/reactivex/subjects/SerializedSubjectTest.java
@@ -0,0 +1,416 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.subjects;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import io.reactivex.exceptions.TestException;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class SerializedSubjectTest {
+
+    @Test
+    public void testBasic() {
+        SerializedSubject<String, String> subject = new SerializedSubject<>(PublishSubject.<String> create());
+        TestSubscriber<String> ts = new TestSubscriber<>();
+        subject.subscribe(ts);
+        subject.onNext("hello");
+        subject.onComplete();
+        ts.awaitTerminalEvent();
+        ts.assertValue("hello");
+    }
+    
+    @Test
+    public void testAsyncSubjectValueRelay() {
+        AsyncSubject<Integer> async = AsyncSubject.create();
+        async.onNext(1);
+        async.onComplete();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertTrue(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertEquals((Integer)1, serial.getValue());
+        assertTrue(serial.hasValue());
+        assertArrayEquals(new Object[] { 1 }, serial.getValues());
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testAsyncSubjectValueEmpty() {
+        AsyncSubject<Integer> async = AsyncSubject.create();
+        async.onComplete();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertTrue(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testAsyncSubjectValueError() {
+        AsyncSubject<Integer> async = AsyncSubject.create();
+        TestException te = new TestException();
+        async.onError(te);
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertFalse(serial.hasComplete());
+        assertTrue(serial.hasThrowable());
+        assertSame(te, serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testPublishSubjectValueRelay() {
+        PublishSubject<Integer> async = PublishSubject.create();
+        async.onNext(1);
+        async.onComplete();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertTrue(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        
+        assertArrayEquals(new Object[0], serial.getValues());
+        assertArrayEquals(new Integer[0], serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    
+    @Test
+    public void testPublishSubjectValueEmpty() {
+        PublishSubject<Integer> async = PublishSubject.create();
+        async.onComplete();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertTrue(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testPublishSubjectValueError() {
+        PublishSubject<Integer> async = PublishSubject.create();
+        TestException te = new TestException();
+        async.onError(te);
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertFalse(serial.hasComplete());
+        assertTrue(serial.hasThrowable());
+        assertSame(te, serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+
+    @Test
+    public void testBehaviorSubjectValueRelay() {
+        BehaviorSubject<Integer> async = BehaviorSubject.create();
+        async.onNext(1);
+        async.onComplete();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertTrue(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testBehaviorSubjectValueRelayIncomplete() {
+        BehaviorSubject<Integer> async = BehaviorSubject.create();
+        async.onNext(1);
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertFalse(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertEquals((Integer)1, serial.getValue());
+        assertTrue(serial.hasValue());
+        assertArrayEquals(new Object[] { 1 }, serial.getValues());
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testBehaviorSubjectIncompleteEmpty() {
+        BehaviorSubject<Integer> async = BehaviorSubject.create();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertFalse(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testBehaviorSubjectEmpty() {
+        BehaviorSubject<Integer> async = BehaviorSubject.create();
+        async.onComplete();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertTrue(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testBehaviorSubjectError() {
+        BehaviorSubject<Integer> async = BehaviorSubject.create();
+        TestException te = new TestException();
+        async.onError(te);
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertFalse(serial.hasComplete());
+        assertTrue(serial.hasThrowable());
+        assertSame(te, serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    
+    @Test
+    public void testReplaySubjectValueRelay() {
+        ReplaySubject<Integer> async = ReplaySubject.create();
+        async.onNext(1);
+        async.onComplete();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertTrue(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertEquals((Integer)1, serial.getValue());
+        assertTrue(serial.hasValue());
+        assertArrayEquals(new Object[] { 1 }, serial.getValues());
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectValueRelayIncomplete() {
+        ReplaySubject<Integer> async = ReplaySubject.create();
+        async.onNext(1);
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertFalse(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertEquals((Integer)1, serial.getValue());
+        assertTrue(serial.hasValue());
+        assertArrayEquals(new Object[] { 1 }, serial.getValues());
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectValueRelayBounded() {
+        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
+        async.onNext(0);
+        async.onNext(1);
+        async.onComplete();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertTrue(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertEquals((Integer)1, serial.getValue());
+        assertTrue(serial.hasValue());
+        assertArrayEquals(new Object[] { 1 }, serial.getValues());
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectValueRelayBoundedIncomplete() {
+        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
+        async.onNext(0);
+        async.onNext(1);
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertFalse(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertEquals((Integer)1, serial.getValue());
+        assertTrue(serial.hasValue());
+        assertArrayEquals(new Object[] { 1 }, serial.getValues());
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectValueRelayBoundedEmptyIncomplete() {
+        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertFalse(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectValueRelayEmptyIncomplete() {
+        ReplaySubject<Integer> async = ReplaySubject.create();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertFalse(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    
+    @Test
+    public void testReplaySubjectEmpty() {
+        ReplaySubject<Integer> async = ReplaySubject.create();
+        async.onComplete();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertTrue(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectError() {
+        ReplaySubject<Integer> async = ReplaySubject.create();
+        TestException te = new TestException();
+        async.onError(te);
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertFalse(serial.hasComplete());
+        assertTrue(serial.hasThrowable());
+        assertSame(te, serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    
+    @Test
+    public void testReplaySubjectBoundedEmpty() {
+        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
+        async.onComplete();
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertTrue(serial.hasComplete());
+        assertFalse(serial.hasThrowable());
+        assertNull(serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectBoundedError() {
+        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
+        TestException te = new TestException();
+        async.onError(te);
+        Subject<Integer, Integer> serial = async.toSerialized();
+        
+        assertFalse(serial.hasSubscribers());
+        assertFalse(serial.hasComplete());
+        assertTrue(serial.hasThrowable());
+        assertSame(te, serial.getThrowable());
+        assertNull(serial.getValue());
+        assertFalse(serial.hasValue());
+        assertArrayEquals(new Object[] { }, serial.getValues());
+        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
+    }
+    
+    @Test
+    public void testDontWrapSerializedSubjectAgain() {
+        PublishSubject<Object> s = PublishSubject.create();
+        Subject<Object, Object> s1 = s.toSerialized();
+        Subject<Object, Object> s2 = s1.toSerialized();
+        assertSame(s1, s2);
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/subscribers/SafeSubscriberTest.java b/src/test/java/io/reactivex/subscribers/SafeSubscriberTest.java
index aab2724439..b709a0b796 100644
--- a/src/test/java/io/reactivex/subscribers/SafeSubscriberTest.java
+++ b/src/test/java/io/reactivex/subscribers/SafeSubscriberTest.java
@@ -1,3 +1,16 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
 package io.reactivex.subscribers;
 
 import static org.mockito.Matchers.any;
