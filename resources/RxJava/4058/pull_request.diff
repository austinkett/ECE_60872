diff --git a/src/main/java/io/reactivex/disposables/RefCountDisposable.java b/src/main/java/io/reactivex/disposables/RefCountDisposable.java
index b3fd87daa4..2fe5ce4e3c 100644
--- a/src/main/java/io/reactivex/disposables/RefCountDisposable.java
+++ b/src/main/java/io/reactivex/disposables/RefCountDisposable.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.disposables;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.internal.functions.Objects;
@@ -21,10 +22,7 @@
 
     final AtomicReference<Disposable> resource = new AtomicReference<Disposable>();
 
-    static final Disposable DISPOSED = new Disposable() {
-        @Override
-        public void dispose() { }
-    };
+    static final Disposable DISPOSED = DisposableHelper.DISPOSED;
     
     final AtomicInteger count = new AtomicInteger();
 
@@ -40,21 +38,11 @@ public RefCountDisposable(Disposable resource) {
     public void dispose() {
         if (once.compareAndSet(false, true)) {
             if (count.decrementAndGet() == 0) {
-                disposeActual();
+                DisposableHelper.dispose(resource);
             }
         }
     }
-    
-    void disposeActual() {
-        Disposable d = resource.get();
-        if (d != DISPOSED) {
-            d = resource.getAndSet(DISPOSED);
-            if (d != DISPOSED && d != null) {
-                d.dispose();
-            }
-        }
-    }
-    
+
     public Disposable get() {
         count.getAndIncrement();
         return new InnerDisposable(this);
@@ -62,7 +50,7 @@ public Disposable get() {
     
     void release() {
         if (count.decrementAndGet() == 0) {
-            disposeActual();
+            DisposableHelper.dispose(resource);
         }
     }
     
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java
index b9be53daa5..35e48a08cf 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java
@@ -150,19 +150,7 @@ public void cancel() {
         boolean won;
         
         final AtomicLong missedRequested = new AtomicLong();
-        
-        static final Subscription CANCELLED = new Subscription() {
-            @Override
-            public void request(long n) {
-                
-            }
-            
-            @Override
-            public void cancel() {
-                
-            }
-        };
-        
+
         public AmbInnerSubscriber(AmbCoordinator<T> parent, int index, Subscriber<? super T> actual) {
             this.parent = parent;
             this.index = index;
@@ -173,7 +161,7 @@ public AmbInnerSubscriber(AmbCoordinator<T> parent, int index, Subscriber<? supe
         public void onSubscribe(Subscription s) {
             if (!compareAndSet(null, s)) {
                 s.cancel();
-                if (get() != CANCELLED) {
+                if (get() != SubscriptionHelper.CANCELLED) {
                     SubscriptionHelper.reportSubscriptionSet();
                 }
                 return;
@@ -196,7 +184,7 @@ public void request(long n) {
                 }
                 BackpressureHelper.add(missedRequested, n);
                 s = get();
-                if (s != null && s != CANCELLED) {
+                if (s != null && s != SubscriptionHelper.CANCELLED) {
                     long r = missedRequested.getAndSet(0L);
                     if (r != 0L) {
                         s.request(r);
@@ -250,13 +238,7 @@ public void onComplete() {
         
         @Override
         public void cancel() {
-            Subscription s = get();
-            if (s != CANCELLED) {
-                s = getAndSet(CANCELLED);
-                if (s != CANCELLED && s != null) {
-                    s.cancel();
-                }
-            }
+            SubscriptionHelper.dispose(this);
         }
         
     }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
index afaebe10c5..f5b3722139 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicReference;
@@ -93,11 +94,6 @@ protected void subscribeActual(Subscriber<? super U> s) {
         
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
         public BufferExactUnboundedSubscriber(
                 Subscriber<? super U> actual, Supplier<U> bufferSupplier,
                 long timespan, TimeUnit unit, Scheduler scheduler) {
@@ -158,7 +154,7 @@ public void onNext(T t) {
         
         @Override
         public void onError(Throwable t) {
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             synchronized (this) {
                 buffer = null;
             }
@@ -167,7 +163,7 @@ public void onError(Throwable t) {
         
         @Override
         public void onComplete() {
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             U b;
             synchronized (this) {
                 b = buffer;
@@ -190,21 +186,11 @@ public void request(long n) {
         
         @Override
         public void cancel() {
-            disposeTimer();
-            
+            DisposableHelper.dispose(timer);
+
             s.cancel();
         }
-        
-        void disposeTimer() {
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
-        
+
         @Override
         public void run() {
             /*
@@ -246,7 +232,7 @@ public void run() {
             
             if (current == null) {
                 selfCancel = true;
-                disposeTimer();
+                DisposableHelper.dispose(timer);
                 return;
             }
 
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
index e9cdae8c24..18221ec5b5 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
@@ -346,19 +346,7 @@ void onError(Throwable e) {
         boolean done;
         
         final AtomicReference<Subscription> s = new AtomicReference<Subscription>();
-        
-        static final Subscription CANCELLED = new Subscription() {
-            @Override
-            public void request(long n) {
-                
-            }
-            
-            @Override
-            public void cancel() {
-                
-            }
-        };
-        
+
         public CombinerSubscriber(LatestCoordinator<T, R> parent, int index) {
             this.parent = parent;
             this.index = index;
@@ -368,7 +356,7 @@ public CombinerSubscriber(LatestCoordinator<T, R> parent, int index) {
         public void onSubscribe(Subscription s) {
             if (!this.s.compareAndSet(null, s)) {
                 s.cancel();
-                if (this.s.get() != CANCELLED) {
+                if (this.s.get() != SubscriptionHelper.CANCELLED) {
                     SubscriptionHelper.reportSubscriptionSet();
                 }
                 return;
@@ -411,13 +399,7 @@ public void request(long n) {
         
         @Override
         public void cancel() {
-            Subscription a = s.get();
-            if (a != CANCELLED) {
-                a = s.getAndSet(CANCELLED);
-                if (a != CANCELLED && a != null) {
-                    a.cancel();
-                }
-            }
+            SubscriptionHelper.dispose(s);
         }
     }
 }
\ No newline at end of file
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java
index 8bd36c6f18..d9f1beee2e 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.concurrent.atomic.*;
 
 import org.reactivestreams.*;
@@ -53,11 +54,6 @@ protected void subscribeActual(Subscriber<? super T> s) {
         
         final AtomicReference<Disposable> debouncer = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
         volatile long index;
         
         boolean done;
@@ -118,7 +114,7 @@ public void onNext(T t) {
         
         @Override
         public void onError(Throwable t) {
-            disposeDebouncer();
+            DisposableHelper.dispose(debouncer);
             actual.onError(t);
         }
         
@@ -129,11 +125,11 @@ public void onComplete() {
             }
             done = true;
             Disposable d = debouncer.get();
-            if (d != CANCELLED) {
+            if (!DisposableHelper.isDisposed(d)) {
                 @SuppressWarnings("unchecked")
                 DebounceInnerSubscriber<T, U> dis = (DebounceInnerSubscriber<T, U>)d;
                 dis.emit();
-                disposeDebouncer();
+                DisposableHelper.dispose(debouncer);
                 actual.onComplete();
             }
         }
@@ -150,19 +146,9 @@ public void request(long n) {
         @Override
         public void cancel() {
             s.cancel();
-            disposeDebouncer();
+            DisposableHelper.dispose(debouncer);
         }
-        
-        public void disposeDebouncer() {
-            Disposable d = debouncer.get();
-            if (d != CANCELLED) {
-                d = debouncer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
-        
+
         void emit(long idx, T value) {
             if (idx == index) {
                 long r = get();
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
index ce3a011ba1..eec54501a2 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
@@ -60,16 +60,6 @@ protected void subscribeActual(Subscriber<? super T> s) {
         
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
 
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
-        static final Disposable NEW_TIMER = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         volatile long index;
         
         boolean done;
@@ -80,17 +70,7 @@ public DebounceTimedSubscriber(Subscriber<? super T> actual, long timeout, TimeU
             this.unit = unit;
             this.worker = worker;
         }
-        
-        public void disposeTimer() {
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
-        
+
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
@@ -132,7 +112,7 @@ public void onError(Throwable t) {
                 return;
             }
             done = true;
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             actual.onError(t);
         }
         
@@ -144,11 +124,11 @@ public void onComplete() {
             done = true;
             
             Disposable d = timer.get();
-            if (d != CANCELLED) {
+            if (!DisposableHelper.isDisposed(d)) {
                 @SuppressWarnings("unchecked")
                 DebounceEmitter<T> de = (DebounceEmitter<T>)d;
                 de.emit();
-                disposeTimer();
+                DisposableHelper.dispose(timer);
                 worker.dispose();
                 actual.onComplete();
             }
@@ -164,7 +144,7 @@ public void request(long n) {
         
         @Override
         public void cancel() {
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             worker.dispose();
             s.cancel();
         }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
index 5fbea67092..9962ebe41e 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
@@ -571,19 +571,7 @@ void unsubscribe() {
         volatile boolean done;
         volatile Queue<U> queue;
         int outstanding;
-        
-        static final Subscription CANCELLED = new Subscription() {
-            @Override
-            public void request(long n) {
-                
-            }
-            
-            @Override
-            public void cancel() {
-                
-            }
-        };
-        
+
         public InnerSubscriber(MergeSubscriber<T, U> parent, long id) {
             this.id = id;
             this.parent = parent;
@@ -594,7 +582,7 @@ public InnerSubscriber(MergeSubscriber<T, U> parent, long id) {
         public void onSubscribe(Subscription s) {
             if (!compareAndSet(null, s)) {
                 s.cancel();
-                if (get() != CANCELLED) {
+                if (get() != SubscriptionHelper.CANCELLED) {
                     SubscriptionHelper.reportSubscriptionSet();
                 }
                 return;
@@ -633,13 +621,7 @@ void requestMore(long n) {
         
         @Override
         public void dispose() {
-            Subscription s = get();
-            if (s != CANCELLED) {
-                s = getAndSet(CANCELLED);
-                if (s != CANCELLED && s != null) {
-                    s.cancel();
-                }
-            }
+            SubscriptionHelper.dispose(this);
         }
     }
     
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
index ab0fd903a5..7df4b78f31 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
@@ -229,19 +229,7 @@ public void connect(Consumer<? super Disposable> connection) {
         boolean missed;
         
         final AtomicReference<Subscription> s = new AtomicReference<Subscription>();
-        
-        static final Subscription CANCELLED = new Subscription() {
-            @Override
-            public void request(long n) {
-                
-            }
-            
-            @Override
-            public void cancel() {
-                
-            }
-        };
-        
+
         public PublishSubscriber(AtomicReference<PublishSubscriber<T>> current, int bufferSize) {
             this.queue = new SpscArrayQueue<Object>(bufferSize);
             
@@ -257,14 +245,7 @@ public void dispose() {
                 InnerProducer[] ps = producers.getAndSet(TERMINATED);
                 if (ps != TERMINATED) {
                     current.compareAndSet(PublishSubscriber.this, null);
-                    
-                    Subscription a = s.get();
-                    if (a != CANCELLED) {
-                        a = s.getAndSet(CANCELLED);
-                        if (a != CANCELLED && a != null) {
-                            a.cancel();
-                        }
-                    }
+                    SubscriptionHelper.dispose(s);
                 }
             }
         }
@@ -277,7 +258,7 @@ public boolean isDisposed() {
         public void onSubscribe(Subscription s) {
             if (!this.s.compareAndSet(null, s)) {
                 s.cancel();
-                if (this.s.get() != CANCELLED) {
+                if (this.s.get() != SubscriptionHelper.CANCELLED) {
                     SubscriptionHelper.reportSubscriptionSet();
                 }
                 return;
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSamplePublisher.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSamplePublisher.java
index 6df856259e..cbd07ad253 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSamplePublisher.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSamplePublisher.java
@@ -48,18 +48,6 @@ protected void subscribeActual(Subscriber<? super T> s) {
 
         final AtomicReference<Subscription> other = new AtomicReference<Subscription>();
         
-        static final Subscription CANCELLED = new Subscription() {
-            @Override
-            public void request(long n) {
-                
-            }
-            
-            @Override
-            public void cancel() {
-                
-            }
-        };
-        
         Subscription s;
         
         public SamplePublisherSubscriber(Subscriber<? super T> actual, Publisher<?> other) {
@@ -89,26 +77,16 @@ public void onNext(T t) {
         
         @Override
         public void onError(Throwable t) {
-            cancelOther();
+            SubscriptionHelper.dispose(other);
             actual.onError(t);
         }
         
         @Override
         public void onComplete() {
-            cancelOther();
+            SubscriptionHelper.dispose(other);
             actual.onComplete();
         }
-        
-        void cancelOther() {
-            Subscription o = other.get();
-            if (o != CANCELLED) {
-                o = other.getAndSet(CANCELLED);
-                if (o != CANCELLED && o != null) {
-                    o.cancel();
-                }
-            }
-        }
-        
+
         boolean setOther(Subscription o) {
             if (other.get() == null) {
                 if (other.compareAndSet(null, o)) {
@@ -130,7 +108,7 @@ public void request(long n) {
         
         @Override
         public void cancel() {
-            cancelOther();
+            SubscriptionHelper.dispose(other);
             s.cancel();
         }
         
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
index c4d8188404..25771aadd3 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java
@@ -320,19 +320,7 @@ boolean checkTerminated(boolean d, boolean empty, Subscriber<? super R> a) {
         
         volatile boolean done;
         Throwable error;
-        
-        static final Subscription CANCELLED = new Subscription() {
-            @Override
-            public void request(long n) {
-                
-            }
-            
-            @Override
-            public void cancel() {
-                
-            }
-        };
-        
+
         public SwitchMapInnerSubscriber(SwitchMapSubscriber<T, R> parent, long index, int bufferSize) {
             this.parent = parent;
             this.index = index;
@@ -351,7 +339,7 @@ public void onSubscribe(Subscription s) {
             if (index == parent.unique) {
                 if (!compareAndSet(null, s)) {
                     s.cancel();
-                    if (get() != CANCELLED) {
+                    if (get() != SubscriptionHelper.CANCELLED) {
                         SubscriptionHelper.reportSubscriptionSet();
                     }
                     return;
@@ -393,13 +381,7 @@ public void onComplete() {
         }
         
         public void cancel() {
-            Subscription s = get();
-            if (s != CANCELLED) {
-                s = getAndSet(CANCELLED);
-                if (s != CANCELLED && s != null) {
-                    s.cancel();
-                }
-            }
+            SubscriptionHelper.dispose(this);
         }
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTimed.java
index 29f9bced8f..b67f6dcac6 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableThrottleFirstTimed.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.*;
 
@@ -60,11 +61,6 @@ protected void subscribeActual(Subscriber<? super T> s) {
         
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
 
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
         static final Disposable NEW_TIMER = new Disposable() {
             @Override
             public void dispose() { }
@@ -80,16 +76,7 @@ public DebounceTimedSubscriber(Subscriber<? super T> actual, long timeout, TimeU
             this.unit = unit;
             this.worker = worker;
         }
-        
-        public void disposeTimer() {
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
+
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validateSubscription(this.s, s)) {
@@ -151,7 +138,7 @@ public void onError(Throwable t) {
                 return;
             }
             done = true;
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             actual.onError(t);
         }
         
@@ -161,7 +148,7 @@ public void onComplete() {
                 return;
             }
             done = true;
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             worker.dispose();
             actual.onComplete();
         }
@@ -176,7 +163,7 @@ public void request(long n) {
         
         @Override
         public void cancel() {
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             worker.dispose();
             s.cancel();
         }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java
index 5d796a4967..7dab36bb93 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -68,12 +69,7 @@ protected void subscribeActual(Subscriber<? super T> s) {
         
         final AtomicReference<Disposable> timeout = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
-        public TimeoutSubscriber(Subscriber<? super T> actual, 
+        public TimeoutSubscriber(Subscriber<? super T> actual,
                 Supplier<? extends Publisher<U>> firstTimeoutSelector,
                 Function<? super T, ? extends Publisher<V>> timeoutSelector) {
             this.actual = actual;
@@ -178,14 +174,7 @@ public void request(long n) {
         public void cancel() {
             cancelled = true;
             s.cancel();
-            
-            Disposable d = timeout.get();
-            if (d != CANCELLED) {
-                d = timeout.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
+            DisposableHelper.dispose(timeout);
         }
         
         @Override
@@ -256,11 +245,6 @@ public void onComplete() {
         
         final AtomicReference<Disposable> timeout = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
         public TimeoutOtherSubscriber(Subscriber<? super T> actual,
                 Supplier<? extends Publisher<U>> firstTimeoutSelector,
                 Function<? super T, ? extends Publisher<V>> timeoutSelector, Publisher<? extends T> other) {
@@ -374,14 +358,7 @@ public void onComplete() {
         public void dispose() {
             cancelled = true;
             s.cancel();
-            
-            Disposable d = timeout.get();
-            if (d != CANCELLED) {
-                d = timeout.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
+            DisposableHelper.dispose(timeout);
         }
         
         @Override
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java
index 317ac9b6cd..f3d8477eec 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -68,11 +69,6 @@ protected void subscribeActual(Subscriber<? super T> s) {
 
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
 
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
         static final Disposable NEW_TIMER = new Disposable() {
             @Override
             public void dispose() { }
@@ -132,7 +128,7 @@ public void run() {
                         if (idx == index) {
                             done = true;
                             s.cancel();
-                            disposeTimer();
+                            DisposableHelper.dispose(timer);
                             worker.dispose();
                             
                             if (other == null) {
@@ -162,7 +158,7 @@ public void onError(Throwable t) {
             }
             done = true;
             worker.dispose();
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             arbiter.onError(t, s);
         }
         
@@ -173,24 +169,14 @@ public void onComplete() {
             }
             done = true;
             worker.dispose();
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             arbiter.onComplete(s);
         }
         
         @Override
         public void dispose() {
             worker.dispose();
-            disposeTimer();
-        }
-        
-        public void disposeTimer() {
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
+            DisposableHelper.dispose(timer);
         }
     }
     
@@ -204,11 +190,6 @@ public void disposeTimer() {
         
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
 
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
         static final Disposable NEW_TIMER = new Disposable() {
             @Override
             public void dispose() { }
@@ -301,19 +282,9 @@ public void onComplete() {
         @Override
         public void dispose() {
             worker.dispose();
-            disposeTimer();
+            DisposableHelper.dispose(timer);
         }
-        
-        public void disposeTimer() {
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
-        
+
         @Override
         public void request(long n) {
             s.request(n);
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java
index 7de941a549..1f274cb669 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.Queue;
 import java.util.concurrent.atomic.*;
 
@@ -57,11 +58,6 @@ protected void subscribeActual(Subscriber<? super Flowable<T>> s) {
         
         final AtomicReference<Disposable> boundary = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         UnicastProcessor<T> window;
         
         static final Object NEXT = new Object();
@@ -146,7 +142,7 @@ public void onError(Throwable t) {
             }
             
             if (windows.decrementAndGet() == 0) {
-                dispose();
+                DisposableHelper.dispose(boundary);
             }
             
             actual.onError(t);
@@ -163,7 +159,7 @@ public void onComplete() {
             }
             
             if (windows.decrementAndGet() == 0) {
-                dispose();
+                DisposableHelper.dispose(boundary);
             }
 
             actual.onComplete();
@@ -181,17 +177,7 @@ public void cancel() {
                 cancelled = true;
             }
         }
-        
-        void dispose() {
-            Disposable d = boundary.get();
-            if (d != CANCELLED) {
-                d = boundary.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
-        
+
         void drainLoop() {
             final Queue<Object> q = queue;
             final Subscriber<? super Flowable<T>> a = actual;
@@ -207,7 +193,7 @@ void drainLoop() {
                     boolean empty = o == null;
                     
                     if (d && empty) {
-                        dispose();
+                        DisposableHelper.dispose(boundary);
                         Throwable e = error;
                         if (e != null) {
                             w.onError(e);
@@ -225,7 +211,7 @@ void drainLoop() {
                         w.onComplete();
 
                         if (windows.decrementAndGet() == 0) {
-                            dispose();
+                            DisposableHelper.dispose(boundary);
                             return;
                         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java
index 779bfa139d..f472064843 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.*;
 import java.util.concurrent.atomic.*;
 
@@ -65,11 +66,6 @@ protected void subscribeActual(Subscriber<? super Flowable<T>> s) {
         
         final AtomicReference<Disposable> boundary = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         final List<UnicastProcessor<T>> ws;
         
         final AtomicLong windows = new AtomicLong();
@@ -199,13 +195,7 @@ public void cancel() {
         
         void dispose() {
             resources.dispose();
-            Disposable d = boundary.get();
-            if (d != CANCELLED) {
-                d = boundary.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
+            DisposableHelper.dispose(boundary);
         }
         
         void drainLoop() {
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java
index 38e096dfba..2ad714d733 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.Queue;
 import java.util.concurrent.atomic.*;
 
@@ -58,11 +59,6 @@ protected void subscribeActual(Subscriber<? super Flowable<T>> s) {
         
         final AtomicReference<Disposable> boundary = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         UnicastProcessor<T> window;
         
         static final Object NEXT = new Object();
@@ -165,7 +161,7 @@ public void onError(Throwable t) {
             }
             
             if (windows.decrementAndGet() == 0) {
-                dispose();
+                DisposableHelper.dispose(boundary);
             }
             
             actual.onError(t);
@@ -182,7 +178,7 @@ public void onComplete() {
             }
             
             if (windows.decrementAndGet() == 0) {
-                dispose();
+                DisposableHelper.dispose(boundary);
             }
 
             actual.onComplete();
@@ -200,17 +196,7 @@ public void cancel() {
                 cancelled = true;
             }
         }
-        
-        void dispose() {
-            Disposable d = boundary.get();
-            if (d != CANCELLED) {
-                d = boundary.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
-        
+
         void drainLoop() {
             final Queue<Object> q = queue;
             final Subscriber<? super Flowable<T>> a = actual;
@@ -225,7 +211,7 @@ void drainLoop() {
                     boolean empty = o == null;
                     
                     if (d && empty) {
-                        dispose();
+                        DisposableHelper.dispose(boundary);
                         Throwable e = error;
                         if (e != null) {
                             w.onError(e);
@@ -243,7 +229,7 @@ void drainLoop() {
                         w.onComplete();
 
                         if (windows.decrementAndGet() == 0) {
-                            dispose();
+                            DisposableHelper.dispose(boundary);
                             return;
                         }
 
@@ -256,13 +242,13 @@ void drainLoop() {
                         try {
                             p = other.get();
                         } catch (Throwable e) {
-                            dispose();
+                            DisposableHelper.dispose(boundary);
                             a.onError(e);
                             return;
                         }
                         
                         if (p == null) {
-                            dispose();
+                            DisposableHelper.dispose(boundary);
                             a.onError(new NullPointerException("The publisher supplied is null"));
                             return;
                         }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
index 3c838911c0..bab961b704 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.nio.channels.CancelledKeyException;
 import java.util.*;
 import java.util.concurrent.TimeUnit;
@@ -90,11 +91,6 @@ protected void subscribeActual(Subscriber<? super Flowable<T>> s) {
 
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
 
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         static final Object NEXT = new Object();
         
         volatile boolean terminated;
@@ -199,13 +195,7 @@ public void cancel() {
         @Override
         public void dispose() {
             selfCancel = true;
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
+            DisposableHelper.dispose(timer);
         }
         
         @Override
@@ -328,11 +318,6 @@ public boolean accept(Subscriber<? super Flowable<T>> a, Object v) {
         
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         public WindowExactBoundedSubscriber(
                 Subscriber<? super Flowable<T>> actual, 
                 long timespan, TimeUnit unit, Scheduler scheduler, 
@@ -493,13 +478,7 @@ public void cancel() {
         @Override
         public void dispose() {
             selfCancel = true;
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
+            DisposableHelper.dispose(timer);
         }
         
         @Override
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java
index 917b0d89e3..6978770fb1 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java
@@ -75,18 +75,8 @@ public void onComplete() {
         final AtomicReference<Subscription> s = new AtomicReference<Subscription>();
         
         final AtomicReference<Subscription> other = new AtomicReference<Subscription>();
-        
-        static final Subscription CANCELLED = new Subscription() {
-            @Override
-            public void request(long n) {
-                SubscriptionHelper.validateRequest(n);
-            }
-            
-            @Override
-            public void cancel() {
-                
-            }
-        };
+
+        static final Subscription CANCELLED = SubscriptionHelper.CANCELLED;
         
         public WithLatestFromSubscriber(Subscriber<? super R> actual, BiFunction<? super T, ? super U, ? extends R> combiner) {
             this.actual = actual;
@@ -122,13 +112,13 @@ public void onNext(T t) {
         
         @Override
         public void onError(Throwable t) {
-            cancelOther();
+            SubscriptionHelper.dispose(other);
             actual.onError(t);
         }
         
         @Override
         public void onComplete() {
-            cancelOther();
+            SubscriptionHelper.dispose(other);
             actual.onComplete();
         }
         
@@ -140,19 +130,9 @@ public void request(long n) {
         @Override
         public void cancel() {
             s.get().cancel();
-            cancelOther();
+            SubscriptionHelper.dispose(other);
         }
-        
-        void cancelOther() {
-            Subscription o = other.get();
-            if (o != CANCELLED) {
-                o = other.getAndSet(CANCELLED);
-                if (o != CANCELLED && o != null) {
-                    o.cancel();
-                }
-            }
-        }
-        
+
         public boolean setOther(Subscription o) {
             for (;;) {
                 Subscription current = other.get();
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
index 84f8fe58aa..9383606c89 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import java.util.Queue;
 import java.util.concurrent.atomic.*;
 
@@ -276,19 +277,7 @@ boolean checkTerminated(boolean d, boolean empty, Subscriber<? super R> a, boole
         final AtomicReference<Subscription> s = new AtomicReference<Subscription>();
         
         Subscription cachedS;
-        
-        static final Subscription CANCELLED = new Subscription() {
-            @Override
-            public void request(long n) {
-                
-            }
-            
-            @Override
-            public void cancel() {
-                
-            }
-        };
-        
+
         public ZipSubscriber(ZipCoordinator<T, R> parent, int bufferSize) {
             this.parent = parent;
             this.bufferSize = bufferSize;
@@ -305,7 +294,7 @@ public void onSubscribe(Subscription s) {
             
             for (;;) {
                 Subscription current = this.s.get();
-                if (current == CANCELLED) {
+                if (current == SubscriptionHelper.CANCELLED) {
                     s.cancel();
                     return;
                 }
@@ -365,13 +354,7 @@ public void request(long n) {
         
         @Override
         public void cancel() {
-            Subscription s = this.s.get();
-            if (s != CANCELLED) {
-                s = this.s.getAndSet(CANCELLED);
-                if (s != CANCELLED && s != null) {
-                    s.cancel();
-                }
-            }
+            SubscriptionHelper.dispose(s);
         }
         
         public void produced(long n) {
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeAmb.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeAmb.java
index b14b93d87d..ecd2b67e75 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeAmb.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeAmb.java
@@ -130,11 +130,6 @@ public void dispose() {
         
         boolean won;
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         public AmbInnerSubscriber(AmbCoordinator<T> parent, int index, Observer<? super T> actual) {
             this.parent = parent;
             this.index = index;
@@ -191,13 +186,7 @@ public void onComplete() {
         
         @Override
         public void dispose() {
-            Disposable s = get();
-            if (s != CANCELLED) {
-                s = getAndSet(CANCELLED);
-                if (s != CANCELLED && s != null) {
-                    s.dispose();
-                }
-            }
+            DisposableHelper.dispose(this);
         }
         
     }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeCombineLatest.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeCombineLatest.java
index 0fbe9d518f..b5e20bc3cc 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeCombineLatest.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeCombineLatest.java
@@ -320,11 +320,6 @@ void onError(Throwable e) {
         
         final AtomicReference<Disposable> s = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         public CombinerSubscriber(LatestCoordinator<T, R> parent, int index) {
             this.parent = parent;
             this.index = index;
@@ -365,13 +360,7 @@ public void onComplete() {
         
         @Override
         public void dispose() {
-            Disposable a = s.get();
-            if (a != CANCELLED) {
-                a = s.getAndSet(CANCELLED);
-                if (a != CANCELLED && a != null) {
-                    a.dispose();
-                }
-            }
+            DisposableHelper.dispose(s);
         }
     }
 }
\ No newline at end of file
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeZip.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeZip.java
index dc77a411bc..4439f4b5e0 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeZip.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOnSubscribeZip.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.observable;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.Queue;
 import java.util.concurrent.atomic.*;
 
@@ -241,12 +242,7 @@ boolean checkTerminated(boolean d, boolean empty, Observer<? super R> a, boolean
         Throwable error;
         
         final AtomicReference<Disposable> s = new AtomicReference<Disposable>();
-        
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
+
         public ZipSubscriber(ZipCoordinator<T, R> parent, int bufferSize) {
             this.parent = parent;
             this.queue = new SpscLinkedArrayQueue<T>(bufferSize);
@@ -256,7 +252,7 @@ public void onSubscribe(Disposable s) {
             
             for (;;) {
                 Disposable current = this.s.get();
-                if (current == CANCELLED) {
+                if (current == DisposableHelper.DISPOSED) {
                     s.dispose();
                     return;
                 }
@@ -304,13 +300,7 @@ public void onComplete() {
         
         @Override
         public void dispose() {
-            Disposable s = this.s.get();
-            if (s != CANCELLED) {
-                s = this.s.getAndSet(CANCELLED);
-                if (s != CANCELLED && s != null) {
-                    s.dispose();
-                }
-            }
+            DisposableHelper.dispose(s);
         }
     }
 }
\ No newline at end of file
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorBufferTimed.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorBufferTimed.java
index d390a0733d..46d334afcd 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorBufferTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorBufferTimed.java
@@ -88,11 +88,6 @@ public NbpOperatorBufferTimed(long timespan, long timeskip, TimeUnit unit, Sched
         
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
         public BufferExactUnboundedSubscriber(
                 Observer<? super U> actual, Supplier<U> bufferSupplier,
                 long timespan, TimeUnit unit, Scheduler scheduler) {
@@ -150,7 +145,7 @@ public void onNext(T t) {
         
         @Override
         public void onError(Throwable t) {
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             synchronized (this) {
                 buffer = null;
             }
@@ -159,7 +154,7 @@ public void onError(Throwable t) {
         
         @Override
         public void onComplete() {
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             U b;
             synchronized (this) {
                 b = buffer;
@@ -177,20 +172,10 @@ public void onComplete() {
         
         @Override
         public void dispose() {
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             s.dispose();
         }
-        
-        void disposeTimer() {
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
-        
+
         @Override
         public void run() {
             /*
@@ -232,7 +217,7 @@ public void run() {
             
             if (current == null) {
                 selfCancel = true;
-                disposeTimer();
+                DisposableHelper.dispose(timer);
                 return;
             }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDebounce.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDebounce.java
index 129fdec44b..4d1026d538 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDebounce.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDebounce.java
@@ -46,11 +46,6 @@ public NbpOperatorDebounce(Function<? super T, ? extends ObservableConsumable<U>
         Disposable s;
         
         final AtomicReference<Disposable> debouncer = new AtomicReference<Disposable>();
-        
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
 
         volatile long index;
         
@@ -109,7 +104,7 @@ public void onNext(T t) {
         
         @Override
         public void onError(Throwable t) {
-            disposeDebouncer();
+            DisposableHelper.dispose(debouncer);
             actual.onError(t);
         }
         
@@ -120,11 +115,11 @@ public void onComplete() {
             }
             done = true;
             Disposable d = debouncer.get();
-            if (d != CANCELLED) {
+            if (d != DisposableHelper.DISPOSED) {
                 @SuppressWarnings("unchecked")
                 DebounceInnerSubscriber<T, U> dis = (DebounceInnerSubscriber<T, U>)d;
                 dis.emit();
-                disposeDebouncer();
+                DisposableHelper.dispose(debouncer);
                 actual.onComplete();
             }
         }
@@ -132,19 +127,9 @@ public void onComplete() {
         @Override
         public void dispose() {
             s.dispose();
-            disposeDebouncer();
+            DisposableHelper.dispose(debouncer);
         }
-        
-        public void disposeDebouncer() {
-            Disposable d = debouncer.get();
-            if (d != CANCELLED) {
-                d = debouncer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
-        
+
         void emit(long idx, T value) {
             if (idx == index) {
                 actual.onNext(value);
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDebounceTimed.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDebounceTimed.java
index c518302457..67390d0ca9 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDebounceTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorDebounceTimed.java
@@ -53,16 +53,6 @@ public NbpOperatorDebounceTimed(long timeout, TimeUnit unit, Scheduler scheduler
         
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
 
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
-        static final Disposable NEW_TIMER = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         volatile long index;
         
         boolean done;
@@ -73,17 +63,7 @@ public DebounceTimedSubscriber(Observer<? super T> actual, long timeout, TimeUni
             this.unit = unit;
             this.worker = worker;
         }
-        
-        public void disposeTimer() {
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
-        
+
         @Override
         public void onSubscribe(Disposable s) {
             if (DisposableHelper.validate(this.s, s)) {
@@ -122,7 +102,7 @@ public void onError(Throwable t) {
                 return;
             }
             done = true;
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             actual.onError(t);
         }
         
@@ -134,11 +114,11 @@ public void onComplete() {
             done = true;
             
             Disposable d = timer.get();
-            if (d != CANCELLED) {
+            if (d != DisposableHelper.DISPOSED) {
                 @SuppressWarnings("unchecked")
                 DebounceEmitter<T> de = (DebounceEmitter<T>)d;
                 de.emit();
-                disposeTimer();
+                DisposableHelper.dispose(timer);
                 worker.dispose();
                 actual.onComplete();
             }
@@ -146,7 +126,7 @@ public void onComplete() {
         
         @Override
         public void dispose() {
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             worker.dispose();
             s.dispose();
         }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSampleWithObservable.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSampleWithObservable.java
index e6fb200ebb..4a7c621314 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSampleWithObservable.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSampleWithObservable.java
@@ -44,11 +44,6 @@ public NbpOperatorSampleWithObservable(ObservableConsumable<?> other) {
         
         final AtomicReference<Disposable> other = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         Disposable s;
         
         public SamplePublisherSubscriber(Observer<? super T> actual, ObservableConsumable<?> other) {
@@ -74,26 +69,16 @@ public void onNext(T t) {
         
         @Override
         public void onError(Throwable t) {
-            cancelOther();
+            DisposableHelper.dispose(other);
             actual.onError(t);
         }
         
         @Override
         public void onComplete() {
-            cancelOther();
+            DisposableHelper.dispose(other);
             actual.onComplete();
         }
-        
-        void cancelOther() {
-            Disposable o = other.get();
-            if (o != CANCELLED) {
-                o = other.getAndSet(CANCELLED);
-                if (o != CANCELLED && o != null) {
-                    o.dispose();
-                }
-            }
-        }
-        
+
         boolean setOther(Disposable o) {
             if (other.get() == null) {
                 if (other.compareAndSet(null, o)) {
@@ -106,7 +91,7 @@ boolean setOther(Disposable o) {
         
         @Override
         public void dispose() {
-            cancelOther();
+            DisposableHelper.dispose(other);
             s.dispose();
         }
         
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSwitchMap.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSwitchMap.java
index 5ca16b4fb5..591386c685 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSwitchMap.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorSwitchMap.java
@@ -289,12 +289,7 @@ boolean checkTerminated(boolean d, boolean empty, Subscriber<? super R> a) {
         
         volatile boolean done;
         Throwable error;
-        
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
+
         public SwitchMapInnerSubscriber(SwitchMapSubscriber<T, R> parent, long index, int bufferSize) {
             this.parent = parent;
             this.index = index;
@@ -313,7 +308,7 @@ public void onSubscribe(Disposable s) {
             if (index == parent.unique) {
                 if (!compareAndSet(null, s)) {
                     s.dispose();
-                    if (get() != CANCELLED) {
+                    if (get() != DisposableHelper.DISPOSED) {
                         SubscriptionHelper.reportSubscriptionSet();
                     }
                     return;
@@ -354,13 +349,7 @@ public void onComplete() {
         }
         
         public void cancel() {
-            Disposable s = get();
-            if (s != CANCELLED) {
-                s = getAndSet(CANCELLED);
-                if (s != CANCELLED && s != null) {
-                    s.dispose();
-                }
-            }
+            DisposableHelper.dispose(this);
         }
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorThrottleFirstTimed.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorThrottleFirstTimed.java
index 7f32e83022..455a035a8a 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorThrottleFirstTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorThrottleFirstTimed.java
@@ -53,11 +53,6 @@ public NbpOperatorThrottleFirstTimed(long timeout, TimeUnit unit, Scheduler sche
         
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
 
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
         static final Disposable NEW_TIMER = new Disposable() {
             @Override
             public void dispose() { }
@@ -73,16 +68,7 @@ public DebounceTimedSubscriber(Observer<? super T> actual, long timeout, TimeUni
             this.unit = unit;
             this.worker = worker;
         }
-        
-        public void disposeTimer() {
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
+
         @Override
         public void onSubscribe(Disposable s) {
             if (DisposableHelper.validate(this.s, s)) {
@@ -131,7 +117,7 @@ public void onError(Throwable t) {
                 return;
             }
             done = true;
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             actual.onError(t);
         }
         
@@ -141,14 +127,14 @@ public void onComplete() {
                 return;
             }
             done = true;
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             worker.dispose();
             actual.onComplete();
         }
         
         @Override
         public void dispose() {
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             worker.dispose();
             s.dispose();
         }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTimeout.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTimeout.java
index 9506462025..d959e6c02e 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTimeout.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTimeout.java
@@ -60,12 +60,7 @@ public NbpOperatorTimeout(Supplier<? extends ObservableConsumable<U>> firstTimeo
         
         final AtomicReference<Disposable> timeout = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
-        public TimeoutSubscriber(Observer<? super T> actual, 
+        public TimeoutSubscriber(Observer<? super T> actual,
                 Supplier<? extends ObservableConsumable<U>> firstTimeoutSelector,
                 Function<? super T, ? extends ObservableConsumable<V>> timeoutSelector) {
             this.actual = actual;
@@ -161,14 +156,8 @@ public void dispose() {
             if (!cancelled) {
                 cancelled = true;
                 s.dispose();
-                
-                Disposable d = timeout.get();
-                if (d != CANCELLED) {
-                    d = timeout.getAndSet(CANCELLED);
-                    if (d != CANCELLED && d != null) {
-                        d.dispose();
-                    }
-                }
+
+                DisposableHelper.dispose(timeout);
             }
         }
         
@@ -240,11 +229,6 @@ public void onComplete() {
         
         final AtomicReference<Disposable> timeout = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
         public TimeoutOtherSubscriber(Observer<? super T> actual,
                 Supplier<? extends ObservableConsumable<U>> firstTimeoutSelector,
                 Function<? super T, ? extends ObservableConsumable<V>> timeoutSelector, ObservableConsumable<? extends T> other) {
@@ -358,14 +342,8 @@ public void dispose() {
             if (!cancelled) {
                 cancelled = true;
                 s.dispose();
-                
-                Disposable d = timeout.get();
-                if (d != CANCELLED) {
-                    d = timeout.getAndSet(CANCELLED);
-                    if (d != CANCELLED && d != null) {
-                        d.dispose();
-                    }
-                }
+
+                DisposableHelper.dispose(timeout);
             }
         }
         
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTimeoutTimed.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTimeoutTimed.java
index 97754e99e6..81ce738b89 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTimeoutTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorTimeoutTimed.java
@@ -63,11 +63,6 @@ public NbpOperatorTimeoutTimed(long timeout, TimeUnit unit, Scheduler scheduler,
 
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
 
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
         static final Disposable NEW_TIMER = new Disposable() {
             @Override
             public void dispose() { }
@@ -126,7 +121,7 @@ public void run() {
                         if (idx == index) {
                             done = true;
                             s.dispose();
-                            disposeTimer();
+                            DisposableHelper.dispose(timer);
                             worker.dispose();
                             
                             if (other == null) {
@@ -156,7 +151,7 @@ public void onError(Throwable t) {
             }
             done = true;
             worker.dispose();
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             arbiter.onError(t, s);
         }
         
@@ -167,24 +162,14 @@ public void onComplete() {
             }
             done = true;
             worker.dispose();
-            disposeTimer();
+            DisposableHelper.dispose(timer);
             arbiter.onComplete(s);
         }
         
         @Override
         public void dispose() {
             worker.dispose();
-            disposeTimer();
-        }
-        
-        public void disposeTimer() {
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
+            DisposableHelper.dispose(timer);
         }
     }
     
@@ -198,11 +183,6 @@ public void disposeTimer() {
         
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
 
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-
         static final Disposable NEW_TIMER = new Disposable() {
             @Override
             public void dispose() { }
@@ -294,17 +274,7 @@ public void onComplete() {
         @Override
         public void dispose() {
             worker.dispose();
-            disposeTimer();
-        }
-        
-        public void disposeTimer() {
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
+            DisposableHelper.dispose(timer);
         }
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundary.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundary.java
index 5a210f55bf..7f7095e6a8 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundary.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundary.java
@@ -52,11 +52,6 @@ public NbpOperatorWindowBoundary(ObservableConsumable<B> other, int bufferSize)
         
         final AtomicReference<Disposable> boundary = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         UnicastSubject<T> window;
         
         static final Object NEXT = new Object();
@@ -130,7 +125,7 @@ public void onError(Throwable t) {
             }
             
             if (windows.decrementAndGet() == 0) {
-                disposeBoundary();
+                DisposableHelper.dispose(boundary);
             }
             
             actual.onError(t);
@@ -147,7 +142,7 @@ public void onComplete() {
             }
             
             if (windows.decrementAndGet() == 0) {
-                disposeBoundary();
+                DisposableHelper.dispose(boundary);
             }
 
             actual.onComplete();
@@ -160,17 +155,7 @@ public void dispose() {
                 cancelled = true;
             }
         }
-        
-        void disposeBoundary() {
-            Disposable d = boundary.get();
-            if (d != CANCELLED) {
-                d = boundary.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
-        
+
         void drainLoop() {
             final Queue<Object> q = queue;
             final Observer<? super Observable<T>> a = actual;
@@ -186,7 +171,7 @@ void drainLoop() {
                     boolean empty = o == null;
                     
                     if (d && empty) {
-                        disposeBoundary();
+                        DisposableHelper.dispose(boundary);
                         Throwable e = error;
                         if (e != null) {
                             w.onError(e);
@@ -204,7 +189,7 @@ void drainLoop() {
                         w.onComplete();
 
                         if (windows.decrementAndGet() == 0) {
-                            disposeBoundary();
+                            DisposableHelper.dispose(boundary);
                             return;
                         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySelector.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySelector.java
index 3a62dc658c..6ddca031d4 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySelector.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySelector.java
@@ -61,11 +61,6 @@ public NbpOperatorWindowBoundarySelector(ObservableConsumable<B> open, Function<
         
         final AtomicReference<Disposable> boundary = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         final List<UnicastSubject<T>> ws;
         
         final AtomicLong windows = new AtomicLong();
@@ -185,13 +180,7 @@ public void dispose() {
         
         void disposeBoundary() {
             resources.dispose();
-            Disposable d = boundary.get();
-            if (d != CANCELLED) {
-                d = boundary.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
+            DisposableHelper.dispose(boundary);
         }
         
         void drainLoop() {
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySupplier.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySupplier.java
index 0d11025ee8..fd0232f143 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySupplier.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowBoundarySupplier.java
@@ -53,11 +53,6 @@ public NbpOperatorWindowBoundarySupplier(Supplier<? extends ObservableConsumable
         
         final AtomicReference<Disposable> boundary = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         UnicastSubject<T> window;
         
         static final Object NEXT = new Object();
@@ -148,7 +143,7 @@ public void onError(Throwable t) {
             }
             
             if (windows.decrementAndGet() == 0) {
-                disposeBoundary();
+                DisposableHelper.dispose(boundary);
             }
             
             actual.onError(t);
@@ -165,7 +160,7 @@ public void onComplete() {
             }
             
             if (windows.decrementAndGet() == 0) {
-                disposeBoundary();
+                DisposableHelper.dispose(boundary);
             }
 
             actual.onComplete();
@@ -178,17 +173,7 @@ public void dispose() {
                 cancelled = true;
             }
         }
-        
-        void disposeBoundary() {
-            Disposable d = boundary.get();
-            if (d != CANCELLED) {
-                d = boundary.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
-        }
-        
+
         void drainLoop() {
             final Queue<Object> q = queue;
             final Observer<? super Observable<T>> a = actual;
@@ -203,7 +188,7 @@ void drainLoop() {
                     boolean empty = o == null;
                     
                     if (d && empty) {
-                        disposeBoundary();
+                        DisposableHelper.dispose(boundary);
                         Throwable e = error;
                         if (e != null) {
                             w.onError(e);
@@ -221,7 +206,7 @@ void drainLoop() {
                         w.onComplete();
 
                         if (windows.decrementAndGet() == 0) {
-                            disposeBoundary();
+                            DisposableHelper.dispose(boundary);
                             return;
                         }
 
@@ -234,13 +219,13 @@ void drainLoop() {
                         try {
                             p = other.get();
                         } catch (Throwable e) {
-                            disposeBoundary();
+                            DisposableHelper.dispose(boundary);
                             a.onError(e);
                             return;
                         }
                         
                         if (p == null) {
-                            disposeBoundary();
+                            DisposableHelper.dispose(boundary);
                             a.onError(new NullPointerException("The NbpObservable supplied is null"));
                             return;
                         }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowTimed.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowTimed.java
index 812ae0b09d..ae9b10ca7f 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWindowTimed.java
@@ -86,11 +86,6 @@ public NbpOperatorWindowTimed(long timespan, long timeskip, TimeUnit unit, Sched
 
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
 
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         static final Object NEXT = new Object();
         
         volatile boolean terminated;
@@ -176,13 +171,7 @@ public void dispose() {
         
         void disposeTimer() {
             selfCancel = true;
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
+            DisposableHelper.dispose(timer);
         }
         
         @Override
@@ -291,11 +280,6 @@ public void accept(Observer<? super Observable<T>> a, Object v) {
         
         final AtomicReference<Disposable> timer = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
-        
         public WindowExactBoundedSubscriber(
                 Observer<? super Observable<T>> actual, 
                 long timespan, TimeUnit unit, Scheduler scheduler, 
@@ -422,13 +406,7 @@ public void dispose() {
         
         void disposeTimer() {
             selfCancel = true;
-            Disposable d = timer.get();
-            if (d != CANCELLED) {
-                d = timer.getAndSet(CANCELLED);
-                if (d != CANCELLED && d != null) {
-                    d.dispose();
-                }
-            }
+            DisposableHelper.dispose(timer);
         }
         
         @Override
diff --git a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWithLatestFrom.java b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWithLatestFrom.java
index 2a23879503..0f5d91c4e0 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWithLatestFrom.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/NbpOperatorWithLatestFrom.java
@@ -72,10 +72,7 @@ public void onComplete() {
         
         final AtomicReference<Disposable> other = new AtomicReference<Disposable>();
         
-        static final Disposable CANCELLED = new Disposable() {
-            @Override
-            public void dispose() { }
-        };
+        static final Disposable CANCELLED = DisposableHelper.DISPOSED;
         
         public WithLatestFromSubscriber(Observer<? super R> actual, BiFunction<? super T, ? super U, ? extends R> combiner) {
             this.actual = actual;
@@ -106,32 +103,22 @@ public void onNext(T t) {
         
         @Override
         public void onError(Throwable t) {
-            cancelOther();
+            DisposableHelper.dispose(other);
             actual.onError(t);
         }
         
         @Override
         public void onComplete() {
-            cancelOther();
+            DisposableHelper.dispose(other);
             actual.onComplete();
         }
         
         @Override
         public void dispose() {
             s.get().dispose();
-            cancelOther();
-        }
-        
-        void cancelOther() {
-            Disposable o = other.get();
-            if (o != CANCELLED) {
-                o = other.getAndSet(CANCELLED);
-                if (o != CANCELLED && o != null) {
-                    o.dispose();
-                }
-            }
+            DisposableHelper.dispose(other);
         }
-        
+
         public boolean setOther(Disposable o) {
             for (;;) {
                 Disposable current = other.get();
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSubscriber.java
index d9181d38e4..60aa0f6f8f 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSubscriber.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.subscribers.flowable;
 
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -24,18 +25,6 @@
     /** */
     private static final long serialVersionUID = -4875965440900746268L;
 
-    static final Subscription CANCELLED = new Subscription() {
-        @Override
-        public void request(long n) {
-            
-        }
-        
-        @Override
-        public void cancel() {
-            
-        }
-    };
-    
     public static final Object TERMINATED = new Object();
     
     final Queue<Object> queue;
@@ -48,7 +37,7 @@ public BlockingSubscriber(Queue<Object> queue) {
     public void onSubscribe(Subscription s) {
         if (!compareAndSet(null, s)) {
             s.cancel();
-            if (get() != CANCELLED) {
+            if (get() != SubscriptionHelper.CANCELLED) {
                 onError(new IllegalStateException("Subscription already set"));
             }
             return;
@@ -78,17 +67,12 @@ public void request(long n) {
     
     @Override
     public void cancel() {
-        Subscription s = get();
-        if (s != CANCELLED) {
-            s = getAndSet(CANCELLED);
-            if (s != CANCELLED && s != null) {
-                s.cancel();
-                queue.offer(TERMINATED);
-            }
+        if (SubscriptionHelper.dispose(this)) {
+            queue.offer(TERMINATED);
         }
     }
     
     public boolean isCancelled() {
-        return get() == CANCELLED;
+        return get() == SubscriptionHelper.CANCELLED;
     }
 }
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/DisposableSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/DisposableSubscriber.java
index 4a1a5d210f..59f400361d 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/DisposableSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/DisposableSubscriber.java
@@ -27,24 +27,12 @@
  */
 public abstract class DisposableSubscriber<T> implements Subscriber<T>, Disposable {
     final AtomicReference<Subscription> s = new AtomicReference<Subscription>();
-    
-    static final Subscription CANCELLED = new Subscription() {
-        @Override
-        public void request(long n) {
-            
-        }
-        
-        @Override
-        public void cancel() {
-            
-        }
-    };
-    
+
     @Override
     public final void onSubscribe(Subscription s) {
         if (!this.s.compareAndSet(null, s)) {
             s.cancel();
-            if (this.s.get() != CANCELLED) {
+            if (this.s.get() != SubscriptionHelper.CANCELLED) {
                 SubscriptionHelper.reportSubscriptionSet();
             }
             return;
@@ -69,17 +57,11 @@ protected final void cancel() {
     }
     
     public final boolean isDisposed() {
-        return s.get() == CANCELLED;
+        return s.get() == SubscriptionHelper.CANCELLED;
     }
     
     @Override
     public final void dispose() {
-        Subscription a = s.get();
-        if (a != CANCELLED) {
-            a = s.getAndSet(CANCELLED);
-            if (a != CANCELLED && a != null) {
-                a.cancel();
-            }
-        }
+        SubscriptionHelper.dispose(s);
     }
 }
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/NbpBlockingSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/observable/NbpBlockingSubscriber.java
index bf2b5d22ba..4dfa7853cb 100644
--- a/src/main/java/io/reactivex/internal/subscribers/observable/NbpBlockingSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/NbpBlockingSubscriber.java
@@ -18,17 +18,13 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.util.NotificationLite;
 
 public final class NbpBlockingSubscriber<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {
     /** */
     private static final long serialVersionUID = -4875965440900746268L;
 
-    static final Disposable CANCELLED = new Disposable() {
-        @Override
-        public void dispose() { }
-    };
-    
     public static final Object TERMINATED = new Object();
 
     final Queue<Object> queue;
@@ -41,7 +37,7 @@ public NbpBlockingSubscriber(Queue<Object> queue) {
     public void onSubscribe(Disposable s) {
         if (!compareAndSet(null, s)) {
             s.dispose();
-            if (get() != CANCELLED) {
+            if (get() != DisposableHelper.DISPOSED) {
                 onError(new IllegalStateException("Subscription already set"));
             }
             return;
@@ -65,17 +61,12 @@ public void onComplete() {
     
     @Override
     public void dispose() {
-        Disposable s = get();
-        if (s != CANCELLED) {
-            s = getAndSet(CANCELLED);
-            if (s != CANCELLED && s != null) {
-                s.dispose();
-                queue.offer(TERMINATED);
-            }
+        if (DisposableHelper.dispose(this)) {
+            queue.offer(TERMINATED);
         }
     }
     
     public boolean isCancelled() {
-        return get() == CANCELLED;
+        return get() == DisposableHelper.DISPOSED;
     }
 }
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/NbpDisposableSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/observable/NbpDisposableSubscriber.java
index bae3c6328f..f5c25dcdf6 100644
--- a/src/main/java/io/reactivex/internal/subscribers/observable/NbpDisposableSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/NbpDisposableSubscriber.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.subscribers.observable;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.reactivex.Observer;
@@ -26,17 +27,12 @@
  */
 public abstract class NbpDisposableSubscriber<T> implements Observer<T>, Disposable {
     final AtomicReference<Disposable> s = new AtomicReference<Disposable>();
-    
-    static final Disposable CANCELLED = new Disposable() {
-        @Override
-        public void dispose() { }
-    };
-    
+
     @Override
     public final void onSubscribe(Disposable s) {
         if (!this.s.compareAndSet(null, s)) {
             s.dispose();
-            if (this.s.get() != CANCELLED) {
+            if (this.s.get() != DisposableHelper.DISPOSED) {
                 SubscriptionHelper.reportSubscriptionSet();
             }
             return;
@@ -48,17 +44,11 @@ protected void onStart() {
     }
     
     public final boolean isDisposed() {
-        return s == CANCELLED;
+        return s == DisposableHelper.DISPOSED;
     }
     
     @Override
     public final void dispose() {
-        Disposable a = s.get();
-        if (a != CANCELLED) {
-            a = s.getAndSet(CANCELLED);
-            if (a != CANCELLED && a != null) {
-                a.dispose();
-            }
-        }
+        DisposableHelper.dispose(s);
     }
 }
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/NbpLambdaSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/observable/NbpLambdaSubscriber.java
index 501912bcf1..a10a277c99 100644
--- a/src/main/java/io/reactivex/internal/subscribers/observable/NbpLambdaSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/NbpLambdaSubscriber.java
@@ -29,12 +29,7 @@
     final Runnable onComplete;
     final Consumer<? super Disposable> onSubscribe;
     
-    static final Disposable CANCELLED = new Disposable() {
-        @Override
-        public void dispose() { }
-    };
-    
-    public NbpLambdaSubscriber(Consumer<? super T> onNext, Consumer<? super Throwable> onError, 
+    public NbpLambdaSubscriber(Consumer<? super T> onNext, Consumer<? super Throwable> onError,
             Runnable onComplete,
             Consumer<? super Disposable> onSubscribe) {
         super();
@@ -83,12 +78,6 @@ public void onComplete() {
     
     @Override
     public void dispose() {
-        Disposable o = get();
-        if (o != CANCELLED) {
-            o = getAndSet(CANCELLED);
-            if (o != CANCELLED && o != null) {
-                o.dispose();
-            }
-        }
+        DisposableHelper.dispose(this);
     }
 }
diff --git a/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java b/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java
index 0bae5f22f3..8e76a5a474 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.subscriptions;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.concurrent.atomic.*;
 
 import org.reactivestreams.Subscription;
@@ -33,35 +34,7 @@
     final AtomicReference<Subscription> actual;
 
     final AtomicReference<Disposable> resource;
-    
-    static final Subscription CANCELLED = new Subscription() {
-        @Override
-        public void request(long n) {
-            
-        }
-        @Override
-        public void cancel() {
-            
-        }
-        
-        @Override
-        public String toString() {
-            return "AsyncSubscription.CANCELLED";
-        }
-    };
-    
-    static final Disposable DISPOSED = new Disposable() {
-        @Override
-        public void dispose() { 
-            
-        }
-        
-        @Override
-        public String toString() {
-            return "AsyncSubscription.DISPOSED";
-        };
-    };
-    
+
     public AsyncSubscription() {
         resource = new AtomicReference<Disposable>();
         actual = new AtomicReference<Subscription>();
@@ -94,21 +67,8 @@ public void request(long n) {
     
     @Override
     public void cancel() {
-        Subscription s = actual.get();
-        if (s != CANCELLED) {
-            s = actual.getAndSet(CANCELLED);
-            if (s != CANCELLED && s != null) {
-                s.cancel();
-            }
-        }
-        
-        Disposable d = resource.get();
-        if (d != DISPOSED) {
-            d = resource.getAndSet(DISPOSED);
-            if (d != CANCELLED && d != null) {
-                d.dispose();
-            }
-        }
+        SubscriptionHelper.dispose(actual);
+        DisposableHelper.dispose(resource);
     }
     
     @Override
@@ -123,21 +83,7 @@ public void dispose() {
      * @see #replaceResource(Disposable)
      */
     public boolean setResource(Disposable r) {
-        for (;;) {
-            Disposable d = resource.get();
-            if (d == DISPOSED) {
-                if (r != null) {
-                    r.dispose();
-                }
-                return false;
-            }
-            if (resource.compareAndSet(d, r)) {
-                if (d != null) {
-                    d.dispose();
-                }
-                return true;
-            }
-        }
+        return DisposableHelper.set(resource, r);
     }
     
     /**
@@ -146,18 +92,7 @@ public boolean setResource(Disposable r) {
      * @return false if this AsyncSubscription has been cancelled/disposed
      */
     public boolean replaceResource(Disposable r) {
-        for (;;) {
-            Disposable d = resource.get();
-            if (d == DISPOSED) {
-                if (r != null) {
-                    r.dispose();
-                }
-                return false;
-            }
-            if (resource.compareAndSet(d, r)) {
-                return true;
-            }
-        }
+        return DisposableHelper.replace(resource, r);
     }
     
     /**
@@ -168,7 +103,7 @@ public boolean replaceResource(Disposable r) {
     public boolean setSubscription(Subscription s) {
         for (;;) {
             Subscription a = actual.get();
-            if (a == CANCELLED) {
+            if (a == SubscriptionHelper.CANCELLED) {
                 s.cancel();
                 return false;
             }
diff --git a/src/main/java/io/reactivex/internal/subscriptions/DisposableSubscription.java b/src/main/java/io/reactivex/internal/subscriptions/DisposableSubscription.java
deleted file mode 100644
index 247f08003a..0000000000
--- a/src/main/java/io/reactivex/internal/subscriptions/DisposableSubscription.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/**
- * Copyright 2016 Netflix, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
- * the License for the specific language governing permissions and limitations under the License.
- */
-
-package io.reactivex.internal.subscriptions;
-
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.reactivestreams.Subscription;
-
-import io.reactivex.disposables.Disposable;
-
-/**
- * Subscription that ignores (but validates) requests and delegates cancel to a disposable instance.
- */
-public final class DisposableSubscription extends AtomicReference<Disposable> implements Subscription {
-    /** */
-    private static final long serialVersionUID = -2358839743797425727L;
-    /** The disposed state indicator. */
-    static final Disposable DISPOSED = new Disposable() {
-        @Override
-        public void dispose() { }
-    };
-    
-    /**
-     * Constructs an empty DisposableSubscription.
-     */
-    public DisposableSubscription() {
-    }
-
-    /**
-     * Constructs a DisposableSubscription by wrapping the given Disposable.
-     * @param d the disposable to wrap, may be null
-     */
-    public DisposableSubscription(Disposable d) {
-        this.lazySet(d);
-    }
-    
-    @Override
-    public void request(long n) {
-        if (SubscriptionHelper.validateRequest(n)) {
-            return;
-        }
-    }
-    
-    /**
-     * Sets a new disposable resource and disposes any old one.
-     * @param d the new disposable to set
-     * @return false if this Subscription has been cancelled
-     */
-    public boolean setDisposable(Disposable d) {
-        for (;;) {
-            Disposable a = get();
-            if (a == DISPOSED) {
-                if (d != null) {
-                    d.dispose();
-                }
-                return false;
-            }
-            if (compareAndSet(a, d)) {
-                if (a != null) {
-                    a.dispose();
-                }
-                return true;
-            }
-        }
-    }
-    
-    /**
-     * Replaces any existing disposable with a new disposable but doesn't dispose the old one.
-     * @param d the new disposable to set
-     * @return false if this disposable was disposed
-     */
-    public boolean replaceDisposable(Disposable d) {
-        for (;;) {
-            Disposable a = get();
-            if (a == DISPOSED) {
-                if (d != null) {
-                    d.dispose();
-                }
-                return false;
-            }
-            if (compareAndSet(a, d)) {
-                return true;
-            }
-        }
-    }
-    
-    @Override
-    public void cancel() {
-        Disposable d = get();
-        if (d != DISPOSED) {
-            d = getAndSet(DISPOSED);
-            if (d != DISPOSED && d != null) {
-                d.dispose();
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/io/reactivex/observers/AsyncObserver.java b/src/main/java/io/reactivex/observers/AsyncObserver.java
index 884159fd2f..5bb78dae42 100644
--- a/src/main/java/io/reactivex/observers/AsyncObserver.java
+++ b/src/main/java/io/reactivex/observers/AsyncObserver.java
@@ -19,7 +19,6 @@
 import io.reactivex.disposables.*;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.functions.Objects;
-import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
 /**
  * An abstract Subscriber implementation that allows asynchronous cancellation of its
@@ -39,12 +38,6 @@
     /** The resource composite, can be null. */
     private final ListCompositeResource<Disposable> resources;
     
-    /** The cancelled subscription indicator. */
-    private static final Disposable CANCELLED = new Disposable() {
-        @Override
-        public void dispose() { }
-    };
-    
     /**
      * Constructs an AsyncObserver with resource support.
      */
@@ -116,15 +109,8 @@ protected void onStart() {
      * case the main Disposable will be immediately disposed.
      */
     protected final void cancel() {
-        Disposable a = s.get();
-        if (a != CANCELLED) {
-            a = s.getAndSet(CANCELLED);
-            if (a != CANCELLED && a != null) {
-                a.dispose();
-                if (resources != null) {
-                    resources.dispose();
-                }
-            }
+        if (DisposableHelper.dispose(s) && resources != null) {
+            resources.dispose();
         }
     }
     
@@ -138,6 +124,6 @@ public final void dispose() {
      * @return true if this AsyncObserver has been disposed/cancelled
      */
     public final boolean isDisposed() {
-        return s == CANCELLED;
+        return DisposableHelper.isDisposed(s.get());
     }
 }
diff --git a/src/main/java/io/reactivex/observers/TestObserver.java b/src/main/java/io/reactivex/observers/TestObserver.java
index 9fc8139d06..d25de4e77a 100644
--- a/src/main/java/io/reactivex/observers/TestObserver.java
+++ b/src/main/java/io/reactivex/observers/TestObserver.java
@@ -12,6 +12,7 @@
  */
 package io.reactivex.observers;
 
+import io.reactivex.internal.disposables.DisposableHelper;
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicReference;
@@ -55,12 +56,6 @@
 
     /** Holds the current subscription if any. */
     private final AtomicReference<Disposable> subscription = new AtomicReference<Disposable>();
-    
-    /** Indicates a cancelled subscription. */
-    private static final Disposable CANCELLED = new Disposable() {
-        @Override
-        public void dispose() { }
-    };
 
     private boolean checkSubscriptionOnce;
 
@@ -92,7 +87,7 @@ public void onSubscribe(Disposable s) {
         }
         if (!subscription.compareAndSet(null, s)) {
             s.dispose();
-            if (subscription.get() != CANCELLED) {
+            if (subscription.get() != DisposableHelper.DISPOSED) {
                 errors.add(new NullPointerException("onSubscribe received multiple subscriptions: " + s));
             }
             return;
@@ -182,13 +177,7 @@ public final boolean isCancelled() {
     public final void dispose() {
         if (!cancelled) {
             cancelled = true;
-            Disposable s = subscription.get();
-            if (s != CANCELLED) {
-                s = subscription.getAndSet(CANCELLED);
-                if (s != CANCELLED && s != null) {
-                    s.dispose();
-                }
-            }
+            DisposableHelper.dispose(subscription);
         }
     }
     
diff --git a/src/main/java/io/reactivex/subscribers/AsyncSubscriber.java b/src/main/java/io/reactivex/subscribers/AsyncSubscriber.java
index 4518e26eaf..ef667dcf9d 100644
--- a/src/main/java/io/reactivex/subscribers/AsyncSubscriber.java
+++ b/src/main/java/io/reactivex/subscribers/AsyncSubscriber.java
@@ -43,20 +43,7 @@
     
     /** Remembers the request(n) counts until a subscription arrives. */
     private final AtomicLong missedRequested;
-    
-    /** The cancelled subscription indicator. */
-    private static final Subscription CANCELLED = new Subscription() {
-        @Override
-        public void request(long n) {
-            // deliberately no op
-        }
-        
-        @Override
-        public void cancel() {
-            // deliberately no op
-        }
-    };
-    
+
     /**
      * Constructs an AsyncObserver with resource support.
      */
@@ -110,7 +97,7 @@ public final boolean supportsResources() {
     public final void onSubscribe(Subscription s) {
         if (!this.s.compareAndSet(null, s)) {
             s.cancel();
-            if (s != CANCELLED) {
+            if (s != SubscriptionHelper.CANCELLED) {
                 SubscriptionHelper.reportSubscriptionSet();
             }
             return;
@@ -168,15 +155,8 @@ protected final void request(long n) {
      * case the Subscription will be immediately cancelled.
      */
     protected final void cancel() {
-        Subscription a = s.get();
-        if (a != CANCELLED) {
-            a = s.getAndSet(CANCELLED);
-            if (a != CANCELLED && a != null) {
-                a.cancel();
-                if (resources != null) {
-                    resources.dispose();
-                }
-            }
+        if (SubscriptionHelper.dispose(s) && resources != null) {
+            resources.dispose();
         }
     }
     
@@ -190,6 +170,6 @@ public final void dispose() {
      * @return true if this AsyncObserver has been disposed/cancelled
      */
     public final boolean isDisposed() {
-        return s == CANCELLED;
+        return SubscriptionHelper.isCancelled(s.get());
     }
 }
diff --git a/src/main/java/io/reactivex/subscribers/TestSubscriber.java b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
index a7546b8c5c..f6e9cb96d6 100644
--- a/src/main/java/io/reactivex/subscribers/TestSubscriber.java
+++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
@@ -65,19 +65,7 @@
     private final AtomicLong missedRequested = new AtomicLong();
     
     private boolean checkSubscriptionOnce;
-    
-    /** Indicates a cancelled subscription. */
-    private static final Subscription CANCELLED = new Subscription() {
-        @Override
-        public void request(long n) {
-            
-        }
-        
-        @Override
-        public void cancel() {
-            
-        }
-    };
+
     /**
      * Constructs a non-forwarding TestSubscriber with an initial request value of Long.MAX_VALUE.
      */
@@ -128,7 +116,7 @@ public void onSubscribe(Subscription s) {
         }
         if (!subscription.compareAndSet(null, s)) {
             s.cancel();
-            if (subscription.get() != CANCELLED) {
+            if (subscription.get() != SubscriptionHelper.CANCELLED) {
                 errors.add(new IllegalStateException("onSubscribe received multiple subscriptions: " + s));
             }
             return;
@@ -236,13 +224,7 @@ public void request(long n) {
     public void cancel() {
         if (!cancelled) {
             cancelled = true;
-            Subscription s = subscription.get();
-            if (s != CANCELLED) {
-                s = subscription.getAndSet(CANCELLED);
-                if (s != CANCELLED && s != null) {
-                    s.cancel();
-                }
-            }
+            SubscriptionHelper.dispose(subscription);
         }
     }
     
