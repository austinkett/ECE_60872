diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java
index b27e163b63..e631463bea 100644
--- a/src/main/java/io/reactivex/Completable.java
+++ b/src/main/java/io/reactivex/Completable.java
@@ -225,15 +225,7 @@ public static Completable unsafeCreate(CompletableSource source) {
         if (source instanceof Completable) {
             throw new IllegalArgumentException("Use of unsafeCreate(Completable)!");
         }
-        try {
-            return RxJavaPlugins.onAssembly(new CompletableFromUnsafeSource(source));
-        } catch (NullPointerException ex) { // NOPMD
-            throw ex;
-        } catch (Throwable ex) {
-            Exceptions.throwIfFatal(ex);
-            RxJavaPlugins.onError(ex);
-            throw toNpe(ex);
-        } 
+        return RxJavaPlugins.onAssembly(new CompletableFromUnsafeSource(source));
     }
     
     /**
diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java
index 09f4092373..091e1af16d 100644
--- a/src/main/java/io/reactivex/Observable.java
+++ b/src/main/java/io/reactivex/Observable.java
@@ -1743,16 +1743,10 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public static Observable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {
-        if (initialDelay < 0) {
-            initialDelay = 0L;
-        }
-        if (period < 0) {
-            period = 0L;
-        }
         ObjectHelper.requireNonNull(unit, "unit is null");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
 
-        return RxJavaPlugins.onAssembly(new ObservableInterval(initialDelay, period, unit, scheduler));
+        return RxJavaPlugins.onAssembly(new ObservableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));
     }
 
     /**
@@ -1843,17 +1837,10 @@ public static int bufferSize() {
         if (end < 0) {
             throw new IllegalArgumentException("Overflow! start + count is bigger than Long.MAX_VALUE");
         }
-
-        if (initialDelay < 0) {
-            initialDelay = 0L;
-        }
-        if (period < 0) {
-            period = 0L;
-        }
         ObjectHelper.requireNonNull(unit, "unit is null");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
 
-        return RxJavaPlugins.onAssembly(new ObservableIntervalRange(start, end, initialDelay, period, unit, scheduler));
+        return RxJavaPlugins.onAssembly(new ObservableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));
     }
 
     /**
@@ -3226,13 +3213,10 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public static Observable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {
-        if (delay < 0) {
-            delay = 0L;
-        }
         ObjectHelper.requireNonNull(unit, "unit is null");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
 
-        return RxJavaPlugins.onAssembly(new ObservableTimer(delay, unit, scheduler));
+        return RxJavaPlugins.onAssembly(new ObservableTimer(Math.max(delay, 0L), unit, scheduler));
     }
 
     /**
@@ -4701,12 +4685,8 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <U extends Collection<? super T>> Observable<U> buffer(int count, int skip, Callable<U> bufferSupplier) {
-        if (count <= 0) {
-            throw new IllegalArgumentException("count > 0 required but it was " + count);
-        }
-        if (skip <= 0) {
-            throw new IllegalArgumentException("skip > 0 required but it was " + count);
-        }
+        verifyPositive(count, "count");
+        verifyPositive(skip, "skip");
         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");
         return RxJavaPlugins.onAssembly(new ObservableBuffer<T, U>(this, count, skip, bufferSupplier));
     }
@@ -4965,9 +4945,7 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
         ObjectHelper.requireNonNull(unit, "unit is null");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");
-        if (count <= 0) {
-            throw new IllegalArgumentException("count > 0 required but it was " + count);
-        }
+        verifyPositive(count, "count");
         return RxJavaPlugins.onAssembly(new ObservableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));
     }
 
@@ -6529,8 +6507,10 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Observable<T> doOnTerminate(final Action onTerminate) {
-        return doOnEach(Functions.emptyConsumer(), Functions.actionConsumer(onTerminate), 
-                onTerminate, Functions.EMPTY_ACTION);
+        ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");
+        return doOnEach(Functions.emptyConsumer(), 
+                Functions.actionConsumer(onTerminate), onTerminate, 
+                Functions.EMPTY_ACTION);
     }
 
     /**
@@ -6769,9 +6749,7 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
     public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper,
             boolean delayErrors, int maxConcurrency, int bufferSize) {
         ObjectHelper.requireNonNull(mapper, "mapper is null");
-        if (maxConcurrency <= 0) {
-            throw new IllegalArgumentException("maxConcurrency > 0 required but it was " + maxConcurrency);
-        }
+        verifyPositive(maxConcurrency, "maxConcurrency");
         verifyPositive(bufferSize, "bufferSize");
         if (this instanceof ScalarCallable) {
             @SuppressWarnings("unchecked")
@@ -8255,7 +8233,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer
      *  <dd>{@code repeat} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param count
+     * @param times
      *            the number of times the source ObservableSource items are repeated, a count of 0 will yield an empty
      *            sequence
      * @return a Observable that repeats the sequence of items emitted by the source ObservableSource at most
@@ -8265,14 +8243,14 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer
      * @see <a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeat</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Observable<T> repeat(long count) {
-        if (count < 0) {
-            throw new IllegalArgumentException("count >= 0 required but it was " + count);
+    public final Observable<T> repeat(long times) {
+        if (times < 0) {
+            throw new IllegalArgumentException("times >= 0 required but it was " + times);
         }
-        if (count == 0) {
+        if (times == 0) {
             return empty();
         }
-        return RxJavaPlugins.onAssembly(new ObservableRepeat<T>(this, count));
+        return RxJavaPlugins.onAssembly(new ObservableRepeat<T>(this, times));
     }
 
     /**
@@ -8466,9 +8444,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer
      */
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends ObservableSource<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
-        if (bufferSize < 0) {
-            throw new IllegalArgumentException("bufferSize < 0");
-        }
+        verifyPositive(bufferSize, "bufferSize");
         ObjectHelper.requireNonNull(selector, "selector is null");
         return ObservableReplay.multicastSelector(
                 ObservableInternalHelper.replayCallable(this, bufferSize, time, unit, scheduler), selector);
@@ -8680,9 +8656,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer
      */
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public final ConnectableObservable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
-        if (bufferSize < 0) {
-            throw new IllegalArgumentException("bufferSize < 0");
-        }
+        verifyPositive(bufferSize, "bufferSize");
         ObjectHelper.requireNonNull(unit, "unit is null");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
         return ObservableReplay.create(this, time, unit, scheduler, bufferSize);
@@ -8861,14 +8835,14 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer
      *  <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param count
+     * @param times
      *            number of retry attempts before failing
      * @return the source ObservableSource modified with retry logic
      * @see <a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX operators documentation: Retry</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Observable<T> retry(long count) {
-        return retry(count, Functions.alwaysTrue());
+    public final Observable<T> retry(long times) {
+        return retry(times, Functions.alwaysTrue());
     }
     
     /**
@@ -10108,7 +10082,7 @@ public final void subscribe(Observer<? super T> observer) {
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Observable<T> take(long count) {
         if (count < 0) {
-            throw new IllegalArgumentException("count >= required but it was " + count);
+            throw new IllegalArgumentException("count >= 0 required but it was " + count);
         }
         return RxJavaPlugins.onAssembly(new ObservableTake<T>(this, count));
     }
@@ -11237,9 +11211,7 @@ public final Completable toCompletable() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Observable<List<T>> toList(final int capacityHint) {
-        if (capacityHint <= 0) {
-            throw new IllegalArgumentException("capacityHint > 0 required but it was " + capacityHint);
-        }
+        verifyPositive(capacityHint, "capacityHint");
         return RxJavaPlugins.onAssembly(new ObservableToList<T, List<T>>(this, capacityHint));
     }
 
@@ -11501,14 +11473,12 @@ public final Completable toCompletable() {
         Flowable<T> o = new FlowableFromObservable<T>(this);
         
         switch (strategy) {
-        case BUFFER:
-            return o.onBackpressureBuffer();
         case DROP:
             return o.onBackpressureDrop();
         case LATEST:
             return o.onBackpressureLatest();
         default:
-            return o;
+            return o.onBackpressureBuffer();
         }
     }
 
@@ -11821,6 +11791,8 @@ public final Completable toCompletable() {
      */
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {
+        verifyPositive(timespan, "timespan");
+        verifyPositive(timeskip, "timeskip");
         verifyPositive(bufferSize, "bufferSize");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
         ObjectHelper.requireNonNull(unit, "unit is null");
@@ -12052,9 +12024,7 @@ public final Completable toCompletable() {
         verifyPositive(bufferSize, "bufferSize");
         ObjectHelper.requireNonNull(scheduler, "scheduler is null");
         ObjectHelper.requireNonNull(unit, "unit is null");
-        if (count <= 0) {
-            throw new IllegalArgumentException("count > 0 required but it was " + count);
-        }
+        verifyPositive(count, "count");
         return RxJavaPlugins.onAssembly(new ObservableWindowTimed<T>(this, timespan, timespan, unit, scheduler, count, bufferSize, restart));
     }
 
diff --git a/src/main/java/io/reactivex/Scheduler.java b/src/main/java/io/reactivex/Scheduler.java
index 09b1cea6b5..a36c892d80 100644
--- a/src/main/java/io/reactivex/Scheduler.java
+++ b/src/main/java/io/reactivex/Scheduler.java
@@ -174,7 +174,6 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
      * Unsubscribing the {@link Worker} cancels all outstanding work and allows resource cleanup.
      */
     public static abstract class Worker implements Disposable {
-
         /**
          * Schedules a Runnable for execution without delay.
          * 
@@ -236,38 +235,8 @@ public Disposable schedulePeriodically(Runnable run, final long initialDelay, fi
             final long firstNowNanoseconds = now(TimeUnit.NANOSECONDS);
             final long firstStartInNanoseconds = firstNowNanoseconds + unit.toNanos(initialDelay);
 
-            first.replace(schedule(new Runnable() {
-                long count;
-                long lastNowNanoseconds = firstNowNanoseconds;
-                long startInNanoseconds = firstStartInNanoseconds;
-                @Override
-                public void run() {
-                    decoratedRun.run();
-
-                    if (!sd.isDisposed()) {
-
-                        long nextTick;
-
-                        long nowNanoseconds = now(TimeUnit.NANOSECONDS);
-                        // If the clock moved in a direction quite a bit, rebase the repetition period
-                        if (nowNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS < lastNowNanoseconds
-                                || nowNanoseconds >= lastNowNanoseconds + periodInNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS) {
-                            nextTick = nowNanoseconds + periodInNanoseconds;
-                            /* 
-                             * Shift the start point back by the drift as if the whole thing
-                             * started count periods ago.
-                             */
-                            startInNanoseconds = nextTick - (periodInNanoseconds * (++count));
-                        } else {
-                            nextTick = startInNanoseconds + (++count * periodInNanoseconds);
-                        }
-                        lastNowNanoseconds = nowNanoseconds;
-
-                        long delay = nextTick - nowNanoseconds;
-                        sd.replace(schedule(this, delay, TimeUnit.NANOSECONDS));
-                    }
-                }
-            }, initialDelay, unit));
+            first.replace(schedule(new PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd,
+                    periodInNanoseconds), initialDelay, unit));
             
             return sd;
         }
@@ -281,7 +250,60 @@ public void run() {
         public long now(TimeUnit unit) {
             return unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);
         }
-        
+
+        /**
+         * Holds state and logic to calculate when the next delayed invocation
+         * of this task has to happen (accounting for clock drifts).
+         */
+        final class PeriodicTask implements Runnable {
+            final long firstStartInNanoseconds;
+            final Runnable decoratedRun;
+            final long firstNowNanoseconds;
+            final SequentialDisposable sd;
+            final long periodInNanoseconds;
+            long count;
+            long lastNowNanoseconds;
+            long startInNanoseconds;
+
+            PeriodicTask(long firstStartInNanoseconds, Runnable decoratedRun,
+                    long firstNowNanoseconds, SequentialDisposable sd, long periodInNanoseconds) {
+                this.firstStartInNanoseconds = firstStartInNanoseconds;
+                this.decoratedRun = decoratedRun;
+                this.firstNowNanoseconds = firstNowNanoseconds;
+                this.sd = sd;
+                this.periodInNanoseconds = periodInNanoseconds;
+                lastNowNanoseconds = firstNowNanoseconds;
+                startInNanoseconds = firstStartInNanoseconds;
+            }
+
+            @Override
+            public void run() {
+                decoratedRun.run();
+
+                if (!sd.isDisposed()) {
+
+                    long nextTick;
+
+                    long nowNanoseconds = now(TimeUnit.NANOSECONDS);
+                    // If the clock moved in a direction quite a bit, rebase the repetition period
+                    if (nowNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS < lastNowNanoseconds
+                            || nowNanoseconds >= lastNowNanoseconds + periodInNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS) {
+                        nextTick = nowNanoseconds + periodInNanoseconds;
+                        /* 
+                         * Shift the start point back by the drift as if the whole thing
+                         * started count periods ago.
+                         */
+                        startInNanoseconds = nextTick - (periodInNanoseconds * (++count));
+                    } else {
+                        nextTick = startInNanoseconds + (++count * periodInNanoseconds);
+                    }
+                    lastNowNanoseconds = nowNanoseconds;
+
+                    long delay = nextTick - nowNanoseconds;
+                    sd.replace(schedule(this, delay, TimeUnit.NANOSECONDS));
+                }
+            }
+        }
     }
     
     static class PeriodicDirectTask 
diff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java
index 880e57e39d..0aee07ea73 100644
--- a/src/main/java/io/reactivex/Single.java
+++ b/src/main/java/io/reactivex/Single.java
@@ -801,7 +801,7 @@
      * @param source the source to wrap
      * @return the Single wrapper or the source cast to Single (if possible)
      */
-    static <T> Single<T> wrap(SingleSource<T> source) {
+    public static <T> Single<T> wrap(SingleSource<T> source) {
         ObjectHelper.requireNonNull(source, "source is null");
         if (source instanceof Single) {
             return RxJavaPlugins.onAssembly((Single<T>)source);
@@ -1824,7 +1824,7 @@ public final T blockingGet() {
      * @return the new Single instance
      * @since 2.0
      */
-    public final Single<T> onErrorReturnValue(final T value) {
+    public final Single<T> onErrorReturnItem(final T value) {
         ObjectHelper.requireNonNull(value, "value is null");
         return RxJavaPlugins.onAssembly(new SingleOnErrorReturn<T>(this, null, value));
     }
@@ -2036,16 +2036,6 @@ public final T blockingGet() {
         return toFlowable().retryWhen(handler).toSingle();
     }
     
-    /**
-     * Subscribes the given Reactive-Streams Subscriber to this Single with a safety wrapper
-     * that handles exceptions thrown from the Subscriber's onXXX methods.
-     * @param s the Subscriber to wrap and subscribe to the current Single
-     * @since 2.0
-     */
-    public final void safeSubscribe(Subscriber<? super T> s) {
-        toFlowable().safeSubscribe(s);
-    }
-    
     /**
      * Subscribes to a Single but ignore its emission or notification.
      * <dl>
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimer.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimer.java
index 561e390780..db220e89f2 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimer.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimer.java
@@ -20,6 +20,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.MissingBackpressureException;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
@@ -75,7 +76,7 @@ public void run() {
                     actual.onNext(0L);
                     actual.onComplete();
                 } else {
-                    actual.onError(new IllegalStateException("Can't deliver value due to lack of requests"));
+                    actual.onError(new MissingBackpressureException("Can't deliver value due to lack of requests"));
                 }
                 lazySet(EmptyDisposable.INSTANCE);
             }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableSequenceEqual.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableSequenceEqual.java
index f73eddb6f4..b23f957cac 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableSequenceEqual.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSequenceEqual.java
@@ -39,6 +39,7 @@ public ObservableSequenceEqual(ObservableSource<? extends T> first, ObservableSo
     @Override
     public void subscribeActual(Observer<? super Boolean> s) {
         EqualCoordinator<T> ec = new EqualCoordinator<T>(s, bufferSize, first, second, comparer);
+        s.onSubscribe(ec);
         ec.subscribe();
     }
     
diff --git a/src/main/java/io/reactivex/internal/operators/single/SingleAmbArray.java b/src/main/java/io/reactivex/internal/operators/single/SingleAmbArray.java
index 3cb1d6a8f2..018fb032e4 100644
--- a/src/main/java/io/reactivex/internal/operators/single/SingleAmbArray.java
+++ b/src/main/java/io/reactivex/internal/operators/single/SingleAmbArray.java
@@ -60,6 +60,7 @@ public void onSubscribe(Disposable d) {
                 @Override
                 public void onSuccess(T value) {
                     if (once.compareAndSet(false, true)) {
+                        set.dispose();
                         s.onSuccess(value);
                     }
                 }
@@ -67,6 +68,7 @@ public void onSuccess(T value) {
                 @Override
                 public void onError(Throwable e) {
                     if (once.compareAndSet(false, true)) {
+                        set.dispose();
                         s.onError(e);
                     } else {
                         RxJavaPlugins.onError(e);
diff --git a/src/main/java/io/reactivex/internal/operators/single/SingleDelayWithPublisher.java b/src/main/java/io/reactivex/internal/operators/single/SingleDelayWithPublisher.java
index a203eaf8b6..bce0788e4c 100644
--- a/src/main/java/io/reactivex/internal/operators/single/SingleDelayWithPublisher.java
+++ b/src/main/java/io/reactivex/internal/operators/single/SingleDelayWithPublisher.java
@@ -73,7 +73,7 @@ public void onSubscribe(Subscription s) {
         
         @Override
         public void onNext(U value) {
-            get().dispose();
+            s.cancel();
             onComplete();
         }
         
diff --git a/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
index f1f0a31183..29160db1d3 100644
--- a/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
+++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
@@ -45,7 +45,7 @@
     private static final Object HAS_NEXT = new Object();
 
     public SpscLinkedArrayQueue(final int bufferSize) {
-        int p2capacity = Pow2.roundToPowerOfTwo(bufferSize);
+        int p2capacity = Pow2.roundToPowerOfTwo(Math.max(8, bufferSize));
         int mask = p2capacity - 1;
         AtomicReferenceArray<Object> buffer = new AtomicReferenceArray<Object>(p2capacity + 1);
         producerBuffer = buffer;
diff --git a/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java b/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
index 2174adec2f..a400d02010 100644
--- a/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
+++ b/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
@@ -54,6 +54,7 @@ public Disposable scheduleDirect(Runnable run) {
     public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
         try {
             unit.sleep(delay);
+            run.run();
         } catch (InterruptedException ex) {
             Thread.currentThread().interrupt();
             RxJavaPlugins.onError(ex);
diff --git a/src/main/java/io/reactivex/observers/TestObserver.java b/src/main/java/io/reactivex/observers/TestObserver.java
index 440d50866f..62aa3ebcbe 100644
--- a/src/main/java/io/reactivex/observers/TestObserver.java
+++ b/src/main/java/io/reactivex/observers/TestObserver.java
@@ -895,15 +895,16 @@ private String fusionModeToString(int mode) {
      * @param time the waiting time
      * @param unit the time unit of the waiting time
      * @return this
-     * @throws InterruptedException if the wait is interrupted
+     * @throws RuntimeException wrapping an InterruptedException if the wait is interrupted
      */
-    public final TestObserver<T> awaitDone(long time, TimeUnit unit) throws InterruptedException {
+    public final TestObserver<T> awaitDone(long time, TimeUnit unit) {
         try {
             if (!done.await(time, unit)) {
                 cancel();
             }
         } catch (InterruptedException ex) {
             cancel();
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         return this;
     }
diff --git a/src/main/java/io/reactivex/subscribers/TestSubscriber.java b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
index 8d412b97c9..c3f52ea4bc 100644
--- a/src/main/java/io/reactivex/subscribers/TestSubscriber.java
+++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
@@ -957,15 +957,16 @@ public final boolean await(long time, TimeUnit unit) throws InterruptedException
      * @param time the waiting time
      * @param unit the time unit of the waiting time
      * @return this
-     * @throws InterruptedException if the wait is interrupted
+     * @throws RuntimeException wrapping an InterruptedException if the wait is interrupted
      */
-    public final TestSubscriber<T> awaitDone(long time, TimeUnit unit) throws InterruptedException {
+    public final TestSubscriber<T> awaitDone(long time, TimeUnit unit) {
         try {
             if (!done.await(time, unit)) {
                 cancel();
             }
         } catch (InterruptedException ex) {
             cancel();
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         return this;
     }
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableAwaitTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableAwaitTest.java
index 01b3b8ce9b..ba3f51476a 100644
--- a/src/test/java/io/reactivex/internal/operators/completable/CompletableAwaitTest.java
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableAwaitTest.java
@@ -13,11 +13,14 @@
 
 package io.reactivex.internal.operators.completable;
 
-import static org.junit.Assert.fail;
+import static org.junit.Assert.*;
+
+import java.util.concurrent.TimeUnit;
 
 import org.junit.Test;
 
-import io.reactivex.TestHelper;
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.processors.PublishProcessor;
 
 public class CompletableAwaitTest {
@@ -42,4 +45,48 @@ public void awaitInterrupted() {
         }
         
     }
+    
+    @Test
+    public void awaitTimeoutInterrupted() {
+        
+        Thread.currentThread().interrupt();
+        
+        try {
+            PublishProcessor.create().toCompletable().blockingAwait(1, TimeUnit.SECONDS);
+            fail("Should have thrown RuntimeException");
+        } catch (RuntimeException ex) {
+            if (!(ex.getCause() instanceof InterruptedException)) {
+                fail("Wrong cause: " + ex.getCause());
+            }
+        }
+        
+    }
+    
+    @Test
+    public void awaitTimeout() {
+        assertFalse(PublishProcessor.create().toCompletable().blockingAwait(100, TimeUnit.MILLISECONDS));
+    }
+    
+    @Test
+    public void blockingGet() {
+        assertNull(Completable.complete().blockingGet());
+    }
+
+    @Test
+    public void blockingGetTimeout() {
+        assertNull(Completable.complete().blockingGet(1, TimeUnit.SECONDS));
+    }
+
+    @Test
+    public void blockingGetError() {
+        TestException ex = new TestException();
+        assertSame(ex, Completable.error(ex).blockingGet());
+    }
+
+    @Test
+    public void blockingGetErrorTimeout() {
+        TestException ex = new TestException();
+        assertSame(ex, Completable.error(ex).blockingGet(1, TimeUnit.SECONDS));
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java
index ea6de8b5ee..9622563229 100644
--- a/src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java
@@ -13,6 +13,7 @@
 
 package io.reactivex.internal.operators.completable;
 
+import static org.junit.Assert.*;
 import org.junit.Test;
 import org.reactivestreams.*;
 
@@ -40,4 +41,14 @@ public void subscribe(Subscriber<? super Completable> s) {
         .test()
         .assertFailure(MissingBackpressureException.class);
     }
+    
+    @Test
+    public void invalidPrefetch() {
+        try {
+            Completable.concat(Flowable.just(Completable.complete()), -99);
+            fail("Should have thrown IllegalArgumentExceptio");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("prefetch > 0 required but it was -99", ex.getMessage());
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java
new file mode 100644
index 0000000000..67ec775b01
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java
@@ -0,0 +1,33 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.completable;
+
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Test;
+
+import io.reactivex.Completable;
+import io.reactivex.schedulers.Schedulers;
+
+public class CompletableDelayTest {
+
+    @Test
+    public void delayCustomScheduler() {
+        
+        Completable.complete()
+        .delay(100, TimeUnit.MILLISECONDS, Schedulers.trampoline())
+        .test()
+        .assertResult();
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableMergeTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableMergeTest.java
new file mode 100644
index 0000000000..335948713b
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableMergeTest.java
@@ -0,0 +1,33 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.completable;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+
+public class CompletableMergeTest {
+    @Test
+    public void invalidPrefetch() {
+        try {
+            Completable.merge(Flowable.just(Completable.complete()), -99);
+            fail("Should have thrown IllegalArgumentExceptio");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("maxConcurrency > 0 required but it was -99", ex.getMessage());
+        }
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableRepeatWhenTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableRepeatWhenTest.java
new file mode 100644
index 0000000000..48ea13943c
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableRepeatWhenTest.java
@@ -0,0 +1,51 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.completable;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+import org.reactivestreams.Publisher;
+
+import io.reactivex.*;
+import io.reactivex.functions.*;
+
+public class CompletableRepeatWhenTest {
+    @Test
+    public void whenCounted() {
+        
+        final int[] counter = { 0 };
+        
+        Completable.fromAction(new Action() {
+            @Override
+            public void run() throws Exception {
+                counter[0]++;
+            }
+        })
+        .repeatWhen(new Function<Flowable<Object>, Publisher<Object>>() {
+            @Override
+            public Publisher<Object> apply(Flowable<Object> f) throws Exception {
+                final int[] j = { 3 };
+                return f.takeWhile(new Predicate<Object>() {
+                    @Override
+                    public boolean test(Object v) throws Exception {
+                        return j[0]-- != 0;
+                    }
+                });
+            }
+        })
+        .subscribe();
+        
+        assertEquals(4, counter[0]);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableSubscribeTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableSubscribeTest.java
new file mode 100644
index 0000000000..422aa3e145
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableSubscribeTest.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.completable;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+import io.reactivex.processors.PublishProcessor;
+
+public class CompletableSubscribeTest {
+    @Test
+    public void subscribeAlreadyCancelled() {
+        
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+        
+        pp.toCompletable().test(true);
+        
+        assertFalse(pp.hasSubscribers());
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableTimeoutTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableTimeoutTest.java
new file mode 100644
index 0000000000..c45b35b3fc
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableTimeoutTest.java
@@ -0,0 +1,59 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.completable;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.concurrent.*;
+
+import org.junit.Test;
+
+import io.reactivex.Completable;
+import io.reactivex.functions.Action;
+import io.reactivex.schedulers.Schedulers;
+
+public class CompletableTimeoutTest {
+
+    @Test
+    public void timeoutException() throws Exception {
+        
+        Completable.never()
+        .timeout(100, TimeUnit.MILLISECONDS, Schedulers.io())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TimeoutException.class);
+    }
+
+    @Test
+    public void timeoutContinueOther() throws Exception {
+        
+        final int[] call = { 0 };
+        
+        Completable other = Completable.fromAction(new Action() {
+            @Override
+            public void run() throws Exception {
+                call[0]++;
+            }
+        });
+        
+        Completable.never()
+        .timeout(100, TimeUnit.MILLISECONDS, Schedulers.io(), other)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult();
+        
+        assertEquals(1, call[0]);
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableUnsafeTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableUnsafeTest.java
new file mode 100644
index 0000000000..80bdb92dda
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableUnsafeTest.java
@@ -0,0 +1,74 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.completable;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.disposables.Disposables;
+
+public class CompletableUnsafeTest {
+
+    @Test(expected = IllegalArgumentException.class)
+    public void unsafeCreateRejectsCompletable() {
+        Completable.unsafeCreate(Completable.complete());
+    }
+    
+    @Test
+    public void wrapAlreadyCompletable() {
+        assertSame(Completable.complete(), Completable.wrap(Completable.complete()));
+    }
+    
+    @Test
+    public void wrapCustomCompletable() {
+        
+        Completable.wrap(new CompletableSource() {
+            @Override
+            public void subscribe(CompletableObserver s) {
+                s.onSubscribe(Disposables.empty());
+                s.onComplete();
+            }
+        })
+        .test()
+        .assertResult();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void unsafeCreateThrowsNPE() {
+        Completable.unsafeCreate(new CompletableSource() {
+            @Override
+            public void subscribe(CompletableObserver s) {
+                throw new NullPointerException();
+            }
+        }).test();
+    }
+    
+    @Test
+    public void unsafeCreateThrowsIAE() {
+        try {
+            Completable.unsafeCreate(new CompletableSource() {
+                @Override
+                public void subscribe(CompletableObserver s) {
+                    throw new IllegalArgumentException();
+                }
+            }).test();
+            fail("Should have thrown!");
+        } catch (NullPointerException ex) {
+            if (!(ex.getCause() instanceof IllegalArgumentException)) {
+                fail(ex.toString() + ": should have thrown NPA(IAE)");
+            }
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java
index 7a4189591e..adb53c9d84 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimedTest.java
@@ -25,7 +25,7 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.processors.PublishProcessor;
-import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.schedulers.*;
 
 public class FlowableSkipLastTimedTest {
 
@@ -148,4 +148,32 @@ public void testSkipLastTimedWhenAllElementsAreValid() {
         inOrder.verify(o).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
+    
+    @Test
+    public void skipLastTimedDefaultScheduler() {
+        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        .skipLast(300, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void skipLastTimedDefaultSchedulerDelayError() {
+        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        .skipLast(300, TimeUnit.MILLISECONDS, true)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void skipLastTimedCustomSchedulerDelayError() {
+        Observable.just(1).concatWith(Observable.just(2).delay(500, TimeUnit.MILLISECONDS))
+        .skipLast(300, TimeUnit.MILLISECONDS, Schedulers.io(), true)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTimedTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTimedTest.java
index 06996a1910..4e0974e6ab 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTimedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeTimedTest.java
@@ -123,4 +123,12 @@ public void testTakeTimedErrorAfterTime() {
         verify(o, never()).onNext(4);
         verify(o, never()).onError(any(TestException.class));
     }
+    
+    @Test
+    public void timedDefaultScheduler() {
+        Observable.range(1, 5).take(1, TimeUnit.MINUTES)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableAmbTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableAmbTest.java
index 171e44cd54..4971d636e6 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableAmbTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableAmbTest.java
@@ -220,4 +220,17 @@ public void testAmbCancelsOthers() {
         assertFalse("Source 2 still has subscribers!", source3.hasObservers());
         
     }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void ambArrayEmpty() {
+        assertSame(Observable.empty(), Observable.ambArray());
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void ambArraySingleElement() {
+        assertSame(Observable.never(), Observable.ambArray(Observable.never()));
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableBlockingTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableBlockingTest.java
new file mode 100644
index 0000000000..df2e1c4fff
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableBlockingTest.java
@@ -0,0 +1,218 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.observable;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.*;
+
+import org.junit.Test;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.schedulers.Schedulers;
+
+public class ObservableBlockingTest {
+
+    @Test
+    public void blockingFirst() {
+        assertEquals(1, Observable.range(1, 10)
+                .subscribeOn(Schedulers.computation()).blockingFirst().intValue());
+    }
+
+    @Test
+    public void blockingFirstDefault() {
+        assertEquals(1, Observable.<Integer>empty()
+                .subscribeOn(Schedulers.computation()).blockingFirst(1).intValue());
+    }
+
+    @Test
+    public void blockingSubscribeConsumer() {
+        final List<Integer> list = new ArrayList<Integer>();
+        
+        Observable.range(1, 5)
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5), list);
+    }
+
+    @Test
+    public void blockingSubscribeConsumerConsumer() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        Observable.range(1, 5)
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        }, Functions.emptyConsumer());
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5), list);
+    }
+
+    @Test
+    public void blockingSubscribeConsumerConsumerError() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        TestException ex = new TestException();
+        
+        Consumer<Object> cons = new Consumer<Object>() {
+            @Override
+            public void accept(Object v) throws Exception {
+                list.add(v);
+            }
+        };
+        
+        Observable.range(1, 5).concatWith(Observable.<Integer>error(ex))
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(cons, cons);
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5, ex), list);
+    }
+
+    @Test
+    public void blockingSubscribeConsumerConsumerAction() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        Consumer<Object> cons = new Consumer<Object>() {
+            @Override
+            public void accept(Object v) throws Exception {
+                list.add(v);
+            }
+        };
+        
+        Observable.range(1, 5)
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(cons, cons, new Action() {
+            @Override
+            public void run() throws Exception {
+                list.add(100);
+            }
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 100), list);
+    }
+
+    @Test
+    public void blockingSubscribeObserver() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        Observable.range(1, 5)
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(new Observer<Object>() {
+
+            @Override
+            public void onSubscribe(Disposable d) {
+                
+            }
+
+            @Override
+            public void onNext(Object value) {
+                list.add(value);
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                list.add(e);
+            }
+
+            @Override
+            public void onComplete() {
+                list.add(100);
+            }
+            
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 100), list);
+    }
+
+    @Test
+    public void blockingSubscribeObserverError() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        final TestException ex = new TestException();
+        
+        Observable.range(1, 5).concatWith(Observable.<Integer>error(ex))
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(new Observer<Object>() {
+
+            @Override
+            public void onSubscribe(Disposable d) {
+                
+            }
+
+            @Override
+            public void onNext(Object value) {
+                list.add(value);
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                list.add(e);
+            }
+
+            @Override
+            public void onComplete() {
+                list.add(100);
+            }
+            
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5, ex), list);
+    }
+
+    @Test(expected = TestException.class)
+    public void blockingForEachThrows() {
+        Observable.just(1)
+        .blockingForEach(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer e) throws Exception {
+                throw new TestException();
+            }
+        });
+    }
+    
+    @Test(expected = NoSuchElementException.class)
+    public void blockingFirstEmpty() {
+        Observable.empty().blockingFirst();
+    }
+
+    @Test(expected = NoSuchElementException.class)
+    public void blockingLastEmpty() {
+        Observable.empty().blockingLast();
+    }
+
+    @Test
+    public void blockingFirstNormal() {
+        assertEquals(1, Observable.just(1, 2).blockingFirst(3).intValue());
+    }
+
+    @Test
+    public void blockingLastNormal() {
+        assertEquals(2, Observable.just(1, 2).blockingLast(3).intValue());
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java
index 891877458a..85c7abc6a4 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java
@@ -790,4 +790,53 @@ public void onComplete() {
         
         assertFalse(s.isDisposed());
     }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void bufferTimeSkipDefault() {
+        Observable.range(1, 5).buffer(1, 1, TimeUnit.MINUTES)
+        .test()
+        .assertResult(Arrays.asList(1, 2, 3, 4, 5));
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void bufferBoundaryHint() {
+        Observable.range(1, 5).buffer(Observable.timer(1, TimeUnit.MINUTES), 2)
+        .test()
+        .assertResult(Arrays.asList(1, 2, 3, 4, 5));
+    }
+
+    static HashSet<Integer> set(Integer... values) {
+        return new HashSet<Integer>(Arrays.asList(values));
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void bufferIntoCustomCollection() {
+        Observable.just(1, 1, 2, 2, 3, 3, 4, 4)
+        .buffer(3, new Callable<Collection<Integer>>() {
+            @Override
+            public Collection<Integer> call() throws Exception {
+                return new HashSet<Integer>();
+            }
+        })
+        .test()
+        .assertResult(set(1, 2), set(2, 3), set(4));
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void bufferSkipIntoCustomCollection() {
+        Observable.just(1, 1, 2, 2, 3, 3, 4, 4)
+        .buffer(3, 3, new Callable<Collection<Integer>>() {
+            @Override
+            public Collection<Integer> call() throws Exception {
+                return new HashSet<Integer>();
+            }
+        })
+        .test()
+        .assertResult(set(1, 2), set(2, 3), set(4));
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
index 4cde4b9a3f..14751098ef 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
@@ -1,16 +1,10 @@
 package io.reactivex.internal.operators.observable;
 
-import static io.reactivex.internal.util.TestingHelper.addToList;
-import static io.reactivex.internal.util.TestingHelper.biConsumerThrows;
-import static io.reactivex.internal.util.TestingHelper.callableListCreator;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
+import static io.reactivex.internal.util.TestingHelper.*;
+import static org.junit.Assert.*;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.*;
+import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.junit.Test;
@@ -129,4 +123,18 @@ public void accept(Object o, Integer t) {
         assertFalse(added.get());
     }
 
+    @SuppressWarnings("unchecked")
+    @Test
+    public void collectInto() {
+        Observable.just(1, 1, 1, 1, 2)
+        .collectInto(new HashSet<Integer>(), new BiConsumer<HashSet<Integer>, Integer>() {
+            @Override
+            public void accept(HashSet<Integer> s, Integer v) throws Exception {
+                s.add(v);
+            }
+        })
+        .test()
+        .assertResult(new HashSet<Integer>(Arrays.asList(1, 2)));
+        
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java
index 5ae079091e..68c898b2ec 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableCombineLatestTest.java
@@ -27,7 +27,9 @@
 import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subjects.PublishSubject;
@@ -767,4 +769,90 @@ public Long apply(Long t1, Integer t2) {
 
         assertEquals(SIZE, count.get());
     }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void combineLatestArrayOfSources() {
+        
+        Observable.combineLatest(new ObservableSource[] {
+                Observable.just(1), Observable.just(2)
+        }, new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return Arrays.toString(a);
+            }
+        })
+        .test()
+        .assertResult("[1, 2]");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void combineLatestDelayErrorArrayOfSources() {
+        
+        Observable.combineLatestDelayError(new ObservableSource[] {
+                Observable.just(1), Observable.just(2)
+        }, new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return Arrays.toString(a);
+            }
+        })
+        .test()
+        .assertResult("[1, 2]");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void combineLatestDelayErrorArrayOfSourcesWithError() {
+        
+        Observable.combineLatestDelayError(new ObservableSource[] {
+                Observable.just(1), Observable.just(2).concatWith(Observable.<Integer>error(new TestException()))
+        }, new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return Arrays.toString(a);
+            }
+        })
+        .test()
+        .assertFailure(TestException.class, "[1, 2]");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void combineLatestDelayErrorIterableOfSources() {
+        
+        Observable.combineLatestDelayError(Arrays.asList(
+                Observable.just(1), Observable.just(2)
+        ), new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return Arrays.toString(a);
+            }
+        })
+        .test()
+        .assertResult("[1, 2]");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void combineLatestDelayErrorIterableOfSourcesWithError() {
+        
+        Observable.combineLatestDelayError(Arrays.asList(
+                Observable.just(1), Observable.just(2).concatWith(Observable.<Integer>error(new TestException()))
+        ), new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] a) throws Exception {
+                return Arrays.toString(a);
+            }
+        })
+        .test()
+        .assertFailure(TestException.class, "[1, 2]");
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void combineLatestDelayErrorEmpty() {
+        assertSame(Observable.empty(), Observable.combineLatestDelayError(new ObservableSource[0], Functions.<Object[]>identity(), 16));
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java
index 531675a081..9a452df4d9 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java
@@ -731,4 +731,12 @@ public void mappingBadCapacityHint() throws Exception {
         }
         
     }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatEagerIterable() {
+        Observable.concatEager(Arrays.asList(Observable.just(1), Observable.just(2)))
+        .test()
+        .assertResult(1, 2);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatTest.java
index 0aa6b39f29..1768244637 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatTest.java
@@ -28,7 +28,9 @@
 import io.reactivex.Observable;
 import io.reactivex.Observer;
 import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Function;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.*;
 import io.reactivex.subjects.*;
@@ -756,5 +758,202 @@ public void concatMapRangeAsyncLoopIssue2876() {
             assertEquals((Integer)999, ts.values().get(999));
         }
     }
+
+    @Test
+    public void concat3() {
+        Observable.concat(Observable.just(1), Observable.just(2), Observable.just(3))
+        .test()
+        .assertResult(1, 2, 3);
+    }
+
+    @Test
+    public void concat4() {
+        Observable.concat(Observable.just(1), Observable.just(2), 
+                Observable.just(3), Observable.just(4))
+        .test()
+        .assertResult(1, 2, 3, 4);
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatArrayDelayError() {
+        Observable.concatArrayDelayError(Observable.just(1), Observable.just(2), 
+                Observable.just(3), Observable.just(4))
+        .test()
+        .assertResult(1, 2, 3, 4);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatArrayDelayErrorWithError() {
+        Observable.concatArrayDelayError(Observable.just(1), Observable.just(2), 
+                Observable.just(3).concatWith(Observable.<Integer>error(new TestException())), 
+                Observable.just(4))
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3, 4);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatIterableDelayError() {
+        Observable.concatDelayError(
+                Arrays.asList(Observable.just(1), Observable.just(2), 
+                Observable.just(3), Observable.just(4)))
+        .test()
+        .assertResult(1, 2, 3, 4);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatIterableDelayErrorWithError() {
+        Observable.concatDelayError(
+                Arrays.asList(Observable.just(1), Observable.just(2), 
+                Observable.just(3).concatWith(Observable.<Integer>error(new TestException())), 
+                Observable.just(4)))
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3, 4);
+    }
+
+    @Test
+    public void concatObservableDelayError() {
+        Observable.concatDelayError(
+                Observable.just(Observable.just(1), Observable.just(2), 
+                Observable.just(3), Observable.just(4)))
+        .test()
+        .assertResult(1, 2, 3, 4);
+    }
+
+    @Test
+    public void concatObservableDelayErrorWithError() {
+        Observable.concatDelayError(
+                Observable.just(Observable.just(1), Observable.just(2), 
+                Observable.just(3).concatWith(Observable.<Integer>error(new TestException())), 
+                Observable.just(4)))
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3, 4);
+    }
+
+    @Test
+    public void concatObservableDelayErrorBoundary() {
+        Observable.concatDelayError(
+                Observable.just(Observable.just(1), Observable.just(2), 
+                Observable.just(3).concatWith(Observable.<Integer>error(new TestException())), 
+                Observable.just(4)), 2, false)
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3);
+    }
+
+    @Test
+    public void concatObservableDelayErrorTillEnd() {
+        Observable.concatDelayError(
+                Observable.just(Observable.just(1), Observable.just(2), 
+                Observable.just(3).concatWith(Observable.<Integer>error(new TestException())), 
+                Observable.just(4)), 2, true)
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3, 4);
+    }
+
+    @Test
+    public void concatMapDelayError() {
+        Observable.just(Observable.just(1), Observable.just(2))
+        .concatMapDelayError(Functions.<Observable<Integer>>identity())
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void concatMapDelayErrorWithError() {
+        Observable.just(Observable.just(1).concatWith(Observable.<Integer>error(new TestException())), Observable.just(2))
+        .concatMapDelayError(Functions.<Observable<Integer>>identity())
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+    
+    @Test
+    public void concatMapIterableBufferSize() {
+        
+        Observable.just(1, 2).concatMapIterable(new Function<Integer, Iterable<Integer>>() {
+            @Override
+            public Iterable<Integer> apply(Integer v) throws Exception {
+                return Arrays.asList(1, 2, 3, 4, 5);
+            }
+        }, 1)
+        .test()
+        .assertResult(1, 2, 3, 4, 5, 1, 2, 3, 4, 5);
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void emptyArray() {
+        assertSame(Observable.empty(), Observable.concatArrayDelayError());
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void singleElementArray() {
+        assertSame(Observable.never(), Observable.concatArrayDelayError(Observable.never()));
+    }
+    
+    @Test
+    public void concatMapDelayErrorEmptySource() {
+        assertSame(Observable.empty(), Observable.<Object>empty()
+                .concatMapDelayError(new Function<Object, ObservableSource<Integer>>() {
+                    @Override
+                    public ObservableSource<Integer> apply(Object v) throws Exception {
+                        return Observable.just(1);
+                    }
+                }, 16, true));
+    }
+
+    @Test
+    public void concatMapDelayErrorJustSource() {
+        Observable.just(0)
+        .concatMapDelayError(new Function<Object, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Object v) throws Exception {
+                return Observable.just(1);
+            }
+        }, 16, true)
+        .test()
+        .assertResult(1);
     
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatArrayEmpty() {
+        assertSame(Observable.empty(), Observable.concatArray());
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void concatArraySingleElement() {
+        assertSame(Observable.never(), Observable.concatArray(Observable.never()));
+    }
+
+    @Test
+    public void concatMapErrorEmptySource() {
+        assertSame(Observable.empty(), Observable.<Object>empty()
+                .concatMap(new Function<Object, ObservableSource<Integer>>() {
+                    @Override
+                    public ObservableSource<Integer> apply(Object v) throws Exception {
+                        return Observable.just(1);
+                    }
+                }, 16));
+    }
+
+    @Test
+    public void concatMapJustSource() {
+        Observable.just(0)
+        .concatMap(new Function<Object, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Object v) throws Exception {
+                return Observable.just(1);
+            }
+        }, 16)
+        .test()
+        .assertResult(1);
+    
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableCreateTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableCreateTest.java
index ecd69a53a5..064f1054b6 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableCreateTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableCreateTest.java
@@ -130,4 +130,45 @@ public void subscribe(ObservableEmitter<Integer> e) throws Exception {
         assertTrue(d.isDisposed());
     }
 
+    @Test
+    public void wrap() {
+        Observable.wrap(new ObservableSource<Integer>() {
+            @Override
+            public void subscribe(Observer<? super Integer> observer) {
+                observer.onSubscribe(Disposables.empty());
+                observer.onNext(1);
+                observer.onNext(2);
+                observer.onNext(3);
+                observer.onNext(4);
+                observer.onNext(5);
+                observer.onComplete();
+            }
+        })
+        .test()
+        .assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void unsafe() {
+        Observable.unsafeCreate(new ObservableSource<Integer>() {
+            @Override
+            public void subscribe(Observer<? super Integer> observer) {
+                observer.onSubscribe(Disposables.empty());
+                observer.onNext(1);
+                observer.onNext(2);
+                observer.onNext(3);
+                observer.onNext(4);
+                observer.onNext(5);
+                observer.onComplete();
+            }
+        })
+        .test()
+        .assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void unsafeWithObservable() {
+        Observable.unsafeCreate(Observable.just(1));
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java
index 9dc16d8dbd..08dc6f2c00 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableDebounceTest.java
@@ -290,4 +290,13 @@ public void debounceWithTimeBackpressure() throws InterruptedException {
         NbpSubscriber.assertTerminated();
         NbpSubscriber.assertNoErrors();
     }
+    
+    @Test
+    public void debounceDefault() throws Exception {
+        
+        Observable.just(1).debounce(1, TimeUnit.SECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableDelayTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableDelayTest.java
index c12726b664..ad1d96cfb9 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableDelayTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableDelayTest.java
@@ -850,4 +850,12 @@ public void testDelaySupplierErrors() {
         ts.assertError(TestException.class);
     }
 
+    @Test
+    public void delayWithTimeDelayError() throws Exception {
+        Observable.just(1).concatWith(Observable.<Integer>error(new TestException()))
+        .delay(100, TimeUnit.MILLISECONDS, true)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class, 1);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java
index be36d3b167..1371aba24e 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java
@@ -13,7 +13,7 @@
 
 package io.reactivex.internal.operators.observable;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
@@ -23,9 +23,9 @@
 
 import org.junit.*;
 
+import io.reactivex.*;
 import io.reactivex.Observable;
 import io.reactivex.Observer;
-import io.reactivex.TestHelper;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
@@ -545,4 +545,68 @@ public void flatMapTwoNestedSync() {
             ts.assertValueCount(n * 2);
         }
     }
+    
+    @Test
+    public void flatMapBiMapper() {
+        Observable.just(1)
+        .flatMap(new Function<Integer, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Integer v) throws Exception {
+                return Observable.just(v * 10);
+            }
+        }, new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }, true)
+        .test()
+        .assertResult(11);
+    }
+
+    @Test
+    public void flatMapBiMapperWithError() {
+        Observable.just(1)
+        .flatMap(new Function<Integer, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Integer v) throws Exception {
+                return Observable.just(v * 10).concatWith(Observable.<Integer>error(new TestException()));
+            }
+        }, new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }, true)
+        .test()
+        .assertFailure(TestException.class, 11);
+    }
+
+    @Test
+    public void flatMapBiMapperMaxConcurrency() {
+        Observable.just(1, 2)
+        .flatMap(new Function<Integer, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Integer v) throws Exception {
+                return Observable.just(v * 10);
+            }
+        }, new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }, true, 1)
+        .test()
+        .assertResult(11, 22);
+    }
+
+    @Test
+    public void flatMapEmpty() {
+        assertSame(Observable.empty(), Observable.empty().flatMap(new Function<Object, ObservableSource<Object>>() {
+            @Override
+            public ObservableSource<Object> apply(Object v) throws Exception {
+                return Observable.just(v);
+            }
+        }));
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableFlattenIterable.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlattenIterable.java
new file mode 100644
index 0000000000..c515c0a90e
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlattenIterable.java
@@ -0,0 +1,39 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.observable;
+
+import java.util.Arrays;
+
+import org.junit.Test;
+
+import io.reactivex.Observable;
+import io.reactivex.functions.Function;
+
+public class ObservableFlattenIterable {
+
+    @Test
+    public void flatMapIterablePrefetch() {
+        
+        Observable.just(1, 2)
+        .flatMapIterable(new Function<Integer, Iterable<Integer>>() {
+            @Override
+            public Iterable<Integer> apply(Integer t) throws Exception {
+                return Arrays.asList(t * 10);
+            }
+        }, 1)
+        .test()
+        .assertResult(10, 20);
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableForEachTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableForEachTest.java
new file mode 100644
index 0000000000..564527afdd
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableForEachTest.java
@@ -0,0 +1,75 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.observable;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.*;
+
+import org.junit.Test;
+
+import io.reactivex.Observable;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.*;
+
+public class ObservableForEachTest {
+
+    @Test
+    public void forEachWile() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        Observable.range(1, 5)
+        .doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        })
+        .forEachWhile(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) throws Exception {
+                return v < 3;
+            }
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3), list);
+    }
+
+    @Test
+    public void forEachWileWithError() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        Observable.range(1, 5).concatWith(Observable.<Integer>error(new TestException()))
+        .doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        })
+        .forEachWhile(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) throws Exception {
+                return true;
+            }
+        }, new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) throws Exception {
+                list.add(100);
+            }
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 100), list);
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableFromTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableFromTest.java
new file mode 100644
index 0000000000..4054ad9326
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFromTest.java
@@ -0,0 +1,60 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.observable;
+
+import static org.junit.Assert.*;
+
+import java.util.concurrent.*;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.internal.fuseable.ScalarCallable;
+import io.reactivex.schedulers.Schedulers;
+
+public class ObservableFromTest {
+
+    @Test
+    public void fromFutureTimeout() throws Exception {
+        Observable.fromFuture(Observable.never()
+        .toFuture(), 100, TimeUnit.MILLISECONDS, Schedulers.io())
+        .test()
+        .awaitDone()
+        .assertFailure(TimeoutException.class);
+    }
+    
+    @Test
+    public void fromPublisher() {
+        Observable.fromPublisher(Flowable.just(1))
+        .test()
+        .assertResult(1);
+    }
+    
+    @Test
+    public void just10() {
+        Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
+        .test()
+        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+    }
+    
+    @Test
+    public void fromArrayEmpty() {
+        assertSame(Observable.empty(), Observable.fromArray());
+    }
+
+    @Test
+    public void fromArraySingle() {
+        assertTrue(Observable.fromArray(1) instanceof ScalarCallable);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableGenerateTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableGenerateTest.java
new file mode 100644
index 0000000000..33bb8cea4d
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableGenerateTest.java
@@ -0,0 +1,47 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.observable;
+
+import java.util.concurrent.Callable;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.functions.*;
+
+public class ObservableGenerateTest {
+
+    @Test
+    public void statefulBiconsumer() {
+        Observable.generate(new Callable<Object>() {
+            @Override
+            public Object call() throws Exception {
+                return 10;
+            }
+        }, new BiConsumer<Object, Emitter<Object>>() {
+            @Override
+            public void accept(Object s, Emitter<Object> e) throws Exception {
+                e.onNext(s);
+            }
+        }, new Consumer<Object>() {
+            @Override
+            public void accept(Object d) throws Exception { 
+                
+            }
+        })
+        .take(5)
+        .test()
+        .assertResult(10, 10, 10, 10, 10);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java
index d34ddd4304..b188b0ba04 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableGroupByTest.java
@@ -30,6 +30,7 @@
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.observables.GroupedObservable;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.Schedulers;
@@ -1442,4 +1443,33 @@ public Integer apply(Integer i) {
         assertEquals(Arrays.asList(e), inner1.errors());
         assertEquals(Arrays.asList(e), inner2.errors());
     }
+    
+    @Test
+    public void keySelectorAndDelayError() {
+        Observable.just(1).concatWith(Observable.<Integer>error(new TestException()))
+        .groupBy(Functions.identity(), true)
+        .flatMap(new Function<GroupedObservable<Object, Integer>, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(GroupedObservable<Object, Integer> g) throws Exception {
+                return g;
+            }
+        })
+        .test()
+        .assertFailure(TestException.class, 1);
+    }
+
+    @Test
+    public void keyAndValueSelectorAndDelayError() {
+        Observable.just(1).concatWith(Observable.<Integer>error(new TestException()))
+        .groupBy(Functions.identity(), Functions.<Integer>identity(), true)
+        .flatMap(new Function<GroupedObservable<Object, Integer>, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(GroupedObservable<Object, Integer> g) throws Exception {
+                return g;
+            }
+        })
+        .test()
+        .assertFailure(TestException.class, 1);
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableIntervalRangeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableIntervalRangeTest.java
new file mode 100644
index 0000000000..fc5dca5d99
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableIntervalRangeTest.java
@@ -0,0 +1,41 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.observable;
+
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Test;
+
+import io.reactivex.Observable;
+
+public class ObservableIntervalRangeTest {
+
+    @Test
+    public void simple() throws Exception {
+        Observable.intervalRange(5, 5, 50, 50, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(5L, 6L, 7L, 8L, 9L);
+    }
+
+    @Test
+    public void noOverflow() {
+        Observable.intervalRange(Long.MAX_VALUE - 1, 2, 1, 1, TimeUnit.SECONDS);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void longOverflow() {
+        Observable.intervalRange(Long.MAX_VALUE - 1, 3, 1, 1, TimeUnit.SECONDS);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeDelayErrorTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeDelayErrorTest.java
index cb7dd95e4c..7a2d509c73 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeDelayErrorTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeDelayErrorTest.java
@@ -553,4 +553,109 @@ public void run() {
             t.start();
         }
     }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeIterableDelayError() {
+        Observable.mergeDelayError(Arrays.asList(Observable.just(1), Observable.just(2)))
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeArrayDelayError() {
+        Observable.mergeArrayDelayError(Observable.just(1), Observable.just(2))
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeIterableDelayErrorWithError() {
+        Observable.mergeDelayError(
+                Arrays.asList(Observable.just(1).concatWith(Observable.<Integer>error(new TestException())), 
+                Observable.just(2)))
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
+    @Test
+    public void mergeDelayError() {
+        Observable.mergeDelayError(
+                Observable.just(Observable.just(1), 
+                Observable.just(2)))
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void mergeDelayErrorWithError() {
+        Observable.mergeDelayError(
+                Observable.just(Observable.just(1).concatWith(Observable.<Integer>error(new TestException())), 
+                Observable.just(2)))
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
+    @Test
+    public void mergeDelayErrorMaxConcurrency() {
+        Observable.mergeDelayError(
+                Observable.just(Observable.just(1), 
+                Observable.just(2)), 1)
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void mergeDelayErrorWithErrorMaxConcurrency() {
+        Observable.mergeDelayError(
+                Observable.just(Observable.just(1).concatWith(Observable.<Integer>error(new TestException())), 
+                Observable.just(2)), 1)
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeIterableDelayErrorMaxConcurrency() {
+        Observable.mergeDelayError(
+                Arrays.asList(Observable.just(1), 
+                Observable.just(2)), 1)
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeIterableDelayErrorWithErrorMaxConcurrency() {
+        Observable.mergeDelayError(
+                Arrays.asList(Observable.just(1).concatWith(Observable.<Integer>error(new TestException())), 
+                Observable.just(2)), 1)
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
+    @Test
+    public void mergeDelayError3() {
+        Observable.mergeDelayError(
+                Observable.just(1), 
+                Observable.just(2),
+                Observable.just(3)
+        )
+        .test()
+        .assertResult(1, 2, 3);
+    }
+
+    @Test
+    public void mergeDelayError3WithError() {
+        Observable.mergeDelayError(
+                Observable.just(1), 
+                Observable.just(2).concatWith(Observable.<Integer>error(new TestException())),
+                Observable.just(3)
+        )
+        .test()
+        .assertFailure(TestException.class, 1, 2, 3);
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java
index 9df3ff79fd..f046f65040 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java
@@ -1116,4 +1116,12 @@ public void onNext(Integer t) {
             runMerge(toHiddenScalar, ts);
         }
     }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeArray() {
+        Observable.mergeArray(Observable.just(1), Observable.just(2))
+        .test()
+        .assertResult(1, 2);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java
index ea2ae55711..8f159f2dc3 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableObserveOnTest.java
@@ -439,4 +439,21 @@ public void testAsyncChild() {
         ts.awaitTerminalEvent();
         ts.assertNoErrors();
     }
+    
+    @Test
+    public void delayError() {
+        Observable.range(1, 5).concatWith(Observable.<Integer>error(new TestException()))
+        .observeOn(Schedulers.computation(), true)
+        .doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                if (v == 1) {
+                    Thread.sleep(100);
+                }
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class, 1, 2, 3, 4, 5);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorReturnTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorReturnTest.java
index 836d1c0b8f..3e4636d119 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorReturnTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableOnErrorReturnTest.java
@@ -24,6 +24,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposables;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Function;
 import io.reactivex.observers.*;
 import io.reactivex.schedulers.Schedulers;
@@ -212,6 +213,12 @@ public void run() {
         }
     }
     
-    
+    @Test
+    public void returnItem() {
+        Observable.error(new TestException())
+        .onErrorReturnItem(1)
+        .test()
+        .assertResult(1);
+    }
     
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableRangeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableRangeTest.java
index 2321546650..a49c3f71f6 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableRangeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableRangeTest.java
@@ -142,4 +142,15 @@ public void testNearMaxValueWithoutBackpressure() {
         ts.assertNoErrors();
         ts.assertValues(Integer.MAX_VALUE - 1, Integer.MAX_VALUE);
     }
+    
+    @Test
+    public void negativeCount() {
+        try {
+            Observable.range(1, -1);
+            fail("Should have thrown IllegalArgumentException");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("count >= 0 required but it was -1", ex.getMessage());
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableRepeatTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableRepeatTest.java
index a96f0e3393..321757589d 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableRepeatTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableRepeatTest.java
@@ -28,7 +28,7 @@
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.functions.Function;
+import io.reactivex.functions.*;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.schedulers.Schedulers;
 
@@ -194,4 +194,29 @@ public void testRepeatRetarget() {
         
         assertEquals(Arrays.asList(1, 2, 1, 2, 1, 2, 1, 2, 1, 2), concatBase);
     }
+    
+    @Test
+    public void repeatUntil() {
+        Observable.just(1)
+        .repeatUntil(new BooleanSupplier() {
+            @Override
+            public boolean getAsBoolean() throws Exception {
+                return false;
+            }
+        })
+        .take(5)
+        .test()
+        .assertResult(1, 1, 1, 1, 1);
+    }
+
+    @Test
+    public void repeatLongPredicateInvalid() {
+        try {
+            Observable.just(1).repeat(-99);
+            fail("Should have thrown");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("times >= 0 required but it was -99", ex.getMessage());
+        }
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java
index 456b293d8d..46d84a00d4 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableReplayTest.java
@@ -31,6 +31,7 @@
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.operators.observable.ObservableReplay.*;
 import io.reactivex.observables.ConnectableObservable;
 import io.reactivex.observers.TestObserver;
@@ -1004,4 +1005,67 @@ public void onNext(Integer t) {
         ts.assertNotComplete();
         ts.assertError(TestException.class);
     }
+    
+    @Test
+    public void replayScheduler() {
+        
+        Observable.just(1).replay(Schedulers.computation())
+        .autoConnect()
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+    
+    @Test
+    public void replayTime() {
+        Observable.just(1).replay(1, TimeUnit.MINUTES)
+        .autoConnect()
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void replaySizeScheduler() {
+        
+        Observable.just(1).replay(1, Schedulers.computation())
+        .autoConnect()
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void replaySizeAndTime() {
+        Observable.just(1).replay(1, 1, TimeUnit.MILLISECONDS)
+        .autoConnect()
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+    
+    @Test
+    public void replaySelectorSizeScheduler() {
+        Observable.just(1).replay(Functions.<Observable<Integer>>identity(), 1, Schedulers.io())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void replaySelectorScheduler() {
+        Observable.just(1).replay(Functions.<Observable<Integer>>identity(), Schedulers.io())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void replaySelectorTime() {
+        Observable.just(1).replay(Functions.<Observable<Integer>>identity(), 1, TimeUnit.MINUTES)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java
index e2b555b70b..15d1d2d3bc 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java
@@ -28,6 +28,7 @@
 import io.reactivex.Observable;
 import io.reactivex.Observer;
 import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.observables.GroupedObservable;
@@ -865,4 +866,47 @@ public String apply(String t1) {
         inOrder.verifyNoMoreInteractions();
     }
 
+    @Test
+    public void retryPredicate() {
+        Observable.just(1).concatWith(Observable.<Integer>error(new TestException()))
+        .retry(new Predicate<Throwable>() {
+            @Override
+            public boolean test(Throwable v) throws Exception {
+                return true;
+            }
+        })
+        .take(5)
+        .test()
+        .assertResult(1, 1, 1, 1, 1);
+    }
+
+    @Test
+    public void retryUntil() {
+        Observable.just(1).concatWith(Observable.<Integer>error(new TestException()))
+        .retryUntil(new BooleanSupplier() {
+            @Override
+            public boolean getAsBoolean() throws Exception {
+                return false;
+            }
+        })
+        .take(5)
+        .test()
+        .assertResult(1, 1, 1, 1, 1);
+    }
+
+    @Test
+    public void retryLongPredicateInvalid() {
+        try {
+            Observable.just(1).retry(-99, new Predicate<Throwable>() {
+                @Override
+                public boolean test(Throwable e) throws Exception {
+                    return true;
+                }
+            });
+            fail("Should have thrown");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("times >= 0 required but it was -99", ex.getMessage());
+        }
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSequenceEqualTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSequenceEqualTest.java
index 2921694337..b8b577adec 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSequenceEqualTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSequenceEqualTest.java
@@ -148,4 +148,11 @@ private void verifyError(Observable<Boolean> NbpObservable) {
         inOrder.verify(NbpObserver, times(1)).onError(isA(TestException.class));
         inOrder.verifyNoMoreInteractions();
     }
+    
+    @Test
+    public void sequenceEqualBufferSize() {
+        Observable.sequenceEqual(Observable.range(1, 20), Observable.range(1, 20), 2)
+        .test()
+        .assertResult(true);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipTimedTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipTimedTest.java
index c716691116..4c1c69d6d3 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipTimedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSkipTimedTest.java
@@ -156,4 +156,12 @@ public void testSkipTimedErrorAfterTime() {
         verify(o, never()).onComplete();
 
     }
+
+    @Test
+    public void skipTimedDefaultScheduler() {
+        Observable.just(1).skip(1, TimeUnit.MINUTES)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult();
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java
index 3e0bced9af..bdf1565513 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSwitchTest.java
@@ -13,7 +13,7 @@
 
 package io.reactivex.internal.operators.observable;
 
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
 
@@ -516,4 +516,95 @@ public void delayErrors() {
         TestHelper.assertError(errors, 1, TestException.class, "Forced failure 2");
         TestHelper.assertError(errors, 2, TestException.class, "Forced failure 3");
     }
+    
+    @Test
+    public void switchOnNextDelayError() {
+        PublishSubject<Observable<Integer>> ps = PublishSubject.create();
+        
+        TestObserver<Integer> ts = Observable.switchOnNextDelayError(ps).test();
+        
+        ps.onNext(Observable.just(1));
+        ps.onNext(Observable.range(2, 4));
+        ps.onComplete();
+        
+        ts.assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void switchOnNextDelayErrorWithError() {
+        PublishSubject<Observable<Integer>> ps = PublishSubject.create();
+        
+        TestObserver<Integer> ts = Observable.switchOnNextDelayError(ps).test();
+        
+        ps.onNext(Observable.just(1));
+        ps.onNext(Observable.<Integer>error(new TestException()));
+        ps.onNext(Observable.range(2, 4));
+        ps.onComplete();
+        
+        ts.assertFailure(TestException.class, 1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void switchOnNextDelayErrorBufferSize() {
+        PublishSubject<Observable<Integer>> ps = PublishSubject.create();
+        
+        TestObserver<Integer> ts = Observable.switchOnNextDelayError(ps, 2).test();
+        
+        ps.onNext(Observable.just(1));
+        ps.onNext(Observable.range(2, 4));
+        ps.onComplete();
+        
+        ts.assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void switchMapDelayErrorEmptySource() {
+        assertSame(Observable.empty(), Observable.<Object>empty()
+                .switchMapDelayError(new Function<Object, ObservableSource<Integer>>() {
+                    @Override
+                    public ObservableSource<Integer> apply(Object v) throws Exception {
+                        return Observable.just(1);
+                    }
+                }, 16));
+    }
+
+    @Test
+    public void switchMapDelayErrorJustSource() {
+        Observable.just(0)
+        .switchMapDelayError(new Function<Object, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Object v) throws Exception {
+                return Observable.just(1);
+            }
+        }, 16)
+        .test()
+        .assertResult(1);
+    
+    }
+
+    @Test
+    public void switchMapErrorEmptySource() {
+        assertSame(Observable.empty(), Observable.<Object>empty()
+                .switchMap(new Function<Object, ObservableSource<Integer>>() {
+                    @Override
+                    public ObservableSource<Integer> apply(Object v) throws Exception {
+                        return Observable.just(1);
+                    }
+                }, 16));
+    }
+
+    @Test
+    public void switchMapJustSource() {
+        Observable.just(0)
+        .switchMap(new Function<Object, ObservableSource<Integer>>() {
+            @Override
+            public ObservableSource<Integer> apply(Object v) throws Exception {
+                return Observable.just(1);
+            }
+        }, 16)
+        .test()
+        .assertResult(1);
+    
+    }
+
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeLastTimedTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeLastTimedTest.java
index e66f3b4eb9..777da5e419 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeLastTimedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeLastTimedTest.java
@@ -23,7 +23,7 @@
 
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.schedulers.*;
 import io.reactivex.subjects.PublishSubject;
 
 public class ObservableTakeLastTimedTest {
@@ -199,4 +199,37 @@ public void takeLastTimedWithZeroCapacity() {
         verify(o, never()).onNext(any());
         verify(o, never()).onError(any(Throwable.class));
     }
+    
+    @Test
+    public void takeLastTimeAndSize() {
+        Observable.just(1, 2)
+        .takeLast(1, 1, TimeUnit.MINUTES)
+        .test()
+        .assertResult(2);
+    }
+
+    @Test
+    public void takeLastTime() {
+        Observable.just(1, 2)
+        .takeLast(1, TimeUnit.MINUTES)
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void takeLastTimeDelayError() {
+        Observable.just(1, 2).concatWith(Observable.<Integer>error(new TestException()))
+        .takeLast(1, TimeUnit.MINUTES, true)
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
+    @Test
+    public void takeLastTimeDelayErrorCustomScheduler() {
+        Observable.just(1, 2).concatWith(Observable.<Integer>error(new TestException()))
+        .takeLast(1, TimeUnit.MINUTES, Schedulers.io(), true)
+        .test()
+        .assertFailure(TestException.class, 1, 2);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeTest.java
index cdc7a2ec6b..b7573b04b6 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableTakeTest.java
@@ -357,4 +357,14 @@ public void accept(Integer v) {
         ts.assertNoErrors();
         ts.assertComplete();
     }
+    
+    @Test
+    public void takeNegative() {
+        try {
+            Observable.just(1).take(-99);
+            fail("Should have thrown");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("count >= 0 required but it was -99", ex.getMessage());
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTest.java
index 722a1dffd9..f4d93a5859 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTest.java
@@ -149,4 +149,12 @@ public void testThrottle() {
         inOrder.verify(NbpObserver).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
+    
+    @Test
+    public void throttleFirstDefaultScheduler() {
+        Observable.just(1).throttleFirst(100, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableTimeIntervalTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableTimeIntervalTest.java
index bffaa48fc8..85d767587e 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableTimeIntervalTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableTimeIntervalTest.java
@@ -21,6 +21,8 @@
 import org.mockito.InOrder;
 
 import io.reactivex.*;
+import io.reactivex.functions.Function;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.schedulers.*;
 import io.reactivex.subjects.PublishSubject;
 
@@ -64,4 +66,59 @@ public void testTimeInterval() {
         inOrder.verify(NbpObserver, times(1)).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
+    
+    @Test
+    public void timeIntervalDefault() {
+        final TestScheduler scheduler = new TestScheduler();
+        
+        RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler, Scheduler>() {
+            @Override
+            public Scheduler apply(Scheduler v) throws Exception {
+                return scheduler;
+            }
+        });
+        
+        try {
+            Observable.range(1, 5)
+            .timeInterval()
+            .map(new Function<Timed<Integer>, Long>() {
+                @Override
+                public Long apply(Timed<Integer> v) throws Exception {
+                    return v.time();
+                }
+            })
+            .test()
+            .assertResult(0L, 0L, 0L, 0L, 0L);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void timeIntervalDefaultSchedulerCustomUnit() {
+        final TestScheduler scheduler = new TestScheduler();
+        
+        RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler, Scheduler>() {
+            @Override
+            public Scheduler apply(Scheduler v) throws Exception {
+                return scheduler;
+            }
+        });
+        
+        try {
+            Observable.range(1, 5)
+            .timeInterval(TimeUnit.SECONDS)
+            .map(new Function<Timed<Integer>, Long>() {
+                @Override
+                public Long apply(Timed<Integer> v) throws Exception {
+                    return v.time();
+                }
+            })
+            .test()
+            .assertResult(0L, 0L, 0L, 0L, 0L);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableTimeoutTests.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableTimeoutTests.java
index e7815d27eb..b491470dba 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableTimeoutTests.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableTimeoutTests.java
@@ -356,4 +356,12 @@ public void subscribe(Observer<? super String> NbpSubscriber) {
 
         verify(s, times(1)).dispose();
     }
+    
+    @Test
+    public void timedAndOther() {
+        Observable.never().timeout(100, TimeUnit.MILLISECONDS, Observable.just(1))
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableTimestampTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableTimestampTest.java
index 953362b6b9..50aca27fbd 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableTimestampTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableTimestampTest.java
@@ -22,6 +22,8 @@
 import org.mockito.InOrder;
 
 import io.reactivex.*;
+import io.reactivex.functions.Function;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.schedulers.*;
 import io.reactivex.subjects.PublishSubject;
 
@@ -80,4 +82,59 @@ public void timestampWithScheduler2() {
         verify(NbpObserver, never()).onError(any(Throwable.class));
         verify(NbpObserver, never()).onComplete();
     }
+
+    @Test
+    public void timeIntervalDefault() {
+        final TestScheduler scheduler = new TestScheduler();
+        
+        RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler, Scheduler>() {
+            @Override
+            public Scheduler apply(Scheduler v) throws Exception {
+                return scheduler;
+            }
+        });
+        
+        try {
+            Observable.range(1, 5)
+            .timestamp()
+            .map(new Function<Timed<Integer>, Long>() {
+                @Override
+                public Long apply(Timed<Integer> v) throws Exception {
+                    return v.time();
+                }
+            })
+            .test()
+            .assertResult(0L, 0L, 0L, 0L, 0L);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void timeIntervalDefaultSchedulerCustomUnit() {
+        final TestScheduler scheduler = new TestScheduler();
+        
+        RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler, Scheduler>() {
+            @Override
+            public Scheduler apply(Scheduler v) throws Exception {
+                return scheduler;
+            }
+        });
+        
+        try {
+            Observable.range(1, 5)
+            .timestamp(TimeUnit.SECONDS)
+            .map(new Function<Timed<Integer>, Long>() {
+                @Override
+                public Long apply(Timed<Integer> v) throws Exception {
+                    return v.time();
+                }
+            })
+            .test()
+            .assertResult(0L, 0L, 0L, 0L, 0L);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableListTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableListTest.java
index 318d292d15..45f5ee1eb2 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableListTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableListTest.java
@@ -103,4 +103,13 @@ static void await(CyclicBarrier cb) {
             ex.printStackTrace();
         }
     }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void capacityHint() {
+        Observable.range(1, 10)
+        .toList(4)
+        .test()
+        .assertResult(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableSortedListTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableSortedListTest.java
index 602f002491..0cfe73ce66 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableSortedListTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableToObservableSortedListTest.java
@@ -75,4 +75,45 @@ static void await(CyclicBarrier cb) {
             ex.printStackTrace();
         }
     }
+    
+    @Test
+    public void sorted() {
+        Observable.just(5, 1, 2, 4, 3).sorted()
+        .test()
+        .assertResult(1, 2, 3, 4, 5);
+    }
+    
+    @Test
+    public void sortedComparator() {
+        Observable.just(5, 1, 2, 4, 3).sorted(new Comparator<Integer>() {
+            @Override
+            public int compare(Integer a, Integer b) {
+                return b - a;
+            }
+        })
+        .test()
+        .assertResult(5, 4, 3, 2, 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void toSortedListCapacity() {
+        Observable.just(5, 1, 2, 4, 3).toSortedList(4)
+        .test()
+        .assertResult(Arrays.asList(1, 2, 3, 4, 5));
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void toSortedListComparatorCapacity() {
+        Observable.just(5, 1, 2, 4, 3).toSortedList(new Comparator<Integer>() {
+            @Override
+            public int compare(Integer a, Integer b) {
+                return b - a;
+            }
+        }, 4)
+        .test()
+        .assertResult(Arrays.asList(5, 4, 3, 2, 1));
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableToXTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableToXTest.java
new file mode 100644
index 0000000000..ccc0ca411b
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableToXTest.java
@@ -0,0 +1,51 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.observable;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class ObservableToXTest {
+
+    @Test
+    public void toFlowableBuffer() {
+        Observable.range(1, 5)
+        .toFlowable(BackpressureStrategy.BUFFER)
+        .test(2L)
+        .assertValues(1, 2)
+        .assertNoErrors()
+        .assertNotComplete();
+    }
+
+    @Test
+    public void toFlowableDrop() {
+        Observable.range(1, 5)
+        .toFlowable(BackpressureStrategy.DROP)
+        .test(1)
+        .assertResult(1);
+    }
+
+    @Test
+    public void toFlowableLatest() {
+        TestSubscriber<Integer> ts = Observable.range(1, 5)
+        .toFlowable(BackpressureStrategy.LATEST)
+        .test(0);
+        
+        ts.request(1);
+        ts
+        .assertResult(5);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java
index 4a8c2f6365..1ba22d2178 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithSizeTest.java
@@ -129,7 +129,14 @@ public void testWindowUnsubscribeNonOverlappingAsyncSource() {
 
                     @Override
                     public void accept(Integer t1) {
-                        count.incrementAndGet();
+                        if (count.incrementAndGet() == 500000) {
+                            // give it a small break halfway through
+                            try {
+                                Thread.sleep(1);
+                            } catch (InterruptedException ex) {
+                                // ignored
+                            }
+                        }
                     }
 
                 })
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
index 7ce76ca1b0..a0510fe8c2 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
@@ -13,7 +13,7 @@
 
 package io.reactivex.internal.operators.observable;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 
 import java.util.*;
 import java.util.concurrent.TimeUnit;
@@ -26,8 +26,9 @@
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposables;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.observers.*;
-import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.schedulers.*;
 
 
 public class ObservableWindowWithTimeTest {
@@ -218,5 +219,64 @@ public void accept(Integer pv) {
         ts.assertComplete();
         Assert.assertTrue(ts.valueCount() != 0);
     }
-    
+
+    @Test
+    public void timespanTimeskipDefaultScheduler() {
+        Observable.just(1)
+        .window(1, 1, TimeUnit.MINUTES)
+        .flatMap(Functions.<Observable<Integer>>identity())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void timespanTimeskipCustomScheduler() {
+        Observable.just(1)
+        .window(1, 1, TimeUnit.MINUTES, Schedulers.io())
+        .flatMap(Functions.<Observable<Integer>>identity())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void timespanTimeskipCustomSchedulerBufferSize() {
+        Observable.range(1, 10)
+        .window(1, 1, TimeUnit.MINUTES, Schedulers.io(), 2)
+        .flatMap(Functions.<Observable<Integer>>identity())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+    }
+
+    @Test
+    public void timespanDefaultSchedulerSize() {
+        Observable.range(1, 10)
+        .window(1, TimeUnit.MINUTES, 20)
+        .flatMap(Functions.<Observable<Integer>>identity())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+    }
+
+    @Test
+    public void timespanDefaultSchedulerSizeRestart() {
+        Observable.range(1, 10)
+        .window(1, TimeUnit.MINUTES, 20, true)
+        .flatMap(Functions.<Observable<Integer>>identity(), true)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+    }
+
+    @Test
+    public void invalidSpan() {
+        try {
+            Observable.just(1).window(-99, 1, TimeUnit.SECONDS);
+            fail("Should have thrown!");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("timespan > 0 required but it was -99", ex.getMessage());
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableZipTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableZipTest.java
index c6a5357037..4746403990 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableZipTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableZipTest.java
@@ -28,6 +28,7 @@
 import io.reactivex.Observable;
 import io.reactivex.Observer;
 import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.observers.*;
@@ -1144,4 +1145,191 @@ public Integer apply(Integer t1, Integer t2) {
             Assert.assertEquals(11, value);
         }
     }
+
+    @Test
+    public void zip2() {
+        Observable.zip(Observable.just(1),
+                Observable.just(2),
+            new BiFunction<Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b) throws Exception {
+                    return "" + a + b;
+                }
+            }
+        )
+        .test()
+        .assertResult("12");
+    }
+
+    @Test
+    public void zip3() {
+        Observable.zip(Observable.just(1),
+                Observable.just(2), Observable.just(3),
+            new Function3<Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c) throws Exception {
+                    return "" + a + b + c;
+                }
+            }
+        )
+        .test()
+        .assertResult("123");
+    }
+
+    @Test
+    public void zip4() {
+        Observable.zip(Observable.just(1),
+                Observable.just(2), Observable.just(3),
+                Observable.just(4),
+            new Function4<Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d) throws Exception {
+                    return "" + a + b + c + d;
+                }
+            }
+        )
+        .test()
+        .assertResult("1234");
+    }
+
+    @Test
+    public void zip5() {
+        Observable.zip(Observable.just(1),
+                Observable.just(2), Observable.just(3),
+                Observable.just(4), Observable.just(5),
+            new Function5<Integer, Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e) throws Exception {
+                    return "" + a + b + c + d + e;
+                }
+            }
+        )
+        .test()
+        .assertResult("12345");
+    }
+
+    @Test
+    public void zip6() {
+        Observable.zip(Observable.just(1),
+                Observable.just(2), Observable.just(3),
+                Observable.just(4), Observable.just(5),
+                Observable.just(6),
+            new Function6<Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f) throws Exception {
+                    return "" + a + b + c + d + e + f;
+                }
+            }
+        )
+        .test()
+        .assertResult("123456");
+    }
+
+    @Test
+    public void zip7() {
+        Observable.zip(Observable.just(1),
+                Observable.just(2), Observable.just(3),
+                Observable.just(4), Observable.just(5),
+                Observable.just(6), Observable.just(7),
+            new Function7<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g)
+                        throws Exception {
+                    return "" + a + b + c + d + e + f + g;
+                }
+            }
+        )
+        .test()
+        .assertResult("1234567");
+    }
+
+    @Test
+    public void zip8() {
+        Observable.zip(Observable.just(1),
+                Observable.just(2), Observable.just(3),
+                Observable.just(4), Observable.just(5),
+                Observable.just(6), Observable.just(7),
+                Observable.just(8), 
+            new Function8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g,
+                        Integer h) throws Exception {
+                    return "" + a + b + c + d + e + f + g + h;
+                }
+            }
+        )
+        .test()
+        .assertResult("12345678");
+    }
+    @Test
+    public void zip9() {
+        Observable.zip(Observable.just(1),
+                Observable.just(2), Observable.just(3),
+                Observable.just(4), Observable.just(5),
+                Observable.just(6), Observable.just(7),
+                Observable.just(8), Observable.just(9),
+            new Function9<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g,
+                        Integer h, Integer i) throws Exception {
+                    return "" + a + b + c + d + e + f + g + h + i;
+                }
+            }
+        )
+        .test()
+        .assertResult("123456789");
+    }
+
+    @Test
+    public void zip2DelayError() {
+        Observable.zip(Observable.just(1).concatWith(Observable.<Integer>error(new TestException())),
+                Observable.just(2),
+            new BiFunction<Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b) throws Exception {
+                    return "" + a + b;
+                }
+            }, true
+        )
+        .test()
+        .assertFailure(TestException.class, "12");
+    }
+
+    @Test
+    public void zip2Prefetch() {
+        Observable.zip(Observable.range(1, 9),
+                Observable.range(21, 9),
+            new BiFunction<Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b) throws Exception {
+                    return "" + a + b;
+                }
+            }, false, 2
+        )
+        .takeLast(1)
+        .test()
+        .assertResult("929");
+    }
+
+    @Test
+    public void zip2DelayErrorPrefetch() {
+        Observable.zip(Observable.range(1, 9).concatWith(Observable.<Integer>error(new TestException())),
+                Observable.range(21, 9),
+            new BiFunction<Integer, Integer, Object>() {
+                @Override
+                public Object apply(Integer a, Integer b) throws Exception {
+                    return "" + a + b;
+                }
+            }, true, 2
+        )
+        .skip(8)
+        .test()
+        .assertFailure(TestException.class, "929");
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void zipArrayEmpty() {
+        assertSame(Observable.empty(), Observable.zipArray(Functions.<Object[]>identity(), false, 16));
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleAmbTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleAmbTest.java
new file mode 100644
index 0000000000..78a4ed5049
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleAmbTest.java
@@ -0,0 +1,79 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.single;
+
+import static org.junit.Assert.*;
+
+import java.util.NoSuchElementException;
+
+import org.junit.Test;
+
+import io.reactivex.Single;
+import io.reactivex.processors.PublishProcessor;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class SingleAmbTest {
+    @Test
+    public void ambWithFirstFires() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+        
+        TestSubscriber<Integer> ts = pp1.toSingle().ambWith(pp2.toSingle()).test();
+        
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+        
+        pp1.onNext(1);
+        pp1.onComplete();
+        
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+        
+        ts.assertResult(1);
+    
+    }
+
+    @Test
+    public void ambWithSecondFires() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+        
+        TestSubscriber<Integer> ts = pp1.toSingle().ambWith(pp2.toSingle()).test();
+        
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+        
+        pp2.onNext(2);
+        pp2.onComplete();
+        
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+        
+        ts.assertResult(2);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void ambArrayEmpty() {
+        Single.ambArray()
+        .test()
+        .assertFailure(NoSuchElementException.class);
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void ambSingleSource() {
+        assertSame(Single.never(), Single.ambArray(Single.never()));
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleConcatTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleConcatTest.java
new file mode 100644
index 0000000000..cff61e1d5d
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleConcatTest.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.single;
+
+import org.junit.Test;
+
+import io.reactivex.Single;
+
+public class SingleConcatTest {
+    @Test
+    public void concatWith() {
+        Single.just(1).concatWith(Single.just(2))
+        .test()
+        .assertResult(1, 2);
+    }
+    
+    @Test
+    public void concat2() {
+        Single.concat(Single.just(1), Single.just(2))
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void concat3() {
+        Single.concat(Single.just(1), Single.just(2), Single.just(3))
+        .test()
+        .assertResult(1, 2, 3);
+    }
+
+    @Test
+    public void concat4() {
+        Single.concat(Single.just(1), Single.just(2), Single.just(3), Single.just(4))
+        .test()
+        .assertResult(1, 2, 3, 4);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleCreateTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleCreateTest.java
index b691d90a0e..daa47e94bd 100644
--- a/src/test/java/io/reactivex/internal/operators/single/SingleCreateTest.java
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleCreateTest.java
@@ -68,4 +68,9 @@ public void subscribe(SingleEmitter<Integer> e) throws Exception {
         
         assertTrue(d.isDisposed());
     }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void unsafeCreate() {
+        Single.unsafeCreate(Single.just(1));
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleDelayTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleDelayTest.java
new file mode 100644
index 0000000000..9f15b44fe8
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleDelayTest.java
@@ -0,0 +1,97 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.single;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.functions.BiConsumer;
+import io.reactivex.schedulers.Schedulers;
+
+public class SingleDelayTest {
+    @Test
+    public void delay() throws Exception {
+        final AtomicInteger value = new AtomicInteger();
+        
+        Single.just(1).delay(200, TimeUnit.MILLISECONDS)
+        .subscribe(new BiConsumer<Integer, Throwable>() {
+            @Override
+            public void accept(Integer v, Throwable e) throws Exception {
+                value.set(v);
+            }
+        });
+        
+        Thread.sleep(100);
+        
+        assertEquals(0, value.get());
+        
+        Thread.sleep(200);
+        
+        assertEquals(1, value.get());
+    }
+    
+    @Test
+    public void delaySubscriptionCompletable() throws Exception {
+        Single.just(1).delaySubscription(Completable.complete().delay(100, TimeUnit.MILLISECONDS))
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void delaySubscriptionObservable() throws Exception {
+        Single.just(1).delaySubscription(Observable.timer(100, TimeUnit.MILLISECONDS))
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void delaySubscriptionFlowable() throws Exception {
+        Single.just(1).delaySubscription(Flowable.timer(100, TimeUnit.MILLISECONDS))
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void delaySubscriptionSingle() throws Exception {
+        Single.just(1).delaySubscription(Single.timer(100, TimeUnit.MILLISECONDS))
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void delaySubscriptionTime() throws Exception {
+        Single.just(1).delaySubscription(100, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void delaySubscriptionTimeCustomScheduler() throws Exception {
+        Single.just(1).delaySubscription(100, TimeUnit.MILLISECONDS, Schedulers.io())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleDoOnTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleDoOnTest.java
new file mode 100644
index 0000000000..6c357e1eef
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleDoOnTest.java
@@ -0,0 +1,85 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.single;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import io.reactivex.Single;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.*;
+
+public class SingleDoOnTest {
+
+    @Test
+    public void doOnCancel() {
+        final int[] count = { 0 };
+        
+        Single.never().doOnCancel(new Action() {
+            @Override
+            public void run() throws Exception { 
+                count[0]++; 
+            }
+        }).test(true);
+        
+        assertEquals(1, count[0]);
+    }
+
+    @Test
+    public void doOnError() {
+        final Object[] event = { null };
+        
+        Single.error(new TestException()).doOnError(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) throws Exception {
+                event[0] = e;
+            }
+        })
+        .test();
+        
+        assertTrue(event[0].toString(), event[0] instanceof TestException);
+    }
+
+    @Test
+    public void doOnSubscribe() {
+        final int[] count = { 0 };
+        
+        Single.never().doOnSubscribe(new Consumer<Disposable>() {
+            @Override
+            public void accept(Disposable d) throws Exception { 
+                count[0]++; 
+            }
+        }).test();
+        
+        assertEquals(1, count[0]);
+    }
+
+    @Test
+    public void doOnSuccess() {
+        final Object[] event = { null };
+        
+        Single.just(1).doOnSuccess(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer e) throws Exception {
+                event[0] = e;
+            }
+        })
+        .test();
+        
+        assertEquals((Integer)1, event[0]);
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleFromTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleFromTest.java
new file mode 100644
index 0000000000..bdb3b3117d
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleFromTest.java
@@ -0,0 +1,47 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.single;
+
+import java.util.concurrent.*;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.schedulers.Schedulers;
+
+public class SingleFromTest {
+
+    @Test
+    public void fromFuture() throws Exception {
+        Single.fromFuture(Flowable.just(1).toFuture(), Schedulers.io())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void fromFutureTimeout() throws Exception {
+        Single.fromFuture(Flowable.never().toFuture(), 1, TimeUnit.SECONDS, Schedulers.io())
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TimeoutException.class);
+    }
+    
+    @Test
+    public void fromPublisher() {
+        Single.fromPublisher(Flowable.just(1))
+        .test()
+        .assertResult(1);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleMergeTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleMergeTest.java
new file mode 100644
index 0000000000..e5b2465b14
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleMergeTest.java
@@ -0,0 +1,51 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.single;
+
+import org.junit.Test;
+
+import io.reactivex.Single;
+
+public class SingleMergeTest {
+    
+    @Test
+    public void mergeSingleSingle() {
+        
+        Single.merge(Single.just(Single.just(1)))
+        .test()
+        .assertResult(1);
+    }
+
+    @Test
+    public void merge2() {
+        Single.merge(Single.just(1), Single.just(2))
+        .test()
+        .assertResult(1, 2);
+    }
+
+    @Test
+    public void merge3() {
+        Single.merge(Single.just(1), Single.just(2), Single.just(3))
+        .test()
+        .assertResult(1, 2, 3);
+    }
+
+    @Test
+    public void merge4() {
+        Single.merge(Single.just(1), Single.just(2), Single.just(3), Single.just(4))
+        .test()
+        .assertResult(1, 2, 3, 4);
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleMiscTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleMiscTest.java
new file mode 100644
index 0000000000..9681d235bb
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleMiscTest.java
@@ -0,0 +1,288 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.single;
+
+import static org.junit.Assert.*;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.disposables.Disposables;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.*;
+import io.reactivex.schedulers.Schedulers;
+
+public class SingleMiscTest {
+    @Test
+    public void never() {
+        Single.never()
+        .test()
+        .assertNoValues()
+        .assertNoErrors()
+        .assertNotComplete();
+    }
+    
+    @Test
+    public void timer() throws Exception {
+        Single.timer(100, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(0L);
+    }
+    
+    @Test
+    public void wrap() {
+        assertSame(Single.never(), Single.wrap(Single.never()));
+        
+        Single.wrap(new SingleSource<Object>() {
+            @Override
+            public void subscribe(SingleObserver<? super Object> s) {
+                s.onSubscribe(Disposables.empty());
+                s.onSuccess(1);
+            }
+        })
+        .test()
+        .assertResult(1);
+    }
+    
+    @Test
+    public void cast() {
+        Single<Number> source = Single.just(1d)
+                .cast(Number.class);
+        source.test()
+        .assertResult((Number)1d);
+    }
+    
+    @Test
+    public void contains() {
+        Single.just(1).contains(1).test().assertResult(true);
+        
+        Single.just(2).contains(1).test().assertResult(false);
+    }
+    
+    @Test
+    public void compose() {
+        
+        Single.just(1)
+        .compose(new Function<Single<Integer>, SingleSource<Object>>() {
+            @Override
+            public SingleSource<Object> apply(Single<Integer> f) throws Exception {
+                return f.map(new Function<Integer, Object>() {
+                    @Override
+                    public Object apply(Integer v) throws Exception {
+                        return v + 1;
+                    }
+                });
+            }
+        })
+        .test()
+        .assertResult(2);
+    }
+    
+    @Test
+    public void hide() {
+        assertNotSame(Single.never(), Single.never().hide());
+    }
+    
+    @Test
+    public void onErrorResumeNext() {
+        Single.<Integer>error(new TestException())
+        .onErrorResumeNext(Single.just(1))
+        .test()
+        .assertResult(1);
+    }
+    
+    @Test
+    public void onErrorReturnValue() {
+        Single.<Integer>error(new TestException())
+        .onErrorReturnItem(1)
+        .test()
+        .assertResult(1);
+    }
+    
+    @Test
+    public void repeat() {
+        Single.just(1).repeat().take(5)
+        .test()
+        .assertResult(1, 1, 1, 1, 1);
+    }
+    
+    @Test
+    public void repeatTimes() {
+        Single.just(1).repeat(5)
+        .test()
+        .assertResult(1, 1, 1, 1, 1);
+    }
+    
+    @Test
+    public void repeatUntil() {
+        final AtomicBoolean flag = new AtomicBoolean();
+        
+        Single.just(1)
+        .doOnSuccess(new Consumer<Integer>() {
+            int c;
+            @Override
+            public void accept(Integer v) throws Exception { 
+                if (++c == 5) {
+                    flag.set(true);
+                }
+                
+            }
+        })
+        .repeatUntil(new BooleanSupplier() {
+            @Override
+            public boolean getAsBoolean() throws Exception {
+                return flag.get();
+            }
+        })
+        .test()
+        .assertResult(1, 1, 1, 1, 1);
+    }
+
+    @Test
+    public void retry() {
+        Single.fromCallable(new Callable<Object>() {
+            int c;
+            @Override
+            public Object call() throws Exception {
+                if (++c != 5) {
+                    throw new TestException();
+                }
+                return 1;
+            }
+        })
+        .retry()
+        .test()
+        .assertResult(1);
+    }
+
+    @Test
+    public void retryBiPredicate() {
+        Single.fromCallable(new Callable<Object>() {
+            int c;
+            @Override
+            public Object call() throws Exception {
+                if (++c != 5) {
+                    throw new TestException();
+                }
+                return 1;
+            }
+        })
+        .retry(new BiPredicate<Integer, Throwable>() {
+            @Override
+            public boolean test(Integer i, Throwable e) throws Exception {
+                return true;
+            }
+        })
+        .test()
+        .assertResult(1);
+    }
+
+    @Test
+    public void retryTimes() {
+        Single.fromCallable(new Callable<Object>() {
+            int c;
+            @Override
+            public Object call() throws Exception {
+                if (++c != 5) {
+                    throw new TestException();
+                }
+                return 1;
+            }
+        })
+        .retry(5)
+        .test()
+        .assertResult(1);
+    }
+
+    @Test
+    public void retryPredicate() {
+        Single.fromCallable(new Callable<Object>() {
+            int c;
+            @Override
+            public Object call() throws Exception {
+                if (++c != 5) {
+                    throw new TestException();
+                }
+                return 1;
+            }
+        })
+        .retry(new Predicate<Throwable>() {
+            @Override
+            public boolean test(Throwable e) throws Exception {
+                return true;
+            }
+        })
+        .test()
+        .assertResult(1);
+    }
+    
+    @Test
+    public void timeout() throws Exception {
+        Single.never().timeout(100, TimeUnit.MILLISECONDS, Schedulers.io())
+        .test()
+        .awaitDone()
+        .assertFailure(TimeoutException.class);
+    }
+
+    @Test
+    public void timeoutOther() throws Exception {
+        Single.never()
+        .timeout(100, TimeUnit.MILLISECONDS, Schedulers.io(), Single.just(1))
+        .test()
+        .awaitDone()
+        .assertResult(1);
+    }
+    
+    @Test
+    public void toCompletable() {
+        Single.just(1)
+        .toCompletable()
+        .test()
+        .assertResult();
+
+        Single.error(new TestException())
+        .toCompletable()
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void toObservable() {
+        Single.just(1)
+        .toObservable()
+        .test()
+        .assertResult(1);
+
+        Single.error(new TestException())
+        .toObservable()
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void equals() {
+        Single.equals(Single.just(1), Single.just(1).hide())
+        .test()
+        .assertResult(true);
+
+        Single.equals(Single.just(1), Single.just(2))
+        .test()
+        .assertResult(false);
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleZipTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleZipTest.java
new file mode 100644
index 0000000000..ee9aa207f7
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleZipTest.java
@@ -0,0 +1,138 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.single;
+
+import org.junit.Test;
+
+import io.reactivex.Single;
+import io.reactivex.functions.*;
+
+public class SingleZipTest {
+
+    @Test
+    public void zip2() {
+        Single.zip(Single.just(1), Single.just(2), new BiFunction<Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b) throws Exception {
+                return a + "" + b;
+            }
+        })
+        .test()
+        .assertResult("12");
+    }
+
+    @Test
+    public void zip3() {
+        Single.zip(Single.just(1), Single.just(2), Single.just(3), new Function3<Integer, Integer, Integer, Object>() {
+            @Override
+            public Object apply(Integer a, Integer b, Integer c) throws Exception {
+                return a + "" + b + c;
+            }
+        })
+        .test()
+        .assertResult("123");
+    }
+
+    @Test
+    public void zip4() {
+        Single.zip(Single.just(1), Single.just(2), Single.just(3),
+                Single.just(4),
+                new Function4<Integer, Integer, Integer, Integer, Object>() {
+                    @Override
+                    public Object apply(Integer a, Integer b, Integer c, Integer d) throws Exception {
+                        return a + "" + b + c + d;
+                    }
+                })
+        .test()
+        .assertResult("1234");
+    }
+
+    @Test
+    public void zip5() {
+        Single.zip(Single.just(1), Single.just(2), Single.just(3),
+                Single.just(4), Single.just(5),
+                new Function5<Integer, Integer, Integer, Integer, Integer, Object>() {
+                    @Override
+                    public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e) throws Exception {
+                        return a + "" + b + c + d + e;
+                    }
+                })
+        .test()
+        .assertResult("12345");
+    }
+
+    @Test
+    public void zip6() {
+        Single.zip(Single.just(1), Single.just(2), Single.just(3),
+                Single.just(4), Single.just(5), Single.just(6),
+                new Function6<Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                    @Override
+                    public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f)
+                            throws Exception {
+                        return a + "" + b + c + d + e + f;
+                    }
+                })
+        .test()
+        .assertResult("123456");
+    }
+
+    @Test
+    public void zip7() {
+        Single.zip(Single.just(1), Single.just(2), Single.just(3),
+                Single.just(4), Single.just(5), Single.just(6),
+                Single.just(7),
+                new Function7<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                    @Override
+                    public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g)
+                            throws Exception {
+                        return a + "" + b + c + d + e + f + g;
+                    }
+                })
+        .test()
+        .assertResult("1234567");
+    }
+
+    @Test
+    public void zip8() {
+        Single.zip(Single.just(1), Single.just(2), Single.just(3),
+                Single.just(4), Single.just(5), Single.just(6),
+                Single.just(7), Single.just(8),
+                new Function8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                    @Override
+                    public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g,
+                            Integer h) throws Exception {
+                        return a + "" + b + c + d + e + f + g + h;
+                    }
+                })
+        .test()
+        .assertResult("12345678");
+    }
+
+    @Test
+    public void zip9() {
+        Single.zip(Single.just(1), Single.just(2), Single.just(3),
+                Single.just(4), Single.just(5), Single.just(6),
+                Single.just(7), Single.just(8), Single.just(9),
+                new Function9<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Object>() {
+                    @Override
+                    public Object apply(Integer a, Integer b, Integer c, Integer d, Integer e, Integer f, Integer g,
+                            Integer h, Integer i) throws Exception {
+                        return a + "" + b + c + d + e + f + g + h + i;
+                    }
+                })
+        .test()
+        .assertResult("123456789");
+    }
+
+}
diff --git a/src/test/java/io/reactivex/observable/ObservableDoOnTest.java b/src/test/java/io/reactivex/observable/ObservableDoOnTest.java
index c5e90767b1..1318896001 100644
--- a/src/test/java/io/reactivex/observable/ObservableDoOnTest.java
+++ b/src/test/java/io/reactivex/observable/ObservableDoOnTest.java
@@ -20,6 +20,7 @@
 import org.junit.Test;
 
 import io.reactivex.Observable;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 
 public class ObservableDoOnTest {
@@ -72,4 +73,34 @@ public void run() {
         assertEquals("one", output);
         assertTrue(r.get());
     }
+    
+    @Test
+    public void doOnTerminateComplete() {
+        final AtomicBoolean r = new AtomicBoolean();
+        String output = Observable.just("one").doOnTerminate(new Action() {
+            @Override
+            public void run() {
+                r.set(true);
+            }
+        }).blockingSingle();
+
+        assertEquals("one", output);
+        assertTrue(r.get());
+        
+    }
+
+    @Test
+    public void doOnTerminateError() {
+        final AtomicBoolean r = new AtomicBoolean();
+        Observable.<String>error(new TestException()).doOnTerminate(new Action() {
+            @Override
+            public void run() {
+                r.set(true);
+            }
+        })
+        .test()
+        .assertFailure(TestException.class);
+        assertTrue(r.get());
+        
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/observable/ObservableStartWithTests.java b/src/test/java/io/reactivex/observable/ObservableStartWithTests.java
index be597d8eaa..75d548850a 100644
--- a/src/test/java/io/reactivex/observable/ObservableStartWithTests.java
+++ b/src/test/java/io/reactivex/observable/ObservableStartWithTests.java
@@ -61,4 +61,8 @@ public void startWithObservable() {
         assertEquals("two", values.get(3));
     }
 
+    @Test
+    public void startWithEmpty() {
+        Observable.just(1).startWithArray().test().assertResult(1);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java b/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
index 060c7590e1..cc01e7a747 100644
--- a/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
+++ b/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
@@ -13,15 +13,20 @@
 
 package io.reactivex.observable;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 
+import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Test;
 
-import io.reactivex.*;
+import io.reactivex.Observable;
 import io.reactivex.ObservableOperator;
-import io.reactivex.observers.DefaultObserver;
+import io.reactivex.Observer;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.Consumer;
+import io.reactivex.observers.*;
+import io.reactivex.subjects.PublishSubject;
 
 public class ObservableSubscriberTest {
     @Test
@@ -118,4 +123,59 @@ public void onNext(Integer t) {
 
         assertEquals(1, c.get());
     }
+    
+    @Test
+    public void subscribeConsumerConsumer() {
+        final List<Integer> list = new ArrayList<Integer>();
+        
+        Observable.just(1).subscribe(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        }, new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) throws Exception {
+                list.add(100);
+            }
+        });
+        
+        assertEquals(Arrays.asList(1), list);
+    }
+
+    @Test
+    public void subscribeConsumerConsumerWithError() {
+        final List<Integer> list = new ArrayList<Integer>();
+        
+        Observable.<Integer>error(new TestException()).subscribe(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        }, new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) throws Exception {
+                list.add(100);
+            }
+        });
+        
+        assertEquals(Arrays.asList(100), list);
+    }
+
+    @Test
+    public void methodTestCancelled() {
+        PublishSubject<Integer> ps = PublishSubject.create();
+        
+        ps.test(true);
+        
+        assertFalse(ps.hasObservers());
+    }
+    
+    @Test
+    public void safeSubscriberAlreadySafe() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        Observable.just(1).safeSubscribe(new SafeObserver<Integer>(ts));
+        
+        ts.assertResult(1);
+    }
 }
diff --git a/src/test/java/io/reactivex/observable/ObservableThrottleWithTimeoutTests.java b/src/test/java/io/reactivex/observable/ObservableThrottleWithTimeoutTests.java
index 969150105e..768bab316f 100644
--- a/src/test/java/io/reactivex/observable/ObservableThrottleWithTimeoutTests.java
+++ b/src/test/java/io/reactivex/observable/ObservableThrottleWithTimeoutTests.java
@@ -58,4 +58,13 @@ public void testThrottle() {
         inOrder.verify(observer).onComplete();
         inOrder.verifyNoMoreInteractions();
     }
+
+    @Test
+    public void throttleFirstDefaultScheduler() {
+        Observable.just(1).throttleWithTimeout(100, TimeUnit.MILLISECONDS)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/observable/ObservableZipTests.java b/src/test/java/io/reactivex/observable/ObservableZipTests.java
index 57c6271b27..fea218f038 100644
--- a/src/test/java/io/reactivex/observable/ObservableZipTests.java
+++ b/src/test/java/io/reactivex/observable/ObservableZipTests.java
@@ -123,4 +123,31 @@ public void accept(ExtendedResult t1) {
             System.out.println("Result: " + t1);
         }
     };
+    
+    @Test
+    public void zipWithDelayError() {
+        Observable.just(1)
+        .zipWith(Observable.just(2), new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }, true)
+        .test()
+        .assertResult(3);
+    }
+
+    @Test
+    public void zipWithDelayErrorBufferSize() {
+        Observable.just(1)
+        .zipWith(Observable.just(2), new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer a, Integer b) throws Exception {
+                return a + b;
+            }
+        }, true, 16)
+        .test()
+        .assertResult(3);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/CachedThreadSchedulerTest.java b/src/test/java/io/reactivex/schedulers/CachedThreadSchedulerTest.java
index c659bb4707..033c099b2a 100644
--- a/src/test/java/io/reactivex/schedulers/CachedThreadSchedulerTest.java
+++ b/src/test/java/io/reactivex/schedulers/CachedThreadSchedulerTest.java
@@ -57,12 +57,12 @@ public void accept(String t) {
     @Test
     @Ignore("Unhandled errors are no longer thrown")
     public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
     }
 
     @Test
     public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
     }
     
     @Test(timeout = 60000)
diff --git a/src/test/java/io/reactivex/schedulers/ComputationSchedulerTests.java b/src/test/java/io/reactivex/schedulers/ComputationSchedulerTests.java
index 3cd012569c..f0664af030 100644
--- a/src/test/java/io/reactivex/schedulers/ComputationSchedulerTests.java
+++ b/src/test/java/io/reactivex/schedulers/ComputationSchedulerTests.java
@@ -139,12 +139,12 @@ public void accept(String t) {
     @Test
     @Ignore("Unhandled errors are no longer thrown")
     public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
     }
 
     @Test
     public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
     }
     
     @Test(timeout = 60000)
diff --git a/src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java b/src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java
index 64bbec890a..b1b0903d90 100644
--- a/src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java
+++ b/src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java
@@ -47,12 +47,12 @@ protected Scheduler getScheduler() {
     @Test
     @Ignore("Unhandled errors are no longer thrown")
     public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
     }
 
     @Test
     public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
     }
     
     public static void testCancelledRetention(Scheduler.Worker w, boolean periodic) throws InterruptedException {
@@ -109,8 +109,18 @@ public void run() {
         int t = (int)(n * Math.log(n) / 100) + SchedulerPoolFactory.PURGE_PERIOD_SECONDS * 1000;
         while (t > 0) {
             System.out.printf("  >> Waiting for purge: %.2f s remaining%n", t / 1000d);
+
+            System.gc();
+            
             Thread.sleep(1000);
+            
             t -= 1000;
+            memHeap = memoryMXBean.getHeapMemoryUsage();
+            long finish = memHeap.getUsed();
+            System.out.printf("After: %.3f MB%n", finish / 1024.0 / 1024.0);
+            if (finish <= initial * 5) {
+                break;
+            }
         }
         
         System.out.println("Second GC");
diff --git a/src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java b/src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java
index d0964d147f..0688f6adef 100644
--- a/src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java
+++ b/src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java
@@ -27,12 +27,12 @@ protected Scheduler getScheduler() {
     @Test
     @Ignore("Unhandled errors are no longer thrown")
     public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
     }
 
     @Test
     public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
-        SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
+        SchedulerTestHelper.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
     }
     
     // FIXME no longer testable due to internal changes
diff --git a/src/test/java/io/reactivex/schedulers/SchedulerTest.java b/src/test/java/io/reactivex/schedulers/SchedulerTest.java
new file mode 100644
index 0000000000..ab6b5a61f7
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/SchedulerTest.java
@@ -0,0 +1,242 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import static org.junit.Assert.*;
+
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.Scheduler.Worker;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.disposables.SequentialDisposable;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.plugins.RxJavaPlugins;
+
+public class SchedulerTest {
+
+    @Test
+    public void defaultPeriodicTask() {
+        final int[] count = { 0 };
+        
+        TestScheduler scheduler = new TestScheduler();
+        
+        Disposable d = scheduler.schedulePeriodicallyDirect(new Runnable() {
+            @Override
+            public void run() {
+                count[0]++;
+            }
+        }, 100, 100, TimeUnit.MILLISECONDS);
+        
+        assertEquals(0, count[0]);
+        assertFalse(d.isDisposed());
+        
+        scheduler.advanceTimeBy(200, TimeUnit.MILLISECONDS);
+        
+        assertEquals(2, count[0]);
+        
+        d.dispose();
+        
+        assertTrue(d.isDisposed());
+        
+        scheduler.advanceTimeBy(200, TimeUnit.MILLISECONDS);
+        
+        assertEquals(2, count[0]);
+    }
+    
+    @Test(expected = TestException.class)
+    public void periodicDirectThrows() {
+        TestScheduler scheduler = new TestScheduler();
+        
+        scheduler.schedulePeriodicallyDirect(new Runnable() {
+            @Override
+            public void run() {
+                throw new TestException();
+            }
+        }, 100, 100, TimeUnit.MILLISECONDS);
+    
+        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);
+    }
+
+    @Test
+    public void disposePeriodicDirect() {
+        final int[] count = { 0 };
+        
+        TestScheduler scheduler = new TestScheduler();
+        
+        Disposable d = scheduler.schedulePeriodicallyDirect(new Runnable() {
+            @Override
+            public void run() {
+                count[0]++;
+            }
+        }, 100, 100, TimeUnit.MILLISECONDS);
+
+        d.dispose();
+        
+        assertEquals(0, count[0]);
+        assertTrue(d.isDisposed());
+        
+        scheduler.advanceTimeBy(200, TimeUnit.MILLISECONDS);
+
+        assertEquals(0, count[0]);
+        assertTrue(d.isDisposed());
+    }
+    
+    @Test
+    public void scheduleDirect() {
+        final int[] count = { 0 };
+        
+        TestScheduler scheduler = new TestScheduler();
+        
+        scheduler.scheduleDirect(new Runnable() {
+            @Override
+            public void run() {
+                count[0]++;
+            }
+        }, 100, TimeUnit.MILLISECONDS);
+
+        assertEquals(0, count[0]);
+        
+        scheduler.advanceTimeBy(200, TimeUnit.MILLISECONDS);
+
+        assertEquals(1, count[0]);
+    }
+
+    @Test
+    public void disposeSelfPeriodicDirect() {
+        final int[] count = { 0 };
+        
+        TestScheduler scheduler = new TestScheduler();
+        
+        final SequentialDisposable sd = new SequentialDisposable();
+        
+        Disposable d = scheduler.schedulePeriodicallyDirect(new Runnable() {
+            @Override
+            public void run() {
+                count[0]++;
+                sd.dispose();
+            }
+        }, 100, 100, TimeUnit.MILLISECONDS);
+
+        sd.set(d);
+        
+        assertEquals(0, count[0]);
+        assertFalse(d.isDisposed());
+        
+        scheduler.advanceTimeBy(400, TimeUnit.MILLISECONDS);
+
+        assertEquals(1, count[0]);
+        assertTrue(d.isDisposed());
+    }
+
+    @Test
+    public void disposeSelfPeriodic() {
+        final int[] count = { 0 };
+        
+        TestScheduler scheduler = new TestScheduler();
+        
+        Worker worker = scheduler.createWorker();
+        
+        try {
+            final SequentialDisposable sd = new SequentialDisposable();
+            
+            Disposable d = worker.schedulePeriodically(new Runnable() {
+                @Override
+                public void run() {
+                    count[0]++;
+                    sd.dispose();
+                }
+            }, 100, 100, TimeUnit.MILLISECONDS);
+    
+            sd.set(d);
+            
+            assertEquals(0, count[0]);
+            assertFalse(d.isDisposed());
+            
+            scheduler.advanceTimeBy(400, TimeUnit.MILLISECONDS);
+    
+            assertEquals(1, count[0]);
+            assertTrue(d.isDisposed());
+        } finally {
+            worker.dispose();
+        }
+    }
+
+    @Test
+    public void periodicDirectTaskRace() {
+        final TestScheduler scheduler = new TestScheduler();
+        
+        for (int i = 0; i < 100; i++) {
+            final Disposable d = scheduler.schedulePeriodicallyDirect(Functions.EMPTY_RUNNABLE, 1, 1, TimeUnit.MILLISECONDS);
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    d.dispose();
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.io());
+        }
+        
+    }
+
+
+    @Test
+    public void periodicDirectTaskRaceIO() throws Exception{
+        final Scheduler scheduler = Schedulers.io();
+        
+        for (int i = 0; i < 100; i++) {
+            final Disposable d = scheduler.schedulePeriodicallyDirect(
+                    Functions.EMPTY_RUNNABLE, 0, 0, TimeUnit.MILLISECONDS);
+            
+            Thread.sleep(1);
+            
+            d.dispose();
+        }
+        
+    }
+    
+    @Test
+    public void scheduleDirectThrows() throws Exception {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        try {
+            Schedulers.io().scheduleDirect(new Runnable() {
+                @Override
+                public void run() {
+                    throw new TestException();
+                }
+            });
+            
+            Thread.sleep(250);
+            
+            assertEquals(1, list.size());
+            TestHelper.assertError(list, 0, TestException.class, null);
+            
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/schedulers/SchedulerTests.java b/src/test/java/io/reactivex/schedulers/SchedulerTestHelper.java
similarity index 98%
rename from src/test/java/io/reactivex/schedulers/SchedulerTests.java
rename to src/test/java/io/reactivex/schedulers/SchedulerTestHelper.java
index 65a5bc520a..d327be6b74 100644
--- a/src/test/java/io/reactivex/schedulers/SchedulerTests.java
+++ b/src/test/java/io/reactivex/schedulers/SchedulerTestHelper.java
@@ -20,8 +20,8 @@
 import io.reactivex.*;
 import io.reactivex.subscribers.DefaultSubscriber;
 
-final class SchedulerTests {
-    private SchedulerTests() {
+final class SchedulerTestHelper {
+    private SchedulerTestHelper() {
         // No instances.
     }
 
diff --git a/src/test/java/io/reactivex/schedulers/SchedulerWorkerTest.java b/src/test/java/io/reactivex/schedulers/SchedulerWorkerTest.java
index 98bbeeb494..dbd779d4f5 100644
--- a/src/test/java/io/reactivex/schedulers/SchedulerWorkerTest.java
+++ b/src/test/java/io/reactivex/schedulers/SchedulerWorkerTest.java
@@ -13,7 +13,7 @@
 
 package io.reactivex.schedulers;
 
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 import java.util.*;
 import java.util.concurrent.TimeUnit;
@@ -83,7 +83,7 @@ public void run() {
 
             Thread.sleep(150);
             
-            s.drift = -1000 - TimeUnit.NANOSECONDS.toMillis(Scheduler.clockDriftTolerance());
+            s.drift = -TimeUnit.SECONDS.toNanos(1) - Scheduler.clockDriftTolerance();
             
             Thread.sleep(400);
             
@@ -125,7 +125,7 @@ public void run() {
 
             Thread.sleep(150);
             
-            s.drift = 1000 + TimeUnit.NANOSECONDS.toMillis(Scheduler.clockDriftTolerance());
+            s.drift = TimeUnit.SECONDS.toNanos(1) + Scheduler.clockDriftTolerance();
             
             Thread.sleep(400);
             
diff --git a/src/test/java/io/reactivex/single/SingleNullTests.java b/src/test/java/io/reactivex/single/SingleNullTests.java
index 18c2e70ef5..9626bf83c4 100644
--- a/src/test/java/io/reactivex/single/SingleNullTests.java
+++ b/src/test/java/io/reactivex/single/SingleNullTests.java
@@ -688,7 +688,7 @@ public Integer apply(Throwable t) throws Exception {
     
     @Test(expected = NullPointerException.class)
     public void onErrorReturnValueNull() {
-        error.onErrorReturnValue(null);
+        error.onErrorReturnItem(null);
     }
     
     @Test(expected = NullPointerException.class)
@@ -756,11 +756,6 @@ public void retryWhenFunctionReturnsNull() {
         }).blockingGet();
     }
     
-    @Test(expected = NullPointerException.class)
-    public void safeSubscribeNull() {
-        just1.safeSubscribe(null);
-    }
-    
     @Test(expected = NullPointerException.class)
     public void subscribeBiConsumerNull() {
         just1.subscribe((BiConsumer<Integer, Throwable>)null);
diff --git a/src/test/java/io/reactivex/single/SingleSubscribeTest.java b/src/test/java/io/reactivex/single/SingleSubscribeTest.java
index 352a0e4536..e489dd0020 100644
--- a/src/test/java/io/reactivex/single/SingleSubscribeTest.java
+++ b/src/test/java/io/reactivex/single/SingleSubscribeTest.java
@@ -17,7 +17,7 @@
 
 import org.junit.Test;
 
-import io.reactivex.Single;
+import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 
@@ -70,5 +70,21 @@ public void accept(Object v, Throwable e) throws Exception {
         assertNull(value[0]);
         assertEquals(ex, value[1]);
     }
+    
+    @Test
+    public void subscribeThrows() {
+        try {
+            new Single<Integer>() {
+                @Override
+                protected void subscribeActual(SingleObserver<? super Integer> observer) {
+                    throw new IllegalArgumentException();
+                }
+            }.test();
+        } catch (NullPointerException ex) {
+            if (!(ex.getCause() instanceof IllegalArgumentException)) {
+                fail(ex.toString() + ": should have thrown NPE(IAE)");
+            }
+        }
+    }
 
 }
