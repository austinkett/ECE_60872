diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java
index e3802eaa18..837622d84d 100644
--- a/src/main/java/io/reactivex/Flowable.java
+++ b/src/main/java/io/reactivex/Flowable.java
@@ -110,7 +110,7 @@ public static int bufferSize() {
     public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<Object[], ? extends R> combiner, int bufferSize) {
         Objects.requireNonNull(sources, "sources is null");
         Objects.requireNonNull(combiner, "combiner is null");
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         if (sources.length == 0) {
             return empty();
         }
@@ -128,7 +128,7 @@ public static int bufferSize() {
     public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources, Function<Object[], ? extends R> combiner, int bufferSize) {
         Objects.requireNonNull(sources, "sources is null");
         Objects.requireNonNull(combiner, "combiner is null");
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         return new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false);
     }
 
@@ -149,7 +149,7 @@ public static int bufferSize() {
     public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources, Function<Object[], ? extends R> combiner, int bufferSize) {
         Objects.requireNonNull(sources, "sources is null");
         Objects.requireNonNull(combiner, "combiner is null");
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         if (sources.length == 0) {
             return empty();
         }
@@ -167,7 +167,7 @@ public static int bufferSize() {
     public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources, Function<Object[], ? extends R> combiner, int bufferSize) {
         Objects.requireNonNull(sources, "sources is null");
         Objects.requireNonNull(combiner, "combiner is null");
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         return new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, true);
     }
 
@@ -447,7 +447,7 @@ public static int bufferSize() {
     public static <T> Flowable<T> concatEager(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int prefetch) {
         return new FlowableConcatMapEager(new FlowableFromIterable(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE);
     }
-
+    
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Flowable<T> concatDelayError(Iterable<? extends Publisher<? extends T>> sources) {
@@ -1037,7 +1037,7 @@ public S apply(S s, Subscriber<T> o) {
     @SchedulerSupport(SchedulerSupport.NONE)
     public static Flowable<Integer> range(int start, int count) {
         if (count < 0) {
-            throw new IllegalArgumentException("count >= required but it was " + count);
+            throw new IllegalArgumentException("count >= 0 required but it was " + count);
         } else
         if (count == 0) {
             return empty();
@@ -1069,7 +1069,7 @@ public S apply(S s, Subscriber<T> o) {
         Objects.requireNonNull(p1, "p1 is null");
         Objects.requireNonNull(p2, "p2 is null");
         Objects.requireNonNull(isEqual, "isEqual is null");
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         return new FlowableSequenceEqual<T>(p1, p2, isEqual, bufferSize);
     }
 
@@ -1126,9 +1126,9 @@ public S apply(S s, Subscriber<T> o) {
         return new FlowableUsing<T, D>(resourceSupplier, sourceSupplier, disposer, eager);
     }
 
-    private static void validateBufferSize(int bufferSize) {
+    private static void validateBufferSize(int bufferSize, String paramName) {
         if (bufferSize <= 0) {
-            throw new IllegalArgumentException("bufferSize > 0 required but it was " + bufferSize);
+            throw new IllegalArgumentException(paramName + " > 0 required but it was " + bufferSize);
         }
     }
 
@@ -1260,7 +1260,7 @@ private static void validateBufferSize(int bufferSize) {
             return empty();
         }
         Objects.requireNonNull(zipper, "zipper is null");
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         return new FlowableZip<T, R>(sources, null, zipper, bufferSize, delayError);
     }
 
@@ -1271,7 +1271,7 @@ private static void validateBufferSize(int bufferSize) {
             Iterable<? extends Publisher<? extends T>> sources) {
         Objects.requireNonNull(zipper, "zipper is null");
         Objects.requireNonNull(sources, "sources is null");
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         return new FlowableZip<T, R>(null, sources, zipper, bufferSize, delayError);
     }
 
@@ -1344,7 +1344,6 @@ public void subscribe(Subscriber<? super T> s) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <U extends Collection<? super T>> Flowable<U> buffer(int count, int skip, Supplier<U> bufferSupplier) {
-        Objects.requireNonNull(bufferSupplier, "bufferSupplier is null");
         return new FlowableBuffer<T, U>(this, count, skip, bufferSupplier);
     }
     
@@ -1622,6 +1621,10 @@ public U get() {
 
     public final <R> Flowable<R> concatMapEager(Function<? super T, ? extends Publisher<? extends R>> mapper, 
             int maxConcurrency, int prefetch) {
+        if (maxConcurrency <= 0) {
+            throw new IllegalArgumentException("maxConcurrency > 0 required but it was " + maxConcurrency);
+        }
+        validateBufferSize(prefetch, "prefetch");
         return new FlowableConcatMapEager<T, R>(this, mapper, maxConcurrency, prefetch, ErrorMode.IMMEDIATE);
     }
 
@@ -2063,7 +2066,7 @@ public void accept(Throwable e) {
 
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> finallyDo(Runnable onFinally) {
+    public final Flowable<T> doAfterTerminate(Runnable onFinally) {
         return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(), Functions.emptyRunnable(), onFinally);
     }
 
@@ -2113,7 +2116,7 @@ public void accept(Throwable e) {
         if (maxConcurrency <= 0) {
             throw new IllegalArgumentException("maxConcurrency > 0 required but it was " + maxConcurrency);
         }
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         return new FlowableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize);
     }
 
@@ -2308,7 +2311,7 @@ public void accept(Subscription s) {
             boolean delayError, int bufferSize) {
         Objects.requireNonNull(keySelector, "keySelector is null");
         Objects.requireNonNull(valueSelector, "valueSelector is null");
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
 
         return new FlowableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError);
     }
@@ -2418,7 +2421,7 @@ public boolean test(T v) {
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public final Flowable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {
         Objects.requireNonNull(scheduler, "scheduler is null");
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         return new FlowableObserveOn<T>(this, scheduler, delayError, bufferSize);
     }
 
@@ -2461,7 +2464,7 @@ public boolean test(T c) {
     @BackpressureSupport(BackpressureKind.SPECIAL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Flowable<T> onBackpressureBuffer(int bufferSize, boolean delayError, boolean unbounded) {
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         return new FlowableOnBackpressureBuffer<T>(this, bufferSize, unbounded, delayError, Functions.emptyRunnable());
     }
 
@@ -2569,7 +2572,7 @@ public T apply(Throwable e) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <R> Flowable<R> publish(Function<? super Flowable<T>, ? extends Publisher<R>> selector, int bufferSize) {
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         Objects.requireNonNull(selector, "selector is null");
         return FlowablePublish.create(this, selector, bufferSize);
     }
@@ -2577,7 +2580,7 @@ public T apply(Throwable e) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final ConnectableFlowable<T> publish(int bufferSize) {
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         return FlowablePublish.create(this, bufferSize);
     }
 
@@ -3041,7 +3044,7 @@ public R get() {
     public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {
         Objects.requireNonNull(unit, "unit is null");
         Objects.requireNonNull(scheduler, "scheduler is null");
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
      // the internal buffer holds pairs of (timestamp, value) so double the default buffer size
         int s = bufferSize << 1; 
         return new FlowableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError);
@@ -3218,7 +3221,7 @@ public final void subscribe(Subscriber<? super T> s) {
             }
             return ScalarXMap.scalarXMap(v, mapper);
         }
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         return new FlowableSwitchMap<T, R>(this, mapper, bufferSize);
     }
 
@@ -3288,7 +3291,7 @@ public final void subscribe(Subscriber<? super T> s) {
     public final Flowable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {
         Objects.requireNonNull(unit, "unit is null");
         Objects.requireNonNull(scheduler, "scheduler is null");
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         if (count < 0) {
             throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);
         }
@@ -3823,7 +3826,7 @@ public final void unsafeSubscribe(Subscriber<? super T> s) {
         if (count <= 0) {
             throw new IllegalArgumentException("count > 0 required but it was " + count);
         }
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         return new FlowableWindow<T>(this, count, skip, bufferSize);
     }
     
@@ -3842,7 +3845,7 @@ public final void unsafeSubscribe(Subscriber<? super T> s) {
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.CUSTOM)
     public final Flowable<Flowable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         Objects.requireNonNull(scheduler, "scheduler is null");
         Objects.requireNonNull(unit, "unit is null");
         return new FlowableWindowTimed<T>(this, timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false);
@@ -3894,7 +3897,7 @@ public final void unsafeSubscribe(Subscriber<? super T> s) {
     public final Flowable<Flowable<T>> window(
             long timespan, TimeUnit unit, Scheduler scheduler, 
             long count, boolean restart, int bufferSize) {
-        validateBufferSize(bufferSize);
+        validateBufferSize(bufferSize, "bufferSize");
         Objects.requireNonNull(scheduler, "scheduler is null");
         Objects.requireNonNull(unit, "unit is null");
         if (count <= 0) {
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java
index 890a939605..72429d3bea 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java
@@ -14,257 +14,449 @@
 package io.reactivex.internal.operators.flowable;
 
 import java.util.*;
-import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.*;
 
 import org.reactivestreams.*;
 
-import io.reactivex.Flowable;
-import io.reactivex.functions.Supplier;
-import io.reactivex.internal.subscriptions.*;
-import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Objects;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
+import io.reactivex.internal.util.*;
+import io.reactivex.plugins.RxJavaPlugins;
+
+public final class FlowableBuffer<T, C extends Collection<? super T>> extends FlowableSource<T, C> {
+    final int size;
 
-public final class FlowableBuffer<T, U extends Collection<? super T>> extends Flowable<U> {
-    final Publisher<T> source;
-    final int count;
     final int skip;
-    final Supplier<U> bufferSupplier;
-    
-    public FlowableBuffer(Publisher<T> source, int count, int skip, Supplier<U> bufferSupplier) {
-        this.source = source;
-        this.count = count;
+
+    final Supplier<C> bufferSupplier;
+
+    public FlowableBuffer(Publisher<T> source, int size, Supplier<C> bufferSupplier) {
+        this(source, size, size, bufferSupplier);
+    }
+
+    public FlowableBuffer(Publisher<T> source, int size, int skip, Supplier<C> bufferSupplier) {
+        super(source);
+        if (size <= 0) {
+            throw new IllegalArgumentException("size > 0 required but it was " + size);
+        }
+
+        if (skip <= 0) {
+            throw new IllegalArgumentException("skip > 0 required but it was " + size);
+        }
+
+        this.size = size;
         this.skip = skip;
-        this.bufferSupplier = bufferSupplier;
+        this.bufferSupplier = Objects.requireNonNull(bufferSupplier, "bufferSupplier");
     }
 
     @Override
-    protected void subscribeActual(Subscriber<? super U> s) {
-        if (skip == count) {
-            BufferExactSubscriber<T, U> bes = new BufferExactSubscriber<T, U>(s, count, bufferSupplier);
-            if (bes.createBuffer()) {
-                source.subscribe(bes);
-            }
+    public void subscribeActual(Subscriber<? super C> s) {
+        if (size == skip) {
+            source.subscribe(new PublisherBufferExactSubscriber<T, C>(s, size, bufferSupplier));
+        } else if (skip > size) {
+            source.subscribe(new PublisherBufferSkipSubscriber<T, C>(s, size, skip, bufferSupplier));
         } else {
-            source.subscribe(new BufferSkipSubscriber<T, U>(s, count, skip, bufferSupplier));
+            source.subscribe(new PublisherBufferOverlappingSubscriber<T, C>(s, size, skip, bufferSupplier));
         }
     }
-    
-    static final class BufferExactSubscriber<T, U extends Collection<? super T>> implements Subscriber<T>, Subscription {
-        final Subscriber<? super U> actual;
-        final int count;
-        final Supplier<U> bufferSupplier;
-        U buffer;
-        
-        int size;
-        
+
+    static final class PublisherBufferExactSubscriber<T, C extends Collection<? super T>>
+      implements Subscriber<T>, Subscription {
+
+        final Subscriber<? super C> actual;
+
+        final Supplier<C> bufferSupplier;
+
+        final int size;
+
+        C buffer;
+
         Subscription s;
 
-        public BufferExactSubscriber(Subscriber<? super U> actual, int count, Supplier<U> bufferSupplier) {
+        boolean done;
+
+        public PublisherBufferExactSubscriber(Subscriber<? super C> actual, int size, Supplier<C> bufferSupplier) {
             this.actual = actual;
-            this.count = count;
+            this.size = size;
             this.bufferSupplier = bufferSupplier;
         }
-        
-        boolean createBuffer() {
-            U b;
-            try {
-                b = bufferSupplier.get();
-            } catch (Throwable t) {
-                buffer = null;
-                if (s == null) {
-                    EmptySubscription.error(t, actual);
-                } else {
-                    s.cancel();
-                    actual.onError(t);
-                }
-                return false;
-            }
-            
-            buffer = b;
-            if (b == null) {
-                Throwable t = new NullPointerException("Empty buffer supplied");
-                if (s == null) {
-                    EmptySubscription.error(t, actual);
-                } else {
-                    s.cancel();
-                    actual.onError(t);
-                }
-                return false;
+
+        @Override
+        public void request(long n) {
+            if (SubscriptionHelper.validate(n)) {
+                s.request(BackpressureHelper.multiplyCap(n, size));
             }
-            
-            return true;
         }
-        
+
+        @Override
+        public void cancel() {
+            s.cancel();
+        }
+
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
+
                 actual.onSubscribe(this);
             }
         }
-        
+
         @Override
         public void onNext(T t) {
-            U b = buffer;
-            if (b == null) {
+            if (done) {
                 return;
             }
-            
+
+            C b = buffer;
+            if (b == null) {
+
+                try {
+                    b = bufferSupplier.get();
+                } catch (Throwable e) {
+                    Exceptions.throwIfFatal(e);
+                    cancel();
+                    onError(e);
+                    return;
+                }
+
+                if (b == null) {
+                    cancel();
+
+                    onError(new NullPointerException("The bufferSupplier returned a null buffer"));
+                    return;
+                }
+                buffer = b;
+            }
+
             b.add(t);
-            
-            if (++size >= count) {
+
+            if (b.size() == size) {
+                buffer = null;
                 actual.onNext(b);
-                
-                size = 0;
-                createBuffer();
             }
         }
-        
+
         @Override
         public void onError(Throwable t) {
-            buffer = null;
+            if (done) {
+                RxJavaPlugins.onError(t);
+                return;
+            }
+            done = true;
             actual.onError(t);
         }
-        
+
         @Override
         public void onComplete() {
-            U b = buffer;
-            buffer = null;
+            if (done) {
+                return;
+            }
+            done = true;
+
+            C b = buffer;
+
             if (b != null && !b.isEmpty()) {
                 actual.onNext(b);
             }
             actual.onComplete();
         }
-        
-        @Override
-        public void request(long n) {
-            if (SubscriptionHelper.validate(n)) {
-                long m = BackpressureHelper.multiplyCap(n, count);
-                s.request(m);
-            }
-        }
-        
-        @Override
-        public void cancel() {
-            s.cancel();
-        }
     }
-    
-    static final class BufferSkipSubscriber<T, U extends Collection<? super T>> extends AtomicBoolean implements Subscriber<T>, Subscription {
+
+    static final class PublisherBufferSkipSubscriber<T, C extends Collection<? super T>>
+    extends AtomicInteger
+    implements Subscriber<T>, Subscription {
+
         /** */
-        private static final long serialVersionUID = -8223395059921494546L;
-        final Subscriber<? super U> actual;
-        final int count;
+        private static final long serialVersionUID = -5616169793639412593L;
+
+        final Subscriber<? super C> actual;
+
+        final Supplier<C> bufferSupplier;
+
+        final int size;
+
         final int skip;
-        final Supplier<U> bufferSupplier;
+
+        C buffer;
 
         Subscription s;
-        
-        final ArrayDeque<U> buffers;
-        
+
+        boolean done;
+
         long index;
 
-        public BufferSkipSubscriber(Subscriber<? super U> actual, int count, int skip, Supplier<U> bufferSupplier) {
+        public PublisherBufferSkipSubscriber(Subscriber<? super C> actual, int size, int skip,
+                                             Supplier<C> bufferSupplier) {
             this.actual = actual;
-            this.count = count;
+            this.size = size;
             this.skip = skip;
             this.bufferSupplier = bufferSupplier;
-            this.buffers = new ArrayDeque<U>();
+        }
+
+        @Override
+        public void request(long n) {
+            if (get() == 0 && compareAndSet(0, 1)) {
+                // n full buffers
+                long u = BackpressureHelper.multiplyCap(n, size);
+                // + (n - 1) gaps
+                long v = BackpressureHelper.multiplyCap(skip - size, n - 1);
+
+                s.request(BackpressureHelper.addCap(u, v));
+            } else {
+                // n full buffer + gap
+                s.request(BackpressureHelper.multiplyCap(skip, n));
+            }
+        }
+
+        @Override
+        public void cancel() {
+            s.cancel();
         }
 
         @Override
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
+
                 actual.onSubscribe(this);
             }
         }
 
         @Override
         public void onNext(T t) {
-            if (index++ % skip == 0) {
-                U b;
-                
+            if (done) {
+                return;
+            }
+
+            C b = buffer;
+
+            long i = index;
+
+            if (i % skip == 0L) {
                 try {
                     b = bufferSupplier.get();
                 } catch (Throwable e) {
-                    buffers.clear();
-                    s.cancel();
-                    actual.onError(e);
+                    cancel();
+
+                    onError(e);
                     return;
                 }
-                
+
                 if (b == null) {
-                    buffers.clear();
-                    s.cancel();
-                    actual.onError(new NullPointerException());
+                    cancel();
+
+                    onError(new NullPointerException("The bufferSupplier returned a null buffer"));
                     return;
                 }
-                
-                buffers.offer(b);
+
+                buffer = b;
             }
-            
-            Iterator<U> it = buffers.iterator();
-            while (it.hasNext()) {
-                U b = it.next();
+
+            if (b != null) {
                 b.add(t);
-                if (count <= b.size()) {
-                    it.remove();
-                    
+                if (b.size() == size) {
+                    buffer = null;
                     actual.onNext(b);
                 }
             }
+
+            index = i + 1;
         }
-        
+
         @Override
         public void onError(Throwable t) {
-            buffers.clear();
+            if (done) {
+                RxJavaPlugins.onError(t);
+                return;
+            }
+
+            done = true;
+            buffer = null;
+
             actual.onError(t);
         }
-        
+
         @Override
         public void onComplete() {
-            while (!buffers.isEmpty()) {
-                actual.onNext(buffers.poll());
+            if (done) {
+                return;
+            }
+
+            done = true;
+            C b = buffer;
+            buffer = null;
+
+            if (b != null) {
+                actual.onNext(b);
             }
+
             actual.onComplete();
         }
+    }
+
+
+    static final class PublisherBufferOverlappingSubscriber<T, C extends Collection<? super T>>
+    extends AtomicLong
+    implements Subscriber<T>, Subscription, BooleanSupplier {
+        /** */
+        private static final long serialVersionUID = -7370244972039324525L;
+
+        final Subscriber<? super C> actual;
+
+        final Supplier<C> bufferSupplier;
+
+        final int size;
+
+        final int skip;
+
+        final ArrayDeque<C> buffers;
+
+        final AtomicBoolean once;
+
+        Subscription s;
+
+        boolean done;
+
+        long index;
+
+        volatile boolean cancelled;
+
+        long produced;
         
+        public PublisherBufferOverlappingSubscriber(Subscriber<? super C> actual, int size, int skip,
+                                                    Supplier<C> bufferSupplier) {
+            this.actual = actual;
+            this.size = size;
+            this.skip = skip;
+            this.bufferSupplier = bufferSupplier;
+            this.once = new AtomicBoolean();
+            this.buffers = new ArrayDeque<C>();
+        }
+
+        @Override
+        public boolean getAsBoolean() {
+            return cancelled;
+        }
+
         @Override
         public void request(long n) {
+
             if (!SubscriptionHelper.validate(n)) {
                 return;
             }
-            // requesting the first set of buffers must happen only once
-            if (!get() && compareAndSet(false, true)) {
-                
-                if (count < skip) {
-                    // don't request the first gap after n buffers
-                    long m = BackpressureHelper.multiplyCap(n, count);
-                    s.request(m);
-                } else {
-                    // request 1 full and n - 1 skip gaps
-                    long m = BackpressureHelper.multiplyCap(n - 1, skip);
-                    long k = BackpressureHelper.addCap(count, m);
-                    s.request(k);
-                }
-                
+
+            if (QueueDrainHelper.postCompleteRequest(n, actual, buffers, this, this)) {
+                return;
+            }
+
+            if (!once.get() && once.compareAndSet(false, true)) {
+                // (n - 1) skips
+                long u = BackpressureHelper.multiplyCap(skip, n - 1);
+
+                // + 1 full buffer
+                long r = BackpressureHelper.addCap(size, u);
+                s.request(r);
             } else {
-                
-                if (count < skip) {
-                    // since this isn't the first, request n buffers and n gaps
-                    long m = BackpressureHelper.multiplyCap(n, count + skip);
-                    s.request(m);
-                } else {
-                    // request the remaining n * skip
-                    long m = BackpressureHelper.multiplyCap(n, skip);
-                    s.request(m);
-                }
+                // n skips
+                long r = BackpressureHelper.multiplyCap(skip, n);
+                s.request(r);
             }
         }
-        
+
         @Override
         public void cancel() {
+            cancelled = true;
             s.cancel();
         }
+
+        @Override
+        public void onSubscribe(Subscription s) {
+            if (SubscriptionHelper.validate(this.s, s)) {
+                this.s = s;
+
+                actual.onSubscribe(this);
+            }
+        }
+
+        @Override
+        public void onNext(T t) {
+            if (done) {
+                return;
+            }
+
+            ArrayDeque<C> bs = buffers;
+
+            long i = index;
+
+            if (i % skip == 0L) {
+                C b;
+
+                try {
+                    b = bufferSupplier.get();
+                } catch (Throwable e) {
+                    Exceptions.throwIfFatal(e);
+                    cancel();
+                    onError(e);
+                    return;
+                }
+
+                if (b == null) {
+                    cancel();
+
+                    onError(new NullPointerException("The bufferSupplier returned a null buffer"));
+                    return;
+                }
+
+                bs.offer(b);
+            }
+
+            C b = bs.peek();
+
+            if (b != null && b.size() + 1 == size) {
+                bs.poll();
+
+                b.add(t);
+
+                produced++;
+                
+                actual.onNext(b);
+            }
+
+            for (C b0 : bs) {
+                b0.add(t);
+            }
+
+            index = i + 1;
+        }
+
+        @Override
+        public void onError(Throwable t) {
+            if (done) {
+                RxJavaPlugins.onError(t);
+                return;
+            }
+
+            done = true;
+            buffers.clear();
+
+            actual.onError(t);
+        }
+
+        @Override
+        public void onComplete() {
+            if (done) {
+                return;
+            }
+
+            done = true;
+
+            long p = produced;
+            if (p != 0L) {
+                BackpressureHelper.produced(this, p);
+            }
+            QueueDrainHelper.postComplete(actual, buffers, this, this);
+        }
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/single/SingleFromPublisher.java b/src/main/java/io/reactivex/internal/operators/single/SingleFromPublisher.java
index 6e889653e6..8f3af1dacd 100644
--- a/src/main/java/io/reactivex/internal/operators/single/SingleFromPublisher.java
+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFromPublisher.java
@@ -18,7 +18,9 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.disposables.Disposables;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class SingleFromPublisher<T> extends Single<T> {
 
@@ -30,38 +32,85 @@ public SingleFromPublisher(Publisher<? extends T> publisher) {
 
     @Override
     protected void subscribeActual(final SingleSubscriber<? super T> s) {
+        publisher.subscribe(new ToSingleSubscriber<T>(s));
+    }
+    
+    static final class ToSingleSubscriber<T> implements Subscriber<T>, Disposable {
+        final SingleSubscriber<? super T> actual;
+        
+        Subscription s;
+        
+        T value;
+        
+        boolean done;
+        
+        volatile boolean disposed;
 
-        publisher.subscribe(new Subscriber<T>() {
-            T value;
-            @Override
-            public void onComplete() {
-                T v = value;
-                value = null;
-                if (v != null) {
-                    s.onSuccess(v);
-                } else {
-                    s.onError(new NoSuchElementException());
-                }
+        public ToSingleSubscriber(SingleSubscriber<? super T> actual) {
+            this.actual = actual;
+        }
+        
+        @Override
+        public void onSubscribe(Subscription s) {
+            if (SubscriptionHelper.validate(this.s, s)) {
+                this.s = s;
+                
+                actual.onSubscribe(this);
+                
+                s.request(Long.MAX_VALUE);
             }
-
-            @Override
-            public void onError(Throwable t) {
-                value = null;
-                s.onError(t);
+        }
+        
+        @Override
+        public void onNext(T t) {
+            if (done) {
+                return;
             }
-
-            @Override
-            public void onNext(T t) {
+            if (value != null) {
+                s.cancel();
+                done = true;
+                this.value = null;
+                actual.onError(new IndexOutOfBoundsException("Too many elements in the Publisher"));
+            } else {
                 value = t;
             }
-
-            @Override
-            public void onSubscribe(Subscription inner) {
-                s.onSubscribe(Disposables.from(inner));
-                inner.request(Long.MAX_VALUE);
+        }
+        
+        @Override
+        public void onError(Throwable t) {
+            if (done) {
+                RxJavaPlugins.onError(t);
+                return;
+            }
+            done = true;
+            this.value = null;
+            actual.onError(t);
+        }
+        
+        @Override
+        public void onComplete() {
+            if (done) {
+                return;
             }
-            
-        });
+            done = true;
+            T v = this.value;
+            this.value = null;
+            if (v == null) {
+                actual.onError(new NoSuchElementException("The source Publisher is empty"));
+            } else {
+                actual.onSuccess(v);
+            }
+        }
+        
+        @Override
+        public boolean isDisposed() {
+            return disposed;
+        }
+        
+        @Override
+        public void dispose() {
+            disposed = true;
+            s.cancel();
+        }
     }
-
 }
diff --git a/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
index 483378f91b..a0f8bc5c61 100644
--- a/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
+++ b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
@@ -13,7 +13,7 @@
 package io.reactivex.internal.util;
 
 import java.util.Queue;
-import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.*;
 
 import org.reactivestreams.*;
 
@@ -385,4 +385,195 @@
     public static void request(Subscription s, int prefetch) {
         s.request(prefetch < 0 ? Long.MAX_VALUE : prefetch);
     }
+    
+    static final long COMPLETED_MASK = 0x8000000000000000L;
+    static final long REQUESTED_MASK = 0x7FFFFFFFFFFFFFFFL;
+
+    /**
+     * Accumulates requests (validated) and handles the completed mode draining of the queue based on the requests.
+     * 
+     * <p>
+     * Post-completion backpressure handles the case when a source produces values based on
+     * requests when it is active but more values are available even after its completion.
+     * In this case, the onComplete() can't just emit the contents of the queue but has to
+     * coordinate with the requested amounts. This requires two distinct modes: active and
+     * completed. In active mode, requests flow through and the queue is not accessed but
+     * in completed mode, requests no-longer reach the upstream but help in draining the queue.
+     *
+     * @param <T> the value type emitted
+     * @param n
+     * @param actual
+     * @param queue
+     * @param state
+     * @param isCancelled
+     * @return true if the state indicates a completion state.
+     */
+    public static <T> boolean postCompleteRequest(long n,
+                                                  Subscriber<? super T> actual,
+                                                  Queue<T> queue,
+                                                  AtomicLong state,
+                                                  BooleanSupplier isCancelled) {
+        for (; ; ) {
+            long r = state.get();
+
+            // extract the current request amount
+            long r0 = r & REQUESTED_MASK;
+
+            // preserve COMPLETED_MASK and calculate new requested amount
+            long u = (r & COMPLETED_MASK) | BackpressureHelper.addCap(r0, n);
+
+            if (state.compareAndSet(r, u)) {
+                // (complete, 0) -> (complete, n) transition then replay
+                if (r == COMPLETED_MASK) {
+
+                    postCompleteDrain(n | COMPLETED_MASK, actual, queue, state, isCancelled);
+
+                    return true;
+                }
+                // (active, r) -> (active, r + n) transition then continue with requesting from upstream
+                return false;
+            }
+        }
+
+    }
+
+    /**
+     * Drains the queue based on the outstanding requests in post-completed mode (only!).
+     *
+     * @param n
+     * @param actual
+     * @param queue
+     * @param state
+     * @param isCancelled
+     * @return true if the queue was completely drained or the drain process was cancelled
+     */
+    static <T> boolean postCompleteDrain(long n,
+                                         Subscriber<? super T> actual,
+                                         Queue<T> queue,
+                                         AtomicLong state,
+                                         BooleanSupplier isCancelled) {
+
+// TODO enable fast-path
+//        if (n == -1 || n == Long.MAX_VALUE) {
+//            for (;;) {
+//                if (isCancelled.getAsBoolean()) {
+//                    break;
+//                }
+//                
+//                T v = queue.poll();
+//                
+//                if (v == null) {
+//                    actual.onComplete();
+//                    break;
+//                }
+//                
+//                actual.onNext(v);
+//            }
+//            
+//            return true;
+//        }
+
+        long e = n & COMPLETED_MASK;
+
+        for (; ; ) {
+
+            while (e != n) {
+                if (isCancelled.getAsBoolean()) {
+                    return true;
+                }
+
+                T t = queue.poll();
+
+                if (t == null) {
+                    actual.onComplete();
+                    return true;
+                }
+
+                actual.onNext(t);
+                e++;
+            }
+
+            if (isCancelled.getAsBoolean()) {
+                return true;
+            }
+
+            if (queue.isEmpty()) {
+                actual.onComplete();
+                return true;
+            }
+
+            n = state.get();
+
+            if (n == e) {
+
+                n = state.addAndGet(-(e & REQUESTED_MASK));
+
+                if ((n & REQUESTED_MASK) == 0L) {
+                    return false;
+                }
+
+                e = n & COMPLETED_MASK;
+            }
+        }
+
+    }
+
+    /**
+     * Signals the completion of the main sequence and switches to post-completion replay mode.
+     * 
+     * <p>
+     * Don't modify the queue after calling this method!
+     * 
+     * <p>
+     * Post-completion backpressure handles the case when a source produces values based on
+     * requests when it is active but more values are available even after its completion.
+     * In this case, the onCompleted() can't just emit the contents of the queue but has to
+     * coordinate with the requested amounts. This requires two distinct modes: active and
+     * completed. In active mode, requests flow through and the queue is not accessed but
+     * in completed mode, requests no-longer reach the upstream but help in draining the queue.
+     * <p>
+     * The algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since
+     * request amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't
+     * allowed.
+     *
+     * @param <T> the value type emitted
+     * @param actual
+     * @param queue
+     * @param state
+     * @param isCancelled
+     */
+    public static <T> void postComplete(Subscriber<? super T> actual,
+                                        Queue<T> queue,
+                                        AtomicLong state,
+                                        BooleanSupplier isCancelled) {
+
+        if (queue.isEmpty()) {
+            actual.onComplete();
+            return;
+        }
+
+        if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) {
+            return;
+        }
+
+        for (; ; ) {
+            long r = state.get();
+
+            if ((r & COMPLETED_MASK) != 0L) {
+                return;
+            }
+
+            long u = r | COMPLETED_MASK;
+            // (active, r) -> (complete, r) transition
+            if (state.compareAndSet(r, u)) {
+                // if the requested amount was non-zero, drain the queue
+                if (r != 0L) {
+                    postCompleteDrain(u, actual, queue, state, isCancelled);
+                }
+
+                return;
+            }
+        }
+
+    }
 }
diff --git a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
index 4d3739606f..10a3521e3c 100644
--- a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
@@ -247,6 +247,18 @@ public static void reset() {
 
         setNewThreadSchedulerHandler(null);
         setInitNewThreadSchedulerHandler(null);
+        
+        setOnFlowableAssembly(null);
+        setOnFlowableSubscribe(null);
+        
+        setOnObservableAssembly(null);
+        setOnObservableSubscribe(null);
+        
+        setOnSingleAssembly(null);
+        setOnSingleSubscribe(null);
+        
+        setOnCompletableAssembly(null);
+        setOnCompletableSubscribe(null);
     }
 
     public static void setComputationSchedulerHandler(Function<Scheduler, Scheduler> handler) {
diff --git a/src/test/java/io/reactivex/flowable/FlowableNullTests.java b/src/test/java/io/reactivex/flowable/FlowableNullTests.java
index 7c78540eff..e81c7d2231 100644
--- a/src/test/java/io/reactivex/flowable/FlowableNullTests.java
+++ b/src/test/java/io/reactivex/flowable/FlowableNullTests.java
@@ -1315,7 +1315,7 @@ public void filterNull() {
     
     @Test(expected = NullPointerException.class)
     public void finallyDoNull() {
-        just1.finallyDo(null);
+        just1.doAfterTerminate(null);
     }
     
     @Test(expected = NullPointerException.class)
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
index e19f9c0c5f..c8faa58600 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
@@ -28,11 +28,11 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
-import io.reactivex.internal.subscriptions.*;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.TestScheduler;
 import io.reactivex.subscribers.*;
-import io.reactivex.subscribers.DefaultObserver;
 
 public class FlowableBufferTest {
 
@@ -1016,4 +1016,256 @@ public void onComplete() {
         
         assertFalse(s.isDisposed());
     }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testPostCompleteBackpressure() {
+        Flowable<List<Integer>> source = Flowable.range(1, 10).buffer(3, 1);
+        
+        TestSubscriber<List<Integer>> ts = TestSubscriber.create(0L);
+        
+        source.subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertNotComplete();
+        ts.assertNoErrors();
+        
+        ts.request(7);
+        
+        ts.assertValues(
+                Arrays.asList(1, 2, 3),
+                Arrays.asList(2, 3, 4),
+                Arrays.asList(3, 4, 5),
+                Arrays.asList(4, 5, 6),
+                Arrays.asList(5, 6, 7),
+                Arrays.asList(6, 7, 8),
+                Arrays.asList(7, 8, 9)
+        );
+        ts.assertNotComplete();
+        ts.assertNoErrors();
+
+        ts.request(1);
+
+        ts.assertValues(
+                Arrays.asList(1, 2, 3),
+                Arrays.asList(2, 3, 4),
+                Arrays.asList(3, 4, 5),
+                Arrays.asList(4, 5, 6),
+                Arrays.asList(5, 6, 7),
+                Arrays.asList(6, 7, 8),
+                Arrays.asList(7, 8, 9),
+                Arrays.asList(8, 9, 10)
+        );
+        ts.assertNotComplete();
+        ts.assertNoErrors();
+        
+        ts.request(1);
+
+        ts.assertValues(
+                Arrays.asList(1, 2, 3),
+                Arrays.asList(2, 3, 4),
+                Arrays.asList(3, 4, 5),
+                Arrays.asList(4, 5, 6),
+                Arrays.asList(5, 6, 7),
+                Arrays.asList(6, 7, 8),
+                Arrays.asList(7, 8, 9),
+                Arrays.asList(8, 9, 10),
+                Arrays.asList(9, 10)
+        );
+        ts.assertNotComplete();
+        ts.assertNoErrors();
+        
+        ts.request(1);
+
+        ts.assertValues(
+                Arrays.asList(1, 2, 3),
+                Arrays.asList(2, 3, 4),
+                Arrays.asList(3, 4, 5),
+                Arrays.asList(4, 5, 6),
+                Arrays.asList(5, 6, 7),
+                Arrays.asList(6, 7, 8),
+                Arrays.asList(7, 8, 9),
+                Arrays.asList(8, 9, 10),
+                Arrays.asList(9, 10),
+                Arrays.asList(10)
+        );
+        ts.assertComplete();
+        ts.assertNoErrors();
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void timeAndSkipOverlap() {
+        
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+        
+        TestSubscriber<List<Integer>> ts = TestSubscriber.create();
+        
+        ps.buffer(2, 1, TimeUnit.SECONDS, scheduler).subscribe(ts);
+        
+        ps.onNext(1);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        ps.onNext(2);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        ps.onNext(3);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        ps.onNext(4);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        ps.onComplete();
+        
+        ts.assertValues(
+                Arrays.asList(1, 2),
+                Arrays.asList(2, 3),
+                Arrays.asList(3, 4),
+                Arrays.asList(4),
+                Collections.<Integer>emptyList()
+        );
+        
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void timeAndSkipSkip() {
+        
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+        
+        TestSubscriber<List<Integer>> ts = TestSubscriber.create();
+        
+        ps.buffer(2, 3, TimeUnit.SECONDS, scheduler).subscribe(ts);
+        
+        ps.onNext(1);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        ps.onNext(2);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        ps.onNext(3);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        ps.onNext(4);
+        
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        ps.onComplete();
+        
+        ts.assertValues(
+                Arrays.asList(1, 2),
+                Arrays.asList(4)
+        );
+        
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void timeAndSkipOverlapScheduler() {
+        
+        RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler, Scheduler>() {
+            @Override
+            public Scheduler apply(Scheduler t) {
+                return scheduler;
+            }
+        });
+        
+        try {
+            PublishProcessor<Integer> ps = PublishProcessor.create();
+            
+            TestSubscriber<List<Integer>> ts = TestSubscriber.create();
+            
+            ps.buffer(2, 1, TimeUnit.SECONDS).subscribe(ts);
+            
+            ps.onNext(1);
+            
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+            
+            ps.onNext(2);
+            
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+    
+            ps.onNext(3);
+            
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+    
+            ps.onNext(4);
+            
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+            
+            ps.onComplete();
+            
+            ts.assertValues(
+                    Arrays.asList(1, 2),
+                    Arrays.asList(2, 3),
+                    Arrays.asList(3, 4),
+                    Arrays.asList(4),
+                    Collections.<Integer>emptyList()
+            );
+            
+            ts.assertNoErrors();
+            ts.assertComplete();
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void timeAndSkipSkipDefaultScheduler() {
+        RxJavaPlugins.setComputationSchedulerHandler(new Function<Scheduler, Scheduler>() {
+            @Override
+            public Scheduler apply(Scheduler t) {
+                return scheduler;
+            }
+        });
+        
+        try {
+        
+            PublishProcessor<Integer> ps = PublishProcessor.create();
+            
+            TestSubscriber<List<Integer>> ts = TestSubscriber.create();
+            
+            ps.buffer(2, 3, TimeUnit.SECONDS).subscribe(ts);
+            
+            ps.onNext(1);
+            
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+            
+            ps.onNext(2);
+            
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+    
+            ps.onNext(3);
+            
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+    
+            ps.onNext(4);
+            
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+            
+            ps.onComplete();
+            
+            ts.assertValues(
+                    Arrays.asList(1, 2),
+                    Arrays.asList(4)
+            );
+            
+            ts.assertNoErrors();
+            ts.assertComplete();
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCastTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCastTest.java
index 177750dc7d..081b78fe66 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCastTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCastTest.java
@@ -15,10 +15,12 @@
 
 import static org.mockito.Mockito.*;
 
-import org.junit.Test;
+import org.junit.*;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.processors.PublishProcessor;
+import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableCastTest {
 
@@ -50,4 +52,22 @@ public void testCastWithWrongType() {
         verify(observer, times(1)).onError(
                 org.mockito.Matchers.any(ClassCastException.class));
     }
+    
+    @Test
+    public void castCrashUnsubscribes() {
+        
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+        
+        TestSubscriber<String> ts = TestSubscriber.create();
+        
+        ps.cast(String.class).unsafeSubscribe(ts);
+        
+        Assert.assertTrue("Not subscribed?", ps.hasSubscribers());
+        
+        ps.onNext(1);
+        
+        Assert.assertFalse("Subscribed?", ps.hasSubscribers());
+        
+        ts.assertError(ClassCastException.class);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
index 382ca71cb3..64acb42a62 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java
@@ -13,14 +13,21 @@
 
 package io.reactivex.internal.operators.flowable;
 
-import org.junit.Test;
 import org.reactivestreams.Publisher;
 import static org.junit.Assert.*;
 
+import java.lang.reflect.Method;
+import java.util.*;
+import java.util.concurrent.atomic.*;
+
+import org.junit.*;
+
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.functions.Function;
+import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.processors.PublishProcessor;
+import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableConcatMapEagerTest {
@@ -246,4 +253,511 @@ public void longEager() {
         .assertNoErrors()
         .assertComplete();
     }
+    
+    TestSubscriber<Object> ts;
+    TestSubscriber<Object> tsBp;
+    
+    Function<Integer, Flowable<Integer>> toJust = new Function<Integer, Flowable<Integer>>() {
+        @Override
+        public Flowable<Integer> apply(Integer t) {
+            return Flowable.just(t);
+        }
+    };
+
+    Function<Integer, Flowable<Integer>> toRange = new Function<Integer, Flowable<Integer>>() {
+        @Override
+        public Flowable<Integer> apply(Integer t) {
+            return Flowable.range(t, 2);
+        }
+    };
+
+    @Before
+    public void before() {
+        ts = new TestSubscriber<Object>();
+        tsBp = new TestSubscriber<Object>(0L);
+    }
+    
+    @Test
+    public void testSimple() {
+        Flowable.range(1, 100).concatMapEager(toJust).subscribe(ts);
+        
+        ts.assertNoErrors();
+        ts.assertValueCount(100);
+        ts.assertComplete();
+    }
+
+    @Test
+    public void testSimple2() {
+        Flowable.range(1, 100).concatMapEager(toRange).subscribe(ts);
+        
+        ts.assertNoErrors();
+        ts.assertValueCount(200);
+        ts.assertComplete();
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testEagerness2() {
+        final AtomicInteger count = new AtomicInteger();
+        Flowable<Integer> source = Flowable.just(1).doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer t) {
+                count.getAndIncrement();
+            }
+        }).hide();
+        
+        Flowable.concatArrayEager(source, source).subscribe(tsBp);
+        
+        Assert.assertEquals(2, count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertNotComplete();
+        tsBp.assertNoValues();
+        
+        tsBp.request(Long.MAX_VALUE);
+        
+        tsBp.assertValueCount(count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertComplete();
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testEagerness3() {
+        final AtomicInteger count = new AtomicInteger();
+        Flowable<Integer> source = Flowable.just(1).doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer t) {
+                count.getAndIncrement();
+            }
+        }).hide();
+        
+        Flowable.concatArrayEager(source, source, source).subscribe(tsBp);
+        
+        Assert.assertEquals(3, count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertNotComplete();
+        tsBp.assertNoValues();
+        
+        tsBp.request(Long.MAX_VALUE);
+        
+        tsBp.assertValueCount(count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertComplete();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testEagerness4() {
+        final AtomicInteger count = new AtomicInteger();
+        Flowable<Integer> source = Flowable.just(1).doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer t) {
+                count.getAndIncrement();
+            }
+        }).hide();
+        
+        Flowable.concatArrayEager(source, source, source, source).subscribe(tsBp);
+        
+        Assert.assertEquals(4, count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertNotComplete();
+        tsBp.assertNoValues();
+        
+        tsBp.request(Long.MAX_VALUE);
+        
+        tsBp.assertValueCount(count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertComplete();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testEagerness5() {
+        final AtomicInteger count = new AtomicInteger();
+        Flowable<Integer> source = Flowable.just(1).doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer t) {
+                count.getAndIncrement();
+            }
+        }).hide();
+        
+        Flowable.concatArrayEager(source, source, source, source, source).subscribe(tsBp);
+        
+        Assert.assertEquals(5, count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertNotComplete();
+        tsBp.assertNoValues();
+        
+        tsBp.request(Long.MAX_VALUE);
+        
+        tsBp.assertValueCount(count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertComplete();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testEagerness6() {
+        final AtomicInteger count = new AtomicInteger();
+        Flowable<Integer> source = Flowable.just(1).doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer t) {
+                count.getAndIncrement();
+            }
+        }).hide();
+        
+        Flowable.concatArrayEager(source, source, source, source, source, source).subscribe(tsBp);
+        
+        Assert.assertEquals(6, count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertNotComplete();
+        tsBp.assertNoValues();
+        
+        tsBp.request(Long.MAX_VALUE);
+        
+        tsBp.assertValueCount(count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertComplete();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testEagerness7() {
+        final AtomicInteger count = new AtomicInteger();
+        Flowable<Integer> source = Flowable.just(1).doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer t) {
+                count.getAndIncrement();
+            }
+        }).hide();
+        
+        Flowable.concatArrayEager(source, source, source, source, source, source, source).subscribe(tsBp);
+        
+        Assert.assertEquals(7, count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertNotComplete();
+        tsBp.assertNoValues();
+        
+        tsBp.request(Long.MAX_VALUE);
+        
+        tsBp.assertValueCount(count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertComplete();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testEagerness8() {
+        final AtomicInteger count = new AtomicInteger();
+        Flowable<Integer> source = Flowable.just(1).doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer t) {
+                count.getAndIncrement();
+            }
+        }).hide();
+        
+        Flowable.concatArrayEager(source, source, source, source, source, source, source, source).subscribe(tsBp);
+        
+        Assert.assertEquals(8, count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertNotComplete();
+        tsBp.assertNoValues();
+        
+        tsBp.request(Long.MAX_VALUE);
+        
+        tsBp.assertValueCount(count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertComplete();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testEagerness9() {
+        final AtomicInteger count = new AtomicInteger();
+        Flowable<Integer> source = Flowable.just(1).doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer t) {
+                count.getAndIncrement();
+            }
+        }).hide();
+        
+        Flowable.concatArrayEager(source, source, source, source, source, source, source, source, source).subscribe(tsBp);
+        
+        Assert.assertEquals(9, count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertNotComplete();
+        tsBp.assertNoValues();
+        
+        tsBp.request(Long.MAX_VALUE);
+        
+        tsBp.assertValueCount(count.get());
+        tsBp.assertNoErrors();
+        tsBp.assertComplete();
+    }
+
+    @Test
+    public void testMainError() {
+        Flowable.<Integer>error(new TestException()).concatMapEager(toJust).subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertError(TestException.class);
+        ts.assertNotComplete();
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testInnerError() {
+        Flowable.concatArrayEager(Flowable.just(1), Flowable.error(new TestException())).subscribe(ts);
+        
+        ts.assertValue(1);
+        ts.assertError(TestException.class);
+        ts.assertNotComplete();
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testInnerEmpty() {
+        Flowable.concatArrayEager(Flowable.empty(), Flowable.empty()).subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @Test
+    public void testMapperThrows() {
+        Flowable.just(1).concatMapEager(new Function<Integer, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer t) {
+                throw new TestException();
+            } 
+        }).subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertNotComplete();
+        ts.assertError(TestException.class);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testInvalidCapacityHint() {
+        Flowable.just(1).concatMapEager(toJust, 0, Flowable.bufferSize());
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testInvalidMaxConcurrent() {
+        Flowable.just(1).concatMapEager(toJust, Flowable.bufferSize(), 0);
+    }
+    
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testBackpressure() {
+        Flowable.concatArrayEager(Flowable.just(1), Flowable.just(1)).subscribe(tsBp);
+
+        tsBp.assertNoErrors();
+        tsBp.assertNoValues();
+        tsBp.assertNotComplete();
+        
+        tsBp.request(1);
+        tsBp.assertValue(1);
+        tsBp.assertNoErrors();
+        tsBp.assertNotComplete();
+        
+        tsBp.request(1);
+        tsBp.assertValues(1, 1);
+        tsBp.assertNoErrors();
+        tsBp.assertComplete();
+    }
+    
+    @Test
+    public void testAsynchronousRun() {
+        Flowable.range(1, 2).concatMapEager(new Function<Integer, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer t) {
+                return Flowable.range(1, 1000).subscribeOn(Schedulers.computation());
+            }
+        }).observeOn(Schedulers.newThread()).subscribe(ts);
+        
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        ts.assertValueCount(2000);
+    }
+    
+    @Test
+    public void testReentrantWork() {
+        final PublishProcessor<Integer> subject = PublishProcessor.create();
+        
+        final AtomicBoolean once = new AtomicBoolean();
+        
+        subject.concatMapEager(new Function<Integer, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer t) {
+                return Flowable.just(t);
+            }
+        })
+        .doOnNext(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer t) {
+                if (once.compareAndSet(false, true)) {
+                    subject.onNext(2);
+                }
+            }
+        })
+        .subscribe(ts);
+        
+        subject.onNext(1);
+        
+        ts.assertNoErrors();
+        ts.assertNotComplete();
+        ts.assertValues(1, 2);
+    }
+    
+    @Test
+    public void testPrefetchIsBounded() {
+        final AtomicInteger count = new AtomicInteger();
+        
+        TestSubscriber<Object> ts = TestSubscriber.create(0);
+        
+        Flowable.just(1).concatMapEager(new Function<Integer, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer t) {
+                return Flowable.range(1, Flowable.bufferSize() * 2)
+                        .doOnNext(new Consumer<Integer>() {
+                            @Override
+                            public void accept(Integer t) {
+                                count.getAndIncrement();
+                            }
+                        }).hide();
+            }
+        }).subscribe(ts);
+        
+        ts.assertNoErrors();
+        ts.assertNoValues();
+        ts.assertNotComplete();
+        Assert.assertEquals(Flowable.bufferSize(), count.get());
+    }
+    
+    @Test
+    @Ignore("Null values are not allowed in RS")
+    public void testInnerNull() {
+        Flowable.just(1).concatMapEager(new Function<Integer, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer t) {
+                return Flowable.just(null);
+            }
+        }).subscribe(ts);
+
+        ts.assertNoErrors();
+        ts.assertComplete();
+        ts.assertValue(null);
+    }
+
+
+    @Test
+    public void testMaxConcurrent5() {
+        final List<Long> requests = new ArrayList<Long>();
+        Flowable.range(1, 100).doOnRequest(new LongConsumer() {
+            @Override
+            public void accept(long reqCount) {
+                requests.add(reqCount);
+            }
+        }).concatMapEager(toJust, 5, Flowable.bufferSize()).subscribe(ts);
+
+        ts.assertNoErrors();
+        ts.assertValueCount(100);
+        ts.assertComplete();
+
+        Assert.assertEquals(5, (long) requests.get(0));
+        Assert.assertEquals(1, (long) requests.get(1));
+        Assert.assertEquals(1, (long) requests.get(2));
+        Assert.assertEquals(1, (long) requests.get(3));
+        Assert.assertEquals(1, (long) requests.get(4));
+        Assert.assertEquals(1, (long) requests.get(5));
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    @Ignore("Currently there are no 2-9 argument variants, use concatArrayEager()")
+    public void many() throws Exception {
+        for (int i = 2; i < 10; i++) {
+            Class<?>[] clazz = new Class[i];
+            Arrays.fill(clazz, Flowable.class);
+            
+            Flowable<Integer>[] obs = new Flowable[i];
+            Arrays.fill(obs, Flowable.just(1));
+            
+            Integer[] expected = new Integer[i];
+            Arrays.fill(expected, 1);
+            
+            Method m = Flowable.class.getMethod("concatEager", clazz);
+            
+            TestSubscriber<Integer> ts = TestSubscriber.create();
+            
+            ((Flowable<Integer>)m.invoke(null, (Object[])obs)).subscribe(ts);
+            
+            ts.assertValues(expected);
+            ts.assertNoErrors();
+            ts.assertComplete();
+        }
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void capacityHint() {
+        Flowable<Integer> source = Flowable.just(1);
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        Flowable.concatEager(Arrays.asList(source, source, source), 1, 1).subscribe(ts);
+        
+        ts.assertValues(1, 1, 1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+
+    @Test
+    public void Flowable() {
+        Flowable<Integer> source = Flowable.just(1);
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        Flowable.concatEager(Flowable.just(source, source, source)).subscribe(ts);
+        
+        ts.assertValues(1, 1, 1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @Test
+    public void FlowableCapacityHint() {
+        Flowable<Integer> source = Flowable.just(1);
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        Flowable.concatEager(Flowable.just(source, source, source), 1, 1).subscribe(ts);
+        
+        ts.assertValues(1, 1, 1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void badCapacityHint() throws Exception {
+        Flowable<Integer> source = Flowable.just(1);
+        try {
+            Flowable.concatEager(Arrays.asList(source, source, source), 1, -99);
+        } catch (IllegalArgumentException ex) {
+            assertEquals("prefetch > 0 required but it was -99", ex.getMessage());
+        }
+        
+    }
+
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void mappingBadCapacityHint() throws Exception {
+        Flowable<Integer> source = Flowable.just(1);
+        try {
+            Flowable.just(source, source, source).concatMapEager((Function)Functions.identity(), 10, -99);
+        } catch (IllegalArgumentException ex) {
+            assertEquals("prefetch > 0 required but it was -99", ex.getMessage());
+        }
+        
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
index 96af441dc4..6e664263da 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java
@@ -17,11 +17,12 @@
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
 
+import java.lang.reflect.Method;
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;
 
-import org.junit.Test;
+import org.junit.*;
 import org.mockito.InOrder;
 import org.reactivestreams.*;
 
@@ -29,7 +30,8 @@
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.processors.*;
 import io.reactivex.schedulers.*;
 import io.reactivex.subscribers.*;
@@ -824,7 +826,7 @@ public void concatMapRangeAsyncLoopIssue2876() {
             assertEquals((Integer)999, ts.values().get(999));
         }
     }
- 
+
     @SuppressWarnings("unchecked")
     @Test
     public void arrayDelayError() {
@@ -845,4 +847,164 @@ public void arrayDelayError() {
         assertTrue(list.get(0).toString(), list.get(0) instanceof NullPointerException);
         assertTrue(list.get(1).toString(), list.get(1) instanceof TestException);
     }
+
+    @Test
+    public void scalarAndRangeBackpressured() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        
+        Flowable.just(1).concatWith(Flowable.range(2, 3)).subscribe(ts);
+        
+        ts.assertNoValues();
+        
+        ts.request(5);
+        
+        ts.assertValues(1, 2, 3, 4);
+        ts.assertComplete();
+        ts.assertNoErrors();
+    }
+    
+    @Test
+    public void scalarAndEmptyBackpressured() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        
+        Flowable.just(1).concatWith(Flowable.<Integer>empty()).subscribe(ts);
+        
+        ts.assertNoValues();
+        
+        ts.request(5);
+        
+        ts.assertValue(1);
+        ts.assertComplete();
+        ts.assertNoErrors();
+    }
+
+    @Test
+    public void rangeAndEmptyBackpressured() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        
+        Flowable.range(1, 2).concatWith(Flowable.<Integer>empty()).subscribe(ts);
+        
+        ts.assertNoValues();
+        
+        ts.request(5);
+        
+        ts.assertValues(1, 2);
+        ts.assertComplete();
+        ts.assertNoErrors();
+    }
+
+    @Test
+    public void emptyAndScalarBackpressured() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        
+        Flowable.<Integer>empty().concatWith(Flowable.just(1)).subscribe(ts);
+        
+        ts.assertNoValues();
+        
+        ts.request(5);
+        
+        ts.assertValue(1);
+        ts.assertComplete();
+        ts.assertNoErrors();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    @Ignore("concat(a, b, ...) replaced by concatArray(T...)")
+    public void concatMany() throws Exception {
+        for (int i = 2; i < 10; i++) {
+            Class<?>[] clazz = new Class[i];
+            Arrays.fill(clazz, Flowable.class);
+            
+            Flowable<Integer>[] obs = new Flowable[i];
+            Arrays.fill(obs, Flowable.just(1));
+            
+            Integer[] expected = new Integer[i];
+            Arrays.fill(expected, 1);
+            
+            Method m = Flowable.class.getMethod("concat", clazz);
+            
+            TestSubscriber<Integer> ts = TestSubscriber.create();
+            
+            ((Flowable<Integer>)m.invoke(null, (Object[])obs)).subscribe(ts);
+            
+            ts.assertValues(expected);
+            ts.assertNoErrors();
+            ts.assertComplete();
+        }
+    }
+    
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void concatMapJustJust() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.just(Flowable.just(1)).concatMap((Function)Functions.identity()).subscribe(ts);
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void concatMapJustRange() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.just(Flowable.range(1, 5)).concatMap((Function)Functions.identity()).subscribe(ts);
+        
+        ts.assertValues(1, 2, 3, 4, 5);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void concatMapDelayErrorJustJust() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.just(Flowable.just(1)).concatMapDelayError((Function)Functions.identity()).subscribe(ts);
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void concatMapDelayErrorJustRange() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.just(Flowable.range(1, 5)).concatMapDelayError((Function)Functions.identity()).subscribe(ts);
+        
+        ts.assertValues(1, 2, 3, 4, 5);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    @Ignore("startWith(a, b, ...) replaced by startWithArray(T...)")
+    public void startWith() throws Exception {
+        for (int i = 2; i < 10; i++) {
+            Class<?>[] clazz = new Class[i];
+            Arrays.fill(clazz, Object.class);
+            
+            Object[] obs = new Object[i];
+            Arrays.fill(obs, 1);
+            
+            Integer[] expected = new Integer[i];
+            Arrays.fill(expected, 1);
+            
+            Method m = Flowable.class.getMethod("startWith", clazz);
+            
+            TestSubscriber<Integer> ts = TestSubscriber.create();
+            
+            ((Flowable<Integer>)m.invoke(Flowable.empty(), obs)).subscribe(ts);
+            
+            ts.assertValues(expected);
+            ts.assertNoErrors();
+            ts.assertComplete();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCountTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCountTest.java
new file mode 100644
index 0000000000..5cd26a6ab8
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCountTest.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.flowable;
+
+import org.junit.*;
+
+import io.reactivex.Flowable;
+
+public class FlowableCountTest {
+    @Test
+    public void simple() {
+        Assert.assertEquals(0, Flowable.empty().count().toBlocking().last().intValue());
+
+        Assert.assertEquals(1, Flowable.just(1).count().toBlocking().last().intValue());
+
+        Assert.assertEquals(10, Flowable.range(1, 10).count().toBlocking().last().intValue());
+
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
index a153c1d5e1..dcce44464a 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDebounceTest.java
@@ -291,4 +291,17 @@ public void debounceWithTimeBackpressure() throws InterruptedException {
         subscriber.assertTerminated();
         subscriber.assertNoErrors();
     }
+    
+    @Test
+    public void debounceDefaultScheduler() throws Exception {
+        
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+
+        Flowable.range(1, 1000).debounce(1, TimeUnit.SECONDS).subscribe(ts);
+
+        ts.awaitTerminalEvent(5, TimeUnit.SECONDS);
+        ts.assertValue(1000);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java
index 77f962f1e4..bf4cdad20c 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java
@@ -19,6 +19,7 @@
 
 import java.util.*;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.junit.*;
 import org.mockito.InOrder;
@@ -869,4 +870,26 @@ public void testDelaySupplierErrors() {
         ts.assertError(TestException.class);
     }
 
+    @Test
+    public void delayAndTakeUntilNeverSubscribeToSource() {
+        PublishProcessor<Integer> delayUntil = PublishProcessor.create();
+        PublishProcessor<Integer> interrupt = PublishProcessor.create();
+        final AtomicBoolean subscribed = new AtomicBoolean(false);
+
+        Flowable.just(1)
+        .doOnSubscribe(new Consumer<Object>() {
+            @Override
+            public void accept(Object o) {
+                subscribed.set(true);
+            }
+        })
+        .delaySubscription(delayUntil)
+        .takeUntil(interrupt)
+        .subscribe();
+
+        interrupt.onNext(9000);
+        delayUntil.onNext(1);
+
+        Assert.assertFalse(subscribed.get());
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChangedTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChangedTest.java
index 70ecbb5213..c04c5f930a 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChangedTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChangedTest.java
@@ -16,13 +16,17 @@
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
 
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import org.junit.*;
 import org.mockito.InOrder;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.internal.fuseable.QueueSubscription;
+import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableDistinctUntilChangedTest {
 
@@ -196,4 +200,65 @@ public boolean test(Integer v) {
         .assertFusionMode(QueueSubscription.SYNC)
         .assertResult(1, 2, 3, 2, 4, 1, 2);
     }
+    
+    private final static Function<String, String> THROWS_NON_FATAL = new Function<String, String>() {
+        @Override
+        public String apply(String s) {
+            throw new RuntimeException();
+        }
+    };
+    
+    @Test
+    public void testDistinctUntilChangedWhenNonFatalExceptionThrownByKeySelectorIsNotReportedByUpstream() {
+        Flowable<String> src = Flowable.just("a", "b", "null", "c");
+        final AtomicBoolean errorOccurred = new AtomicBoolean(false);
+        src
+          .doOnError(new Consumer<Throwable>() {
+                @Override
+                public void accept(Throwable t) {
+                    errorOccurred.set(true);
+                }
+            })
+          .distinctUntilChanged(THROWS_NON_FATAL)
+          .subscribe(w);
+        Assert.assertFalse(errorOccurred.get());
+    }
+    
+    @Test
+    public void customComparator() {
+        Flowable<String> source = Flowable.just("a", "b", "B", "A","a", "C");
+        
+        TestSubscriber<String> ts = TestSubscriber.create();
+        
+        source.distinctUntilChanged(new BiPredicate<String, String>() {
+            @Override
+            public boolean test(String a, String b) {
+                return a.compareToIgnoreCase(b) == 0;
+            }
+        })
+        .subscribe(ts);
+        
+        ts.assertValues("a", "b", "A", "C");
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+
+    @Test
+    public void customComparatorThrows() {
+        Flowable<String> source = Flowable.just("a", "b", "B", "A","a", "C");
+        
+        TestSubscriber<String> ts = TestSubscriber.create();
+        
+        source.distinctUntilChanged(new BiPredicate<String, String>() {
+            @Override
+            public boolean test(String a, String b) {
+                throw new TestException();
+            }
+        })
+        .subscribe(ts);
+        
+        ts.assertValue("a");
+        ts.assertNotComplete();
+        ts.assertError(TestException.class);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoAfterTerminateTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoAfterTerminateTest.java
new file mode 100644
index 0000000000..7881153364
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoAfterTerminateTest.java
@@ -0,0 +1,96 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.reactivex.internal.operators.flowable;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+import org.junit.*;
+import org.mockito.Mockito;
+import org.reactivestreams.Subscriber;
+
+import io.reactivex.*;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class FlowableDoAfterTerminateTest {
+
+    private Runnable aAction0;
+    private Subscriber<String> observer;
+
+    @Before
+    public void before() {
+        aAction0 = Mockito.mock(Runnable.class);
+        observer = TestHelper.mockSubscriber();
+    }
+
+    private void checkActionCalled(Flowable<String> input) {
+        input.doAfterTerminate(aAction0).subscribe(observer);
+        verify(aAction0, times(1)).run();
+    }
+
+    @Test
+    public void testDoAfterTerminateCalledOnComplete() {
+        checkActionCalled(Flowable.fromArray("1", "2", "3"));
+    }
+
+    @Test
+    public void testDoAfterTerminateCalledOnError() {
+        checkActionCalled(Flowable.<String> error(new RuntimeException("expected")));
+    }
+
+    @Test
+    public void nullActionShouldBeCheckedInConstructor() {
+        try {
+            Flowable.empty().doAfterTerminate(null);
+            fail("Should have thrown NullPointerException");
+        } catch (NullPointerException expected) {
+            assertEquals("onAfterTerminate is null", expected.getMessage());
+        }
+    }
+    
+    @Test
+    public void nullFinallyActionShouldBeCheckedASAP() {
+        try {
+            Flowable
+                    .just("value")
+                    .doAfterTerminate(null);
+
+            fail();
+        } catch (NullPointerException expected) {
+
+        }
+    }
+
+    @Test
+    public void ifFinallyActionThrowsExceptionShouldNotBeSwallowedAndActionShouldBeCalledOnce() {
+        Runnable finallyAction = Mockito.mock(Runnable.class);
+        doThrow(new IllegalStateException()).when(finallyAction).run();
+
+        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();
+
+        Flowable
+                .just("value")
+                .doAfterTerminate(finallyAction)
+                .subscribe(testSubscriber);
+
+        testSubscriber.assertValue("value");
+
+        verify(finallyAction).run();
+        // Actual result:
+        // Not only IllegalStateException was swallowed
+        // But finallyAction was called twice!
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnEachTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnEachTest.java
index b653e062ec..e277e22626 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnEachTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnEachTest.java
@@ -24,7 +24,9 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
+import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableDoOnEachTest {
 
@@ -161,9 +163,9 @@ public void accept(List<Boolean> booleans) {
         assertEquals(expectedCount, count.get());
     }
 
-    // FIXME crashing publisher can't propagate to a subscriber
-//    @Test
-//    public void testFatalError() {
+    @Test
+    @Ignore("crashing publisher can't propagate to a subscriber")
+    public void testFatalError() {
 //        try {
 //            Observable.just(1, 2, 3)
 //                    .flatMap(new Function<Integer, Observable<?>>() {
@@ -190,5 +192,29 @@ public void accept(List<Boolean> booleans) {
 //            assertEquals(e.getCause().getMessage(), "Test NPE");
 //            System.out.println("Received exception: " + e);
 //        }
-//    }
+    }
+    
+    @Test
+    public void testOnErrorThrows() {
+        TestSubscriber<Object> ts = TestSubscriber.create();
+        
+        Flowable.error(new TestException())
+        .doOnError(new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) {
+                throw new TestException();
+            }
+        }).subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertNotComplete();
+        ts.assertError(CompositeException.class);
+        
+        CompositeException ex = (CompositeException)ts.errors().get(0);
+        
+        List<Throwable> exceptions = ex.getExceptions();
+        assertEquals(2, exceptions.size());
+        Assert.assertTrue(exceptions.get(0) instanceof TestException);
+        Assert.assertTrue(exceptions.get(1) instanceof TestException);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnRequestTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnRequestTest.java
index ab17e493d8..2c46e6f7cf 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnRequestTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnRequestTest.java
@@ -18,7 +18,7 @@
 import java.util.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.junit.Test;
+import org.junit.*;
 
 import io.reactivex.Flowable;
 import io.reactivex.functions.LongConsumer;
@@ -86,4 +86,55 @@ public void onNext(Integer t) {
         assertEquals(Arrays.asList(3L,1L,2L,3L,4L,5L), requests);
     }
 
+    @Test
+    @Ignore("This is a 1.x architecture-specific test")
+    public void dontRequestIfDownstreamRequestsLate() {
+//        final List<Long> requested = new ArrayList<Long>();
+//
+//        Action1<Long> empty = Actions.empty();
+//        
+//        final AtomicReference<Producer> producer = new AtomicReference<Producer>();
+//        
+//        Observable.create(new OnSubscribe<Integer>() {
+//            @Override
+//            public void call(Subscriber<? super Integer> t) {
+//                t.setProducer(new Producer() {
+//                    @Override
+//                    public void request(long n) {
+//                        requested.add(n);
+//                    }
+//                });
+//            }
+//        }).doOnRequest(empty).subscribe(new Subscriber<Object>() {
+//            @Override
+//            public void onNext(Object t) {
+//                
+//            }
+//            
+//            @Override
+//            public void onError(Throwable e) {
+//                
+//            }
+//            
+//            @Override
+//            public void onCompleted() {
+//                
+//            }
+//            
+//            @Override
+//            public void setProducer(Producer p) {
+//                producer.set(p);
+//            }
+//        });
+//        
+//        producer.get().request(1);
+//
+//        int s = requested.size();
+//        if (s == 1) {
+//            // this allows for an implementation that itself doesn't request
+//            Assert.assertEquals(Arrays.asList(1L), requested);
+//        } else {
+//            Assert.assertEquals(Arrays.asList(0L, 1L), requested);
+//        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFilterTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFilterTest.java
index 7aa30ba53f..3039dc46eb 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFilterTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFilterTest.java
@@ -18,12 +18,15 @@
 
 import java.util.concurrent.CountDownLatch;
 
-import org.junit.Test;
+import org.junit.*;
 import org.mockito.Mockito;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Predicate;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableFilterTest {
@@ -144,9 +147,9 @@ public void onNext(Integer t) {
         latch.await();
     }
     
-    // FIXME subscribers are not allowed to throw
-//    @Test
-//    public void testFatalError() {
+    @Test
+    @Ignore("subscribers are not allowed to throw")
+    public void testFatalError() {
 //        try {
 //            Observable.just(1)
 //            .filter(new Predicate<Integer>() {
@@ -168,5 +171,43 @@ public void onNext(Integer t) {
 //                Assert.fail("Failed to report the original exception, instead: " + ex.getCause());
 //            }
 //        }
-//    }
+    }
+
+    @Test
+    public void functionCrashUnsubscribes() {
+        
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+        
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        ps.filter(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) { 
+                throw new TestException(); 
+            }
+        }).unsafeSubscribe(ts);
+        
+        Assert.assertTrue("Not subscribed?", ps.hasSubscribers());
+        
+        ps.onNext(1);
+        
+        Assert.assertFalse("Subscribed?", ps.hasSubscribers());
+        
+        ts.assertError(TestException.class);
+    }
+
+    @Test
+    public void doesntRequestOnItsOwn() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0L);
+        
+        Flowable.range(1, 10).filter(Functions.alwaysTrue()).unsafeSubscribe(ts);
+        
+        ts.assertNoValues();
+        
+        ts.request(10);
+        
+        ts.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFinallyTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFinallyTest.java
deleted file mode 100644
index b102a7a3e5..0000000000
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFinallyTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/**
- * Copyright 2016 Netflix, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
- * the License for the specific language governing permissions and limitations under the License.
- */
-
-package io.reactivex.internal.operators.flowable;
-
-import static org.mockito.Mockito.*;
-
-import org.junit.*;
-import org.reactivestreams.Subscriber;
-
-import io.reactivex.*;
-
-public class FlowableFinallyTest {
-
-    private Runnable aAction0;
-    private Subscriber<String> observer;
-
-    // mocking has to be unchecked, unfortunately
-    @Before
-    public void before() {
-        aAction0 = mock(Runnable.class);
-        observer = TestHelper.mockSubscriber();
-    }
-
-    private void checkActionCalled(Flowable<String> input) {
-        input.finallyDo(aAction0).subscribe(observer);
-        verify(aAction0, times(1)).run();
-    }
-
-    @Test
-    public void testFinallyCalledOnComplete() {
-        checkActionCalled(Flowable.fromArray("1", "2", "3"));
-    }
-
-    @Test
-    public void testFinallyCalledOnError() {
-        checkActionCalled(Flowable.<String> error(new RuntimeException("expected")));
-    }
-}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java
index da1a712b9c..291555b89d 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java
@@ -482,7 +482,7 @@ public void flatMapRangeMixedAsyncLoop() {
                 public Flowable<Integer> apply(Integer t) {
                     Flowable<Integer> r = Flowable.just(t);
                     if (rnd.nextBoolean()) {
-                        r = r.asObservable();
+                        r = r.hide();
                     }
                     return r;
                 }
@@ -545,4 +545,108 @@ public void flatMapTwoNestedSync() {
             ts.assertValueCount(n * 2);
         }
     }
+    
+    @Test
+    public void justEmptyMixture() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.range(0, 4 * Flowable.bufferSize())
+        .flatMap(new Function<Integer, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer v) {
+                return (v & 1) == 0 ? Flowable.<Integer>empty() : Flowable.just(v);
+            }
+        })
+        .subscribe(ts);
+        
+        ts.assertValueCount(2 * Flowable.bufferSize());
+        ts.assertNoErrors();
+        ts.assertComplete();
+        
+        int j = 1;
+        for (Integer v : ts.values()) {
+            Assert.assertEquals(j, v.intValue());
+            
+            j += 2;
+        }
+    }
+
+    @Test
+    public void rangeEmptyMixture() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.range(0, 4 * Flowable.bufferSize())
+        .flatMap(new Function<Integer, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer v) {
+                return (v & 1) == 0 ? Flowable.<Integer>empty() : Flowable.range(v, 2);
+            }
+        })
+        .subscribe(ts);
+        
+        ts.assertValueCount(4 * Flowable.bufferSize());
+        ts.assertNoErrors();
+        ts.assertComplete();
+        
+        int j = 1;
+        List<Integer> list = ts.values();
+        for (int i = 0; i < list.size(); i += 2) {
+            Assert.assertEquals(j, list.get(i).intValue());
+            Assert.assertEquals(j + 1, list.get(i + 1).intValue());
+            
+            j += 2;
+        }
+    }
+
+    @Test
+    public void justEmptyMixtureMaxConcurrent() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.range(0, 4 * Flowable.bufferSize())
+        .flatMap(new Function<Integer, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer v) {
+                return (v & 1) == 0 ? Flowable.<Integer>empty() : Flowable.just(v);
+            }
+        }, 16)
+        .subscribe(ts);
+        
+        ts.assertValueCount(2 * Flowable.bufferSize());
+        ts.assertNoErrors();
+        ts.assertComplete();
+        
+        int j = 1;
+        for (Integer v : ts.values()) {
+            Assert.assertEquals(j, v.intValue());
+            
+            j += 2;
+        }
+    }
+
+    @Test
+    public void rangeEmptyMixtureMaxConcurrent() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.range(0, 4 * Flowable.bufferSize())
+        .flatMap(new Function<Integer, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer v) {
+                return (v & 1) == 0 ? Flowable.<Integer>empty() : Flowable.range(v, 2);
+            }
+        }, 16)
+        .subscribe(ts);
+        
+        ts.assertValueCount(4 * Flowable.bufferSize());
+        ts.assertNoErrors();
+        ts.assertComplete();
+        
+        int j = 1;
+        List<Integer> list = ts.values();
+        for (int i = 0; i < list.size(); i += 2) {
+            Assert.assertEquals(j, list.get(i).intValue());
+            Assert.assertEquals(j + 1, list.get(i + 1).intValue());
+            
+            j += 2;
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
index 3188c9a76f..e68e79ebf7 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
@@ -118,7 +118,7 @@ public void accept(String t1) {
                 assertTrue(correctThreadName);
             }
 
-        }).finallyDo(new Runnable() {
+        }).doAfterTerminate(new Runnable() {
 
             @Override
             public void run() {
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRangeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRangeTest.java
index a711f57141..67d945e7cb 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableRangeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRangeTest.java
@@ -267,4 +267,15 @@ public void testNearMaxValueWithBackpressure() {
         ts.assertNoErrors();
         ts.assertValues(Integer.MAX_VALUE - 1, Integer.MAX_VALUE);
     }
+    
+
+    @Test
+    public void negativeCount() {
+        try {
+            Flowable.range(1, -1);
+            fail("Should have thrown IllegalArgumentException");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("count >= 0 required but it was -1", ex.getMessage());
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java
index 5613096ad9..206eac3d58 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSingleTest.java
@@ -18,15 +18,15 @@
 import static org.mockito.Mockito.*;
 
 import java.util.*;
-import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.*;
 
-import org.junit.Test;
+import org.junit.*;
 import org.mockito.InOrder;
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
 import io.reactivex.functions.*;
-import io.reactivex.subscribers.DefaultObserver;
+import io.reactivex.subscribers.*;
 
 public class FlowableSingleTest {
 
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableFutureTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableFutureTest.java
index 0c1d0c50b2..bbee37e8e8 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableFutureTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableFutureTest.java
@@ -138,4 +138,87 @@ public Object get(long timeout, TimeUnit unit) throws InterruptedException, Exec
         ts.assertNoValues();
         ts.assertNotComplete();
     }
+    
+    @Test
+    public void backpressure() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0);
+        
+        FutureTask<Integer> f = new FutureTask<Integer>(new Runnable() {
+            @Override
+            public void run() {
+                
+            }
+        }, 1);
+        
+        f.run();
+        
+        Flowable.fromFuture(f).subscribe(ts);
+        
+        ts.assertNoValues();
+        
+        ts.request(1);
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @Test
+    public void withTimeoutNoTimeout() {
+        FutureTask<Integer> task = new FutureTask<Integer>(new Runnable() {
+            @Override
+            public void run() {
+                
+            }
+        }, 1);
+        
+        task.run();
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.fromFuture(task, 1, TimeUnit.SECONDS).subscribe(ts);
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @Test
+    public void withTimeoutTimeout() {
+        FutureTask<Integer> task = new FutureTask<Integer>(new Runnable() {
+            @Override
+            public void run() {
+                
+            }
+        }, 1);
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.fromFuture(task, 10, TimeUnit.MILLISECONDS).subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertError(TimeoutException.class);
+        ts.assertNotComplete();
+    }
+    
+    @Test
+    public void withTimeoutNoTimeoutScheduler() {
+        FutureTask<Integer> task = new FutureTask<Integer>(new Runnable() {
+            @Override
+            public void run() {
+                
+            }
+        }, 1);
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.fromFuture(task, Schedulers.computation()).subscribe(ts);
+
+        task.run();
+
+        ts.awaitTerminalEvent(5, TimeUnit.SECONDS);
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableToSingleTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToSingleTest.java
new file mode 100644
index 0000000000..9a6213dcc5
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToSingleTest.java
@@ -0,0 +1,86 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.flowable;
+
+import java.util.NoSuchElementException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.junit.*;
+
+import io.reactivex.*;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class FlowableToSingleTest {
+
+    @Test
+    public void testJustSingleItemObservable() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        Single<String> single = Flowable.just("Hello World!").toSingle();
+        single.subscribe(subscriber);
+
+        subscriber.assertResult("Hello World!");
+    }
+
+    @Test
+    public void testErrorObservable() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        IllegalArgumentException error = new IllegalArgumentException("Error");
+        Single<String> single = Flowable.<String>error(error).toSingle();
+        single.subscribe(subscriber);
+
+        subscriber.assertError(error);
+    }
+
+    @Test
+    public void testJustTwoEmissionsObservableThrowsError() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        Single<String> single = Flowable.just("First", "Second").toSingle();
+        single.subscribe(subscriber);
+
+        subscriber.assertError(IndexOutOfBoundsException.class);
+    }
+
+    @Test
+    public void testEmptyObservable() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        Single<String> single = Flowable.<String>empty().toSingle();
+        single.subscribe(subscriber);
+
+        subscriber.assertError(NoSuchElementException.class);
+    }
+
+    @Test
+    public void testRepeatObservableThrowsError() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        Single<String> single = Flowable.just("First", "Second").repeat().toSingle();
+        single.subscribe(subscriber);
+
+        subscriber.assertError(IndexOutOfBoundsException.class);
+    }
+    
+    @Test
+    public void testShouldUseUnsafeSubscribeInternallyNotSubscribe() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        final AtomicBoolean unsubscribed = new AtomicBoolean(false);
+        Single<String> single = Flowable.just("Hello World!").doOnCancel(new Runnable() {
+
+            @Override
+            public void run() {
+                unsubscribed.set(true);
+            }}).toSingle();
+        single.unsafeSubscribe(subscriber);
+        subscriber.assertComplete();
+        Assert.assertFalse(unsubscribed.get());
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
index 74c33980f8..11d35133a8 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
@@ -17,6 +17,7 @@
 import static org.mockito.Mockito.*;
 
 import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.*;
 import org.mockito.InOrder;
@@ -26,6 +27,7 @@
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableUsingTest {
 
@@ -431,4 +433,73 @@ public void run() {
         };
     }
     
+    @Test
+    public void factoryThrows() {
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        final AtomicInteger count = new AtomicInteger();
+        
+        Flowable.<Integer, Integer>using(
+                new Supplier<Integer>() {
+                    @Override
+                    public Integer get() {
+                        return 1;
+                    }
+                }, 
+                new Function<Integer, Flowable<Integer>>() {
+                    @Override
+                    public Flowable<Integer> apply(Integer v) { 
+                        throw new TestException("forced failure"); 
+                    }
+                }, 
+                new Consumer<Integer>() {
+                    @Override
+                    public void accept(Integer c) {
+                        count.incrementAndGet();
+                    }
+                }
+        )
+        .unsafeSubscribe(ts);
+        
+        ts.assertError(TestException.class);
+        
+        Assert.assertEquals(1, count.get());
+    }
+    
+    @Test
+    public void nonEagerTermination() {
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        final AtomicInteger count = new AtomicInteger();
+        
+        Flowable.<Integer, Integer>using(
+                new Supplier<Integer>() {
+                    @Override
+                    public Integer get() {
+                        return 1;
+                    }
+                }, 
+                new Function<Integer, Flowable<Integer>>() {
+                    @Override
+                    public Flowable<Integer> apply(Integer v) { 
+                        return Flowable.just(v);
+                    }
+                }, 
+                new Consumer<Integer>() {
+                    @Override
+                    public void accept(Integer c) {
+                        count.incrementAndGet();
+                    }
+                }, false
+        )
+        .unsafeSubscribe(ts);
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+        
+        Assert.assertEquals(1, count.get());
+    }
 }
\ No newline at end of file
