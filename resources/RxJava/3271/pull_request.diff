diff --git a/build.gradle b/build.gradle
index 58b0450096..9b9f91ab80 100644
--- a/build.gradle
+++ b/build.gradle
@@ -13,12 +13,16 @@ targetCompatibility = JavaVersion.VERSION_1_8
 
 dependencies {
     compile 'org.reactivestreams:reactive-streams:1.0.0'
-    testCompile 'junit:junit-dep:4.10'
-    testCompile 'org.mockito:mockito-core:1.8.5'
+    testCompile 'junit:junit:4.12'
+    testCompile 'org.mockito:mockito-core:1.10.19'
+
+    perfCompile 'org.openjdk.jmh:jmh-core:1.10.5'
+    perfCompile 'org.openjdk.jmh:jmh-generator-annprocess:1.10.5'
+    // perfCompile 'org.reactivex:rxjava:1.0.14'
 }
 
 javadoc {
-    exclude "**/rx/internal/**"
+    exclude "**/io/reactivex/internal/**"
 }
 
 // support for snapshot/final releases with the various branches RxJava uses
diff --git a/src/main/java/io/reactivex/exceptions/MissingBackpressureException.java b/src/main/java/io/reactivex/exceptions/MissingBackpressureException.java
new file mode 100644
index 0000000000..2251df0551
--- /dev/null
+++ b/src/main/java/io/reactivex/exceptions/MissingBackpressureException.java
@@ -0,0 +1,34 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.exceptions;
+
+/**
+ * Indicates that an operator attempted to emit a value but the downstream wasn't ready for it.
+ */
+public class MissingBackpressureException extends RuntimeException {
+    /** */
+    private static final long serialVersionUID = 8517344746016032542L;
+
+    public MissingBackpressureException() {
+        super();
+    }
+    
+    public MissingBackpressureException(String message) {
+        super(message);
+    }
+    
+    public MissingBackpressureException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorDoOnEach.java b/src/main/java/io/reactivex/internal/operators/OperatorDoOnEach.java
index 42c8edf6a2..1a10b6382d 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorDoOnEach.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorDoOnEach.java
@@ -38,8 +38,7 @@ public OperatorDoOnEach(Consumer<? super T> onNext,
     
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
-        // TODO Auto-generated method stub
-        return null;
+        return new DoOnEachSubscriber<>(t, onNext, onError, onComplete, onAfterTerminate);
     }
     
     static final class DoOnEachSubscriber<T> implements Subscriber<T> {
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorFlatMap.java b/src/main/java/io/reactivex/internal/operators/OperatorFlatMap.java
index d5891e7045..424e2a01d3 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorFlatMap.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorFlatMap.java
@@ -24,9 +24,10 @@
 
 import io.reactivex.Observable.Operator;
 import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.MissingBackpressureException;
 import io.reactivex.internal.queue.*;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.*;
-import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  * 
@@ -106,17 +107,17 @@ public MergeSubscriber(Subscriber<? super U> actual, Function<? super T, ? exten
         
         @Override
         public void onSubscribe(Subscription s) {
-            if (this.s != null) {
-                s.cancel();
-                RxJavaPlugins.onError(new IllegalStateException("Subscription already set!"));
+            if (SubscriptionHelper.validateSubscription(this.s, s)) {
                 return;
             }
             this.s = s;
             actual.onSubscribe(this);
-            if (maxConcurrency == Integer.MAX_VALUE) {
-                s.request(Long.MAX_VALUE);
-            } else {
-                s.request(maxConcurrency);
+            if (!cancelled) {
+                if (maxConcurrency == Integer.MAX_VALUE) {
+                    s.request(Long.MAX_VALUE);
+                } else {
+                    s.request(maxConcurrency);
+                }
             }
         }
         
@@ -137,6 +138,7 @@ public void onNext(T t) {
                 tryEmitScalar(((PublisherScalarSource<? extends U>)p).value());
             } else {
                 InnerSubscriber<T, U> inner = new InnerSubscriber<>(this, uniqueId++);
+                addInner(inner);
                 p.subscribe(inner);
             }
         }
@@ -189,6 +191,23 @@ void removeInner(InnerSubscriber<T, U> inner) {
             }
         }
         
+        Queue<U> getMainQueue() {
+            Queue<U> q = queue;
+            if (q == null) {
+                if (maxConcurrency == Integer.MAX_VALUE) {
+                    q = new SpscLinkedArrayQueue<>(bufferSize);
+                } else {
+                    if (Pow2.isPowerOfTwo(maxConcurrency)) {
+                        q = new SpscArrayQueue<>(maxConcurrency);
+                    } else {
+                        q = new SpscExactArrayQueue<>(maxConcurrency);
+                    }
+                }
+                queue = q;
+            }
+            return q;
+        }
+        
         void tryEmitScalar(U value) {
             if (get() == 0 && compareAndSet(0, 1)) {
                 long r = requested;
@@ -197,27 +216,17 @@ void tryEmitScalar(U value) {
                     if (r != Long.MAX_VALUE) {
                         REQUESTED.decrementAndGet(this);
                     }
-                    if (maxConcurrency != Integer.MAX_VALUE) {
+                    if (maxConcurrency != Integer.MAX_VALUE && !cancelled) {
                         s.request(1);
                     }
+                } else {
+                    
                 }
                 if (decrementAndGet() == 0) {
                     return;
                 }
             } else {
-                Queue<U> q = queue;
-                if (q == null) {
-                    if (maxConcurrency == Integer.MAX_VALUE) {
-                        q = new SpscLinkedArrayQueue<>(bufferSize);
-                    } else {
-                        if (Pow2.isPowerOfTwo(maxConcurrency)) {
-                            q = new SpscArrayQueue<>(maxConcurrency);
-                        } else {
-                            q = new SpscExactArrayQueue<>(maxConcurrency);
-                        }
-                    }
-                    queue = q;
-                }
+                Queue<U> q = getMainQueue();
                 if (!q.offer(value)) {
                     onError(new IllegalStateException("Scalar queue full?!"));
                     return;
@@ -229,6 +238,15 @@ void tryEmitScalar(U value) {
             drainLoop();
         }
         
+        Queue<U> getInnerQueue(InnerSubscriber<T, U> inner) {
+            Queue<U> q = inner.queue;
+            if (q == null) {
+                q = new SpscArrayQueue<>(bufferSize);
+                inner.queue = q;
+            }
+            return q;
+        }
+        
         void tryEmit(U value, InnerSubscriber<T, U> inner) {
             if (get() == 0 && compareAndSet(0, 1)) {
                 long r = requested;
@@ -238,6 +256,12 @@ void tryEmit(U value, InnerSubscriber<T, U> inner) {
                         REQUESTED.decrementAndGet(this);
                     }
                     inner.requestMore(1);
+                } else {
+                    Queue<U> q = getInnerQueue(inner);
+                    if (!q.offer(value)) {
+                        onError(new MissingBackpressureException("Inner queue full?!"));
+                        return;
+                    }
                 }
                 if (decrementAndGet() == 0) {
                     return;
@@ -249,7 +273,7 @@ void tryEmit(U value, InnerSubscriber<T, U> inner) {
                     inner.queue = q;
                 }
                 if (!q.offer(value)) {
-                    onError(new IllegalStateException("Inner queue full?!"));
+                    onError(new MissingBackpressureException("Inner queue full?!"));
                     return;
                 }
                 if (getAndIncrement() != 0) {
@@ -282,8 +306,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required"));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             BackpressureHelper.add(REQUESTED, this, n);
@@ -292,9 +315,13 @@ public void request(long n) {
         
         @Override
         public void cancel() {
-            cancelled = true;
-            s.cancel();
-            unsubscribe();
+            if (!cancelled) {
+                cancelled = true;
+                if (getAndIncrement() == 0) {
+                    s.cancel();
+                    unsubscribe();
+                }
+            }
         }
         
         void drain() {
@@ -305,6 +332,7 @@ void drain() {
         
         void drainLoop() {
             final Subscriber<? super U> child = this.actual;
+            int missed = 1;
             for (;;) {
                 if (checkTerminate()) {
                     return;
@@ -451,20 +479,23 @@ void drainLoop() {
                     lastId = inner[j].id;
                 }
                 
-                if (replenishMain != 0L) {
+                if (replenishMain != 0L && !cancelled) {
                     s.request(replenishMain);
                 }
                 if (innerCompleted) {
                     continue;
                 }
-                if (decrementAndGet() == 0) {
-                    return;
+                missed = addAndGet(-missed);
+                if (missed == 0) {
+                    break;
                 }
             }
         }
         
         boolean checkTerminate() {
             if (cancelled) {
+                s.cancel();
+                unsubscribe();
                 return true;
             }
             Queue<Throwable> e = errors;
@@ -533,15 +564,30 @@ void unsubscribe() {
         }
     }
     
-    static final class InnerSubscriber<T, U> implements Subscriber<U>, Disposable {
+    static final class InnerSubscriber<T, U> extends AtomicReference<Subscription> 
+    implements Subscriber<U>, Disposable {
+        /** */
+        private static final long serialVersionUID = -4606175640614850599L;
         final long id;
         final MergeSubscriber<T, U> parent;
-        Subscription s;
+        final int limit;
+        final int bufferSize;
+        
         volatile boolean done;
         volatile Queue<U> queue;
         int outstanding;
-        final int limit;
-        final int bufferSize;
+        
+        static final Subscription CANCELLED = new Subscription() {
+            @Override
+            public void request(long n) {
+                
+            }
+            
+            @Override
+            public void cancel() {
+                
+            }
+        };
         
         public InnerSubscriber(MergeSubscriber<T, U> parent, long id) {
             this.id = id;
@@ -551,14 +597,13 @@ public InnerSubscriber(MergeSubscriber<T, U> parent, long id) {
         }
         @Override
         public void onSubscribe(Subscription s) {
-            if (this.s != null) {
+            if (!compareAndSet(null, s)) {
                 s.cancel();
-                RxJavaPlugins.onError(new IllegalStateException("Subscription already set!"));
+                if (get() != CANCELLED) {
+                    SubscriptionHelper.reportSubscriptionSet();
+                }
                 return;
             }
-            this.s = s;
-            parent.addInner(this);
-            
             outstanding = bufferSize;
             s.request(outstanding);
         }
@@ -587,13 +632,19 @@ void requestMore(long n) {
             outstanding = bufferSize;
             int k = bufferSize - r;
             if (k > 0) {
-                s.request(k);
+                get().request(k);
             }
         }
         
         @Override
         public void dispose() {
-            s.cancel();
+            Subscription s = get();
+            if (s != CANCELLED) {
+                s = getAndSet(CANCELLED);
+                if (s != CANCELLED && s != null) {
+                    s.cancel();
+                }
+            }
         }
     }
     
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java
index 7f95206b47..284a834b89 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java
@@ -20,6 +20,7 @@
 
 import io.reactivex.Observable.Operator;
 import io.reactivex.Scheduler;
+import io.reactivex.exceptions.MissingBackpressureException;
 import io.reactivex.internal.queue.*;
 import io.reactivex.internal.schedulers.TrampolineScheduler;
 import io.reactivex.internal.util.*;
@@ -122,8 +123,12 @@ public void onSubscribe(Subscription s) {
         
         @Override
         public void onNext(T t) {
+            if (done) {
+                return;
+            }
             if (!queue.offer(t)) {
-                onError(new IllegalStateException("Queue full?!"));
+                s.cancel();
+                onError(new MissingBackpressureException("Queue full?!"));
                 return;
             }
             schedule();
@@ -131,6 +136,10 @@ public void onNext(T t) {
         
         @Override
         public void onError(Throwable t) {
+            if (done) {
+                RxJavaPlugins.onError(t);
+                return;
+            }
             error = t;
             done = true;
             schedule();
@@ -138,6 +147,9 @@ public void onError(Throwable t) {
         
         @Override
         public void onComplete() {
+            if (done) {
+                return;
+            }
             done = true;
             schedule();
         }
@@ -156,8 +168,10 @@ public void request(long n) {
         public void cancel() {
             if (!cancelled) {
                 cancelled = true;
-                s.cancel();
-                worker.dispose();
+                if (getAndIncrement() == 0) {
+                    s.cancel();
+                    worker.dispose();
+                }
             }
         }
         
@@ -218,6 +232,8 @@ public void run() {
         
         boolean checkTerminated(boolean d, boolean empty, Subscriber<? super T> a) {
             if (cancelled) {
+                s.cancel();
+                worker.dispose();
                 return true;
             }
             if (d) {
diff --git a/src/main/java/io/reactivex/internal/operators/PublisherLift.java b/src/main/java/io/reactivex/internal/operators/PublisherLift.java
index 7495872e9c..f800e57d73 100644
--- a/src/main/java/io/reactivex/internal/operators/PublisherLift.java
+++ b/src/main/java/io/reactivex/internal/operators/PublisherLift.java
@@ -57,10 +57,21 @@ public PublisherLift(Publisher<? extends T> source, Operator<? extends R, ? supe
     @Override
     public void subscribe(Subscriber<? super R> s) {
         try {
+            if (s == null) {
+                throw new NullPointerException("Operator " + operator + " received a null Subscriber");
+            }
             Subscriber<? super T> st = operator.apply(s);
-            
+
+            if (st == null) {
+                throw new NullPointerException("Operator " + operator + " returned a null Subscriber");
+            }
+
             st = RxJavaPlugins.onSubscribe(st);
-            
+
+            if (st == null) {
+                throw new NullPointerException("Plugin call for operator " + operator + " returned a null Subscriber");
+            }
+
             source.subscribe(st);
         } catch (NullPointerException e) {
             throw e;
diff --git a/src/main/java/io/reactivex/internal/operators/PublisherSubscribeOn.java b/src/main/java/io/reactivex/internal/operators/PublisherSubscribeOn.java
index 5331521203..6cc55e5d7a 100644
--- a/src/main/java/io/reactivex/internal/operators/PublisherSubscribeOn.java
+++ b/src/main/java/io/reactivex/internal/operators/PublisherSubscribeOn.java
@@ -18,6 +18,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Scheduler;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class PublisherSubscribeOn<T> implements Publisher<T> {
@@ -95,8 +96,7 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (Thread.currentThread() == get()) {
diff --git a/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java b/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java
index 4113ebef88..52eda3964f 100644
--- a/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java
+++ b/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java
@@ -29,6 +29,9 @@
     
     static final Object DONE = new Object();
     
+    static final int PARENT_INDEX = 0;
+    static final int FUTURE_INDEX = 1;
+    
     /**
      * Creates a ScheduledRunnable by wrapping the given action and setting
      * up the optional parent.
@@ -49,19 +52,19 @@ public void run() {
         } catch (Throwable e) {
             RxJavaPlugins.onError(e);
         } finally {
-            Object o = get(0);
+            Object o = get(PARENT_INDEX);
             if (o != DISPOSED && o != null) {
                 // done races with dispose here
-                if (compareAndSet(0, o, DONE)) {
+                if (compareAndSet(PARENT_INDEX, o, DONE)) {
                     ((CompositeResource<Disposable>)o).delete(this);
                 }
             }
             
             for (;;) {
-                o = get(1);
+                o = get(FUTURE_INDEX);
                 if (o != DISPOSED) {
                     // o is either null or a future
-                    if (compareAndSet(1, o, DONE)) {
+                    if (compareAndSet(FUTURE_INDEX, o, DONE)) {
                         break;
                     }
                 }
@@ -71,7 +74,7 @@ public void run() {
     
     public void setFuture(Future<?> f) {
         for (;;) {
-            Object o = get(1);
+            Object o = get(FUTURE_INDEX);
             if (o == DONE) {
                 return;
             }
@@ -79,7 +82,7 @@ public void setFuture(Future<?> f) {
                 f.cancel(true);
                 return;
             }
-            if (compareAndSet(1, o, f)) {
+            if (compareAndSet(FUTURE_INDEX, o, f)) {
                 return;
             }
         }
@@ -90,18 +93,18 @@ public void setFuture(Future<?> f) {
      * @return true if this ScheduledRunnable has been scheduled.
      */
     public boolean wasScheduled() {
-        return get(1) != null;
+        return get(FUTURE_INDEX) != null;
     }
     
     @Override
     @SuppressWarnings("unchecked")
     public void dispose() {
         for (;;) {
-            Object o = get(1);
+            Object o = get(FUTURE_INDEX);
             if (o == DONE || o == DISPOSED) {
                 break;
             }
-            if (compareAndSet(1, o, DISPOSED)) {
+            if (compareAndSet(FUTURE_INDEX, o, DISPOSED)) {
                 if (o != null) {
                     ((Future<?>)o).cancel(true);
                 }
@@ -110,12 +113,13 @@ public void dispose() {
         }
         
         for (;;) {
-            Object o = get(0);
+            Object o = get(PARENT_INDEX);
             if (o == DONE || o == DISPOSED || o == null) {
                 break;
             }
-            if (compareAndSet(1, o, DISPOSED)) {
+            if (compareAndSet(PARENT_INDEX, o, DISPOSED)) {
                 ((CompositeResource<Disposable>)o).delete(this);
+                return;
             }
         }
     }
diff --git a/src/main/java/io/reactivex/internal/util/Exceptions.java b/src/main/java/io/reactivex/internal/util/Exceptions.java
index 05d07d040d..043f7b59f6 100644
--- a/src/main/java/io/reactivex/internal/util/Exceptions.java
+++ b/src/main/java/io/reactivex/internal/util/Exceptions.java
@@ -1,3 +1,16 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
 package io.reactivex.internal.util;
 
 public enum Exceptions {
diff --git a/src/main/java/io/reactivex/internal/util/Pow2.java b/src/main/java/io/reactivex/internal/util/Pow2.java
index 54e65f1d97..d0d036bc27 100644
--- a/src/main/java/io/reactivex/internal/util/Pow2.java
+++ b/src/main/java/io/reactivex/internal/util/Pow2.java
@@ -1,16 +1,18 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
  * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
  * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+
+/*
  * Original License: https://github.com/JCTools/JCTools/blob/master/LICENSE
  * Original location: https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/util/Pow2.java
  */
diff --git a/src/main/java/io/reactivex/internal/util/QueueDrain.java b/src/main/java/io/reactivex/internal/util/QueueDrain.java
index ae70021474..8ed411139b 100644
--- a/src/main/java/io/reactivex/internal/util/QueueDrain.java
+++ b/src/main/java/io/reactivex/internal/util/QueueDrain.java
@@ -1,3 +1,16 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
 package io.reactivex.internal.util;
 
 import java.util.Queue;
diff --git a/src/main/java/io/reactivex/subscribers/AsyncObserver.java b/src/main/java/io/reactivex/subscribers/AsyncObserver.java
index 6bd9547229..821e4cd191 100644
--- a/src/main/java/io/reactivex/subscribers/AsyncObserver.java
+++ b/src/main/java/io/reactivex/subscribers/AsyncObserver.java
@@ -115,7 +115,7 @@ public final boolean supportsResources() {
     
     @Override
     public final void onSubscribe(Subscription s) {
-        if (S.compareAndSet(this, null, s)) {
+        if (!S.compareAndSet(this, null, s)) {
             s.cancel();
             if (s != CANCELLED) {
                 SubscriptionHelper.reportSubscriptionSet();
@@ -137,7 +137,7 @@ public final void onSubscribe(Subscription s) {
      * implementation requests Long.MAX_VALUE from upstream.
      */
     protected void onStart() {
-        s.request(Long.MAX_VALUE);
+        request(Long.MAX_VALUE);
     }
     
     /**
@@ -162,6 +162,8 @@ protected final void request(long n) {
                     a.request(mr);
                 }
             }
+        } else {
+            a.request(n);
         }
     }
     
diff --git a/src/main/java/io/reactivex/subscribers/TestSubscriber.java b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
index 0582c6f5c4..4253244109 100644
--- a/src/main/java/io/reactivex/subscribers/TestSubscriber.java
+++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
@@ -404,7 +404,7 @@ public void assertNotComplete() {
     /**
      * Assert that this TestSubscriber has not received any onError event.
      */
-    public void assertNoError() {
+    public void assertNoErrors() {
         String prefix = "";
         if (done.getCount() != 0) {
             prefix = "Subscriber still running! ";
diff --git a/src/test/java/io/reactivex/BackpressureTests.java b/src/test/java/io/reactivex/BackpressureTests.java
new file mode 100644
index 0000000000..2d0b21cacd
--- /dev/null
+++ b/src/test/java/io/reactivex/BackpressureTests.java
@@ -0,0 +1,677 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex;
+
+import static org.junit.Assert.*;
+
+import java.util.List;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+import java.util.function.Function;
+
+import org.junit.*;
+import org.junit.rules.TestName;
+import org.reactivestreams.*;
+
+import io.reactivex.exceptions.MissingBackpressureException;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
+import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subscribers.*;
+
+public class BackpressureTests {
+
+    private static final class FirehoseNoBackpressure extends AtomicBoolean implements Subscription {
+        /** */
+        private static final long serialVersionUID = -669931580197884015L;
+        final Subscriber<? super Integer> s;
+        private final AtomicInteger counter;
+        volatile boolean cancelled;
+
+        private FirehoseNoBackpressure(AtomicInteger counter, Subscriber<? super Integer> s) {
+            this.counter = counter;
+            this.s = s;
+        }
+
+        @Override
+        public void request(long n) {
+            if (SubscriptionHelper.validateRequest(n)) {
+                return;
+            }
+            if (compareAndSet(false, true)) {
+                int i = 0;
+                while (!cancelled) {
+                    s.onNext(i++);
+                    counter.incrementAndGet();
+                }
+                System.out.println("unsubscribed after: " + i);
+            }
+        }
+
+        @Override
+        public void cancel() {
+            cancelled = true;
+        }
+    }
+
+    @Rule
+    public TestName testName = new TestName();
+
+    @After
+    public void doAfterTest() {
+        // FIXME LATER
+//        TestObstructionDetection.checkObstruction();
+    }
+    
+    @Test
+    public void testObserveOn() {
+        int NUM = (int) (Observable.bufferSize() * 2.1);
+        AtomicInteger c = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        incrementingIntegers(c).observeOn(Schedulers.computation()).take(NUM).subscribe(ts);
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        System.out.println("testObserveOn => Received: " + ts.valueCount() + "  Emitted: " + c.get());
+        assertEquals(NUM, ts.valueCount());
+        assertTrue(c.get() < Observable.bufferSize() * 4);
+    }
+
+    @Test
+    public void testObserveOnWithSlowConsumer() {
+        int NUM = (int) (Observable.bufferSize() * 0.2);
+        AtomicInteger c = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        incrementingIntegers(c).observeOn(Schedulers.computation()).map(
+            i -> {
+                try {
+                    Thread.sleep(1);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                return i;
+            }
+        ).take(NUM).subscribe(ts);
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        System.out.println("testObserveOnWithSlowConsumer => Received: " + ts.valueCount() + "  Emitted: " + c.get());
+        assertEquals(NUM, ts.valueCount());
+        assertTrue(c.get() < Observable.bufferSize() * 2);
+    }
+
+    @Test
+    public void testMergeSync() {
+        int NUM = (int) (Observable.bufferSize() * 4.1);
+        AtomicInteger c1 = new AtomicInteger();
+        AtomicInteger c2 = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        Observable<Integer> merged = Observable.merge(incrementingIntegers(c1), incrementingIntegers(c2));
+
+        merged.take(NUM).subscribe(ts);
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        System.out.println("Expected: " + NUM + " got: " + ts.valueCount());
+        System.out.println("testMergeSync => Received: " + ts.valueCount() + "  Emitted: " + c1.get() + " / " + c2.get());
+        assertEquals(NUM, ts.valueCount());
+        // either one can starve the other, but neither should be capable of doing more than 5 batches (taking 4.1)
+        // TODO is it possible to make this deterministic rather than one possibly starving the other?
+        // benjchristensen => In general I'd say it's not worth trying to make it so, as "fair" algoritms generally take a performance hit
+        assertTrue(c1.get() < Observable.bufferSize() * 5);
+        assertTrue(c2.get() < Observable.bufferSize() * 5);
+    }
+
+    @Test
+    public void testMergeAsync() {
+        int NUM = (int) (Observable.bufferSize() * 4.1);
+        AtomicInteger c1 = new AtomicInteger();
+        AtomicInteger c2 = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        Observable<Integer> merged = Observable.merge(
+                incrementingIntegers(c1).subscribeOn(Schedulers.computation()),
+                incrementingIntegers(c2).subscribeOn(Schedulers.computation()));
+
+        merged.take(NUM).subscribe(ts);
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        System.out.println("testMergeAsync => Received: " + ts.valueCount() + "  Emitted: " + c1.get() + " / " + c2.get());
+        assertEquals(NUM, ts.valueCount());
+        // either one can starve the other, but neither should be capable of doing more than 5 batches (taking 4.1)
+        // TODO is it possible to make this deterministic rather than one possibly starving the other?
+        // benjchristensen => In general I'd say it's not worth trying to make it so, as "fair" algoritms generally take a performance hit
+        int max = Observable.bufferSize() * 7;
+        assertTrue("" + c1.get() + " >= " + max, c1.get() < max);
+        assertTrue("" + c2.get() + " >= " + max, c2.get() < max);
+    }
+
+    @Test
+    public void testMergeAsyncThenObserveOnLoop() {
+        for (int i = 0; i < 500; i++) {
+            if (i % 10 == 0) {
+                System.out.println("testMergeAsyncThenObserveOnLoop >> " + i);
+            }
+            // Verify there is no MissingBackpressureException
+            int NUM = (int) (Observable.bufferSize() * 4.1);
+            AtomicInteger c1 = new AtomicInteger();
+            AtomicInteger c2 = new AtomicInteger();
+            
+            TestSubscriber<Integer> ts = new TestSubscriber<>();
+            Observable<Integer> merged = Observable.merge(
+                    incrementingIntegers(c1).subscribeOn(Schedulers.computation()),
+                    incrementingIntegers(c2).subscribeOn(Schedulers.computation()));
+
+            merged
+            .observeOn(Schedulers.io())
+            .take(NUM)
+            .subscribe(ts);
+            
+            
+            ts.awaitTerminalEvent(5, TimeUnit.SECONDS);
+            ts.assertComplete();
+            ts.assertNoErrors();
+            System.out.println("testMergeAsyncThenObserveOn => Received: " + ts.valueCount() + "  Emitted: " + c1.get() + " / " + c2.get());
+            assertEquals(NUM, ts.valueCount());
+        }
+    }
+    
+    @Test
+    public void testMergeAsyncThenObserveOn() {
+        int NUM = (int) (Observable.bufferSize() * 4.1);
+        AtomicInteger c1 = new AtomicInteger();
+        AtomicInteger c2 = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        Observable<Integer> merged = Observable.merge(
+                incrementingIntegers(c1).subscribeOn(Schedulers.computation()),
+                incrementingIntegers(c2).subscribeOn(Schedulers.computation()));
+
+        merged.observeOn(Schedulers.newThread()).take(NUM).subscribe(ts);
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        System.out.println("testMergeAsyncThenObserveOn => Received: " + ts.valueCount() + "  Emitted: " + c1.get() + " / " + c2.get());
+        assertEquals(NUM, ts.valueCount());
+        // either one can starve the other, but neither should be capable of doing more than 5 batches (taking 4.1)
+        // TODO is it possible to make this deterministic rather than one possibly starving the other?
+        // benjchristensen => In general I'd say it's not worth trying to make it so, as "fair" algoritms generally take a performance hit
+        // akarnokd => run this in a loop over 10k times and never saw values get as high as 7*SIZE, but since observeOn delays the unsubscription non-deterministically, the test will remain unreliable
+        assertTrue(c1.get() < Observable.bufferSize() * 7);
+        assertTrue(c2.get() < Observable.bufferSize() * 7);
+    }
+
+    @Test
+    public void testFlatMapSync() {
+        int NUM = (int) (Observable.bufferSize() * 2.1);
+        AtomicInteger c = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        
+        incrementingIntegers(c)
+        .flatMap(i -> incrementingIntegers(new AtomicInteger()).take(10))
+        .take(NUM).subscribe(ts);
+        
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        System.out.println("testFlatMapSync => Received: " + ts.valueCount() + "  Emitted: " + c.get());
+        assertEquals(NUM, ts.valueCount());
+        // expect less than 1 buffer since the flatMap is emitting 10 each time, so it is NUM/10 that will be taken.
+        assertTrue(c.get() < Observable.bufferSize());
+    }
+
+    @Test
+    @Ignore // the test is non-deterministic and can't be made deterministic
+    public void testFlatMapAsync() {
+        int NUM = (int) (Observable.bufferSize() * 2.1);
+        AtomicInteger c = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        
+        incrementingIntegers(c)
+        .subscribeOn(Schedulers.computation())
+        .flatMap(i -> incrementingIntegers(new AtomicInteger())
+                .take(10)
+                .subscribeOn(Schedulers.computation())
+        )
+        .take(NUM).subscribe(ts);
+        
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        System.out.println("testFlatMapAsync => Received: " + ts.valueCount() + "  Emitted: " + c.get() + " Size: " + Observable.bufferSize());
+        assertEquals(NUM, ts.valueCount());
+        // even though we only need 10, it will request at least Observable.bufferSize(), and then as it drains keep requesting more
+        // and then it will be non-deterministic when the take() causes the unsubscribe as it is scheduled on 10 different schedulers (threads)
+        // normally this number is ~250 but can get up to ~1200 when Observable.bufferSize() == 1024
+        assertTrue(c.get() <= Observable.bufferSize() * 2);
+    }
+
+    @Test
+    public void testZipSync() {
+        int NUM = (int) (Observable.bufferSize() * 4.1);
+        AtomicInteger c1 = new AtomicInteger();
+        AtomicInteger c2 = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        
+        Observable<Integer> zipped = Observable.zip(
+                incrementingIntegers(c1),
+                incrementingIntegers(c2),
+                (t1, t2) -> t1 + t2);
+
+        zipped.take(NUM)
+        .subscribe(ts);
+        
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        System.out.println("testZipSync => Received: " + ts.valueCount() + "  Emitted: " + c1.get() + " / " + c2.get());
+        assertEquals(NUM, ts.valueCount());
+        assertTrue(c1.get() < Observable.bufferSize() * 7);
+        assertTrue(c2.get() < Observable.bufferSize() * 7);
+    }
+
+    @Test
+    public void testZipAsync() {
+        int NUM = (int) (Observable.bufferSize() * 2.1);
+        AtomicInteger c1 = new AtomicInteger();
+        AtomicInteger c2 = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        Observable<Integer> zipped = Observable.zip(
+                incrementingIntegers(c1).subscribeOn(Schedulers.computation()),
+                incrementingIntegers(c2).subscribeOn(Schedulers.computation()),
+                (t1, t2) -> t1 + t2);
+
+        zipped.take(NUM).subscribe(ts);
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        System.out.println("testZipAsync => Received: " + ts.valueCount() + "  Emitted: " + c1.get() + " / " + c2.get());
+        assertEquals(NUM, ts.valueCount());
+        int max = Observable.bufferSize() * 5;
+        assertTrue("" + c1.get() + " >= " + max, c1.get() < max);
+        assertTrue("" + c2.get() + " >= " + max, c2.get() < max);
+    }
+
+    @Test
+    public void testSubscribeOnScheduling() {
+        // in a loop for repeating the concurrency in this to increase chance of failure
+        for (int i = 0; i < 100; i++) {
+            int NUM = (int) (Observable.bufferSize() * 2.1);
+            AtomicInteger c = new AtomicInteger();
+            ConcurrentLinkedQueue<Thread> threads = new ConcurrentLinkedQueue<>();
+            TestSubscriber<Integer> ts = new TestSubscriber<>();
+            // observeOn is there to make it async and need backpressure
+            incrementingIntegers(c, threads).subscribeOn(Schedulers.computation()).observeOn(Schedulers.computation()).take(NUM).subscribe(ts);
+            ts.awaitTerminalEvent();
+            ts.assertNoErrors();
+            System.out.println("testSubscribeOnScheduling => Received: " + ts.valueCount() + "  Emitted: " + c.get());
+            assertEquals(NUM, ts.valueCount());
+            assertTrue(c.get() < Observable.bufferSize() * 4);
+            Thread first = null;
+            for (Thread t : threads) {
+                System.out.println("testSubscribeOnScheduling => thread: " + t);
+                if (first == null) {
+                    first = t;
+                } else {
+                    if (!first.equals(t)) {
+                        fail("Expected to see the same thread");
+                    }
+                }
+            }
+            System.out.println("testSubscribeOnScheduling => Number of batch requests seen: " + threads.size());
+            assertTrue(threads.size() > 1);
+            System.out.println("-------------------------------------------------------------------------------------------");
+        }
+    }
+
+    @Test
+    public void testTakeFilterSkipChainAsync() {
+        int NUM = (int) (Observable.bufferSize() * 2.1);
+        AtomicInteger c = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        incrementingIntegers(c).observeOn(Schedulers.computation())
+                .skip(10000)
+                .filter(i -> i > 11000).take(NUM).subscribe(ts);
+
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+
+        // emit 10000 that are skipped
+        // emit next 1000 that are filtered out
+        // take NUM
+        // so emitted is at least 10000+1000+NUM + extra for buffer size/threshold
+        int expected = 10000 + 1000 + Observable.bufferSize() * 3 + Observable.bufferSize() / 2;
+
+        System.out.println("testTakeFilterSkipChain => Received: " + ts.valueCount() + "  Emitted: " + c.get() + " Expected: " + expected);
+        assertEquals(NUM, ts.valueCount());
+        assertTrue(c.get() < expected);
+    }
+
+    @Test
+    public void testUserSubscriberUsingRequestSync() {
+        AtomicInteger c = new AtomicInteger();
+        final AtomicInteger totalReceived = new AtomicInteger();
+        final AtomicInteger batches = new AtomicInteger();
+        final AtomicInteger received = new AtomicInteger();
+        incrementingIntegers(c).subscribe(new AsyncObserver<Integer>() {
+
+            @Override
+            public void onStart() {
+                request(100);
+            }
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+
+            }
+
+            @Override
+            public void onNext(Integer t) {
+                int total = totalReceived.incrementAndGet();
+                received.incrementAndGet();
+                if (total >= 2000) {
+                    cancel();
+                }
+                if (received.get() == 100) {
+                    batches.incrementAndGet();
+                    request(100);
+                    received.set(0);
+                }
+            }
+
+        });
+
+        System.out.println("testUserSubscriberUsingRequestSync => Received: " + totalReceived.get() + "  Emitted: " + c.get() + " Request Batches: " + batches.get());
+        assertEquals(2000, c.get());
+        assertEquals(2000, totalReceived.get());
+        assertEquals(20, batches.get());
+    }
+
+    @Test
+    public void testUserSubscriberUsingRequestAsync() throws InterruptedException {
+        AtomicInteger c = new AtomicInteger();
+        final AtomicInteger totalReceived = new AtomicInteger();
+        final AtomicInteger received = new AtomicInteger();
+        final AtomicInteger batches = new AtomicInteger();
+        final CountDownLatch latch = new CountDownLatch(1);
+        incrementingIntegers(c).subscribeOn(Schedulers.newThread()).subscribe(
+                new AsyncObserver<Integer>() {
+
+            @Override
+            public void onStart() {
+                request(100);
+            }
+
+            @Override
+            public void onComplete() {
+                latch.countDown();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                latch.countDown();
+            }
+
+            @Override
+            public void onNext(Integer t) {
+                int total = totalReceived.incrementAndGet();
+                received.incrementAndGet();
+                boolean done = false;
+                if (total >= 2000) {
+                    done = true;
+                    cancel();
+                }
+                if (received.get() == 100) {
+                    batches.incrementAndGet();
+                    received.set(0);
+                    if (!done) {
+                        request(100);
+                    }
+                }
+                if (done) {
+                    latch.countDown();
+                }
+            }
+
+        });
+
+        latch.await();
+        System.out.println("testUserSubscriberUsingRequestAsync => Received: " + totalReceived.get() + "  Emitted: " + c.get() + " Request Batches: " + batches.get());
+        assertEquals(2000, c.get());
+        assertEquals(2000, totalReceived.get());
+        assertEquals(20, batches.get());
+    }
+
+    @Test(timeout = 2000)
+    public void testFirehoseFailsAsExpected() {
+        AtomicInteger c = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        
+        firehose(c).observeOn(Schedulers.computation()).map(SLOW_PASS_THRU).subscribe(ts);
+        
+        ts.awaitTerminalEvent();
+        System.out.println("testFirehoseFailsAsExpected => Received: " + ts.valueCount() + "  Emitted: " + c.get());
+        
+        // FIXME it is possible slow is not slow enough or the main gets delayed and thus more than one source value is emitted.
+        int vc = ts.valueCount();
+        assertTrue("10 < " + vc, vc <= 10);
+        
+        ts.assertError(MissingBackpressureException.class);
+    }
+
+    @Test(timeout = 10000)
+    public void testOnBackpressureDrop() {
+        long t = System.currentTimeMillis();
+        for (int i = 0; i < 100; i++) {
+            // stop the test if we are getting close to the timeout because slow machines 
+            // may not get through 100 iterations
+            if (System.currentTimeMillis() - t > TimeUnit.SECONDS.toMillis(9)) {
+                break;
+            }
+            int NUM = (int) (Observable.bufferSize() * 1.1); // > 1 so that take doesn't prevent buffer overflow
+            AtomicInteger c = new AtomicInteger();
+            TestSubscriber<Integer> ts = new TestSubscriber<>();
+            firehose(c).onBackpressureDrop()
+            .observeOn(Schedulers.computation())
+            .map(SLOW_PASS_THRU).take(NUM).subscribe(ts);
+            ts.awaitTerminalEvent();
+            ts.assertNoErrors();
+
+            List<Integer> onNextEvents = ts.values();
+            assertEquals(NUM, onNextEvents.size());
+
+            Integer lastEvent = onNextEvents.get(NUM - 1);
+
+            System.out.println("testOnBackpressureDrop => Received: " + onNextEvents.size() + "  Emitted: " + c.get() + " Last value: " + lastEvent);
+            // it drop, so we should get some number far higher than what would have sequentially incremented
+            assertTrue(NUM - 1 <= lastEvent.intValue());
+        }
+    }
+
+    @Test(timeout = 20000)
+    public void testOnBackpressureDropWithAction() {
+        for (int i = 0; i < 100; i++) {
+            final AtomicInteger emitCount = new AtomicInteger();
+            final AtomicInteger dropCount = new AtomicInteger();
+            final AtomicInteger passCount = new AtomicInteger();
+            final int NUM = Observable.bufferSize() * 3; // > 1 so that take doesn't prevent buffer overflow
+            TestSubscriber<Integer> ts = new TestSubscriber<>();
+            
+            firehose(emitCount)
+            .onBackpressureDrop(v -> dropCount.incrementAndGet())
+            .doOnNext(v -> passCount.incrementAndGet())
+            .observeOn(Schedulers.computation())
+            .map(SLOW_PASS_THRU)
+            .take(NUM).subscribe(ts);
+            
+            ts.awaitTerminalEvent();
+            ts.assertNoErrors();
+            
+            List<Integer> onNextEvents = ts.values();
+            Integer lastEvent = onNextEvents.get(NUM - 1);
+            System.out.println(testName.getMethodName() + " => Received: " + onNextEvents.size() + " Passed: " + passCount.get() + " Dropped: " + dropCount.get() + "  Emitted: " + emitCount.get() + " Last value: " + lastEvent);
+            assertEquals(NUM, onNextEvents.size());
+            // in reality, NUM < passCount
+            assertTrue(NUM <= passCount.get());
+            // it drop, so we should get some number far higher than what would have sequentially incremented
+            assertTrue(NUM - 1 <= lastEvent.intValue());
+            assertTrue(0 < dropCount.get());
+            assertEquals(emitCount.get(), passCount.get() + dropCount.get());
+        }
+    }
+
+    @Test(timeout = 10000)
+    public void testOnBackpressureDropSynchronous() {
+        for (int i = 0; i < 100; i++) {
+            int NUM = (int) (Observable.bufferSize() * 1.1); // > 1 so that take doesn't prevent buffer overflow
+            AtomicInteger c = new AtomicInteger();
+            TestSubscriber<Integer> ts = new TestSubscriber<>();
+            firehose(c).onBackpressureDrop()
+            .map(SLOW_PASS_THRU).take(NUM).subscribe(ts);
+            ts.awaitTerminalEvent();
+            ts.assertNoErrors();
+
+            List<Integer> onNextEvents = ts.values();
+            assertEquals(NUM, onNextEvents.size());
+
+            Integer lastEvent = onNextEvents.get(NUM - 1);
+
+            System.out.println("testOnBackpressureDrop => Received: " + onNextEvents.size() + "  Emitted: " + c.get() + " Last value: " + lastEvent);
+            // it drop, so we should get some number far higher than what would have sequentially incremented
+            assertTrue(NUM - 1 <= lastEvent.intValue());
+        }
+    }
+
+    @Test(timeout = 10000)
+    public void testOnBackpressureDropSynchronousWithAction() {
+        for (int i = 0; i < 100; i++) {
+            final AtomicInteger dropCount = new AtomicInteger();
+            int NUM = (int) (Observable.bufferSize() * 1.1); // > 1 so that take doesn't prevent buffer overflow
+            AtomicInteger c = new AtomicInteger();
+            TestSubscriber<Integer> ts = new TestSubscriber<>();
+            firehose(c).onBackpressureDrop(j -> dropCount.incrementAndGet())
+            .map(SLOW_PASS_THRU).take(NUM).subscribe(ts);
+            ts.awaitTerminalEvent();
+            ts.assertNoErrors();
+
+            List<Integer> onNextEvents = ts.values();
+            assertEquals(NUM, onNextEvents.size());
+
+            Integer lastEvent = onNextEvents.get(NUM - 1);
+
+            System.out.println("testOnBackpressureDrop => Received: " + onNextEvents.size() + " Dropped: " + dropCount.get() + "  Emitted: " + c.get() + " Last value: " + lastEvent);
+            // it drop, so we should get some number far higher than what would have sequentially incremented
+            assertTrue(NUM - 1 <= lastEvent.intValue());
+            // no drop in synchronous mode
+            assertEquals(0, dropCount.get());
+            assertEquals(c.get(), onNextEvents.size());
+        }
+    }
+
+    @Test(timeout = 2000)
+    public void testOnBackpressureBuffer() {
+        int NUM = (int) (Observable.bufferSize() * 1.1); // > 1 so that take doesn't prevent buffer overflow
+        AtomicInteger c = new AtomicInteger();
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        
+        firehose(c).takeWhile(t1 -> t1 < 100000)
+        .onBackpressureBuffer()
+        .observeOn(Schedulers.computation())
+        .map(SLOW_PASS_THRU).take(NUM).subscribe(ts);
+        
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        System.out.println("testOnBackpressureBuffer => Received: " + ts.valueCount() + "  Emitted: " + c.get());
+        assertEquals(NUM, ts.valueCount());
+        // it buffers, so we should get the right value sequentially
+        assertEquals(NUM - 1, ts.values().get(NUM - 1).intValue());
+    }
+
+    /**
+     * A synchronous Observable that will emit incrementing integers as requested.
+     * 
+     * @param counter
+     * @return
+     */
+    private static Observable<Integer> incrementingIntegers(final AtomicInteger counter) {
+        return incrementingIntegers(counter, null);
+    }
+
+    private static Observable<Integer> incrementingIntegers(final AtomicInteger counter, final ConcurrentLinkedQueue<Thread> threadsSeen) {
+        return Observable.create(new Publisher<Integer>() {
+
+            @Override
+            public void subscribe(final Subscriber<? super Integer> s) {
+                s.onSubscribe(new Subscription() {
+                    int i = 0;
+                    
+                    volatile boolean cancelled;
+
+                    final AtomicLong requested = new AtomicLong();
+
+                    @Override
+                    public void request(long n) {
+                        if (SubscriptionHelper.validateRequest(n)) {
+                            return;
+                        }
+                        if (threadsSeen != null) {
+                            threadsSeen.offer(Thread.currentThread());
+                        }
+                        long _c = BackpressureHelper.add(requested, n);
+                        if (_c == 0) {
+                            while (!cancelled) {
+                                counter.incrementAndGet();
+                                s.onNext(i++);
+                                if (requested.decrementAndGet() == 0) {
+                                    // we're done emitting the number requested so return
+                                    return;
+                                }
+                            }
+                        }
+                    }
+
+                    @Override
+                    public void cancel() {
+                        cancelled = true;
+                    }
+                });
+            }
+
+        });
+    }
+
+    /**
+     * Incrementing int without backpressure.
+     * 
+     * @param counter
+     * @return
+     */
+    private static Observable<Integer> firehose(final AtomicInteger counter) {
+        return Observable.create(s -> {
+            Subscription s2 = new FirehoseNoBackpressure(counter, s);
+            s.onSubscribe(s2);
+        });
+    }
+
+    final static Function<Integer, Integer> SLOW_PASS_THRU = new Function<Integer, Integer>() {
+        volatile int sink;
+        @Override
+        public Integer apply(Integer t1) {
+            // be slow ... but faster than Thread.sleep(1)
+            String t = "";
+            int s = sink;
+            for (int i = 5000; i >= 0; i--) {
+                t = String.valueOf(i + t.hashCode() + s);
+            }
+            sink = t.hashCode();
+            return t1;
+        }
+
+    };
+}
\ No newline at end of file
