diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java
index 583697d069..b27e163b63 100644
--- a/src/main/java/io/reactivex/Completable.java
+++ b/src/main/java/io/reactivex/Completable.java
@@ -14,7 +14,7 @@
 
 import java.util.concurrent.*;
 
-import org.reactivestreams.*;
+import org.reactivestreams.Publisher;
 
 import io.reactivex.annotations.SchedulerSupport;
 import io.reactivex.disposables.Disposable;
@@ -24,8 +24,9 @@
 import io.reactivex.internal.operators.completable.*;
 import io.reactivex.internal.operators.flowable.FlowableDelaySubscriptionOther;
 import io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther;
-import io.reactivex.internal.operators.single.*;
+import io.reactivex.internal.operators.single.SingleDelayWithCompletable;
 import io.reactivex.internal.subscribers.completable.*;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
@@ -197,7 +198,6 @@ public static Completable concat(Publisher<? extends CompletableSource> sources,
      * @param source the emitter that is called when a Subscriber subscribes to the returned {@code Flowable}
      * @return the new Completable instance
      * @see FlowableOnSubscribe
-     * @see FlowableEmitter.BackpressureMode
      * @see Cancellable
      */
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -1612,7 +1612,7 @@ private Completable timeout0(long timeout, TimeUnit unit, Scheduler scheduler, C
             return converter.apply(this);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 
diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java
index a8327ed449..d847c5fe3e 100644
--- a/src/main/java/io/reactivex/Flowable.java
+++ b/src/main/java/io/reactivex/Flowable.java
@@ -4848,7 +4848,7 @@ public final void blockingForEach(Consumer<? super T> onNext) {
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
                 ((Disposable)it).dispose();
-                throw Exceptions.propagate(e);
+                throw ExceptionHelper.wrapOrThrow(e);
             }
         }
     }
@@ -13181,7 +13181,7 @@ public final void subscribe(Subscriber<? super T> s) {
             return converter.apply(this);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 
diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java
index 648068da47..09f4092373 100644
--- a/src/main/java/io/reactivex/Observable.java
+++ b/src/main/java/io/reactivex/Observable.java
@@ -4346,7 +4346,7 @@ public final void blockingForEach(Consumer<? super T> onNext) {
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
                 ((Disposable)it).dispose();
-                throw Exceptions.propagate(e);
+                throw ExceptionHelper.wrapOrThrow(e);
             }
         }
     }
@@ -11154,7 +11154,7 @@ public final void subscribe(Observer<? super T> observer) {
             return converter.apply(this);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 
diff --git a/src/main/java/io/reactivex/Scheduler.java b/src/main/java/io/reactivex/Scheduler.java
index 02cd737f7c..09b1cea6b5 100644
--- a/src/main/java/io/reactivex/Scheduler.java
+++ b/src/main/java/io/reactivex/Scheduler.java
@@ -18,6 +18,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.disposables.SequentialDisposable;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
@@ -37,6 +38,16 @@
                 Long.getLong("rx2.scheduler.drift-tolerance", 15));
     }
 
+    /**
+     * Returns the clock drift tolerance in nanoseconds.
+     * <p>Related system property: {@code rx2.scheduler.drift-tolerance} in minutes
+     * @return the tolerance in nanoseconds
+     * @since 2.0
+     */
+    public static long clockDriftTolerance() {
+        return CLOCK_DRIFT_TOLERANCE_NANOSECONDS;
+    }
+    
     
     /**
      * Retrieves or creates a new {@link Scheduler.Worker} that represents serial execution of actions.
@@ -294,7 +305,7 @@ public void run() {
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
                     worker.dispose();
-                    throw Exceptions.propagate(ex);
+                    throw ExceptionHelper.wrapOrThrow(ex);
                 }
             }
         }
diff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java
index 9c642f55c5..880e57e39d 100644
--- a/src/main/java/io/reactivex/Single.java
+++ b/src/main/java/io/reactivex/Single.java
@@ -25,7 +25,7 @@
 import io.reactivex.internal.operators.flowable.*;
 import io.reactivex.internal.operators.single.*;
 import io.reactivex.internal.subscribers.single.*;
-import io.reactivex.internal.util.ErrorMode;
+import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
@@ -249,7 +249,6 @@
      * @param source the emitter that is called when a Subscriber subscribes to the returned {@code Flowable}
      * @return the new Single instance
      * @see FlowableOnSubscribe
-     * @see FlowableEmitter.BackpressureMode
      * @see Cancellable
      */
     public static <T> Single<T> create(SingleOnSubscribe<T> source) {
@@ -2366,7 +2365,7 @@ public final void subscribe(SingleObserver<? super T> subscriber) {
             return convert.apply(this);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 
diff --git a/src/main/java/io/reactivex/disposables/ActionDisposable.java b/src/main/java/io/reactivex/disposables/ActionDisposable.java
index 1cb56c51c2..e174ae999f 100644
--- a/src/main/java/io/reactivex/disposables/ActionDisposable.java
+++ b/src/main/java/io/reactivex/disposables/ActionDisposable.java
@@ -12,8 +12,8 @@
  */
 package io.reactivex.disposables;
 
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Action;
+import io.reactivex.internal.util.ExceptionHelper;
 
 final class ActionDisposable extends ReferenceDisposable<Action> {
     /** */
@@ -28,8 +28,7 @@ protected void onDisposed(Action value) {
         try {
             value.run();
         } catch (Throwable ex) {
-            Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 }
diff --git a/src/main/java/io/reactivex/disposables/CompositeDisposable.java b/src/main/java/io/reactivex/disposables/CompositeDisposable.java
index ed6197ff58..a646d81b96 100644
--- a/src/main/java/io/reactivex/disposables/CompositeDisposable.java
+++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java
@@ -17,7 +17,7 @@
 import io.reactivex.exceptions.*;
 import io.reactivex.internal.disposables.DisposableContainer;
 import io.reactivex.internal.functions.ObjectHelper;
-import io.reactivex.internal.util.OpenHashSet;
+import io.reactivex.internal.util.*;
 
 /**
  * A disposable container that can hold onto multiple other disposables and
@@ -54,6 +54,7 @@ public CompositeDisposable(Disposable... resources) {
      */
     public CompositeDisposable(Iterable<? extends Disposable> resources) {
         ObjectHelper.requireNonNull(resources, "resources is null");
+        this.resources = new OpenHashSet<Disposable>();
         for (Disposable d : resources) {
             ObjectHelper.requireNonNull(d, "Disposable item is null");
             this.resources.add(d);
@@ -193,7 +194,8 @@ public int size() {
             if (disposed) {
                 return 0;
             }
-            return resources.size();
+            OpenHashSet<Disposable> set = resources;
+            return set != null ? set.size() : 0;
         }
     }
     
@@ -223,7 +225,7 @@ void dispose(OpenHashSet<Disposable> set) {
         }
         if (errors != null) {
             if (errors.size() == 1) {
-                throw Exceptions.propagate(errors.get(0));
+                throw ExceptionHelper.wrapOrThrow(errors.get(0));
             }
             throw new CompositeException(errors);
         }
diff --git a/src/main/java/io/reactivex/disposables/SerialDisposable.java b/src/main/java/io/reactivex/disposables/SerialDisposable.java
index f4bfd4b471..9f0c59e1e7 100644
--- a/src/main/java/io/reactivex/disposables/SerialDisposable.java
+++ b/src/main/java/io/reactivex/disposables/SerialDisposable.java
@@ -81,6 +81,6 @@ public void dispose() {
     
     @Override
     public boolean isDisposed() {
-        return DisposableHelper.isDisposed(get());
+        return DisposableHelper.isDisposed(resource.get());
     }
 }
diff --git a/src/main/java/io/reactivex/exceptions/CompositeException.java b/src/main/java/io/reactivex/exceptions/CompositeException.java
index eb95c49841..25127c7a12 100644
--- a/src/main/java/io/reactivex/exceptions/CompositeException.java
+++ b/src/main/java/io/reactivex/exceptions/CompositeException.java
@@ -205,9 +205,7 @@ private void printStackTrace(PrintStreamOrWriter s) {
             appendStackTrace(b, ex, "\t");
             i++;
         }
-        synchronized (s.lock()) {
-            s.println(b.toString());
-        }
+        s.println(b.toString());
     }
 
     private void appendStackTrace(StringBuilder b, Throwable ex, String prefix) {
@@ -222,9 +220,6 @@ private void appendStackTrace(StringBuilder b, Throwable ex, String prefix) {
     }
 
     abstract static class PrintStreamOrWriter {
-        /** Returns the object to be locked when using this StreamOrWriter */
-        abstract Object lock();
-
         /** Prints the specified string as a line on this StreamOrWriter */
         abstract void println(Object o);
     }
@@ -239,11 +234,6 @@ private void appendStackTrace(StringBuilder b, Throwable ex, String prefix) {
             this.printStream = printStream;
         }
 
-        @Override
-        Object lock() {
-            return printStream;
-        }
-
         @Override
         void println(Object o) {
             printStream.println(o);
@@ -257,11 +247,6 @@ void println(Object o) {
             this.printWriter = printWriter;
         }
 
-        @Override
-        Object lock() {
-            return printWriter;
-        }
-
         @Override
         void println(Object o) {
             printWriter.println(o);
@@ -310,7 +295,7 @@ public int size() {
      * any suppressed exceptions.
      */
     public boolean isEmpty() {
-        return exceptions.isEmpty() && getCause() == null;
+        return exceptions.isEmpty();
     }
     
     /**
@@ -321,16 +306,15 @@ public boolean isEmpty() {
      */
     private Throwable getRootCause(Throwable e) {
         Throwable root = e.getCause();
-        if (root == null || root == e) {
+        if (root == null /* || cause == root */) { // case might not be possible
             return e;
-        } else {
-            while(true) {
-                Throwable cause = root.getCause();
-                if (cause == null || cause == root) {
-                    return root;
-                }
-                root = root.getCause();
+        }
+        while(true) {
+            Throwable cause = root.getCause();
+            if (cause == null /* || cause == root */) { // case might not be possible
+                return root;
             }
+            root = root.getCause();
         }
     }
 }
\ No newline at end of file
diff --git a/src/main/java/io/reactivex/exceptions/Exceptions.java b/src/main/java/io/reactivex/exceptions/Exceptions.java
index e48002dfed..4e3319c07a 100644
--- a/src/main/java/io/reactivex/exceptions/Exceptions.java
+++ b/src/main/java/io/reactivex/exceptions/Exceptions.java
@@ -13,6 +13,8 @@
 
 package io.reactivex.exceptions;
 
+import io.reactivex.internal.util.ExceptionHelper;
+
 /**
  * Utility class to help propagate checked exceptions and rethrow exceptions
  * designated as fatal.
@@ -39,13 +41,7 @@ public static RuntimeException propagate(Throwable t) {
          * Even though nothing will return and throw via that 'throw', it allows the code to look like it
          * so it's easy to read and understand that it will always result in a throw.
          */
-        if (t instanceof RuntimeException) {
-            throw (RuntimeException) t;
-        } else if (t instanceof Error) {
-            throw (Error) t;
-        } else {
-            throw new RuntimeException(t); // NOPMD
-        }
+        throw ExceptionHelper.wrapOrThrow(t);
     }
     
     /**
diff --git a/src/main/java/io/reactivex/exceptions/MissingBackpressureException.java b/src/main/java/io/reactivex/exceptions/MissingBackpressureException.java
index 5b33963cc3..d518ae4a89 100644
--- a/src/main/java/io/reactivex/exceptions/MissingBackpressureException.java
+++ b/src/main/java/io/reactivex/exceptions/MissingBackpressureException.java
@@ -16,7 +16,7 @@
 /**
  * Indicates that an operator attempted to emit a value but the downstream wasn't ready for it.
  */
-public class MissingBackpressureException extends RuntimeException {
+public final class MissingBackpressureException extends RuntimeException {
     /** */
     private static final long serialVersionUID = 8517344746016032542L;
 
@@ -24,7 +24,7 @@
      * Constructs a MissingBackpressureException without message or cause.
      */
     public MissingBackpressureException() {
-        super();
+        // no message
     }
     
     /**
@@ -35,12 +35,4 @@ public MissingBackpressureException(String message) {
         super(message);
     }
     
-    /**
-     * Constructs a MissingBackpressureException with the given message and cause.
-     * @param message the error message
-     * @param cause the cause Throwable
-     */
-    public MissingBackpressureException(String message, Throwable cause) {
-        super(message, cause);
-    }
 }
diff --git a/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java b/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java
index ccccc73b59..1f3d01325c 100644
--- a/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java
+++ b/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java
@@ -17,6 +17,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.*;
 import io.reactivex.internal.functions.ObjectHelper;
+import io.reactivex.internal.util.ExceptionHelper;
 
 /**
  * A disposable container that can hold onto multiple other disposables.
@@ -177,7 +178,7 @@ void dispose(List<Disposable> set) {
         }
         if (errors != null) {
             if (errors.size() == 1) {
-                throw Exceptions.propagate(errors.get(0));
+                throw ExceptionHelper.wrapOrThrow(errors.get(0));
             }
             throw new CompositeException(errors);
         }
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableAwait.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableAwait.java
index 1bb609fedf..16fc993d92 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableAwait.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableAwait.java
@@ -17,8 +17,8 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.functions.ObjectHelper;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public enum CompletableAwait {
     ;
@@ -49,17 +49,17 @@ public void onSubscribe(Disposable d) {
         
         if (cdl.getCount() == 0) {
             if (err[0] != null) {
-                throw Exceptions.propagate(err[0]);
+                throw ExceptionHelper.wrapOrThrow(err[0]);
             }
             return;
         }
         try {
             cdl.await();
         } catch (InterruptedException ex) {
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         if (err[0] != null) {
-            throw Exceptions.propagate(err[0]);
+            throw ExceptionHelper.wrapOrThrow(err[0]);
         }
     }
     
@@ -91,7 +91,7 @@ public void onSubscribe(Disposable d) {
         
         if (cdl.getCount() == 0) {
             if (err[0] != null) {
-                throw Exceptions.propagate(err[0]);
+                throw ExceptionHelper.wrapOrThrow(err[0]);
             }
             return true;
         }
@@ -99,11 +99,11 @@ public void onSubscribe(Disposable d) {
         try {
              b = cdl.await(timeout, unit);
         } catch (InterruptedException ex) {
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         if (b) {
             if (err[0] != null) {
-                throw Exceptions.propagate(err[0]);
+                throw ExceptionHelper.wrapOrThrow(err[0]);
             }
         }
         return b;
@@ -139,7 +139,7 @@ public void onSubscribe(Disposable d) {
         try {
             cdl.await();
         } catch (InterruptedException ex) {
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         return err[0];
     }
@@ -177,11 +177,11 @@ public void onSubscribe(Disposable d) {
         try {
             b = cdl.await(timeout, unit);
         } catch (InterruptedException ex) {
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         if (b) {
             return err[0];
         }
-        throw Exceptions.propagate(new TimeoutException());
+        throw ExceptionHelper.wrapOrThrow(new TimeoutException());
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java
index 7ccb86ea45..d77955d78e 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java
@@ -93,6 +93,7 @@ public void onError(Throwable t) {
                 actual.onError(t);
                 return;
             }
+            done = true;
             RxJavaPlugins.onError(t);
         }
         
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java
index 9e7c42696b..c96bce536a 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java
@@ -20,9 +20,9 @@
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public final class BlockingFlowableIterator<T> 
 extends AtomicReference<Subscription>
@@ -67,7 +67,7 @@ public boolean hasNext() {
             if (d) {
                 Throwable e = error;
                 if (e != null) {
-                    throw Exceptions.propagate(e);
+                    throw ExceptionHelper.wrapOrThrow(e);
                 } else
                 if (empty) {
                     return false;
@@ -81,7 +81,7 @@ public boolean hasNext() {
                     }
                 } catch (InterruptedException ex) {
                     run();
-                    throw Exceptions.propagate(ex);
+                    throw ExceptionHelper.wrapOrThrow(ex);
                 } finally {
                     lock.unlock();
                 }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableLatest.java b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableLatest.java
index 2e2ac86e6b..2170e27e5d 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableLatest.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableLatest.java
@@ -20,7 +20,7 @@
 import org.reactivestreams.Publisher;
 
 import io.reactivex.*;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.subscribers.DisposableSubscriber;
 
 /**
@@ -81,7 +81,7 @@ public void onComplete() {
         @Override
         public boolean hasNext() {
             if (iteratorNotification != null && iteratorNotification.isOnError()) {
-                throw Exceptions.propagate(iteratorNotification.getError());
+                throw ExceptionHelper.wrapOrThrow(iteratorNotification.getError());
             }
             if (iteratorNotification == null || iteratorNotification.isOnNext()) {
                 if (iteratorNotification == null) {
@@ -91,13 +91,13 @@ public boolean hasNext() {
                         dispose();
                         Thread.currentThread().interrupt();
                         iteratorNotification = Notification.createOnError(ex);
-                        throw Exceptions.propagate(ex);
+                        throw ExceptionHelper.wrapOrThrow(ex);
                     }
 
                     Notification<T> n = value.getAndSet(null);
                     iteratorNotification = n;
                     if (n.isOnError()) {
-                        throw Exceptions.propagate(n.getError());
+                        throw ExceptionHelper.wrapOrThrow(n.getError());
                     }
                 }
             }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java
index e8cf3d4c8b..ca21b896a1 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java
@@ -17,8 +17,7 @@
 
 import org.reactivestreams.Publisher;
 
-import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.util.NotificationLite;
+import io.reactivex.internal.util.*;
 import io.reactivex.subscribers.DefaultSubscriber;
 
 /**
@@ -109,7 +108,7 @@ public T next() {
                             throw new NoSuchElementException();
                         }
                         if (NotificationLite.isError(buf)) {
-                            throw Exceptions.propagate(NotificationLite.getError(buf));
+                            throw ExceptionHelper.wrapOrThrow(NotificationLite.getError(buf));
                         }
                         return NotificationLite.getValue(buf);
                     }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableNext.java b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableNext.java
index 0e4214864d..21301c492e 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableNext.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableNext.java
@@ -20,7 +20,7 @@
 import org.reactivestreams.Publisher;
 
 import io.reactivex.*;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.subscribers.DisposableSubscriber;
 
 /**
@@ -70,7 +70,7 @@
         public boolean hasNext() {
             if (error != null) {
                 // If any error has already been thrown, throw it again.
-                throw Exceptions.propagate(error);
+                throw ExceptionHelper.wrapOrThrow(error);
             }
             // Since an iterator should not be used in different thread,
             // so we do not need any synchronization.
@@ -106,14 +106,14 @@ private boolean moveToNext() {
                 }
                 if (nextNotification.isOnError()) {
                     error = nextNotification.getError();
-                    throw Exceptions.propagate(error);
+                    throw ExceptionHelper.wrapOrThrow(error);
                 }
                 throw new IllegalStateException("Should not reach here");
             } catch (InterruptedException e) {
                 observer.dispose();
                 Thread.currentThread().interrupt();
                 error = e;
-                throw Exceptions.propagate(e);
+                throw ExceptionHelper.wrapOrThrow(e);
             }
         }
 
@@ -121,7 +121,7 @@ private boolean moveToNext() {
         public T next() {
             if (error != null) {
                 // If any error has already been thrown, throw it again.
-                throw Exceptions.propagate(error);
+                throw ExceptionHelper.wrapOrThrow(error);
             }
             if (hasNext()) {
                 isNextConsumed = true;
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java
index ff120f6a7c..780bc73830 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java
@@ -108,7 +108,7 @@ public void accept(Subscription s) {
         BlockingHelper.awaitForComplete(cdl, ls);
         Throwable e = error[0];
         if (e != null) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
     }
     
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
index fda3311221..d7f5c16654 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
@@ -21,10 +21,10 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.flowables.ConnectableFlowable;
-import io.reactivex.functions.*;
+import io.reactivex.functions.Consumer;
 import io.reactivex.internal.queue.SpscArrayQueue;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
-import io.reactivex.internal.util.NotificationLite;
+import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
@@ -180,7 +180,7 @@ public void connect(Consumer<? super Disposable> connection) {
             connection.accept(ps);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         if (doConnect) {
             source.subscribe(ps);
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
index 1a8d3e08dd..95e4629318 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
@@ -217,7 +217,7 @@ public void subscribe(Subscriber<? super T> child) {
                             buf = bufferFactory.call();
                         } catch (Throwable ex) {
                             Exceptions.throwIfFatal(ex);
-                            throw Exceptions.propagate(ex);
+                            throw ExceptionHelper.wrapOrThrow(ex);
                         }
                         // create a new subscriber to source
                         ReplaySubscriber<T> u = new ReplaySubscriber<T>(buf);
@@ -287,7 +287,7 @@ public void connect(Consumer<? super Disposable> connection) {
                     buf = bufferFactory.call();
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
-                    throw Exceptions.propagate(ex);
+                    throw ExceptionHelper.wrapOrThrow(ex);
                 }
                 
                 // create a new subscriber-to-source
@@ -322,7 +322,7 @@ public void connect(Consumer<? super Disposable> connection) {
             connection.accept(ps);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         if (doConnect) {
             source.subscribe(ps);
diff --git a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterator.java b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterator.java
index cfc75d79dd..80b674fd07 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterator.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterator.java
@@ -18,9 +18,9 @@
 import java.util.concurrent.locks.*;
 
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public final class BlockingObservableIterator<T> 
 extends AtomicReference<Disposable>
@@ -57,7 +57,7 @@ public boolean hasNext() {
             if (d) {
                 Throwable e = error;
                 if (e != null) {
-                    throw Exceptions.propagate(e);
+                    throw ExceptionHelper.wrapOrThrow(e);
                 } else
                 if (empty) {
                     return false;
@@ -71,7 +71,7 @@ public boolean hasNext() {
                     }
                 } catch (InterruptedException ex) {
                     run();
-                    throw Exceptions.propagate(ex);
+                    throw ExceptionHelper.wrapOrThrow(ex);
                 } finally {
                     lock.unlock();
                 }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java
index 6d332964c5..92ce51dc3a 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java
@@ -19,7 +19,7 @@
 
 import io.reactivex.*;
 import io.reactivex.Observable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.observers.DisposableObserver;
 
 /**
@@ -84,7 +84,7 @@ public void onComplete() {
         @Override
         public boolean hasNext() {
             if (iteratorNotification != null && iteratorNotification.isOnError()) {
-                throw Exceptions.propagate(iteratorNotification.getError());
+                throw ExceptionHelper.wrapOrThrow(iteratorNotification.getError());
             }
             if (iteratorNotification == null || iteratorNotification.isOnNext()) {
                 if (iteratorNotification == null) {
@@ -94,13 +94,13 @@ public boolean hasNext() {
                         dispose();
                         Thread.currentThread().interrupt();
                         iteratorNotification = Notification.createOnError(ex);
-                        throw Exceptions.propagate(ex);
+                        throw ExceptionHelper.wrapOrThrow(ex);
                     }
 
                     Notification<T> n = value.getAndSet(null);
                     iteratorNotification = n;
                     if (n.isOnError()) {
-                        throw Exceptions.propagate(n.getError());
+                        throw ExceptionHelper.wrapOrThrow(n.getError());
                     }
                 }
             }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableMostRecent.java b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableMostRecent.java
index 75434de3f9..127645bdbf 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableMostRecent.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableMostRecent.java
@@ -17,8 +17,7 @@
 import java.util.*;
 
 import io.reactivex.ObservableSource;
-import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.util.NotificationLite;
+import io.reactivex.internal.util.*;
 import io.reactivex.observers.DefaultObserver;
 
 /**
@@ -109,7 +108,7 @@ public T next() {
                             throw new NoSuchElementException();
                         }
                         if (NotificationLite.isError(buf)) {
-                            throw Exceptions.propagate(NotificationLite.getError(buf));
+                            throw ExceptionHelper.wrapOrThrow(NotificationLite.getError(buf));
                         }
                         return NotificationLite.getValue(buf);
                     }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java
index 86df3e4f9f..22519d5636 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java
@@ -19,7 +19,7 @@
 
 import io.reactivex.Notification;
 import io.reactivex.Observable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.observers.DisposableObserver;
 
 /**
@@ -69,7 +69,7 @@
         public boolean hasNext() {
             if (error != null) {
                 // If any error has already been thrown, throw it again.
-                throw Exceptions.propagate(error);
+                throw ExceptionHelper.wrapOrThrow(error);
             }
             // Since an iterator should not be used in different thread,
             // so we do not need any synchronization.
@@ -106,14 +106,14 @@ private boolean moveToNext() {
                 }
                 if (nextNotification.isOnError()) {
                     error = nextNotification.getError();
-                    throw Exceptions.propagate(error);
+                    throw ExceptionHelper.wrapOrThrow(error);
                 }
                 throw new IllegalStateException("Should not reach here");
             } catch (InterruptedException e) {
                 observer.dispose();
                 Thread.currentThread().interrupt();
                 error = e;
-                throw Exceptions.propagate(e);
+                throw ExceptionHelper.wrapOrThrow(e);
             }
         }
 
@@ -121,7 +121,7 @@ private boolean moveToNext() {
         public T next() {
             if (error != null) {
                 // If any error has already been thrown, throw it again.
-                throw Exceptions.propagate(error);
+                throw ExceptionHelper.wrapOrThrow(error);
             }
             if (hasNext()) {
                 isNextConsumed = true;
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableAutoConnect.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableAutoConnect.java
index b64165398e..fd015a4686 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableAutoConnect.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAutoConnect.java
@@ -35,9 +35,6 @@
     public ObservableAutoConnect(ConnectableObservable<? extends T> source,
             int numberOfSubscribers,
             Consumer<? super Disposable> connection) {
-        if (numberOfSubscribers <= 0) {
-            throw new IllegalArgumentException("numberOfSubscribers > 0 required");
-        }
         this.source = source;
         this.numberOfSubscribers = numberOfSubscribers;
         this.connection = connection;
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java
index cf79477b5c..7b4930d788 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java
@@ -108,7 +108,7 @@ public void accept(Disposable s) {
         BlockingHelper.awaitForComplete(cdl, ls);
         Throwable e = error[0];
         if (e != null) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
     }
     
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java
index 0917a99429..3552ee0790 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java
@@ -187,7 +187,7 @@ void disposeAll() {
                     inner = observers.poll();
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
-                    throw Exceptions.propagate(ex);
+                    throw ExceptionHelper.wrapOrThrow(ex);
                 }
                 if (inner == null) {
                     return;
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java b/src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java
index a127dda87a..8d955428e6 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java
@@ -21,7 +21,7 @@
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
-import io.reactivex.internal.util.NotificationLite;
+import io.reactivex.internal.util.*;
 import io.reactivex.observables.ConnectableObservable;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -209,7 +209,7 @@ public void connect(Consumer<? super Disposable> connection) {
             connection.accept(ps);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         if (doConnect) {
             source.subscribe(ps);
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java
index 538606aebb..7e81f40428 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java
@@ -24,7 +24,7 @@
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.*;
 import io.reactivex.internal.disposables.*;
-import io.reactivex.internal.util.NotificationLite;
+import io.reactivex.internal.util.*;
 import io.reactivex.observables.ConnectableObservable;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.schedulers.Timed;
@@ -202,7 +202,7 @@ public void subscribe(Observer<? super T> child) {
                             buf = bufferFactory.call();
                         } catch (Throwable ex) {
                             Exceptions.throwIfFatal(ex);
-                            throw Exceptions.propagate(ex);
+                            throw ExceptionHelper.wrapOrThrow(ex);
                         }
                         
                         ReplaySubscriber<T> u = new ReplaySubscriber<T>(buf);
@@ -274,7 +274,7 @@ public void connect(Consumer<? super Disposable> connection) {
                     buf = bufferFactory.call();
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
-                    throw Exceptions.propagate(ex);
+                    throw ExceptionHelper.wrapOrThrow(ex);
                 }
 
                 ReplaySubscriber<T> u = new ReplaySubscriber<T>(buf);
@@ -309,7 +309,7 @@ public void connect(Consumer<? super Disposable> connection) {
             connection.accept(ps);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         if (doConnect) {
             source.subscribe(ps);
diff --git a/src/main/java/io/reactivex/internal/operators/single/SingleAwait.java b/src/main/java/io/reactivex/internal/operators/single/SingleAwait.java
index b92d7885f5..c2ffe88164 100644
--- a/src/main/java/io/reactivex/internal/operators/single/SingleAwait.java
+++ b/src/main/java/io/reactivex/internal/operators/single/SingleAwait.java
@@ -18,7 +18,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public enum SingleAwait {
     ;
@@ -54,7 +54,7 @@ public void onSuccess(T value) {
         }
         Throwable e = errorRef.get();
         if (e != null) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
         return valueRef.get();
     }
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java
index 896b61b0f8..9a1912c31c 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java
@@ -17,7 +17,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public abstract class BlockingSingleSubscriber<T> extends CountDownLatch
 implements Subscriber<T>, Disposable {
@@ -74,13 +74,13 @@ public final T blockingGet() {
                 await();
             } catch (InterruptedException ex) {
                 dispose();
-                throw Exceptions.propagate(ex);
+                throw ExceptionHelper.wrapOrThrow(ex);
             }
         }
         
         Throwable e = error;
         if (e != null) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
         return value;
     }
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/BlockingSingleObserver.java b/src/main/java/io/reactivex/internal/subscribers/observable/BlockingSingleObserver.java
index 7a7ceec343..a4afef752e 100644
--- a/src/main/java/io/reactivex/internal/subscribers/observable/BlockingSingleObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/BlockingSingleObserver.java
@@ -16,7 +16,7 @@
 
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public abstract class BlockingSingleObserver<T> extends CountDownLatch
 implements Observer<T>, Disposable {
@@ -70,13 +70,13 @@ public final T blockingGet() {
                 await();
             } catch (InterruptedException ex) {
                 dispose();
-                throw Exceptions.propagate(ex);
+                throw ExceptionHelper.wrapOrThrow(ex);
             }
         }
         
         Throwable e = error;
         if (e != null) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
         return value;
     }
diff --git a/src/main/java/io/reactivex/internal/util/BackpressureHelper.java b/src/main/java/io/reactivex/internal/util/BackpressureHelper.java
index 23c311c763..6e6d398ff3 100644
--- a/src/main/java/io/reactivex/internal/util/BackpressureHelper.java
+++ b/src/main/java/io/reactivex/internal/util/BackpressureHelper.java
@@ -70,7 +70,31 @@ public static long add(AtomicLong requested, long n) {
             }
         }
     }
-    
+
+    /**
+     * Atomically adds the positive value n to the requested value in the AtomicLong and
+     * caps the result at Long.MAX_VALUE and returns the previous value and
+     * considers Long.MIN_VALUE as a cancel indication (no addition then).
+     * @param requested the AtomicLong holding the current requested value
+     * @param n the value to add, must be positive (not verified)
+     * @return the original value before the add
+     */
+    public static long addCancel(AtomicLong requested, long n) {
+        for (;;) {
+            long r = requested.get();
+            if (r == Long.MIN_VALUE) {
+                return Long.MIN_VALUE;
+            }
+            if (r == Long.MAX_VALUE) {
+                return Long.MAX_VALUE;
+            }
+            long u = addCap(r, n);
+            if (requested.compareAndSet(r, u)) {
+                return r;
+            }
+        }
+    }
+
     /**
      * Atomically subtract the given number (positive, not validated) from the target field.
      * @param requested the target field holding the current requested amount
diff --git a/src/main/java/io/reactivex/internal/util/ExceptionHelper.java b/src/main/java/io/reactivex/internal/util/ExceptionHelper.java
index 7e49330ae6..663826d9a5 100644
--- a/src/main/java/io/reactivex/internal/util/ExceptionHelper.java
+++ b/src/main/java/io/reactivex/internal/util/ExceptionHelper.java
@@ -23,6 +23,24 @@
  */
 public enum ExceptionHelper {
     ;
+    
+    /**
+     * If the provided Throwable is an Error this method
+     * throws it, otherwise returns a RuntimeException wrapping the error
+     * if that error is a checked exception.
+     * @param error the error to wrap or throw
+     * @return the (wrapped) error
+     */
+    public static RuntimeException wrapOrThrow(Throwable error) {
+        if (error instanceof Error) {
+            throw (Error)error;
+        }
+        if (error instanceof RuntimeException) {
+            return (RuntimeException)error;
+        }
+        return new RuntimeException(error);
+    }
+    
     /**
      * A singleton instance of a Throwable indicating a terminal state for exceptions,
      * don't leak this!
diff --git a/src/main/java/io/reactivex/observers/TestObserver.java b/src/main/java/io/reactivex/observers/TestObserver.java
index c71f58f562..440d50866f 100644
--- a/src/main/java/io/reactivex/observers/TestObserver.java
+++ b/src/main/java/io/reactivex/observers/TestObserver.java
@@ -19,11 +19,12 @@
 import io.reactivex.Notification;
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.*;
+import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.Consumer;
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.QueueDisposable;
+import io.reactivex.internal.util.ExceptionHelper;
 
 /**
  * An Observer that records events and allows making assertions about them.
@@ -824,7 +825,7 @@ private String fusionModeToString(int mode) {
         try {
             check.accept(this);
         } catch (Throwable ex) {
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         return this;
     }
@@ -872,7 +873,42 @@ private String fusionModeToString(int mode) {
                 .assertErrorMessage(message)
                 .assertNotComplete();
     }
-    
+
+    /**
+     * Awaits until the internal latch is counted down.
+     * <p>If the wait times out or gets interrupted, the TestSubscriber is cancelled.
+     * @return this
+     * @throws InterruptedException if the wait is interrupted
+     */
+    public final TestObserver<T> awaitDone() throws InterruptedException {
+        try {
+            done.await();
+        } catch (InterruptedException ex) {
+            cancel();
+        }
+        return this;
+    }
+
+    /**
+     * Awaits until the internal latch is counted down.
+     * <p>If the wait times out or gets interrupted, the TestSubscriber is cancelled.
+     * @param time the waiting time
+     * @param unit the time unit of the waiting time
+     * @return this
+     * @throws InterruptedException if the wait is interrupted
+     */
+    public final TestObserver<T> awaitDone(long time, TimeUnit unit) throws InterruptedException {
+        try {
+            if (!done.await(time, unit)) {
+                cancel();
+            }
+        } catch (InterruptedException ex) {
+            cancel();
+        }
+        return this;
+    }
+
+
     /**
      * An observer that ignores all events and does not report errors.
      */
diff --git a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
index 406c570995..cde932dcc8 100644
--- a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
@@ -17,9 +17,9 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.flowables.ConnectableFlowable;
 import io.reactivex.functions.*;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.observables.ConnectableObservable;
 
 /**
@@ -76,7 +76,7 @@
     static volatile BiFunction<Completable, CompletableObserver, CompletableObserver> onCompletableSubscribe;
 
     /** Prevents changing the plugins. */
-    private static volatile boolean lockdown;
+    static volatile boolean lockdown;
     
     /**
      * Prevents changing the plugins from then on.
@@ -256,6 +256,7 @@ public static void onError(Throwable error) {
                     error = new NullPointerException();
                 }
                 e.printStackTrace(); // NOPMD
+                uncaught(e);
             }
         } else {
             if (error == null) {
@@ -263,9 +264,13 @@ public static void onError(Throwable error) {
             }
         }
         error.printStackTrace(); // NOPMD
-        
-        UncaughtExceptionHandler handler = Thread.currentThread().getUncaughtExceptionHandler();
-        handler.uncaughtException(Thread.currentThread(), error);
+        uncaught(error);
+    }
+    
+    static void uncaught(Throwable error) {
+        Thread currentThread = Thread.currentThread();
+        UncaughtExceptionHandler handler = currentThread.getUncaughtExceptionHandler();
+        handler.uncaughtException(currentThread, error);
     }
     
     /**
@@ -350,6 +355,9 @@ public static void reset() {
         
         setOnCompletableAssembly(null);
         setOnCompletableSubscribe(null);
+
+        setOnConnectableFlowableAssembly(null);
+        setOnConnectableObservableAssembly(null);
     }
 
     /**
@@ -840,8 +848,7 @@ public static Completable onAssembly(Completable source) {
         try {
             return f.apply(t);
         } catch (Throwable ex) {
-            Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 
@@ -860,8 +867,7 @@ public static Completable onAssembly(Completable source) {
         try {
             return f.apply(t, u);
         } catch (Throwable ex) {
-            Exceptions.throwIfFatal(ex);
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 
diff --git a/src/main/java/io/reactivex/processors/PublishProcessor.java b/src/main/java/io/reactivex/processors/PublishProcessor.java
index 3f8e25363e..61c93733ed 100644
--- a/src/main/java/io/reactivex/processors/PublishProcessor.java
+++ b/src/main/java/io/reactivex/processors/PublishProcessor.java
@@ -187,20 +187,18 @@ public boolean hasComplete() {
         public void subscribe(Subscriber<? super T> t) {
             PublishSubscriber<T> ps = new PublishSubscriber<T>(t, this);
             t.onSubscribe(ps);
-            if (!ps.cancelled.get()) {
-                if (add(ps)) {
-                    // if cancellation happened while a successful add, the remove() didn't work
-                    // so we need to do it again
-                    if (ps.cancelled.get()) {
-                        remove(ps);
-                    }
+            if (add(ps)) {
+                // if cancellation happened while a successful add, the remove() didn't work
+                // so we need to do it again
+                if (ps.isCancelled()) {
+                    remove(ps);
+                }
+            } else {
+                Object o = get();
+                if (o == COMPLETE) {
+                    ps.onComplete();
                 } else {
-                    Object o = get();
-                    if (o == COMPLETE) {
-                        ps.onComplete();
-                    } else {
-                        ps.onError((Throwable)o);
-                    }
+                    ps.onError((Throwable)o);
                 }
             }
         }
@@ -230,11 +228,7 @@ public void subscribe(Subscriber<? super T> t) {
         @SuppressWarnings("unchecked")
         PublishSubscriber<T>[] terminate(Object event) {
             if (compareAndSet(null, event)) {
-                PublishSubscriber<T>[] a = subscribers.get();
-                if (a != TERMINATED) {
-                    a = subscribers.getAndSet(TERMINATED);
-                }
-                return a;
+                return subscribers.getAndSet(TERMINATED);
             }
             return TERMINATED;
         }
@@ -316,15 +310,13 @@ void remove(PublishSubscriber<T> ps) {
      *
      * @param <T> the value type
      */
-    static final class PublishSubscriber<T> extends AtomicLong implements Subscriber<T>, Subscription {
+    static final class PublishSubscriber<T> extends AtomicLong implements Subscription {
         /** */
         private static final long serialVersionUID = 3562861878281475070L;
         /** The actual subscriber. */
         final Subscriber<? super T> actual;
         /** The subject state. */
         final State<T> state;
-
-        final AtomicBoolean cancelled = new AtomicBoolean();
         
         /**
          * Constructs a PublishSubscriber, wraps the actual subscriber and the state.
@@ -336,14 +328,11 @@ public PublishSubscriber(Subscriber<? super T> actual, State<T> state) {
             this.state = state;
         }
         
-        @Override
-        public void onSubscribe(Subscription s) {
-            // not called because requests are handled locally and cancel is forwarded to state
-        }
-        
-        @Override
         public void onNext(T t) {
             long r = get();
+            if (r == Long.MIN_VALUE) {
+                return;
+            }
             if (r != 0L) {
                 actual.onNext(t);
                 if (r != Long.MAX_VALUE) {
@@ -355,28 +344,36 @@ public void onNext(T t) {
             }
         }
         
-        @Override
         public void onError(Throwable t) {
-            actual.onError(t);
+            if (get() != Long.MIN_VALUE) {
+                actual.onError(t);
+            } else {
+                RxJavaPlugins.onError(t);
+            }
         }
         
-        @Override
         public void onComplete() {
-            actual.onComplete();
+            if (get() != Long.MIN_VALUE) {
+                actual.onComplete();
+            }
         }
         
         @Override
         public void request(long n) {
             if (SubscriptionHelper.validate(n)) {
-                BackpressureHelper.add(this, n);
+                BackpressureHelper.addCancel(this, n);
             }
         }
         
         @Override
         public void cancel() {
-            if (!cancelled.get() && cancelled.compareAndSet(false, true)) {
+            if (getAndSet(Long.MIN_VALUE) != Long.MIN_VALUE) {
                 state.remove(this);
             }
         }
+        
+        public boolean isCancelled() {
+            return get() == Long.MIN_VALUE;
+        }
     }
 }
diff --git a/src/main/java/io/reactivex/subscribers/TestSubscriber.java b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
index 6c12819827..8d412b97c9 100644
--- a/src/main/java/io/reactivex/subscribers/TestSubscriber.java
+++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
@@ -20,12 +20,12 @@
 
 import io.reactivex.Notification;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.*;
+import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.Consumer;
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.QueueSubscription;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
-import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.internal.util.*;
 
 /**
  * A subscriber that records events and allows making assertions about them.
@@ -401,20 +401,7 @@ public final boolean hasSubscription() {
         done.await();
         return this;
     }
-    
-    /**
-     * Awaits the specified amount of time or until this TestSubscriber 
-     * receives an onError or onComplete events, whichever happens first.
-     * @param time the waiting time
-     * @param unit the time unit of the waiting time
-     * @return true if the TestSubscriber terminated, false if timeout happened
-     * @throws InterruptedException if the current thread is interrupted while waiting
-     * @see #awaitTerminalEvent(long, TimeUnit)
-     */
-    public final boolean await(long time, TimeUnit unit) throws InterruptedException {
-        return done.getCount() == 0 || done.await(time, unit);
-    }
-    
+
     // assertion methods
     
     /**
@@ -887,7 +874,7 @@ private String fusionModeToString(int mode) {
         try {
             check.accept(this);
         } catch (Throwable ex) {
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
         return this;
     }
@@ -936,6 +923,53 @@ private String fusionModeToString(int mode) {
                 .assertNotComplete();
     }
 
+    /**
+     * Awaits the specified amount of time or until this TestSubscriber 
+     * receives an onError or onComplete events, whichever happens first.
+     * @param time the waiting time
+     * @param unit the time unit of the waiting time
+     * @return true if the TestSubscriber terminated, false if timeout happened
+     * @throws InterruptedException if the current thread is interrupted while waiting
+     * @see #awaitTerminalEvent(long, TimeUnit)
+     */
+    public final boolean await(long time, TimeUnit unit) throws InterruptedException {
+        return done.getCount() == 0 || done.await(time, unit);
+    }
+    
+    /**
+     * Awaits until the internal latch is counted down.
+     * <p>If the wait times out or gets interrupted, the TestSubscriber is cancelled.
+     * @return this
+     * @throws InterruptedException if the wait is interrupted
+     */
+    public final TestSubscriber<T> awaitDone() throws InterruptedException {
+        try {
+            done.await();
+        } catch (InterruptedException ex) {
+            cancel();
+        }
+        return this;
+    }
+    
+    /**
+     * Awaits until the internal latch is counted down for the specified duration.
+     * <p>If the wait times out or gets interrupted, the TestSubscriber is cancelled.
+     * @param time the waiting time
+     * @param unit the time unit of the waiting time
+     * @return this
+     * @throws InterruptedException if the wait is interrupted
+     */
+    public final TestSubscriber<T> awaitDone(long time, TimeUnit unit) throws InterruptedException {
+        try {
+            if (!done.await(time, unit)) {
+                cancel();
+            }
+        } catch (InterruptedException ex) {
+            cancel();
+        }
+        return this;
+    }
+
     /**
      * A subscriber that ignores all events and does not report errors.
      */
diff --git a/src/test/java/io/reactivex/BackpressureEnumTest.java b/src/test/java/io/reactivex/BackpressureEnumTest.java
new file mode 100644
index 0000000000..f76fcb3139
--- /dev/null
+++ b/src/test/java/io/reactivex/BackpressureEnumTest.java
@@ -0,0 +1,47 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.reactivex;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import io.reactivex.annotations.BackpressureKind;
+
+public class BackpressureEnumTest {
+
+    @Test
+    public void backpressureOverflowStrategy() {
+        assertEquals(3, BackpressureOverflowStrategy.values().length);
+        
+        assertNotNull(BackpressureOverflowStrategy.valueOf("ERROR"));
+    }
+
+    @Test
+    public void backpressureStrategy() {
+        assertEquals(3, BackpressureStrategy.values().length);
+        
+        assertNotNull(BackpressureStrategy.valueOf("BUFFER"));
+    }
+
+    @Test
+    public void backpressureKind() {
+        assertEquals(6, BackpressureKind.values().length);
+        
+        assertNotNull(BackpressureKind.valueOf("FULL"));
+    }
+
+}
diff --git a/src/test/java/io/reactivex/NotificationTest.java b/src/test/java/io/reactivex/NotificationTest.java
new file mode 100644
index 0000000000..5045e8a014
--- /dev/null
+++ b/src/test/java/io/reactivex/NotificationTest.java
@@ -0,0 +1,66 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import io.reactivex.exceptions.TestException;
+
+public class NotificationTest {
+
+    @Test
+    public void valueOfOnErrorIsNull() {
+        Notification<Integer> notification = Notification.createOnError(new TestException());
+        
+        assertNull(notification.getValue());
+        assertTrue(notification.getError().toString(), notification.getError() instanceof TestException);
+    }
+
+    @Test
+    public void valueOfOnCompleteIsNull() {
+        Notification<Integer> notification = Notification.createOnComplete();
+        
+        assertNull(notification.getValue());
+        assertNull(notification.getError());
+        assertTrue(notification.isOnComplete());
+    }
+    
+    @Test
+    public void notEqualsToObject() {
+        Notification<Integer> n1 = Notification.createOnNext(0);
+        assertFalse(n1.equals(0));
+        Notification<Integer> n2 = Notification.createOnError(new TestException());
+        assertFalse(n2.equals(0));
+        Notification<Integer> n3 = Notification.createOnComplete();
+        assertFalse(n3.equals(0));
+    }
+    
+    @Test
+    public void hashCodeIsTheInner() {
+        Notification<Integer> n1 = Notification.createOnNext(1337);
+        
+        assertEquals(Integer.valueOf(1337).hashCode(), n1.hashCode());
+        
+        assertEquals(0, Notification.createOnComplete().hashCode());
+    }
+
+    @Test
+    public void toStringPattern() {
+        assertEquals("OnNextNotification[1]", Notification.createOnNext(1).toString());
+        assertEquals("OnErrorNotification[io.reactivex.exceptions.TestException]", Notification.createOnError(new TestException()).toString());
+        assertEquals("OnCompleteNotification", Notification.createOnComplete().toString());
+    }
+}
diff --git a/src/test/java/io/reactivex/TestHelper.java b/src/test/java/io/reactivex/TestHelper.java
index 52b06f68ec..6457159eb6 100644
--- a/src/test/java/io/reactivex/TestHelper.java
+++ b/src/test/java/io/reactivex/TestHelper.java
@@ -13,19 +13,23 @@
 
 package io.reactivex;
 
+import static org.junit.Assert.*;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.mock;
 
 import java.lang.reflect.*;
 import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Assert;
 import org.mockito.Mockito;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 import org.reactivestreams.*;
 
+import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.Consumer;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
@@ -54,11 +58,21 @@ public Object answer(InvocationOnMock a) throws Throwable {
         return w;
     }
     
+    /**
+     * Mocks an Observer with the proper receiver type.
+     * @param <T> the value type
+     * @return the mocked observer
+     */
     @SuppressWarnings("unchecked")
     public static <T> Observer<T> mockObserver() {
         return mock(Observer.class);
     }
     
+    /**
+     * Validates that the given class, when forcefully instantiated throws
+     * an IllegalArgumentException("No instances!") exception.
+     * @param clazz the class to test, not null
+     */
     public static void checkUtilityClass(Class<?> clazz) {
         try {
             Constructor<?> c = clazz.getDeclaredConstructor();
@@ -67,9 +81,9 @@ public static void checkUtilityClass(Class<?> clazz) {
             
             try {
                 c.newInstance();
-                Assert.fail("Should have thrown InvocationTargetException(IllegalStateException)");
+                fail("Should have thrown InvocationTargetException(IllegalStateException)");
             } catch (InvocationTargetException ex) {
-                Assert.assertEquals("No instances!", ex.getCause().getMessage());
+                assertEquals("No instances!", ex.getCause().getMessage());
             }
         } catch (Exception ex) {
             AssertionError ae = new AssertionError(ex.toString());
@@ -92,7 +106,153 @@ public void accept(Throwable t) {
     }
     
     public static void assertError(List<Throwable> list, int index, Class<? extends Throwable> clazz, String message) {
-        Assert.assertTrue(list.get(index).toString(), clazz.isInstance(list.get(index)));
-        Assert.assertEquals(message, list.get(index).getMessage());
+        assertTrue(list.get(index).toString(), clazz.isInstance(list.get(index)));
+        assertEquals(message, list.get(index).getMessage());
+    }
+    
+    /**
+     * Verify that a specific enum type has no enum constants.
+     * @param <E> the enum type
+     * @param e the enum class instance
+     */
+    public static <E extends Enum<E>> void assertEmptyEnum(Class<E> e) {
+        assertEquals(0, e.getEnumConstants().length);
+        
+        try {
+            Method m = e.getDeclaredMethod("valueOf", String.class);
+            
+            try {
+                m.invoke("INSTANCE");
+                fail("Should have thrown!");
+            } catch (InvocationTargetException ex) {
+                fail(ex.toString());
+            } catch (IllegalAccessException ex) {
+                fail(ex.toString());
+            } catch (IllegalArgumentException ex) {
+                // we expected this
+            }
+        } catch (NoSuchMethodException ex) {
+            fail(ex.toString());
+        }
+    }
+    
+    public static void assertBadRequestReported(Publisher<?> source) {
+        List<Throwable> list = trackPluginErrors();
+        try {
+            final CountDownLatch cdl = new CountDownLatch(1);
+            
+            source.subscribe(new Subscriber<Object>() {
+
+                @Override
+                public void onSubscribe(Subscription s) {
+                    try {
+                        s.request(-99);
+                        s.cancel();
+                        s.cancel();
+                    } finally {
+                        cdl.countDown();
+                    }
+                }
+
+                @Override
+                public void onNext(Object t) {
+                    
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    
+                }
+
+                @Override
+                public void onComplete() {
+                    
+                }
+                
+            });
+            
+            try {
+                assertTrue(cdl.await(5, TimeUnit.SECONDS));
+            } catch (InterruptedException ex) {
+                throw new AssertionError(ex.getMessage());
+            }
+            
+            assertTrue(list.toString(), list.get(0) instanceof IllegalArgumentException);
+            assertEquals("n > 0 required but it was -99", list.get(0).getMessage());
+        } finally {
+            RxJavaPlugins.setErrorHandler(null);
+        }
+    }
+    
+    /**
+     * Synchronizes the execution of two runnables (as much as possible)
+     * to test race conditions.
+     * <p>The method blocks until both have run to completion.
+     * @param r1 the first runnable
+     * @param r2 the second runnable
+     * @param s the scheduler to use
+     */
+    public static void race(final Runnable r1, final Runnable r2, Scheduler s) {
+        final AtomicInteger count = new AtomicInteger(2);
+        final CountDownLatch cdl = new CountDownLatch(2);
+        
+        final Throwable[] errors = { null, null };
+        
+        s.scheduleDirect(new Runnable() {
+            @Override
+            public void run() {
+                if (count.decrementAndGet() != 0) {
+                    while (count.get() != 0);
+                }
+                
+                try {
+                    try {
+                        r1.run();
+                    } catch (Throwable ex) {
+                        errors[0] = ex;
+                    }
+                } finally {
+                    cdl.countDown();
+                }
+            }
+        });
+        
+        s.scheduleDirect(new Runnable() {
+            @Override
+            public void run() {
+                if (count.decrementAndGet() != 0) {
+                    while (count.get() != 0);
+                }
+                
+                try {
+                    try {
+                        r2.run();
+                    } catch (Throwable ex) {
+                        errors[1] = ex;
+                    }
+                } finally {
+                    cdl.countDown();
+                }
+            }
+        });
+        
+        try {
+            if (!cdl.await(5, TimeUnit.SECONDS)) {
+                throw new AssertionError("The wait timed out!");
+            }
+        } catch (InterruptedException ex) {
+            throw new RuntimeException(ex);
+        }
+        if (errors[0] != null && errors[1] == null) {
+            throw ExceptionHelper.wrapOrThrow(errors[0]);
+        }
+        
+        if (errors[0] == null && errors[1] != null) {
+            throw ExceptionHelper.wrapOrThrow(errors[1]);
+        }
+        
+        if (errors[0] != null && errors[1] != null) {
+            throw new CompositeException(errors);
+        }
     }
 }
diff --git a/src/test/java/io/reactivex/completable/CompletableTest.java b/src/test/java/io/reactivex/completable/CompletableTest.java
index 44c99ed4bc..147f64fd68 100644
--- a/src/test/java/io/reactivex/completable/CompletableTest.java
+++ b/src/test/java/io/reactivex/completable/CompletableTest.java
@@ -33,6 +33,7 @@
 import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
@@ -3439,7 +3440,7 @@ private static void expectUncaughtTestException(Action action) {
             assertTrue("A TestException should have been delivered to the handler",
                     caught instanceof TestException);
         } catch (Throwable ex) {
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         } finally {
             Thread.setDefaultUncaughtExceptionHandler(originalHandler);
         }
diff --git a/src/test/java/io/reactivex/disposables/CompositeDisposableTest.java b/src/test/java/io/reactivex/disposables/CompositeDisposableTest.java
index c589c2c622..6a1f6ddce8 100644
--- a/src/test/java/io/reactivex/disposables/CompositeDisposableTest.java
+++ b/src/test/java/io/reactivex/disposables/CompositeDisposableTest.java
@@ -15,13 +15,17 @@
 
 import static org.junit.Assert.*;
 
+import java.io.IOException;
 import java.util.*;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Test;
 
+import io.reactivex.TestHelper;
 import io.reactivex.exceptions.CompositeException;
+import io.reactivex.functions.Action;
+import io.reactivex.schedulers.Schedulers;
 
 public class CompositeDisposableTest {
 
@@ -294,4 +298,525 @@ public void testAddingNullDisposableIllegal() {
         csub.add(null);
     }
 
+    @Test
+    public void initializeVarargs() {
+        Disposable d1 = Disposables.empty();
+        Disposable d2 = Disposables.empty();
+        
+        CompositeDisposable cd = new CompositeDisposable(d1, d2);
+
+        assertEquals(2, cd.size());
+
+        cd.clear();
+
+        assertEquals(0, cd.size());
+
+        assertTrue(d1.isDisposed());
+        assertTrue(d2.isDisposed());
+        
+        Disposable d3 = Disposables.empty();
+        Disposable d4 = Disposables.empty();
+
+        cd = new CompositeDisposable(d3, d4);
+        
+        cd.dispose();
+        
+        assertTrue(d3.isDisposed());
+        assertTrue(d4.isDisposed());
+        
+        assertEquals(0, cd.size());
+    }
+    
+    @Test
+    public void initializeIterable() {
+        Disposable d1 = Disposables.empty();
+        Disposable d2 = Disposables.empty();
+        
+        CompositeDisposable cd = new CompositeDisposable(Arrays.asList(d1, d2));
+        
+        assertEquals(2, cd.size());
+        
+        cd.clear();
+
+        assertEquals(0, cd.size());
+
+        assertTrue(d1.isDisposed());
+        assertTrue(d2.isDisposed());
+        
+        Disposable d3 = Disposables.empty();
+        Disposable d4 = Disposables.empty();
+
+        cd = new CompositeDisposable(Arrays.asList(d3, d4));
+
+        assertEquals(2, cd.size());
+
+        cd.dispose();
+        
+        assertTrue(d3.isDisposed());
+        assertTrue(d4.isDisposed());
+        
+        assertEquals(0, cd.size());
+    }
+    
+    @Test
+    public void addAll() {
+        CompositeDisposable cd = new CompositeDisposable();
+        
+        Disposable d1 = Disposables.empty();
+        Disposable d2 = Disposables.empty();
+        Disposable d3 = Disposables.empty();
+        
+        cd.addAll(d1, d2);
+        cd.addAll(d3);
+        
+        assertFalse(d1.isDisposed());
+        assertFalse(d2.isDisposed());
+        assertFalse(d3.isDisposed());
+
+        cd.clear();
+        
+        assertTrue(d1.isDisposed());
+        assertTrue(d2.isDisposed());
+        
+        d1 = Disposables.empty();
+        d2 = Disposables.empty();
+        
+        cd = new CompositeDisposable();
+        
+        cd.addAll(d1, d2);
+        
+        assertFalse(d1.isDisposed());
+        assertFalse(d2.isDisposed());
+        
+        cd.dispose();
+        
+        assertTrue(d1.isDisposed());
+        assertTrue(d2.isDisposed());
+
+        assertEquals(0, cd.size());
+
+        cd.clear();
+        
+        assertEquals(0, cd.size());
+    }
+    
+    @Test
+    public void addAfterDisposed() {
+        CompositeDisposable cd = new CompositeDisposable();
+        cd.dispose();
+        
+        Disposable d1 = Disposables.empty();
+        
+        assertFalse(cd.add(d1));
+        
+        assertTrue(d1.isDisposed());
+        
+        d1 = Disposables.empty();
+        Disposable d2 = Disposables.empty();
+        
+        assertFalse(cd.addAll(d1, d2));
+        
+        assertTrue(d1.isDisposed());
+        assertTrue(d2.isDisposed());
+        
+    }
+    
+    @Test
+    public void delete() {
+        
+        CompositeDisposable cd = new CompositeDisposable();
+        
+        Disposable d1 = Disposables.empty();
+        
+        assertFalse(cd.delete(d1));
+        
+        Disposable d2 = Disposables.empty();
+        
+        cd.add(d2);
+        
+        assertFalse(cd.delete(d1));
+        
+        cd.dispose();
+        
+        assertFalse(cd.delete(d1));
+    }
+    
+    @Test
+    public void disposeRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void addRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.add(Disposables.empty());
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void addAllRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.addAll(Disposables.empty());
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void removeRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+            
+            final Disposable d1 = Disposables.empty();
+            
+            cd.add(d1);
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.remove(d1);
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void deleteRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+            
+            final Disposable d1 = Disposables.empty();
+
+            cd.add(d1);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.delete(d1);
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void clearRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+            
+            final Disposable d1 = Disposables.empty();
+
+            cd.add(d1);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.clear();
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void addDisposeRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+
+            Runnable run2 = new Runnable() {
+                @Override
+                public void run() {
+                    cd.add(Disposables.empty());
+                }
+            };
+
+            TestHelper.race(run, run2, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void addAllDisposeRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+
+            Runnable run2 = new Runnable() {
+                @Override
+                public void run() {
+                    cd.addAll(Disposables.empty());
+                }
+            };
+
+            TestHelper.race(run, run2, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void removeDisposeRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+
+            final Disposable d1 = Disposables.empty();
+
+            cd.add(d1);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+
+            Runnable run2 = new Runnable() {
+                @Override
+                public void run() {
+                    cd.remove(d1);
+                }
+            };
+
+            TestHelper.race(run, run2, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void deleteDisposeRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+
+            final Disposable d1 = Disposables.empty();
+
+            cd.add(d1);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+
+            Runnable run2 = new Runnable() {
+                @Override
+                public void run() {
+                    cd.delete(d1);
+                }
+            };
+
+            TestHelper.race(run, run2, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void clearDisposeRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+
+            final Disposable d1 = Disposables.empty();
+
+            cd.add(d1);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+
+            Runnable run2 = new Runnable() {
+                @Override
+                public void run() {
+                    cd.clear();
+                }
+            };
+
+            TestHelper.race(run, run2, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void sizeDisposeRace() {
+        for (int i = 0; i < 100; i++) {
+            final CompositeDisposable cd = new CompositeDisposable();
+
+            final Disposable d1 = Disposables.empty();
+
+            cd.add(d1);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+
+            Runnable run2 = new Runnable() {
+                @Override
+                public void run() {
+                    cd.size();
+                }
+            };
+
+            TestHelper.race(run, run2, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void disposeThrowsIAE() {
+        CompositeDisposable cd = new CompositeDisposable();
+        
+        cd.add(Disposables.from(new Action() {
+            @Override
+            public void run() throws Exception {
+                throw new IllegalArgumentException();
+            }
+        }));
+        
+        Disposable d1 = Disposables.empty();
+        
+        cd.add(d1);
+        
+        try {
+            cd.dispose();
+            fail("Failed to throw");
+        } catch (IllegalArgumentException ex) {
+            // expected
+        }
+        
+        assertTrue(d1.isDisposed());
+    }
+    
+    @Test
+    public void disposeThrowsError() {
+        CompositeDisposable cd = new CompositeDisposable();
+        
+        cd.add(Disposables.from(new Action() {
+            @Override
+            public void run() throws Exception {
+                throw new AssertionError();
+            }
+        }));
+        
+        Disposable d1 = Disposables.empty();
+        
+        cd.add(d1);
+        
+        try {
+            cd.dispose();
+            fail("Failed to throw");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        assertTrue(d1.isDisposed());
+    }
+
+    @Test
+    public void disposeThrowsCheckedException() {
+        CompositeDisposable cd = new CompositeDisposable();
+        
+        cd.add(Disposables.from(new Action() {
+            @Override
+            public void run() throws Exception {
+                throw new IOException();
+            }
+        }));
+        
+        Disposable d1 = Disposables.empty();
+        
+        cd.add(d1);
+        
+        try {
+            cd.dispose();
+            fail("Failed to throw");
+        } catch (RuntimeException ex) {
+            // expected
+            if (!(ex.getCause() instanceof IOException)) {
+                fail(ex.toString() + " should have thrown RuntimeException(IOException)");
+            }
+        }
+        
+        assertTrue(d1.isDisposed());
+    }
+    
+    @SuppressWarnings("unchecked")
+    static <E extends Throwable> void throwSneaky() throws E {
+        throw (E)new IOException();
+    }
+    
+    @Test
+    public void disposeThrowsCheckedExceptionSneaky() {
+        CompositeDisposable cd = new CompositeDisposable();
+        
+        cd.add(new Disposable() {
+            @Override
+            public void dispose() {
+                CompositeDisposableTest.<RuntimeException>throwSneaky();
+            }
+            
+            @Override
+            public boolean isDisposed() {
+                // TODO Auto-generated method stub
+                return false;
+            }
+        });
+        
+        Disposable d1 = Disposables.empty();
+        
+        cd.add(d1);
+        
+        try {
+            cd.dispose();
+            fail("Failed to throw");
+        } catch (RuntimeException ex) {
+            // expected
+            if (!(ex.getCause() instanceof IOException)) {
+                fail(ex.toString() + " should have thrown RuntimeException(IOException)");
+            }
+        }
+        
+        assertTrue(d1.isDisposed());
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/disposables/DisposablesTest.java b/src/test/java/io/reactivex/disposables/DisposablesTest.java
index cedda44b29..a7d4cbdb5b 100644
--- a/src/test/java/io/reactivex/disposables/DisposablesTest.java
+++ b/src/test/java/io/reactivex/disposables/DisposablesTest.java
@@ -16,8 +16,14 @@
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import org.junit.Test;
 
+import io.reactivex.TestHelper;
+import io.reactivex.functions.Action;
+
 
 public class DisposablesTest {
 
@@ -43,4 +49,71 @@ public void testUnsubscribed() {
         Disposable disposed = Disposables.disposed();
         assertTrue(disposed.isDisposed());
     }
+    
+    @Test
+    public void utilityClass() {
+        TestHelper.checkUtilityClass(Disposables.class);
+    }
+    
+    @Test
+    public void fromAction() {
+        class AtomicAction extends AtomicBoolean implements Action {
+            /** */
+            private static final long serialVersionUID = -1517510584253657229L;
+
+            @Override
+            public void run() throws Exception {
+                set(true);
+            }
+        }
+        
+        AtomicAction aa = new AtomicAction();
+        
+        Disposables.from(aa).dispose();
+        
+        assertTrue(aa.get());
+    }
+    
+    @Test
+    public void fromActionThrows() {
+        try {
+            Disposables.from(new Action() {
+                @Override
+                public void run() throws Exception {
+                    throw new IllegalArgumentException();
+                }
+            }).dispose();
+            fail("Should have thrown!");
+        } catch (IllegalArgumentException ex) {
+            // expected
+        }
+        
+        try {
+            Disposables.from(new Action() {
+                @Override
+                public void run() throws Exception {
+                    throw new InternalError();
+                }
+            }).dispose();
+            fail("Should have thrown!");
+        } catch (InternalError ex) {
+            // expected
+        }
+        
+        try {
+            Disposables.from(new Action() {
+                @Override
+                public void run() throws Exception {
+                    throw new IOException();
+                }
+            }).dispose();
+            fail("Should have thrown!");
+        } catch (RuntimeException ex) {
+            if (!(ex.getCause() instanceof IOException)) {
+                fail(ex.toString() + ": Should have cause of IOException");
+            }
+            // expected
+        }
+
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/disposables/SerialDisposableTests.java b/src/test/java/io/reactivex/disposables/SerialDisposableTests.java
index 860645a3f6..7b9a12a756 100644
--- a/src/test/java/io/reactivex/disposables/SerialDisposableTests.java
+++ b/src/test/java/io/reactivex/disposables/SerialDisposableTests.java
@@ -23,6 +23,8 @@
 import org.junit.runner.RunWith;
 import org.mockito.runners.MockitoJUnitRunner;
 
+import io.reactivex.internal.disposables.DisposableHelper;
+
 @RunWith(MockitoJUnitRunner.class)
 public class SerialDisposableTests {
     private SerialDisposable serialDisposable;
@@ -200,4 +202,22 @@ public void run() {
             t.join();
         }
     }
+    
+    @Test
+    public void disposeState() {
+        Disposable empty = Disposables.empty();
+        SerialDisposable d = new SerialDisposable(empty);
+        
+        assertFalse(d.isDisposed());
+        
+        assertSame(empty, d.get());
+        
+        d.dispose();
+        
+        assertTrue(d.isDisposed());
+        
+        assertNotSame(empty, d.get());
+        
+        assertNotSame(DisposableHelper.DISPOSED, d.get());
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/exceptions/CompositeExceptionTest.java b/src/test/java/io/reactivex/exceptions/CompositeExceptionTest.java
index 55276d9bbe..9a77cd2056 100644
--- a/src/test/java/io/reactivex/exceptions/CompositeExceptionTest.java
+++ b/src/test/java/io/reactivex/exceptions/CompositeExceptionTest.java
@@ -267,4 +267,85 @@ public void complexCauses() {
         // e1 -> e2 -> e3 -> e4 -> e5 -> e6
         assertEquals(Arrays.asList(e1, e2, e3, e4, e5, e6), causeChain);
     }
+    
+    @Test
+    public void constructorWithNull() {
+        assertTrue(new CompositeException((Throwable[])null).getExceptions().get(0) instanceof NullPointerException);
+
+        assertTrue(new CompositeException((Iterable<Throwable>)null).getExceptions().get(0) instanceof NullPointerException);
+
+        assertTrue(new CompositeException(null, new TestException()).getExceptions().get(0) instanceof NullPointerException);
+        
+        CompositeException ce1 = new CompositeException();
+        ce1.suppress(null);
+        
+        assertTrue(ce1.getExceptions().get(0) instanceof NullPointerException);
+    }
+    
+    @Test
+    public void isEmpty() {
+        assertTrue(new CompositeException().isEmpty());
+        
+        assertFalse(new CompositeException(new TestException()).isEmpty());
+        
+        CompositeException ce1 = new CompositeException();
+        ce1.initCause(new TestException());
+        
+        assertTrue(ce1.isEmpty());
+        
+        ce1.suppress(new TestException());
+        
+        assertEquals(1, ce1.size());
+    }
+    
+    @Test
+    public void printStackTrace() {
+        StringWriter sw = new StringWriter();
+        PrintWriter pw = new PrintWriter(sw);
+        
+        new CompositeException(new TestException()).printStackTrace(pw);
+        
+        assertTrue(sw.toString().contains("TestException"));
+    }
+    
+    @Test
+    public void cyclicRootCause() {
+        RuntimeException te = new RuntimeException() {
+            /** */
+            private static final long serialVersionUID = -8492568224555229753L;
+            Throwable cause;
+            
+            @Override
+            public Throwable initCause(Throwable c) {
+                return this;
+            }
+            
+            @Override
+            public Throwable getCause() {
+                return cause;
+            }
+        };
+        
+        assertSame(te, new CompositeException(te).getCause().getCause());
+        
+        assertSame(te, new CompositeException(new RuntimeException(te)).getCause().getCause().getCause());
+    }
+
+    @Test
+    public void nullRootCause() {
+        RuntimeException te = new RuntimeException() {
+            /** */
+            private static final long serialVersionUID = -8492568224555229753L;
+            
+            @Override
+            public Throwable getCause() {
+                return null;
+            }
+        };
+        
+        assertSame(te, new CompositeException(te).getCause().getCause());
+        
+        assertSame(te, new CompositeException(new RuntimeException(te)).getCause().getCause().getCause());
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/exceptions/ExceptionsTest.java b/src/test/java/io/reactivex/exceptions/ExceptionsTest.java
index 50a5b68e81..3cba90d6f4 100644
--- a/src/test/java/io/reactivex/exceptions/ExceptionsTest.java
+++ b/src/test/java/io/reactivex/exceptions/ExceptionsTest.java
@@ -442,4 +442,34 @@ public void onError(Throwable e) {
         public void onNext(Integer value) {
         }
     }
+
+    @Test
+    public void utilityClass() {
+        TestHelper.checkUtilityClass(Exceptions.class);
+    }
+    
+    @Test
+    public void manualThrowIfFatal() {
+        
+        try {
+            Exceptions.throwIfFatal(new ThreadDeath());
+            fail("Didn't throw fatal exception");
+        } catch (ThreadDeath ex) {
+            // expected
+        }
+        
+        try {
+            Exceptions.throwIfFatal(new LinkageError());
+            fail("Didn't throw fatal error");
+        } catch (LinkageError ex) {
+            // expected
+        }
+
+        try {
+            ExceptionHelper.wrapOrThrow(new LinkageError());
+            fail("Didn't propagate Error");
+        } catch (LinkageError ex) {
+            // expected
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/flowable/FlowableConversionTest.java b/src/test/java/io/reactivex/flowable/FlowableConversionTest.java
index 7968009036..bb3f59c3ca 100644
--- a/src/test/java/io/reactivex/flowable/FlowableConversionTest.java
+++ b/src/test/java/io/reactivex/flowable/FlowableConversionTest.java
@@ -20,11 +20,10 @@
 import org.junit.*;
 import org.reactivestreams.*;
 
-import io.reactivex.Flowable;
-import io.reactivex.FlowableOperator;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.operators.flowable.*;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
 
@@ -63,7 +62,7 @@ public void subscribe(Subscriber<T> subscriber) {
             try {
                 return operator.apply(onSubscribe);
             } catch (Throwable ex) {
-                throw Exceptions.propagate(ex);
+                throw ExceptionHelper.wrapOrThrow(ex);
             }
         }
 
@@ -71,7 +70,7 @@ public void subscribe(Subscriber<T> subscriber) {
             try {
                 return transformer.apply(this);
             } catch (Throwable ex) {
-                throw Exceptions.propagate(ex);
+                throw ExceptionHelper.wrapOrThrow(ex);
             }
         }
         
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableAwaitTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableAwaitTest.java
new file mode 100644
index 0000000000..01b3b8ce9b
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableAwaitTest.java
@@ -0,0 +1,45 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.completable;
+
+import static org.junit.Assert.fail;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.processors.PublishProcessor;
+
+public class CompletableAwaitTest {
+
+    @Test
+    public void emptyEnum() {
+        TestHelper.assertEmptyEnum(CompletableAwait.class);
+    }
+    
+    @Test
+    public void awaitInterrupted() {
+        
+        Thread.currentThread().interrupt();
+        
+        try {
+            PublishProcessor.create().toCompletable().blockingAwait();
+            fail("Should have thrown RuntimeException");
+        } catch (RuntimeException ex) {
+            if (!(ex.getCause() instanceof InterruptedException)) {
+                fail("Wrong cause: " + ex.getCause());
+            }
+        }
+        
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java
new file mode 100644
index 0000000000..ea6de8b5ee
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableConcatTest.java
@@ -0,0 +1,43 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.completable;
+
+import org.junit.Test;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.MissingBackpressureException;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+
+public class CompletableConcatTest {
+
+    @Test
+    public void overflowReported() {
+        Completable.concat(
+            Flowable.fromPublisher(new Publisher<Completable>() {
+                @Override
+                public void subscribe(Subscriber<? super Completable> s) {
+                    s.onSubscribe(new BooleanSubscription());
+                    s.onNext(Completable.never());
+                    s.onNext(Completable.never());
+                    s.onNext(Completable.never());
+                    s.onNext(Completable.never());
+                    s.onComplete();
+                }
+            }), 1
+        )
+        .test()
+        .assertFailure(MissingBackpressureException.class);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableAutoConnectTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableAutoConnectTest.java
new file mode 100644
index 0000000000..09c06c84b0
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableAutoConnectTest.java
@@ -0,0 +1,32 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.flowable;
+
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Test;
+
+import io.reactivex.processors.PublishProcessor;
+
+public class FlowableAutoConnectTest {
+
+    @Test
+    public void autoConnectImmediately() {
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+        
+        ps.publish().autoConnect(0);
+        
+        assertTrue(ps.hasSubscribers());
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoAfterTerminateTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoAfterTerminateTest.java
index a4861f721f..d4ab56dc5e 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoAfterTerminateTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoAfterTerminateTest.java
@@ -23,8 +23,8 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Action;
+import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableDoAfterTerminateTest {
@@ -43,7 +43,7 @@ private void checkActionCalled(Flowable<String> input) {
         try {
             verify(aAction0, times(1)).run();
         } catch (Throwable ex) {
-            throw Exceptions.propagate(ex);
+            throw ExceptionHelper.wrapOrThrow(ex);
         }
     }
 
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java
index 9e7544c272..f1941e0be0 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java
@@ -13,6 +13,8 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import static org.junit.Assert.*;
+
 import org.junit.*;
 import org.reactivestreams.*;
 
@@ -37,6 +39,13 @@ public void before() {
         ts = new TestSubscriber<Integer>(0L);
     }
     
+    @Test
+    public void backpressureModeEnum() {
+        assertEquals(5, FlowableEmitter.BackpressureMode.values().length);
+        
+        assertNotNull(FlowableEmitter.BackpressureMode.valueOf("BUFFER"));
+    }
+    
     @Test
     public void normalBuffered() {
         Flowable.create(source, FlowableEmitter.BackpressureMode.BUFFER).subscribe(ts);
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableAutoConnectTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableAutoConnectTest.java
new file mode 100644
index 0000000000..6a11f0398d
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableAutoConnectTest.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.observable;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+import io.reactivex.subjects.PublishSubject;
+
+public class ObservableAutoConnectTest {
+
+    @Test
+    public void autoConnectImmediately() {
+        PublishSubject<Integer> ps = PublishSubject.create();
+        
+        ps.publish().autoConnect(0);
+        
+        assertTrue(ps.hasObservers());
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableFinallyTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableFinallyTest.java
index 1e631600b9..35b3e40c0a 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableFinallyTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFinallyTest.java
@@ -18,8 +18,8 @@
 import org.junit.*;
 
 import io.reactivex.*;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Action;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public class ObservableFinallyTest {
 
@@ -38,7 +38,7 @@ private void checkActionCalled(Observable<String> input) {
         try {
             verify(aAction0, times(1)).run();
         } catch (Throwable e) {
-            throw Exceptions.propagate(e);
+            throw ExceptionHelper.wrapOrThrow(e);
         }
     }
 
diff --git a/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java
new file mode 100644
index 0000000000..0f23f28a89
--- /dev/null
+++ b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java
@@ -0,0 +1,1602 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.reactivex.plugins;
+
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+import java.lang.Thread.UncaughtExceptionHandler;
+import java.lang.reflect.*;
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.*;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.Scheduler.Worker;
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.flowables.ConnectableFlowable;
+import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.internal.operators.completable.CompletableError;
+import io.reactivex.internal.operators.flowable.FlowableRange;
+import io.reactivex.internal.operators.observable.ObservableRange;
+import io.reactivex.internal.operators.single.SingleJust;
+import io.reactivex.internal.schedulers.ImmediateThinScheduler;
+import io.reactivex.internal.subscriptions.ScalarSubscription;
+import io.reactivex.observables.ConnectableObservable;
+import io.reactivex.schedulers.Schedulers;
+
+public class RxJavaPluginsTest {
+
+//    static Observable<Integer> createObservable() {
+//        return Observable.range(1, 5).map(new Function<Integer, Integer>() {
+//            @Override
+//            public Integer apply(Integer t) {
+//                throw new TestException();
+//            }
+//        });
+//    }
+//    
+//    static Flowable<Integer> createFlowable() {
+//        return Flowable.range(1, 5).map(new Function<Integer, Integer>() {
+//            @Override
+//            public Integer apply(Integer t) {
+//                throw new TestException();
+//            }
+//        });
+//    }
+    
+    @Test
+    public void constructorShouldBePrivate() {
+        TestHelper.checkUtilityClass(RxJavaPlugins.class);
+    }
+
+    @Test
+    @Ignore("Not part of 2.0")
+    public void assemblyTrackingObservable() {
+//        RxJavaPlugins.enableAssemblyTracking();
+//        try {
+//            TestSubscriber<Integer> ts = TestSubscriber.create();
+//            
+//            createObservable().subscribe(ts);
+//            
+//            ts.assertError(TestException.class);
+//            
+//            Throwable ex = ts.getOnErrorEvents().get(0);
+//            
+//            AssemblyStackTraceException aste = AssemblyStackTraceException.find(ex);
+//            
+//            assertNotNull(aste);
+//            
+//            assertTrue(aste.getMessage(), aste.getMessage().contains("createObservable"));
+//            
+//            RxJavaPlugins.clearAssemblyTracking();
+//
+//            ts = TestSubscriber.create();
+//            
+//            createObservable().subscribe(ts);
+//
+//            ts.assertError(TestException.class);
+//            
+//            ex = ts.getOnErrorEvents().get(0);
+//            
+//            aste = AssemblyStackTraceException.find(ex);
+//
+//            assertNull(aste);
+//        } finally {
+//            RxJavaPlugins.resetAssemblyTracking();
+//        }
+    }
+    
+//    static Single<Integer> createSingle() {
+//        return Single.just(1).map(new Function<Integer, Integer>() {
+//            @Override
+//            public Integer apply(Integer t) {
+//                throw new TestException();
+//            }
+//        });
+//    }
+    
+    @Test
+    @Ignore("Not part of 2.0")
+    public void assemblyTrackingSingle() {
+//        RxJavaPlugins.enableAssemblyTracking();
+//        try {
+//            TestSubscriber<Integer> ts = TestSubscriber.create();
+//            
+//            createSingle().subscribe(ts);
+//            
+//            ts.assertError(TestException.class);
+//            
+//            Throwable ex = ts.getOnErrorEvents().get(0);
+//            
+//            AssemblyStackTraceException aste = AssemblyStackTraceException.find(ex);
+//            
+//            assertNotNull(aste);
+//            
+//            assertTrue(aste.getMessage(), aste.getMessage().contains("createSingle"));
+//
+//            RxJavaPlugins.clearAssemblyTracking();
+//
+//            ts = TestSubscriber.create();
+//            
+//            createSingle().subscribe(ts);
+//
+//            ts.assertError(TestException.class);
+//            
+//            ex = ts.getOnErrorEvents().get(0);
+//            
+//            aste = AssemblyStackTraceException.find(ex);
+//
+//            assertNull(aste);
+//        } finally {
+//            RxJavaPlugins.resetAssemblyTracking();
+//        }
+    }
+    
+//    static Completable createCompletable() {
+//        return Completable.error(new Callable<Throwable>() {
+//            @Override
+//            public Throwable call() {
+//                return new TestException();
+//            }
+//        });
+//    }
+    
+    @Test
+    @Ignore("Not part of 2.0")
+    public void assemblyTrackingCompletable() {
+//        RxJavaPlugins.enableAssemblyTracking();
+//        try {
+//            TestSubscriber<Integer> ts = TestSubscriber.create();
+//            
+//            createCompletable().subscribe(ts);
+//            
+//            ts.assertError(TestException.class);
+//            
+//            Throwable ex = ts.getOnErrorEvents().get(0);
+//            
+//            AssemblyStackTraceException aste = AssemblyStackTraceException.find(ex);
+//            
+//            assertNotNull(aste);
+//            
+//            assertTrue(aste.getMessage(), aste.getMessage().contains("createCompletable"));
+//
+//            RxJavaPlugins.clearAssemblyTracking();
+//
+//            ts = TestSubscriber.create();
+//            
+//            createCompletable().subscribe(ts);
+//
+//            ts.assertError(TestException.class);
+//
+//            ex = ts.getOnErrorEvents().get(0);
+//            
+//            aste = AssemblyStackTraceException.find(ex);
+//
+//            assertNull(aste);
+//            
+//        } finally {
+//            RxJavaPlugins.resetAssemblyTracking();
+//        }
+    }
+    
+    @SuppressWarnings({ "rawtypes" })
+    @Test
+    public void lockdown() throws Exception {
+        RxJavaPlugins.reset();
+        RxJavaPlugins.lockdown();
+        try {
+            assertTrue(RxJavaPlugins.isLockdown());
+            Consumer a1 = Functions.emptyConsumer();
+            Callable f0 = new Callable() {
+                @Override
+                public Object call() {
+                    return null;
+                }
+            };
+            Function f1 = Functions.identity();
+            BiFunction f2 = new BiFunction() {
+                @Override
+                public Object apply(Object t1, Object t2) {
+                    return t2;
+                }
+            };
+            
+            for (Method m : RxJavaPlugins.class.getMethods()) {
+                if (m.getName().startsWith("set")) {
+                    
+                    Method getter = RxJavaPlugins.class.getMethod("get" + m.getName().substring(3));
+                    
+                    Object before = getter.invoke(null);
+                    
+                    try {
+                        if (m.getParameterTypes()[0].isAssignableFrom(Callable.class)) {
+                            m.invoke(null, f0);
+                        } else
+                        if (m.getParameterTypes()[0].isAssignableFrom(Function.class)) {
+                            m.invoke(null, f1);
+                        } else
+                        if (m.getParameterTypes()[0].isAssignableFrom(Consumer.class)) {
+                            m.invoke(null, a1);
+                        } else {
+                            m.invoke(null, f2);
+                        }
+                        fail("Should have thrown InvocationTargetException(IllegalStateException)");
+                    } catch (InvocationTargetException ex) {
+                        if (ex.getCause() instanceof IllegalStateException) {
+                            assertEquals("Plugins can't be changed anymore",ex.getCause().getMessage());
+                        } else {
+                            fail("Should have thrown InvocationTargetException(IllegalStateException)");
+                        }
+                    }
+                    
+                    Object after = getter.invoke(null);
+                    
+                    assertSame(m.toString(), before, after);
+                }
+            }
+            
+//            Object o1 = RxJavaPlugins.getOnObservableCreate();
+//            Object o2 = RxJavaPlugins.getOnSingleCreate();
+//            Object o3 = RxJavaPlugins.getOnCompletableCreate();
+//            
+//            RxJavaPlugins.enableAssemblyTracking();
+//            RxJavaPlugins.clearAssemblyTracking();
+//            RxJavaPlugins.resetAssemblyTracking();
+//
+//            
+//            assertSame(o1, RxJavaPlugins.getOnObservableCreate());
+//            assertSame(o2, RxJavaPlugins.getOnSingleCreate());
+//            assertSame(o3, RxJavaPlugins.getOnCompletableCreate());
+            
+        } finally {
+            RxJavaPlugins.unlock();
+            RxJavaPlugins.reset();
+            assertFalse(RxJavaPlugins.isLockdown());
+        }
+    }
+    
+    Function<Scheduler, Scheduler> replaceWithImmediate = new Function<Scheduler, Scheduler>() {
+        @Override
+        public Scheduler apply(Scheduler t) {
+            return ImmediateThinScheduler.INSTANCE;
+        }
+    };
+
+    @Test
+    public void overrideSingleScheduler() {
+        try {
+            RxJavaPlugins.setSingleSchedulerHandler(replaceWithImmediate);
+            
+            assertSame(ImmediateThinScheduler.INSTANCE, Schedulers.single());
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.computation());
+    }
+
+    @Test
+    public void overrideComputationScheduler() {
+        try {
+            RxJavaPlugins.setComputationSchedulerHandler(replaceWithImmediate);
+            
+            assertSame(ImmediateThinScheduler.INSTANCE, Schedulers.computation());
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.computation());
+    }
+
+    @Test
+    public void overrideIoScheduler() {
+        try {
+            RxJavaPlugins.setIoSchedulerHandler(replaceWithImmediate);
+            
+            assertSame(ImmediateThinScheduler.INSTANCE, Schedulers.io());
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.io());
+    }
+
+    @Test
+    public void overrideNewThreadScheduler() {
+        try {
+            RxJavaPlugins.setNewThreadSchedulerHandler(replaceWithImmediate);
+            
+            assertSame(ImmediateThinScheduler.INSTANCE, Schedulers.newThread());
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.newThread());
+    }
+
+    @Test
+    public void overrideInitSingleScheduler() {
+        Scheduler s = Schedulers.single(); // make sure the Schedulers is initialized
+        try {
+            RxJavaPlugins.setInitSingleSchedulerHandler(replaceWithImmediate);
+            
+            assertSame(ImmediateThinScheduler.INSTANCE, RxJavaPlugins.initSingleScheduler(s));
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        assertSame(s, RxJavaPlugins.initSingleScheduler(s));
+    }
+
+    @Test
+    public void overrideInitComputationScheduler() {
+        Scheduler s = Schedulers.computation(); // make sure the Schedulers is initialized
+        try {
+            RxJavaPlugins.setInitComputationSchedulerHandler(replaceWithImmediate);
+            
+            assertSame(ImmediateThinScheduler.INSTANCE, RxJavaPlugins.initComputationScheduler(s));
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        assertSame(s, RxJavaPlugins.initComputationScheduler(s));
+    }
+
+    @Test
+    public void overrideInitIoScheduler() {
+        Scheduler s = Schedulers.io(); // make sure the Schedulers is initialized
+        try {
+            RxJavaPlugins.setInitIoSchedulerHandler(replaceWithImmediate);
+            
+            assertSame(ImmediateThinScheduler.INSTANCE, RxJavaPlugins.initIoScheduler(s));
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        assertSame(s, RxJavaPlugins.initIoScheduler(s));
+    }
+
+    @Test
+    public void overrideInitNewThreadScheduler() {
+        Scheduler s = Schedulers.newThread(); // make sure the Schedulers is initialized
+        try {
+            RxJavaPlugins.setInitNewThreadSchedulerHandler(replaceWithImmediate);
+            
+            assertSame(ImmediateThinScheduler.INSTANCE, RxJavaPlugins.initNewThreadScheduler(s));
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        assertSame(s, RxJavaPlugins.initNewThreadScheduler(s));
+    }
+
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void observableCreate() {
+        try {
+            RxJavaPlugins.setOnObservableAssembly(new Function<Observable, Observable>() {
+                @Override
+                public Observable apply(Observable t) {
+                    return new ObservableRange(1, 2);
+                }
+            });
+            
+            Observable.range(10, 3)
+            .test()
+            .assertValues(1, 2)
+            .assertNoErrors()
+            .assertComplete();
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        Observable.range(10, 3)
+        .test()
+        .assertValues(10, 11, 12)
+        .assertNoErrors()
+        .assertComplete();
+    }
+
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void flowableCreate() {
+        try {
+            RxJavaPlugins.setOnFlowableAssembly(new Function<Flowable, Flowable>() {
+                @Override
+                public Flowable apply(Flowable t) {
+                    return new FlowableRange(1, 2);
+                }
+            });
+            
+            Flowable.range(10, 3)
+            .test()
+            .assertValues(1, 2)
+            .assertNoErrors()
+            .assertComplete();
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        Flowable.range(10, 3)
+        .test()
+        .assertValues(10, 11, 12)
+        .assertNoErrors()
+        .assertComplete();
+    }
+
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void observableStart() {
+        try {
+            RxJavaPlugins.setOnObservableSubscribe(new BiFunction<Observable, Observer, Observer>() {
+                @Override
+                public Observer apply(Observable o, final Observer t) {
+                    return new Observer() {
+
+                        @Override
+                        public void onSubscribe(Disposable d) {
+                            t.onSubscribe(d);
+                        }
+
+                        @SuppressWarnings("unchecked")
+                        @Override
+                        public void onNext(Object value) {
+                            t.onNext((Integer)value - 9);
+                        }
+
+                        @Override
+                        public void onError(Throwable e) {
+                            t.onError(e);
+                        }
+
+                        @Override
+                        public void onComplete() {
+                            t.onComplete();
+                        }
+                        
+                    };
+                }
+            });
+            
+            Observable.range(10, 3)
+            .test()
+            .assertValues(1, 2, 3)
+            .assertNoErrors()
+            .assertComplete();
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        Observable.range(10, 3)
+        .test()
+        .assertValues(10, 11, 12)
+        .assertNoErrors()
+        .assertComplete();
+    }
+
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void flowableStart() {
+        try {
+            RxJavaPlugins.setOnFlowableSubscribe(new BiFunction<Flowable, Subscriber, Subscriber>() {
+                @Override
+                public Subscriber apply(Flowable o, final Subscriber t) {
+                    return new Subscriber() {
+
+                        @Override
+                        public void onSubscribe(Subscription d) {
+                            t.onSubscribe(d);
+                        }
+
+                        @SuppressWarnings("unchecked")
+                        @Override
+                        public void onNext(Object value) {
+                            t.onNext((Integer)value - 9);
+                        }
+
+                        @Override
+                        public void onError(Throwable e) {
+                            t.onError(e);
+                        }
+
+                        @Override
+                        public void onComplete() {
+                            t.onComplete();
+                        }
+                        
+                    };
+                }
+            });
+            
+            Flowable.range(10, 3)
+            .test()
+            .assertValues(1, 2, 3)
+            .assertNoErrors()
+            .assertComplete();
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        Flowable.range(10, 3)
+        .test()
+        .assertValues(10, 11, 12)
+        .assertNoErrors()
+        .assertComplete();
+    }
+
+    @Test
+    @Ignore("Different architecture, no longer supported")
+    public void observableReturn() {
+//        try {
+//            final Subscription s = Subscriptions.empty();
+//            
+//            RxJavaPlugins.setOnObservableReturn(new Function<Subscription, Subscription>() {
+//                @Override
+//                public Subscription call(Subscription t) {
+//                    return s;
+//                }
+//            });
+//            
+//            TestSubscriber<Integer> ts = TestSubscriber.create();
+//            
+//            Subscription u = Observable.range(10, 3).subscribe(ts);
+//            
+//            ts.assertValues(10, 11, 12);
+//            ts.assertNoErrors();
+//            ts.assertComplete();
+//            
+//            assertSame(s, u);
+//        } finally {
+//            RxJavaPlugins.reset();
+//        }
+    }
+
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void singleCreate() {
+        try {
+            RxJavaPlugins.setOnSingleAssembly(new Function<Single, Single>() {
+                @Override
+                public Single apply(Single t) {
+                    return new SingleJust<Integer>(10);
+                }
+            });
+            
+            Single.just(1)
+            .test()
+            .assertValue(10)
+            .assertNoErrors()
+            .assertComplete();
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        Single.just(1)
+        .test()
+        .assertValue(1)
+        .assertNoErrors()
+        .assertComplete();
+    }
+    
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void singleStart() {
+        try {
+            RxJavaPlugins.setOnSingleSubscribe(new BiFunction<Single, SingleObserver, SingleObserver>() {
+                @Override
+                public SingleObserver apply(Single o, final SingleObserver t) {
+                    return new SingleObserver<Object>() {
+
+                        @Override
+                        public void onSubscribe(Disposable d) {
+                            t.onSubscribe(d);
+                        }
+
+                        @SuppressWarnings("unchecked")
+                        @Override
+                        public void onSuccess(Object value) {
+                            t.onSuccess(10);
+                        }
+
+                        @Override
+                        public void onError(Throwable e) {
+                            t.onError(e);
+                        }
+                        
+                    };
+                }
+            });
+            
+            Single.just(1)
+            .test()
+            .assertValue(10)
+            .assertNoErrors()
+            .assertComplete();
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        Single.just(1)
+        .test()
+        .assertValue(1)
+        .assertNoErrors()
+        .assertComplete();
+    }
+    
+    @Test
+    @Ignore("Different architecture, no longer supported")
+    public void singleReturn() {
+//        try {
+//            final Subscription s = Subscriptions.empty();
+//            
+//            RxJavaPlugins.setOnSingleReturn(new Function<Subscription, Subscription>() {
+//                @Override
+//                public Subscription call(Subscription t) {
+//                    return s;
+//                }
+//            });
+//            
+//            TestSubscriber<Integer> ts = TestSubscriber.create();
+//            
+//            Subscription u = Single.just(1).subscribe(ts);
+//            
+//            ts.assertValue(1);
+//            ts.assertNoErrors();
+//            ts.assertComplete();
+//            
+//            assertSame(s, u);
+//        } finally {
+//            RxJavaPlugins.reset();
+//        }
+    }
+
+    @Test
+    public void completableCreate() {
+        try {
+            RxJavaPlugins.setOnCompletableAssembly(new Function<Completable, Completable>() {
+                @Override
+                public Completable apply(Completable t) {
+                    return new CompletableError(new TestException());
+                }
+            });
+            
+            Completable.complete()
+            .test()
+            .assertNoValues()
+            .assertNotComplete()
+            .assertError(TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        Completable.complete()
+        .test()
+        .assertNoValues()
+        .assertNoErrors()
+        .assertComplete();
+    }
+    
+    @Test
+    public void completableStart() {
+        try {
+            RxJavaPlugins.setOnCompletableSubscribe(new BiFunction<Completable, CompletableObserver, CompletableObserver>() {
+                @Override
+                public CompletableObserver apply(Completable o, final CompletableObserver t) {
+                    return new CompletableObserver() {
+                        @Override
+                        public void onSubscribe(Disposable d) {
+                            t.onSubscribe(d);
+                        }
+                        
+                        @Override
+                        public void onError(Throwable e) {
+                            t.onError(e);
+                        }
+                        
+                        @Override
+                        public void onComplete() {
+                            t.onError(new TestException());
+                        }
+                    };
+                }
+            });
+            
+            Completable.complete()
+            .test()
+            .assertNoValues()
+            .assertNotComplete()
+            .assertError(TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        
+        Completable.complete()
+        .test()
+        .assertNoValues()
+        .assertNoErrors()
+        .assertComplete();
+    }
+
+    void onSchedule(Worker w) throws InterruptedException {
+        try {
+            try {
+                final AtomicInteger value = new AtomicInteger();
+                final CountDownLatch cdl = new CountDownLatch(1);
+                
+                RxJavaPlugins.setScheduleHandler(new Function<Runnable, Runnable>() {
+                    @Override
+                    public Runnable apply(Runnable t) {
+                        return new Runnable() {
+                            @Override
+                            public void run() {
+                                value.set(10);
+                                cdl.countDown();
+                            }
+                        };
+                    }
+                });
+                
+                w.schedule(new Runnable() {
+                    @Override
+                    public void run() {
+                        value.set(1);
+                        cdl.countDown();
+                    }
+                });
+                
+                cdl.await();
+                
+                assertEquals(10, value.get());
+                
+            } finally {
+                
+                RxJavaPlugins.reset();
+            }
+            
+            // make sure the reset worked
+            final AtomicInteger value = new AtomicInteger();
+            final CountDownLatch cdl = new CountDownLatch(1);
+            
+            w.schedule(new Runnable() {
+                @Override
+                public void run() {
+                    value.set(1);
+                    cdl.countDown();
+                }
+            });
+            
+            cdl.await();
+            
+            assertEquals(1, value.get());
+        } finally {
+            w.dispose();
+        }
+    }
+    
+    @Test
+    public void onScheduleComputation() throws InterruptedException {
+        onSchedule(Schedulers.computation().createWorker());
+    }
+
+    @Test
+    public void onScheduleIO() throws InterruptedException {
+        onSchedule(Schedulers.io().createWorker());
+    }
+
+    @Test
+    public void onScheduleNewThread() throws InterruptedException {
+        onSchedule(Schedulers.newThread().createWorker());
+    }
+
+    @Test
+    public void onError() {
+        try {
+            final List<Throwable> list = new ArrayList<Throwable>();
+            
+            RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+                @Override
+                public void accept(Throwable t) {
+                    list.add(t);
+                }
+            });
+            
+            RxJavaPlugins.onError(new TestException("Forced failure"));
+            
+            assertEquals(1, list.size());
+            assertTestException(list, 0, "Forced failure");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    @Ignore("No (need for) clear() method in 2.0")
+    public void clear() throws Exception {
+//        RxJavaPlugins.reset();
+//        try {
+//            RxJavaPlugins.clear();
+//            for (Method m : RxJavaPlugins.class.getMethods()) {
+//                if (m.getName().startsWith("getOn")) {
+//                    assertNull(m.toString(), m.invoke(null));
+//                }
+//            }
+//
+//        } finally {
+//            RxJavaPlugins.reset();
+//        }
+//
+//        for (Method m : RxJavaPlugins.class.getMethods()) {
+//            if (m.getName().startsWith("getOn") 
+//                    && !m.getName().endsWith("Scheduler")
+//                    && !m.getName().contains("GenericScheduledExecutorService")) {
+//                assertNotNull(m.toString(), m.invoke(null));
+//            }
+//        }
+    }
+
+    @Test
+    public void onErrorNoHandler() {
+        try {
+            final List<Throwable> list = new ArrayList<Throwable>();
+            
+            RxJavaPlugins.setErrorHandler(null);
+            
+            Thread.currentThread().setUncaughtExceptionHandler(new UncaughtExceptionHandler() {
+                
+                @Override
+                public void uncaughtException(Thread t, Throwable e) {
+                    list.add(e);
+                    
+                }
+            });
+            
+            RxJavaPlugins.onError(new TestException("Forced failure"));
+
+            Thread.currentThread().setUncaughtExceptionHandler(null);
+
+            // this will be printed on the console and should not crash
+            RxJavaPlugins.onError(new TestException("Forced failure 3"));
+
+            assertEquals(1, list.size());
+            assertTestException(list, 0, "Forced failure");
+        } finally {
+            RxJavaPlugins.reset();
+            Thread.currentThread().setUncaughtExceptionHandler(null);
+        }
+    }
+
+    @Test
+    public void onErrorCrashes() {
+        try {
+            final List<Throwable> list = new ArrayList<Throwable>();
+            
+            RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+                @Override
+                public void accept(Throwable t) {
+                    throw new TestException("Forced failure 2");
+                }
+            });
+
+            Thread.currentThread().setUncaughtExceptionHandler(new UncaughtExceptionHandler() {
+                
+                @Override
+                public void uncaughtException(Thread t, Throwable e) {
+                    list.add(e);
+                    
+                }
+            });
+
+            RxJavaPlugins.onError(new TestException("Forced failure"));
+            
+            assertEquals(2, list.size());
+            assertTestException(list, 0, "Forced failure 2");
+            assertTestException(list, 1, "Forced failure");
+
+            Thread.currentThread().setUncaughtExceptionHandler(null);
+            
+        } finally {
+            RxJavaPlugins.reset();
+            Thread.currentThread().setUncaughtExceptionHandler(null);
+        }
+    }
+
+    @Test
+    public void onErrorWithNull() {
+        try {
+            final List<Throwable> list = new ArrayList<Throwable>();
+            
+            RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
+                @Override
+                public void accept(Throwable t) {
+                    throw new TestException("Forced failure 2");
+                }
+            });
+
+            Thread.currentThread().setUncaughtExceptionHandler(new UncaughtExceptionHandler() {
+                
+                @Override
+                public void uncaughtException(Thread t, Throwable e) {
+                    list.add(e);
+                    
+                }
+            });
+
+            RxJavaPlugins.onError(null);
+            
+            assertEquals(2, list.size());
+            assertTestException(list, 0, "Forced failure 2");
+            assertNPE(list, 1);
+
+            RxJavaPlugins.reset();
+            
+            RxJavaPlugins.onError(null);
+            
+            assertNPE(list, 2);
+
+        } finally {
+            RxJavaPlugins.reset();
+            
+            Thread.currentThread().setUncaughtExceptionHandler(null);
+        }
+    }
+
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    @Test
+    public void clearIsPassthrough() {
+        try {
+            RxJavaPlugins.reset();
+            
+            assertNull(RxJavaPlugins.onAssembly((Observable)null));
+
+            assertNull(RxJavaPlugins.onAssembly((ConnectableObservable)null));
+
+            assertNull(RxJavaPlugins.onAssembly((Flowable)null));
+            
+            assertNull(RxJavaPlugins.onAssembly((ConnectableFlowable)null));
+
+            Observable oos = new Observable() {
+                @Override
+                public void subscribeActual(Observer t) {
+                    
+                }
+            };
+
+            Flowable fos = new Flowable() {
+                @Override
+                public void subscribeActual(Subscriber t) {
+                    
+                }
+            };
+
+            assertSame(oos, RxJavaPlugins.onAssembly(oos));
+
+            assertSame(fos, RxJavaPlugins.onAssembly(fos));
+
+            assertNull(RxJavaPlugins.onAssembly((Single)null));
+
+            Single sos = new Single() {
+                @Override
+                public void subscribeActual(SingleObserver t) {
+                    
+                }
+            };
+
+            assertSame(sos, RxJavaPlugins.onAssembly(sos));
+            
+            assertNull(RxJavaPlugins.onAssembly((Completable)null));
+
+            Completable cos = new Completable() {
+                @Override
+                public void subscribeActual(CompletableObserver t) {
+                    
+                }
+            };
+
+            assertSame(cos, RxJavaPlugins.onAssembly(cos));
+            
+            assertNull(RxJavaPlugins.onSchedule(null));
+            
+            Runnable action = Functions.EMPTY_RUNNABLE;
+            
+            assertSame(action, RxJavaPlugins.onSchedule(action));
+            
+            class AllSubscriber implements Subscriber, Observer, SingleObserver, CompletableObserver {
+
+                @Override
+                public void onSuccess(Object value) {
+                    
+                }
+
+                @Override
+                public void onSubscribe(Disposable d) {
+                    
+                }
+
+                @Override
+                public void onSubscribe(Subscription s) {
+                    
+                }
+
+                @Override
+                public void onNext(Object t) {
+                    
+                }
+
+                @Override
+                public void onError(Throwable t) {
+                    
+                }
+
+                @Override
+                public void onComplete() {
+                    
+                }
+                
+            }
+            
+            AllSubscriber all = new AllSubscriber();
+            
+            assertNull(RxJavaPlugins.onSubscribe(Observable.never(), null));
+            
+            assertSame(all, RxJavaPlugins.onSubscribe(Observable.never(), all));
+
+            assertNull(RxJavaPlugins.onSubscribe(Flowable.never(), null));
+            
+            assertSame(all, RxJavaPlugins.onSubscribe(Flowable.never(), all));
+
+            assertNull(RxJavaPlugins.onSubscribe(Single.just(1), null));
+            
+            assertSame(all, RxJavaPlugins.onSubscribe(Single.just(1), all));
+
+            assertNull(RxJavaPlugins.onSubscribe(Completable.never(), null));
+            
+            assertSame(all, RxJavaPlugins.onSubscribe(Completable.never(), all));
+
+            // These hooks don't exist in 2.0
+//            Subscription subscription = Subscriptions.empty();
+//            
+//            assertNull(RxJavaPlugins.onObservableReturn(null));
+//            
+//            assertSame(subscription, RxJavaPlugins.onObservableReturn(subscription));
+//
+//            assertNull(RxJavaPlugins.onSingleReturn(null));
+//            
+//            assertSame(subscription, RxJavaPlugins.onSingleReturn(subscription));
+//
+//            TestException ex = new TestException();
+//            
+//            assertNull(RxJavaPlugins.onObservableError(null));
+//            
+//            assertSame(ex, RxJavaPlugins.onObservableError(ex));
+//
+//            assertNull(RxJavaPlugins.onSingleError(null));
+//            
+//            assertSame(ex, RxJavaPlugins.onSingleError(ex));
+//
+//            assertNull(RxJavaPlugins.onCompletableError(null));
+//            
+//            assertSame(ex, RxJavaPlugins.onCompletableError(ex));
+//
+//            Observable.Operator oop = new Observable.Operator() {
+//                @Override
+//                public Object call(Object t) {
+//                    return t;
+//                }
+//            };
+//            
+//            assertNull(RxJavaPlugins.onObservableLift(null));
+//            
+//            assertSame(oop, RxJavaPlugins.onObservableLift(oop));
+//            
+//            assertNull(RxJavaPlugins.onSingleLift(null));
+//            
+//            assertSame(oop, RxJavaPlugins.onSingleLift(oop));
+//            
+//            Completable.CompletableOperator cop = new Completable.CompletableOperator() {
+//                @Override
+//                public CompletableSubscriber call(CompletableSubscriber t) {
+//                    return t;
+//                }
+//            };
+//            
+//            assertNull(RxJavaPlugins.onCompletableLift(null));
+//            
+//            assertSame(cop, RxJavaPlugins.onCompletableLift(cop));
+              
+            assertNull(RxJavaPlugins.onComputationScheduler(null));
+
+            assertNull(RxJavaPlugins.onIoScheduler(null));
+
+            assertNull(RxJavaPlugins.onNewThreadScheduler(null));
+
+            assertNull(RxJavaPlugins.onSingleScheduler(null));
+
+            Scheduler s = ImmediateThinScheduler.INSTANCE;
+
+            assertSame(s, RxJavaPlugins.onComputationScheduler(s));
+
+            assertSame(s, RxJavaPlugins.onIoScheduler(s));
+
+            assertSame(s, RxJavaPlugins.onNewThreadScheduler(s));
+
+            assertSame(s, RxJavaPlugins.onSingleScheduler(s));
+
+            
+            assertNull(RxJavaPlugins.initComputationScheduler(null));
+
+            assertNull(RxJavaPlugins.initIoScheduler(null));
+
+            assertNull(RxJavaPlugins.initNewThreadScheduler(null));
+
+            assertNull(RxJavaPlugins.initSingleScheduler(null));
+
+            assertSame(s, RxJavaPlugins.initComputationScheduler(s));
+
+            assertSame(s, RxJavaPlugins.initIoScheduler(s));
+
+            assertSame(s, RxJavaPlugins.initNewThreadScheduler(s));
+
+            assertSame(s, RxJavaPlugins.initSingleScheduler(s));
+
+            
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    static void assertTestException(List<Throwable> list, int index, String message) {
+        assertTrue(list.get(index).toString(), list.get(index) instanceof TestException);
+        assertEquals(message, list.get(index).getMessage());
+    }
+
+    static void assertNPE(List<Throwable> list, int index) {
+        assertTrue(list.get(index).toString(), list.get(index) instanceof NullPointerException);
+    }
+
+    @Test
+    @Ignore("Not present in 2.0")
+    public void onXError() {
+//        try {
+//            final List<Throwable> list = new ArrayList<Throwable>();
+//            
+//            final TestException ex = new TestException();
+//            
+//            Function<Throwable, Throwable> errorHandler = new Function<Throwable, Throwable>() {
+//                @Override
+//                public Throwable a(Throwable t) {
+//                    list.add(t);
+//                    return ex;
+//                }
+//            };
+//            
+//            RxJavaPlugins.setOnObservableSubscribeError(errorHandler);
+//
+//            RxJavaPlugins.setOnSingleSubscribeError(errorHandler);
+//
+//            RxJavaPlugins.setOnCompletableSubscribeError(errorHandler);
+//
+//            assertSame(ex, RxJavaPlugins.onObservableError(new TestException("Forced failure 1")));
+//
+//            assertSame(ex, RxJavaPlugins.onSingleError(new TestException("Forced failure 2")));
+//            
+//            assertSame(ex, RxJavaPlugins.onCompletableError(new TestException("Forced failure 3")));
+//            
+//            assertTestException(list, 0, "Forced failure 1");
+//            
+//            assertTestException(list, 1, "Forced failure 2");
+//
+//            assertTestException(list, 2, "Forced failure 3");
+//        } finally {
+//            RxJavaPlugins.reset();
+//        }
+    }
+
+//    @SuppressWarnings("deprecation")
+    @Test
+    @Ignore("Not present in 2.0")
+    public void onPluginsXError() {
+//        try {
+//            RxJavaPlugins.reset();
+//            
+//            final List<Throwable> list = new ArrayList<Throwable>();
+//            
+//            final TestException ex = new TestException();
+//            
+//            final Function<Throwable, Throwable> errorHandler = new Function<Throwable, Throwable>() {
+//                @Override
+//                public Throwable apply(Throwable t) {
+//                    list.add(t);
+//                    return ex;
+//                }
+//            };
+//
+//            RxJavaPlugins.getInstance().registerObservableExecutionHook(new RxJavaObservableExecutionHook() {
+//                @Override
+//                public <T> Throwable onSubscribeError(Throwable e) {
+//                    return errorHandler.call(e);
+//                }
+//            });
+//
+//            RxJavaPlugins.getInstance().registerSingleExecutionHook(new RxJavaSingleExecutionHook() {
+//                @Override
+//                public <T> Throwable onSubscribeError(Throwable e) {
+//                    return errorHandler.call(e);
+//                }
+//            });
+//
+//            RxJavaPlugins.getInstance().registerCompletableExecutionHook(new RxJavaCompletableExecutionHook() {
+//                @Override
+//                public Throwable onSubscribeError(Throwable e) {
+//                    return errorHandler.call(e);
+//                }
+//            });
+//
+//            assertSame(ex, RxJavaPlugins.onObservableError(new TestException("Forced failure 1")));
+//
+//            assertSame(ex, RxJavaPlugins.onSingleError(new TestException("Forced failure 2")));
+//            
+//            assertSame(ex, RxJavaPlugins.onCompletableError(new TestException("Forced failure 3")));
+//            
+//            assertTestException(list, 0, "Forced failure 1");
+//            
+//            assertTestException(list, 1, "Forced failure 2");
+//
+//            assertTestException(list, 2, "Forced failure 3");
+//        } finally {
+//            RxJavaPlugins.getInstance().reset();
+//            RxJavaPlugins.reset();
+//        }
+    }
+
+//    @SuppressWarnings({ "rawtypes", "unchecked" })
+    @Test
+    @Ignore("Not present in 2.0")
+    public void onXLift() {
+//        try {
+//            Completable.CompletableOperator cop = new Completable.CompletableOperator() {
+//                @Override
+//                public CompletableSubscriber call(CompletableSubscriber t) {
+//                    return t;
+//                }
+//            };
+//            
+//            Observable.Operator oop = new Observable.Operator() {
+//                @Override
+//                public Object call(Object t) {
+//                    return t;
+//                }
+//            };
+//
+//            final int[] counter = { 0 };
+//
+//            RxJavaPlugins.setOnObservableLift(new Function<Operator, Operator>() {
+//                @Override
+//                public Operator call(Operator t) {
+//                    counter[0]++;
+//                    return t;
+//                }
+//            });
+//
+//            RxJavaPlugins.setOnSingleLift(new Function<Operator, Operator>() {
+//                @Override
+//                public Operator call(Operator t) {
+//                    counter[0]++;
+//                    return t;
+//                }
+//            });
+//
+//            RxJavaPlugins.setOnCompletableLift(new Function<CompletableOperator, CompletableOperator>() {
+//                @Override
+//                public CompletableOperator call(CompletableOperator t) {
+//                    counter[0]++;
+//                    return t;
+//                }
+//            });
+//            
+//            assertSame(oop, RxJavaPlugins.onObservableLift(oop));
+//
+//            assertSame(oop, RxJavaPlugins.onSingleLift(oop));
+//
+//            assertSame(cop, RxJavaPlugins.onCompletableLift(cop));
+//            
+//            assertEquals(3, counter[0]);
+//
+//        } finally {
+//            RxJavaPlugins.reset();
+//        }
+    }
+
+//    @SuppressWarnings({ "rawtypes", "unchecked", "deprecation" })
+    @Test
+    @Ignore("Not present in 2.0")
+    public void onPluginsXLift() {
+//        try {
+//            
+//            RxJavaPlugins.getInstance().reset();
+//            RxJavaPlugins.reset();
+//
+//            Completable.CompletableOperator cop = new Completable.CompletableOperator() {
+//                @Override
+//                public CompletableSubscriber call(CompletableSubscriber t) {
+//                    return t;
+//                }
+//            };
+//            
+//            Observable.Operator oop = new Observable.Operator() {
+//                @Override
+//                public Object call(Object t) {
+//                    return t;
+//                }
+//            };
+//
+//            final int[] counter = { 0 };
+//
+//            final Function<Operator, Operator> onObservableLift = new Function<Operator, Operator>() {
+//                @Override
+//                public Operator call(Operator t) {
+//                    counter[0]++;
+//                    return t;
+//                }
+//            };
+//
+//            final Function<CompletableOperator, CompletableOperator> onCompletableLift = new Function<CompletableOperator, CompletableOperator>() {
+//                @Override
+//                public CompletableOperator call(CompletableOperator t) {
+//                    counter[0]++;
+//                    return t;
+//                }
+//            };
+//            
+//            RxJavaPlugins.getInstance().registerObservableExecutionHook(new RxJavaObservableExecutionHook() {
+//                @Override
+//                public <T, R> Operator<? extends R, ? super T> onLift(Operator<? extends R, ? super T> lift) {
+//                    return onObservableLift.call(lift);
+//                }
+//            });
+//            
+//            RxJavaPlugins.getInstance().registerSingleExecutionHook(new RxJavaSingleExecutionHook() {
+//                @Override
+//                public <T, R> Operator<? extends R, ? super T> onLift(Operator<? extends R, ? super T> lift) {
+//                    return onObservableLift.call(lift);
+//                }
+//            });
+//            
+//            RxJavaPlugins.getInstance().registerCompletableExecutionHook(new RxJavaCompletableExecutionHook() {
+//                @Override
+//                public CompletableOperator onLift(CompletableOperator lift) {
+//                    return onCompletableLift.call(lift);
+//                }
+//            });
+//            
+//            assertSame(oop, RxJavaPlugins.onObservableLift(oop));
+//
+//            assertSame(oop, RxJavaPlugins.onSingleLift(oop));
+//
+//            assertSame(cop, RxJavaPlugins.onCompletableLift(cop));
+//            
+//            assertEquals(3, counter[0]);
+//
+//        } finally {
+//            RxJavaPlugins.reset();
+//        }
+    }
+    
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void overrideConnectableObservable() {
+        try {
+            RxJavaPlugins.setOnConnectableObservableAssembly(new Function<ConnectableObservable, ConnectableObservable>() {
+                @Override
+                public ConnectableObservable apply(ConnectableObservable co) throws Exception {
+                    return new ConnectableObservable() {
+                        
+                        @Override
+                        public void connect(Consumer connection) {
+                            
+                        }
+                        
+                        @SuppressWarnings("unchecked")
+                        @Override
+                        protected void subscribeActual(Observer observer) {
+                            observer.onSubscribe(Disposables.empty());
+                            observer.onNext(10);
+                            observer.onComplete();
+                        }
+                    };
+                }
+            });
+            
+            Observable
+            .just(1)
+            .publish()
+            .autoConnect()
+            .test()
+            .assertResult(10);
+            
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        
+        Observable
+        .just(1)
+        .publish()
+        .autoConnect()
+        .test()
+        .assertResult(1);
+    }
+
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void overrideConnectableFlowable() {
+        try {
+            RxJavaPlugins.setOnConnectableFlowableAssembly(new Function<ConnectableFlowable, ConnectableFlowable>() {
+                @Override
+                public ConnectableFlowable apply(ConnectableFlowable co) throws Exception {
+                    return new ConnectableFlowable() {
+                        
+                        @Override
+                        public void connect(Consumer connection) {
+                            
+                        }
+                        
+                        @SuppressWarnings("unchecked")
+                        @Override
+                        protected void subscribeActual(Subscriber subscriber) {
+                            subscriber.onSubscribe(new ScalarSubscription(subscriber, 10));
+                        }
+                    };
+                }
+            });
+            
+            Flowable
+            .just(1)
+            .publish()
+            .autoConnect()
+            .test()
+            .assertResult(10);
+            
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        
+        Flowable
+        .just(1)
+        .publish()
+        .autoConnect()
+        .test()
+        .assertResult(1);
+    }
+    
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void assemblyHookCrashes() {
+        try {
+            RxJavaPlugins.setOnFlowableAssembly(new Function<Flowable, Flowable>() {
+                @Override
+                public Flowable apply(Flowable f) throws Exception {
+                    throw new IllegalArgumentException();
+                }
+            });
+            
+            try {
+                Flowable.empty();
+                fail("Should have thrown!");
+            } catch (IllegalArgumentException ex) {
+                // expected
+            }
+            
+            RxJavaPlugins.setOnFlowableAssembly(new Function<Flowable, Flowable>() {
+                @Override
+                public Flowable apply(Flowable f) throws Exception {
+                    throw new InternalError();
+                }
+            });
+            
+            try {
+                Flowable.empty();
+                fail("Should have thrown!");
+            } catch (InternalError ex) {
+                // expected
+            }
+            
+            RxJavaPlugins.setOnFlowableAssembly(new Function<Flowable, Flowable>() {
+                @Override
+                public Flowable apply(Flowable f) throws Exception {
+                    throw new IOException();
+                }
+            });
+            
+            try {
+                Flowable.empty();
+                fail("Should have thrown!");
+            } catch (RuntimeException ex) {
+                if (!(ex.getCause() instanceof IOException)) {
+                    fail(ex.getCause().toString() + ": Should have thrown RuntimeException(IOException)");
+                }
+            }
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void subscribeHookCrashes() {
+        try {
+            RxJavaPlugins.setOnFlowableSubscribe(new BiFunction<Flowable, Subscriber, Subscriber>() {
+                @Override
+                public Subscriber apply(Flowable f, Subscriber s) throws Exception {
+                    throw new IllegalArgumentException();
+                }
+            });
+            
+            try {
+                Flowable.empty().test();
+                fail("Should have thrown!");
+            } catch (NullPointerException ex) {
+                if (!(ex.getCause() instanceof IllegalArgumentException)) {
+                    fail(ex.getCause().toString() + ": Should have thrown NullPointerException(IllegalArgumentException)");
+                }
+            }
+            
+            RxJavaPlugins.setOnFlowableSubscribe(new BiFunction<Flowable, Subscriber, Subscriber>() {
+                @Override
+                public Subscriber apply(Flowable f, Subscriber s) throws Exception {
+                    throw new InternalError();
+                }
+            });
+            
+            try {
+                Flowable.empty().test();
+                fail("Should have thrown!");
+            } catch (InternalError ex) {
+                // expected
+            }
+            
+            RxJavaPlugins.setOnFlowableSubscribe(new BiFunction<Flowable, Subscriber, Subscriber>() {
+                @Override
+                public Subscriber apply(Flowable f, Subscriber s) throws Exception {
+                    throw new IOException();
+                }
+            });
+            
+            try {
+                Flowable.empty().test();
+                fail("Should have thrown!");
+            } catch (NullPointerException ex) {
+                if (!(ex.getCause() instanceof RuntimeException)) {
+                    fail(ex.getCause().toString() + ": Should have thrown NullPointerException(RuntimeException(IOException))");
+                }
+                if (!(ex.getCause().getCause() instanceof IOException)) {
+                    fail(ex.getCause().toString() + ": Should have thrown NullPointerException(RuntimeException(IOException))");
+                }
+            }
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/processors/PublishProcessorTest.java b/src/test/java/io/reactivex/processors/PublishProcessorTest.java
index aeeefce045..94e8488297 100644
--- a/src/test/java/io/reactivex/processors/PublishProcessorTest.java
+++ b/src/test/java/io/reactivex/processors/PublishProcessorTest.java
@@ -18,15 +18,17 @@
 import static org.mockito.Mockito.*;
 
 import java.util.ArrayList;
+import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.junit.Test;
 import org.mockito.*;
-import org.reactivestreams.Subscriber;
+import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.exceptions.TestException;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
+import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
 
 public class PublishProcessorTest {
@@ -426,4 +428,211 @@ public void testCurrentStateMethodsError() {
         assertFalse(as.hasComplete());
         assertTrue(as.getThrowable() instanceof TestException);
     }
+    
+    @Test
+    public void subscribeTo() {
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+        
+        Flowable.range(1, 10).subscribe(pp);
+        
+        assertTrue(pp.hasComplete());
+        
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+        
+        pp2.subscribe(pp);
+        
+        assertFalse(pp2.hasSubscribers());
+    }
+    
+    @Test
+    public void testRequestValidation() {
+        TestHelper.assertBadRequestReported(PublishProcessor.create());
+    }
+    
+    @Test
+    public void crossCancel() {
+        final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();
+        TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                ts1.cancel();
+            }
+        };
+        
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+        
+        pp.subscribe(ts2);
+        pp.subscribe(ts1);
+        
+        pp.onNext(1);
+        
+        ts2.assertValue(1);
+        
+        ts1.assertNoValues();
+    }
+
+    @Test
+    public void crossCancelOnError() {
+        final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();
+        TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>() {
+            @Override
+            public void onError(Throwable t) {
+                super.onError(t);
+                ts1.cancel();
+            }
+        };
+        
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+        
+        pp.subscribe(ts2);
+        pp.subscribe(ts1);
+        
+        pp.onError(new TestException());
+        
+        ts2.assertError(TestException.class);
+        
+        ts1.assertNoErrors();
+    }
+
+    @Test
+    public void crossCancelOnComplete() {
+        final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();
+        TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>() {
+            @Override
+            public void onComplete() {
+                super.onComplete();
+                ts1.cancel();
+            }
+        };
+        
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+        
+        pp.subscribe(ts2);
+        pp.subscribe(ts1);
+        
+        pp.onComplete();
+        
+        ts2.assertComplete();
+        
+        ts1.assertNotComplete();
+    }
+    
+    @Test
+    public void backpressureOverflow() {
+        
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+        
+        TestSubscriber<Integer> ts = pp.test(0L);
+        
+        pp.onNext(1);
+        
+        ts.assertNoValues()
+        .assertNotComplete()
+        .assertError(MissingBackpressureException.class)
+        ;
+    }
+    
+    @Test
+    public void onSubscribeCancelsImmediately() {
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+        
+        TestSubscriber<Integer> ts = pp.test();
+        
+        pp.subscribe(new Subscriber<Integer>() {
+
+            @Override
+            public void onSubscribe(Subscription s) {
+                s.cancel();
+            }
+
+            @Override
+            public void onNext(Integer t) {
+                
+            }
+
+            @Override
+            public void onError(Throwable t) {
+                
+            }
+
+            @Override
+            public void onComplete() {
+                
+            }
+            
+        });
+        
+        ts.cancel();
+        
+        assertFalse(pp.hasSubscribers());
+    }
+    
+    @Test
+    public void terminateRace() throws Exception {
+        
+        for (int i = 0; i < 100; i++) {
+            final PublishProcessor<Integer> pp = PublishProcessor.create();
+            
+            TestSubscriber<Integer> ts = pp.test();
+            
+            final AtomicInteger count = new AtomicInteger(2);
+            
+            Runnable task = new Runnable() {
+                @Override
+                public void run() {
+                    if (count.decrementAndGet() != 0) {
+                        while (count.get() != 0);
+                    }
+                    pp.onComplete();
+                }
+            };
+            
+            Schedulers.newThread().scheduleDirect(task);
+            Schedulers.newThread().scheduleDirect(task);
+            
+            ts
+            .awaitDone(5, TimeUnit.SECONDS)
+            .assertResult();
+        }
+    }
+    
+    @Test
+    public void addRemoveRance() throws Exception {
+        
+        for (int i = 0; i < 100; i++) {
+            final PublishProcessor<Integer> pp = PublishProcessor.create();
+            
+            final TestSubscriber<Integer> ts = pp.test();
+            
+            final AtomicInteger count = new AtomicInteger(2);
+            
+            final CountDownLatch cdl = new CountDownLatch(2);
+            
+            Schedulers.newThread().scheduleDirect(new Runnable() {
+                @Override
+                public void run() {
+                    if (count.decrementAndGet() != 0) {
+                        while (count.get() != 0);
+                    }
+                    pp.subscribe();
+                    
+                    cdl.countDown();
+                }
+            });
+            Schedulers.newThread().scheduleDirect(new Runnable() {
+                @Override
+                public void run() {
+                    if (count.decrementAndGet() != 0) {
+                        while (count.get() != 0);
+                    }
+                    ts.cancel();
+                    
+                    cdl.countDown();
+                }
+            });
+            
+            assertTrue(cdl.await(5, TimeUnit.SECONDS));
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/SchedulerWorkerTest.java b/src/test/java/io/reactivex/schedulers/SchedulerWorkerTest.java
new file mode 100644
index 0000000000..98bbeeb494
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/SchedulerWorkerTest.java
@@ -0,0 +1,151 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import static org.junit.Assert.assertTrue;
+
+import java.util.*;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Test;
+
+import io.reactivex.Scheduler;
+import io.reactivex.disposables.Disposable;
+
+public class SchedulerWorkerTest {
+    
+    static final class CustomDriftScheduler extends Scheduler {
+        public volatile long drift;
+        @Override
+        public Worker createWorker() {
+            final Worker w = Schedulers.computation().createWorker();
+            return new Worker() {
+
+                @Override
+                public void dispose() {
+                    w.dispose();
+                }
+
+                @Override
+                public boolean isDisposed() {
+                    return w.isDisposed();
+                }
+
+                @Override
+                public Disposable schedule(Runnable action) {
+                    return w.schedule(action);
+                }
+
+                @Override
+                public Disposable schedule(Runnable action, long delayTime, TimeUnit unit) {
+                    return w.schedule(action, delayTime, unit);
+                }
+                
+                @Override
+                public long now(TimeUnit unit) {
+                    return super.now(unit) + unit.convert(drift, TimeUnit.NANOSECONDS);
+                }
+            };
+        }
+        
+        @Override
+        public long now(TimeUnit unit) {
+            return super.now(unit) + unit.convert(drift, TimeUnit.NANOSECONDS);
+        }
+    }
+    
+    @Test
+    public void testCurrentTimeDriftBackwards() throws Exception {
+        CustomDriftScheduler s = new CustomDriftScheduler();
+        
+        Scheduler.Worker w = s.createWorker();
+        
+        try {
+            final List<Long> times = new ArrayList<Long>();
+            
+            Disposable d = w.schedulePeriodically(new Runnable() {
+                @Override
+                public void run() {
+                    times.add(System.currentTimeMillis());
+                }
+            }, 100, 100, TimeUnit.MILLISECONDS);
+
+            Thread.sleep(150);
+            
+            s.drift = -1000 - TimeUnit.NANOSECONDS.toMillis(Scheduler.clockDriftTolerance());
+            
+            Thread.sleep(400);
+            
+            d.dispose();
+            
+            Thread.sleep(150);
+            
+            System.out.println("Runs: " + times.size());
+            
+            for (int i = 0; i < times.size() - 1 ; i++) {
+                long diff = times.get(i + 1) - times.get(i);
+                System.out.println("Diff #" + i + ": " + diff);
+                assertTrue("" + i + ":" + diff, diff < 150 && diff > 50);
+            }
+
+            assertTrue("Too few invocations: " + times.size(), times.size() > 2);
+            
+        } finally {
+            w.dispose();
+        }
+        
+    }
+    
+    @Test
+    public void testCurrentTimeDriftForwards() throws Exception {
+        CustomDriftScheduler s = new CustomDriftScheduler();
+        
+        Scheduler.Worker w = s.createWorker();
+        
+        try {
+            final List<Long> times = new ArrayList<Long>();
+            
+            Disposable d = w.schedulePeriodically(new Runnable() {
+                @Override
+                public void run() {
+                    times.add(System.currentTimeMillis());
+                }
+            }, 100, 100, TimeUnit.MILLISECONDS);
+
+            Thread.sleep(150);
+            
+            s.drift = 1000 + TimeUnit.NANOSECONDS.toMillis(Scheduler.clockDriftTolerance());
+            
+            Thread.sleep(400);
+            
+            d.dispose();
+            
+            Thread.sleep(150);
+            
+            System.out.println("Runs: " + times.size());
+            
+            assertTrue(times.size() > 2);
+            
+            for (int i = 0; i < times.size() - 1 ; i++) {
+                long diff = times.get(i + 1) - times.get(i);
+                System.out.println("Diff #" + i + ": " + diff);
+                assertTrue("Diff out of range: " + diff, diff < 250 && diff > 50);
+            }
+            
+        } finally {
+            w.dispose();
+        }
+        
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java b/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java
index 803a9076ca..d5a37e379b 100644
--- a/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java
+++ b/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java
@@ -26,9 +26,9 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.internal.util.ExceptionHelper;
 
 public class TestSchedulerTest {
 
@@ -49,7 +49,7 @@ public void run() {
                     try {
                         calledOp.apply(scheduler.now(TimeUnit.MILLISECONDS));
                     } catch (Throwable ex) {
-                        Exceptions.propagate(ex);
+                        ExceptionHelper.wrapOrThrow(ex);
                     }
                 }
             }, 1, 2, TimeUnit.SECONDS);
@@ -99,7 +99,7 @@ public void run() {
                     try {
                         calledOp.apply(scheduler.now(TimeUnit.MILLISECONDS));
                     } catch (Throwable ex) {
-                        Exceptions.propagate(ex);
+                        ExceptionHelper.wrapOrThrow(ex);
                     }
                 }
             }, 1, 2, TimeUnit.SECONDS);
