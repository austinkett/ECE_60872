diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java
index 94d10f68f1..971bd79b1c 100644
--- a/src/main/java/io/reactivex/Observable.java
+++ b/src/main/java/io/reactivex/Observable.java
@@ -908,6 +908,7 @@ protected Observable(Publisher<T> onSubscribe) {
     }
 
     public final Observable<Boolean> contains(Object o) {
+        Objects.requireNonNull(o);
         return any(v -> Objects.equals(v, o));
     }
 
@@ -981,9 +982,9 @@ protected Observable(Publisher<T> onSubscribe) {
         return fromCallable(delaySupplier::get).take(1).flatMap(v -> this);
     }
 
-    public final Observable<T> dematerialize() {
+    public final <T2> Observable<T2> dematerialize() {
         @SuppressWarnings("unchecked")
-        Observable<Try<Optional<T>>> m = (Observable<Try<Optional<T>>>)this;
+        Observable<Try<Optional<T2>>> m = (Observable<Try<Optional<T2>>>)this;
         return m.lift(OperatorDematerialize.instance());
     }
     public final Observable<T> distinct() {
@@ -1240,85 +1241,84 @@ public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? sup
     }
 
     public static final <T> Observable<T> just(T v1, T v2) {
-        Objects.requireNonNull(v1);
-        Objects.requireNonNull(v2);
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
         
         return fromArray(v1, v2);
     }
 
     public static final <T> Observable<T> just(T v1, T v2, T v3) {
-        Objects.requireNonNull(v1);
-        Objects.requireNonNull(v2);
-        Objects.requireNonNull(v3);
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
         
         return fromArray(v1, v2, v3);
     }
 
     public static final <T> Observable<T> just(T v1, T v2, T v3, T v4) {
-        Objects.requireNonNull(v1);
-        Objects.requireNonNull(v2);
-        Objects.requireNonNull(v3);
-        Objects.requireNonNull(v4);
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
         
         return fromArray(v1, v2, v3, v4);
     }
 
     public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5) {
-        Objects.requireNonNull(v1);
-        Objects.requireNonNull(v2);
-        Objects.requireNonNull(v3);
-        Objects.requireNonNull(v4);
-        Objects.requireNonNull(v5);
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
+        Objects.requireNonNull(v5, "The fifth value is null");
         
         return fromArray(v1, v2, v3, v4, v5);
     }
 
     public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6) {
-        Objects.requireNonNull(v1);
-        Objects.requireNonNull(v2);
-        Objects.requireNonNull(v3);
-        Objects.requireNonNull(v4);
-        Objects.requireNonNull(v5);
-        Objects.requireNonNull(v6);
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
+        Objects.requireNonNull(v5, "The fifth value is null");
         
         return fromArray(v1, v2, v3, v4, v5, v6);
     }
 
     public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7) {
-        Objects.requireNonNull(v1);
-        Objects.requireNonNull(v2);
-        Objects.requireNonNull(v3);
-        Objects.requireNonNull(v4);
-        Objects.requireNonNull(v5);
-        Objects.requireNonNull(v6);
-        Objects.requireNonNull(v7);
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
+        Objects.requireNonNull(v5, "The fifth value is null");
+        Objects.requireNonNull(v6, "The sixth value is null");
+        Objects.requireNonNull(v7, "The seventh value is null");
         
         return fromArray(v1, v2, v3, v4, v5, v6, v7);
     }
 
     public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8) {
-        Objects.requireNonNull(v1);
-        Objects.requireNonNull(v2);
-        Objects.requireNonNull(v3);
-        Objects.requireNonNull(v4);
-        Objects.requireNonNull(v5);
-        Objects.requireNonNull(v6);
-        Objects.requireNonNull(v7);
-        Objects.requireNonNull(v8);
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
+        Objects.requireNonNull(v5, "The fifth value is null");
+        Objects.requireNonNull(v6, "The sixth value is null");
+        Objects.requireNonNull(v7, "The seventh value is null");
+        Objects.requireNonNull(v8, "The eigth value is null");
         
         return fromArray(v1, v2, v3, v4, v5, v6, v7, v8);
     }
 
     public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9) {
-        Objects.requireNonNull(v1);
-        Objects.requireNonNull(v2);
-        Objects.requireNonNull(v3);
-        Objects.requireNonNull(v4);
-        Objects.requireNonNull(v5);
-        Objects.requireNonNull(v6);
-        Objects.requireNonNull(v7);
-        Objects.requireNonNull(v8);
-        Objects.requireNonNull(v9);
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
+        Objects.requireNonNull(v5, "The fifth value is null");
+        Objects.requireNonNull(v6, "The sixth value is null");
+        Objects.requireNonNull(v7, "The seventh value is null");
+        Objects.requireNonNull(v8, "The eigth value is null");
+        Objects.requireNonNull(v9, "The ninth is null");
         
         return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9);
     }
@@ -1863,6 +1863,10 @@ private void subscribeActual(Subscriber<? super T> s) {
         // TODO consider inlining this behavior
         return takeUntil(timer(time, unit, scheduler));
     }
+    
+    public final Observable<T> takeFirst(Predicate<? super T> predicate) {
+        return filter(predicate).take(1);
+    }
 
     public final Observable<T> takeLast(int n) {
         if (n < 0) {
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorDematerialize.java b/src/main/java/io/reactivex/internal/operators/OperatorDematerialize.java
index 08c985b9c7..841237e391 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorDematerialize.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorDematerialize.java
@@ -18,6 +18,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.Try;
 
@@ -38,6 +39,8 @@
         final Subscriber<? super T> actual;
         
         boolean done;
+
+        Subscription s;
         
         public DematerializeSubscriber(Subscriber<? super T> actual) {
             this.actual = actual;
@@ -45,6 +48,12 @@ public DematerializeSubscriber(Subscriber<? super T> actual) {
         
         @Override
         public void onSubscribe(Subscription s) {
+            if (SubscriptionHelper.validateSubscription(this.s, s)) {
+                return;
+            }
+            
+            this.s = s;
+            
             actual.onSubscribe(s);
         }
         
@@ -54,12 +63,14 @@ public void onNext(Try<Optional<T>> t) {
                 return;
             }
             if (t.hasError()) {
+                s.cancel();
                 onError(t.error());
             } else {
                 Optional<T> o = t.value();
                 if (o.isPresent()) {
                     actual.onNext(o.get());
                 } else {
+                    s.cancel();
                     onComplete();
                 }
             }
@@ -72,6 +83,8 @@ public void onError(Throwable t) {
                 return;
             }
             done = true;
+            
+            actual.onError(t);
         }
         @Override
         public void onComplete() {
@@ -79,6 +92,7 @@ public void onComplete() {
                 return;
             }
             done = true;
+            
             actual.onComplete();
         }
     }
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorFilter.java b/src/main/java/io/reactivex/internal/operators/OperatorFilter.java
index 0d498a8706..f0c843309b 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorFilter.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorFilter.java
@@ -19,7 +19,7 @@
 
 import io.reactivex.Observable.Operator;
 import io.reactivex.internal.subscribers.ConditionalSubscriber;
-import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
 /**
  * 
@@ -38,21 +38,23 @@ public OperatorFilter(Predicate<? super T> predicate) {
     static final class FilterSubscriber<T> implements ConditionalSubscriber<T> {
         final Predicate<? super T> filter;
         final Subscriber<? super T> actual;
+        
         Subscription subscription;
+        
         public FilterSubscriber(Subscriber<? super T> actual, Predicate<? super T> filter) {
             this.actual = actual;
             this.filter = filter;
         }
+        
         @Override
         public void onSubscribe(Subscription s) {
-            if (subscription != null) {
-                s.cancel();
-                RxJavaPlugins.onError(new IllegalStateException("Subscription already set!"));
+            if (SubscriptionHelper.validateSubscription(this.subscription, s)) {
                 return;
             }
             subscription = s;
             actual.onSubscribe(s);
         }
+        
         @Override
         public void onNext(T t) {
             if (!onNextIf(t)) {
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorMaterialize.java b/src/main/java/io/reactivex/internal/operators/OperatorMaterialize.java
index 078a10a15e..a695c22b4a 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorMaterialize.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorMaterialize.java
@@ -33,10 +33,10 @@
     
     @Override
     public Subscriber<? super Object> apply(Subscriber<? super Try<Optional<Object>>> t) {
-        return new OnErrorReturnSubscriber<>(t);
+        return new MaterializeSubscriber<>(t);
     }
     
-    static final class OnErrorReturnSubscriber<T> extends AtomicLong implements Subscriber<T>, Subscription {
+    static final class MaterializeSubscriber<T> extends AtomicLong implements Subscriber<T>, Subscription {
         /** */
         private static final long serialVersionUID = -3740826063558713822L;
         final Subscriber<? super Try<Optional<T>>> actual;
@@ -45,8 +45,8 @@
         
         volatile int state;
         @SuppressWarnings("rawtypes")
-        static final AtomicIntegerFieldUpdater<OnErrorReturnSubscriber> STATE =
-                AtomicIntegerFieldUpdater.newUpdater(OnErrorReturnSubscriber.class, "state");
+        static final AtomicIntegerFieldUpdater<MaterializeSubscriber> STATE =
+                AtomicIntegerFieldUpdater.newUpdater(MaterializeSubscriber.class, "state");
         Try<Optional<T>> value;
         
         volatile boolean done;
@@ -56,7 +56,7 @@
         static final int HAS_REQUEST_NO_VALUE = 2;
         static final int HAS_REQUEST_HAS_VALUE = 3;
         
-        public OnErrorReturnSubscriber(Subscriber<? super Try<Optional<T>>> actual) {
+        public MaterializeSubscriber(Subscriber<? super Try<Optional<T>>> actual) {
             this.actual = actual;
         }
         
@@ -132,6 +132,7 @@ public void request(long n) {
             if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
+            s.request(n);
             if (BackpressureHelper.add(this, n) == 0) {
                 if (done) {
                     for (;;) {
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorScan.java b/src/main/java/io/reactivex/internal/operators/OperatorScan.java
index 8e0033f400..d1bf204080 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorScan.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorScan.java
@@ -28,8 +28,7 @@ public OperatorScan(BiFunction<T, T, T> accumulator) {
     
     @Override
     public Subscriber<? super T> apply(Subscriber<? super T> t) {
-        // TODO Auto-generated method stub
-        return null;
+        return new ScanSubscriber<>(t, accumulator);
     }
     
     static final class ScanSubscriber<T> implements Subscriber<T> {
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java b/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java
index 86c8d61384..cf62960453 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java
@@ -60,6 +60,7 @@ public ScanSeedSubscriber(Subscriber<? super R> actual, BiFunction<R, ? super T,
             super(actual, new SpscArrayQueue<>(2));
             this.accumulator = accumulator;
             this.value = value;
+            queue.offer(value);
         }
 
         @Override
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorTake.java b/src/main/java/io/reactivex/internal/operators/OperatorTake.java
index ec67d09e04..42d262e8a9 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorTake.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorTake.java
@@ -18,6 +18,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -86,8 +87,7 @@ public void onComplete() {
         }
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             for (;;) {
diff --git a/src/main/java/io/reactivex/internal/operators/PublisherAmb.java b/src/main/java/io/reactivex/internal/operators/PublisherAmb.java
index 10aef9255d..0b0fd015c3 100644
--- a/src/main/java/io/reactivex/internal/operators/PublisherAmb.java
+++ b/src/main/java/io/reactivex/internal/operators/PublisherAmb.java
@@ -107,7 +107,7 @@ public void request(long n) {
             } else
             if (w == 0) {
                 for (AmbInnerSubscriber<T> a : subscribers) {
-                    a.cancel();
+                    a.request(n);
                 }
             }
         }
diff --git a/src/main/java/io/reactivex/internal/operators/PublisherArraySource.java b/src/main/java/io/reactivex/internal/operators/PublisherArraySource.java
index 7710dbd15f..9f1acd07af 100644
--- a/src/main/java/io/reactivex/internal/operators/PublisherArraySource.java
+++ b/src/main/java/io/reactivex/internal/operators/PublisherArraySource.java
@@ -21,8 +21,8 @@
 import org.reactivestreams.*;
 
 import io.reactivex.internal.subscribers.ConditionalSubscriber;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
-import io.reactivex.plugins.RxJavaPlugins;
 
 /**
  * 
@@ -62,8 +62,7 @@ public ArraySourceSubscription(T[] array, Subscriber<? super T> subscriber) {
         
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (BackpressureHelper.add(this, n) == 0L) {
@@ -133,8 +132,7 @@ public ConditionalArraySourceSubscription(T[] array, ConditionalSubscriber<? sup
         
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             if (BackpressureHelper.add(this, n) == 0L) {
diff --git a/src/main/java/io/reactivex/observables/BlockingObservable.java b/src/main/java/io/reactivex/observables/BlockingObservable.java
index d40bd9f2df..e71a7fb7b3 100644
--- a/src/main/java/io/reactivex/observables/BlockingObservable.java
+++ b/src/main/java/io/reactivex/observables/BlockingObservable.java
@@ -63,15 +63,38 @@ protected BlockingObservable(Publisher<? extends T> source) {
     }
     
     static final class BlockingIterator<T> implements Iterator<T>, AutoCloseable, Disposable {
-        final Queue<Object> queue;
+        final BlockingQueue<Object> queue;
         final Disposable resource;
-        public BlockingIterator(Queue<Object> queue, Disposable resource) {
+        
+        Object last;
+        
+        public BlockingIterator(BlockingQueue<Object> queue, Disposable resource) {
             this.queue = queue;
             this.resource = resource;
         }
         @Override
         public boolean hasNext() {
-            Object o = queue.peek();
+            if (last == null) { 
+                Object o = queue.poll();
+                if (o == null) {
+                    try {
+                        o = queue.take();
+                    } catch (InterruptedException ex) {
+                        Thread.currentThread().interrupt();
+                        Exceptions.propagate(ex);
+                    }
+                }
+                last = o;
+                if (NotificationLite.isError(o)) {
+                    Throwable e = NotificationLite.getError(o);
+                    Exceptions.propagate(e);
+                }
+                if (NotificationLite.isComplete(o)) {
+                    return false;
+                }
+                return true;
+            }
+            Object o = last;
             if (NotificationLite.isError(o)) {
                 Throwable e = NotificationLite.getError(o);
                 Exceptions.propagate(e);
@@ -82,7 +105,8 @@ public boolean hasNext() {
         @Override
         public T next() {
             if (hasNext()) {
-                Object o = queue.poll();
+                Object o = last;
+                last = null;
                 return NotificationLite.getValue(o);
             }
             throw new NoSuchElementException();
diff --git a/src/main/java/io/reactivex/observables/ConnectableObservable.java b/src/main/java/io/reactivex/observables/ConnectableObservable.java
index 70a70e3db7..19119966b2 100644
--- a/src/main/java/io/reactivex/observables/ConnectableObservable.java
+++ b/src/main/java/io/reactivex/observables/ConnectableObservable.java
@@ -55,7 +55,7 @@ protected ConnectableObservable(Publisher<T> onSubscribe) {
      * Instructs the {@code ConnectableObservable} to begin emitting the items from its underlying
      * {@link Observable} to its {@link Subscriber}s.
      * <p>
-     * To disconnect from a synchronous source, use the {@link #connect(rx.functions.Action1)} method.
+     * To disconnect from a synchronous source, use the {@link #connect(java.util.function.Consumer)} method.
      *
      * @return the subscription representing the connection
      * @see <a href="http://reactivex.io/documentation/operators/connect.html">ReactiveX documentation: Connect</a>
diff --git a/src/main/java/io/reactivex/subjects/ReplaySubject.java b/src/main/java/io/reactivex/subjects/ReplaySubject.java
index c3574c3495..892acd8db9 100644
--- a/src/main/java/io/reactivex/subjects/ReplaySubject.java
+++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java
@@ -453,7 +453,14 @@ public void replay(ReplaySubscription<T> rs) {
             final List<Object> b = buffer;
             final Subscriber<? super T> a = rs.actual;
 
-            int index = (Integer)rs.index;
+            Integer indexObject = (Integer)rs.index;
+            int index = 0;
+            if (indexObject != null) {
+                index = indexObject;
+            } else {
+                index = 0;
+                rs.index = 0;
+            }
 
             for (;;) {
 
diff --git a/src/main/java/io/reactivex/subscribers/TestSubscriber.java b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
index e5aba71397..56468d0899 100644
--- a/src/main/java/io/reactivex/subscribers/TestSubscriber.java
+++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
@@ -481,14 +481,22 @@ public final void assertValue(T value) {
         }
         int s = values.size();
         if (s != 1) {
-            fail(prefix, "Expected: " + value + ", Actual: " + values, errors);
+            fail(prefix, "Expected: " + valueAndClass(value) + ", Actual: " + values, errors);
         }
         T v = values.get(0);
-        if (Objects.equals(value, v)) {
-            fail(prefix, "Expected: " + value + ", Actual: " + v, errors);
+        if (!Objects.equals(value, v)) {
+            fail(prefix, "Expected: " + valueAndClass(value) + ", Actual: " + valueAndClass(v), errors);
         }
     }
     
+    /** Appends the class name to a non-null value. */
+    static String valueAndClass(Object o) {
+        if (o != null) {
+            return o + " (class: " + o.getClass().getSimpleName() + ")";
+        }
+        return "null";
+    }
+    
     /**
      * Assert that this TestSubscriber received the specified number onNext events.
      * @param count the expected number of onNext events
@@ -531,7 +539,7 @@ public final void assertValues(T... values) {
             T v = this.values.get(i);
             T u = values[i];
             if (!Objects.equals(u, v)) {
-                fail(prefix, "Values at position " + i + " differ; Expected: " + u + ", Actual: " + v, errors);
+                fail(prefix, "Values at position " + i + " differ; Expected: " + valueAndClass(u) + ", Actual: " + valueAndClass(v), errors);
             }
         }
     }
@@ -557,7 +565,7 @@ public final void assertValueSet(Collection<? extends T> values) {
             T v = this.values.get(i);
             
             if (!values.contains(v)) {
-                fail(prefix, "Value not in the expected collection: " + v, errors);
+                fail(prefix, "Value not in the expected collection: " + valueAndClass(v), errors);
             }
         }
     }
@@ -581,7 +589,7 @@ public final void assertValueSequence(Iterable<? extends T> sequence) {
             T u = vit.next();
             
             if (!Objects.equals(u, v)) {
-                fail(prefix, "Values at position " + i + " differ; Expected: " + u + ", Actual: " + v, errors);
+                fail(prefix, "Values at position " + i + " differ; Expected: " + valueAndClass(u) + ", Actual: " + valueAndClass(v), errors);
             }
             i++;
         }
diff --git a/src/test/java/io/reactivex/MergeTests.java b/src/test/java/io/reactivex/MergeTests.java
index a7b465edd2..f89416238f 100644
--- a/src/test/java/io/reactivex/MergeTests.java
+++ b/src/test/java/io/reactivex/MergeTests.java
@@ -1,3 +1,16 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
 package io.reactivex;
 
 import static org.junit.Assert.*;
diff --git a/src/test/java/io/reactivex/ObservableConversionTest.java b/src/test/java/io/reactivex/ObservableConversionTest.java
index de9abf6871..cd5c6974d7 100644
--- a/src/test/java/io/reactivex/ObservableConversionTest.java
+++ b/src/test/java/io/reactivex/ObservableConversionTest.java
@@ -1,3 +1,16 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
 package io.reactivex;
 
 import java.util.*;
diff --git a/src/test/java/io/reactivex/ObservableTests.java b/src/test/java/io/reactivex/ObservableTests.java
new file mode 100644
index 0000000000..1cd07ed571
--- /dev/null
+++ b/src/test/java/io/reactivex/ObservableTests.java
@@ -0,0 +1,973 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex;
+
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.*;
+import static org.mockito.Mockito.*;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+import java.util.function.Predicate;
+
+import org.junit.*;
+import org.mockito.*;
+import org.reactivestreams.*;
+
+import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.observables.ConnectableObservable;
+import io.reactivex.schedulers.*;
+import io.reactivex.subjects.*;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class ObservableTests {
+
+    Subscriber<Number> w;
+
+    private static final Predicate<Integer> IS_EVEN = v -> v % 2 == 0;
+
+    @Before
+    public void before() {
+        w = mockSubscriber();
+    }
+
+    /**
+     * Mocks a subscriber and prepares it to request Long.MAX_VALUE.
+     * @return the mocked subscriber
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> Subscriber<T> mockSubscriber() {
+        Subscriber<T> w = mock(Subscriber.class);
+        
+        Mockito.doAnswer(a -> {
+            Subscription s = a.getArgumentAt(0, Subscription.class);
+            s.request(Long.MAX_VALUE);
+            return null;
+        }).when(w).onSubscribe(any());
+        
+        return w;
+    }
+    
+    @Test
+    public void fromArray() {
+        String[] items = new String[] { "one", "two", "three" };
+        assertEquals((Long)3L, Observable.fromArray(items).count().toBlocking().single());
+        assertEquals("two", Observable.fromArray(items).skip(1).take(1).toBlocking().single());
+        assertEquals("three", Observable.fromArray(items).takeLast(1).toBlocking().single());
+    }
+
+    @Test
+    public void fromIterable() {
+        ArrayList<String> items = new ArrayList<>();
+        items.add("one");
+        items.add("two");
+        items.add("three");
+
+        assertEquals((Long)3L, Observable.fromIterable(items).count().toBlocking().single());
+        assertEquals("two", Observable.fromIterable(items).skip(1).take(1).toBlocking().single());
+        assertEquals("three", Observable.fromIterable(items).takeLast(1).toBlocking().single());
+    }
+
+    @Test
+    public void fromArityArgs3() {
+        Observable<String> items = Observable.just("one", "two", "three");
+
+        assertEquals((Long)3L, items.count().toBlocking().single());
+        assertEquals("two", items.skip(1).take(1).toBlocking().single());
+        assertEquals("three", items.takeLast(1).toBlocking().single());
+    }
+
+    @Test
+    public void fromArityArgs1() {
+        Observable<String> items = Observable.just("one");
+
+        assertEquals((Long)1L, items.count().toBlocking().single());
+        assertEquals("one", items.takeLast(1).toBlocking().single());
+    }
+
+    @Test
+    public void testCreate() {
+
+        Observable<String> observable = Observable.just("one", "two", "three");
+
+        Subscriber<String> observer = mockSubscriber();
+        
+        observable.subscribe(observer);
+        
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onNext("two");
+        verify(observer, times(1)).onNext("three");
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testCountAFewItems() {
+        Observable<String> observable = Observable.just("a", "b", "c", "d");
+        
+        observable.count().subscribe(w);
+        
+        // we should be called only once
+        verify(w, times(1)).onNext(anyLong());
+        verify(w).onNext(4L);
+        verify(w, never()).onError(any(Throwable.class));
+        verify(w, times(1)).onComplete();
+    }
+
+    @Test
+    public void testCountZeroItems() {
+        Observable<String> observable = Observable.empty();
+        observable.count().subscribe(w);
+        // we should be called only once
+        verify(w, times(1)).onNext(anyLong());
+        verify(w).onNext(0L);
+        verify(w, never()).onError(any(Throwable.class));
+        verify(w, times(1)).onComplete();
+    }
+
+    @Test
+    public void testCountError() {
+        Observable<String> o = Observable.error(() -> new RuntimeException());
+        
+        o.count().subscribe(w);
+        verify(w, never()).onNext(anyInt());
+        verify(w, never()).onComplete();
+        verify(w, times(1)).onError(any(RuntimeException.class));
+    }
+
+    public void testTakeFirstWithPredicateOfSome() {
+        Observable<Integer> observable = Observable.just(1, 3, 5, 4, 6, 3);
+        observable.takeFirst(IS_EVEN).subscribe(w);
+        verify(w, times(1)).onNext(anyInt());
+        verify(w).onNext(4);
+        verify(w, times(1)).onComplete();
+        verify(w, never()).onError(any(Throwable.class));
+    }
+
+    @Test
+    public void testTakeFirstWithPredicateOfNoneMatchingThePredicate() {
+        Observable<Integer> observable = Observable.just(1, 3, 5, 7, 9, 7, 5, 3, 1);
+        observable.takeFirst(IS_EVEN).subscribe(w);
+        verify(w, never()).onNext(anyInt());
+        verify(w, times(1)).onComplete();
+        verify(w, never()).onError(any(Throwable.class));
+    }
+
+    @Test
+    public void testTakeFirstOfSome() {
+        Observable<Integer> observable = Observable.just(1, 2, 3);
+        observable.take(1).subscribe(w);
+        verify(w, times(1)).onNext(anyInt());
+        verify(w).onNext(1);
+        verify(w, times(1)).onComplete();
+        verify(w, never()).onError(any(Throwable.class));
+    }
+
+    @Test
+    public void testTakeFirstOfNone() {
+        Observable<Integer> observable = Observable.empty();
+        observable.take(1).subscribe(w);
+        verify(w, never()).onNext(anyInt());
+        verify(w, times(1)).onComplete();
+        verify(w, never()).onError(any(Throwable.class));
+    }
+
+    @Test
+    public void testFirstOfNone() {
+        Observable<Integer> observable = Observable.empty();
+        observable.first().subscribe(w);
+        verify(w, never()).onNext(anyInt());
+        verify(w, never()).onComplete();
+        verify(w, times(1)).onError(isA(NoSuchElementException.class));
+    }
+
+    @Test
+    public void testFirstWithPredicateOfNoneMatchingThePredicate() {
+        Observable<Integer> observable = Observable.just(1, 3, 5, 7, 9, 7, 5, 3, 1);
+        observable.filter(IS_EVEN).first().subscribe(w);
+        verify(w, never()).onNext(anyInt());
+        verify(w, never()).onComplete();
+        verify(w, times(1)).onError(isA(NoSuchElementException.class));
+    }
+
+    @Test
+    public void testReduce() {
+        Observable<Integer> observable = Observable.just(1, 2, 3, 4);
+        observable.reduce((t1, t2) -> t1 + t2)
+        .subscribe(w);
+        // we should be called only once
+        verify(w, times(1)).onNext(anyInt());
+        verify(w).onNext(10);
+    }
+
+    /**
+     * A reduce should fail with an NoSuchElementException if done on an empty Observable.
+     */
+    @Test(expected = NoSuchElementException.class)
+    public void testReduceWithEmptyObservable() {
+        Observable<Integer> observable = Observable.range(1, 0);
+        observable.reduce((t1, t2) -> t1 + t2)
+        .toBlocking().forEach(t1 -> {
+            // do nothing ... we expect an exception instead
+        });
+
+        fail("Expected an exception to be thrown");
+    }
+
+    /**
+     * A reduce on an empty Observable and a seed should just pass the seed through.
+     * 
+     * This is confirmed at https://github.com/ReactiveX/RxJava/issues/423#issuecomment-27642456
+     */
+    @Test
+    public void testReduceWithEmptyObservableAndSeed() {
+        Observable<Integer> observable = Observable.range(1, 0);
+        int value = observable.reduce(1, (t1, t2) -> t1 + t2)
+                .toBlocking().last();
+
+        assertEquals(1, value);
+    }
+
+    @Test
+    public void testReduceWithInitialValue() {
+        Observable<Integer> observable = Observable.just(1, 2, 3, 4);
+        observable.reduce(50, (t1, t2) -> t1 + t2)
+        .subscribe(w);
+        // we should be called only once
+        verify(w, times(1)).onNext(anyInt());
+        verify(w).onNext(60);
+    }
+
+    @Ignore // FIXME throwing is not allowed from the create?!
+    @Test
+    public void testOnSubscribeFails() {
+        Subscriber<String> observer = mockSubscriber();
+
+        final RuntimeException re = new RuntimeException("bad impl");
+        Observable<String> o = Observable.create(s -> { throw re; });
+        
+        o.subscribe(observer);
+        verify(observer, times(0)).onNext(anyString());
+        verify(observer, times(0)).onComplete();
+        verify(observer, times(1)).onError(re);
+    }
+
+    @Test
+    public void testMaterializeDematerializeChaining() {
+        Observable<Integer> obs = Observable.just(1);
+        Observable<Integer> chained = obs.materialize().dematerialize();
+
+        Subscriber<Integer> observer = mockSubscriber();
+
+        chained.subscribe(observer);
+
+        verify(observer, times(1)).onNext(1);
+        verify(observer, times(1)).onComplete();
+        verify(observer, times(0)).onError(any(Throwable.class));
+    }
+
+    /**
+     * The error from the user provided Observer is not handled by the subscribe method try/catch.
+     * 
+     * It is handled by the AtomicObserver that wraps the provided Observer.
+     * 
+     * Result: Passes (if AtomicObserver functionality exists)
+     */
+    @Test
+    public void testCustomObservableWithErrorInObserverAsynchronous() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicInteger count = new AtomicInteger();
+        final AtomicReference<Throwable> error = new AtomicReference<>();
+        
+        // FIXME custom built???
+        Observable.just("1", "2", "three", "4")
+        .subscribeOn(Schedulers.newThread())
+        .safeSubscribe(new Observer<String>() {
+            @Override
+            public void onComplete() {
+                System.out.println("completed");
+                latch.countDown();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                error.set(e);
+                System.out.println("error");
+                e.printStackTrace();
+                latch.countDown();
+            }
+
+            @Override
+            public void onNext(String v) {
+                int num = Integer.parseInt(v);
+                System.out.println(num);
+                // doSomething(num);
+                count.incrementAndGet();
+            }
+
+        });
+
+        // wait for async sequence to complete
+        latch.await();
+
+        assertEquals(2, count.get());
+        assertNotNull(error.get());
+        if (!(error.get() instanceof NumberFormatException)) {
+            fail("It should be a NumberFormatException");
+        }
+    }
+
+    /**
+     * The error from the user provided Observer is handled by the subscribe try/catch because this is synchronous
+     * 
+     * Result: Passes
+     */
+    @Test
+    public void testCustomObservableWithErrorInObserverSynchronous() {
+        final AtomicInteger count = new AtomicInteger();
+        final AtomicReference<Throwable> error = new AtomicReference<>();
+        
+        // FIXME custom built???
+        Observable.just("1", "2", "three", "4")
+        .safeSubscribe(new Observer<String>() {
+
+            @Override
+            public void onComplete() {
+                System.out.println("completed");
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                error.set(e);
+                System.out.println("error");
+                e.printStackTrace();
+            }
+
+            @Override
+            public void onNext(String v) {
+                int num = Integer.parseInt(v);
+                System.out.println(num);
+                // doSomething(num);
+                count.incrementAndGet();
+            }
+
+        });
+        assertEquals(2, count.get());
+        assertNotNull(error.get());
+        if (!(error.get() instanceof NumberFormatException)) {
+            fail("It should be a NumberFormatException");
+        }
+    }
+
+    /**
+     * The error from the user provided Observable is handled by the subscribe try/catch because this is synchronous
+     * 
+     * 
+     * Result: Passes
+     */
+    @Test
+    public void testCustomObservableWithErrorInObservableSynchronous() {
+        final AtomicInteger count = new AtomicInteger();
+        final AtomicReference<Throwable> error = new AtomicReference<>();
+        // FIXME custom built???
+        Observable.just("1", "2").concatWith(Observable.error(() -> new NumberFormatException()))
+        .subscribe(new Observer<String>() {
+
+            @Override
+            public void onComplete() {
+                System.out.println("completed");
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                error.set(e);
+                System.out.println("error");
+                e.printStackTrace();
+            }
+
+            @Override
+            public void onNext(String v) {
+                System.out.println(v);
+                count.incrementAndGet();
+            }
+
+        });
+        assertEquals(2, count.get());
+        assertNotNull(error.get());
+        if (!(error.get() instanceof NumberFormatException)) {
+            fail("It should be a NumberFormatException");
+        }
+    }
+
+    @Test
+    public void testPublishLast() throws InterruptedException {
+        final AtomicInteger count = new AtomicInteger();
+        ConnectableObservable<String> connectable = Observable.<String>create(observer -> {
+            observer.onSubscribe(EmptySubscription.INSTANCE);
+            count.incrementAndGet();
+            new Thread(() -> {
+                observer.onNext("first");
+                observer.onNext("last");
+                observer.onComplete();
+            }).start();
+        }).takeLast(1).publish();
+
+        // subscribe once
+        final CountDownLatch latch = new CountDownLatch(1);
+        connectable.subscribe(value -> {
+            assertEquals("last", value);
+            latch.countDown();
+        });
+
+        // subscribe twice
+        connectable.subscribe();
+
+        Disposable subscription = connectable.connect();
+        assertTrue(latch.await(1000, TimeUnit.MILLISECONDS));
+        assertEquals(1, count.get());
+        subscription.dispose();
+    }
+
+    @Test
+    public void testReplay() throws InterruptedException {
+        final AtomicInteger counter = new AtomicInteger();
+        ConnectableObservable<String> o = Observable.<String>create(observer -> {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                new Thread(new Runnable() {
+
+                    @Override
+                    public void run() {
+                        counter.incrementAndGet();
+                        observer.onNext("one");
+                        observer.onComplete();
+                    }
+                }).start();
+        }).replay();
+
+        // we connect immediately and it will emit the value
+        Disposable s = o.connect();
+        try {
+
+            // we then expect the following 2 subscriptions to get that same value
+            final CountDownLatch latch = new CountDownLatch(2);
+
+            // subscribe once
+            o.subscribe(v -> {
+                assertEquals("one", v);
+                latch.countDown();
+            });
+
+            // subscribe again
+            o.subscribe(v -> {
+                assertEquals("one", v);
+                latch.countDown();
+            });
+
+            if (!latch.await(1000, TimeUnit.MILLISECONDS)) {
+                fail("subscriptions did not receive values");
+            }
+            assertEquals(1, counter.get());
+        } finally {
+            s.dispose();
+        }
+    }
+
+    @Test
+    public void testCache() throws InterruptedException {
+        final AtomicInteger counter = new AtomicInteger();
+        Observable<String> o = Observable.<String>create(observer -> {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                new Thread(() -> {
+                    counter.incrementAndGet();
+                    observer.onNext("one");
+                    observer.onComplete();
+                }).start();
+        }).cache();
+
+        // we then expect the following 2 subscriptions to get that same value
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        // subscribe once
+        o.subscribe(v -> {
+            assertEquals("one", v);
+            latch.countDown();
+        });
+
+        // subscribe again
+        o.subscribe(v -> {
+            assertEquals("one", v);
+            latch.countDown();
+        });
+
+        if (!latch.await(1000, TimeUnit.MILLISECONDS)) {
+            fail("subscriptions did not receive values");
+        }
+        assertEquals(1, counter.get());
+    }
+
+    @Test
+    public void testCacheWithCapacity() throws InterruptedException {
+        final AtomicInteger counter = new AtomicInteger();
+        Observable<String> o = Observable.<String>create(observer -> {
+            observer.onSubscribe(EmptySubscription.INSTANCE);
+            new Thread(() -> {
+                counter.incrementAndGet();
+                observer.onNext("one");
+                observer.onComplete();
+            }).start();
+        }).cache(1);
+
+        // we then expect the following 2 subscriptions to get that same value
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        // subscribe once
+        o.subscribe(v -> {
+            assertEquals("one", v);
+            latch.countDown();
+        });
+
+        // subscribe again
+        o.subscribe(v -> {
+            assertEquals("one", v);
+            latch.countDown();
+        });
+
+        if (!latch.await(1000, TimeUnit.MILLISECONDS)) {
+            fail("subscriptions did not receive values");
+        }
+        assertEquals(1, counter.get());
+    }
+
+    /**
+     * https://github.com/ReactiveX/RxJava/issues/198
+     * 
+     * Rx Design Guidelines 5.2
+     * 
+     * "when calling the Subscribe method that only has an onNext argument, the OnError behavior will be
+     * to rethrow the exception on the thread that the message comes out from the Observable.
+     * The OnCompleted behavior in this case is to do nothing."
+     */
+    @Test
+    @Ignore("Subscribers can't throw")
+    public void testErrorThrownWithoutErrorHandlerSynchronous() {
+        try {
+            Observable.error(new RuntimeException("failure"))
+            .subscribe();
+            fail("expected exception");
+        } catch (Throwable e) {
+            assertEquals("failure", e.getMessage());
+        }
+    }
+
+    /**
+     * https://github.com/ReactiveX/RxJava/issues/198
+     * 
+     * Rx Design Guidelines 5.2
+     * 
+     * "when calling the Subscribe method that only has an onNext argument, the OnError behavior will be
+     * to rethrow the exception on the thread that the message comes out from the Observable.
+     * The OnCompleted behavior in this case is to do nothing."
+     * 
+     * @throws InterruptedException
+     */
+    @Test
+    @Ignore("Subscribers can't throw")
+    public void testErrorThrownWithoutErrorHandlerAsynchronous() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final AtomicReference<Throwable> exception = new AtomicReference<>();
+        Observable.create(observer -> {
+            new Thread(() -> {
+                try {
+                    observer.onError(new Error("failure"));
+                } catch (Throwable e) {
+                    // without an onError handler it has to just throw on whatever thread invokes it
+                    exception.set(e);
+                }
+                latch.countDown();
+            }).start();
+        }).subscribe();
+        // wait for exception
+        latch.await(3000, TimeUnit.MILLISECONDS);
+        assertNotNull(exception.get());
+        assertEquals("failure", exception.get().getMessage());
+    }
+
+    @Test
+    public void testTakeWithErrorInObserver() {
+        final AtomicInteger count = new AtomicInteger();
+        final AtomicReference<Throwable> error = new AtomicReference<>();
+        Observable.just("1", "2", "three", "4").take(3)
+        .safeSubscribe(new Observer<String>() {
+
+            @Override
+            public void onComplete() {
+                System.out.println("completed");
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                error.set(e);
+                System.out.println("error");
+                e.printStackTrace();
+            }
+
+            @Override
+            public void onNext(String v) {
+                int num = Integer.parseInt(v);
+                System.out.println(num);
+                // doSomething(num);
+                count.incrementAndGet();
+            }
+
+        });
+        assertEquals(2, count.get());
+        assertNotNull(error.get());
+        if (!(error.get() instanceof NumberFormatException)) {
+            fail("It should be a NumberFormatException");
+        }
+    }
+
+    @Test
+    public void testOfType() {
+        Observable<String> observable = Observable.just(1, "abc", false, 2L).ofType(String.class);
+
+        Subscriber<Object> observer = mockSubscriber();
+        
+        observable.subscribe(observer);
+        
+        verify(observer, never()).onNext(1);
+        verify(observer, times(1)).onNext("abc");
+        verify(observer, never()).onNext(false);
+        verify(observer, never()).onNext(2L);
+        verify(observer, never()).onError(
+                org.mockito.Matchers.any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testOfTypeWithPolymorphism() {
+        ArrayList<Integer> l1 = new ArrayList<>();
+        l1.add(1);
+        LinkedList<Integer> l2 = new LinkedList<>();
+        l2.add(2);
+
+        @SuppressWarnings("rawtypes")
+        Observable<List> observable = Observable.<Object> just(l1, l2, "123").ofType(List.class);
+
+        Subscriber<Object> observer = mockSubscriber();
+        
+        observable.subscribe(observer);
+        
+        verify(observer, times(1)).onNext(l1);
+        verify(observer, times(1)).onNext(l2);
+        verify(observer, never()).onNext("123");
+        verify(observer, never()).onError(
+                org.mockito.Matchers.any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testContains() {
+        Observable<Boolean> observable = Observable.just("a", "b", "c").contains("b"); // FIXME nulls not allowed, changed to "c"
+
+        Subscriber<Boolean> observer = mockSubscriber();
+
+        observable.subscribe(observer);
+        
+        verify(observer, times(1)).onNext(true);
+        verify(observer, never()).onNext(false);
+        verify(observer, never()).onError(
+                org.mockito.Matchers.any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testContainsWithInexistence() {
+        Observable<Boolean> observable = Observable.just("a", "b").contains("c"); // FIXME null values are not allowed, removed
+
+        Subscriber<Object> observer = mockSubscriber();
+        
+        observable.subscribe(observer);
+        
+        verify(observer, times(1)).onNext(false);
+        verify(observer, never()).onNext(true);
+        verify(observer, never()).onError(
+                org.mockito.Matchers.any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    @Ignore("null values are not allowed")
+    public void testContainsWithNull() {
+        Observable<Boolean> observable = Observable.just("a", "b", null).contains(null);
+
+        @SuppressWarnings("unchecked")
+        Observer<Object> observer = mock(Observer.class);
+        observable.subscribe(observer);
+        verify(observer, times(1)).onNext(true);
+        verify(observer, never()).onNext(false);
+        verify(observer, never()).onError(
+                org.mockito.Matchers.any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testContainsWithEmptyObservable() {
+        Observable<Boolean> observable = Observable.<String> empty().contains("a");
+
+        @SuppressWarnings("unchecked")
+        Observer<Object> observer = mock(Observer.class);
+        observable.subscribe(observer);
+        verify(observer, times(1)).onNext(false);
+        verify(observer, never()).onNext(true);
+        verify(observer, never()).onError(
+                org.mockito.Matchers.any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testIgnoreElements() {
+        Observable<Integer> observable = Observable.just(1, 2, 3).ignoreElements();
+
+        @SuppressWarnings("unchecked")
+        Observer<Integer> observer = mock(Observer.class);
+        observable.subscribe(observer);
+        verify(observer, never()).onNext(any(Integer.class));
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testJustWithScheduler() {
+        TestScheduler scheduler = new TestScheduler();
+        Observable<Integer> observable = Observable.fromArray(1, 2).subscribeOn(scheduler);
+
+        Subscriber<Integer> observer = mockSubscriber();
+        
+        observable.subscribe(observer);
+
+        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);
+
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, times(1)).onNext(1);
+        inOrder.verify(observer, times(1)).onNext(2);
+        inOrder.verify(observer, times(1)).onComplete();
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testStartWithWithScheduler() {
+        TestScheduler scheduler = new TestScheduler();
+        Observable<Integer> observable = Observable.just(3, 4).startWith(Arrays.asList(1, 2)).subscribeOn(scheduler);
+
+        Subscriber<Integer> observer = mockSubscriber();
+        
+        observable.subscribe(observer);
+
+        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);
+
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, times(1)).onNext(1);
+        inOrder.verify(observer, times(1)).onNext(2);
+        inOrder.verify(observer, times(1)).onNext(3);
+        inOrder.verify(observer, times(1)).onNext(4);
+        inOrder.verify(observer, times(1)).onComplete();
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testRangeWithScheduler() {
+        TestScheduler scheduler = new TestScheduler();
+        Observable<Integer> observable = Observable.range(3, 4).subscribeOn(scheduler);
+
+        Subscriber<Integer> observer = mockSubscriber();
+
+        observable.subscribe(observer);
+
+        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);
+
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, times(1)).onNext(3);
+        inOrder.verify(observer, times(1)).onNext(4);
+        inOrder.verify(observer, times(1)).onNext(5);
+        inOrder.verify(observer, times(1)).onNext(6);
+        inOrder.verify(observer, times(1)).onComplete();
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testCollectToList() {
+        Observable<List<Integer>> o = Observable.just(1, 2, 3)
+        .collect(ArrayList::new, (list, v) -> list.add(v));
+        
+        List<Integer> list =  o.toBlocking().last();
+
+        assertEquals(3, list.size());
+        assertEquals(1, list.get(0).intValue());
+        assertEquals(2, list.get(1).intValue());
+        assertEquals(3, list.get(2).intValue());
+        
+        // test multiple subscribe
+        List<Integer> list2 =  o.toBlocking().last();
+
+        assertEquals(3, list2.size());
+        assertEquals(1, list2.get(0).intValue());
+        assertEquals(2, list2.get(1).intValue());
+        assertEquals(3, list2.get(2).intValue());
+    }
+
+    @Test
+    public void testCollectToString() {
+        String value = Observable.just(1, 2, 3).collect(StringBuilder::new, 
+            (sb, v) -> {
+            if (sb.length() > 0) {
+                sb.append("-");
+            }
+            sb.append(v);
+        }).toBlocking().last().toString();
+
+        assertEquals("1-2-3", value);
+    }
+    
+    @Test
+    public void testMergeWith() {
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        Observable.just(1).mergeWith(Observable.just(2)).subscribe(ts);
+        ts.assertValues(1, 2);
+    }
+    
+    @Test
+    public void testConcatWith() {
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        Observable.just(1).concatWith(Observable.just(2)).subscribe(ts);
+        ts.assertValues(1, 2);
+    }
+    
+    @Test
+    public void testAmbWith() {
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        Observable.just(1).ambWith(Observable.just(2)).subscribe(ts);
+        ts.assertValue(1);
+    }
+// FIXME Subscribers can't throw
+//    @Test(expected = OnErrorNotImplementedException.class)
+//    public void testSubscribeWithoutOnError() {
+//        Observable<String> o = Observable.just("a", "b").flatMap(new Func1<String, Observable<String>>() {
+//            @Override
+//            public Observable<String> call(String s) {
+//                return Observable.error(new Exception("test"));
+//            }
+//        });
+//        o.subscribe();
+//    }
+
+    @Test
+    public void testTakeWhileToList() {
+        final int expectedCount = 3;
+        final AtomicInteger count = new AtomicInteger();
+        for (int i = 0;i < expectedCount; i++) {
+            Observable
+                    .just(Boolean.TRUE, Boolean.FALSE)
+                    .takeWhile(v -> v)
+                    .toList()
+                    .doOnNext(booleans -> count.incrementAndGet())
+                    .subscribe();
+        }
+        assertEquals(expectedCount, count.get());
+    }
+    
+    @Test
+    public void testCompose() {
+        TestSubscriber<String> ts = new TestSubscriber<>();
+        Observable.just(1, 2, 3).compose(t1 ->t1.map(String::valueOf))
+        .subscribe(ts);
+        ts.assertTerminated();
+        ts.assertNoErrors();
+        ts.assertValues("1", "2", "3");
+    }
+    
+    @Test
+    public void testErrorThrownIssue1685() {
+        Subject<Object, Object> subject = ReplaySubject.create();
+
+        Observable.error(new RuntimeException("oops"))
+            .materialize()
+            .delay(1, TimeUnit.SECONDS)
+            .dematerialize()
+            .subscribe(subject);
+
+        subject.subscribe();
+        subject.materialize().toBlocking().first();
+
+        System.out.println("Done");
+    }
+
+    @Test
+    public void testEmptyIdentity() {
+        assertEquals(Observable.empty(), Observable.empty());
+    }
+    
+    @Test
+    public void testEmptyIsEmpty() {
+        Observable.<Integer>empty().subscribe(w);
+        
+        verify(w).onComplete();
+        verify(w, never()).onNext(any(Integer.class));
+        verify(w, never()).onError(any(Throwable.class));
+    }
+
+// FIXME this test doesn't make sense 
+//    @Test // cf. https://github.com/ReactiveX/RxJava/issues/2599
+//    public void testSubscribingSubscriberAsObserverMaintainsSubscriptionChain() {
+//        TestSubscriber<Object> subscriber = new TestSubscriber<>();
+//        Subscription subscription = Observable.just("event").subscribe((Observer<Object>) subscriber);
+//        subscription.unsubscribe();
+//
+//        subscriber.assertUnsubscribed();
+//    }
+
+// FIXME subscribers can't throw
+//    @Test(expected=OnErrorNotImplementedException.class)
+//    public void testForEachWithError() {
+//        Observable.error(new Exception("boo"))
+//        //
+//        .forEach(new Action1<Object>() {
+//            @Override
+//            public void call(Object t) {
+//                //do nothing
+//            }});
+//    }
+    
+    @Test(expected = NullPointerException.class)
+    public void testForEachWithNull() {
+        Observable.error(new Exception("boo"))
+        //
+        .forEach(null);
+    }
+    
+    @Test
+    public void testExtend() {
+        final TestSubscriber<Object> subscriber = new TestSubscriber<>();
+        final Object value = new Object();
+        Observable.just(value).to(onSubscribe -> {
+                onSubscribe.subscribe(subscriber);
+                subscriber.assertNoErrors();
+                subscriber.assertComplete();
+                subscriber.assertValue(value);
+                return subscriber.values().get(0);
+            });
+    }
+}
\ No newline at end of file
