diff --git a/src/main/java/io/reactivex/Maybe.java b/src/main/java/io/reactivex/Maybe.java
index 2c7a8de01e..b4b559851a 100644
--- a/src/main/java/io/reactivex/Maybe.java
+++ b/src/main/java/io/reactivex/Maybe.java
@@ -2670,13 +2670,13 @@ public final Completable flatMapCompletable(final Function<? super T, ? extends
      *  <dd>{@code ignoreElement} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @return an empty Maybe that only calls {@code onComplete} or {@code onError}, based on which one is
+     * @return an empty Completable that only calls {@code onComplete} or {@code onError}, based on which one is
      *         called by the source Maybe
      * @see <a href="http://reactivex.io/documentation/operators/ignoreelements.html">ReactiveX operators documentation: IgnoreElements</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Maybe<T> ignoreElement() {
-        return RxJavaPlugins.onAssembly(new MaybeIgnoreElement<T>(this));
+    public final Completable ignoreElement() {
+        return RxJavaPlugins.onAssembly(new MaybeIgnoreElementCompletable<T>(this));
     }
 
     /**
diff --git a/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java
index 1aec2ce308..bd94ca1211 100644
--- a/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java
+++ b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java
@@ -97,6 +97,11 @@ public static boolean replace(AtomicReference<Disposable> field, Disposable d) {
         }
     }
 
+    /**
+     * Atomically disposes the Disposable in the field if not already disposed.
+     * @param field the target field
+     * @return true if the curren thread managed to dispose the Disposable
+     */
     public static boolean dispose(AtomicReference<Disposable> field) {
         Disposable current = field.get();
         Disposable d = DISPOSED;
diff --git a/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java b/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java
index f1cac318d8..722fa860a0 100644
--- a/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java
+++ b/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java
@@ -15,7 +15,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.Consumer;
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -58,7 +58,7 @@ public void onError(Throwable t) {
             consumer.accept(Notification.<Object>createOnError(t));
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            RxJavaPlugins.onError(ex);
+            RxJavaPlugins.onError(new CompositeException(t, ex));
         }
     }
 
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromIterable.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromIterable.java
index a2f1e345a5..8979924811 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromIterable.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromIterable.java
@@ -261,28 +261,6 @@ void slowPath(long r) {
 
                 r = get();
                 if (e == r) {
-
-                    if (cancelled) {
-                        return;
-                    }
-
-                    boolean b;
-
-                    try {
-                        b = it.hasNext();
-                    } catch (Throwable ex) {
-                        Exceptions.throwIfFatal(ex);
-                        a.onError(ex);
-                        return;
-                    }
-
-                    if (!b) {
-                        if (!cancelled) {
-                            a.onComplete();
-                        }
-                        return;
-                    }
-
                     r = addAndGet(-e);
                     if (r == 0L) {
                         return;
@@ -423,28 +401,6 @@ void slowPath(long r) {
 
                 r = get();
                 if (e == r) {
-
-                    if (cancelled) {
-                        return;
-                    }
-
-                    boolean hasNext;
-
-                    try {
-                        hasNext = it.hasNext();
-                    } catch (Throwable ex) {
-                        Exceptions.throwIfFatal(ex);
-                        a.onError(ex);
-                        return;
-                    }
-
-                    if (!hasNext) {
-                        if (!cancelled) {
-                            a.onComplete();
-                        }
-                        return;
-                    }
-
                     r = addAndGet(-e);
                     if (r == 0L) {
                         return;
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
index 7821eb7f7b..2e3819e614 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
@@ -23,7 +23,7 @@
 import io.reactivex.*;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.exceptions.*;
 import io.reactivex.internal.disposables.DisposableHelper;
 import io.reactivex.internal.fuseable.SimpleQueue;
 import io.reactivex.internal.queue.MpscLinkedQueue;
@@ -126,7 +126,7 @@ public void onSubscribe(Subscription s) {
             } else {
                 cancelled = true;
                 s.cancel();
-                a.onError(new IllegalStateException("Could not deliver first window due to lack of requests."));
+                a.onError(new MissingBackpressureException("Could not deliver first window due to lack of requests."));
                 return;
             }
 
@@ -281,7 +281,7 @@ void drainLoop() {
                                 queue.clear();
                                 s.cancel();
                                 dispose();
-                                a.onError(new IllegalStateException("Could not deliver first window due to lack of requests."));
+                                a.onError(new MissingBackpressureException("Could not deliver first window due to lack of requests."));
                                 return;
                             }
                         } else {
@@ -374,7 +374,7 @@ public void onSubscribe(Subscription s) {
             } else {
                 cancelled = true;
                 s.cancel();
-                a.onError(new IllegalStateException("Could not deliver initial window due to lack of requests."));
+                a.onError(new MissingBackpressureException("Could not deliver initial window due to lack of requests."));
                 return;
             }
 
@@ -436,7 +436,7 @@ public void onNext(T t) {
                         window = null;
                         s.cancel();
                         dispose();
-                        actual.onError(new IllegalStateException("Could not deliver window due to lack of requests"));
+                        actual.onError(new MissingBackpressureException("Could not deliver window due to lack of requests"));
                         return;
                     }
                 } else {
@@ -572,7 +572,7 @@ void drainLoop() {
                                 queue.clear();
                                 s.cancel();
                                 dispose();
-                                a.onError(new IllegalStateException("Could not deliver first window due to lack of requests."));
+                                a.onError(new MissingBackpressureException("Could not deliver first window due to lack of requests."));
                                 return;
                             }
                         }
@@ -613,7 +613,7 @@ void drainLoop() {
                             window = null;
                             s.cancel();
                             dispose();
-                            actual.onError(new IllegalStateException("Could not deliver window due to lack of requests"));
+                            actual.onError(new MissingBackpressureException("Could not deliver window due to lack of requests"));
                             return;
                         }
                     } else {
@@ -719,7 +719,7 @@ public void run() {
 
             } else {
                 s.cancel();
-                actual.onError(new IllegalStateException("Could not emit the first window due to lack of requests"));
+                actual.onError(new MissingBackpressureException("Could not emit the first window due to lack of requests"));
             }
         }
 
@@ -878,7 +878,7 @@ public void run() {
                                     }
                                 }, timespan, unit);
                             } else {
-                                a.onError(new IllegalStateException("Can't emit window due to lack of requests"));
+                                a.onError(new MissingBackpressureException("Can't emit window due to lack of requests"));
                                 continue;
                             }
                         } else {
diff --git a/src/main/java/io/reactivex/internal/operators/maybe/MaybeFromFuture.java b/src/main/java/io/reactivex/internal/operators/maybe/MaybeFromFuture.java
index 3015cb1da2..8db068bff6 100644
--- a/src/main/java/io/reactivex/internal/operators/maybe/MaybeFromFuture.java
+++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeFromFuture.java
@@ -42,43 +42,37 @@ public MaybeFromFuture(Future<? extends T> future, long timeout, TimeUnit unit)
     protected void subscribeActual(MaybeObserver<? super T> observer) {
         Disposable d = Disposables.empty();
         observer.onSubscribe(d);
-        if (d.isDisposed()) {
-            return;
-        }
-
-        T v;
-        try {
-            if (timeout <= 0L) {
-                v = future.get();
-            } else {
-                v = future.get(timeout, unit);
-            }
-        } catch (InterruptedException ex) {
-            if (d.isDisposed()) {
+        if (!d.isDisposed()) {
+            T v;
+            try {
+                if (timeout <= 0L) {
+                    v = future.get();
+                } else {
+                    v = future.get(timeout, unit);
+                }
+            } catch (InterruptedException ex) {
+                if (!d.isDisposed()) {
+                    observer.onError(ex);
+                }
                 return;
-            }
-            observer.onError(ex);
-            return;
-        } catch (ExecutionException ex) {
-            if (d.isDisposed()) {
+            } catch (ExecutionException ex) {
+                if (!d.isDisposed()) {
+                    observer.onError(ex.getCause());
+                }
                 return;
-            }
-            observer.onError(ex.getCause());
-            return;
-        } catch (TimeoutException ex) {
-            if (d.isDisposed()) {
+            } catch (TimeoutException ex) {
+                if (!d.isDisposed()) {
+                    observer.onError(ex);
+                }
                 return;
             }
-            observer.onError(ex);
-            return;
-        }
-        if (d.isDisposed()) {
-            return;
-        }
-        if (v == null) {
-            observer.onComplete();
-        } else {
-            observer.onSuccess(v);
+            if (!d.isDisposed()) {
+                if (v == null) {
+                    observer.onComplete();
+                } else {
+                    observer.onSuccess(v);
+                }
+            }
         }
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/maybe/MaybeIgnoreElementCompletable.java b/src/main/java/io/reactivex/internal/operators/maybe/MaybeIgnoreElementCompletable.java
new file mode 100644
index 0000000000..8f481d14be
--- /dev/null
+++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeIgnoreElementCompletable.java
@@ -0,0 +1,95 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.maybe;
+
+import io.reactivex.*;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.fuseable.FuseToMaybe;
+import io.reactivex.plugins.RxJavaPlugins;
+
+/**
+ * Turns an onSuccess into an onComplete, onError and onComplete is relayed as is.
+ *
+ * @param <T> the value type
+ */
+public final class MaybeIgnoreElementCompletable<T> extends Completable implements FuseToMaybe<T> {
+
+    final MaybeSource<T> source;
+
+    public MaybeIgnoreElementCompletable(MaybeSource<T> source) {
+        this.source = source;
+    }
+
+    @Override
+    protected void subscribeActual(CompletableObserver observer) {
+        source.subscribe(new IgnoreMaybeObserver<T>(observer));
+    }
+
+    @Override
+    public Maybe<T> fuseToMaybe() {
+        return RxJavaPlugins.onAssembly(new MaybeIgnoreElement<T>(source));
+    }
+
+    static final class IgnoreMaybeObserver<T> implements MaybeObserver<T>, Disposable {
+
+        final CompletableObserver actual;
+
+        Disposable d;
+
+        IgnoreMaybeObserver(CompletableObserver actual) {
+            this.actual = actual;
+        }
+
+        @Override
+        public void onSubscribe(Disposable d) {
+            if (DisposableHelper.validate(this.d, d)) {
+                this.d = d;
+
+                actual.onSubscribe(this);
+            }
+        }
+
+        @Override
+        public void onSuccess(T value) {
+            d = DisposableHelper.DISPOSED;
+            actual.onComplete();
+        }
+
+        @Override
+        public void onError(Throwable e) {
+            d = DisposableHelper.DISPOSED;
+            actual.onError(e);
+        }
+
+        @Override
+        public void onComplete() {
+            d = DisposableHelper.DISPOSED;
+            actual.onComplete();
+        }
+
+        @Override
+        public boolean isDisposed() {
+            return d.isDisposed();
+        }
+
+        @Override
+        public void dispose() {
+            d.dispose();
+            d = DisposableHelper.DISPOSED;
+        }
+
+    }
+
+}
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
index 4925c09d23..68b8159ecd 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
@@ -23,6 +23,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.internal.disposables.*;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.observers.QueueDrainObserver;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.util.QueueDrainHelper;
@@ -201,7 +202,7 @@ public void run() {
             U next;
 
             try {
-                next = bufferSupplier.call();
+                next = ObjectHelper.requireNonNull(bufferSupplier.call(), "The bufferSupplier returned a null buffer");
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
                 selfCancel = true;
@@ -210,13 +211,6 @@ public void run() {
                 return;
             }
 
-            if (next == null) {
-                selfCancel = true;
-                dispose();
-                actual.onError(new NullPointerException("buffer supplied is null"));
-                return;
-            }
-
             U current;
 
             synchronized (this) {
@@ -371,7 +365,7 @@ public void run() {
             final U b; // NOPMD
 
             try {
-                b = bufferSupplier.call();
+                b = ObjectHelper.requireNonNull(bufferSupplier.call(), "The bufferSupplier returned a null buffer");
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
                 dispose();
@@ -379,11 +373,6 @@ public void run() {
                 return;
             }
 
-            if (b == null) {
-                dispose();
-                actual.onError(new NullPointerException("The supplied buffer is null"));
-                return;
-            }
             synchronized (this) {
                 if (cancelled) {
                     return;
@@ -584,7 +573,7 @@ public void run() {
             U next;
 
             try {
-                next = bufferSupplier.call();
+                next = ObjectHelper.requireNonNull(bufferSupplier.call(), "The bufferSupplier returned a null buffer");
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
                 dispose();
@@ -592,12 +581,6 @@ public void run() {
                 return;
             }
 
-            if (next == null) {
-                dispose();
-                actual.onError(new NullPointerException("The buffer supplied is null"));
-                return;
-            }
-
             U current;
 
             synchronized (this) {
diff --git a/src/main/java/io/reactivex/internal/schedulers/DisposeOnCancel.java b/src/main/java/io/reactivex/internal/schedulers/DisposeOnCancel.java
index ec89f477c5..ea50598392 100644
--- a/src/main/java/io/reactivex/internal/schedulers/DisposeOnCancel.java
+++ b/src/main/java/io/reactivex/internal/schedulers/DisposeOnCancel.java
@@ -24,7 +24,7 @@
 final class DisposeOnCancel implements Future<Object> {
     final Disposable d;
 
-    public DisposeOnCancel(Disposable d) {
+    DisposeOnCancel(Disposable d) {
         this.d = d;
     }
 
diff --git a/src/test/java/io/reactivex/TestHelper.java b/src/test/java/io/reactivex/TestHelper.java
index 4a6f279c71..390b1168f3 100644
--- a/src/test/java/io/reactivex/TestHelper.java
+++ b/src/test/java/io/reactivex/TestHelper.java
@@ -619,6 +619,55 @@ public void onComplete() {
         assertEquals("Didn't report disposed after?", true, b[1]);
     }
 
+    /**
+     * Checks if the upstream's Disposable sent through the onSubscribe reports
+     * isDisposed properly before and after calling dispose.
+     * @param source the source to test
+     */
+    public static void checkDisposed(Observable<?> source) {
+        final Boolean[] b = { null, null };
+        final CountDownLatch cdl = new CountDownLatch(1);
+        source.subscribe(new Observer<Object>() {
+
+            @Override
+            public void onSubscribe(Disposable d) {
+                try {
+                    b[0] = d.isDisposed();
+
+                    d.dispose();
+
+                    b[1] = d.isDisposed();
+                } finally {
+                    cdl.countDown();
+                }
+            }
+
+            @Override
+            public void onNext(Object value) {
+                // ignored
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                // ignored
+            }
+
+            @Override
+            public void onComplete() {
+                // ignored
+            }
+        });
+
+        try {
+            assertTrue("Timed out", cdl.await(5, TimeUnit.SECONDS));
+        } catch (InterruptedException ex) {
+            throw ExceptionHelper.wrapOrThrow(ex);
+        }
+
+        assertEquals("Reports disposed upfront?", false, b[0]);
+        assertEquals("Didn't report disposed after?", true, b[1]);
+    }
+
     /**
      * Checks if the upstream's Disposable sent through the onSubscribe reports
      * isDisposed properly before and after calling dispose.
@@ -798,7 +847,6 @@ protected void subscribeActual(MaybeObserver<? super T> observer) {
         }
     }
 
-
     /**
      * Check if the given transformed reactive type reports multiple onSubscribe calls to
      * RxJavaPlugins.
@@ -852,6 +900,58 @@ protected void subscribeActual(MaybeObserver<? super T> observer) {
             RxJavaPlugins.reset();
         }
     }
+    /**
+     * Check if the given transformed reactive type reports multiple onSubscribe calls to
+     * RxJavaPlugins.
+     * @param <T> the input value type
+     * @param transform the transform to drive an operator
+     */
+    public static <T> void checkDoubleOnSubscribeMaybeToCompletable(Function<Maybe<T>, ? extends CompletableSource> transform) {
+        List<Throwable> errors = trackPluginErrors();
+        try {
+            final Boolean[] b = { null, null };
+            final CountDownLatch cdl = new CountDownLatch(1);
+
+            Maybe<T> source = new Maybe<T>() {
+                @Override
+                protected void subscribeActual(MaybeObserver<? super T> observer) {
+                    try {
+                        Disposable d1 = Disposables.empty();
+
+                        observer.onSubscribe(d1);
+
+                        Disposable d2 = Disposables.empty();
+
+                        observer.onSubscribe(d2);
+
+                        b[0] = d1.isDisposed();
+                        b[1] = d2.isDisposed();
+                    } finally {
+                        cdl.countDown();
+                    }
+                }
+            };
+
+            CompletableSource out = transform.apply(source);
+
+            out.subscribe(NoOpConsumer.INSTANCE);
+
+            try {
+                assertTrue("Timed out", cdl.await(5, TimeUnit.SECONDS));
+            } catch (InterruptedException ex) {
+                throw ExceptionHelper.wrapOrThrow(ex);
+            }
+
+            assertEquals("First disposed?", false, b[0]);
+            assertEquals("Second not disposed?", true, b[1]);
+
+            assertError(errors, 0, IllegalStateException.class, "Disposable already set!");
+        } catch (Throwable ex) {
+            throw ExceptionHelper.wrapOrThrow(ex);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 
     /**
      * Check if the given transformed reactive type reports multiple onSubscribe calls to
diff --git a/src/test/java/io/reactivex/internal/observers/ToNotificationObserverTest.java b/src/test/java/io/reactivex/internal/observers/ToNotificationObserverTest.java
new file mode 100644
index 0000000000..3d11cae31c
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/observers/ToNotificationObserverTest.java
@@ -0,0 +1,148 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.observers;
+
+import static org.junit.Assert.*;
+
+import java.util.*;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.*;
+import io.reactivex.functions.Consumer;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.plugins.RxJavaPlugins;
+
+public class ToNotificationObserverTest {
+
+    @Test
+    public void doubleOnSubscribe() {
+        ToNotificationObserver<Integer> o = new ToNotificationObserver<Integer>(Functions.emptyConsumer());
+
+        Disposable d1 = Disposables.empty();
+
+        o.onSubscribe(d1);
+
+        Disposable d2 = Disposables.empty();
+
+        o.onSubscribe(d2);
+
+        assertFalse(d1.isDisposed());
+
+        assertTrue(d2.isDisposed());
+    }
+
+    @Test
+    public void nullOnNext() {
+        final List<Notification<Object>> list = new ArrayList<Notification<Object>>();
+
+        ToNotificationObserver<Integer> o = new ToNotificationObserver<Integer>(new Consumer<Notification<Object>>() {
+            @Override
+            public void accept(Notification<Object> e) throws Exception {
+                list.add(e);
+            }
+        });
+
+        Disposable d1 = Disposables.empty();
+
+        o.onSubscribe(d1);
+
+        o.onNext(null);
+
+        assertTrue(d1.isDisposed());
+
+        assertTrue(list.toString(), list.get(0).getError() instanceof NullPointerException);
+    }
+
+    @Test
+    public void onNextCrash() {
+        final List<Notification<Object>> list = new ArrayList<Notification<Object>>();
+
+        ToNotificationObserver<Integer> o = new ToNotificationObserver<Integer>(new Consumer<Notification<Object>>() {
+            @Override
+            public void accept(Notification<Object> e) throws Exception {
+                if (e.isOnNext()) {
+                    throw new TestException();
+                } else {
+                    list.add(e);
+                }
+            }
+        });
+
+        Disposable d1 = Disposables.empty();
+
+        o.onSubscribe(d1);
+
+        o.onNext(1);
+
+        assertTrue(d1.isDisposed());
+
+        assertTrue(list.toString(), list.get(0).getError() instanceof TestException);
+    }
+
+    @Test
+    public void onErrorCrash() {
+        final List<Throwable> list = TestHelper.trackPluginErrors();
+
+        try {
+            ToNotificationObserver<Integer> o = new ToNotificationObserver<Integer>(new Consumer<Notification<Object>>() {
+                @Override
+                public void accept(Notification<Object> e) throws Exception {
+                    throw new TestException("Inner");
+                }
+            });
+
+            Disposable d1 = Disposables.empty();
+
+            o.onSubscribe(d1);
+
+            o.onError(new TestException("Outer"));
+
+            TestHelper.assertError(list, 0, CompositeException.class);
+
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+
+            TestHelper.assertError(ce, 0, TestException.class, "Outer");
+            TestHelper.assertError(ce, 1, TestException.class, "Inner");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteCrash() {
+        final List<Throwable> list = TestHelper.trackPluginErrors();
+
+        try {
+            ToNotificationObserver<Integer> o = new ToNotificationObserver<Integer>(new Consumer<Notification<Object>>() {
+                @Override
+                public void accept(Notification<Object> e) throws Exception {
+                    throw new TestException("Inner");
+                }
+            });
+
+            Disposable d1 = Disposables.empty();
+
+            o.onSubscribe(d1);
+
+            o.onComplete();
+
+            TestHelper.assertError(list, 0, TestException.class, "Inner");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
index 3c4006dabb..2fe728979c 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBufferTest.java
@@ -14,6 +14,7 @@
 package io.reactivex.internal.operators.flowable;
 
 import static org.junit.Assert.*;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
 import java.util.*;
@@ -27,6 +28,7 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.processors.PublishProcessor;
@@ -1316,4 +1318,206 @@ public void bufferTimeSkipDefault() {
         .assertResult(Arrays.asList(1, 2, 3, 4, 5));
     }
 
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBufferSupplierThrows() {
+        Flowable.never()
+        .buffer(Functions.justCallable(Flowable.never()), new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                throw new TestException();
+            }
+        })
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBoundarySupplierThrows() {
+        Flowable.never()
+        .buffer(new Callable<Publisher<Object>>() {
+            @Override
+            public Publisher<Object> call() throws Exception {
+                throw new TestException();
+            }
+        }, new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBufferSupplierThrows2() {
+        Flowable.never()
+        .buffer(Functions.justCallable(Flowable.timer(1, TimeUnit.MILLISECONDS)), new Callable<Collection<Object>>() {
+            int count;
+            @Override
+            public Collection<Object> call() throws Exception {
+                if (count++ == 1) {
+                    throw new TestException();
+                } else {
+                    return new ArrayList<Object>();
+                }
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBufferSupplierReturnsNull() {
+        Flowable.never()
+        .buffer(Functions.justCallable(Flowable.timer(1, TimeUnit.MILLISECONDS)), new Callable<Collection<Object>>() {
+            int count;
+            @Override
+            public Collection<Object> call() throws Exception {
+                if (count++ == 1) {
+                    return null;
+                } else {
+                    return new ArrayList<Object>();
+                }
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBoundarySupplierThrows2() {
+        Flowable.never()
+        .buffer(new Callable<Publisher<Long>>() {
+            int count;
+            @Override
+            public Publisher<Long> call() throws Exception {
+                if (count++ == 1) {
+                    throw new TestException();
+                }
+                return Flowable.timer(1, TimeUnit.MILLISECONDS);
+            }
+        }, new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void boundaryCancel() {
+        PublishProcessor<Object> pp = PublishProcessor.create();
+
+        TestSubscriber<Collection<Object>> ts = pp
+        .buffer(Functions.justCallable(Flowable.never()), new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test();
+
+        assertTrue(pp.hasSubscribers());
+
+        ts.dispose();
+
+        assertFalse(pp.hasSubscribers());
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBoundarySupplierReturnsNull() {
+        Flowable.never()
+        .buffer(new Callable<Publisher<Long>>() {
+            int count;
+            @Override
+            public Publisher<Long> call() throws Exception {
+                if (count++ == 1) {
+                    return null;
+                }
+                return Flowable.timer(1, TimeUnit.MILLISECONDS);
+            }
+        }, new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBoundarySupplierReturnsNull2() {
+        Flowable.never()
+        .buffer(new Callable<Publisher<Long>>() {
+            int count;
+            @Override
+            public Publisher<Long> call() throws Exception {
+                if (count++ == 1) {
+                    return null;
+                }
+                return Flowable.empty();
+            }
+        }, new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(NullPointerException.class);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void boundaryMainError() {
+        PublishProcessor<Object> pp = PublishProcessor.create();
+
+        TestSubscriber<Collection<Object>> ts = pp
+        .buffer(Functions.justCallable(Flowable.never()), new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test();
+
+        pp.onError(new TestException());
+
+        ts.assertFailure(TestException.class);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void boundaryBoundaryError() {
+        PublishProcessor<Object> pp = PublishProcessor.create();
+
+        TestSubscriber<Collection<Object>> ts = pp
+        .buffer(Functions.justCallable(Flowable.error(new TestException())), new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test();
+
+        pp.onError(new TestException());
+
+        ts.assertFailure(TestException.class);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromIterableTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromIterableTest.java
index 2f5b10b356..2cd4c82021 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromIterableTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromIterableTest.java
@@ -22,11 +22,15 @@
 
 import org.junit.Test;
 import org.mockito.Mockito;
-import org.reactivestreams.Subscriber;
+import org.reactivestreams.*;
 
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.Function;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.internal.fuseable.QueueSubscription;
+import io.reactivex.internal.util.CrashingIterable;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.*;
 
@@ -560,4 +564,304 @@ public void fusionWithConcatMap() {
         to.assertNoErrors();
         to.assertComplete();
     }
+
+    @Test
+    public void fusedAPICalls() {
+        Flowable.fromIterable(Arrays.asList(1, 2, 3))
+        .subscribe(new Subscriber<Integer>() {
+
+            @Override
+            public void onSubscribe(Subscription s) {
+                @SuppressWarnings("unchecked")
+                QueueSubscription<Integer> qs = (QueueSubscription<Integer>)s;
+
+                assertFalse(qs.isEmpty());
+
+                try {
+                    assertEquals(1, qs.poll().intValue());
+                } catch (Exception ex) {
+                    throw new AssertionError(ex);
+                }
+
+                assertFalse(qs.isEmpty());
+
+                qs.clear();
+
+                List<Throwable> errors = TestHelper.trackPluginErrors();
+                try {
+                    qs.request(-99);
+
+                    TestHelper.assertError(errors, 0, IllegalArgumentException.class, "n > 0 required but it was -99");
+                } finally {
+                    RxJavaPlugins.reset();
+                }
+            }
+
+            @Override
+            public void onNext(Integer t) {
+            }
+
+            @Override
+            public void onError(Throwable t) {
+            }
+
+            @Override
+            public void onComplete() {
+            }
+        });
+    }
+
+    @Test
+    public void normalConditional() {
+        Flowable.fromIterable(Arrays.asList(1, 2, 3, 4, 5))
+        .filter(Functions.alwaysTrue())
+        .test()
+        .assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void normalConditionalBackpressured() {
+        Flowable.fromIterable(Arrays.asList(1, 2, 3, 4, 5))
+        .filter(Functions.alwaysTrue())
+        .test(5L)
+        .assertResult(1, 2, 3, 4, 5);
+    }
+
+    @Test
+    public void normalConditionalBackpressured2() {
+        Flowable.fromIterable(Arrays.asList(1, 2, 3, 4, 5))
+        .filter(Functions.alwaysTrue())
+        .test(4L)
+        .assertSubscribed()
+        .assertValues(1, 2, 3, 4)
+        .assertNoErrors()
+        .assertNotComplete();
+    }
+
+    @Test
+    public void emptyConditional() {
+        Flowable.fromIterable(Arrays.asList(1, 2, 3, 4, 5))
+        .filter(Functions.alwaysFalse())
+        .test()
+        .assertResult();
+    }
+
+    @Test
+    public void nullConditional() {
+        Flowable.fromIterable(Arrays.asList(1, null, 3, 4, 5))
+        .filter(Functions.alwaysTrue())
+        .test()
+        .assertFailure(NullPointerException.class, 1);
+    }
+
+    @Test
+    public void nullConditionalBackpressured() {
+        Flowable.fromIterable(Arrays.asList(1, null, 3, 4, 5))
+        .filter(Functions.alwaysTrue())
+        .test(5L)
+        .assertFailure(NullPointerException.class, 1);
+    }
+
+    @Test
+    public void normalConditionalCrash() {
+        Flowable.fromIterable(new CrashingIterable(100, 2, 100))
+        .filter(Functions.alwaysTrue())
+        .test()
+        .assertFailure(TestException.class, 0);
+    }
+
+    @Test
+    public void normalConditionalCrash2() {
+        Flowable.fromIterable(new CrashingIterable(100, 100, 2))
+        .filter(Functions.alwaysTrue())
+        .test()
+        .assertFailure(TestException.class, 0);
+    }
+
+    @Test
+    public void normalConditionalCrashBackpressured() {
+        Flowable.fromIterable(new CrashingIterable(100, 2, 100))
+        .filter(Functions.alwaysTrue())
+        .test(5L)
+        .assertFailure(TestException.class, 0);
+    }
+
+    @Test
+    public void normalConditionalCrashBackpressured2() {
+        Flowable.fromIterable(new CrashingIterable(100, 100, 2))
+        .filter(Functions.alwaysTrue())
+        .test(5L)
+        .assertFailure(TestException.class, 0);
+    }
+
+    @Test
+    public void normalConditionalLong() {
+        Flowable.fromIterable(new CrashingIterable(100, 10 * 1000 * 1000, 10 * 1000 * 1000))
+        .filter(Functions.alwaysTrue())
+        .take(1000 * 1000)
+        .test()
+        .assertSubscribed()
+        .assertValueCount(1000 * 1000)
+        .assertNoErrors()
+        .assertComplete();
+    }
+
+    @Test
+    public void normalConditionalLong2() {
+        Flowable.fromIterable(new CrashingIterable(100, 10 * 1000 * 1000, 10 * 1000 * 1000))
+        .filter(Functions.alwaysTrue())
+        .rebatchRequests(128)
+        .take(1000 * 1000)
+        .test()
+        .assertSubscribed()
+        .assertValueCount(1000 * 1000)
+        .assertNoErrors()
+        .assertComplete();
+    }
+
+    @Test
+    public void requestRaceConditional() {
+        for (int i = 0; i < 500; i++) {
+            final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
+
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    ts.request(1);
+                }
+            };
+
+            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
+            .filter(Functions.alwaysTrue())
+            .subscribe(ts);
+
+            TestHelper.race(r, r, Schedulers.single());
+        }
+    }
+
+    @Test
+    public void requestRaceConditional2() {
+        for (int i = 0; i < 500; i++) {
+            final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
+
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    ts.request(1);
+                }
+            };
+
+            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
+            .filter(Functions.alwaysFalse())
+            .subscribe(ts);
+
+            TestHelper.race(r, r, Schedulers.single());
+        }
+    }
+
+    @Test
+    public void requestCancelConditionalRace() {
+        for (int i = 0; i < 500; i++) {
+            final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    ts.request(1);
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    ts.cancel();
+                }
+            };
+
+            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
+            .filter(Functions.alwaysTrue())
+            .subscribe(ts);
+
+            TestHelper.race(r1, r2, Schedulers.single());
+        }
+    }
+
+    @Test
+    public void requestCancelConditionalRace2() {
+        for (int i = 0; i < 500; i++) {
+            final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    ts.request(Long.MAX_VALUE);
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    ts.cancel();
+                }
+            };
+
+            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
+            .filter(Functions.alwaysTrue())
+            .subscribe(ts);
+
+            TestHelper.race(r1, r2, Schedulers.single());
+        }
+    }
+
+    @Test
+    public void requestCancelRace() {
+        for (int i = 0; i < 500; i++) {
+            final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    ts.request(1);
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    ts.cancel();
+                }
+            };
+
+            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
+            .subscribe(ts);
+
+            TestHelper.race(r1, r2, Schedulers.single());
+        }
+    }
+
+    @Test
+    public void requestCancelRace2() {
+        for (int i = 0; i < 500; i++) {
+            final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    ts.request(Long.MAX_VALUE);
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    ts.cancel();
+                }
+            };
+
+            Flowable.fromIterable(Arrays.asList(1, 2, 3, 4))
+            .subscribe(ts);
+
+            TestHelper.race(r1, r2, Schedulers.single());
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java
index ca39e6c229..0510593274 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java
@@ -18,11 +18,14 @@
 import java.util.concurrent.atomic.*;
 
 import org.junit.Test;
+import org.reactivestreams.*;
 
 import io.reactivex.Flowable;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.internal.fuseable.QueueSubscription;
 import io.reactivex.observers.*;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.subscribers.*;
 
 public class FlowableIgnoreElementsTest {
@@ -238,4 +241,86 @@ public void onError(Throwable e) {
         assertEquals(0, count.get());
     }
 
+    @Test
+    public void cancel() {
+
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+
+        TestSubscriber<Integer> ts = pp.ignoreElements().<Integer>toFlowable().test();
+
+        assertTrue(pp.hasSubscribers());
+
+        ts.cancel();
+
+        assertFalse(pp.hasSubscribers());
+    }
+
+    @Test
+    public void fused() {
+        TestSubscriber<Integer> ts = SubscriberFusion.newTest(QueueSubscription.ANY);
+
+        Flowable.just(1).hide().ignoreElements().<Integer>toFlowable()
+        .subscribe(ts);
+
+        ts.assertOf(SubscriberFusion.<Integer>assertFuseable())
+        .assertOf(SubscriberFusion.<Integer>assertFusionMode(QueueSubscription.ASYNC))
+        .assertResult();
+    }
+
+    @Test
+    public void fusedAPICalls() {
+        Flowable.just(1).hide().ignoreElements().<Integer>toFlowable()
+        .subscribe(new Subscriber<Integer>() {
+
+            @Override
+            public void onSubscribe(Subscription s) {
+                @SuppressWarnings("unchecked")
+                QueueSubscription<Integer> qs = (QueueSubscription<Integer>)s;
+
+                try {
+                    assertNull(qs.poll());
+                } catch (Exception ex) {
+                    throw new AssertionError(ex);
+                }
+
+                assertTrue(qs.isEmpty());
+
+                qs.clear();
+
+                assertTrue(qs.isEmpty());
+
+                try {
+                    assertNull(qs.poll());
+                } catch (Exception ex) {
+                    throw new AssertionError(ex);
+                }
+
+                try {
+                    qs.offer(1);
+                    fail("Should have thrown!");
+                } catch (UnsupportedOperationException ex) {
+                    // expected
+                }
+
+                try {
+                    qs.offer(1, 2);
+                    fail("Should have thrown!");
+                } catch (UnsupportedOperationException ex) {
+                    // expected
+                }
+            }
+
+            @Override
+            public void onNext(Integer t) {
+            }
+
+            @Override
+            public void onError(Throwable t) {
+            }
+
+            @Override
+            public void onComplete() {
+            }
+        });
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
index 13254a8e39..f918ccdd2f 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java
@@ -23,7 +23,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.Flowable;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
@@ -363,4 +363,136 @@ public void timeskipOverlapping() {
 
         ts.assertResult(1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7);
     }
+
+    @Test
+    public void exactOnError() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+
+        TestSubscriber<Integer> ts = pp.window(1, 1, TimeUnit.SECONDS, scheduler)
+        .flatMap(Functions.<Flowable<Integer>>identity())
+        .test();
+
+        pp.onError(new TestException());
+
+        ts.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void overlappingOnError() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+
+        TestSubscriber<Integer> ts = pp.window(2, 1, TimeUnit.SECONDS, scheduler)
+        .flatMap(Functions.<Flowable<Integer>>identity())
+        .test();
+
+        pp.onError(new TestException());
+
+        ts.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void skipOnError() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+
+        TestSubscriber<Integer> ts = pp.window(1, 2, TimeUnit.SECONDS, scheduler)
+        .flatMap(Functions.<Flowable<Integer>>identity())
+        .test();
+
+        pp.onError(new TestException());
+
+        ts.assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void exactBackpressure() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+
+        TestSubscriber<Flowable<Integer>> ts = pp.window(1, 1, TimeUnit.SECONDS, scheduler)
+        .test(0L);
+
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        ts.assertFailure(MissingBackpressureException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void skipBackpressure() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+
+        TestSubscriber<Flowable<Integer>> ts = pp.window(1, 2, TimeUnit.SECONDS, scheduler)
+        .test(0L);
+
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        ts.assertFailure(MissingBackpressureException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void overlapBackpressure() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+
+        TestSubscriber<Flowable<Integer>> ts = pp.window(2, 1, TimeUnit.SECONDS, scheduler)
+        .test(0L);
+
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        ts.assertFailure(MissingBackpressureException.class);
+    }
+
+    @Test
+    public void exactBackpressure2() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+
+        TestSubscriber<Flowable<Integer>> ts = pp.window(1, 1, TimeUnit.SECONDS, scheduler)
+        .test(1L);
+
+        scheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+
+        ts.assertError(MissingBackpressureException.class);
+    }
+
+    @Test
+    public void skipBackpressure2() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+
+        TestSubscriber<Flowable<Integer>> ts = pp.window(1, 2, TimeUnit.SECONDS, scheduler)
+        .test(1L);
+
+        scheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+
+        ts.assertError(MissingBackpressureException.class);
+    }
+
+    @Test
+    public void overlapBackpressure2() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+
+        TestSubscriber<Flowable<Integer>> ts = pp.window(2, 1, TimeUnit.SECONDS, scheduler)
+        .test(1L);
+
+        scheduler.advanceTimeBy(2, TimeUnit.SECONDS);
+
+        ts.assertError(MissingBackpressureException.class);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/maybe/AbstractMaybeWithUpstreamTest.java b/src/test/java/io/reactivex/internal/operators/maybe/AbstractMaybeWithUpstreamTest.java
new file mode 100644
index 0000000000..8925c59f04
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/maybe/AbstractMaybeWithUpstreamTest.java
@@ -0,0 +1,32 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.maybe;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+import io.reactivex.Maybe;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.internal.fuseable.HasUpstreamMaybeSource;
+
+public class AbstractMaybeWithUpstreamTest {
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void upstream() {
+        Maybe<Integer> source = Maybe.just(1);
+
+        assertSame(source, ((HasUpstreamMaybeSource<Integer>)source.map(Functions.<Integer>identity())).source());
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeCallbackObserverTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeCallbackObserverTest.java
new file mode 100644
index 0000000000..eddb45e1ae
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeCallbackObserverTest.java
@@ -0,0 +1,124 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.maybe;
+
+import static org.junit.Assert.*;
+
+import java.util.List;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.*;
+import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.plugins.RxJavaPlugins;
+
+public class MaybeCallbackObserverTest {
+
+    @Test
+    public void dispose() {
+        MaybeCallbackObserver<Object> mo = new MaybeCallbackObserver<Object>(Functions.emptyConsumer(), Functions.emptyConsumer(), Functions.EMPTY_ACTION);
+
+        Disposable d = Disposables.empty();
+
+        mo.onSubscribe(d);
+
+        assertFalse(mo.isDisposed());
+
+        mo.dispose();
+
+        assertTrue(mo.isDisposed());
+
+        assertTrue(d.isDisposed());
+    }
+
+    @Test
+    public void onSuccessCrashes() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            MaybeCallbackObserver<Object> mo = new MaybeCallbackObserver<Object>(
+                    new Consumer<Object>() {
+                        @Override
+                        public void accept(Object v) throws Exception {
+                            throw new TestException();
+                        }
+                    },
+                    Functions.emptyConsumer(),
+                    Functions.EMPTY_ACTION);
+
+            mo.onSubscribe(Disposables.empty());
+
+            mo.onSuccess(1);
+
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onErrorCrashes() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            MaybeCallbackObserver<Object> mo = new MaybeCallbackObserver<Object>(
+                    Functions.emptyConsumer(),
+                    new Consumer<Object>() {
+                        @Override
+                        public void accept(Object v) throws Exception {
+                            throw new TestException("Inner");
+                        }
+                    },
+                    Functions.EMPTY_ACTION);
+
+            mo.onSubscribe(Disposables.empty());
+
+            mo.onError(new TestException("Outer"));
+
+            TestHelper.assertError(errors, 0, CompositeException.class);
+
+            List<Throwable> ce = TestHelper.compositeList(errors.get(0));
+
+            TestHelper.assertError(ce, 0, TestException.class, "Outer");
+            TestHelper.assertError(ce, 1, TestException.class, "Inner");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteCrashes() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            MaybeCallbackObserver<Object> mo = new MaybeCallbackObserver<Object>(
+                    Functions.emptyConsumer(),
+                    Functions.emptyConsumer(),
+                    new Action() {
+                        @Override
+                        public void run() throws Exception {
+                            throw new TestException();
+                        }
+                    });
+
+            mo.onSubscribe(Disposables.empty());
+
+            mo.onComplete();
+
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeCreateTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeCreateTest.java
new file mode 100644
index 0000000000..eb5b1d83f2
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeCreateTest.java
@@ -0,0 +1,313 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.maybe;
+
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
+
+public class MaybeCreateTest {
+
+    @Test
+    public void callbackThrows() {
+        Maybe.create(new MaybeOnSubscribe<Object>() {
+            @Override
+            public void subscribe(MaybeEmitter<Object> e) throws Exception {
+                throw new TestException();
+            }
+        })
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void onSuccessNull() {
+        Maybe.create(new MaybeOnSubscribe<Object>() {
+            @Override
+            public void subscribe(MaybeEmitter<Object> e) throws Exception {
+                e.onSuccess(null);
+            }
+        })
+        .test()
+        .assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    public void onErrorNull() {
+        Maybe.create(new MaybeOnSubscribe<Object>() {
+            @Override
+            public void subscribe(MaybeEmitter<Object> e) throws Exception {
+                e.onError(null);
+            }
+        })
+        .test()
+        .assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Maybe.create(new MaybeOnSubscribe<Object>() {
+            @Override
+            public void subscribe(MaybeEmitter<Object> e) throws Exception {
+                e.onSuccess(1);
+            }
+        }));
+    }
+
+    @Test
+    public void onSuccessThrows() {
+        Maybe.create(new MaybeOnSubscribe<Object>() {
+            @Override
+            public void subscribe(MaybeEmitter<Object> e) throws Exception {
+                Disposable d = Disposables.empty();
+                e.setDisposable(d);
+
+                try {
+                    e.onSuccess(1);
+                    fail("Should have thrown");
+                } catch (TestException ex) {
+                    // expected
+                }
+
+                assertTrue(d.isDisposed());
+                assertTrue(e.isDisposed());
+            }
+        }).subscribe(new MaybeObserver<Object>() {
+
+            @Override
+            public void onSubscribe(Disposable d) {
+
+            }
+
+            @Override
+            public void onSuccess(Object value) {
+                throw new TestException();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+
+            }
+
+            @Override
+            public void onComplete() {
+
+            }
+        });
+    }
+
+    @Test
+    public void onErrorThrows() {
+        Maybe.create(new MaybeOnSubscribe<Object>() {
+            @Override
+            public void subscribe(MaybeEmitter<Object> e) throws Exception {
+                Disposable d = Disposables.empty();
+                e.setDisposable(d);
+
+                try {
+                    e.onError(new IOException());
+                    fail("Should have thrown");
+                } catch (TestException ex) {
+                    // expected
+                }
+
+                assertTrue(d.isDisposed());
+                assertTrue(e.isDisposed());
+            }
+        }).subscribe(new MaybeObserver<Object>() {
+
+            @Override
+            public void onSubscribe(Disposable d) {
+
+            }
+
+            @Override
+            public void onSuccess(Object value) {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                throw new TestException();
+            }
+
+            @Override
+            public void onComplete() {
+
+            }
+        });
+    }
+
+    @Test
+    public void onCompleteThrows() {
+        Maybe.create(new MaybeOnSubscribe<Object>() {
+            @Override
+            public void subscribe(MaybeEmitter<Object> e) throws Exception {
+                Disposable d = Disposables.empty();
+                e.setDisposable(d);
+
+                try {
+                    e.onComplete();
+                    fail("Should have thrown");
+                } catch (TestException ex) {
+                    // expected
+                }
+
+                assertTrue(d.isDisposed());
+                assertTrue(e.isDisposed());
+            }
+        }).subscribe(new MaybeObserver<Object>() {
+
+            @Override
+            public void onSubscribe(Disposable d) {
+
+            }
+
+            @Override
+            public void onSuccess(Object value) {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+
+            }
+
+            @Override
+            public void onComplete() {
+                throw new TestException();
+            }
+        });
+    }
+
+    @Test
+    public void onSuccessThrows2() {
+        Maybe.create(new MaybeOnSubscribe<Object>() {
+            @Override
+            public void subscribe(MaybeEmitter<Object> e) throws Exception {
+                try {
+                    e.onSuccess(1);
+                    fail("Should have thrown");
+                } catch (TestException ex) {
+                    // expected
+                }
+
+                assertTrue(e.isDisposed());
+            }
+        }).subscribe(new MaybeObserver<Object>() {
+
+            @Override
+            public void onSubscribe(Disposable d) {
+
+            }
+
+            @Override
+            public void onSuccess(Object value) {
+                throw new TestException();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+
+            }
+
+            @Override
+            public void onComplete() {
+
+            }
+        });
+    }
+
+    @Test
+    public void onErrorThrows2() {
+        Maybe.create(new MaybeOnSubscribe<Object>() {
+            @Override
+            public void subscribe(MaybeEmitter<Object> e) throws Exception {
+                try {
+                    e.onError(new IOException());
+                    fail("Should have thrown");
+                } catch (TestException ex) {
+                    // expected
+                }
+
+                assertTrue(e.isDisposed());
+            }
+        }).subscribe(new MaybeObserver<Object>() {
+
+            @Override
+            public void onSubscribe(Disposable d) {
+
+            }
+
+            @Override
+            public void onSuccess(Object value) {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                throw new TestException();
+            }
+
+            @Override
+            public void onComplete() {
+
+            }
+        });
+    }
+
+    @Test
+    public void onCompleteThrows2() {
+        Maybe.create(new MaybeOnSubscribe<Object>() {
+            @Override
+            public void subscribe(MaybeEmitter<Object> e) throws Exception {
+                try {
+                    e.onComplete();
+                    fail("Should have thrown");
+                } catch (TestException ex) {
+                    // expected
+                }
+
+                assertTrue(e.isDisposed());
+            }
+        }).subscribe(new MaybeObserver<Object>() {
+
+            @Override
+            public void onSubscribe(Disposable d) {
+
+            }
+
+            @Override
+            public void onSuccess(Object value) {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+
+            }
+
+            @Override
+            public void onComplete() {
+                throw new TestException();
+            }
+        });
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeDetachTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeDetachTest.java
new file mode 100644
index 0000000000..8309f4f3fa
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeDetachTest.java
@@ -0,0 +1,56 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.maybe;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.Function;
+import io.reactivex.processors.PublishProcessor;
+
+public class MaybeDetachTest {
+
+    @Test
+    public void doubleSubscribe() {
+
+        TestHelper.checkDoubleOnSubscribeMaybe(new Function<Maybe<Object>, MaybeSource<Object>>() {
+            @Override
+            public MaybeSource<Object> apply(Maybe<Object> m) throws Exception {
+                return m.onTerminateDetach();
+            }
+        });
+    }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(PublishProcessor.create().singleElement().onTerminateDetach());
+    }
+
+    @Test
+    public void onError() {
+        Maybe.error(new TestException())
+        .onTerminateDetach()
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void onComplete() {
+        Maybe.empty()
+        .onTerminateDetach()
+        .test()
+        .assertResult();
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeFlatMapNotificationTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFlatMapNotificationTest.java
new file mode 100644
index 0000000000..2254135453
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFlatMapNotificationTest.java
@@ -0,0 +1,101 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.maybe;
+
+import java.util.List;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.*;
+import io.reactivex.functions.Function;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.observers.TestObserver;
+
+public class MaybeFlatMapNotificationTest {
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Maybe.just(1)
+                .flatMap(Functions.justFunction(Maybe.just(1)),
+                        Functions.justFunction(Maybe.just(1)), Functions.justCallable(Maybe.just(1))));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeMaybe(new Function<Maybe<Integer>, MaybeSource<Integer>>() {
+            @Override
+            public MaybeSource<Integer> apply(Maybe<Integer> m) throws Exception {
+                return m
+                        .flatMap(Functions.justFunction(Maybe.just(1)),
+                                Functions.justFunction(Maybe.just(1)), Functions.justCallable(Maybe.just(1)));
+            }
+        });
+    }
+
+    @Test
+    public void onSuccessNull() {
+        Maybe.just(1)
+        .flatMap(Functions.justFunction((Maybe<Integer>)null),
+                Functions.justFunction(Maybe.just(1)),
+                Functions.justCallable(Maybe.just(1)))
+        .test()
+        .assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    public void onErrorNull() {
+        TestObserver<Integer> to = Maybe.<Integer>error(new TestException())
+        .flatMap(Functions.justFunction(Maybe.just(1)),
+                Functions.justFunction((Maybe<Integer>)null),
+                Functions.justCallable(Maybe.just(1)))
+        .test()
+        .assertFailure(CompositeException.class);
+
+        List<Throwable> ce = TestHelper.compositeList(to.errors().get(0));
+
+        TestHelper.assertError(ce, 0, TestException.class);
+        TestHelper.assertError(ce, 1, NullPointerException.class);
+    }
+
+    @Test
+    public void onCompleteNull() {
+        Maybe.<Integer>empty()
+        .flatMap(Functions.justFunction(Maybe.just(1)),
+                Functions.justFunction(Maybe.just(1)),
+                Functions.justCallable((Maybe<Integer>)null))
+        .test()
+        .assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    public void onSuccessEmpty() {
+        Maybe.just(1)
+        .flatMap(Functions.justFunction(Maybe.<Integer>empty()),
+                Functions.justFunction(Maybe.just(1)),
+                Functions.justCallable(Maybe.just(1)))
+        .test()
+        .assertResult();
+    }
+
+    @Test
+    public void onSuccessError() {
+        Maybe.just(1)
+        .flatMap(Functions.justFunction(Maybe.<Integer>error(new TestException())),
+                Functions.justFunction((Maybe<Integer>)null),
+                Functions.justCallable(Maybe.just(1)))
+        .test()
+        .assertFailure(TestException.class);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromFutureTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromFutureTest.java
new file mode 100644
index 0000000000..4a7e3fb107
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromFutureTest.java
@@ -0,0 +1,61 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.maybe;
+
+import java.util.concurrent.*;
+
+import org.junit.Test;
+
+import io.reactivex.Maybe;
+import io.reactivex.internal.functions.Functions;
+
+public class MaybeFromFutureTest {
+
+    @Test
+    public void cancelImmediately() {
+        FutureTask<Integer> ft = new FutureTask<Integer>(Functions.justCallable(1));
+
+        Maybe.fromFuture(ft).test(true)
+        .assertEmpty();
+    }
+
+    @Test
+    public void timeout() {
+        FutureTask<Integer> ft = new FutureTask<Integer>(Functions.justCallable(1));
+
+        Maybe.fromFuture(ft, 1, TimeUnit.MILLISECONDS).test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TimeoutException.class);
+    }
+
+    @Test
+    public void timedWait() {
+        FutureTask<Integer> ft = new FutureTask<Integer>(Functions.justCallable(1));
+        ft.run();
+
+        Maybe.fromFuture(ft, 1, TimeUnit.MILLISECONDS).test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertResult(1);
+    }
+
+    @Test
+    public void interrupt() {
+        FutureTask<Integer> ft = new FutureTask<Integer>(Functions.justCallable(1));
+
+        Thread.currentThread().interrupt();
+
+        Maybe.fromFuture(ft, 1, TimeUnit.MILLISECONDS).test()
+        .assertFailure(InterruptedException.class);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisherTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisherTest.java
new file mode 100644
index 0000000000..5cb8b8f2d8
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisherTest.java
@@ -0,0 +1,187 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.maybe;
+
+import static org.junit.Assert.*;
+
+import java.util.List;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.Function;
+import io.reactivex.observers.TestObserver;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.processors.PublishProcessor;
+import io.reactivex.schedulers.Schedulers;
+
+public class MaybeTakeUntilPublisherTest {
+
+    @Test
+    public void disposed() {
+        TestHelper.checkDisposed(PublishProcessor.create().singleElement().takeUntil(Flowable.never()));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeMaybe(new Function<Maybe<Object>, MaybeSource<Object>>() {
+            @Override
+            public MaybeSource<Object> apply(Maybe<Object> m) throws Exception {
+                return m.takeUntil(Flowable.never());
+            }
+        });
+    }
+
+    @Test
+    public void mainErrors() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp1.onError(new TestException());
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void otherErrors() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onError(new TestException());
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void mainCompletes() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp1.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertResult();
+    }
+
+    @Test
+    public void otherCompletes() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertResult();
+    }
+
+    @Test
+    public void onErrorRace() {
+        for (int i = 0; i < 500; i++) {
+            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
+            final PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2).test();
+
+            final TestException ex1 = new TestException();
+            final TestException ex2 = new TestException();
+
+            List<Throwable> errors = TestHelper.trackPluginErrors();
+            try {
+
+                Runnable r1 = new Runnable() {
+                    @Override
+                    public void run() {
+                        pp1.onError(ex1);
+                    }
+                };
+                Runnable r2 = new Runnable() {
+                    @Override
+                    public void run() {
+                        pp2.onError(ex2);
+                    }
+                };
+
+                TestHelper.race(r1, r2, Schedulers.single());
+
+                to.assertFailure(TestException.class);
+
+                if (!errors.isEmpty()) {
+                    TestHelper.assertError(errors, 0, TestException.class);
+                }
+
+            } finally {
+                RxJavaPlugins.reset();
+            }
+
+        }
+    }
+
+    @Test
+    public void onCompleteRace() {
+        for (int i = 0; i < 500; i++) {
+            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
+            final PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2).test();
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    pp1.onComplete();
+                }
+            };
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    pp2.onComplete();
+                }
+            };
+
+            TestHelper.race(r1, r2, Schedulers.single());
+
+            to.assertResult();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilTest.java
index 1151b8ad88..0fc89a40b0 100644
--- a/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilTest.java
+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilTest.java
@@ -13,9 +13,19 @@
 
 package io.reactivex.internal.operators.maybe;
 
+import static org.junit.Assert.*;
+
+import java.util.List;
+
 import org.junit.Test;
 
 import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.Function;
+import io.reactivex.observers.TestObserver;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.processors.PublishProcessor;
+import io.reactivex.schedulers.Schedulers;
 
 public class MaybeTakeUntilTest {
 
@@ -46,4 +56,160 @@ public void untilFirstMaybe() {
         .test()
         .assertResult();
     }
+
+    @Test
+    public void disposed() {
+        TestHelper.checkDisposed(PublishProcessor.create().singleElement().takeUntil(Maybe.never()));
+    }
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.checkDoubleOnSubscribeMaybe(new Function<Maybe<Object>, MaybeSource<Object>>() {
+            @Override
+            public MaybeSource<Object> apply(Maybe<Object> m) throws Exception {
+                return m.takeUntil(Maybe.never());
+            }
+        });
+    }
+
+    @Test
+    public void mainErrors() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2.singleElement()).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp1.onError(new TestException());
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void otherErrors() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2.singleElement()).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onError(new TestException());
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void mainCompletes() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2.singleElement()).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp1.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertResult();
+    }
+
+    @Test
+    public void otherCompletes() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2.singleElement()).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertResult();
+    }
+
+    @Test
+    public void onErrorRace() {
+        for (int i = 0; i < 500; i++) {
+            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
+            final PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2.singleElement()).test();
+
+            final TestException ex1 = new TestException();
+            final TestException ex2 = new TestException();
+
+            List<Throwable> errors = TestHelper.trackPluginErrors();
+            try {
+
+                Runnable r1 = new Runnable() {
+                    @Override
+                    public void run() {
+                        pp1.onError(ex1);
+                    }
+                };
+                Runnable r2 = new Runnable() {
+                    @Override
+                    public void run() {
+                        pp2.onError(ex2);
+                    }
+                };
+
+                TestHelper.race(r1, r2, Schedulers.single());
+
+                to.assertFailure(TestException.class);
+
+                if (!errors.isEmpty()) {
+                    TestHelper.assertError(errors, 0, TestException.class);
+                }
+
+            } finally {
+                RxJavaPlugins.reset();
+            }
+
+        }
+    }
+
+    @Test
+    public void onCompleteRace() {
+        for (int i = 0; i < 500; i++) {
+            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
+            final PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+            TestObserver<Integer> to = pp1.singleElement().takeUntil(pp2.singleElement()).test();
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    pp1.onComplete();
+                }
+            };
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    pp2.onComplete();
+                }
+            };
+
+            TestHelper.race(r1, r2, Schedulers.single());
+
+            to.assertResult();
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeTimeoutPublisherTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTimeoutPublisherTest.java
new file mode 100644
index 0000000000..414ce829fd
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTimeoutPublisherTest.java
@@ -0,0 +1,223 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.maybe;
+
+import static org.junit.Assert.*;
+
+import java.util.concurrent.*;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.observers.TestObserver;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.processors.PublishProcessor;
+import io.reactivex.schedulers.Schedulers;
+
+public class MaybeTimeoutPublisherTest {
+
+    @Test
+    public void mainError() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp1.onError(new TestException());
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void otherError() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onError(new TestException());
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void fallbackError() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2, Maybe.<Integer>error(new TestException())).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onNext(1);
+        pp2.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void fallbackComplete() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2, Maybe.<Integer>empty()).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onNext(1);
+        pp2.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertResult();
+    }
+
+    @Test
+    public void mainComplete() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp1.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertResult();
+    }
+
+    @Test
+    public void otherComplete() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TimeoutException.class);
+    }
+
+    @Test
+    public void dispose() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestHelper.checkDisposed(pp1.singleElement().timeout(pp2));
+    }
+
+    @Test
+    public void dispose2() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestHelper.checkDisposed(pp1.singleElement().timeout(pp2, Maybe.just(1)));
+    }
+
+    @Test
+    public void onErrorRace() {
+        for (int i = 0; i < 500; i++) {
+            TestHelper.trackPluginErrors();
+            try {
+                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
+                final PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+                TestObserver<Integer> to = pp1.singleElement().timeout(pp2).test();
+
+                final TestException ex = new TestException();
+
+                Runnable r1 = new Runnable() {
+                    @Override
+                    public void run() {
+                        pp1.onError(ex);
+                    }
+                };
+                Runnable r2 = new Runnable() {
+                    @Override
+                    public void run() {
+                        pp2.onError(ex);
+                    }
+                };
+
+                TestHelper.race(r1, r2, Schedulers.single());
+
+                to.assertFailure(TestException.class);
+            } finally {
+                RxJavaPlugins.reset();
+            }
+        }
+    }
+
+    @Test
+    public void onCompleteRace() {
+        for (int i = 0; i < 500; i++) {
+            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
+            final PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+            TestObserver<Integer> to = pp1.singleElement().timeout(pp2).test();
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    pp1.onComplete();
+                }
+            };
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    pp2.onComplete();
+                }
+            };
+
+            TestHelper.race(r1, r2, Schedulers.single());
+
+            to.assertSubscribed().assertNoValues();
+
+            if (to.errorCount() != 0) {
+                to.assertError(TimeoutException.class).assertNotComplete();
+            } else {
+                to.assertNoErrors().assertComplete();
+            }
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeTimeoutTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTimeoutTest.java
index f2068aa16b..3ef9af9bd6 100644
--- a/src/test/java/io/reactivex/internal/operators/maybe/MaybeTimeoutTest.java
+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTimeoutTest.java
@@ -13,11 +13,17 @@
 
 package io.reactivex.internal.operators.maybe;
 
+import static org.junit.Assert.*;
+
 import java.util.concurrent.*;
 
 import org.junit.Test;
 
 import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.observers.TestObserver;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
 
 public class MaybeTimeoutTest {
@@ -141,4 +147,197 @@ public void neverFlowable() {
         .awaitDone(5, TimeUnit.SECONDS)
         .assertFailure(TimeoutException.class);
     }
+
+    @Test
+    public void mainError() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2.singleElement()).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp1.onError(new TestException());
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void otherError() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2.singleElement()).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onError(new TestException());
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void fallbackError() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2.singleElement(), Maybe.<Integer>error(new TestException())).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onNext(1);
+        pp2.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void fallbackComplete() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2.singleElement(), Maybe.<Integer>empty()).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onNext(1);
+        pp2.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertResult();
+    }
+
+    @Test
+    public void mainComplete() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2.singleElement()).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp1.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertResult();
+    }
+
+    @Test
+    public void otherComplete() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestObserver<Integer> to = pp1.singleElement().timeout(pp2.singleElement()).test();
+
+        assertTrue(pp1.hasSubscribers());
+        assertTrue(pp2.hasSubscribers());
+
+        pp2.onComplete();
+
+        assertFalse(pp1.hasSubscribers());
+        assertFalse(pp2.hasSubscribers());
+
+        to.assertFailure(TimeoutException.class);
+    }
+
+    @Test
+    public void dispose() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestHelper.checkDisposed(pp1.singleElement().timeout(pp2.singleElement()));
+    }
+
+    @Test
+    public void dispose2() {
+        PublishProcessor<Integer> pp1 = PublishProcessor.create();
+        PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+        TestHelper.checkDisposed(pp1.singleElement().timeout(pp2.singleElement(), Maybe.just(1)));
+    }
+
+    @Test
+    public void onErrorRace() {
+        for (int i = 0; i < 500; i++) {
+            TestHelper.trackPluginErrors();
+            try {
+                final PublishProcessor<Integer> pp1 = PublishProcessor.create();
+                final PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+                TestObserver<Integer> to = pp1.singleElement().timeout(pp2.singleElement()).test();
+
+                final TestException ex = new TestException();
+
+                Runnable r1 = new Runnable() {
+                    @Override
+                    public void run() {
+                        pp1.onError(ex);
+                    }
+                };
+                Runnable r2 = new Runnable() {
+                    @Override
+                    public void run() {
+                        pp2.onError(ex);
+                    }
+                };
+
+                TestHelper.race(r1, r2, Schedulers.single());
+
+                to.assertFailure(TestException.class);
+            } finally {
+                RxJavaPlugins.reset();
+            }
+        }
+    }
+
+    @Test
+    public void onCompleteRace() {
+        for (int i = 0; i < 500; i++) {
+            final PublishProcessor<Integer> pp1 = PublishProcessor.create();
+            final PublishProcessor<Integer> pp2 = PublishProcessor.create();
+
+            TestObserver<Integer> to = pp1.singleElement().timeout(pp2.singleElement()).test();
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    pp1.onComplete();
+                }
+            };
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    pp2.onComplete();
+                }
+            };
+
+            TestHelper.race(r1, r2, Schedulers.single());
+
+            to.assertSubscribed().assertNoValues();
+
+            if (to.errorCount() != 0) {
+                to.assertError(TimeoutException.class).assertNotComplete();
+            } else {
+                to.assertNoErrors().assertComplete();
+            }
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/maybe/MaybeToCompletableTest.java b/src/test/java/io/reactivex/internal/operators/maybe/MaybeToCompletableTest.java
new file mode 100644
index 0000000000..0933e37eb9
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeToCompletableTest.java
@@ -0,0 +1,55 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.maybe;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.functions.Function;
+import io.reactivex.internal.fuseable.HasUpstreamMaybeSource;
+
+public class MaybeToCompletableTest {
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void source() {
+        Maybe<Integer> source = Maybe.just(1);
+
+        assertSame(source, ((HasUpstreamMaybeSource<Integer>)source.toCompletable()).source());
+    }
+
+    @Test
+    public void dispose() {
+        TestHelper.checkDisposed(Maybe.never().toCompletable());
+    }
+
+    @Test
+    public void successToComplete() {
+        Maybe.just(1)
+        .toCompletable()
+        .test()
+        .assertResult();
+    }
+
+    @Test
+    public void doubleSubscribe() {
+        TestHelper.checkDoubleOnSubscribeMaybeToCompletable(new Function<Maybe<Object>, CompletableSource>() {
+            @Override
+            public CompletableSource apply(Maybe<Object> m) throws Exception {
+                return m.toCompletable();
+            }
+        });
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableBlockingTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableBlockingTest.java
index f15dad5184..9f8d6e87e6 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableBlockingTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableBlockingTest.java
@@ -215,4 +215,8 @@ public void blockingLastNormal() {
         assertEquals(2, Observable.just(1, 2).blockingLast(3).intValue());
     }
 
+    @Test(expected = NoSuchElementException.class)
+    public void blockingSingleEmpty() {
+        Observable.empty().blockingSingle();
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java
index 43468ea060..30e9f84089 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java
@@ -13,7 +13,8 @@
 
 package io.reactivex.internal.operators.observable;
 
-import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.*;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
 import java.util.*;
@@ -28,8 +29,9 @@
 import io.reactivex.disposables.Disposables;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.observers.*;
-import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.schedulers.*;
 import io.reactivex.subjects.PublishSubject;
 
 public class ObservableBufferTest {
@@ -838,4 +840,368 @@ public void bufferSkipIntoCustomCollection() {
         .assertResult(set(1, 2), set(2, 3), set(4));
     }
 
+    @Test
+    @SuppressWarnings("unchecked")
+    public void supplierThrows() {
+        Observable.just(1)
+        .buffer(1, TimeUnit.SECONDS, Integer.MAX_VALUE, Schedulers.single(), new Callable<Collection<Integer>>() {
+            @Override
+            public Collection<Integer> call() throws Exception {
+                throw new TestException();
+            }
+        }, false)
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void supplierThrows2() {
+        Observable.just(1)
+        .buffer(1, TimeUnit.SECONDS, 10, Schedulers.single(), new Callable<Collection<Integer>>() {
+            @Override
+            public Collection<Integer> call() throws Exception {
+                throw new TestException();
+            }
+        }, false)
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void supplierThrows3() {
+        Observable.just(1)
+        .buffer(2, 1, TimeUnit.SECONDS, Schedulers.single(), new Callable<Collection<Integer>>() {
+            @Override
+            public Collection<Integer> call() throws Exception {
+                throw new TestException();
+            }
+        })
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void supplierThrows4() {
+        Observable.<Integer>never()
+        .buffer(1, TimeUnit.MILLISECONDS, Integer.MAX_VALUE, Schedulers.single(), new Callable<Collection<Integer>>() {
+            int count;
+            @Override
+            public Collection<Integer> call() throws Exception {
+                if (count++ == 1) {
+                    throw new TestException();
+                } else {
+                    return new ArrayList<Integer>();
+                }
+            }
+        }, false)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void supplierThrows5() {
+        Observable.<Integer>never()
+        .buffer(1, TimeUnit.MILLISECONDS, 10, Schedulers.single(), new Callable<Collection<Integer>>() {
+            int count;
+            @Override
+            public Collection<Integer> call() throws Exception {
+                if (count++ == 1) {
+                    throw new TestException();
+                } else {
+                    return new ArrayList<Integer>();
+                }
+            }
+        }, false)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void supplierThrows6() {
+        Observable.<Integer>never()
+        .buffer(2, 1, TimeUnit.MILLISECONDS, Schedulers.single(), new Callable<Collection<Integer>>() {
+            int count;
+            @Override
+            public Collection<Integer> call() throws Exception {
+                if (count++ == 1) {
+                    throw new TestException();
+                } else {
+                    return new ArrayList<Integer>();
+                }
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void supplierReturnsNull() {
+        Observable.<Integer>never()
+        .buffer(1, TimeUnit.MILLISECONDS, Integer.MAX_VALUE, Schedulers.single(), new Callable<Collection<Integer>>() {
+            int count;
+            @Override
+            public Collection<Integer> call() throws Exception {
+                if (count++ == 1) {
+                    return null;
+                } else {
+                    return new ArrayList<Integer>();
+                }
+            }
+        }, false)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void supplierReturnsNull2() {
+        Observable.<Integer>never()
+        .buffer(1, TimeUnit.MILLISECONDS, 10, Schedulers.single(), new Callable<Collection<Integer>>() {
+            int count;
+            @Override
+            public Collection<Integer> call() throws Exception {
+                if (count++ == 1) {
+                    return null;
+                } else {
+                    return new ArrayList<Integer>();
+                }
+            }
+        }, false)
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void supplierReturnsNull3() {
+        Observable.<Integer>never()
+        .buffer(2, 1, TimeUnit.MILLISECONDS, Schedulers.single(), new Callable<Collection<Integer>>() {
+            int count;
+            @Override
+            public Collection<Integer> call() throws Exception {
+                if (count++ == 1) {
+                    return null;
+                } else {
+                    return new ArrayList<Integer>();
+                }
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBufferSupplierThrows() {
+        Observable.never()
+        .buffer(Functions.justCallable(Observable.never()), new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                throw new TestException();
+            }
+        })
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBoundarySupplierThrows() {
+        Observable.never()
+        .buffer(new Callable<ObservableSource<Object>>() {
+            @Override
+            public ObservableSource<Object> call() throws Exception {
+                throw new TestException();
+            }
+        }, new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBufferSupplierThrows2() {
+        Observable.never()
+        .buffer(Functions.justCallable(Observable.timer(1, TimeUnit.MILLISECONDS)), new Callable<Collection<Object>>() {
+            int count;
+            @Override
+            public Collection<Object> call() throws Exception {
+                if (count++ == 1) {
+                    throw new TestException();
+                } else {
+                    return new ArrayList<Object>();
+                }
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBufferSupplierReturnsNull() {
+        Observable.never()
+        .buffer(Functions.justCallable(Observable.timer(1, TimeUnit.MILLISECONDS)), new Callable<Collection<Object>>() {
+            int count;
+            @Override
+            public Collection<Object> call() throws Exception {
+                if (count++ == 1) {
+                    return null;
+                } else {
+                    return new ArrayList<Object>();
+                }
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBoundarySupplierThrows2() {
+        Observable.never()
+        .buffer(new Callable<ObservableSource<Long>>() {
+            int count;
+            @Override
+            public ObservableSource<Long> call() throws Exception {
+                if (count++ == 1) {
+                    throw new TestException();
+                }
+                return Observable.timer(1, TimeUnit.MILLISECONDS);
+            }
+        }, new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void boundaryCancel() {
+        PublishSubject<Object> pp = PublishSubject.create();
+
+        TestObserver<Collection<Object>> ts = pp
+        .buffer(Functions.justCallable(Observable.never()), new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test();
+
+        assertTrue(pp.hasObservers());
+
+        ts.dispose();
+
+        assertFalse(pp.hasObservers());
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBoundarySupplierReturnsNull() {
+        Observable.never()
+        .buffer(new Callable<ObservableSource<Long>>() {
+            int count;
+            @Override
+            public ObservableSource<Long> call() throws Exception {
+                if (count++ == 1) {
+                    return null;
+                }
+                return Observable.timer(1, TimeUnit.MILLISECONDS);
+            }
+        }, new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void boundaryBoundarySupplierReturnsNull2() {
+        Observable.never()
+        .buffer(new Callable<ObservableSource<Long>>() {
+            int count;
+            @Override
+            public ObservableSource<Long> call() throws Exception {
+                if (count++ == 1) {
+                    return null;
+                }
+                return Observable.empty();
+            }
+        }, new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test()
+        .awaitDone(5, TimeUnit.SECONDS)
+        .assertFailure(NullPointerException.class);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void boundaryMainError() {
+        PublishSubject<Object> pp = PublishSubject.create();
+
+        TestObserver<Collection<Object>> ts = pp
+        .buffer(Functions.justCallable(Observable.never()), new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test();
+
+        pp.onError(new TestException());
+
+        ts.assertFailure(TestException.class);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void boundaryBoundaryError() {
+        PublishSubject<Object> pp = PublishSubject.create();
+
+        TestObserver<Collection<Object>> ts = pp
+        .buffer(Functions.justCallable(Observable.error(new TestException())), new Callable<Collection<Object>>() {
+            @Override
+            public Collection<Object> call() throws Exception {
+                return new ArrayList<Object>();
+            }
+        })
+        .test();
+
+        pp.onError(new TestException());
+
+        ts.assertFailure(TestException.class);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableIgnoreElementsTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableIgnoreElementsTest.java
index b1bcdef76d..97a02fa96c 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableIgnoreElementsTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableIgnoreElementsTest.java
@@ -19,10 +19,11 @@
 
 import org.junit.Test;
 
-import io.reactivex.Observable;
+import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.observers.TestObserver;
+import io.reactivex.subjects.PublishSubject;
 
 public class ObservableIgnoreElementsTest {
 
@@ -152,4 +153,20 @@ public void run() {
             .subscribe();
         assertTrue(unsub.get());
     }
+
+    @Test
+    public void cancel() {
+
+        PublishSubject<Integer> pp = PublishSubject.create();
+
+        TestObserver<Integer> ts = pp.ignoreElements().<Integer>toObservable().test();
+
+        assertTrue(pp.hasObservers());
+
+        ts.cancel();
+
+        assertFalse(pp.hasObservers());
+
+        TestHelper.checkDisposed(pp.ignoreElements().<Integer>toObservable());
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
index 2f72eff7a6..92c1c1b1d9 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableWindowWithTimeTest.java
@@ -25,6 +25,7 @@
 import io.reactivex.Observable;
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposables;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.observers.*;
@@ -362,4 +363,49 @@ public void timeskipOverlapping() {
 
         ts.assertResult(1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7);
     }
+
+    @Test
+    public void exactOnError() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishSubject<Integer> pp = PublishSubject.create();
+
+        TestObserver<Integer> ts = pp.window(1, 1, TimeUnit.SECONDS, scheduler)
+        .flatMap(Functions.<Observable<Integer>>identity())
+        .test();
+
+        pp.onError(new TestException());
+
+        ts.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void overlappingOnError() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishSubject<Integer> pp = PublishSubject.create();
+
+        TestObserver<Integer> ts = pp.window(2, 1, TimeUnit.SECONDS, scheduler)
+        .flatMap(Functions.<Observable<Integer>>identity())
+        .test();
+
+        pp.onError(new TestException());
+
+        ts.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void skipOnError() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishSubject<Integer> pp = PublishSubject.create();
+
+        TestObserver<Integer> ts = pp.window(1, 2, TimeUnit.SECONDS, scheduler)
+        .flatMap(Functions.<Observable<Integer>>identity())
+        .test();
+
+        pp.onError(new TestException());
+
+        ts.assertFailure(TestException.class);
+    }
 }
diff --git a/src/test/java/io/reactivex/maybe/MaybeTest.java b/src/test/java/io/reactivex/maybe/MaybeTest.java
index 20934b941b..1151391105 100644
--- a/src/test/java/io/reactivex/maybe/MaybeTest.java
+++ b/src/test/java/io/reactivex/maybe/MaybeTest.java
@@ -478,6 +478,16 @@ public boolean test(Integer v) throws Exception {
         }).test().assertResult();
     }
 
+    @Test
+    public void filterEmpty() {
+        Maybe.<Integer>empty().filter(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) throws Exception {
+                return v == 1;
+            }
+        }).test().assertResult();
+    }
+
     @Test(expected = NullPointerException.class)
     public void singleFilterNull() {
         Single.just(1).filter(null);
@@ -567,6 +577,21 @@ public void observeOnComplete() {
         ;
     }
 
+    @Test
+    public void observeOnDispose2() {
+        TestHelper.checkDisposed(Maybe.empty().observeOn(Schedulers.single()));
+    }
+
+    @Test
+    public void observeOnDoubleSubscribe() {
+        TestHelper.checkDoubleOnSubscribeMaybe(new Function<Maybe<Object>, MaybeSource<Object>>() {
+            @Override
+            public MaybeSource<Object> apply(Maybe<Object> m) throws Exception {
+                return m.observeOn(Schedulers.single());
+            }
+        });
+    }
+
     @Test
     public void subscribeOnSuccess() {
         String main = Thread.currentThread().getName();
@@ -1138,6 +1163,32 @@ public void ignoreElementComplete() {
         .test()
         .assertResult();
     }
+    @Test
+    public void ignoreElementSuccessMaybe() {
+        Maybe.just(1)
+        .ignoreElement()
+        .toMaybe()
+        .test()
+        .assertResult();
+    }
+
+    @Test
+    public void ignoreElementErrorMaybe() {
+        Maybe.error(new TestException())
+        .ignoreElement()
+        .toMaybe()
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void ignoreElementCompleteMaybe() {
+        Maybe.empty()
+        .ignoreElement()
+        .toMaybe()
+        .test()
+        .assertResult();
+    }
 
     @Test
     public void singleToMaybe() {
