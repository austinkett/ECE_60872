diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java
index 837622d84d..bcc07606f4 100644
--- a/src/main/java/io/reactivex/Flowable.java
+++ b/src/main/java/io/reactivex/Flowable.java
@@ -28,6 +28,7 @@
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.operators.flowable.*;
 import io.reactivex.internal.operators.flowable.FlowableConcatMap.ErrorMode;
+import io.reactivex.internal.schedulers.ImmediateThinScheduler;
 import io.reactivex.internal.subscribers.flowable.*;
 import io.reactivex.internal.subscriptions.EmptySubscription;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -941,14 +942,14 @@ public S apply(S s, Subscriber<T> o) {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> mergeDelayError(boolean delayErrors, Iterable<? extends Publisher<? extends T>> sources) {
+    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {
         return fromIterable(sources).flatMap((Function)Functions.identity(), true);
     }
 
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> mergeDelayError(int maxConcurrency, int bufferSize, Iterable<? extends Publisher<? extends T>> sources) {
+    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {
         return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);
     }
 
@@ -962,7 +963,7 @@ public S apply(S s, Subscriber<T> o) {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> mergeDelayError(int maxConcurrency, Iterable<? extends Publisher<? extends T>> sources) {
+    public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {
         return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);
     }
 
@@ -2130,7 +2131,7 @@ public void accept(Throwable e) {
         Objects.requireNonNull(onErrorMapper, "onErrorMapper is null");
         Objects.requireNonNull(onCompleteSupplier, "onCompleteSupplier is null");
         // FIXME run flatMap directly
-        return merge(new FlowableMapNotification<T, R>(this, onNextMapper, onErrorMapper, onCompleteSupplier));
+        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));
     }
 
     @BackpressureSupport(BackpressureKind.FULL)
@@ -2144,7 +2145,7 @@ public void accept(Throwable e) {
         Objects.requireNonNull(onErrorMapper, "onErrorMapper is null");
         Objects.requireNonNull(onCompleteSupplier, "onCompleteSupplier is null");
         // FIXME run flatMap directly
-        return merge(new FlowableMapNotification<T, R>(this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);
+        return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);
     }
 
     @BackpressureSupport(BackpressureKind.FULL)
@@ -2584,6 +2585,12 @@ public T apply(Throwable e) {
         return FlowablePublish.create(this, bufferSize);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerSupport.NONE)
+    public final Flowable<T> rebatchRequests(int bufferSize) {
+        return observeOn(ImmediateThinScheduler.INSTANCE, true, bufferSize);
+    }
+    
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Flowable<T> reduce(BiFunction<T, T, T> reducer) {
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
index 45590847e2..d3214547f0 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java
@@ -226,7 +226,8 @@ void removeInner(InnerSubscriber<T, U> inner) {
         void tryEmitScalar(U value) {
             if (get() == 0 && compareAndSet(0, 1)) {
                 long r = requested.get();
-                if (r != 0L) {
+                Queue<U> q = queue;
+                if (r != 0L && (q == null || q.isEmpty())) {
                     actual.onNext(value);
                     if (r != Long.MAX_VALUE) {
                         requested.decrementAndGet();
@@ -237,7 +238,9 @@ void tryEmitScalar(U value) {
                         s.request(scalarLimit);
                     }
                 } else {
-                    Queue<U> q = getMainQueue();
+                    if (q == null) {
+                        q = getMainQueue();
+                    }
                     if (!q.offer(value)) {
                         onError(new IllegalStateException("Scalar queue full?!"));
                         return;
@@ -271,14 +274,17 @@ void tryEmitScalar(U value) {
         void tryEmit(U value, InnerSubscriber<T, U> inner) {
             if (get() == 0 && compareAndSet(0, 1)) {
                 long r = requested.get();
-                if (r != 0L) {
+                Queue<U> q = inner.queue;
+                if (r != 0L && (q == null || q.isEmpty())) {
                     actual.onNext(value);
                     if (r != Long.MAX_VALUE) {
                         requested.decrementAndGet();
                     }
                     inner.requestMore(1);
                 } else {
-                    Queue<U> q = getInnerQueue(inner);
+                    if (q == null) {
+                        q = getInnerQueue(inner);
+                    }
                     if (!q.offer(value)) {
                         onError(new MissingBackpressureException("Inner queue full?!"));
                         return;
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableMapNotification.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableMapNotification.java
index 2aa20cbaca..806dcdf1f8 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableMapNotification.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableMapNotification.java
@@ -22,19 +22,19 @@
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
-public final class FlowableMapNotification<T, R> extends Flowable<Publisher<? extends R>>{
+public final class FlowableMapNotification<T, R> extends Flowable<R> {
 
     final Publisher<T> source;
     
-    final Function<? super T, ? extends Publisher<? extends R>> onNextMapper;
-    final Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper;
-    final Supplier<? extends Publisher<? extends R>> onCompleteSupplier;
+    final Function<? super T, ? extends R> onNextMapper;
+    final Function<? super Throwable, ? extends R> onErrorMapper;
+    final Supplier<? extends R> onCompleteSupplier;
 
     public FlowableMapNotification(
             Publisher<T> source,
-            Function<? super T, ? extends Publisher<? extends R>> onNextMapper, 
-            Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper, 
-            Supplier<? extends Publisher<? extends R>> onCompleteSupplier) {
+            Function<? super T, ? extends R> onNextMapper, 
+            Function<? super Throwable, ? extends R> onErrorMapper, 
+            Supplier<? extends R> onCompleteSupplier) {
         this.source = source;
         this.onNextMapper = onNextMapper;
         this.onErrorMapper = onErrorMapper;
@@ -42,7 +42,7 @@ public FlowableMapNotification(
     }
     
     @Override
-    protected void subscribeActual(Subscriber<? super Publisher<? extends R>> s) {
+    protected void subscribeActual(Subscriber<? super R> s) {
         source.subscribe(new MapNotificationSubscriber<T, R>(s, onNextMapper, onErrorMapper, onCompleteSupplier));
     }
     
@@ -53,14 +53,14 @@ protected void subscribeActual(Subscriber<? super Publisher<? extends R>> s) {
         /** */
         private static final long serialVersionUID = 2757120512858778108L;
         
-        final Subscriber<? super Publisher<? extends R>> actual;
-        final Function<? super T, ? extends Publisher<? extends R>> onNextMapper;
-        final Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper;
-        final Supplier<? extends Publisher<? extends R>> onCompleteSupplier;
+        final Subscriber<? super R> actual;
+        final Function<? super T, ? extends R> onNextMapper;
+        final Function<? super Throwable, ? extends R> onErrorMapper;
+        final Supplier<? extends R> onCompleteSupplier;
         
         Subscription s;
         
-        Publisher<? extends R> value;
+        R value;
         
         volatile boolean done;
 
@@ -71,10 +71,10 @@ protected void subscribeActual(Subscriber<? super Publisher<? extends R>> s) {
         static final int HAS_REQUEST_NO_VALUE = 2;
         static final int HAS_REQUEST_HAS_VALUE = 3;
 
-        public MapNotificationSubscriber(Subscriber<? super Publisher<? extends R>> actual,
-                Function<? super T, ? extends Publisher<? extends R>> onNextMapper,
-                Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper,
-                Supplier<? extends Publisher<? extends R>> onCompleteSupplier) {
+        public MapNotificationSubscriber(Subscriber<? super R> actual,
+                Function<? super T, ? extends R> onNextMapper,
+                Function<? super Throwable, ? extends R> onErrorMapper,
+                Supplier<? extends R> onCompleteSupplier) {
             this.actual = actual;
             this.onNextMapper = onNextMapper;
             this.onErrorMapper = onErrorMapper;
@@ -91,7 +91,7 @@ public void onSubscribe(Subscription s) {
         
         @Override
         public void onNext(T t) {
-            Publisher<? extends R> p;
+            R p;
             
             try {
                 p = onNextMapper.apply(t);
@@ -115,7 +115,7 @@ public void onNext(T t) {
         
         @Override
         public void onError(Throwable t) {
-            Publisher<? extends R> p;
+            R p;
             
             try {
                 p = onErrorMapper.apply(t);
@@ -134,7 +134,7 @@ public void onError(Throwable t) {
         
         @Override
         public void onComplete() {
-            Publisher<? extends R> p;
+            R p;
             
             try {
                 p = onCompleteSupplier.get();
@@ -152,7 +152,7 @@ public void onComplete() {
         }
         
         
-        void tryEmit(Publisher<? extends R> p) {
+        void tryEmit(R p) {
             long r = get();
             if (r != 0L) {
                 actual.onNext(p);
@@ -197,7 +197,7 @@ public void request(long n) {
                     } else
                     if (s == NO_REQUEST_HAS_VALUE) {
                         if (state.compareAndSet(NO_REQUEST_HAS_VALUE, HAS_REQUEST_HAS_VALUE)) {
-                            Publisher<? extends R> p = value;
+                            R p = value;
                             value = null;
                             actual.onNext(p);
                             actual.onComplete();
diff --git a/src/main/java/io/reactivex/internal/schedulers/ImmediateThinScheduler.java b/src/main/java/io/reactivex/internal/schedulers/ImmediateThinScheduler.java
new file mode 100644
index 0000000000..81328aa0d3
--- /dev/null
+++ b/src/main/java/io/reactivex/internal/schedulers/ImmediateThinScheduler.java
@@ -0,0 +1,97 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.schedulers;
+
+import java.util.concurrent.TimeUnit;
+
+import io.reactivex.Scheduler;
+import io.reactivex.disposables.*;
+
+/**
+ * A Scheduler partially implementing the API by allowing only non-delayed, non-periodic
+ * task execution on the current thread immediately.
+ * <p>
+ * Note that this doesn't support recursive scheduling and disposing the returned Disposable
+ * has no effect (because when the schedule() method returns, the task has been already run).
+ */
+public final class ImmediateThinScheduler extends Scheduler {
+    
+    /**
+     * The singleton instance of the immediate (thin) scheduler.
+     */
+    public static final Scheduler INSTANCE = new ImmediateThinScheduler();
+
+    static final Worker WORKER = new ImmediateThinWorker();
+    
+    static final Disposable DISPOSED;
+    
+    static {
+        DISPOSED = Disposables.empty();
+        DISPOSED.dispose();
+    }
+    
+    private ImmediateThinScheduler() {
+        // singleton class
+    }
+    
+    @Override
+    public Disposable scheduleDirect(Runnable run) {
+        run.run();
+        return DISPOSED;
+    }
+    
+    @Override
+    public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
+        throw new UnsupportedOperationException("This scheduler doesn't support delayed execution");
+    }
+    
+    @Override
+    public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, long period, TimeUnit unit) {
+        throw new UnsupportedOperationException("This scheduler doesn't support periodic execution");
+    }
+    
+    @Override
+    public Worker createWorker() {
+        return WORKER;
+    }
+    
+    static final class ImmediateThinWorker extends Worker {
+
+        @Override
+        public void dispose() {
+            // This worker is always stateless and won't track tasks
+        }
+
+        @Override
+        public boolean isDisposed() {
+            return false; // dispose() has no effect
+        }
+
+        @Override
+        public Disposable schedule(Runnable run) {
+            run.run();
+            return DISPOSED;
+        }
+        
+        @Override
+        public Disposable schedule(Runnable run, long delay, TimeUnit unit) {
+            throw new UnsupportedOperationException("This scheduler doesn't support delayed execution");
+        }
+        
+        @Override
+        public Disposable schedulePeriodically(Runnable run, long initialDelay, long period, TimeUnit unit) {
+            throw new UnsupportedOperationException("This scheduler doesn't support periodic execution");
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/flowable/FlowableNullTests.java b/src/test/java/io/reactivex/flowable/FlowableNullTests.java
index e81c7d2231..d62d7ca2bc 100644
--- a/src/test/java/io/reactivex/flowable/FlowableNullTests.java
+++ b/src/test/java/io/reactivex/flowable/FlowableNullTests.java
@@ -528,23 +528,23 @@ public void mergeArrayOneIsNull() {
 
     @Test(expected = NullPointerException.class)
     public void mergeDelayErrorIterableNull() {
-        Flowable.mergeDelayError(128, 128, (Iterable<Publisher<Object>>)null);
+        Flowable.mergeDelayError((Iterable<Publisher<Object>>)null, 128, 128);
     }
     
     @Test(expected = NullPointerException.class)
     public void mergeDelayErrorIterableIteratorNull() {
-        Flowable.mergeDelayError(128, 128, new Iterable<Publisher<Object>>() {
+        Flowable.mergeDelayError(new Iterable<Publisher<Object>>() {
             @Override
             public Iterator<Publisher<Object>> iterator() {
                 return null;
             }
-        }).toBlocking().lastOption();
+        }, 128, 128).toBlocking().lastOption();
     }
     
     @SuppressWarnings("unchecked")
     @Test(expected = NullPointerException.class)
     public void mergeDelayErrorIterableOneIsNull() {
-        Flowable.mergeDelayError(128, 128, Arrays.asList(just1, null)).toBlocking().lastOption();
+        Flowable.mergeDelayError(Arrays.asList(just1, null), 128, 128).toBlocking().lastOption();
     }
     
     @Test(expected = NullPointerException.class)
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java
index 291555b89d..a26f421d4d 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java
@@ -27,6 +27,7 @@
 import io.reactivex.*;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 
@@ -649,4 +650,32 @@ public void rangeEmptyMixtureMaxConcurrent() {
             j += 2;
         }
     }
+    
+    @Test
+    public void castCrashUnsubscribes() {
+        
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        ps.flatMap(new Function<Integer, Publisher<Integer>>() {
+            @Override
+            public Publisher<Integer> apply(Integer t) {
+                throw new TestException();
+            }
+        }, new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1, Integer t2) {
+                return t1;
+            }
+        }).unsafeSubscribe(ts);
+        
+        Assert.assertTrue("Not subscribed?", ps.hasSubscribers());
+        
+        ps.onNext(1);
+        
+        Assert.assertFalse("Subscribed?", ps.hasSubscribers());
+        
+        ts.assertError(TestException.class);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapNotificationTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapNotificationTest.java
index 4b43c21aee..5aa2095830 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapNotificationTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapNotificationTest.java
@@ -17,6 +17,7 @@
 
 import io.reactivex.Flowable;
 import io.reactivex.functions.*;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableMapNotificationTest {
@@ -49,4 +50,94 @@ public void testJust() {
         ts.assertNotComplete();
         ts.assertValue(2);
     }
+    
+    @Test
+    public void backpressure() {
+        TestSubscriber<Object> ts = TestSubscriber.create(0L);
+
+        new FlowableMapNotification<Integer, Integer>(Flowable.range(1, 3),
+                new Function<Integer, Integer>() {
+                    @Override
+                    public Integer apply(Integer item) {
+                        return item + 1;
+                    }
+                },
+                new Function<Throwable, Integer>() {
+                    @Override
+                    public Integer apply(Throwable e) {
+                        return 0;
+                    }
+                },
+                new Supplier<Integer>() {
+                    @Override
+                    public Integer get() {
+                        return 5;
+                    }
+                }
+        ).subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertNotComplete();
+        
+        ts.request(3);
+        
+        ts.assertValues(2, 3, 4);
+        ts.assertNoErrors();
+        ts.assertNotComplete();
+
+        ts.request(1);
+        
+        ts.assertValues(2, 3, 4, 5);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+
+    @Test
+    public void noBackpressure() {
+        TestSubscriber<Object> ts = TestSubscriber.create(0L);
+
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+        
+        new FlowableMapNotification<Integer, Integer>(ps, 
+                new Function<Integer, Integer>() {
+                    @Override
+                    public Integer apply(Integer item) {
+                        return item + 1;
+                    }
+                },
+                new Function<Throwable, Integer>() {
+                    @Override
+                    public Integer apply(Throwable e) {
+                        return 0;
+                    }
+                },
+                new Supplier<Integer>() {
+                    @Override
+                    public Integer get() {
+                        return 5;
+                    }
+                }
+        ).subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertNotComplete();
+        
+        ps.onNext(1);
+        ps.onNext(2);
+        ps.onNext(3);
+        ps.onComplete();
+        
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertNotComplete();
+        
+        ts.request(1);
+        
+        ts.assertValue(0);
+        ts.assertNoErrors();
+        ts.assertComplete();
+        
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapTest.java
index 5799816c1b..8e25cf3a08 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapTest.java
@@ -22,8 +22,11 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subscribers.TestSubscriber;
 
 public class FlowableMapTest {
 
@@ -306,9 +309,9 @@ public Integer apply(Integer i) {
         return m;
     }
 
-    // FIXME RS subscribers can't throw
-//    @Test(expected = OnErrorNotImplementedException.class)
-//    public void testShouldNotSwallowOnErrorNotImplementedException() {
+    @Test//(expected = OnErrorNotImplementedException.class)
+    @Ignore("RS subscribers can't throw")
+    public void testShouldNotSwallowOnErrorNotImplementedException() {
 //        Observable.just("a", "b").flatMap(new Function<String, Observable<String>>() {
 //            @Override
 //            public Observable<String> apply(String s) {
@@ -325,5 +328,80 @@ public Integer apply(Integer i) {
 //                System.out.println(s);
 //            }
 //        });
-//    }
+    }
+    
+    @Test//(expected = OnErrorNotImplementedException.class)
+    @Ignore("RS subscribers can't throw")
+    public void verifyExceptionIsThrownIfThereIsNoExceptionHandler() {
+//
+//        Observable.OnSubscribe<Object> creator = new Observable.OnSubscribe<Object>() {
+//
+//            @Override
+//            public void call(Subscriber<? super Object> observer) {
+//                observer.onNext("a");
+//                observer.onNext("b");
+//                observer.onNext("c");
+//                observer.onCompleted();
+//            }
+//        };
+//
+//        Func1<Object, Observable<Object>> manyMapper = new Func1<Object, Observable<Object>>() {
+//
+//            @Override
+//            public Observable<Object> call(Object object) {
+//                return Observable.just(object);
+//            }
+//        };
+//
+//        Func1<Object, Object> mapper = new Func1<Object, Object>() {
+//            private int count = 0;
+//
+//            @Override
+//            public Object call(Object object) {
+//                ++count;
+//                if (count > 2) {
+//                    throw new RuntimeException();
+//                }
+//                return object;
+//            }
+//        };
+//
+//        Action1<Object> onNext = new Action1<Object>() {
+//
+//            @Override
+//            public void call(Object object) {
+//                System.out.println(object.toString());
+//            }
+//        };
+//
+//        try {
+//            Observable.create(creator).flatMap(manyMapper).map(mapper).subscribe(onNext);
+//        } catch (RuntimeException e) {
+//            e.printStackTrace();
+//            throw e;
+//        }
+    }
+
+    @Test
+    public void functionCrashUnsubscribes() {
+        
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+        
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        ps.map(new Function<Integer, Integer>() {
+            @Override
+            public Integer apply(Integer v) { 
+                throw new TestException(); 
+            }
+        }).unsafeSubscribe(ts);
+        
+        Assert.assertTrue("Not subscribed?", ps.hasSubscribers());
+        
+        ps.onNext(1);
+        
+        Assert.assertFalse("Subscribed?", ps.hasSubscribers());
+        
+        ts.assertError(TestException.class);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java
index 0203ccd9f6..54b59d76a5 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeDelayErrorTest.java
@@ -17,6 +17,7 @@
 import static org.mockito.Matchers.*;
 import static org.mockito.Mockito.*;
 
+import java.lang.reflect.Method;
 import java.util.*;
 import java.util.concurrent.*;
 
@@ -28,6 +29,7 @@
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.LongConsumer;
 import io.reactivex.internal.subscriptions.*;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.subscribers.DefaultObserver;
 import io.reactivex.subscribers.TestSubscriber;
 
@@ -42,8 +44,8 @@ public void before() {
 
     @Test
     public void testErrorDelayed1() {
-        final Flowable<String> o1 = Flowable.create(new TestErrorObservable("four", null, "six")); // we expect to lose "six" from the source (and it should never be sent by the source since onError was called
-        final Flowable<String> o2 = Flowable.create(new TestErrorObservable("one", "two", "three"));
+        final Flowable<String> o1 = Flowable.create(new TestErrorFlowable("four", null, "six")); // we expect to lose "six" from the source (and it should never be sent by the source since onError was called
+        final Flowable<String> o2 = Flowable.create(new TestErrorFlowable("one", "two", "three"));
 
         Flowable<String> m = Flowable.mergeDelayError(o1, o2);
         m.subscribe(stringObserver);
@@ -55,18 +57,18 @@ public void testErrorDelayed1() {
         verify(stringObserver, times(1)).onNext("three");
         verify(stringObserver, times(1)).onNext("four");
         verify(stringObserver, times(0)).onNext("five");
-        // despite not expecting it ... we don't do anything to prevent it if the source Observable keeps sending after onError
-        // inner observable errors are considered terminal for that source
+        // despite not expecting it ... we don't do anything to prevent it if the source Flowable keeps sending after onError
+        // inner Flowable errors are considered terminal for that source
 //        verify(stringObserver, times(1)).onNext("six");
-        // inner observable errors are considered terminal for that source
+        // inner Flowable errors are considered terminal for that source
     }
 
     @Test
     public void testErrorDelayed2() {
-        final Flowable<String> o1 = Flowable.create(new TestErrorObservable("one", "two", "three"));
-        final Flowable<String> o2 = Flowable.create(new TestErrorObservable("four", null, "six")); // we expect to lose "six" from the source (and it should never be sent by the source since onError was called
-        final Flowable<String> o3 = Flowable.create(new TestErrorObservable("seven", "eight", null));
-        final Flowable<String> o4 = Flowable.create(new TestErrorObservable("nine"));
+        final Flowable<String> o1 = Flowable.create(new TestErrorFlowable("one", "two", "three"));
+        final Flowable<String> o2 = Flowable.create(new TestErrorFlowable("four", null, "six")); // we expect to lose "six" from the source (and it should never be sent by the source since onError was called
+        final Flowable<String> o3 = Flowable.create(new TestErrorFlowable("seven", "eight", null));
+        final Flowable<String> o4 = Flowable.create(new TestErrorFlowable("nine"));
 
         Flowable<String> m = Flowable.mergeDelayError(o1, o2, o3, o4);
         m.subscribe(stringObserver);
@@ -78,8 +80,8 @@ public void testErrorDelayed2() {
         verify(stringObserver, times(1)).onNext("three");
         verify(stringObserver, times(1)).onNext("four");
         verify(stringObserver, times(0)).onNext("five");
-        // despite not expecting it ... we don't do anything to prevent it if the source Observable keeps sending after onError
-        // inner observable errors are considered terminal for that source
+        // despite not expecting it ... we don't do anything to prevent it if the source Flowable keeps sending after onError
+        // inner Flowable errors are considered terminal for that source
 //        verify(stringObserver, times(1)).onNext("six");
         verify(stringObserver, times(1)).onNext("seven");
         verify(stringObserver, times(1)).onNext("eight");
@@ -88,10 +90,10 @@ public void testErrorDelayed2() {
 
     @Test
     public void testErrorDelayed3() {
-        final Flowable<String> o1 = Flowable.create(new TestErrorObservable("one", "two", "three"));
-        final Flowable<String> o2 = Flowable.create(new TestErrorObservable("four", "five", "six"));
-        final Flowable<String> o3 = Flowable.create(new TestErrorObservable("seven", "eight", null));
-        final Flowable<String> o4 = Flowable.create(new TestErrorObservable("nine"));
+        final Flowable<String> o1 = Flowable.create(new TestErrorFlowable("one", "two", "three"));
+        final Flowable<String> o2 = Flowable.create(new TestErrorFlowable("four", "five", "six"));
+        final Flowable<String> o3 = Flowable.create(new TestErrorFlowable("seven", "eight", null));
+        final Flowable<String> o4 = Flowable.create(new TestErrorFlowable("nine"));
 
         Flowable<String> m = Flowable.mergeDelayError(o1, o2, o3, o4);
         m.subscribe(stringObserver);
@@ -111,10 +113,10 @@ public void testErrorDelayed3() {
 
     @Test
     public void testErrorDelayed4() {
-        final Flowable<String> o1 = Flowable.create(new TestErrorObservable("one", "two", "three"));
-        final Flowable<String> o2 = Flowable.create(new TestErrorObservable("four", "five", "six"));
-        final Flowable<String> o3 = Flowable.create(new TestErrorObservable("seven", "eight"));
-        final Flowable<String> o4 = Flowable.create(new TestErrorObservable("nine", null));
+        final Flowable<String> o1 = Flowable.create(new TestErrorFlowable("one", "two", "three"));
+        final Flowable<String> o2 = Flowable.create(new TestErrorFlowable("four", "five", "six"));
+        final Flowable<String> o3 = Flowable.create(new TestErrorFlowable("seven", "eight"));
+        final Flowable<String> o4 = Flowable.create(new TestErrorFlowable("nine", null));
 
         Flowable<String> m = Flowable.mergeDelayError(o1, o2, o3, o4);
         m.subscribe(stringObserver);
@@ -134,11 +136,11 @@ public void testErrorDelayed4() {
 
     @Test
     public void testErrorDelayed4WithThreading() {
-        final TestAsyncErrorObservable o1 = new TestAsyncErrorObservable("one", "two", "three");
-        final TestAsyncErrorObservable o2 = new TestAsyncErrorObservable("four", "five", "six");
-        final TestAsyncErrorObservable o3 = new TestAsyncErrorObservable("seven", "eight");
+        final TestAsyncErrorFlowable o1 = new TestAsyncErrorFlowable("one", "two", "three");
+        final TestAsyncErrorFlowable o2 = new TestAsyncErrorFlowable("four", "five", "six");
+        final TestAsyncErrorFlowable o3 = new TestAsyncErrorFlowable("seven", "eight");
         // throw the error at the very end so no onComplete will be called after it
-        final TestAsyncErrorObservable o4 = new TestAsyncErrorObservable("nine", null);
+        final TestAsyncErrorFlowable o4 = new TestAsyncErrorFlowable("nine", null);
 
         Flowable<String> m = Flowable.mergeDelayError(Flowable.create(o1), Flowable.create(o2), Flowable.create(o3), Flowable.create(o4));
         m.subscribe(stringObserver);
@@ -167,8 +169,8 @@ public void testErrorDelayed4WithThreading() {
 
     @Test
     public void testCompositeErrorDelayed1() {
-        final Flowable<String> o1 = Flowable.create(new TestErrorObservable("four", null, "six")); // we expect to lose "six" from the source (and it should never be sent by the source since onError was called
-        final Flowable<String> o2 = Flowable.create(new TestErrorObservable("one", "two", null));
+        final Flowable<String> o1 = Flowable.create(new TestErrorFlowable("four", null, "six")); // we expect to lose "six" from the source (and it should never be sent by the source since onError was called
+        final Flowable<String> o2 = Flowable.create(new TestErrorFlowable("one", "two", null));
 
         Flowable<String> m = Flowable.mergeDelayError(o1, o2);
         m.subscribe(stringObserver);
@@ -180,15 +182,15 @@ public void testCompositeErrorDelayed1() {
         verify(stringObserver, times(0)).onNext("three");
         verify(stringObserver, times(1)).onNext("four");
         verify(stringObserver, times(0)).onNext("five");
-        // despite not expecting it ... we don't do anything to prevent it if the source Observable keeps sending after onError
-        // inner observable errors are considered terminal for that source
+        // despite not expecting it ... we don't do anything to prevent it if the source Flowable keeps sending after onError
+        // inner Flowable errors are considered terminal for that source
 //        verify(stringObserver, times(1)).onNext("six");
     }
 
     @Test
     public void testCompositeErrorDelayed2() {
-        final Flowable<String> o1 = Flowable.create(new TestErrorObservable("four", null, "six")); // we expect to lose "six" from the source (and it should never be sent by the source since onError was called
-        final Flowable<String> o2 = Flowable.create(new TestErrorObservable("one", "two", null));
+        final Flowable<String> o1 = Flowable.create(new TestErrorFlowable("four", null, "six")); // we expect to lose "six" from the source (and it should never be sent by the source since onError was called
+        final Flowable<String> o2 = Flowable.create(new TestErrorFlowable("one", "two", null));
 
         Flowable<String> m = Flowable.mergeDelayError(o1, o2);
         CaptureObserver w = new CaptureObserver();
@@ -216,23 +218,23 @@ public void testCompositeErrorDelayed2() {
      */
 
     @Test
-    public void testMergeObservableOfObservables() {
-        final Flowable<String> o1 = Flowable.create(new TestSynchronousObservable());
-        final Flowable<String> o2 = Flowable.create(new TestSynchronousObservable());
+    public void testMergeFlowableOfFlowables() {
+        final Flowable<String> o1 = Flowable.create(new TestSynchronousFlowable());
+        final Flowable<String> o2 = Flowable.create(new TestSynchronousFlowable());
 
-        Flowable<Flowable<String>> observableOfObservables = Flowable.create(new Publisher<Flowable<String>>() {
+        Flowable<Flowable<String>> FlowableOfFlowables = Flowable.create(new Publisher<Flowable<String>>() {
 
             @Override
             public void subscribe(Subscriber<? super Flowable<String>> observer) {
                 observer.onSubscribe(new BooleanSubscription());
-                // simulate what would happen in an observable
+                // simulate what would happen in an Flowable
                 observer.onNext(o1);
                 observer.onNext(o2);
                 observer.onComplete();
             }
 
         });
-        Flowable<String> m = Flowable.mergeDelayError(observableOfObservables);
+        Flowable<String> m = Flowable.mergeDelayError(FlowableOfFlowables);
         m.subscribe(stringObserver);
 
         verify(stringObserver, never()).onError(any(Throwable.class));
@@ -242,8 +244,8 @@ public void subscribe(Subscriber<? super Flowable<String>> observer) {
 
     @Test
     public void testMergeArray() {
-        final Flowable<String> o1 = Flowable.create(new TestSynchronousObservable());
-        final Flowable<String> o2 = Flowable.create(new TestSynchronousObservable());
+        final Flowable<String> o1 = Flowable.create(new TestSynchronousFlowable());
+        final Flowable<String> o2 = Flowable.create(new TestSynchronousFlowable());
 
         Flowable<String> m = Flowable.mergeDelayError(o1, o2);
         m.subscribe(stringObserver);
@@ -255,13 +257,13 @@ public void testMergeArray() {
 
     @Test
     public void testMergeList() {
-        final Flowable<String> o1 = Flowable.create(new TestSynchronousObservable());
-        final Flowable<String> o2 = Flowable.create(new TestSynchronousObservable());
-        List<Flowable<String>> listOfObservables = new ArrayList<Flowable<String>>();
-        listOfObservables.add(o1);
-        listOfObservables.add(o2);
+        final Flowable<String> o1 = Flowable.create(new TestSynchronousFlowable());
+        final Flowable<String> o2 = Flowable.create(new TestSynchronousFlowable());
+        List<Flowable<String>> listOfFlowables = new ArrayList<Flowable<String>>();
+        listOfFlowables.add(o1);
+        listOfFlowables.add(o2);
 
-        Flowable<String> m = Flowable.mergeDelayError(Flowable.fromIterable(listOfObservables));
+        Flowable<String> m = Flowable.mergeDelayError(Flowable.fromIterable(listOfFlowables));
         m.subscribe(stringObserver);
 
         verify(stringObserver, never()).onError(any(Throwable.class));
@@ -271,8 +273,8 @@ public void testMergeList() {
 
     @Test
     public void testMergeArrayWithThreading() {
-        final TestASynchronousObservable o1 = new TestASynchronousObservable();
-        final TestASynchronousObservable o2 = new TestASynchronousObservable();
+        final TestASynchronousFlowable o1 = new TestASynchronousFlowable();
+        final TestASynchronousFlowable o2 = new TestASynchronousFlowable();
 
         Flowable<String> m = Flowable.mergeDelayError(Flowable.create(o1), Flowable.create(o2));
         m.subscribe(stringObserver);
@@ -318,7 +320,7 @@ public void onNext(String s) {
         }
     }
 
-    private static class TestSynchronousObservable implements Publisher<String> {
+    private static class TestSynchronousFlowable implements Publisher<String> {
 
         @Override
         public void subscribe(Subscriber<? super String> observer) {
@@ -328,7 +330,7 @@ public void subscribe(Subscriber<? super String> observer) {
         }
     }
 
-    private static class TestASynchronousObservable implements Publisher<String> {
+    private static class TestASynchronousFlowable implements Publisher<String> {
         Thread t;
 
         @Override
@@ -347,11 +349,11 @@ public void run() {
         }
     }
 
-    private static class TestErrorObservable implements Publisher<String> {
+    private static class TestErrorFlowable implements Publisher<String> {
 
         String[] valuesToReturn;
 
-        TestErrorObservable(String... values) {
+        TestErrorFlowable(String... values) {
             valuesToReturn = values;
         }
 
@@ -376,11 +378,11 @@ public void subscribe(Subscriber<? super String> observer) {
         }
     }
 
-    private static class TestAsyncErrorObservable implements Publisher<String> {
+    private static class TestAsyncErrorFlowable implements Publisher<String> {
 
         String[] valuesToReturn;
 
-        TestAsyncErrorObservable(String... values) {
+        TestAsyncErrorFlowable(String... values) {
             valuesToReturn = values;
         }
 
@@ -492,7 +494,7 @@ public void onComplete() {
     }
 
     @Test
-    public void testErrorInParentObservable() {
+    public void testErrorInParentFlowable() {
         TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
         Flowable.mergeDelayError(
                 Flowable.just(Flowable.just(1), Flowable.just(2))
@@ -506,11 +508,11 @@ public void testErrorInParentObservable() {
     }
 
     @Test
-    public void testErrorInParentObservableDelayed() throws Exception {
+    public void testErrorInParentFlowableDelayed() throws Exception {
         for (int i = 0; i < 50; i++) {
-            final TestASynchronous1sDelayedObservable o1 = new TestASynchronous1sDelayedObservable();
-            final TestASynchronous1sDelayedObservable o2 = new TestASynchronous1sDelayedObservable();
-            Flowable<Flowable<String>> parentObservable = Flowable.create(new Publisher<Flowable<String>>() {
+            final TestASynchronous1sDelayedFlowable o1 = new TestASynchronous1sDelayedFlowable();
+            final TestASynchronous1sDelayedFlowable o2 = new TestASynchronous1sDelayedFlowable();
+            Flowable<Flowable<String>> parentFlowable = Flowable.create(new Publisher<Flowable<String>>() {
                 @Override
                 public void subscribe(Subscriber<? super Flowable<String>> op) {
                     op.onSubscribe(new BooleanSubscription());
@@ -523,9 +525,9 @@ public void subscribe(Subscriber<? super Flowable<String>> op) {
             Subscriber<String> stringObserver = TestHelper.mockSubscriber();
             
             TestSubscriber<String> ts = new TestSubscriber<String>(stringObserver);
-            Flowable<String> m = Flowable.mergeDelayError(parentObservable);
+            Flowable<String> m = Flowable.mergeDelayError(parentFlowable);
             m.subscribe(ts);
-            System.out.println("testErrorInParentObservableDelayed | " + i);
+            System.out.println("testErrorInParentFlowableDelayed | " + i);
             ts.awaitTerminalEvent(2000, TimeUnit.MILLISECONDS);
             ts.assertTerminated();
     
@@ -535,7 +537,7 @@ public void subscribe(Subscriber<? super Flowable<String>> op) {
         }
     }
 
-    private static class TestASynchronous1sDelayedObservable implements Publisher<String> {
+    private static class TestASynchronous1sDelayedFlowable implements Publisher<String> {
         Thread t;
 
         @Override
@@ -562,7 +564,7 @@ public void run() {
     public void testDelayErrorMaxConcurrent() {
         final List<Long> requests = new ArrayList<Long>();
         Flowable<Integer> source = Flowable.mergeDelayError(Flowable.just(
-                Flowable.just(1).asObservable(), 
+                Flowable.just(1).hide(), 
                 Flowable.<Integer>error(new TestException()))
                 .doOnRequest(new LongConsumer() {
                     @Override
@@ -580,4 +582,142 @@ public void accept(long t1) {
         ts.assertError(TestException.class);
         assertEquals(Arrays.asList(1L, 1L, 1L), requests);
     }
+    
+    // This is pretty much a clone of testMergeList but with the overloaded MergeDelayError for Iterables
+    @Test     
+    public void mergeIterable() {
+        final Flowable<String> o1 = Flowable.create(new TestSynchronousFlowable());
+        final Flowable<String> o2 = Flowable.create(new TestSynchronousFlowable());
+        List<Flowable<String>> listOfFlowables = new ArrayList<Flowable<String>>();
+        listOfFlowables.add(o1);
+        listOfFlowables.add(o2);
+
+        Flowable<String> m = Flowable.mergeDelayError(listOfFlowables);
+        m.subscribe(stringObserver);
+
+        verify(stringObserver, never()).onError(any(Throwable.class));
+        verify(stringObserver, times(1)).onComplete();
+        verify(stringObserver, times(2)).onNext("hello");   
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void iterableMaxConcurrent() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        PublishProcessor<Integer> ps1 = PublishProcessor.create();
+        PublishProcessor<Integer> ps2 = PublishProcessor.create();
+        
+        Flowable.mergeDelayError(Arrays.asList(ps1, ps2), 1).subscribe(ts);
+        
+        assertTrue("ps1 has no subscribers?!", ps1.hasSubscribers());
+        assertFalse("ps2 has subscribers?!", ps2.hasSubscribers());
+        
+        ps1.onNext(1);
+        ps1.onComplete();
+        
+        assertFalse("ps1 has subscribers?!", ps1.hasSubscribers());
+        assertTrue("ps2 has no subscribers?!", ps2.hasSubscribers());
+
+        ps2.onNext(2);
+        ps2.onComplete();
+
+        ts.assertValues(1, 2);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void iterableMaxConcurrentError() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        PublishProcessor<Integer> ps1 = PublishProcessor.create();
+        PublishProcessor<Integer> ps2 = PublishProcessor.create();
+        
+        Flowable.mergeDelayError(Arrays.asList(ps1, ps2), 1).subscribe(ts);
+        
+        assertTrue("ps1 has no subscribers?!", ps1.hasSubscribers());
+        assertFalse("ps2 has subscribers?!", ps2.hasSubscribers());
+        
+        ps1.onNext(1);
+        ps1.onError(new TestException());
+        
+        assertFalse("ps1 has subscribers?!", ps1.hasSubscribers());
+        assertTrue("ps2 has no subscribers?!", ps2.hasSubscribers());
+
+        ps2.onNext(2);
+        ps2.onError(new TestException());
+
+        ts.assertValues(1, 2);
+        ts.assertError(CompositeException.class);
+        ts.assertNotComplete();
+        
+        CompositeException ce = (CompositeException)ts.errors().get(0);
+        
+        assertEquals(2, ce.getExceptions().size());
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    @Ignore("No 2-9 parameter mergeDelayError() overloads")
+    public void mergeMany() throws Exception {
+        for (int i = 2; i < 10; i++) {
+            Class<?>[] clazz = new Class[i];
+            Arrays.fill(clazz, Flowable.class);
+            
+            Flowable<Integer>[] obs = new Flowable[i];
+            Arrays.fill(obs, Flowable.just(1));
+            
+            Integer[] expected = new Integer[i];
+            Arrays.fill(expected, 1);
+            
+            Method m = Flowable.class.getMethod("mergeDelayError", clazz);
+            
+            TestSubscriber<Integer> ts = TestSubscriber.create();
+            
+            ((Flowable<Integer>)m.invoke(null, (Object[])obs)).subscribe(ts);
+            
+            ts.assertValues(expected);
+            ts.assertNoErrors();
+            ts.assertComplete();
+        }
+    }
+
+    static <T> Flowable<T> withError(Flowable<T> source) {
+        return source.concatWith(Flowable.<T>error(new TestException()));
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    @Ignore("No 2-9 parameter mergeDelayError() overloads")
+    public void mergeManyError() throws Exception {
+        for (int i = 2; i < 10; i++) {
+            Class<?>[] clazz = new Class[i];
+            Arrays.fill(clazz, Flowable.class);
+            
+            Flowable<Integer>[] obs = new Flowable[i];
+            for (int j = 0; j < i; j++) {
+                obs[j] = withError(Flowable.just(1));
+            }
+            
+            Integer[] expected = new Integer[i];
+            Arrays.fill(expected, 1);
+            
+            Method m = Flowable.class.getMethod("mergeDelayError", clazz);
+            
+            TestSubscriber<Integer> ts = TestSubscriber.create();
+            
+            ((Flowable<Integer>)m.invoke(null, (Object[])obs)).subscribe(ts);
+            
+            ts.assertValues(expected);
+            ts.assertError(CompositeException.class);
+            ts.assertNotComplete();
+            
+            CompositeException ce = (CompositeException)ts.errors().get(0);
+            
+            assertEquals(i, ce.getExceptions().size());
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
index e58a76cd9c..44bd43afa3 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java
@@ -18,6 +18,7 @@
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
+import java.lang.reflect.Method;
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.*;
@@ -28,10 +29,12 @@
 import io.reactivex.*;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.subscriptions.*;
+import io.reactivex.internal.util.BackpressureHelper;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.*;
-import io.reactivex.subscribers.DefaultObserver;
-import io.reactivex.subscribers.TestSubscriber;
+import io.reactivex.subscribers.*;
 
 public class FlowableMergeTest {
 
@@ -69,23 +72,23 @@ public void after() {
     }
 
     @Test
-    public void testMergeObservableOfObservables() {
-        final Flowable<String> o1 = Flowable.create(new TestSynchronousObservable());
-        final Flowable<String> o2 = Flowable.create(new TestSynchronousObservable());
+    public void testMergeFlowableOfFlowables() {
+        final Flowable<String> o1 = Flowable.create(new TestSynchronousFlowable());
+        final Flowable<String> o2 = Flowable.create(new TestSynchronousFlowable());
 
-        Flowable<Flowable<String>> observableOfObservables = Flowable.create(new Publisher<Flowable<String>>() {
+        Flowable<Flowable<String>> FlowableOfFlowables = Flowable.create(new Publisher<Flowable<String>>() {
 
             @Override
             public void subscribe(Subscriber<? super Flowable<String>> observer) {
                 observer.onSubscribe(new BooleanSubscription());
-                // simulate what would happen in an observable
+                // simulate what would happen in an Flowable
                 observer.onNext(o1);
                 observer.onNext(o2);
                 observer.onComplete();
             }
 
         });
-        Flowable<String> m = Flowable.merge(observableOfObservables);
+        Flowable<String> m = Flowable.merge(FlowableOfFlowables);
         m.subscribe(stringObserver);
 
         verify(stringObserver, never()).onError(any(Throwable.class));
@@ -95,8 +98,8 @@ public void subscribe(Subscriber<? super Flowable<String>> observer) {
 
     @Test
     public void testMergeArray() {
-        final Flowable<String> o1 = Flowable.create(new TestSynchronousObservable());
-        final Flowable<String> o2 = Flowable.create(new TestSynchronousObservable());
+        final Flowable<String> o1 = Flowable.create(new TestSynchronousFlowable());
+        final Flowable<String> o2 = Flowable.create(new TestSynchronousFlowable());
 
         Flowable<String> m = Flowable.merge(o1, o2);
         m.subscribe(stringObserver);
@@ -108,13 +111,13 @@ public void testMergeArray() {
 
     @Test
     public void testMergeList() {
-        final Flowable<String> o1 = Flowable.create(new TestSynchronousObservable());
-        final Flowable<String> o2 = Flowable.create(new TestSynchronousObservable());
-        List<Flowable<String>> listOfObservables = new ArrayList<Flowable<String>>();
-        listOfObservables.add(o1);
-        listOfObservables.add(o2);
+        final Flowable<String> o1 = Flowable.create(new TestSynchronousFlowable());
+        final Flowable<String> o2 = Flowable.create(new TestSynchronousFlowable());
+        List<Flowable<String>> listOfFlowables = new ArrayList<Flowable<String>>();
+        listOfFlowables.add(o1);
+        listOfFlowables.add(o2);
 
-        Flowable<String> m = Flowable.merge(listOfObservables);
+        Flowable<String> m = Flowable.merge(listOfFlowables);
         m.subscribe(stringObserver);
 
         verify(stringObserver, never()).onError(any(Throwable.class));
@@ -123,7 +126,7 @@ public void testMergeList() {
     }
 
     @Test(timeout = 1000)
-    public void testUnSubscribeObservableOfObservables() throws InterruptedException {
+    public void testUnSubscribeFlowableOfFlowables() throws InterruptedException {
 
         final AtomicBoolean unsubscribed = new AtomicBoolean();
         final CountDownLatch latch = new CountDownLatch(1);
@@ -192,8 +195,8 @@ public void accept(Long v) {
 
     @Test
     public void testMergeArrayWithThreading() {
-        final TestASynchronousObservable o1 = new TestASynchronousObservable();
-        final TestASynchronousObservable o2 = new TestASynchronousObservable();
+        final TestASynchronousFlowable o1 = new TestASynchronousFlowable();
+        final TestASynchronousFlowable o2 = new TestASynchronousFlowable();
 
         Flowable<String> m = Flowable.merge(Flowable.create(o1), Flowable.create(o2));
         TestSubscriber<String> ts = new TestSubscriber<String>(stringObserver);
@@ -217,8 +220,8 @@ public void testSynchronizationOfMultipleSequencesLoop() throws Throwable {
     
     @Test
     public void testSynchronizationOfMultipleSequences() throws Throwable {
-        final TestASynchronousObservable o1 = new TestASynchronousObservable();
-        final TestASynchronousObservable o2 = new TestASynchronousObservable();
+        final TestASynchronousFlowable o1 = new TestASynchronousFlowable();
+        final TestASynchronousFlowable o2 = new TestASynchronousFlowable();
 
         // use this latch to cause onNext to wait until we're ready to let it go
         final CountDownLatch endLatch = new CountDownLatch(1);
@@ -245,7 +248,7 @@ public void onNext(String v) {
                 concurrentCounter.incrementAndGet();
                 try {
                     // avoid deadlocking the main thread
-                    if (Thread.currentThread().getName().equals("TestASynchronousObservable")) {
+                    if (Thread.currentThread().getName().equals("TestASynchronousFlowable")) {
                         // wait here until we're done asserting
                         endLatch.await();
                     }
@@ -259,7 +262,7 @@ public void onNext(String v) {
 
         });
 
-        // wait for both observables to send (one should be blocked)
+        // wait for both Flowables to send (one should be blocked)
         o1.onNextBeingSent.await();
         o2.onNextBeingSent.await();
 
@@ -300,8 +303,8 @@ public void onNext(String v) {
     @Test
     public void testError1() {
         // we are using synchronous execution to test this exactly rather than non-deterministic concurrent behavior
-        final Flowable<String> o1 = Flowable.create(new TestErrorObservable("four", null, "six")); // we expect to lose "six"
-        final Flowable<String> o2 = Flowable.create(new TestErrorObservable("one", "two", "three")); // we expect to lose all of these since o1 is done first and fails
+        final Flowable<String> o1 = Flowable.create(new TestErrorFlowable("four", null, "six")); // we expect to lose "six"
+        final Flowable<String> o2 = Flowable.create(new TestErrorFlowable("one", "two", "three")); // we expect to lose all of these since o1 is done first and fails
 
         Flowable<String> m = Flowable.merge(o1, o2);
         m.subscribe(stringObserver);
@@ -322,10 +325,10 @@ public void testError1() {
     @Test
     public void testError2() {
         // we are using synchronous execution to test this exactly rather than non-deterministic concurrent behavior
-        final Flowable<String> o1 = Flowable.create(new TestErrorObservable("one", "two", "three"));
-        final Flowable<String> o2 = Flowable.create(new TestErrorObservable("four", null, "six")); // we expect to lose "six"
-        final Flowable<String> o3 = Flowable.create(new TestErrorObservable("seven", "eight", null));// we expect to lose all of these since o2 is done first and fails
-        final Flowable<String> o4 = Flowable.create(new TestErrorObservable("nine"));// we expect to lose all of these since o2 is done first and fails
+        final Flowable<String> o1 = Flowable.create(new TestErrorFlowable("one", "two", "three"));
+        final Flowable<String> o2 = Flowable.create(new TestErrorFlowable("four", null, "six")); // we expect to lose "six"
+        final Flowable<String> o3 = Flowable.create(new TestErrorFlowable("seven", "eight", null));// we expect to lose all of these since o2 is done first and fails
+        final Flowable<String> o4 = Flowable.create(new TestErrorFlowable("nine"));// we expect to lose all of these since o2 is done first and fails
 
         Flowable<String> m = Flowable.merge(o1, o2, o3, o4);
         m.subscribe(stringObserver);
@@ -362,7 +365,7 @@ public void subscribe(Subscriber<? super String> s) {
         System.out.println("Error: " + ts.errors());
     }
 
-    private static class TestSynchronousObservable implements Publisher<String> {
+    private static class TestSynchronousFlowable implements Publisher<String> {
 
         @Override
         public void subscribe(Subscriber<? super String> observer) {
@@ -372,7 +375,7 @@ public void subscribe(Subscriber<? super String> observer) {
         }
     }
 
-    private static class TestASynchronousObservable implements Publisher<String> {
+    private static class TestASynchronousFlowable implements Publisher<String> {
         Thread t;
         final CountDownLatch onNextBeingSent = new CountDownLatch(1);
 
@@ -394,16 +397,16 @@ public void run() {
                     }
                 }
 
-            }, "TestASynchronousObservable");
+            }, "TestASynchronousFlowable");
             t.start();
         }
     }
 
-    private static class TestErrorObservable implements Publisher<String> {
+    private static class TestErrorFlowable implements Publisher<String> {
 
         String[] valuesToReturn;
 
-        TestErrorObservable(String... values) {
+        TestErrorFlowable(String... values) {
             valuesToReturn = values;
         }
 
@@ -423,14 +426,14 @@ public void subscribe(Subscriber<? super String> observer) {
     }
 
     @Test
-    public void testUnsubscribeAsObservablesComplete() {
+    public void testUnsubscribeAsFlowablesComplete() {
         TestScheduler scheduler1 = Schedulers.test();
         AtomicBoolean os1 = new AtomicBoolean(false);
-        Flowable<Long> o1 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler1, os1);
+        Flowable<Long> o1 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler1, os1);
 
         TestScheduler scheduler2 = Schedulers.test();
         AtomicBoolean os2 = new AtomicBoolean(false);
-        Flowable<Long> o2 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler2, os2);
+        Flowable<Long> o2 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler2, os2);
 
         TestSubscriber<Long> ts = new TestSubscriber<Long>();
         Flowable.merge(o1, o2).subscribe(ts);
@@ -468,11 +471,11 @@ public void testEarlyUnsubscribe() {
         for (int i = 0; i < 10; i++) {
             TestScheduler scheduler1 = Schedulers.test();
             AtomicBoolean os1 = new AtomicBoolean(false);
-            Flowable<Long> o1 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler1, os1);
+            Flowable<Long> o1 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler1, os1);
 
             TestScheduler scheduler2 = Schedulers.test();
             AtomicBoolean os2 = new AtomicBoolean(false);
-            Flowable<Long> o2 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler2, os2);
+            Flowable<Long> o2 = createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler2, os2);
 
             TestSubscriber<Long> ts = new TestSubscriber<Long>();
             Flowable.merge(o1, o2).subscribe(ts);
@@ -500,7 +503,7 @@ public void testEarlyUnsubscribe() {
         }
     }
 
-    private Flowable<Long> createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(final Scheduler scheduler, final AtomicBoolean unsubscribed) {
+    private Flowable<Long> createFlowableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(final Scheduler scheduler, final AtomicBoolean unsubscribed) {
         return Flowable.create(new Publisher<Long>() {
 
             @Override
@@ -667,9 +670,9 @@ public void run() {
     @Test
     public void testBackpressureUpstream() throws InterruptedException {
         final AtomicInteger generated1 = new AtomicInteger();
-        Flowable<Integer> o1 = createInfiniteObservable(generated1).subscribeOn(Schedulers.computation());
+        Flowable<Integer> o1 = createInfiniteFlowable(generated1).subscribeOn(Schedulers.computation());
         final AtomicInteger generated2 = new AtomicInteger();
-        Flowable<Integer> o2 = createInfiniteObservable(generated2).subscribeOn(Schedulers.computation());
+        Flowable<Integer> o2 = createInfiniteFlowable(generated2).subscribeOn(Schedulers.computation());
 
         TestSubscriber<Integer> testSubscriber = new TestSubscriber<Integer>() {
             @Override
@@ -706,7 +709,7 @@ public void testBackpressureUpstream2InLoop() throws InterruptedException {
     @Test
     public void testBackpressureUpstream2() throws InterruptedException {
         final AtomicInteger generated1 = new AtomicInteger();
-        Flowable<Integer> o1 = createInfiniteObservable(generated1).subscribeOn(Schedulers.computation());
+        Flowable<Integer> o1 = createInfiniteFlowable(generated1).subscribeOn(Schedulers.computation());
 
         TestSubscriber<Integer> testSubscriber = new TestSubscriber<Integer>() {
             @Override
@@ -741,9 +744,9 @@ public void onNext(Integer t) {
     @Test(timeout = 10000)
     public void testBackpressureDownstreamWithConcurrentStreams() throws InterruptedException {
         final AtomicInteger generated1 = new AtomicInteger();
-        Flowable<Integer> o1 = createInfiniteObservable(generated1).subscribeOn(Schedulers.computation());
+        Flowable<Integer> o1 = createInfiniteFlowable(generated1).subscribeOn(Schedulers.computation());
         final AtomicInteger generated2 = new AtomicInteger();
-        Flowable<Integer> o2 = createInfiniteObservable(generated2).subscribeOn(Schedulers.computation());
+        Flowable<Integer> o2 = createInfiniteFlowable(generated2).subscribeOn(Schedulers.computation());
 
         TestSubscriber<Integer> testSubscriber = new TestSubscriber<Integer>() {
             @Override
@@ -775,9 +778,9 @@ public void onNext(Integer t) {
     }
 
     @Test
-    public void testBackpressureBothUpstreamAndDownstreamWithSynchronousScalarObservables() throws InterruptedException {
+    public void testBackpressureBothUpstreamAndDownstreamWithSynchronousScalarFlowables() throws InterruptedException {
         final AtomicInteger generated1 = new AtomicInteger();
-        Flowable<Flowable<Integer>> o1 = createInfiniteObservable(generated1)
+        Flowable<Flowable<Integer>> o1 = createInfiniteFlowable(generated1)
         .map(new Function<Integer, Flowable<Integer>>() {
 
             @Override
@@ -816,21 +819,21 @@ public void onNext(Integer t) {
     }
 
     /**
-     * Currently there is no solution to this ... we can't exert backpressure on the outer Observable if we
+     * Currently there is no solution to this ... we can't exert backpressure on the outer Flowable if we
      * can't know if the ones we've received so far are going to emit or not, otherwise we could starve the system.
      * 
-     * For example, 10,000 Observables are being merged (bad use case to begin with, but ...) and it's only one of them
+     * For example, 10,000 Flowables are being merged (bad use case to begin with, but ...) and it's only one of them
      * that will ever emit. If backpressure only allowed the first 1,000 to be sent, we would hang and never receive an event.
      * 
-     * Thus, we must allow all Observables to be sent. The ScalarSynchronousObservable use case is an exception to this since
+     * Thus, we must allow all Flowables to be sent. The ScalarSynchronousFlowable use case is an exception to this since
      * we can grab the value synchronously.
      * 
      * @throws InterruptedException
      */
     @Test(timeout = 5000)
-    public void testBackpressureBothUpstreamAndDownstreamWithRegularObservables() throws InterruptedException {
+    public void testBackpressureBothUpstreamAndDownstreamWithRegularFlowables() throws InterruptedException {
         final AtomicInteger generated1 = new AtomicInteger();
-        Flowable<Flowable<Integer>> o1 = createInfiniteObservable(generated1).map(new Function<Integer, Flowable<Integer>>() {
+        Flowable<Flowable<Integer>> o1 = createInfiniteFlowable(generated1).map(new Function<Integer, Flowable<Integer>>() {
 
             @Override
             public Flowable<Integer> apply(Integer t1) {
@@ -864,11 +867,11 @@ public void onNext(Integer t) {
         testSubscriber.assertNoErrors();
         System.out.println("Generated 1: " + generated1.get());
         System.err.println(testSubscriber.values());
-        System.out.println("done1 testBackpressureBothUpstreamAndDownstreamWithRegularObservables ");
+        System.out.println("done1 testBackpressureBothUpstreamAndDownstreamWithRegularFlowables ");
         assertEquals(Flowable.bufferSize() * 2, testSubscriber.values().size());
-        System.out.println("done2 testBackpressureBothUpstreamAndDownstreamWithRegularObservables ");
+        System.out.println("done2 testBackpressureBothUpstreamAndDownstreamWithRegularFlowables ");
         // we can't restrict this ... see comment above
-        //        assertTrue(generated1.get() >= Observable.bufferSize() && generated1.get() <= Observable.bufferSize() * 4);
+        //        assertTrue(generated1.get() >= Flowable.bufferSize() && generated1.get() <= Flowable.bufferSize() * 4);
     }
 
     @Test
@@ -905,7 +908,7 @@ public void subscribe(Subscriber<? super String> s) {
 
     @Test
     @Ignore("Null values are not permitted")
-    public void mergingNullObservable() {
+    public void mergingNullFlowable() {
         TestSubscriber<String> ts = new TestSubscriber<String>();
         Flowable.merge(Flowable.just("one"), null).subscribe(ts);
         ts.assertNoErrors();
@@ -1037,8 +1040,8 @@ public void merge1000000SyncStreamOf1() {
         return Flowable.merge(os);
     }
 
-    private Flowable<Integer> createInfiniteObservable(final AtomicInteger generated) {
-        Flowable<Integer> observable = Flowable.fromIterable(new Iterable<Integer>() {
+    private Flowable<Integer> createInfiniteFlowable(final AtomicInteger generated) {
+        Flowable<Integer> flowable = Flowable.fromIterable(new Iterable<Integer>() {
             @Override
             public Iterator<Integer> iterator() {
                 return new Iterator<Integer>() {
@@ -1059,7 +1062,7 @@ public boolean hasNext() {
                 };
             }
         });
-        return observable;
+        return flowable;
     }
 
     @Test
@@ -1233,7 +1236,7 @@ public void accept(long n) {
                         }
 
                     })
-                    // take a number bigger than 2* Observable.bufferSize() (used by OperatorMerge)
+                    // take a number bigger than 2* Flowable.bufferSize() (used by OperatorMerge)
                     .take(Flowable.bufferSize() * 2 + 1)
                     // log count
                     .doOnNext(printCount())
@@ -1322,7 +1325,7 @@ public void accept(Integer s) {
     Function<Integer, Flowable<Integer>> toHiddenScalar = new Function<Integer, Flowable<Integer>>() {
         @Override
         public Flowable<Integer> apply(Integer t) {
-            return Flowable.just(t).asObservable();
+            return Flowable.just(t).hide();
         }
     };
     ;
@@ -1387,4 +1390,208 @@ public void onNext(Integer t) {
             runMerge(toHiddenScalar, ts);
         }
     }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void negativeMaxConcurrent() {
+        try {
+            Flowable.merge(Arrays.asList(Flowable.just(1), Flowable.just(2)), -1);
+            fail("Expected IllegalArgumentException");
+        } catch (IllegalArgumentException e) {
+            assertEquals("maxConcurrency > 0 required but it was -1", e.getMessage());
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void zeroMaxConcurrent() {
+        try {
+            Flowable.merge(Arrays.asList(Flowable.just(1), Flowable.just(2)), 0);
+            fail("Expected IllegalArgumentException");
+        } catch (IllegalArgumentException e) {
+            assertEquals("maxConcurrency > 0 required but it was 0", e.getMessage());
+        }
+    }
+    
+    @Test
+    @Ignore("Nulls are not allowed with RS")
+    public void mergeJustNull() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0);
+        
+        Flowable.range(1, 2).flatMap(new Function<Integer, Flowable<Integer>>() {
+            @Override
+            public Flowable<Integer> apply(Integer t) {
+                return Flowable.just(null);
+            }
+        }).subscribe(ts);
+        
+        ts.request(2);
+        ts.assertValues(null, null);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @Test
+    public void mergeConcurrentJustJust() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.merge(Flowable.just(Flowable.just(1)), 5).subscribe(ts);
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+
+    @Test
+    public void mergeConcurrentJustRange() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.merge(Flowable.just(Flowable.range(1, 5)), 5).subscribe(ts);
+        
+        ts.assertValues(1, 2, 3, 4, 5);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+
+    @SuppressWarnings("unchecked")
+    @Test
+    @Ignore("No 2-9 argument merge()")
+    public void mergeMany() throws Exception {
+        for (int i = 2; i < 10; i++) {
+            Class<?>[] clazz = new Class[i];
+            Arrays.fill(clazz, Flowable.class);
+            
+            Flowable<Integer>[] obs = new Flowable[i];
+            Arrays.fill(obs, Flowable.just(1));
+            
+            Integer[] expected = new Integer[i];
+            Arrays.fill(expected, 1);
+            
+            Method m = Flowable.class.getMethod("merge", clazz);
+            
+            TestSubscriber<Integer> ts = TestSubscriber.create();
+            
+            ((Flowable<Integer>)m.invoke(null, (Object[])obs)).subscribe(ts);
+            
+            ts.assertValues(expected);
+            ts.assertNoErrors();
+            ts.assertComplete();
+        }
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void mergeArrayMaxConcurrent() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        PublishProcessor<Integer> ps1 = PublishProcessor.create();
+        PublishProcessor<Integer> ps2 = PublishProcessor.create();
+        
+        Flowable.merge(1, new Flowable[] { ps1, ps2 }).subscribe(ts);
+        
+        assertTrue("ps1 has no subscribers?!", ps1.hasSubscribers());
+        assertFalse("ps2 has subscribers?!", ps2.hasSubscribers());
+        
+        ps1.onNext(1);
+        ps1.onComplete();
+        
+        assertFalse("ps1 has subscribers?!", ps1.hasSubscribers());
+        assertTrue("ps2 has no subscribers?!", ps2.hasSubscribers());
+
+        ps2.onNext(2);
+        ps2.onComplete();
+
+        ts.assertValues(1, 2);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void flatMapJustJust() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.just(Flowable.just(1)).flatMap((Function)Functions.identity()).subscribe(ts);
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void flatMapJustRange() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.just(Flowable.range(1, 5)).flatMap((Function)Functions.identity()).subscribe(ts);
+        
+        ts.assertValues(1, 2, 3, 4, 5);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void flatMapMaxConcurrentJustJust() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.just(Flowable.just(1)).flatMap((Function)Functions.identity(), 5).subscribe(ts);
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void flatMapMaxConcurrentJustRange() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Flowable.just(Flowable.range(1, 5)).flatMap((Function)Functions.identity(), 5).subscribe(ts);
+        
+        ts.assertValues(1, 2, 3, 4, 5);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @Test
+    public void noInnerReordering() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        FlowableFlatMap.MergeSubscriber<Publisher<Integer>, Integer> ms = 
+                new FlowableFlatMap.MergeSubscriber<Publisher<Integer>, Integer>(ts, Functions.<Publisher<Integer>>identity(), false, 128, 128);
+        ms.onSubscribe(new BooleanSubscription());
+        
+        PublishProcessor<Integer> ps = PublishProcessor.create();
+
+        ms.onNext(ps);
+        
+        ps.onNext(1);
+        
+        BackpressureHelper.add(ms.requested, 2);
+        
+        ps.onNext(2);
+        
+        ms.drain();
+        
+        ts.assertValues(1, 2);
+    }
+    
+    @Test
+    public void noOuterScalarReordering() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        FlowableFlatMap.MergeSubscriber<Publisher<Integer>, Integer> ms = 
+                new FlowableFlatMap.MergeSubscriber<Publisher<Integer>, Integer>(ts, Functions.<Publisher<Integer>>identity(), false, 128, 128);
+        ms.onSubscribe(new BooleanSubscription());
+        
+        ms.onNext(Flowable.just(1));
+        
+        BackpressureHelper.add(ms.requested, 2);
+        
+        ms.onNext(Flowable.just(2));
+        
+        ms.drain();
+        
+        ts.assertValues(1, 2);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
index e68e79ebf7..9dd7272b73 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableObserveOnTest.java
@@ -55,7 +55,7 @@ public void testObserveOn() {
 
     @Test
     public void testOrdering() throws InterruptedException {
-//        Observable<String> obs = Observable.just("one", null, "two", "three", "four");
+//        Flowable<String> obs = Flowable.just("one", null, "two", "three", "four");
         // FIXME null values not allowed
         Flowable<String> obs = Flowable.just("one", "null", "two", "three", "four");
 
@@ -87,7 +87,7 @@ public void testOrdering() throws InterruptedException {
     public void testThreadName() throws InterruptedException {
         System.out.println("Main Thread: " + Thread.currentThread().getName());
         // FIXME null values not allowed
-//        Observable<String> obs = Observable.just("one", null, "two", "three", "four");
+//        Flowable<String> obs = Flowable.just("one", null, "two", "three", "four");
         Flowable<String> obs = Flowable.just("one", "null", "two", "three", "four");
 
         Subscriber<String> observer = TestHelper.mockSubscriber();
@@ -407,7 +407,7 @@ public void testAfterUnsubscribeCalledThenObserverOnNextNeverCalled() {
     @Test
     public void testBackpressureWithTakeAfter() {
         final AtomicInteger generated = new AtomicInteger();
-        Flowable<Integer> observable = Flowable.fromIterable(new Iterable<Integer>() {
+        Flowable<Integer> flowable = Flowable.fromIterable(new Iterable<Integer>() {
             @Override
             public Iterator<Integer> iterator() {
                 return new Iterator<Integer>() {
@@ -441,7 +441,7 @@ public void onNext(Integer t) {
             }
         };
 
-        observable
+        flowable
                 .observeOn(Schedulers.newThread())
                 .take(3)
                 .subscribe(testSubscriber);
@@ -457,7 +457,7 @@ public void onNext(Integer t) {
     public void testBackpressureWithTakeAfterAndMultipleBatches() {
         int numForBatches = Flowable.bufferSize() * 3 + 1; // should be 4 batches == ((3*n)+1) items
         final AtomicInteger generated = new AtomicInteger();
-        Flowable<Integer> observable = Flowable.fromIterable(new Iterable<Integer>() {
+        Flowable<Integer> flowable = Flowable.fromIterable(new Iterable<Integer>() {
             @Override
             public Iterator<Integer> iterator() {
                 return new Iterator<Integer>() {
@@ -487,7 +487,7 @@ public void onNext(Integer t) {
             }
         };
 
-        observable
+        flowable
                 .observeOn(Schedulers.newThread())
                 .take(numForBatches)
                 .subscribe(testSubscriber);
@@ -501,7 +501,7 @@ public void onNext(Integer t) {
     @Test
     public void testBackpressureWithTakeBefore() {
         final AtomicInteger generated = new AtomicInteger();
-        Flowable<Integer> observable = Flowable.fromIterable(new Iterable<Integer>() {
+        Flowable<Integer> flowable = Flowable.fromIterable(new Iterable<Integer>() {
             @Override
             public Iterator<Integer> iterator() {
                 return new Iterator<Integer>() {
@@ -524,7 +524,7 @@ public boolean hasNext() {
         });
 
         TestSubscriber<Integer> testSubscriber = new TestSubscriber<Integer>();
-        observable
+        flowable
                 .take(7)
                 .observeOn(Schedulers.newThread())
                 .subscribe(testSubscriber);
@@ -537,7 +537,7 @@ public boolean hasNext() {
     @Test
     public void testQueueFullEmitsError() {
         final CountDownLatch latch = new CountDownLatch(1);
-        Flowable<Integer> observable = Flowable.create(new Publisher<Integer>() {
+        Flowable<Integer> flowable = Flowable.create(new Publisher<Integer>() {
 
             @Override
             public void subscribe(Subscriber<? super Integer> o) {
@@ -574,7 +574,7 @@ public void onNext(Integer t) {
             }
 
         });
-        observable.observeOn(Schedulers.newThread()).subscribe(testSubscriber);
+        flowable.observeOn(Schedulers.newThread()).subscribe(testSubscriber);
 
         testSubscriber.awaitTerminalEvent();
         List<Throwable> errors = testSubscriber.errors();
@@ -796,5 +796,161 @@ public void onNext(Integer t) {
         // FIXME observeOn requests bufferSize at first always
         assertEquals(Arrays.asList(128L), requests);
     }
+
+    
+    @Test
+    public void testErrorDelayed() {
+        TestScheduler s = Schedulers.test();
+        
+        Flowable<Integer> source = Flowable.just(1, 2 ,3)
+                .concatWith(Flowable.<Integer>error(new TestException()));
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+
+        source.observeOn(s, true).subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertNotComplete();
+        
+        s.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertNotComplete();
+
+        ts.request(1);
+        s.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        ts.assertValues(1);
+        ts.assertNoErrors();
+        ts.assertNotComplete();
+        
+        ts.request(3); // requesting 2 doesn't switch to the error() source for some reason in concat.
+        s.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        ts.assertValues(1, 2, 3);
+        ts.assertError(TestException.class);
+        ts.assertNotComplete();
+    }
+    
+    @Test
+    public void testErrorDelayedAsync() {
+        Flowable<Integer> source = Flowable.just(1, 2 ,3)
+                .concatWith(Flowable.<Integer>error(new TestException()));
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        source.observeOn(Schedulers.computation(), true).subscribe(ts);
+        
+        ts.awaitTerminalEvent(2, TimeUnit.SECONDS);
+        ts.assertValues(1, 2, 3);
+        ts.assertError(TestException.class);
+        ts.assertNotComplete();
+    }
+    
+    @Test
+    public void requestExactCompletesImmediately() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        
+        TestScheduler test = Schedulers.test();
+
+        Flowable.range(1, 10).observeOn(test).subscribe(ts);
+
+        test.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertNotComplete();
+        
+        ts.request(10);
+
+        test.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        ts.assertValueCount(10);
+        ts.assertNoErrors();
+        ts.assertComplete();
+    }
+    
+    @Test
+    public void fixedReplenishPattern() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+
+        TestScheduler test = Schedulers.test();
+        
+        final List<Long> requests = new ArrayList<Long>();
+        
+        Flowable.range(1, 100)
+        .doOnRequest(new LongConsumer() {
+            @Override
+            public void accept(long v) {
+                requests.add(v);
+            }
+        })
+        .observeOn(test, false, 16).subscribe(ts);
+        
+        test.advanceTimeBy(1, TimeUnit.SECONDS);
+        ts.request(20);
+        test.advanceTimeBy(1, TimeUnit.SECONDS);
+        ts.request(10);
+        test.advanceTimeBy(1, TimeUnit.SECONDS);
+        ts.request(50);
+        test.advanceTimeBy(1, TimeUnit.SECONDS);
+        ts.request(35);
+        test.advanceTimeBy(1, TimeUnit.SECONDS);
+        
+        ts.assertValueCount(100);
+        ts.assertComplete();
+        ts.assertNoErrors();
+        
+        assertEquals(Arrays.asList(16L, 12L, 12L, 12L, 12L, 12L, 12L, 12L, 12L), requests);
+    }
     
+    @Test
+    public void bufferSizesWork() {
+        for (int i = 1; i <= 1024; i = i * 2) {
+            TestSubscriber<Integer> ts = TestSubscriber.create();
+            
+            Flowable.range(1, 1000 * 1000).observeOn(Schedulers.computation(), false, i)
+            .subscribe(ts);
+            
+            ts.awaitTerminalEvent();
+            ts.assertValueCount(1000 * 1000);
+            ts.assertComplete();
+            ts.assertNoErrors();
+        }
+    }
+    
+    @Test
+    public void synchronousRebatching() {
+        final List<Long> requests = new ArrayList<Long>();
+        
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+            
+        Flowable.range(1, 50)
+        .doOnRequest(new LongConsumer() {
+            @Override
+            public void accept(long r) {
+                requests.add(r);
+            }
+        })
+       .rebatchRequests(20)
+       .subscribe(ts);
+       
+       ts.assertValueCount(50);
+       ts.assertNoErrors();
+       ts.assertComplete();
+       
+       assertEquals(Arrays.asList(20L, 15L, 15L, 15L), requests);
+    }
+    
+    @Test
+    public void rebatchRequestsArgumentCheck() {
+        try {
+            Flowable.never().rebatchRequests(-99);
+            fail("Didn't throw IAE");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("bufferSize > 0 required but it was -99", ex.getMessage());
+        }
+    }
 }
\ No newline at end of file
