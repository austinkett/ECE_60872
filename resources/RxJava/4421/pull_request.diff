diff --git a/src/main/java/io/reactivex/Completable.java b/src/main/java/io/reactivex/Completable.java
index b790649c80..be4a097d8c 100644
--- a/src/main/java/io/reactivex/Completable.java
+++ b/src/main/java/io/reactivex/Completable.java
@@ -577,7 +577,7 @@ public static Completable never() {
     }
     
     /**
-     * Returns a Completable instance that fires its onComplete event after the given delay ellapsed.
+     * Returns a Completable instance that fires its onComplete event after the given delay elapsed.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code timer} does operate by default on the {@code computation} {@link Scheduler}.</dd>
@@ -592,7 +592,7 @@ public static Completable timer(long delay, TimeUnit unit) {
     }
     
     /**
-     * Returns a Completable instance that fires its onComplete event after the given delay ellapsed
+     * Returns a Completable instance that fires its onComplete event after the given delay elapsed
      * by using the supplied scheduler.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -815,7 +815,7 @@ public final void blockingAwait() {
      * @param timeout the timeout value
      * @param unit the timeout unit
      * @return true if the this Completable instance completed normally within the time limit,
-     * false if the timeout ellapsed before this Completable terminated.
+     * false if the timeout elapsed before this Completable terminated.
      * @throws RuntimeException wrapping an InterruptedException if the current thread is interrupted
      */
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -840,12 +840,12 @@ public final Throwable blockingGet() {
     
     /**
      * Subscribes to this Completable instance and blocks until it terminates or the specified timeout 
-     * ellapses, then returns null for normal termination or the emitted exception if any.
+     * elapses, then returns null for normal termination or the emitted exception if any.
      * @param timeout the timeout value
      * @param unit the time unit
      * @return the throwable if this terminated with an error, null otherwise
      * @throws RuntimeException that wraps an InterruptedException if the wait is interrupted or
-     * TimeoutException if the specified timeout ellapsed before it
+     * TimeoutException if the specified timeout elapsed before it
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Throwable blockingGet(long timeout, TimeUnit unit) {
@@ -957,7 +957,7 @@ public final Completable doOnComplete(Action onComplete) {
     }
     
     /**
-     * Returns a Completable which calls the giveon onDispose callback if the child subscriber cancels
+     * Returns a Completable which calls the given onDispose callback if the child subscriber cancels
      * the subscription.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -1069,9 +1069,13 @@ public final Completable doOnTerminate(final Action onTerminate) {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Completable doAfterTerminate(final Action onAfterTerminate) {
-        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(),
-                onAfterTerminate, Functions.EMPTY_ACTION,
-                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);
+        return doOnLifecycle(
+                Functions.emptyConsumer(),
+                Functions.emptyConsumer(),
+                Functions.EMPTY_ACTION,
+                Functions.EMPTY_ACTION,
+                onAfterTerminate,
+                Functions.EMPTY_ACTION);
     }
 
     /**
@@ -1618,7 +1622,7 @@ private Completable timeout0(long timeout, TimeUnit unit, Scheduler scheduler, C
     }
     
     /**
-     * Convers this Completable into a Single which when this Completable completes normally,
+     * Converts this Completable into a Single which when this Completable completes normally,
      * calls the given supplier and emits its returned value through onSuccess.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -1636,7 +1640,7 @@ private Completable timeout0(long timeout, TimeUnit unit, Scheduler scheduler, C
     }
     
     /**
-     * Convers this Completable into a Single which when this Completable completes normally,
+     * Converts this Completable into a Single which when this Completable completes normally,
      * emits the given value through onSuccess.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java
index fbea084de9..680471225e 100644
--- a/src/main/java/io/reactivex/Flowable.java
+++ b/src/main/java/io/reactivex/Flowable.java
@@ -40,7 +40,7 @@
  * The Flowable class that implements the Reactive-Streams Pattern and offers factory methods,
  * intermediate operators and the ability to consume reactive dataflows.
  * <p>
- * Reactive-Streams operates with {@code Publisher}s wich {@code Flowable} extends. Many operators
+ * Reactive-Streams operates with {@code Publisher}s which {@code Flowable} extends. Many operators
  * therefore accept general {@code Publisher}s directly and allow direct interoperation with other
  * Reactive-Streams implementations.
  * <p>
@@ -505,9 +505,9 @@ public static int bufferSize() {
      * @param <T1> the element type of the first source
      * @param <T2> the element type of the second source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            the second source Publisher
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source Publishers
@@ -519,10 +519,10 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, R> Flowable<R> combineLatest(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
             BiFunction<? super T1, ? super T2, ? extends R> combiner) {
         Function<Object[], R> f = Functions.toFunction(combiner);
-        return combineLatest(f, p1, p2);
+        return combineLatest(f, source1, source2);
     }
 
     /**
@@ -544,11 +544,11 @@ public static int bufferSize() {
      * @param <T2> the element type of the second source
      * @param <T3> the element type of the third source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            the second source Publisher
-     * @param p3
+     * @param source3
      *            the third source Publisher
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source Publishers
@@ -560,10 +560,10 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, R> Flowable<R> combineLatest(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
-            Publisher<? extends T3> p3, 
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
+            Publisher<? extends T3> source3, 
             Function3<? super T1, ? super T2, ? super T3, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), p1, p2, p3);
+        return combineLatest(Functions.toFunction(combiner), source1, source2, source3);
     }
 
     /**
@@ -586,13 +586,13 @@ public static int bufferSize() {
      * @param <T3> the element type of the third source
      * @param <T4> the element type of the fourth source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            the second source Publisher
-     * @param p3
+     * @param source3
      *            the third source Publisher
-     * @param p4
+     * @param source4
      *            the fourth source Publisher
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source Publishers
@@ -604,10 +604,10 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, R> Flowable<R> combineLatest(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
-            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
+            Publisher<? extends T3> source3, Publisher<? extends T4> source4,
             Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4);
+        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4);
     }
 
     /**
@@ -631,15 +631,15 @@ public static int bufferSize() {
      * @param <T4> the element type of the fourth source
      * @param <T5> the element type of the fifth source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            the second source Publisher
-     * @param p3
+     * @param source3
      *            the third source Publisher
-     * @param p4
+     * @param source4
      *            the fourth source Publisher
-     * @param p5
+     * @param source5
      *            the fifth source Publisher
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source Publishers
@@ -651,11 +651,11 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, R> Flowable<R> combineLatest(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
-            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
-            Publisher<? extends T5> p5,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
+            Publisher<? extends T3> source3, Publisher<? extends T4> source4,
+            Publisher<? extends T5> source5,
             Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4, p5);
+        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5);
     }
 
     /**
@@ -680,17 +680,17 @@ public static int bufferSize() {
      * @param <T5> the element type of the fifth source
      * @param <T6> the element type of the sixth source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            the second source Publisher
-     * @param p3
+     * @param source3
      *            the third source Publisher
-     * @param p4
+     * @param source4
      *            the fourth source Publisher
-     * @param p5
+     * @param source5
      *            the fifth source Publisher
-     * @param p6
+     * @param source6
      *            the sixth source Publisher
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source Publishers
@@ -702,11 +702,11 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> combineLatest(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
-            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
-            Publisher<? extends T5> p5, Publisher<? extends T6> p6,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
+            Publisher<? extends T3> source3, Publisher<? extends T4> source4,
+            Publisher<? extends T5> source5, Publisher<? extends T6> source6,
             Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4, p5, p6);
+        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6);
     }
 
     /**
@@ -732,19 +732,19 @@ public static int bufferSize() {
      * @param <T6> the element type of the sixth source
      * @param <T7> the element type of the seventh source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            the second source Publisher
-     * @param p3
+     * @param source3
      *            the third source Publisher
-     * @param p4
+     * @param source4
      *            the fourth source Publisher
-     * @param p5
+     * @param source5
      *            the fifth source Publisher
-     * @param p6
+     * @param source6
      *            the sixth source Publisher
-     * @param p7
+     * @param source7
      *            the seventh source Publisher
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source Publishers
@@ -756,12 +756,12 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> combineLatest(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
-            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
-            Publisher<? extends T5> p5, Publisher<? extends T6> p6,
-            Publisher<? extends T7> p7,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
+            Publisher<? extends T3> source3, Publisher<? extends T4> source4,
+            Publisher<? extends T5> source5, Publisher<? extends T6> source6,
+            Publisher<? extends T7> source7,
             Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4, p5, p6, p7);
+        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7);
     }
 
     /**
@@ -788,21 +788,21 @@ public static int bufferSize() {
      * @param <T7> the element type of the seventh source
      * @param <T8> the element type of the eighth source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            the second source Publisher
-     * @param p3
+     * @param source3
      *            the third source Publisher
-     * @param p4
+     * @param source4
      *            the fourth source Publisher
-     * @param p5
+     * @param source5
      *            the fifth source Publisher
-     * @param p6
+     * @param source6
      *            the sixth source Publisher
-     * @param p7
+     * @param source7
      *            the seventh source Publisher
-     * @param p8
+     * @param source8
      *            the eighth source Publisher
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source Publishers
@@ -814,12 +814,12 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> combineLatest(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
-            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
-            Publisher<? extends T5> p5, Publisher<? extends T6> p6,
-            Publisher<? extends T7> p7, Publisher<? extends T8> p8,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
+            Publisher<? extends T3> source3, Publisher<? extends T4> source4,
+            Publisher<? extends T5> source5, Publisher<? extends T6> source6,
+            Publisher<? extends T7> source7, Publisher<? extends T8> source8,
             Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4, p5, p6, p7, p8);
+        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8);
     }
 
     /**
@@ -847,23 +847,23 @@ public static int bufferSize() {
      * @param <T8> the element type of the eighth source
      * @param <T9> the element type of the ninth source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            the second source Publisher
-     * @param p3
+     * @param source3
      *            the third source Publisher
-     * @param p4
+     * @param source4
      *            the fourth source Publisher
-     * @param p5
+     * @param source5
      *            the fifth source Publisher
-     * @param p6
+     * @param source6
      *            the sixth source Publisher
-     * @param p7
+     * @param source7
      *            the seventh source Publisher
-     * @param p8
+     * @param source8
      *            the eighth source Publisher
-     * @param p9
+     * @param source9
      *            the ninth source Publisher
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source Publishers
@@ -875,13 +875,13 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> combineLatest(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
-            Publisher<? extends T3> p3, Publisher<? extends T4> p4,
-            Publisher<? extends T5> p5, Publisher<? extends T6> p6,
-            Publisher<? extends T7> p7, Publisher<? extends T8> p8,
-            Publisher<? extends T9> p9,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
+            Publisher<? extends T3> source3, Publisher<? extends T4> source4,
+            Publisher<? extends T5> source5, Publisher<? extends T6> source6,
+            Publisher<? extends T7> source7, Publisher<? extends T8> source8,
+            Publisher<? extends T9> source9,
             Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), p1, p2, p3, p4, p5, p6, p7, p8, p9);
+        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8, source9);
     }
 
     /**
@@ -935,7 +935,7 @@ public static int bufferSize() {
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources) {
+    public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources) {
         return concat(sources, bufferSize());
     }
 
@@ -966,7 +966,7 @@ public static int bufferSize() {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {
+    public static <T> Flowable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {
         return fromPublisher(sources).concatMap((Function)Functions.identity(), prefetch);
     }
 
@@ -986,9 +986,9 @@ public static int bufferSize() {
      * </dl>
      *
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a Publisher to be concatenated
-     * @param p2
+     * @param source2
      *            a Publisher to be concatenated
      * @return a Flowable that emits items emitted by the two source Publishers, one after the other,
      *         without interleaving them
@@ -997,8 +997,8 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> concat(Publisher<? extends T> p1, Publisher<? extends T> p2) {
-        return concatArray(p1, p2);
+    public static <T> Flowable<T> concat(Publisher<? extends T> source1, Publisher<? extends T> source2) {
+        return concatArray(source1, source2);
     }
 
     /**
@@ -1017,11 +1017,11 @@ public static int bufferSize() {
      * </dl>
      *
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a Publisher to be concatenated
-     * @param p2
+     * @param source2
      *            a Publisher to be concatenated
-     * @param p3
+     * @param source3
      *            a Publisher to be concatenated
      * @return a Flowable that emits items emitted by the three source Publishers, one after the other,
      *         without interleaving them
@@ -1031,9 +1031,9 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Flowable<T> concat(
-            Publisher<? extends T> p1, Publisher<? extends T> p2,
-            Publisher<? extends T> p3) {
-        return concatArray(p1, p2, p3);
+            Publisher<? extends T> source1, Publisher<? extends T> source2,
+            Publisher<? extends T> source3) {
+        return concatArray(source1, source2, source3);
     }
 
     /**
@@ -1052,13 +1052,13 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a Publisher to be concatenated
-     * @param p2
+     * @param source2
      *            a Publisher to be concatenated
-     * @param p3
+     * @param source3
      *            a Publisher to be concatenated
-     * @param p4
+     * @param source4
      *            a Publisher to be concatenated
      * @return a Flowable that emits items emitted by the four source Publishers, one after the other,
      *         without interleaving them
@@ -1068,9 +1068,9 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Flowable<T> concat(
-            Publisher<? extends T> p1, Publisher<? extends T> p2,
-            Publisher<? extends T> p3, Publisher<? extends T> p4) {
-        return concatArray(p1, p2, p3, p4);
+            Publisher<? extends T> source1, Publisher<? extends T> source2,
+            Publisher<? extends T> source3, Publisher<? extends T> source4) {
+        return concatArray(source1, source2, source3, source4);
     }
 
     /**
@@ -1154,7 +1154,7 @@ public static int bufferSize() {
      * @param <T> the value type
      * @param sources a sequence of Publishers that need to be eagerly concatenated
      * @return the new Publisher instance with the specified concatenation behavior
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -1183,7 +1183,7 @@ public static int bufferSize() {
      *                       is interpreted as indication to subscribe to all sources at once
      * @param prefetch the number of elements to prefetch from each Publisher source
      * @return the new Publisher instance with the specified concatenation behavior
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -1235,7 +1235,7 @@ public static int bufferSize() {
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources) {
+    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources) {
         return concatDelayError(sources, bufferSize(), true);
     }
 
@@ -1260,7 +1260,7 @@ public static int bufferSize() {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {
+    public static <T> Flowable<T> concatDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch, boolean tillTheEnd) {
         return fromPublisher(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);
     }
 
@@ -1281,7 +1281,7 @@ public static int bufferSize() {
      * @param <T> the value type
      * @param sources a sequence of Publishers that need to be eagerly concatenated
      * @return the new Publisher instance with the specified concatenation behavior
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -1309,7 +1309,7 @@ public static int bufferSize() {
      *                       is interpreted as all inner Publishers can be active at the same time
      * @param prefetch the number of elements to prefetch from each inner Publisher source
      * @return the new Publisher instance with the specified concatenation behavior
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -1335,7 +1335,7 @@ public static int bufferSize() {
      * @param <T> the value type
      * @param sources a sequence of Publishers that need to be eagerly concatenated
      * @return the new Publisher instance with the specified concatenation behavior
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -1363,7 +1363,7 @@ public static int bufferSize() {
      *                       is interpreted as all inner Publishers can be active at the same time
      * @param prefetch the number of elements to prefetch from each inner Publisher source
      * @return the new Publisher instance with the specified concatenation behavior
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -1402,7 +1402,7 @@ public static int bufferSize() {
      * </code></pre>
      * <p>
      * You should call the FlowableEmitter onNext, onError and onComplete methods in a serialized fashion. The
-     * rest of its methods are threadsafe.
+     * rest of its methods are thread-safe.
      * 
      * @param <T> the element type
      * @param source the emitter that is called when a Subscriber subscribes to the returned {@code Flowable}
@@ -1489,7 +1489,7 @@ public static int bufferSize() {
      *  <dd>{@code error} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param errorSupplier
+     * @param supplier
      *            a Callable factory to return a Throwable for each individual Subscriber
      * @param <T>
      *            the type of the items (ostensibly) emitted by the Publisher
@@ -1499,9 +1499,9 @@ public static int bufferSize() {
      */
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> error(Callable<? extends Throwable> errorSupplier) {
-        ObjectHelper.requireNonNull(errorSupplier, "errorSupplier is null");
-        return RxJavaPlugins.onAssembly(new FlowableError<T>(errorSupplier));
+    public static <T> Flowable<T> error(Callable<? extends Throwable> supplier) {
+        ObjectHelper.requireNonNull(supplier, "errorSupplier is null");
+        return RxJavaPlugins.onAssembly(new FlowableError<T>(supplier));
     }
 
     /**
@@ -1516,7 +1516,7 @@ public static int bufferSize() {
      *  <dd>{@code error} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param exception
+     * @param throwable
      *            the particular Throwable to pass to {@link Observer#onError onError}
      * @param <T>
      *            the type of the items (ostensibly) emitted by the Publisher
@@ -1526,9 +1526,9 @@ public static int bufferSize() {
      */
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> error(final Throwable exception) {
-        ObjectHelper.requireNonNull(exception, "e is null");
-        return error(Functions.justCallable(exception));
+    public static <T> Flowable<T> error(final Throwable throwable) {
+        ObjectHelper.requireNonNull(throwable, "throwable is null");
+        return error(Functions.justCallable(throwable));
     }
 
     /**
@@ -1543,7 +1543,7 @@ public static int bufferSize() {
      *  <dd>{@code from} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param values
+     * @param items
      *            the array of elements
      * @param <T>
      *            the type of items in the Array and the type of items to be emitted by the resulting Publisher
@@ -1552,15 +1552,15 @@ public static int bufferSize() {
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> fromArray(T... values) {
-        ObjectHelper.requireNonNull(values, "values is null");
-        if (values.length == 0) {
+    public static <T> Flowable<T> fromArray(T... items) {
+        ObjectHelper.requireNonNull(items, "items is null");
+        if (items.length == 0) {
             return empty();
         }
-        if (values.length == 1) {
-            return just(values[0]);
+        if (items.length == 1) {
+            return just(items[0]);
         }
-        return RxJavaPlugins.onAssembly(new FlowableFromArray<T>(values));
+        return RxJavaPlugins.onAssembly(new FlowableFromArray<T>(items));
     }
 
     /**
@@ -1585,7 +1585,7 @@ public static int bufferSize() {
      *         the type of the item emitted by the Publisher
      * @return a Flowable whose {@link Observer}s' subscriptions trigger an invocation of the given function
      * @see #defer(Callable)
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -1785,20 +1785,20 @@ public static int bufferSize() {
      *  <dd>{@code fromPublisher} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * @param <T> the value type of the flow
-     * @param publisher the Publisher to convert
+     * @param source the Publisher to convert
      * @return the new Flowable instance
      * @throws NullPointerException if publisher is null
      */
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
     @SchedulerSupport(SchedulerSupport.NONE)
     @SuppressWarnings("unchecked")
-    public static <T> Flowable<T> fromPublisher(final Publisher<? extends T> publisher) {
-        if (publisher instanceof Flowable) {
-            return RxJavaPlugins.onAssembly((Flowable<T>)publisher);
+    public static <T> Flowable<T> fromPublisher(final Publisher<? extends T> source) {
+        if (source instanceof Flowable) {
+            return RxJavaPlugins.onAssembly((Flowable<T>)source);
         }
-        ObjectHelper.requireNonNull(publisher, "publisher is null");
+        ObjectHelper.requireNonNull(source, "publisher is null");
 
-        return RxJavaPlugins.onAssembly(new FlowableFromPublisher<T>(publisher));
+        return RxJavaPlugins.onAssembly(new FlowableFromPublisher<T>(source));
     }
 
     /**
@@ -2149,7 +2149,7 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param value
+     * @param item
      *            the item to emit
      * @param <T>
      *            the type of that item
@@ -2158,9 +2158,9 @@ public static int bufferSize() {
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> just(T value) {
-        ObjectHelper.requireNonNull(value, "value is null");
-        return RxJavaPlugins.onAssembly(new FlowableJust<T>(value));
+    public static <T> Flowable<T> just(T item) {
+        ObjectHelper.requireNonNull(item, "item is null");
+        return RxJavaPlugins.onAssembly(new FlowableJust<T>(item));
     }
 
     /**
@@ -2174,9 +2174,9 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
      * @param <T>
      *            the type of these items
@@ -2186,11 +2186,11 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> just(T v1, T v2) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
+    public static <T> Flowable<T> just(T item1, T item2) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
         
-        return fromArray(v1, v2);
+        return fromArray(item1, item2);
     }
 
     /**
@@ -2204,11 +2204,11 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
      * @param <T>
      *            the type of these items
@@ -2218,12 +2218,12 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> just(T v1, T v2, T v3) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
+    public static <T> Flowable<T> just(T item1, T item2, T item3) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
         
-        return fromArray(v1, v2, v3);
+        return fromArray(item1, item2, item3);
     }
 
     /**
@@ -2237,13 +2237,13 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
      * @param <T>
      *            the type of these items
@@ -2253,13 +2253,13 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
+    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
         
-        return fromArray(v1, v2, v3, v4);
+        return fromArray(item1, item2, item3, item4);
     }
 
     /**
@@ -2273,15 +2273,15 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
      * @param <T>
      *            the type of these items
@@ -2291,14 +2291,14 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
+    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
         
-        return fromArray(v1, v2, v3, v4, v5);
+        return fromArray(item1, item2, item3, item4, item5);
     }
 
     /**
@@ -2312,17 +2312,17 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
-     * @param v6
+     * @param item6
      *            sixth item
      * @param <T>
      *            the type of these items
@@ -2332,15 +2332,15 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
-        ObjectHelper.requireNonNull(v6, "The sixth value is null");
+    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
+        ObjectHelper.requireNonNull(item6, "The sixth item is null");
         
-        return fromArray(v1, v2, v3, v4, v5, v6);
+        return fromArray(item1, item2, item3, item4, item5, item6);
     }
 
     /**
@@ -2354,19 +2354,19 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
-     * @param v6
+     * @param item6
      *            sixth item
-     * @param v7
+     * @param item7
      *            seventh item
      * @param <T>
      *            the type of these items
@@ -2376,16 +2376,16 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
-        ObjectHelper.requireNonNull(v6, "The sixth value is null");
-        ObjectHelper.requireNonNull(v7, "The seventh value is null");
+    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
+        ObjectHelper.requireNonNull(item6, "The sixth item is null");
+        ObjectHelper.requireNonNull(item7, "The seventh item is null");
         
-        return fromArray(v1, v2, v3, v4, v5, v6, v7);
+        return fromArray(item1, item2, item3, item4, item5, item6, item7);
     }
 
     /**
@@ -2399,21 +2399,21 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
-     * @param v6
+     * @param item6
      *            sixth item
-     * @param v7
+     * @param item7
      *            seventh item
-     * @param v8
+     * @param item8
      *            eighth item
      * @param <T>
      *            the type of these items
@@ -2423,17 +2423,17 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
-        ObjectHelper.requireNonNull(v6, "The sixth value is null");
-        ObjectHelper.requireNonNull(v7, "The seventh value is null");
-        ObjectHelper.requireNonNull(v8, "The eighth value is null");
+    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
+        ObjectHelper.requireNonNull(item6, "The sixth item is null");
+        ObjectHelper.requireNonNull(item7, "The seventh item is null");
+        ObjectHelper.requireNonNull(item8, "The eighth item is null");
         
-        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8);
+        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8);
     }
 
     /**
@@ -2447,23 +2447,23 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
-     * @param v6
+     * @param item6
      *            sixth item
-     * @param v7
+     * @param item7
      *            seventh item
-     * @param v8
+     * @param item8
      *            eighth item
-     * @param v9
+     * @param item9
      *            ninth item
      * @param <T>
      *            the type of these items
@@ -2473,18 +2473,18 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
-        ObjectHelper.requireNonNull(v6, "The sixth value is null");
-        ObjectHelper.requireNonNull(v7, "The seventh value is null");
-        ObjectHelper.requireNonNull(v8, "The eighth value is null");
-        ObjectHelper.requireNonNull(v9, "The ninth is null");
+    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
+        ObjectHelper.requireNonNull(item6, "The sixth item is null");
+        ObjectHelper.requireNonNull(item7, "The seventh item is null");
+        ObjectHelper.requireNonNull(item8, "The eighth item is null");
+        ObjectHelper.requireNonNull(item9, "The ninth is null");
         
-        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9);
+        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9);
     }
 
     /**
@@ -2498,25 +2498,25 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
-     * @param v6
+     * @param item6
      *            sixth item
-     * @param v7
+     * @param item7
      *            seventh item
-     * @param v8
+     * @param item8
      *            eighth item
-     * @param v9
+     * @param item9
      *            ninth item
-     * @param v10
+     * @param item10
      *            tenth item
      * @param <T>
      *            the type of these items
@@ -2526,19 +2526,19 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Flowable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9, T v10) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
-        ObjectHelper.requireNonNull(v6, "The sixth value is null");
-        ObjectHelper.requireNonNull(v7, "The seventh value is null");
-        ObjectHelper.requireNonNull(v8, "The eighth value is null");
-        ObjectHelper.requireNonNull(v9, "The ninth is null");
-        ObjectHelper.requireNonNull(v10, "The tenth is null");
+    public static <T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
+        ObjectHelper.requireNonNull(item6, "The sixth item is null");
+        ObjectHelper.requireNonNull(item7, "The seventh item is null");
+        ObjectHelper.requireNonNull(item8, "The eighth item is null");
+        ObjectHelper.requireNonNull(item9, "The ninth item is null");
+        ObjectHelper.requireNonNull(item10, "The tenth item is null");
         
-        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
+        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);
     }
 
     /**
@@ -2567,7 +2567,7 @@ public static int bufferSize() {
      * @return a Flowable that emits items that are the result of flattening the items emitted by the
      *         Publishers in the Iterable
      * @throws IllegalArgumentException
-     *             if {@code maxConcurrent} is less than or equal to 0
+     *             if {@code maxConcurrency} is less than or equal to 0
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
@@ -2603,7 +2603,7 @@ public static int bufferSize() {
      * @return a Flowable that emits items that are the result of flattening the items emitted by the
      *         Publishers in the Iterable
      * @throws IllegalArgumentException
-     *             if {@code maxConcurrent} is less than or equal to 0
+     *             if {@code maxConcurrency} is less than or equal to 0
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
@@ -2666,7 +2666,7 @@ public static int bufferSize() {
      * @return a Flowable that emits items that are the result of flattening the items emitted by the
      *         Publishers in the Iterable
      * @throws IllegalArgumentException
-     *             if {@code maxConcurrent} is less than or equal to 0
+     *             if {@code maxConcurrency} is less than or equal to 0
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
@@ -2731,7 +2731,7 @@ public static int bufferSize() {
      * @return a Flowable that emits items that are the result of flattening the Publishers emitted by the
      *         {@code source} Publisher
      * @throws IllegalArgumentException
-     *             if {@code maxConcurrent} is less than or equal to 0
+     *             if {@code maxConcurrency} is less than or equal to 0
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
      * @since 1.1.0
      */
@@ -2786,9 +2786,9 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a Publisher to be merged
-     * @param p2
+     * @param source2
      *            a Publisher to be merged
      * @return a Flowable that emits all of the items emitted by the source Publishers
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
@@ -2796,10 +2796,10 @@ public static int bufferSize() {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> merge(Publisher<? extends T> p1, Publisher<? extends T> p2) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        return fromArray(p1, p2).flatMap((Function)Functions.identity(), false, 2);
+    public static <T> Flowable<T> merge(Publisher<? extends T> source1, Publisher<? extends T> source2) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        return fromArray(source1, source2).flatMap((Function)Functions.identity(), false, 2);
     }
 
     /**
@@ -2818,11 +2818,11 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a Publisher to be merged
-     * @param p2
+     * @param source2
      *            a Publisher to be merged
-     * @param p3
+     * @param source3
      *            a Publisher to be merged
      * @return a Flowable that emits all of the items emitted by the source Publishers
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
@@ -2830,11 +2830,11 @@ public static int bufferSize() {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> merge(Publisher<? extends T> p1, Publisher<? extends T> p2, Publisher<? extends T> p3) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        ObjectHelper.requireNonNull(p3, "p3 is null");
-        return fromArray(p1, p2, p3).flatMap((Function)Functions.identity(), false, 3);
+    public static <T> Flowable<T> merge(Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), false, 3);
     }
 
     /**
@@ -2853,13 +2853,13 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a Publisher to be merged
-     * @param p2
+     * @param source2
      *            a Publisher to be merged
-     * @param p3
+     * @param source3
      *            a Publisher to be merged
-     * @param p4
+     * @param source4
      *            a Publisher to be merged
      * @return a Flowable that emits all of the items emitted by the source Publishers
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
@@ -2868,13 +2868,13 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Flowable<T> merge(
-            Publisher<? extends T> p1, Publisher<? extends T> p2, 
-            Publisher<? extends T> p3, Publisher<? extends T> p4) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        ObjectHelper.requireNonNull(p3, "p3 is null");
-        ObjectHelper.requireNonNull(p4, "p4 is null");
-        return fromArray(p1, p2, p3, p4).flatMap((Function)Functions.identity(), false, 4);
+            Publisher<? extends T> source1, Publisher<? extends T> source2, 
+            Publisher<? extends T> source3, Publisher<? extends T> source4) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), false, 4);
     }
 
     /**
@@ -3081,7 +3081,7 @@ public static int bufferSize() {
      * @return a Flowable that emits all of the items emitted by the Publishers emitted by the
      *         {@code source} Publisher
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @BackpressureSupport(BackpressureKind.FULL)
@@ -3144,9 +3144,9 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a Publisher to be merged
-     * @param p2
+     * @param source2
      *            a Publisher to be merged
      * @return a Flowable that emits all of the items that are emitted by the two source Publishers
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
@@ -3154,10 +3154,10 @@ public static int bufferSize() {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> p1, Publisher<? extends T> p2) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        return fromArray(p1, p2).flatMap((Function)Functions.identity(), true, 2);
+    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> source1, Publisher<? extends T> source2) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        return fromArray(source1, source2).flatMap((Function)Functions.identity(), true, 2);
     }
 
     /**
@@ -3183,11 +3183,11 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a Publisher to be merged
-     * @param p2
+     * @param source2
      *            a Publisher to be merged
-     * @param p3
+     * @param source3
      *            a Publisher to be merged
      * @return a Flowable that emits all of the items that are emitted by the source Publishers
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
@@ -3195,11 +3195,11 @@ public static int bufferSize() {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> p1, Publisher<? extends T> p2, Publisher<? extends T> p3) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        ObjectHelper.requireNonNull(p3, "p3 is null");
-        return fromArray(p1, p2, p3).flatMap((Function)Functions.identity(), true, 3);
+    public static <T> Flowable<T> mergeDelayError(Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), true, 3);
     }
 
     
@@ -3226,13 +3226,13 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a Publisher to be merged
-     * @param p2
+     * @param source2
      *            a Publisher to be merged
-     * @param p3
+     * @param source3
      *            a Publisher to be merged
-     * @param p4
+     * @param source4
      *            a Publisher to be merged
      * @return a Flowable that emits all of the items that are emitted by the source Publishers
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
@@ -3241,13 +3241,13 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Flowable<T> mergeDelayError(
-            Publisher<? extends T> p1, Publisher<? extends T> p2, 
-            Publisher<? extends T> p3, Publisher<? extends T> p4) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        ObjectHelper.requireNonNull(p3, "p3 is null");
-        ObjectHelper.requireNonNull(p4, "p4 is null");
-        return fromArray(p1, p2, p3, p4).flatMap((Function)Functions.identity(), true, 4);
+            Publisher<? extends T> source1, Publisher<? extends T> source2, 
+            Publisher<? extends T> source3, Publisher<? extends T> source4) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), true, 4);
     }
 
     /**
@@ -3324,9 +3324,9 @@ public static int bufferSize() {
      *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param p1
+     * @param source1
      *            the first Publisher to compare
-     * @param p2
+     * @param source2
      *            the second Publisher to compare
      * @param <T>
      *            the type of items emitted by each Publisher
@@ -3335,8 +3335,8 @@ public static int bufferSize() {
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2) {
-        return sequenceEqual(p1, p2, ObjectHelper.equalsPredicate(), bufferSize());
+    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2) {
+        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize());
     }
 
     /**
@@ -3353,9 +3353,9 @@ public static int bufferSize() {
      *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param p1
+     * @param source1
      *            the first Publisher to compare
-     * @param p2
+     * @param source2
      *            the second Publisher to compare
      * @param isEqual
      *            a function used to compare items emitted by each Publisher
@@ -3367,9 +3367,9 @@ public static int bufferSize() {
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, 
+    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2, 
             BiPredicate<? super T, ? super T> isEqual) {
-        return sequenceEqual(p1, p2, isEqual, bufferSize());
+        return sequenceEqual(source1, source2, isEqual, bufferSize());
     }
 
     /**
@@ -3386,9 +3386,9 @@ public static int bufferSize() {
      *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param p1
+     * @param source1
      *            the first Publisher to compare
-     * @param p2
+     * @param source2
      *            the second Publisher to compare
      * @param isEqual
      *            a function used to compare items emitted by each Publisher
@@ -3402,13 +3402,13 @@ public static int bufferSize() {
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, 
+    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2, 
             BiPredicate<? super T, ? super T> isEqual, int bufferSize) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
         ObjectHelper.requireNonNull(isEqual, "isEqual is null");
         verifyPositive(bufferSize, "bufferSize");
-        return RxJavaPlugins.onAssembly(new FlowableSequenceEqual<T>(p1, p2, isEqual, bufferSize));
+        return RxJavaPlugins.onAssembly(new FlowableSequenceEqual<T>(source1, source2, isEqual, bufferSize));
     }
 
     /**
@@ -3421,9 +3421,9 @@ public static int bufferSize() {
      *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param p1
+     * @param source1
      *            the first Publisher to compare
-     * @param p2
+     * @param source2
      *            the second Publisher to compare
      * @param bufferSize
      *            the number of items to prefetch from the first and second source Publisher
@@ -3434,8 +3434,8 @@ public static int bufferSize() {
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, int bufferSize) {
-        return sequenceEqual(p1, p2, ObjectHelper.equalsPredicate(), bufferSize);
+    public static <T> Flowable<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2, int bufferSize) {
+        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize);
     }
 
     /**
@@ -3589,7 +3589,7 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Flowable<T> switchOnNextDelayError(Publisher<? extends Publisher<? extends T>> sources, int prefetch) {
-        return fromPublisher(sources).switchMapDelayError(Functions.<Publisher<? extends T>>identity(), bufferSize());
+        return fromPublisher(sources).switchMapDelayError(Functions.<Publisher<? extends T>>identity(), prefetch);
     }
 
     /**
@@ -3698,7 +3698,7 @@ public static int bufferSize() {
      *            the factory function to create a resource object that depends on the Publisher
      * @param sourceSupplier
      *            the factory function to create a Publisher
-     * @param disposer
+     * @param resourceDisposer
      *            the function that will dispose of the resource
      * @return the Publisher whose lifetime controls the lifetime of the dependent resource object
      * @see <a href="http://reactivex.io/documentation/operators/using.html">ReactiveX operators documentation: Using</a>
@@ -3706,8 +3706,8 @@ public static int bufferSize() {
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier, 
-            Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> disposer) {
-        return using(resourceSupplier, sourceSupplier, disposer, true);
+            Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> resourceDisposer) {
+        return using(resourceSupplier, sourceSupplier, resourceDisposer, true);
     }
 
     /**
@@ -3732,7 +3732,7 @@ public static int bufferSize() {
      *            the factory function to create a resource object that depends on the Publisher
      * @param sourceSupplier
      *            the factory function to create a Publisher
-     * @param disposer
+     * @param resourceDisposer
      *            the function that will dispose of the resource
      * @param eager
      *            if {@code true} then disposal will happen either on unsubscription or just before emission of 
@@ -3745,11 +3745,11 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, D> Flowable<T> using(Callable<? extends D> resourceSupplier, 
             Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, 
-                    Consumer<? super D> disposer, boolean eager) {
+                    Consumer<? super D> resourceDisposer, boolean eager) {
         ObjectHelper.requireNonNull(resourceSupplier, "resourceSupplier is null");
         ObjectHelper.requireNonNull(sourceSupplier, "sourceSupplier is null");
-        ObjectHelper.requireNonNull(disposer, "disposer is null");
-        return RxJavaPlugins.onAssembly(new FlowableUsing<T, D>(resourceSupplier, sourceSupplier, disposer, eager));
+        ObjectHelper.requireNonNull(resourceDisposer, "disposer is null");
+        return RxJavaPlugins.onAssembly(new FlowableUsing<T, D>(resourceSupplier, sourceSupplier, resourceDisposer, eager));
     }
 
     /**
@@ -3920,9 +3920,9 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T1> the value type of the first source
      * @param <T2> the value type of the second source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            a second source Publisher
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source Publishers, results
@@ -3934,9 +3934,9 @@ private static void verifyPositive(long value, String paramName) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, R> Flowable<R> zip(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
             BiFunction<? super T1, ? super T2, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2);
     }
 
     /**
@@ -3977,9 +3977,9 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T1> the value type of the first source
      * @param <T2> the value type of the second source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            a second source Publisher
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source Publishers, results
@@ -3992,9 +3992,9 @@ private static void verifyPositive(long value, String paramName) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, R> Flowable<R> zip(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
             BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError) {
-        return zipArray(Functions.toFunction(zipper), delayError, bufferSize(), p1, p2);
+        return zipArray(Functions.toFunction(zipper), delayError, bufferSize(), source1, source2);
     }
 
     
@@ -4036,9 +4036,9 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T1> the value type of the first source
      * @param <T2> the value type of the second source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            a second source Publisher
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source Publishers, results
@@ -4052,9 +4052,9 @@ private static void verifyPositive(long value, String paramName) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, R> Flowable<R> zip(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, 
             BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError, int bufferSize) {
-        return zipArray(Functions.toFunction(zipper), delayError, bufferSize, p1, p2);
+        return zipArray(Functions.toFunction(zipper), delayError, bufferSize, source1, source2);
     }
 
     /**
@@ -4097,11 +4097,11 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T2> the value type of the second source
      * @param <T3> the value type of the third source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            a second source Publisher
-     * @param p3
+     * @param source3
      *            a third source Publisher
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source Publishers, results in
@@ -4113,9 +4113,9 @@ private static void verifyPositive(long value, String paramName) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, R> Flowable<R> zip(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3, 
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3, 
             Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3);
     }
 
     /**
@@ -4159,13 +4159,13 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T3> the value type of the third source
      * @param <T4> the value type of the fourth source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            a second source Publisher
-     * @param p3
+     * @param source3
      *            a third source Publisher
-     * @param p4
+     * @param source4
      *            a fourth source Publisher
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source Publishers, results in
@@ -4177,10 +4177,10 @@ private static void verifyPositive(long value, String paramName) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, R> Flowable<R> zip(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
-            Publisher<? extends T4> p4,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,
+            Publisher<? extends T4> source4,
             Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4);
     }
 
     /**
@@ -4225,15 +4225,15 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T4> the value type of the fourth source
      * @param <T5> the value type of the fifth source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            a second source Publisher
-     * @param p3
+     * @param source3
      *            a third source Publisher
-     * @param p4
+     * @param source4
      *            a fourth source Publisher
-     * @param p5
+     * @param source5
      *            a fifth source Publisher
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source Publishers, results in
@@ -4245,10 +4245,10 @@ private static void verifyPositive(long value, String paramName) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, R> Flowable<R> zip(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
-            Publisher<? extends T4> p4, Publisher<? extends T5> p5,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,
+            Publisher<? extends T4> source4, Publisher<? extends T5> source5,
             Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5);
     }
 
     /**
@@ -4293,17 +4293,17 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T5> the value type of the fifth source
      * @param <T6> the value type of the sixth source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            a second source Publisher
-     * @param p3
+     * @param source3
      *            a third source Publisher
-     * @param p4
+     * @param source4
      *            a fourth source Publisher
-     * @param p5
+     * @param source5
      *            a fifth source Publisher
-     * @param p6
+     * @param source6
      *            a sixth source Publisher
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source Publishers, results in
@@ -4315,10 +4315,10 @@ private static void verifyPositive(long value, String paramName) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, R> Flowable<R> zip(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
-            Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,
+            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,
             Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6);
     }
 
     /**
@@ -4364,19 +4364,19 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T6> the value type of the sixth source
      * @param <T7> the value type of the seventh source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            a second source Publisher
-     * @param p3
+     * @param source3
      *            a third source Publisher
-     * @param p4
+     * @param source4
      *            a fourth source Publisher
-     * @param p5
+     * @param source5
      *            a fifth source Publisher
-     * @param p6
+     * @param source6
      *            a sixth source Publisher
-     * @param p7
+     * @param source7
      *            a seventh source Publisher
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source Publishers, results in
@@ -4388,11 +4388,11 @@ private static void verifyPositive(long value, String paramName) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, R> Flowable<R> zip(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
-            Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
-            Publisher<? extends T7> p7,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,
+            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,
+            Publisher<? extends T7> source7,
             Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6, p7);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7);
     }
 
     /**
@@ -4439,21 +4439,21 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T7> the value type of the seventh source
      * @param <T8> the value type of the eighth source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            a second source Publisher
-     * @param p3
+     * @param source3
      *            a third source Publisher
-     * @param p4
+     * @param source4
      *            a fourth source Publisher
-     * @param p5
+     * @param source5
      *            a fifth source Publisher
-     * @param p6
+     * @param source6
      *            a sixth source Publisher
-     * @param p7
+     * @param source7
      *            a seventh source Publisher
-     * @param p8
+     * @param source8
      *            an eighth source Publisher
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source Publishers, results in
@@ -4465,11 +4465,11 @@ private static void verifyPositive(long value, String paramName) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Flowable<R> zip(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
-            Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
-            Publisher<? extends T7> p7, Publisher<? extends T8> p8,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,
+            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,
+            Publisher<? extends T7> source7, Publisher<? extends T8> source8,
             Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8);
     }
 
     /**
@@ -4517,23 +4517,23 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T8> the value type of the eighth source
      * @param <T9> the value type of the ninth source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source Publisher
-     * @param p2
+     * @param source2
      *            a second source Publisher
-     * @param p3
+     * @param source3
      *            a third source Publisher
-     * @param p4
+     * @param source4
      *            a fourth source Publisher
-     * @param p5
+     * @param source5
      *            a fifth source Publisher
-     * @param p6
+     * @param source6
      *            a sixth source Publisher
-     * @param p7
+     * @param source7
      *            a seventh source Publisher
-     * @param p8
+     * @param source8
      *            an eighth source Publisher
-     * @param p9
+     * @param source9
      *            a ninth source Publisher
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source Publishers, results in
@@ -4545,11 +4545,11 @@ private static void verifyPositive(long value, String paramName) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Flowable<R> zip(
-            Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
-            Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
-            Publisher<? extends T7> p7, Publisher<? extends T8> p8, Publisher<? extends T9> p9,
+            Publisher<? extends T1> source1, Publisher<? extends T2> source2, Publisher<? extends T3> source3,
+            Publisher<? extends T4> source4, Publisher<? extends T5> source5, Publisher<? extends T6> source6,
+            Publisher<? extends T7> source7, Publisher<? extends T8> source8, Publisher<? extends T9> source9,
             Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8, p9);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8, source9);
     }
 
     /**
@@ -4797,17 +4797,17 @@ public final T blockingFirst() {
      *  <dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @param defaultValue
+     * @param defaultItem
      *            a default value to return if this {@code Flowable} emits no items
      * @return the first item emitted by this {@code Flowable}, or the default value if it emits no
      *         items
      * @see <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX documentation: First</a>
      */
-    public final T blockingFirst(T defaultValue) {
+    public final T blockingFirst(T defaultItem) {
         BlockingFirstSubscriber<T> s = new BlockingFirstSubscriber<T>();
         subscribe(s);
         T v = s.blockingGet();
-        return v != null ? v : defaultValue;
+        return v != null ? v : defaultItem;
     }
 
     /**
@@ -4862,7 +4862,7 @@ public final void blockingForEach(Consumer<? super T> onNext) {
      *  <dd>The operator consumes the source {@code Flowable} in an unbounded manner
      *  (i.e., no backpressure applied to it).</dd>
      *  <dt><b>Scheduler:</b></dt>
-     *  <dd>{@code blockingITerable} does not operate by default on a particular {@link Scheduler}.</dd>
+     *  <dd>{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
      * @return an {@link Iterable} version of this {@code Flowable}
@@ -4934,20 +4934,17 @@ public final T blockingLast() {
      *  <dd>{@code blockingLast} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @param defaultValue
+     * @param defaultItem
      *            a default value to return if this {@code Flowable} emits no items
      * @return the last item emitted by the {@code Flowable}, or the default value if it emits no
      *         items
      * @see <a href="http://reactivex.io/documentation/operators/last.html">ReactiveX documentation: Last</a>
      */
-    public final T blockingLast(T defaultValue) {
+    public final T blockingLast(T defaultItem) {
         BlockingLastSubscriber<T> s = new BlockingLastSubscriber<T>();
         subscribe(s);
         T v = s.blockingGet();
-        if (v != null) {
-            return v;
-        }
-        return v != null ? v : defaultValue;
+        return v != null ? v : defaultItem;
     }
     
     /**
@@ -4987,15 +4984,15 @@ public final T blockingLast(T defaultValue) {
      *  <dd>{@code blockingMostRecent} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @param initialValue
-     *            the initial value that the {@link Iterable} sequence will yield if this
+     * @param initialItem
+     *            the initial item that the {@link Iterable} sequence will yield if this
      *            {@code Flowable} has not yet emitted an item
      * @return an {@link Iterable} that on each iteration returns the item that this {@code Flowable}
      *         has most recently emitted
      * @see <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX documentation: First</a>
      */
-    public final Iterable<T> blockingMostRecent(T initialValue) {
-        return BlockingFlowableMostRecent.mostRecent(this, initialValue);
+    public final Iterable<T> blockingMostRecent(T initialItem) {
+        return BlockingFlowableMostRecent.mostRecent(this, initialItem);
     }
     
     /**
@@ -5053,14 +5050,14 @@ public final T blockingSingle() {
      *  <dd>{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @param defaultValue
+     * @param defaultItem
      *            a default value to return if this {@code Flowable} emits no items
      * @return the single item emitted by this {@code Flowable}, or the default value if it emits no
      *         items
      * @see <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX documentation: First</a>
      */
-    public final T blockingSingle(T defaultValue) {
-        return single(defaultValue).blockingFirst();
+    public final T blockingSingle(T defaultItem) {
+        return single(defaultItem).blockingFirst();
     }
     
     /**
@@ -5304,7 +5301,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
     
     /**
      * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
-     * Publisher starts a new buffer periodically, as determined by the {@code timeshift} argument. It emits
+     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument. It emits
      * each buffer after a fixed timespan, specified by the {@code timespan} argument. When the source
      * Publisher completes or encounters an error, the resulting Publisher emits the current buffer and
      * propagates the notification from the source Publisher.
@@ -5323,7 +5320,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @param timeskip
      *            the period of time after which a new buffer will be created
      * @param unit
-     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments
+     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
      * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after
      *         a fixed timespan has elapsed
      * @see <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
@@ -5336,7 +5333,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
 
     /**
      * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
-     * Publisher starts a new buffer periodically, as determined by the {@code timeshift} argument, and on the
+     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the
      * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the
      * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting
      * Publisher emits the current buffer and propagates the notification from the source Publisher.
@@ -5355,7 +5352,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @param timeskip
      *            the period of time after which a new buffer will be created
      * @param unit
-     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments
+     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
      * @param scheduler
      *            the {@link Scheduler} to use when determining the end and start of a buffer
      * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after
@@ -5370,7 +5367,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
 
     /**
      * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
-     * Publisher starts a new buffer periodically, as determined by the {@code timeshift} argument, and on the
+     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the
      * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the
      * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting
      * Publisher emits the current buffer and propagates the notification from the source Publisher.
@@ -5390,7 +5387,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @param timeskip
      *            the period of time after which a new buffer will be created
      * @param unit
-     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments
+     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
      * @param scheduler
      *            the {@link Scheduler} to use when determining the end and start of a buffer
      * @param bufferSupplier
@@ -5597,8 +5594,8 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
 
     /**
      * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
-     * Publisher emits buffers that it creates when the specified {@code bufferOpenings} Publisher emits an
-     * item, and closes when the Publisher returned from {@code bufferClosingSelector} emits an item.
+     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an
+     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="470" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer2.png" alt="">
      * <dl>
@@ -5611,9 +5608,9 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * 
      * @param <TOpening> the element type of the buffer-opening Publisher
      * @param <TClosing> the element type of the individual buffer-closing Publishers
-     * @param bufferOpenings
+     * @param openingIndicator
      *            the Publisher that, when it emits an item, causes a new buffer to be created
-     * @param bufferClosingSelector
+     * @param closingIndicator
      *            the {@link Function} that is used to produce a Publisher for every buffer created. When this
      *            Publisher emits an item, the associated buffer is emitted.
      * @return a Flowable that emits buffers, containing items from the source Publisher, that are created
@@ -5623,15 +5620,15 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <TOpening, TClosing> Flowable<List<T>> buffer(
-            Flowable<? extends TOpening> bufferOpenings, 
-            Function<? super TOpening, ? extends Publisher<? extends TClosing>> bufferClosingSelector) {
-        return buffer(bufferOpenings, bufferClosingSelector, ArrayListSupplier.<T>asCallable());
+            Flowable<? extends TOpening> openingIndicator, 
+            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator) {
+        return buffer(openingIndicator, closingIndicator, ArrayListSupplier.<T>asCallable());
     }
 
     /**
      * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
-     * Publisher emits buffers that it creates when the specified {@code bufferOpenings} Publisher emits an
-     * item, and closes when the Publisher returned from {@code bufferClosingSelector} emits an item.
+     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an
+     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="470" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer2.png" alt="">
      * <dl>
@@ -5645,9 +5642,9 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @param <U> the collection subclass type to buffer into
      * @param <TOpening> the element type of the buffer-opening Publisher
      * @param <TClosing> the element type of the individual buffer-closing Publishers
-     * @param bufferOpenings
+     * @param openingIndicator
      *            the Publisher that, when it emits an item, causes a new buffer to be created
-     * @param bufferClosingSelector
+     * @param closingIndicator
      *            the {@link Function} that is used to produce a Publisher for every buffer created. When this
      *            Publisher emits an item, the associated buffer is emitted.
      * @param bufferSupplier
@@ -5660,13 +5657,13 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <TOpening, TClosing, U extends Collection<? super T>> Flowable<U> buffer(
-            Flowable<? extends TOpening> bufferOpenings, 
-            Function<? super TOpening, ? extends Publisher<? extends TClosing>> bufferClosingSelector,
+            Flowable<? extends TOpening> openingIndicator, 
+            Function<? super TOpening, ? extends Publisher<? extends TClosing>> closingIndicator,
             Callable<U> bufferSupplier) {
-        ObjectHelper.requireNonNull(bufferOpenings, "bufferOpenings is null");
-        ObjectHelper.requireNonNull(bufferClosingSelector, "bufferClosingSelector is null");
+        ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");
+        ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");
         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");
-        return RxJavaPlugins.onAssembly(new FlowableBufferBoundary<T, U, TOpening, TClosing>(this, bufferOpenings, bufferClosingSelector, bufferSupplier));
+        return RxJavaPlugins.onAssembly(new FlowableBufferBoundary<T, U, TOpening, TClosing>(this, openingIndicator, closingIndicator, bufferSupplier));
     }
 
     /**
@@ -5688,7 +5685,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * 
      * @param <B>
      *            the boundary value type (ignored)
-     * @param boundary
+     * @param boundaryIndicator
      *            the boundary Publisher
      * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher
      *         emits an item
@@ -5697,8 +5694,8 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <B> Flowable<List<T>> buffer(Publisher<B> boundary) {
-        return buffer(boundary, ArrayListSupplier.<T>asCallable());
+    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator) {
+        return buffer(boundaryIndicator, ArrayListSupplier.<T>asCallable());
     }
 
     /**
@@ -5720,7 +5717,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * 
      * @param <B>
      *            the boundary value type (ignored)
-     * @param boundary
+     * @param boundaryIndicator
      *            the boundary Publisher
      * @param initialCapacity
      *            the initial capacity of each buffer chunk
@@ -5731,8 +5728,8 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <B> Flowable<List<T>> buffer(Publisher<B> boundary, final int initialCapacity) {
-        return buffer(boundary, Functions.<T>createArrayList(initialCapacity));
+    public final <B> Flowable<List<T>> buffer(Publisher<B> boundaryIndicator, final int initialCapacity) {
+        return buffer(boundaryIndicator, Functions.<T>createArrayList(initialCapacity));
     }
 
     /**
@@ -5755,7 +5752,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @param <U> the collection subclass type to buffer into
      * @param <B>
      *            the boundary value type (ignored)
-     * @param boundary
+     * @param boundaryIndicator
      *            the boundary Publisher
      * @param bufferSupplier
      *            a factory function that returns an instance of the collection subclass to be used and returned
@@ -5767,16 +5764,16 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Publisher<B> boundary, Callable<U> bufferSupplier) {
-        ObjectHelper.requireNonNull(boundary, "boundary is null");
+    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Publisher<B> boundaryIndicator, Callable<U> bufferSupplier) {
+        ObjectHelper.requireNonNull(boundaryIndicator, "boundaryIndicator is null");
         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");
-        return RxJavaPlugins.onAssembly(new FlowableBufferExactBoundary<T, U, B>(this, boundary, bufferSupplier));
+        return RxJavaPlugins.onAssembly(new FlowableBufferExactBoundary<T, U, B>(this, boundaryIndicator, bufferSupplier));
     }
 
     /**
      * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
      * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a
-     * new buffer whenever the Publisher produced by the specified {@code bufferClosingSelector} emits an item.
+     * new buffer whenever the Publisher produced by the specified {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="395" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer1.png" alt="">
      * <dl>
@@ -5788,25 +5785,25 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * </dl>
      * 
      * @param <B> the value type of the boundary-providing Publisher
-     * @param boundarySupplier
+     * @param boundaryIndicatorSupplier
      *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.
      *            Whenever the source {@code Publisher} emits an item, {@code buffer} emits the current buffer and
      *            begins to fill a new one
      * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher
-     *         each time the Publisher created with the {@code bufferClosingSelector} argument emits an item
+     *         each time the Publisher created with the {@code closingIndicator} argument emits an item
      * @see <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
      */
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <B> Flowable<List<T>> buffer(Callable<? extends Publisher<B>> boundarySupplier) {
-        return buffer(boundarySupplier, ArrayListSupplier.<T>asCallable());
+    public final <B> Flowable<List<T>> buffer(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {
+        return buffer(boundaryIndicatorSupplier, ArrayListSupplier.<T>asCallable());
         
     }
 
     /**
      * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
      * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a
-     * new buffer whenever the Publisher produced by the specified {@code bufferClosingSelector} emits an item.
+     * new buffer whenever the Publisher produced by the specified {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="395" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer1.png" alt="">
      * <dl>
@@ -5819,7 +5816,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * 
      * @param <U> the collection subclass type to buffer into
      * @param <B> the value type of the boundary-providing Publisher
-     * @param boundarySupplier
+     * @param boundaryIndicatorSupplier
      *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.
      *            Whenever the source {@code Publisher} emits an item, {@code buffer} emits the current buffer and
      *            begins to fill a new one
@@ -5827,16 +5824,16 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *            a factory function that returns an instance of the collection subclass to be used and returned
      *            as the buffer
      * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher
-     *         each time the Publisher created with the {@code bufferClosingSelector} argument emits an item
+     *         each time the Publisher created with the {@code closingIndicator} argument emits an item
      * @see <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
      */
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Callable<? extends Publisher<B>> boundarySupplier, 
+    public final <B, U extends Collection<? super T>> Flowable<U> buffer(Callable<? extends Publisher<B>> boundaryIndicatorSupplier, 
             Callable<U> bufferSupplier) {
-        ObjectHelper.requireNonNull(boundarySupplier, "boundarySupplier is null");
+        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, "boundaryIndicatorSupplier is null");
         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");
-        return RxJavaPlugins.onAssembly(new FlowableBufferBoundarySupplier<T, U, B>(this, boundarySupplier, bufferSupplier));
+        return RxJavaPlugins.onAssembly(new FlowableBufferBoundarySupplier<T, U, B>(this, boundaryIndicatorSupplier, bufferSupplier));
     }
 
     /**
@@ -6002,7 +5999,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * </dl>
      * 
      * @param <U> the accumulator and output type
-     * @param initialValueSupplier
+     * @param initialItemSupplier
      *           the mutable data structure that will collect the items
      * @param collector
      *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}
@@ -6013,10 +6010,10 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <U> Flowable<U> collect(Callable<? extends U> initialValueSupplier, BiConsumer<? super U, ? super T> collector) {
-        ObjectHelper.requireNonNull(initialValueSupplier, "initialValueSupplier is null");
-        ObjectHelper.requireNonNull(collector, "collectior is null");
-        return RxJavaPlugins.onAssembly(new FlowableCollect<T, U>(this, initialValueSupplier, collector));
+    public final <U> Flowable<U> collect(Callable<? extends U> initialItemSupplier, BiConsumer<? super U, ? super T> collector) {
+        ObjectHelper.requireNonNull(initialItemSupplier, "initialItemSupplier is null");
+        ObjectHelper.requireNonNull(collector, "collector is null");
+        return RxJavaPlugins.onAssembly(new FlowableCollect<T, U>(this, initialItemSupplier, collector));
     }
 
     /**
@@ -6035,7 +6032,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * </dl>
      * 
      * @param <U> the accumulator and output type
-     * @param initialValue
+     * @param initialItem
      *           the mutable data structure that will collect the items
      * @param collector
      *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}
@@ -6046,9 +6043,9 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <U> Flowable<U> collectInto(final U initialValue, BiConsumer<? super U, ? super T> collector) {
-        ObjectHelper.requireNonNull(initialValue, "initialValue is null");
-        return collect(Functions.justCallable(initialValue), collector);
+    public final <U> Flowable<U> collectInto(final U initialItem, BiConsumer<? super U, ? super T> collector) {
+        ObjectHelper.requireNonNull(initialItem, "initialItem is null");
+        return collect(Functions.justCallable(initialItem), collector);
     }
 
     /**
@@ -6242,7 +6239,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be
      *               eagerly concatenated
      * @return the new Publisher instance with the specified concatenation behavior
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -6270,7 +6267,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @param maxConcurrency the maximum number of concurrent subscribed Publishers
      * @param prefetch hints about the number of expected source sequence values
      * @return the new Publisher instance with the specified concatenation behavior
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -6302,7 +6299,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *            if true, all errors from the outer and inner Publisher sources are delayed until the end,
      *            if false, an error from the main source is signalled when the current Publisher source terminates
      * @return the new Publisher instance with the specified concatenation behavior
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -6336,7 +6333,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *               all of them terminate, if false, exception from the current Flowable is delayed until the
      *               currently running Publisher terminates
      * @return the new Publisher instance with the specified concatenation behavior
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -6446,7 +6443,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *  <dd>{@code contains} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param element
+     * @param item
      *            the item to search for in the emissions from the source Publisher
      * @return a Flowable that emits {@code true} if the specified item is emitted by the source Publisher,
      *         or {@code false} if the source Publisher completes without emitting that item
@@ -6454,9 +6451,9 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<Boolean> contains(final Object element) {
-        ObjectHelper.requireNonNull(element, "o is null");
-        return any(Functions.equalsWith(element));
+    public final Flowable<Boolean> contains(final Object item) {
+        ObjectHelper.requireNonNull(item, "item is null");
+        return any(Functions.equalsWith(item));
     }
 
     /**
@@ -6498,7 +6495,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * 
      * @param <U>
      *            the debounce value type (ignored)
-     * @param debounceSelector
+     * @param debounceIndicator
      *            function to retrieve a sequence that indicates the throttle duration for each item
      * @return a Flowable that omits items emitted by the source Publisher that are followed by another item
      *         within a computed debounce duration
@@ -6507,9 +6504,9 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <U> Flowable<T> debounce(Function<? super T, ? extends Publisher<U>> debounceSelector) {
-        ObjectHelper.requireNonNull(debounceSelector, "debounceSelector is null");
-        return RxJavaPlugins.onAssembly(new FlowableDebounce<T, U>(this, debounceSelector));
+    public final <U> Flowable<T> debounce(Function<? super T, ? extends Publisher<U>> debounceIndicator) {
+        ObjectHelper.requireNonNull(debounceIndicator, "debounceIndicator is null");
+        return RxJavaPlugins.onAssembly(new FlowableDebounce<T, U>(this, debounceIndicator));
     }
 
     /**
@@ -6614,7 +6611,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *  <dd>{@code defaultIfEmpty} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param defaultValue
+     * @param defaultItem
      *            the item to emit if the source Publisher emits no items
      * @return a Flowable that emits either the specified default item if the source Publisher emits no
      *         items, or the items emitted by the source Publisher
@@ -6622,9 +6619,9 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> defaultIfEmpty(T defaultValue) {
-        ObjectHelper.requireNonNull(defaultValue, "value is null");
-        return switchIfEmpty(just(defaultValue));
+    public final Flowable<T> defaultIfEmpty(T defaultItem) {
+        ObjectHelper.requireNonNull(defaultItem, "item is null");
+        return switchIfEmpty(just(defaultItem));
     }
 
     /**
@@ -6646,7 +6643,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * 
      * @param <U>
      *            the item delay value type (ignored)
-     * @param itemDelay
+     * @param itemDelayIndicator
      *            a function that returns a Publisher for each item emitted by the source Publisher, which is
      *            then used to delay the emission of that item by the resulting Publisher until the Publisher
      *            returned from {@code itemDelay} emits an item
@@ -6656,9 +6653,9 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <U> Flowable<T> delay(final Function<? super T, ? extends Publisher<U>> itemDelay) {
-        ObjectHelper.requireNonNull(itemDelay, "itemDelay is null");
-        return flatMap(FlowableInternalHelper.itemDelay(itemDelay));
+    public final <U> Flowable<T> delay(final Function<? super T, ? extends Publisher<U>> itemDelayIndicator) {
+        ObjectHelper.requireNonNull(itemDelayIndicator, "itemDelayIndicator is null");
+        return flatMap(FlowableInternalHelper.itemDelay(itemDelayIndicator));
     }
 
     /**
@@ -6795,10 +6792,10 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *            the subscription delay value type (ignored)
      * @param <V>
      *            the item delay value type (ignored)
-     * @param subscriptionDelay
+     * @param subscriptionIndicator
      *            a function that returns a Publisher that triggers the subscription to the source Publisher
      *            once it emits any item
-     * @param itemDelay
+     * @param itemDelayIndicator
      *            a function that returns a Publisher for each item emitted by the source Publisher, which is
      *            then used to delay the emission of that item by the resulting Publisher until the Publisher
      *            returned from {@code itemDelay} emits an item
@@ -6808,9 +6805,9 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <U, V> Flowable<T> delay(Publisher<U> subscriptionDelay,
-            Function<? super T, ? extends Publisher<V>> itemDelay) {
-        return delaySubscription(subscriptionDelay).delay(itemDelay);
+    public final <U, V> Flowable<T> delay(Publisher<U> subscriptionIndicator,
+            Function<? super T, ? extends Publisher<V>> itemDelayIndicator) {
+        return delaySubscription(subscriptionIndicator).delay(itemDelayIndicator);
     }
     
     /**
@@ -6826,15 +6823,15 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * </dl>
      * 
      * @param <U> the value type of the other Publisher, irrelevant
-     * @param other the other Publisher that should trigger the subscription
+     * @param subscriptionIndicator the other Publisher that should trigger the subscription
      *        to this Publisher.
      * @return a Flowable that delays the subscription to this Publisher
      *         until the other Publisher emits an element or completes normally.
      * @since 2.0
      */
-    public final <U> Flowable<T> delaySubscription(Publisher<U> other) {
-        ObjectHelper.requireNonNull(other, "other is null");
-        return RxJavaPlugins.onAssembly(new FlowableDelaySubscriptionOther<T, U>(this, other));
+    public final <U> Flowable<T> delaySubscription(Publisher<U> subscriptionIndicator) {
+        ObjectHelper.requireNonNull(subscriptionIndicator, "subscriptionIndicator is null");
+        return RxJavaPlugins.onAssembly(new FlowableDelaySubscriptionOther<T, U>(this, subscriptionIndicator));
     }
 
     /**
@@ -7066,8 +7063,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @return a Flowable that emits those items from the source Publisher that are distinct from their
      *         immediate predecessors
      * @see <a href="http://reactivex.io/documentation/operators/distinct.html">ReactiveX operators documentation: Distinct</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical
-     *        with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -7089,7 +7085,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *  <dd>{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @param onFinally
+     * @param onAfterTerminate
      *            an {@link Action} to be invoked when the source Publisher finishes
      * @return a Flowable that emits the same items as the source Publisher, then invokes the
      *         {@link Action}
@@ -7098,9 +7094,9 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> doAfterTerminate(Action onFinally) {
+    public final Flowable<T> doAfterTerminate(Action onAfterTerminate) {
         return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(), 
-                Functions.EMPTY_ACTION, onFinally);
+                Functions.EMPTY_ACTION, onAfterTerminate);
     }
 
     /**
@@ -7131,7 +7127,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Flowable<T> doOnCancel(Action onCancel) {
-        return doOnLifecycle(Functions.emptyConsumer(), Functions.EMPTY_LONGCONSUMER, onCancel);
+        return doOnLifecycle(Functions.emptyConsumer(), Functions.EMPTY_LONG_CONSUMER, onCancel);
     }
 
     /**
@@ -7231,7 +7227,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *  <dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param observer
+     * @param subscriber
      *            the observer to be notified about onNext, onError and onCompleted events on its
      *            respective methods before the actual downstream Subscriber gets notified.
      * @return the source Publisher with the side-effecting behavior applied
@@ -7239,12 +7235,12 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> doOnEach(final Subscriber<? super T> observer) {
-        ObjectHelper.requireNonNull(observer, "observer is null");
+    public final Flowable<T> doOnEach(final Subscriber<? super T> subscriber) {
+        ObjectHelper.requireNonNull(subscriber, "subscriber is null");
         return doOnEach(
-                FlowableInternalHelper.subscriberOnNext(observer),
-                FlowableInternalHelper.subscriberOnError(observer),
-                FlowableInternalHelper.subscriberOnComplete(observer),
+                FlowableInternalHelper.subscriberOnNext(subscriber),
+                FlowableInternalHelper.subscriberOnError(subscriber),
+                FlowableInternalHelper.subscriberOnComplete(subscriber),
                 Functions.EMPTY_ACTION);
     }
 
@@ -7351,8 +7347,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @return the source {@code Publisher} modified so as to call this Action when appropriate
      * @see <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators
      *      documentation: Do</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical
-     *        with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -7383,7 +7378,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Flowable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) {
-        return doOnLifecycle(onSubscribe, Functions.EMPTY_LONGCONSUMER, Functions.EMPTY_ACTION);
+        return doOnLifecycle(onSubscribe, Functions.EMPTY_LONG_CONSUMER, Functions.EMPTY_ACTION);
     }
 
     /**
@@ -7462,7 +7457,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * 
      * @param index
      *            the zero-based index of the item to retrieve
-     * @param defaultValue
+     * @param defaultItem
      *            the default item
      * @return a Flowable that emits the item at the specified position in the sequence emitted by the source
      *         Publisher, or the default item if that index is outside the bounds of the source sequence
@@ -7472,12 +7467,12 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> elementAt(long index, T defaultValue) {
+    public final Flowable<T> elementAt(long index, T defaultItem) {
         if (index < 0) {
             throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);
         }
-        ObjectHelper.requireNonNull(defaultValue, "defaultValue is null");
-        return RxJavaPlugins.onAssembly(new FlowableElementAt<T>(this, index, defaultValue));
+        ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");
+        return RxJavaPlugins.onAssembly(new FlowableElementAt<T>(this, index, defaultItem));
     }
 
     /**
@@ -7542,7 +7537,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *  <dd>{@code firstOrDefault} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param defaultValue
+     * @param defaultItem
      *            the default item to emit if the source Publisher doesn't emit anything
      * @return a Flowable that emits only the very first item from the source, or a default item if the
      *         source Publisher completes without emitting any items
@@ -7550,8 +7545,8 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      */
     @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> first(T defaultValue) {
-        return take(1).single(defaultValue);
+    public final Flowable<T> first(T defaultItem) {
+        return take(1).single(defaultItem);
     }
 
     /**
@@ -7642,7 +7637,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *         by the source Publisher and merging the results of the Publishers obtained from this
      *         transformation
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -7678,7 +7673,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *         by the source Publisher and merging the results of the Publishers obtained from this
      *         transformation
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -7716,7 +7711,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *         by the source Publisher and merging the results of the Publishers obtained from this
      *         transformation
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -7805,7 +7800,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @return a Flowable that emits the results of merging the Publishers returned from applying the
      *         specified functions to the emissions and notifications of the source Publisher
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -7921,7 +7916,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @return a Flowable that emits the results of applying a function to a pair of values emitted by the
      *         source Publisher and the collection Publisher
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -7959,11 +7954,11 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate
      *            if false, the first one signalling an exception will terminate the whole sequence immediately
      * @param bufferSize
-     *            the number of elements to prefetch from the innner Publishers.
+     *            the number of elements to prefetch from the inner Publishers.
      * @return a Flowable that emits the results of applying a function to a pair of values emitted by the
      *         source Publisher and the collection Publisher
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -8002,7 +7997,7 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      * @return a Flowable that emits the results of applying a function to a pair of values emitted by the
      *         source Publisher and the collection Publisher
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -8136,10 +8131,8 @@ public final void blockingSubscribe(Subscriber<? super T> subscriber) {
      *            the number of elements to prefetch from the current Flowable
      * @return a Flowable that emits the results of merging the items emitted by the source Publisher with
      *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}
-     * @throws IllegalArgumentException
-     *             if {@code maxConcurrent} is less than or equal to 0
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -8440,7 +8433,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, 
             Function<? super T, ? extends V> valueSelector, boolean delayError) {
-        return groupBy(keySelector, valueSelector, false, bufferSize());
+        return groupBy(keySelector, valueSelector, delayError, bufferSize());
     }
 
     /**
@@ -8692,7 +8685,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
      *  <dd>{@code lastOrDefault} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param defaultValue
+     * @param defaultItem
      *            the default item to emit if the source Publisher is empty
      * @return a Flowable that emits only the last item emitted by the source Publisher, or a default item
      *         if the source Publisher is empty
@@ -8700,8 +8693,8 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
      */
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> last(T defaultValue) {
-        return takeLast(1).single(defaultValue);
+    public final Flowable<T> last(T defaultItem) {
+        return takeLast(1).single(defaultItem);
     }
 
     /**
@@ -8864,7 +8857,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
      *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception
      *  pops up; look for sources up the chain that don't support backpressure, 
      *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any
-     *  of the {@code onBackpressureXXX} opertors <strong>before</strong> applying {@code observeOn} itself.</dd>
+     *  of the {@code onBackpressureXXX} operators <strong>before</strong> applying {@code observeOn} itself.</dd>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>you specify which {@link Scheduler} this operator will use</dd>
      * </dl>
@@ -8900,7 +8893,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
      *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception
      *  pops up; look for sources up the chain that don't support backpressure, 
      *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any
-     *  of the {@code onBackpressureXXX} opertors <strong>before</strong> applying {@code observeOn} itself.</dd>
+     *  of the {@code onBackpressureXXX} operators <strong>before</strong> applying {@code observeOn} itself.</dd>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>you specify which {@link Scheduler} this operator will use</dd>
      * </dl>
@@ -8943,7 +8936,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
      * @param <U> the output type
      * @param clazz
      *            the class type to filter the items emitted by the source Publisher
-     * @return a Flowable that emits items from the source Publisher of type {@code klass}
+     * @return a Flowable that emits items from the source Publisher of type {@code clazz}
      * @see <a href="http://reactivex.io/documentation/operators/filter.html">ReactiveX operators documentation: Filter</a>
      */
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
@@ -8997,7 +8990,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Flowable<T> onBackpressureBuffer(boolean delayError) {
-        return onBackpressureBuffer(bufferSize(), true, true);
+        return onBackpressureBuffer(bufferSize(), delayError, true);
     }
 
     /**
@@ -9053,7 +9046,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Flowable<T> onBackpressureBuffer(int capacity, boolean delayError) {
-        return onBackpressureBuffer(capacity, true, false);
+        return onBackpressureBuffer(capacity, delayError, false);
     }
 
     /**
@@ -9422,7 +9415,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
      *  <dd>{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param value
+     * @param item
      *            the value that is emitted along with a regular onComplete in case the current
      *            Flowable signals an exception
      * @return the original Publisher with appropriately modified behavior
@@ -9430,9 +9423,9 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> onErrorReturnValue(final T value) {
-        ObjectHelper.requireNonNull(value, "value is null");
-        return onErrorReturn(Functions.justFunction(value));
+    public final Flowable<T> onErrorReturnItem(final T item) {
+        ObjectHelper.requireNonNull(item, "item is null");
+        return onErrorReturn(Functions.justFunction(item));
     }
 
     /**
@@ -9492,7 +9485,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
      * </dl>
      * @return a Flowable which out references to the upstream producer and downstream Subscriber if
      * the sequence is terminated or downstream unsubscribes
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.PASS_THROUGH)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -9635,7 +9628,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, final Co
      *  
      * @param n the initial request amount, further request will happen after 75% of this value
      * @return the Publisher that rebatches request amounts from downstream
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -11001,7 +10994,7 @@ public final void safeSubscribe(Subscriber<? super T> s) {
      *  <dd>{@code singleOrDefault} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param defaultValue
+     * @param defaultItem
      *            a default value to emit if the source Publisher emits no item
      * @return a Flowable that emits the single item emitted by the source Publisher, or a default item if
      *         the source Publisher is empty
@@ -11011,9 +11004,9 @@ public final void safeSubscribe(Subscriber<? super T> s) {
      */
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> single(T defaultValue) {
-        ObjectHelper.requireNonNull(defaultValue, "defaultValue is null");
-        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(this, defaultValue));
+    public final Flowable<T> single(T defaultItem) {
+        ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");
+        return RxJavaPlugins.onAssembly(new FlowableSingle<T>(this, defaultItem));
     }
     
     /**
@@ -11423,7 +11416,7 @@ public final void safeSubscribe(Subscriber<? super T> s) {
      *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param values
+     * @param items
      *            an Iterable that contains the items you want the modified Publisher to emit first
      * @return a Flowable that emits the items in the specified {@link Iterable} and then emits the items
      *         emitted by the source Publisher
@@ -11432,8 +11425,8 @@ public final void safeSubscribe(Subscriber<? super T> s) {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> startWith(Iterable<? extends T> values) {
-        return concatArray(fromIterable(values), this);
+    public final Flowable<T> startWith(Iterable<? extends T> items) {
+        return concatArray(fromIterable(items), this);
     }
 
     /**
@@ -11488,7 +11481,7 @@ public final void safeSubscribe(Subscriber<? super T> s) {
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Flowable<T> startWith(T value) {
-        ObjectHelper.requireNonNull(value, "value is null");
+        ObjectHelper.requireNonNull(value, "item is null");
         return concatArray(just(value), this);
     }
 
@@ -11506,7 +11499,7 @@ public final void safeSubscribe(Subscriber<? super T> s) {
      *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param values
+     * @param items
      *            the array of values to emit first
      * @return a Flowable that emits the specified items before it begins to emit items emitted by the source
      *         Publisher
@@ -11515,8 +11508,8 @@ public final void safeSubscribe(Subscriber<? super T> s) {
     @SuppressWarnings("unchecked")
     @BackpressureSupport(BackpressureKind.FULL)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Flowable<T> startWithArray(T... values) {
-        Flowable<T> fromArray = fromArray(values);
+    public final Flowable<T> startWithArray(T... items) {
+        Flowable<T> fromArray = fromArray(items);
         if (fromArray == empty()) {
             return RxJavaPlugins.onAssembly(this);
         }
@@ -13153,7 +13146,7 @@ public final void subscribe(Subscriber<? super T> s) {
      * <p>
      * This allows fluent conversion to any other type.
      * @param <R> the resulting object type
-     * @param converter the function that receives the current Flowable instance and returns a vlau
+     * @param converter the function that receives the current Flowable instance and returns a value
      * @return the value returned by the function
      */
     @BackpressureSupport(BackpressureKind.SPECIAL)
@@ -13187,8 +13180,7 @@ public final void subscribe(Subscriber<? super T> s) {
      *         calls onCompleted
      * @see <a href="http://reactivex.io/documentation/completable.html">ReactiveX documentation:
      *      Completable</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical
-     *        with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -13573,7 +13565,7 @@ public final Completable toCompletable() {
      * @throws NoSuchElementException
      *             if the source Publisher emits no items
      * @see <a href="http://reactivex.io/documentation/single.html">ReactiveX documentation: Single</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -13656,7 +13648,7 @@ public final Completable toCompletable() {
      * @return a Flowable that emits a list that contains the items emitted by the source Publisher in
      *         sorted order
      * @see <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -13687,7 +13679,7 @@ public final Completable toCompletable() {
      *             if any item emitted by the Publisher does not implement {@link Comparable} with respect to
      *             all other items emitted by the Publisher
      * @see <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 2.0
      */
     @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -13816,7 +13808,7 @@ public final Completable toCompletable() {
     
     /**
      * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
-     * Publisher starts a new window periodically, as determined by the {@code timeshift} argument. It emits
+     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits
      * each window after a fixed timespan, specified by the {@code timespan} argument. When the source
      * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the
      * current window and propagates the notification from the source Publisher.
@@ -13838,7 +13830,7 @@ public final Completable toCompletable() {
      * @param timeskip
      *            the period of time after which a new window will be created
      * @param unit
-     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments
+     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
      * @return a Flowable that emits new windows periodically as a fixed timespan elapses
      * @see <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
      */
@@ -13850,7 +13842,7 @@ public final Completable toCompletable() {
     
     /**
      * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
-     * Publisher starts a new window periodically, as determined by the {@code timeshift} argument. It emits
+     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits
      * each window after a fixed timespan, specified by the {@code timespan} argument. When the source
      * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the
      * current window and propagates the notification from the source Publisher.
@@ -13872,7 +13864,7 @@ public final Completable toCompletable() {
      * @param timeskip
      *            the period of time after which a new window will be created
      * @param unit
-     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments
+     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
      * @param scheduler
      *            the {@link Scheduler} to use when determining the end and start of a window
      * @return a Flowable that emits new windows periodically as a fixed timespan elapses
@@ -13886,7 +13878,7 @@ public final Completable toCompletable() {
     
     /**
      * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
-     * Publisher starts a new window periodically, as determined by the {@code timeshift} argument. It emits
+     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits
      * each window after a fixed timespan, specified by the {@code timespan} argument. When the source
      * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the
      * current window and propagates the notification from the source Publisher.
@@ -13908,7 +13900,7 @@ public final Completable toCompletable() {
      * @param timeskip
      *            the period of time after which a new window will be created
      * @param unit
-     *            the unit of time that applies to the {@code timespan} and {@code timeshift} arguments
+     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
      * @param scheduler
      *            the {@link Scheduler} to use when determining the end and start of a window
      * @param bufferSize
@@ -14213,7 +14205,7 @@ public final Completable toCompletable() {
      * 
      * @param <B>
      *            the window element type (ignored)
-     * @param boundary
+     * @param boundaryIndicator
      *            a Publisher whose emitted items close and open windows
      * @return a Flowable that emits non-overlapping windows of items it collects from the source Publisher
      *         where the boundary of each window is determined by the items emitted from the {@code boundary}
@@ -14222,8 +14214,8 @@ public final Completable toCompletable() {
      */
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundary) {
-        return window(boundary, bufferSize());
+    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundaryIndicator) {
+        return window(boundaryIndicator, bufferSize());
     }
 
     /**
@@ -14242,7 +14234,7 @@ public final Completable toCompletable() {
      * 
      * @param <B>
      *            the window element type (ignored)
-     * @param boundary
+     * @param boundaryIndicator
      *            a Publisher whose emitted items close and open windows
      * @param bufferSize
      *            the capacity hint for the buffer in the inner windows
@@ -14253,9 +14245,9 @@ public final Completable toCompletable() {
      */
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundary, int bufferSize) {
-        ObjectHelper.requireNonNull(boundary, "boundary is null");
-        return RxJavaPlugins.onAssembly(new FlowableWindowBoundary<T, B>(this, boundary, bufferSize));
+    public final <B> Flowable<Flowable<T>> window(Publisher<B> boundaryIndicator, int bufferSize) {
+        ObjectHelper.requireNonNull(boundaryIndicator, "boundaryIndicator is null");
+        return RxJavaPlugins.onAssembly(new FlowableWindowBoundary<T, B>(this, boundaryIndicator, bufferSize));
     }
 
     /**
@@ -14277,9 +14269,9 @@ public final Completable toCompletable() {
      * 
      * @param <U> the element type of the window-opening Publisher
      * @param <V> the element type of the window-closing Publishers
-     * @param windowOpen
+     * @param openingIndicator
      *            a Publisher that, when it emits an item, causes another window to be created
-     * @param windowClose
+     * @param closingIndicator
      *            a {@link Function} that produces a Publisher for every window created. When this Publisher
      *            emits an item, the associated window is closed and emitted
      * @return a Flowable that emits windows of items emitted by the source Publisher that are governed by
@@ -14289,9 +14281,9 @@ public final Completable toCompletable() {
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <U, V> Flowable<Flowable<T>> window(
-            Publisher<U> windowOpen, 
-            Function<? super U, ? extends Publisher<V>> windowClose) {
-        return window(windowOpen, windowClose, bufferSize());
+            Publisher<U> openingIndicator, 
+            Function<? super U, ? extends Publisher<V>> closingIndicator) {
+        return window(openingIndicator, closingIndicator, bufferSize());
     }
 
     /**
@@ -14313,9 +14305,9 @@ public final Completable toCompletable() {
      * 
      * @param <U> the element type of the window-opening Publisher
      * @param <V> the element type of the window-closing Publishers
-     * @param windowOpen
+     * @param openingIndicator
      *            a Publisher that, when it emits an item, causes another window to be created
-     * @param windowClose
+     * @param closingIndicator
      *            a {@link Function} that produces a Publisher for every window created. When this Publisher
      *            emits an item, the associated window is closed and emitted
      * @param bufferSize
@@ -14327,11 +14319,11 @@ public final Completable toCompletable() {
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <U, V> Flowable<Flowable<T>> window(
-            Publisher<U> windowOpen, 
-            Function<? super U, ? extends Publisher<V>> windowClose, int bufferSize) {
-        ObjectHelper.requireNonNull(windowOpen, "windowOpen is null");
-        ObjectHelper.requireNonNull(windowClose, "windowClose is null");
-        return RxJavaPlugins.onAssembly(new FlowableWindowBoundarySelector<T, U, V>(this, windowOpen, windowClose, bufferSize));
+            Publisher<U> openingIndicator, 
+            Function<? super U, ? extends Publisher<V>> closingIndicator, int bufferSize) {
+        ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");
+        ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");
+        return RxJavaPlugins.onAssembly(new FlowableWindowBoundarySelector<T, U, V>(this, openingIndicator, closingIndicator, bufferSize));
     }
     
     /**
@@ -14352,7 +14344,7 @@ public final Completable toCompletable() {
      * </dl>
      * 
      * @param <B> the element type of the boundary Publisher
-     * @param boundary
+     * @param boundaryIndicatorSupplier
      *            a {@link Callable} that returns an {@code Publisher} that governs the boundary between windows.
      *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins
      *            a new one.
@@ -14362,8 +14354,8 @@ public final Completable toCompletable() {
      */
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundary) {
-        return window(boundary, bufferSize());
+    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier) {
+        return window(boundaryIndicatorSupplier, bufferSize());
     }
 
     /**
@@ -14384,7 +14376,7 @@ public final Completable toCompletable() {
      * </dl>
      * 
      * @param <B> the element type of the boundary Publisher
-     * @param boundary
+     * @param boundaryIndicatorSupplier
      *            a {@link Callable} that returns an {@code Publisher} that governs the boundary between windows.
      *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins
      *            a new one.
@@ -14396,9 +14388,9 @@ public final Completable toCompletable() {
      */
     @BackpressureSupport(BackpressureKind.ERROR)
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundary, int bufferSize) {
-        ObjectHelper.requireNonNull(boundary, "boundary is null");
-        return RxJavaPlugins.onAssembly(new FlowableWindowBoundarySupplier<T, B>(this, boundary, bufferSize));
+    public final <B> Flowable<Flowable<T>> window(Callable<? extends Publisher<B>> boundaryIndicatorSupplier, int bufferSize) {
+        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, "boundaryIndicatorSupplier is null");
+        return RxJavaPlugins.onAssembly(new FlowableWindowBoundarySupplier<T, B>(this, boundaryIndicatorSupplier, bufferSize));
     }
 
     /**
@@ -14459,16 +14451,16 @@ public final Completable toCompletable() {
      * @param <T1> the first other source's value type
      * @param <T2> the second other source's value type
      * @param <R> the result value type
-     * @param p1 the first other Publisher
-     * @param p2 the second other Publisher
+     * @param source1 the first other Publisher
+     * @param source2 the second other Publisher
      * @param combiner the function called with an array of values from each participating Publisher
      * @return the new Publisher instance
      * @since 2.0
      */
-    public final <T1, T2, R> Flowable<R> withLatestFrom(Publisher<T1> p1, Publisher<T2> p2, 
+    public final <T1, T2, R> Flowable<R> withLatestFrom(Publisher<T1> source1, Publisher<T2> source2, 
             Function3<? super T, ? super T1, ? super T2, R> combiner) {
         Function<Object[], R> f = Functions.toFunction(combiner);
-        return withLatestFrom(new Publisher[] { p1, p2 }, f);
+        return withLatestFrom(new Publisher[] { source1, source2 }, f);
     }
 
     /**
@@ -14492,19 +14484,19 @@ public final Completable toCompletable() {
      * @param <T2> the second other source's value type
      * @param <T3> the third other source's value type
      * @param <R> the result value type
-     * @param p1 the first other Publisher
-     * @param p2 the second other Publisher
-     * @param p3 the third other Publisher
+     * @param source1 the first other Publisher
+     * @param source2 the second other Publisher
+     * @param source3 the third other Publisher
      * @param combiner the function called with an array of values from each participating Publisher
      * @return the new Publisher instance
      * @since 2.0
      */
     public final <T1, T2, T3, R> Flowable<R> withLatestFrom(
-            Publisher<T1> p1, Publisher<T2> p2, 
-            Publisher<T3> p3, 
+            Publisher<T1> source1, Publisher<T2> source2, 
+            Publisher<T3> source3, 
             Function4<? super T, ? super T1, ? super T2, ? super T3, R> combiner) {
         Function<Object[], R> f = Functions.toFunction(combiner);
-        return withLatestFrom(new Publisher[] { p1, p2, p3 }, f);
+        return withLatestFrom(new Publisher[] { source1, source2, source3 }, f);
     }
 
     /**
@@ -14529,20 +14521,20 @@ public final Completable toCompletable() {
      * @param <T3> the third other source's value type
      * @param <T4> the fourth other source's value type
      * @param <R> the result value type
-     * @param p1 the first other Publisher
-     * @param p2 the second other Publisher
-     * @param p3 the third other Publisher
-     * @param p4 the fourth other Publisher
+     * @param source1 the first other Publisher
+     * @param source2 the second other Publisher
+     * @param source3 the third other Publisher
+     * @param source4 the fourth other Publisher
      * @param combiner the function called with an array of values from each participating Publisher
      * @return the new Publisher instance
      * @since 2.0
      */
     public final <T1, T2, T3, T4, R> Flowable<R> withLatestFrom(
-            Publisher<T1> p1, Publisher<T2> p2, 
-            Publisher<T3> p3, Publisher<T4> p4, 
+            Publisher<T1> source1, Publisher<T2> source2, 
+            Publisher<T3> source3, Publisher<T4> source4, 
             Function5<? super T, ? super T1, ? super T2, ? super T3, ? super T4, R> combiner) {
         Function<Object[], R> f = Functions.toFunction(combiner);
-        return withLatestFrom(new Publisher[] { p1, p2, p3, p4 }, f);
+        return withLatestFrom(new Publisher[] { source1, source2, source3, source4 }, f);
     }
 
     /**
diff --git a/src/main/java/io/reactivex/FlowableEmitter.java b/src/main/java/io/reactivex/FlowableEmitter.java
index a2988affe8..45e64554a7 100644
--- a/src/main/java/io/reactivex/FlowableEmitter.java
+++ b/src/main/java/io/reactivex/FlowableEmitter.java
@@ -24,7 +24,7 @@
  * The onNext, onError and onComplete methods should be called 
  * in a sequential manner, just like the Subscriber's methods.
  * Use {@link #serialize()} if you want to ensure this. 
- * The other methods are threadsafe.
+ * The other methods are thread-safe.
  *
  * @param <T> the value type to emit
  */
@@ -45,13 +45,14 @@
     void setCancellable(Cancellable c);
     /**
      * The current outstanding request amount.
-     * <p>This method it threadsafe.
+     * <p>This method is thread-safe.
      * @return the current outstanding request amount
      */
     long requested();
     
     /**
      * Returns true if the downstream cancelled the sequence.
+     * <p>This method is thread-safe.
      * @return true if the downstream cancelled the sequence
      */
     boolean isCancelled();
diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java
index 579abe1deb..0b5079d529 100644
--- a/src/main/java/io/reactivex/Observable.java
+++ b/src/main/java/io/reactivex/Observable.java
@@ -291,9 +291,9 @@ public static int bufferSize() {
      * @param <T1> the element type of the first source
      * @param <T2> the element type of the second source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            the second source ObservableSource
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source ObservableSources
@@ -304,9 +304,9 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, R> Observable<R> combineLatest(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2,
             BiFunction<? super T1, ? super T2, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), bufferSize(), p1, p2);
+        return combineLatest(Functions.toFunction(combiner), bufferSize(), source1, source2);
     }
     
     /**
@@ -324,11 +324,11 @@ public static int bufferSize() {
      * @param <T2> the element type of the second source
      * @param <T3> the element type of the third source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            the second source ObservableSource
-     * @param p3
+     * @param source3
      *            the third source ObservableSource
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source ObservableSources
@@ -339,10 +339,10 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, R> Observable<R> combineLatest(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2,
-            ObservableSource<? extends T3> p3,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2,
+            ObservableSource<? extends T3> source3,
             Function3<? super T1, ? super T2, ? super T3, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), bufferSize(), p1, p2, p3);
+        return combineLatest(Functions.toFunction(combiner), bufferSize(), source1, source2, source3);
     }
     
     /**
@@ -361,13 +361,13 @@ public static int bufferSize() {
      * @param <T3> the element type of the third source
      * @param <T4> the element type of the fourth source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            the second source ObservableSource
-     * @param p3
+     * @param source3
      *            the third source ObservableSource
-     * @param p4
+     * @param source4
      *            the fourth source ObservableSource
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source ObservableSources
@@ -378,10 +378,10 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, R> Observable<R> combineLatest(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2,
-            ObservableSource<? extends T3> p3, ObservableSource<? extends T4> p4,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2,
+            ObservableSource<? extends T3> source3, ObservableSource<? extends T4> source4,
             Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), bufferSize(), p1, p2, p3, p4);
+        return combineLatest(Functions.toFunction(combiner), bufferSize(), source1, source2, source3, source4);
     }
     
     /**
@@ -401,15 +401,15 @@ public static int bufferSize() {
      * @param <T4> the element type of the fourth source
      * @param <T5> the element type of the fifth source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            the second source ObservableSource
-     * @param p3
+     * @param source3
      *            the third source ObservableSource
-     * @param p4
+     * @param source4
      *            the fourth source ObservableSource
-     * @param p5
+     * @param source5
      *            the fifth source ObservableSource
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source ObservableSources
@@ -420,11 +420,11 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, R> Observable<R> combineLatest(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2,
-            ObservableSource<? extends T3> p3, ObservableSource<? extends T4> p4,
-            ObservableSource<? extends T5> p5,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2,
+            ObservableSource<? extends T3> source3, ObservableSource<? extends T4> source4,
+            ObservableSource<? extends T5> source5,
             Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), bufferSize(), p1, p2, p3, p4, p5);
+        return combineLatest(Functions.toFunction(combiner), bufferSize(), source1, source2, source3, source4, source5);
     }
     
     /**
@@ -445,17 +445,17 @@ public static int bufferSize() {
      * @param <T5> the element type of the fifth source
      * @param <T6> the element type of the sixth source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            the second source ObservableSource
-     * @param p3
+     * @param source3
      *            the third source ObservableSource
-     * @param p4
+     * @param source4
      *            the fourth source ObservableSource
-     * @param p5
+     * @param source5
      *            the fifth source ObservableSource
-     * @param p6
+     * @param source6
      *            the sixth source ObservableSource
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source ObservableSources
@@ -466,11 +466,11 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, R> Observable<R> combineLatest(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2,
-            ObservableSource<? extends T3> p3, ObservableSource<? extends T4> p4,
-            ObservableSource<? extends T5> p5, ObservableSource<? extends T6> p6,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2,
+            ObservableSource<? extends T3> source3, ObservableSource<? extends T4> source4,
+            ObservableSource<? extends T5> source5, ObservableSource<? extends T6> source6,
             Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), bufferSize(), p1, p2, p3, p4, p5, p6);
+        return combineLatest(Functions.toFunction(combiner), bufferSize(), source1, source2, source3, source4, source5, source6);
     }
     
     /**
@@ -492,19 +492,19 @@ public static int bufferSize() {
      * @param <T6> the element type of the sixth source
      * @param <T7> the element type of the seventh source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            the second source ObservableSource
-     * @param p3
+     * @param source3
      *            the third source ObservableSource
-     * @param p4
+     * @param source4
      *            the fourth source ObservableSource
-     * @param p5
+     * @param source5
      *            the fifth source ObservableSource
-     * @param p6
+     * @param source6
      *            the sixth source ObservableSource
-     * @param p7
+     * @param source7
      *            the seventh source ObservableSource
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source ObservableSources
@@ -515,12 +515,12 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, R> Observable<R> combineLatest(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2,
-            ObservableSource<? extends T3> p3, ObservableSource<? extends T4> p4,
-            ObservableSource<? extends T5> p5, ObservableSource<? extends T6> p6,
-            ObservableSource<? extends T7> p7,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2,
+            ObservableSource<? extends T3> source3, ObservableSource<? extends T4> source4,
+            ObservableSource<? extends T5> source5, ObservableSource<? extends T6> source6,
+            ObservableSource<? extends T7> source7,
             Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), bufferSize(), p1, p2, p3, p4, p5, p6, p7);
+        return combineLatest(Functions.toFunction(combiner), bufferSize(), source1, source2, source3, source4, source5, source6, source7);
     }
 
     /**
@@ -543,21 +543,21 @@ public static int bufferSize() {
      * @param <T7> the element type of the seventh source
      * @param <T8> the element type of the eighth source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            the second source ObservableSource
-     * @param p3
+     * @param source3
      *            the third source ObservableSource
-     * @param p4
+     * @param source4
      *            the fourth source ObservableSource
-     * @param p5
+     * @param source5
      *            the fifth source ObservableSource
-     * @param p6
+     * @param source6
      *            the sixth source ObservableSource
-     * @param p7
+     * @param source7
      *            the seventh source ObservableSource
-     * @param p8
+     * @param source8
      *            the eighth source ObservableSource
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source ObservableSources
@@ -568,12 +568,12 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Observable<R> combineLatest(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2,
-            ObservableSource<? extends T3> p3, ObservableSource<? extends T4> p4,
-            ObservableSource<? extends T5> p5, ObservableSource<? extends T6> p6,
-            ObservableSource<? extends T7> p7, ObservableSource<? extends T8> p8,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2,
+            ObservableSource<? extends T3> source3, ObservableSource<? extends T4> source4,
+            ObservableSource<? extends T5> source5, ObservableSource<? extends T6> source6,
+            ObservableSource<? extends T7> source7, ObservableSource<? extends T8> source8,
             Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8);
+        return combineLatest(Functions.toFunction(combiner), bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8);
     }
 
     /**
@@ -597,23 +597,23 @@ public static int bufferSize() {
      * @param <T8> the element type of the eighth source
      * @param <T9> the element type of the ninth source
      * @param <R> the combined output type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            the second source ObservableSource
-     * @param p3
+     * @param source3
      *            the third source ObservableSource
-     * @param p4
+     * @param source4
      *            the fourth source ObservableSource
-     * @param p5
+     * @param source5
      *            the fifth source ObservableSource
-     * @param p6
+     * @param source6
      *            the sixth source ObservableSource
-     * @param p7
+     * @param source7
      *            the seventh source ObservableSource
-     * @param p8
+     * @param source8
      *            the eighth source ObservableSource
-     * @param p9
+     * @param source9
      *            the ninth source ObservableSource
      * @param combiner
      *            the aggregation function used to combine the items emitted by the source ObservableSources
@@ -624,13 +624,13 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Observable<R> combineLatest(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2,
-            ObservableSource<? extends T3> p3, ObservableSource<? extends T4> p4,
-            ObservableSource<? extends T5> p5, ObservableSource<? extends T6> p6,
-            ObservableSource<? extends T7> p7, ObservableSource<? extends T8> p8,
-            ObservableSource<? extends T9> p9,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2,
+            ObservableSource<? extends T3> source3, ObservableSource<? extends T4> source4,
+            ObservableSource<? extends T5> source5, ObservableSource<? extends T6> source6,
+            ObservableSource<? extends T7> source7, ObservableSource<? extends T8> source8,
+            ObservableSource<? extends T9> source9,
             Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> combiner) {
-        return combineLatest(Functions.toFunction(combiner), bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8, p9);
+        return combineLatest(Functions.toFunction(combiner), bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8, source9);
     }
 
     /**
@@ -833,7 +833,7 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> concat(ObservableSource<? extends ObservableSource<? extends T>> sources) {
+    public static <T> Observable<T> concat(ObservableSource<? extends ObservableSource<? extends T>> sources) {
         return concat(sources, bufferSize());
     }
 
@@ -858,7 +858,7 @@ public static int bufferSize() {
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> concat(ObservableSource<? extends ObservableSource<? extends T>> sources, int prefetch) {
+    public static <T> Observable<T> concat(ObservableSource<? extends ObservableSource<? extends T>> sources, int prefetch) {
         ObjectHelper.requireNonNull(sources, "sources is null");
         return RxJavaPlugins.onAssembly(new ObservableConcatMap(sources, Functions.identity(), prefetch, ErrorMode.IMMEDIATE));
     }
@@ -874,9 +874,9 @@ public static int bufferSize() {
      * </dl>
      *
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a ObservableSource to be concatenated
-     * @param p2
+     * @param source2
      *            a ObservableSource to be concatenated
      * @return a Observable that emits items emitted by the two source ObservableSources, one after the other,
      *         without interleaving them
@@ -884,8 +884,8 @@ public static int bufferSize() {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Observable<T> concat(ObservableSource<? extends T> p1, ObservableSource<? extends T> p2) {
-        return concatArray(p1, p2);
+    public static <T> Observable<T> concat(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2) {
+        return concatArray(source1, source2);
     }
 
     /**
@@ -899,11 +899,11 @@ public static int bufferSize() {
      * </dl>
      *
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a ObservableSource to be concatenated
-     * @param p2
+     * @param source2
      *            a ObservableSource to be concatenated
-     * @param p3
+     * @param source3
      *            a ObservableSource to be concatenated
      * @return a Observable that emits items emitted by the three source ObservableSources, one after the other,
      *         without interleaving them
@@ -912,9 +912,9 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Observable<T> concat(
-            ObservableSource<? extends T> p1, ObservableSource<? extends T> p2,
-            ObservableSource<? extends T> p3) {
-        return concatArray(p1, p2, p3);
+            ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,
+            ObservableSource<? extends T> source3) {
+        return concatArray(source1, source2, source3);
     }
 
     /**
@@ -928,13 +928,13 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a ObservableSource to be concatenated
-     * @param p2
+     * @param source2
      *            a ObservableSource to be concatenated
-     * @param p3
+     * @param source3
      *            a ObservableSource to be concatenated
-     * @param p4
+     * @param source4
      *            a ObservableSource to be concatenated
      * @return a Observable that emits items emitted by the four source ObservableSources, one after the other,
      *         without interleaving them
@@ -943,9 +943,9 @@ public static int bufferSize() {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Observable<T> concat(
-            ObservableSource<? extends T> p1, ObservableSource<? extends T> p2,
-            ObservableSource<? extends T> p3, ObservableSource<? extends T> p4) {
-        return concatArray(p1, p2, p3, p4);
+            ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,
+            ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) {
+        return concatArray(source1, source2, source3, source4);
     }
 
     /**
@@ -1072,7 +1072,7 @@ public static int bufferSize() {
      * @return the new ObservableSource with the concatenating behavior
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> concatDelayError(ObservableSource<? extends ObservableSource<? extends T>> sources) {
+    public static <T> Observable<T> concatDelayError(ObservableSource<? extends ObservableSource<? extends T>> sources) {
         return concatDelayError(sources, bufferSize(), true);
     }
 
@@ -1094,7 +1094,7 @@ public static int bufferSize() {
      */
     @SuppressWarnings({ "rawtypes", "unchecked" })
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> concatDelayError(ObservableSource<? extends ObservableSource<? extends T>> sources, int prefetch, boolean tillTheEnd) {
+    public static <T> Observable<T> concatDelayError(ObservableSource<? extends ObservableSource<? extends T>> sources, int prefetch, boolean tillTheEnd) {
         return RxJavaPlugins.onAssembly(new ObservableConcatMap(sources, Functions.identity(), prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));
     }
 
@@ -1215,7 +1215,7 @@ public static int bufferSize() {
      * </code></pre>
      * <p>
      * You should call the ObservableEmitter's onNext, onError and onComplete methods in a serialized fashion. The
-     * rest of its methods are threadsafe.
+     * rest of its methods are thread-safe.
      * 
      * @param <T> the element type
      * @param source the emitter that is called when an Observer subscribes to the returned {@code Observable}
@@ -1339,7 +1339,7 @@ public static int bufferSize() {
      *  <dd>{@code from} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param values
+     * @param items
      *            the array of elements
      * @param <T>
      *            the type of items in the Array and the type of items to be emitted by the resulting ObservableSource
@@ -1347,15 +1347,15 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Observable<T> fromArray(T... values) {
-        ObjectHelper.requireNonNull(values, "values is null");
-        if (values.length == 0) {
+    public static <T> Observable<T> fromArray(T... items) {
+        ObjectHelper.requireNonNull(items, "items is null");
+        if (items.length == 0) {
             return empty();
         } else
-        if (values.length == 1) {
-            return just(values[0]);
+        if (items.length == 1) {
+            return just(items[0]);
         }
-        return RxJavaPlugins.onAssembly(new ObservableFromArray<T>(values));
+        return RxJavaPlugins.onAssembly(new ObservableFromArray<T>(items));
     }
 
     /**
@@ -1688,7 +1688,7 @@ public static int bufferSize() {
             Consumer<? super S> disposeState) {
         ObjectHelper.requireNonNull(initialState, "initialState is null");
         ObjectHelper.requireNonNull(generator, "generator  is null");
-        ObjectHelper.requireNonNull(disposeState, "diposeState is null");
+        ObjectHelper.requireNonNull(disposeState, "disposeState is null");
         return RxJavaPlugins.onAssembly(new ObservableGenerate<T, S>(initialState, generator, disposeState));
     }
 
@@ -1873,7 +1873,7 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param value
+     * @param item
      *            the item to emit
      * @param <T>
      *            the type of that item
@@ -1881,9 +1881,9 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Observable<T> just(T value) {
-        ObjectHelper.requireNonNull(value, "The value is null");
-        return RxJavaPlugins.onAssembly(new ObservableJust<T>(value));
+    public static <T> Observable<T> just(T item) {
+        ObjectHelper.requireNonNull(item, "The item is null");
+        return RxJavaPlugins.onAssembly(new ObservableJust<T>(item));
     }
 
     /**
@@ -1895,9 +1895,9 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
      * @param <T>
      *            the type of these items
@@ -1906,11 +1906,11 @@ public static int bufferSize() {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> just(T v1, T v2) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
+    public static <T> Observable<T> just(T item1, T item2) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
         
-        return fromArray(v1, v2);
+        return fromArray(item1, item2);
     }
 
     /**
@@ -1922,11 +1922,11 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
      * @param <T>
      *            the type of these items
@@ -1935,12 +1935,12 @@ public static int bufferSize() {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> just(T v1, T v2, T v3) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
+    public static <T> Observable<T> just(T item1, T item2, T item3) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
         
-        return fromArray(v1, v2, v3);
+        return fromArray(item1, item2, item3);
     }
 
     /**
@@ -1952,13 +1952,13 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
      * @param <T>
      *            the type of these items
@@ -1967,13 +1967,13 @@ public static int bufferSize() {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
+    public static <T> Observable<T> just(T item1, T item2, T item3, T item4) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
         
-        return fromArray(v1, v2, v3, v4);
+        return fromArray(item1, item2, item3, item4);
     }
 
     /**
@@ -1985,15 +1985,15 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
      * @param <T>
      *            the type of these items
@@ -2002,14 +2002,14 @@ public static int bufferSize() {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
+    public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
         
-        return fromArray(v1, v2, v3, v4, v5);
+        return fromArray(item1, item2, item3, item4, item5);
     }
 
     /**
@@ -2021,17 +2021,17 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
-     * @param v6
+     * @param item6
      *            sixth item
      * @param <T>
      *            the type of these items
@@ -2040,15 +2040,15 @@ public static int bufferSize() {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
-        ObjectHelper.requireNonNull(v6, "The sixth value is null");
+    public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5, T item6) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
+        ObjectHelper.requireNonNull(item6, "The sixth item is null");
         
-        return fromArray(v1, v2, v3, v4, v5, v6);
+        return fromArray(item1, item2, item3, item4, item5, item6);
     }
 
     /**
@@ -2060,19 +2060,19 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
-     * @param v6
+     * @param item6
      *            sixth item
-     * @param v7
+     * @param item7
      *            seventh item
      * @param <T>
      *            the type of these items
@@ -2081,16 +2081,16 @@ public static int bufferSize() {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
-        ObjectHelper.requireNonNull(v6, "The sixth value is null");
-        ObjectHelper.requireNonNull(v7, "The seventh value is null");
+    public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
+        ObjectHelper.requireNonNull(item6, "The sixth item is null");
+        ObjectHelper.requireNonNull(item7, "The seventh item is null");
         
-        return fromArray(v1, v2, v3, v4, v5, v6, v7);
+        return fromArray(item1, item2, item3, item4, item5, item6, item7);
     }
 
     /**
@@ -2102,21 +2102,21 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
-     * @param v6
+     * @param item6
      *            sixth item
-     * @param v7
+     * @param item7
      *            seventh item
-     * @param v8
+     * @param item8
      *            eighth item
      * @param <T>
      *            the type of these items
@@ -2125,17 +2125,17 @@ public static int bufferSize() {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
-        ObjectHelper.requireNonNull(v6, "The sixth value is null");
-        ObjectHelper.requireNonNull(v7, "The seventh value is null");
-        ObjectHelper.requireNonNull(v8, "The eighth value is null");
+    public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
+        ObjectHelper.requireNonNull(item6, "The sixth item is null");
+        ObjectHelper.requireNonNull(item7, "The seventh item is null");
+        ObjectHelper.requireNonNull(item8, "The eighth item is null");
         
-        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8);
+        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8);
     }
 
     /**
@@ -2147,23 +2147,23 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
-     * @param v6
+     * @param item6
      *            sixth item
-     * @param v7
+     * @param item7
      *            seventh item
-     * @param v8
+     * @param item8
      *            eighth item
-     * @param v9
+     * @param item9
      *            ninth item
      * @param <T>
      *            the type of these items
@@ -2172,18 +2172,18 @@ public static int bufferSize() {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
-        ObjectHelper.requireNonNull(v6, "The sixth value is null");
-        ObjectHelper.requireNonNull(v7, "The seventh value is null");
-        ObjectHelper.requireNonNull(v8, "The eighth value is null");
-        ObjectHelper.requireNonNull(v9, "The ninth is null");
+    public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
+        ObjectHelper.requireNonNull(item6, "The sixth item is null");
+        ObjectHelper.requireNonNull(item7, "The seventh item is null");
+        ObjectHelper.requireNonNull(item8, "The eighth item is null");
+        ObjectHelper.requireNonNull(item9, "The ninth item is null");
         
-        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9);
+        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9);
     }
 
     /**
@@ -2195,25 +2195,25 @@ public static int bufferSize() {
      *  <dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param v1
+     * @param item1
      *            first item
-     * @param v2
+     * @param item2
      *            second item
-     * @param v3
+     * @param item3
      *            third item
-     * @param v4
+     * @param item4
      *            fourth item
-     * @param v5
+     * @param item5
      *            fifth item
-     * @param v6
+     * @param item6
      *            sixth item
-     * @param v7
+     * @param item7
      *            seventh item
-     * @param v8
+     * @param item8
      *            eighth item
-     * @param v9
+     * @param item9
      *            ninth item
-     * @param v10
+     * @param item10
      *            tenth item
      * @param <T>
      *            the type of these items
@@ -2222,19 +2222,19 @@ public static int bufferSize() {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9, T v10) {
-        ObjectHelper.requireNonNull(v1, "The first value is null");
-        ObjectHelper.requireNonNull(v2, "The second value is null");
-        ObjectHelper.requireNonNull(v3, "The third value is null");
-        ObjectHelper.requireNonNull(v4, "The fourth value is null");
-        ObjectHelper.requireNonNull(v5, "The fifth value is null");
-        ObjectHelper.requireNonNull(v6, "The sixth value is null");
-        ObjectHelper.requireNonNull(v7, "The seventh value is null");
-        ObjectHelper.requireNonNull(v8, "The eighth value is null");
-        ObjectHelper.requireNonNull(v9, "The ninth is null");
-        ObjectHelper.requireNonNull(v10, "The tenth is null");
+    public static <T> Observable<T> just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10) {
+        ObjectHelper.requireNonNull(item1, "The first item is null");
+        ObjectHelper.requireNonNull(item2, "The second item is null");
+        ObjectHelper.requireNonNull(item3, "The third item is null");
+        ObjectHelper.requireNonNull(item4, "The fourth item is null");
+        ObjectHelper.requireNonNull(item5, "The fifth item is null");
+        ObjectHelper.requireNonNull(item6, "The sixth item is null");
+        ObjectHelper.requireNonNull(item7, "The seventh item is null");
+        ObjectHelper.requireNonNull(item8, "The eighth item is null");
+        ObjectHelper.requireNonNull(item9, "The ninth item is null");
+        ObjectHelper.requireNonNull(item10, "The tenth item is null");
         
-        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
+        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);
     }
 
     /**
@@ -2426,19 +2426,19 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a ObservableSource to be merged
-     * @param p2
+     * @param source2
      *            a ObservableSource to be merged
      * @return a Observable that emits all of the items emitted by the source ObservableSources
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Observable<T> merge(ObservableSource<? extends T> p1, ObservableSource<? extends T> p2) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        return fromArray(p1, p2).flatMap((Function)Functions.identity(), false, 2);
+    public static <T> Observable<T> merge(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        return fromArray(source1, source2).flatMap((Function)Functions.identity(), false, 2);
     }
 
     /**
@@ -2454,22 +2454,22 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a ObservableSource to be merged
-     * @param p2
+     * @param source2
      *            a ObservableSource to be merged
-     * @param p3
+     * @param source3
      *            a ObservableSource to be merged
      * @return a Observable that emits all of the items emitted by the source ObservableSources
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Observable<T> merge(ObservableSource<? extends T> p1, ObservableSource<? extends T> p2, ObservableSource<? extends T> p3) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        ObjectHelper.requireNonNull(p3, "p3 is null");
-        return fromArray(p1, p2, p3).flatMap((Function)Functions.identity(), false, 3);
+    public static <T> Observable<T> merge(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), false, 3);
     }
 
     /**
@@ -2485,13 +2485,13 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a ObservableSource to be merged
-     * @param p2
+     * @param source2
      *            a ObservableSource to be merged
-     * @param p3
+     * @param source3
      *            a ObservableSource to be merged
-     * @param p4
+     * @param source4
      *            a ObservableSource to be merged
      * @return a Observable that emits all of the items emitted by the source ObservableSources
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
@@ -2499,13 +2499,13 @@ public static int bufferSize() {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Observable<T> merge(
-            ObservableSource<? extends T> p1, ObservableSource<? extends T> p2,
-            ObservableSource<? extends T> p3, ObservableSource<? extends T> p4) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        ObjectHelper.requireNonNull(p3, "p3 is null");
-        ObjectHelper.requireNonNull(p4, "p4 is null");
-        return fromArray(p1, p2, p3, p4).flatMap((Function)Functions.identity(), false, 4);
+            ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,
+            ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), false, 4);
     }
 
     /**
@@ -2750,19 +2750,19 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a ObservableSource to be merged
-     * @param p2
+     * @param source2
      *            a ObservableSource to be merged
      * @return a Observable that emits all of the items that are emitted by the two source ObservableSources
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Observable<T> mergeDelayError(ObservableSource<? extends T> p1, ObservableSource<? extends T> p2) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        return fromArray(p1, p2).flatMap((Function)Functions.identity(), true, 2);
+    public static <T> Observable<T> mergeDelayError(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        return fromArray(source1, source2).flatMap((Function)Functions.identity(), true, 2);
     }
 
     /**
@@ -2785,22 +2785,22 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a ObservableSource to be merged
-     * @param p2
+     * @param source2
      *            a ObservableSource to be merged
-     * @param p3
+     * @param source3
      *            a ObservableSource to be merged
      * @return a Observable that emits all of the items that are emitted by the source ObservableSources
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Observable<T> mergeDelayError(ObservableSource<? extends T> p1, ObservableSource<? extends T> p2, ObservableSource<? extends T> p3) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        ObjectHelper.requireNonNull(p3, "p3 is null");
-        return fromArray(p1, p2, p3).flatMap((Function)Functions.identity(), true, 3);
+    public static <T> Observable<T> mergeDelayError(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), true, 3);
     }
 
     /**
@@ -2823,13 +2823,13 @@ public static int bufferSize() {
      * </dl>
      * 
      * @param <T> the common element base type
-     * @param p1
+     * @param source1
      *            a ObservableSource to be merged
-     * @param p2
+     * @param source2
      *            a ObservableSource to be merged
-     * @param p3
+     * @param source3
      *            a ObservableSource to be merged
-     * @param p4
+     * @param source4
      *            a ObservableSource to be merged
      * @return a Observable that emits all of the items that are emitted by the source ObservableSources
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
@@ -2837,13 +2837,13 @@ public static int bufferSize() {
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T> Observable<T> mergeDelayError(
-            ObservableSource<? extends T> p1, ObservableSource<? extends T> p2,
-            ObservableSource<? extends T> p3, ObservableSource<? extends T> p4) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
-        ObjectHelper.requireNonNull(p3, "p3 is null");
-        ObjectHelper.requireNonNull(p4, "p4 is null");
-        return fromArray(p1, p2, p3, p4).flatMap((Function)Functions.identity(), true, 4);
+            ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,
+            ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) {
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), true, 4);
     }
 
     /**
@@ -2945,9 +2945,9 @@ public static int bufferSize() {
      *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param p1
+     * @param source1
      *            the first ObservableSource to compare
-     * @param p2
+     * @param source2
      *            the second ObservableSource to compare
      * @param <T>
      *            the type of items emitted by each ObservableSource
@@ -2955,8 +2955,8 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/sequenceequal.html">ReactiveX operators documentation: SequenceEqual</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Observable<Boolean> sequenceEqual(ObservableSource<? extends T> p1, ObservableSource<? extends T> p2) {
-        return sequenceEqual(p1, p2, ObjectHelper.equalsPredicate(), bufferSize());
+    public static <T> Observable<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2) {
+        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize());
     }
 
     /**
@@ -2970,9 +2970,9 @@ public static int bufferSize() {
      *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param p1
+     * @param source1
      *            the first ObservableSource to compare
-     * @param p2
+     * @param source2
      *            the second ObservableSource to compare
      * @param isEqual
      *            a function used to compare items emitted by each ObservableSource
@@ -2983,9 +2983,9 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/sequenceequal.html">ReactiveX operators documentation: SequenceEqual</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Observable<Boolean> sequenceEqual(ObservableSource<? extends T> p1, ObservableSource<? extends T> p2, 
+    public static <T> Observable<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, 
             BiPredicate<? super T, ? super T> isEqual) {
-        return sequenceEqual(p1, p2, isEqual, bufferSize());
+        return sequenceEqual(source1, source2, isEqual, bufferSize());
     }
 
     /**
@@ -2999,9 +2999,9 @@ public static int bufferSize() {
      *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param p1
+     * @param source1
      *            the first ObservableSource to compare
-     * @param p2
+     * @param source2
      *            the second ObservableSource to compare
      * @param isEqual
      *            a function used to compare items emitted by each ObservableSource
@@ -3014,13 +3014,13 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/sequenceequal.html">ReactiveX operators documentation: SequenceEqual</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Observable<Boolean> sequenceEqual(ObservableSource<? extends T> p1, ObservableSource<? extends T> p2, 
+    public static <T> Observable<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, 
             BiPredicate<? super T, ? super T> isEqual, int bufferSize) {
-        ObjectHelper.requireNonNull(p1, "p1 is null");
-        ObjectHelper.requireNonNull(p2, "p2 is null");
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
         ObjectHelper.requireNonNull(isEqual, "isEqual is null");
         verifyPositive(bufferSize, "bufferSize");
-        return RxJavaPlugins.onAssembly(new ObservableSequenceEqual<T>(p1, p2, isEqual, bufferSize));
+        return RxJavaPlugins.onAssembly(new ObservableSequenceEqual<T>(source1, source2, isEqual, bufferSize));
     }
 
     /**
@@ -3033,9 +3033,9 @@ public static int bufferSize() {
      *  <dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param p1
+     * @param source1
      *            the first ObservableSource to compare
-     * @param p2
+     * @param source2
      *            the second ObservableSource to compare
      * @param bufferSize
      *            the number of items to prefetch from the first and second source ObservableSource
@@ -3045,9 +3045,9 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/sequenceequal.html">ReactiveX operators documentation: SequenceEqual</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T> Observable<Boolean> sequenceEqual(ObservableSource<? extends T> p1, ObservableSource<? extends T> p2, 
+    public static <T> Observable<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, 
             int bufferSize) {
-        return sequenceEqual(p1, p2, ObjectHelper.equalsPredicate(), bufferSize);
+        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize);
     }
 
     /**
@@ -3496,9 +3496,9 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T1> the value type of the first source
      * @param <T2> the value type of the second source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            a second source ObservableSource
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source ObservableSources, results
@@ -3509,9 +3509,9 @@ private static void verifyPositive(long value, String paramName) {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, R> Observable<R> zip(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2,
             BiFunction<? super T1, ? super T2, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2);
     }
 
     /**
@@ -3548,9 +3548,9 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T1> the value type of the first source
      * @param <T2> the value type of the second source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            a second source ObservableSource
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source ObservableSources, results
@@ -3562,9 +3562,9 @@ private static void verifyPositive(long value, String paramName) {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, R> Observable<R> zip(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2,
             BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError) {
-        return zipArray(Functions.toFunction(zipper), delayError, bufferSize(), p1, p2);
+        return zipArray(Functions.toFunction(zipper), delayError, bufferSize(), source1, source2);
     }
 
     /**
@@ -3601,9 +3601,9 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T1> the value type of the first source
      * @param <T2> the value type of the second source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            a second source ObservableSource
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source ObservableSources, results
@@ -3616,9 +3616,9 @@ private static void verifyPositive(long value, String paramName) {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, R> Observable<R> zip(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2,
             BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError, int bufferSize) {
-        return zipArray(Functions.toFunction(zipper), delayError, bufferSize, p1, p2);
+        return zipArray(Functions.toFunction(zipper), delayError, bufferSize, source1, source2);
     }
 
     /**
@@ -3657,11 +3657,11 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T2> the value type of the second source
      * @param <T3> the value type of the third source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            a second source ObservableSource
-     * @param p3
+     * @param source3
      *            a third source ObservableSource
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source ObservableSources, results in
@@ -3672,9 +3672,9 @@ private static void verifyPositive(long value, String paramName) {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, R> Observable<R> zip(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2, ObservableSource<? extends T3> p3,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2, ObservableSource<? extends T3> source3,
             Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3);
     }
 
     /**
@@ -3714,13 +3714,13 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T3> the value type of the third source
      * @param <T4> the value type of the fourth source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            a second source ObservableSource
-     * @param p3
+     * @param source3
      *            a third source ObservableSource
-     * @param p4
+     * @param source4
      *            a fourth source ObservableSource
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source ObservableSources, results in
@@ -3731,10 +3731,10 @@ private static void verifyPositive(long value, String paramName) {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, R> Observable<R> zip(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2, ObservableSource<? extends T3> p3,
-            ObservableSource<? extends T4> p4,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2, ObservableSource<? extends T3> source3,
+            ObservableSource<? extends T4> source4,
             Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4);
     }
 
     /**
@@ -3775,15 +3775,15 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T4> the value type of the fourth source
      * @param <T5> the value type of the fifth source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            a second source ObservableSource
-     * @param p3
+     * @param source3
      *            a third source ObservableSource
-     * @param p4
+     * @param source4
      *            a fourth source ObservableSource
-     * @param p5
+     * @param source5
      *            a fifth source ObservableSource
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source ObservableSources, results in
@@ -3794,10 +3794,10 @@ private static void verifyPositive(long value, String paramName) {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, R> Observable<R> zip(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2, ObservableSource<? extends T3> p3,
-            ObservableSource<? extends T4> p4, ObservableSource<? extends T5> p5,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2, ObservableSource<? extends T3> source3,
+            ObservableSource<? extends T4> source4, ObservableSource<? extends T5> source5,
             Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5);
     }
 
     /**
@@ -3838,17 +3838,17 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T5> the value type of the fifth source
      * @param <T6> the value type of the sixth source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            a second source ObservableSource
-     * @param p3
+     * @param source3
      *            a third source ObservableSource
-     * @param p4
+     * @param source4
      *            a fourth source ObservableSource
-     * @param p5
+     * @param source5
      *            a fifth source ObservableSource
-     * @param p6
+     * @param source6
      *            a sixth source ObservableSource
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source ObservableSources, results in
@@ -3859,10 +3859,10 @@ private static void verifyPositive(long value, String paramName) {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, R> Observable<R> zip(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2, ObservableSource<? extends T3> p3,
-            ObservableSource<? extends T4> p4, ObservableSource<? extends T5> p5, ObservableSource<? extends T6> p6,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2, ObservableSource<? extends T3> source3,
+            ObservableSource<? extends T4> source4, ObservableSource<? extends T5> source5, ObservableSource<? extends T6> source6,
             Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6);
     }
 
     /**
@@ -3904,19 +3904,19 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T6> the value type of the sixth source
      * @param <T7> the value type of the seventh source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            a second source ObservableSource
-     * @param p3
+     * @param source3
      *            a third source ObservableSource
-     * @param p4
+     * @param source4
      *            a fourth source ObservableSource
-     * @param p5
+     * @param source5
      *            a fifth source ObservableSource
-     * @param p6
+     * @param source6
      *            a sixth source ObservableSource
-     * @param p7
+     * @param source7
      *            a seventh source ObservableSource
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source ObservableSources, results in
@@ -3927,11 +3927,11 @@ private static void verifyPositive(long value, String paramName) {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, R> Observable<R> zip(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2, ObservableSource<? extends T3> p3,
-            ObservableSource<? extends T4> p4, ObservableSource<? extends T5> p5, ObservableSource<? extends T6> p6,
-            ObservableSource<? extends T7> p7,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2, ObservableSource<? extends T3> source3,
+            ObservableSource<? extends T4> source4, ObservableSource<? extends T5> source5, ObservableSource<? extends T6> source6,
+            ObservableSource<? extends T7> source7,
             Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6, p7);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7);
     }
 
     /**
@@ -3974,21 +3974,21 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T7> the value type of the seventh source
      * @param <T8> the value type of the eighth source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            a second source ObservableSource
-     * @param p3
+     * @param source3
      *            a third source ObservableSource
-     * @param p4
+     * @param source4
      *            a fourth source ObservableSource
-     * @param p5
+     * @param source5
      *            a fifth source ObservableSource
-     * @param p6
+     * @param source6
      *            a sixth source ObservableSource
-     * @param p7
+     * @param source7
      *            a seventh source ObservableSource
-     * @param p8
+     * @param source8
      *            an eighth source ObservableSource
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source ObservableSources, results in
@@ -3999,11 +3999,11 @@ private static void verifyPositive(long value, String paramName) {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Observable<R> zip(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2, ObservableSource<? extends T3> p3,
-            ObservableSource<? extends T4> p4, ObservableSource<? extends T5> p5, ObservableSource<? extends T6> p6,
-            ObservableSource<? extends T7> p7, ObservableSource<? extends T8> p8,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2, ObservableSource<? extends T3> source3,
+            ObservableSource<? extends T4> source4, ObservableSource<? extends T5> source5, ObservableSource<? extends T6> source6,
+            ObservableSource<? extends T7> source7, ObservableSource<? extends T8> source8,
             Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8);
     }
 
     /**
@@ -4047,23 +4047,23 @@ private static void verifyPositive(long value, String paramName) {
      * @param <T8> the value type of the eighth source
      * @param <T9> the value type of the ninth source
      * @param <R> the zipped result type
-     * @param p1
+     * @param source1
      *            the first source ObservableSource
-     * @param p2
+     * @param source2
      *            a second source ObservableSource
-     * @param p3
+     * @param source3
      *            a third source ObservableSource
-     * @param p4
+     * @param source4
      *            a fourth source ObservableSource
-     * @param p5
+     * @param source5
      *            a fifth source ObservableSource
-     * @param p6
+     * @param source6
      *            a sixth source ObservableSource
-     * @param p7
+     * @param source7
      *            a seventh source ObservableSource
-     * @param p8
+     * @param source8
      *            an eighth source ObservableSource
-     * @param p9
+     * @param source9
      *            a ninth source ObservableSource
      * @param zipper
      *            a function that, when applied to an item emitted by each of the source ObservableSources, results in
@@ -4074,11 +4074,11 @@ private static void verifyPositive(long value, String paramName) {
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Observable<R> zip(
-            ObservableSource<? extends T1> p1, ObservableSource<? extends T2> p2, ObservableSource<? extends T3> p3,
-            ObservableSource<? extends T4> p4, ObservableSource<? extends T5> p5, ObservableSource<? extends T6> p6,
-            ObservableSource<? extends T7> p7, ObservableSource<? extends T8> p8, ObservableSource<? extends T9> p9,
+            ObservableSource<? extends T1> source1, ObservableSource<? extends T2> source2, ObservableSource<? extends T3> source3,
+            ObservableSource<? extends T4> source4, ObservableSource<? extends T5> source5, ObservableSource<? extends T6> source6,
+            ObservableSource<? extends T7> source7, ObservableSource<? extends T8> source8, ObservableSource<? extends T9> source9,
             Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> zipper) {
-        return zipArray(Functions.toFunction(zipper), false, bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8, p9);
+        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8, source9);
     }
 
     /**
@@ -4298,17 +4298,17 @@ public final T blockingFirst() {
      *  <dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @param defaultValue
+     * @param defaultItem
      *            a default value to return if this {@code Observable} emits no items
      * @return the first item emitted by this {@code Observable}, or the default value if it emits no
      *         items
      * @see <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX documentation: First</a>
      */
-    public final T blockingFirst(T defaultValue) {
+    public final T blockingFirst(T defaultItem) {
         BlockingFirstObserver<T> s = new BlockingFirstObserver<T>();
         subscribe(s);
         T v = s.blockingGet();
-        return v != null ? v : defaultValue;
+        return v != null ? v : defaultItem;
     }
 
     /**
@@ -4420,20 +4420,17 @@ public final T blockingLast() {
      *  <dd>{@code blockingLast} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @param defaultValue
+     * @param defaultItem
      *            a default value to return if this {@code Observable} emits no items
      * @return the last item emitted by the {@code Observable}, or the default value if it emits no
      *         items
      * @see <a href="http://reactivex.io/documentation/operators/last.html">ReactiveX documentation: Last</a>
      */
-    public final T blockingLast(T defaultValue) {
+    public final T blockingLast(T defaultItem) {
         BlockingLastObserver<T> s = new BlockingLastObserver<T>();
         subscribe(s);
         T v = s.blockingGet();
-        if (v != null) {
-            return v;
-        }
-        return v != null ? v : defaultValue;
+        return v != null ? v : defaultItem;
     }
     
     /**
@@ -4524,14 +4521,14 @@ public final T blockingSingle() {
      *  <dd>{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      *
-     * @param defaultValue
+     * @param defaultItem
      *            a default value to return if this {@code Observable} emits no items
      * @return the single item emitted by this {@code Observable}, or the default value if it emits no
      *         items
      * @see <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX documentation: First</a>
      */
-    public final T blockingSingle(T defaultValue) {
-        return single(defaultValue).blockingFirst();
+    public final T blockingSingle(T defaultItem) {
+        return single(defaultItem).blockingFirst();
     }
     
     /**
@@ -5005,8 +5002,8 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
 
     /**
      * Returns a Observable that emits buffers of items it collects from the source ObservableSource. The resulting
-     * ObservableSource emits buffers that it creates when the specified {@code bufferOpenings} ObservableSource emits an
-     * item, and closes when the ObservableSource returned from {@code bufferClosingSelector} emits an item.
+     * ObservableSource emits buffers that it creates when the specified {@code openingIndicator} ObservableSource emits an
+     * item, and closes when the ObservableSource returned from {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="470" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer2.png" alt="">
      * <dl>
@@ -5016,9 +5013,9 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      * 
      * @param <TOpening> the element type of the buffer-opening ObservableSource
      * @param <TClosing> the element type of the individual buffer-closing ObservableSources
-     * @param bufferOpenings
+     * @param openingIndicator
      *            the ObservableSource that, when it emits an item, causes a new buffer to be created
-     * @param bufferClosingSelector
+     * @param closingIndicator
      *            the {@link Function} that is used to produce a ObservableSource for every buffer created. When this
      *            ObservableSource emits an item, the associated buffer is emitted.
      * @return a Observable that emits buffers, containing items from the source ObservableSource, that are created
@@ -5027,15 +5024,15 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <TOpening, TClosing> Observable<List<T>> buffer(
-            ObservableSource<? extends TOpening> bufferOpenings,
-            Function<? super TOpening, ? extends ObservableSource<? extends TClosing>> bufferClosingSelector) {
-        return buffer(bufferOpenings, bufferClosingSelector, ArrayListSupplier.<T>asCallable());
+            ObservableSource<? extends TOpening> openingIndicator,
+            Function<? super TOpening, ? extends ObservableSource<? extends TClosing>> closingIndicator) {
+        return buffer(openingIndicator, closingIndicator, ArrayListSupplier.<T>asCallable());
     }
 
     /**
      * Returns a Observable that emits buffers of items it collects from the source ObservableSource. The resulting
-     * ObservableSource emits buffers that it creates when the specified {@code bufferOpenings} ObservableSource emits an
-     * item, and closes when the ObservableSource returned from {@code bufferClosingSelector} emits an item.
+     * ObservableSource emits buffers that it creates when the specified {@code openingIndicator} ObservableSource emits an
+     * item, and closes when the ObservableSource returned from {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="470" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer2.png" alt="">
      * <dl>
@@ -5046,9 +5043,9 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      * @param <U> the collection subclass type to buffer into
      * @param <TOpening> the element type of the buffer-opening ObservableSource
      * @param <TClosing> the element type of the individual buffer-closing ObservableSources
-     * @param bufferOpenings
+     * @param openingIndicator
      *            the ObservableSource that, when it emits an item, causes a new buffer to be created
-     * @param bufferClosingSelector
+     * @param closingIndicator
      *            the {@link Function} that is used to produce a ObservableSource for every buffer created. When this
      *            ObservableSource emits an item, the associated buffer is emitted.
      * @param bufferSupplier
@@ -5060,13 +5057,13 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <TOpening, TClosing, U extends Collection<? super T>> Observable<U> buffer(
-            ObservableSource<? extends TOpening> bufferOpenings,
-            Function<? super TOpening, ? extends ObservableSource<? extends TClosing>> bufferClosingSelector,
+            ObservableSource<? extends TOpening> openingIndicator,
+            Function<? super TOpening, ? extends ObservableSource<? extends TClosing>> closingIndicator,
             Callable<U> bufferSupplier) {
-        ObjectHelper.requireNonNull(bufferOpenings, "bufferOpenings is null");
-        ObjectHelper.requireNonNull(bufferClosingSelector, "bufferClosingSelector is null");
+        ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");
+        ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");
         ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");
-        return RxJavaPlugins.onAssembly(new ObservableBufferBoundary<T, U, TOpening, TClosing>(this, bufferOpenings, bufferClosingSelector, bufferSupplier));
+        return RxJavaPlugins.onAssembly(new ObservableBufferBoundary<T, U, TOpening, TClosing>(this, openingIndicator, closingIndicator, bufferSupplier));
     }
 
     /**
@@ -5161,7 +5158,7 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
     /**
      * Returns a Observable that emits buffers of items it collects from the source ObservableSource. The resulting
      * ObservableSource emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a
-     * new buffer whenever the ObservableSource produced by the specified {@code bufferClosingSelector} emits an item.
+     * new buffer whenever the ObservableSource produced by the specified {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="395" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer1.png" alt="">
      * <dl>
@@ -5175,7 +5172,7 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      *            Whenever the source {@code ObservableSource} emits an item, {@code buffer} emits the current buffer and
      *            begins to fill a new one
      * @return a Observable that emits a connected, non-overlapping buffer of items from the source ObservableSource
-     *         each time the ObservableSource created with the {@code bufferClosingSelector} argument emits an item
+     *         each time the ObservableSource created with the {@code closingIndicator} argument emits an item
      * @see <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -5187,7 +5184,7 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
     /**
      * Returns a Observable that emits buffers of items it collects from the source ObservableSource. The resulting
      * ObservableSource emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a
-     * new buffer whenever the ObservableSource produced by the specified {@code bufferClosingSelector} emits an item.
+     * new buffer whenever the ObservableSource produced by the specified {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="395" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer1.png" alt="">
      * <dl>
@@ -5205,7 +5202,7 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      *            a factory function that returns an instance of the collection subclass to be used and returned
      *            as the buffer
      * @return a Observable that emits a connected, non-overlapping buffer of items from the source ObservableSource
-     *         each time the ObservableSource created with the {@code bufferClosingSelector} argument emits an item
+     *         each time the ObservableSource created with the {@code closingIndicator} argument emits an item
      * @see <a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -5879,16 +5876,16 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      *  <dd>{@code defaultIfEmpty} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param defaultValue
+     * @param defaultItem
      *            the item to emit if the source ObservableSource emits no items
      * @return a Observable that emits either the specified default item if the source ObservableSource emits no
      *         items, or the items emitted by the source ObservableSource
      * @see <a href="http://reactivex.io/documentation/operators/defaultifempty.html">ReactiveX operators documentation: DefaultIfEmpty</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Observable<T> defaultIfEmpty(T defaultValue) {
-        ObjectHelper.requireNonNull(defaultValue, "value is null");
-        return switchIfEmpty(just(defaultValue));
+    public final Observable<T> defaultIfEmpty(T defaultItem) {
+        ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");
+        return switchIfEmpty(just(defaultItem));
     }
 
     /**
@@ -6270,8 +6267,7 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      * @return a Observable that emits those items from the source ObservableSource that are distinct from their
      *         immediate predecessors
      * @see <a href="http://reactivex.io/documentation/operators/distinct.html">ReactiveX operators documentation: Distinct</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical
-     *        with the release number)
+     * @since 2.0
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Observable<T> distinctUntilChanged(BiPredicate<? super T, ? super T> comparer) {
@@ -6577,7 +6573,7 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      * 
      * @param index
      *            the zero-based index of the item to retrieve
-     * @param defaultValue
+     * @param defaultItem
      *            the default item
      * @return a Observable that emits the item at the specified position in the sequence emitted by the source
      *         ObservableSource, or the default item if that index is outside the bounds of the source sequence
@@ -6586,12 +6582,12 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      * @see <a href="http://reactivex.io/documentation/operators/elementat.html">ReactiveX operators documentation: ElementAt</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Observable<T> elementAt(long index, T defaultValue) {
+    public final Observable<T> elementAt(long index, T defaultItem) {
         if (index < 0) {
             throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);
         }
-        ObjectHelper.requireNonNull(defaultValue, "defaultValue is null");
-        return RxJavaPlugins.onAssembly(new ObservableElementAt<T>(this, index, defaultValue));
+        ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");
+        return RxJavaPlugins.onAssembly(new ObservableElementAt<T>(this, index, defaultItem));
     }
 
     /**
@@ -6645,15 +6641,15 @@ public final void blockingSubscribe(Observer<? super T> subscriber) {
      *  <dd>{@code firstOrDefault} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param defaultValue
+     * @param defaultItem
      *            the default item to emit if the source ObservableSource doesn't emit anything
      * @return a Observable that emits only the very first item from the source, or a default item if the
      *         source ObservableSource completes without emitting any items
      * @see <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Observable<T> first(T defaultValue) {
-        return take(1).single(defaultValue);
+    public final Observable<T> first(T defaultItem) {
+        return take(1).single(defaultItem);
     }
 
     /**
@@ -7391,7 +7387,7 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, 
             Function<? super T, ? extends V> valueSelector, boolean delayError) {
-        return groupBy(keySelector, valueSelector, false, bufferSize());
+        return groupBy(keySelector, valueSelector, delayError, bufferSize());
     }
 
     /**
@@ -7610,15 +7606,15 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer
      *  <dd>{@code lastOrDefault} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param defaultValue
+     * @param defaultItem
      *            the default item to emit if the source ObservableSource is empty
      * @return a Observable that emits only the last item emitted by the source ObservableSource, or a default item
      *         if the source ObservableSource is empty
      * @see <a href="http://reactivex.io/documentation/operators/last.html">ReactiveX operators documentation: Last</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Observable<T> last(T defaultValue) {
-        return takeLast(1).single(defaultValue);
+    public final Observable<T> last(T defaultItem) {
+        return takeLast(1).single(defaultItem);
     }
 
     /**
@@ -7948,16 +7944,16 @@ public final Disposable forEachWhile(final Predicate<? super T> onNext, Consumer
      *  <dd>{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param value
+     * @param item
      *            the value that is emitted along with a regular onComplete in case the current
      *            Observable signals an exception
      * @return the original ObservableSource with appropriately modified behavior
      * @see <a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX operators documentation: Catch</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Observable<T> onErrorReturnValue(final T value) {
-        ObjectHelper.requireNonNull(value, "value is null");
-        return onErrorReturn(Functions.justFunction(value));
+    public final Observable<T> onErrorReturnItem(final T item) {
+        ObjectHelper.requireNonNull(item, "item is null");
+        return onErrorReturn(Functions.justFunction(item));
     }
 
     /**
@@ -9285,7 +9281,7 @@ public final void safeSubscribe(Observer<? super T> s) {
      *  <dd>{@code singleOrDefault} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param defaultValue
+     * @param defaultItem
      *            a default value to emit if the source ObservableSource emits no item
      * @return a Observable that emits the single item emitted by the source ObservableSource, or a default item if
      *         the source ObservableSource is empty
@@ -9294,9 +9290,9 @@ public final void safeSubscribe(Observer<? super T> s) {
      * @see <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Observable<T> single(T defaultValue) {
-        ObjectHelper.requireNonNull(defaultValue, "defaultValue is null");
-        return RxJavaPlugins.onAssembly(new ObservableSingle<T>(this, defaultValue));
+    public final Observable<T> single(T defaultItem) {
+        ObjectHelper.requireNonNull(defaultItem, "defaultItem is null");
+        return RxJavaPlugins.onAssembly(new ObservableSingle<T>(this, defaultItem));
     }
 
     /**
@@ -9652,7 +9648,7 @@ public final void safeSubscribe(Observer<? super T> s) {
      *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param values
+     * @param items
      *            an Iterable that contains the items you want the modified ObservableSource to emit first
      * @return a Observable that emits the items in the specified {@link Iterable} and then emits the items
      *         emitted by the source ObservableSource
@@ -9660,8 +9656,8 @@ public final void safeSubscribe(Observer<? super T> s) {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Observable<T> startWith(Iterable<? extends T> values) {
-        return concatArray(fromIterable(values), this);
+    public final Observable<T> startWith(Iterable<? extends T> items) {
+        return concatArray(fromIterable(items), this);
     }
     
     /**
@@ -9697,7 +9693,7 @@ public final void safeSubscribe(Observer<? super T> s) {
      *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param value
+     * @param item
      *            the item to emit first
      * @return a Observable that emits the specified item before it begins to emit items emitted by the source
      *         ObservableSource
@@ -9705,9 +9701,9 @@ public final void safeSubscribe(Observer<? super T> s) {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Observable<T> startWith(T value) {
-        ObjectHelper.requireNonNull(value, "value is null");
-        return concatArray(just(value), this);
+    public final Observable<T> startWith(T item) {
+        ObjectHelper.requireNonNull(item, "item is null");
+        return concatArray(just(item), this);
     }
 
     /**
@@ -9720,7 +9716,7 @@ public final void safeSubscribe(Observer<? super T> s) {
      *  <dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
-     * @param values
+     * @param items
      *            the array of values to emit first
      * @return a Observable that emits the specified items before it begins to emit items emitted by the source
      *         ObservableSource
@@ -9728,8 +9724,8 @@ public final void safeSubscribe(Observer<? super T> s) {
      */
     @SuppressWarnings("unchecked")
     @SchedulerSupport(SchedulerSupport.NONE)
-    public final Observable<T> startWithArray(T... values) {
-        Observable<T> fromArray = fromArray(values);
+    public final Observable<T> startWithArray(T... items) {
+        Observable<T> fromArray = fromArray(items);
         if (fromArray == empty()) {
             return RxJavaPlugins.onAssembly(this);
         }
@@ -11125,7 +11121,7 @@ public final void subscribe(Observer<? super T> observer) {
      * <p>
      * This allows fluent conversion to any other type.
      * @param <R> the resulting object type
-     * @param converter the function that receives the current Observable instance and returns a vlau
+     * @param converter the function that receives the current Observable instance and returns a value
      * @return the value returned by the function
      */
     public final <R> R to(Function<? super Observable<T>, R> converter) {
@@ -11154,8 +11150,7 @@ public final void subscribe(Observer<? super T> observer) {
      *         calls onCompleted
      * @see <a href="http://reactivex.io/documentation/completable.html">ReactiveX documentation:
      *      Completable</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical
-     *        with the release number)
+     * @since 2.0
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final Completable toCompletable() {
@@ -12094,8 +12089,8 @@ public final Completable toCompletable() {
     /**
      * Returns a Observable that emits windows of items it collects from the source ObservableSource. The resulting
      * ObservableSource emits windows that contain those items emitted by the source ObservableSource between the time when
-     * the {@code windowOpenings} ObservableSource emits an item and when the ObservableSource returned by
-     * {@code closingSelector} emits an item.
+     * the {@code openingIndicator} ObservableSource emits an item and when the ObservableSource returned by
+     * {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="550" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window2.png" alt="">
      * <dl>
@@ -12105,9 +12100,9 @@ public final Completable toCompletable() {
      * 
      * @param <U> the element type of the window-opening ObservableSource
      * @param <V> the element type of the window-closing ObservableSources
-     * @param windowOpen
+     * @param openingIndicator
      *            a ObservableSource that, when it emits an item, causes another window to be created
-     * @param windowClose
+     * @param closingIndicator
      *            a {@link Function} that produces a ObservableSource for every window created. When this ObservableSource
      *            emits an item, the associated window is closed and emitted
      * @return a Observable that emits windows of items emitted by the source ObservableSource that are governed by
@@ -12116,16 +12111,16 @@ public final Completable toCompletable() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <U, V> Observable<Observable<T>> window(
-            ObservableSource<U> windowOpen,
-            Function<? super U, ? extends ObservableSource<V>> windowClose) {
-        return window(windowOpen, windowClose, bufferSize());
+            ObservableSource<U> openingIndicator,
+            Function<? super U, ? extends ObservableSource<V>> closingIndicator) {
+        return window(openingIndicator, closingIndicator, bufferSize());
     }
 
     /**
      * Returns a Observable that emits windows of items it collects from the source ObservableSource. The resulting
      * ObservableSource emits windows that contain those items emitted by the source ObservableSource between the time when
-     * the {@code windowOpenings} ObservableSource emits an item and when the ObservableSource returned by
-     * {@code closingSelector} emits an item.
+     * the {@code openingIndicator} ObservableSource emits an item and when the ObservableSource returned by
+     * {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="550" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window2.png" alt="">
      * <dl>
@@ -12135,9 +12130,9 @@ public final Completable toCompletable() {
      * 
      * @param <U> the element type of the window-opening ObservableSource
      * @param <V> the element type of the window-closing ObservableSources
-     * @param windowOpen
+     * @param openingIndicator
      *            a ObservableSource that, when it emits an item, causes another window to be created
-     * @param windowClose
+     * @param closingIndicator
      *            a {@link Function} that produces a ObservableSource for every window created. When this ObservableSource
      *            emits an item, the associated window is closed and emitted
      * @param bufferSize
@@ -12148,17 +12143,17 @@ public final Completable toCompletable() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public final <U, V> Observable<Observable<T>> window(
-            ObservableSource<U> windowOpen,
-            Function<? super U, ? extends ObservableSource<V>> windowClose, int bufferSize) {
-        ObjectHelper.requireNonNull(windowOpen, "windowOpen is null");
-        ObjectHelper.requireNonNull(windowClose, "windowClose is null");
-        return RxJavaPlugins.onAssembly(new ObservableWindowBoundarySelector<T, U, V>(this, windowOpen, windowClose, bufferSize));
+            ObservableSource<U> openingIndicator,
+            Function<? super U, ? extends ObservableSource<V>> closingIndicator, int bufferSize) {
+        ObjectHelper.requireNonNull(openingIndicator, "openingIndicator is null");
+        ObjectHelper.requireNonNull(closingIndicator, "closingIndicator is null");
+        return RxJavaPlugins.onAssembly(new ObservableWindowBoundarySelector<T, U, V>(this, openingIndicator, closingIndicator, bufferSize));
     }
 
     /**
      * Returns a Observable that emits windows of items it collects from the source ObservableSource. The resulting
      * ObservableSource emits connected, non-overlapping windows. It emits the current window and opens a new one
-     * whenever the ObservableSource produced by the specified {@code closingSelector} emits an item.
+     * whenever the ObservableSource produced by the specified {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="460" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window1.png" alt="">
      * <dl>
@@ -12173,7 +12168,7 @@ public final Completable toCompletable() {
      *            When the source {@code ObservableSource} emits an item, {@code window} emits the current window and begins
      *            a new one.
      * @return a Observable that emits connected, non-overlapping windows of items from the source ObservableSource
-     *         whenever {@code closingSelector} emits an item
+     *         whenever {@code closingIndicator} emits an item
      * @see <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
@@ -12184,7 +12179,7 @@ public final Completable toCompletable() {
     /**
      * Returns a Observable that emits windows of items it collects from the source ObservableSource. The resulting
      * ObservableSource emits connected, non-overlapping windows. It emits the current window and opens a new one
-     * whenever the ObservableSource produced by the specified {@code closingSelector} emits an item.
+     * whenever the ObservableSource produced by the specified {@code closingIndicator} emits an item.
      * <p>
      * <img width="640" height="460" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window1.png" alt="">
      * <dl>
@@ -12200,7 +12195,7 @@ public final Completable toCompletable() {
      * @param bufferSize
      *            the capacity hint for the buffer in the inner windows
      * @return a Observable that emits connected, non-overlapping windows of items from the source ObservableSource
-     *         whenever {@code closingSelector} emits an item
+     *         whenever {@code closingIndicator} emits an item
      * @see <a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
diff --git a/src/main/java/io/reactivex/ObservableEmitter.java b/src/main/java/io/reactivex/ObservableEmitter.java
index a5b6dc146e..774c91a457 100644
--- a/src/main/java/io/reactivex/ObservableEmitter.java
+++ b/src/main/java/io/reactivex/ObservableEmitter.java
@@ -23,7 +23,7 @@
  * The onNext, onError and onComplete methods should be called 
  * in a sequential manner, just like the Observer's methods.
  * Use {@link #serialize()} if you want to ensure this. 
- * The other methods are threadsafe.
+ * The other methods are thread-safe.
  *
  * @param <T> the value type to emit
  */
diff --git a/src/main/java/io/reactivex/Scheduler.java b/src/main/java/io/reactivex/Scheduler.java
index d25618d8de..02cd737f7c 100644
--- a/src/main/java/io/reactivex/Scheduler.java
+++ b/src/main/java/io/reactivex/Scheduler.java
@@ -31,9 +31,9 @@
      * <p>
      * The associated system parameter, {@code rx.scheduler.drift-tolerance}, expects its value in minutes.
      */
-    static final long CLOCK_DRIFT_TOLERANCE_NANOS;
+    static final long CLOCK_DRIFT_TOLERANCE_NANOSECONDS;
     static {
-        CLOCK_DRIFT_TOLERANCE_NANOS = TimeUnit.MINUTES.toNanos(
+        CLOCK_DRIFT_TOLERANCE_NANOSECONDS = TimeUnit.MINUTES.toNanos(
                 Long.getLong("rx2.scheduler.drift-tolerance", 15));
     }
 
@@ -62,7 +62,7 @@ public long now(TimeUnit unit) {
     /** 
      * Allows the Scheduler instance to start threads 
      * and accept tasks on them.
-     * <p>Implementations should make sure the call is idempotent and threadsafe. 
+     * <p>Implementations should make sure the call is idempotent and thread-safe.
      * @since 2.0
      */
     public void start() {
@@ -72,7 +72,7 @@ public void start() {
     /** 
      * Instructs the Scheduler instance to stop threads 
      * and stop accepting tasks on any outstanding Workers. 
-     * <p>Implementations should make sure the call is idempotent and threadsafe. 
+     * <p>Implementations should make sure the call is idempotent and thread-safe.
      * @since 2.0
      */
     public void shutdown() {
@@ -160,7 +160,7 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
     /**
      * Sequential Scheduler for executing actions on a single thread or event loop.
      * <p>
-     * Unsubscribing the {@link Worker} unschedules all outstanding work and allows resources cleanup.
+     * Unsubscribing the {@link Worker} cancels all outstanding work and allows resource cleanup.
      */
     public static abstract class Worker implements Disposable {
 
@@ -171,7 +171,7 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
          * 
          * @param run
          *            Runnable to schedule
-         * @return a Disposable to be able to unsubscribe the action (unschedule it if not executed)
+         * @return a Disposable to be able to unsubscribe the action (cancel it if not executed)
          */
         public Disposable schedule(Runnable run) {
             return schedule(run, 0L, TimeUnit.NANOSECONDS);
@@ -180,17 +180,17 @@ public Disposable schedule(Runnable run) {
         /**
          * Schedules an Runnable for execution at some point in the future.
          * <p>
-         * Note to implementors: non-positive {@code delayTime} should be regarded as undelayed schedule, i.e.,
+         * Note to implementors: non-positive {@code delayTime} should be regarded as non-delayed schedule, i.e.,
          * as if the {@link #schedule(Runnable)} was called.
          *
          * @param run
          *            the Runnable to schedule
          * @param delay
-         *            time to wait before executing the action; non-positive values indicate an undelayed
+         *            time to wait before executing the action; non-positive values indicate an non-delayed
          *            schedule
          * @param unit
          *            the time unit of {@code delayTime}
-         * @return a Disposable to be able to unsubscribe the action (unschedule it if not executed)
+         * @return a Disposable to be able to unsubscribe the action (cancel it if not executed)
          */
         public abstract Disposable schedule(Runnable run, long delay, TimeUnit unit);
 
@@ -200,19 +200,19 @@ public Disposable schedule(Runnable run) {
          * concurrently). Each scheduler that can do periodic scheduling in a better way should override this.
          * <p>
          * Note to implementors: non-positive {@code initialTime} and {@code period} should be regarded as
-         * undelayed scheduling of the first and any subsequent executions.
+         * non-delayed scheduling of the first and any subsequent executions.
          *
          * @param run
          *            the Runnable to execute periodically
          * @param initialDelay
          *            time to wait before executing the action for the first time; non-positive values indicate
-         *            an undelayed schedule
+         *            an non-delayed schedule
          * @param period
          *            the time interval to wait each time in between executing the action; non-positive values
          *            indicate no delay between repeated schedules
          * @param unit
          *            the time unit of {@code period}
-         * @return a Disposable to be able to unsubscribe the action (unschedule it if not executed)
+         * @return a Disposable to be able to unsubscribe the action (cancel it if not executed)
          */
         public Disposable schedulePeriodically(Runnable run, final long initialDelay, final long period, final TimeUnit unit) {
             final SequentialDisposable first = new SequentialDisposable();
@@ -221,14 +221,14 @@ public Disposable schedulePeriodically(Runnable run, final long initialDelay, fi
             
             final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
 
-            final long periodInNanos = unit.toNanos(period);
-            final long firstNowNanos = now(TimeUnit.NANOSECONDS);
-            final long firstStartInNanos = firstNowNanos + unit.toNanos(initialDelay);
+            final long periodInNanoseconds = unit.toNanos(period);
+            final long firstNowNanoseconds = now(TimeUnit.NANOSECONDS);
+            final long firstStartInNanoseconds = firstNowNanoseconds + unit.toNanos(initialDelay);
 
             first.replace(schedule(new Runnable() {
                 long count;
-                long lastNowNanos = firstNowNanos;
-                long startInNanos = firstStartInNanos;
+                long lastNowNanoseconds = firstNowNanoseconds;
+                long startInNanoseconds = firstStartInNanoseconds;
                 @Override
                 public void run() {
                     decoratedRun.run();
@@ -237,22 +237,22 @@ public void run() {
 
                         long nextTick;
 
-                        long nowNanos = now(TimeUnit.NANOSECONDS);
+                        long nowNanoseconds = now(TimeUnit.NANOSECONDS);
                         // If the clock moved in a direction quite a bit, rebase the repetition period
-                        if (nowNanos + CLOCK_DRIFT_TOLERANCE_NANOS < lastNowNanos
-                                || nowNanos >= lastNowNanos + periodInNanos + CLOCK_DRIFT_TOLERANCE_NANOS) {
-                            nextTick = nowNanos + periodInNanos;
+                        if (nowNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS < lastNowNanoseconds
+                                || nowNanoseconds >= lastNowNanoseconds + periodInNanoseconds + CLOCK_DRIFT_TOLERANCE_NANOSECONDS) {
+                            nextTick = nowNanoseconds + periodInNanoseconds;
                             /* 
                              * Shift the start point back by the drift as if the whole thing
                              * started count periods ago.
                              */
-                            startInNanos = nextTick - (periodInNanos * (++count));
+                            startInNanoseconds = nextTick - (periodInNanoseconds * (++count));
                         } else {
-                            nextTick = startInNanos + (++count * periodInNanos);
+                            nextTick = startInNanoseconds + (++count * periodInNanoseconds);
                         }
-                        lastNowNanos = nowNanos;
+                        lastNowNanoseconds = nowNanoseconds;
 
-                        long delay = nextTick - nowNanos;
+                        long delay = nextTick - nowNanoseconds;
                         sd.replace(schedule(this, delay, TimeUnit.NANOSECONDS));
                     }
                 }
diff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java
index 91f83eabe3..2d712b9830 100644
--- a/src/main/java/io/reactivex/Single.java
+++ b/src/main/java/io/reactivex/Single.java
@@ -95,7 +95,7 @@
     }
 
     /**
-     * Concatenate the single values, non-overlappingly, of the Single sources provided by
+     * Concatenate the single values, in a non-overlapping fashion, of the Single sources provided by
      * an Iterable sequence. 
      * <dl>
      * <dt><b>Scheduler:</b></dt>
@@ -111,7 +111,7 @@
     }
     
     /**
-     * Concatenate the single values, non-overlappingly, of the Single sources provided by
+     * Concatenate the single values, in a non-overlapping fashion, of the Single sources provided by
      * a Publisher sequence. 
      * <dl>
      * <dt><b>Scheduler:</b></dt>
@@ -137,20 +137,20 @@
      * </dl>
      * 
      * @param <T> the common value type
-     * @param s1
+     * @param source1
      *            a Single to be concatenated
-     * @param s2
+     * @param source2
      *            a Single to be concatenated
      * @return a Flowable that emits items emitted by the two source Singles, one after the other.
      * @see <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
      */
     @SuppressWarnings("unchecked")
     public static <T> Flowable<T> concat(
-            SingleSource<? extends T> s1, SingleSource<? extends T> s2
+            SingleSource<? extends T> source1, SingleSource<? extends T> source2
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        return concat(Flowable.fromArray(s1, s2));
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        return concat(Flowable.fromArray(source1, source2));
     }
     
     /**
@@ -163,24 +163,24 @@
      * </dl>
      *
      * @param <T> the common value type
-     * @param s1
+     * @param source1
      *            a Single to be concatenated
-     * @param s2
+     * @param source2
      *            a Single to be concatenated
-     * @param s3
+     * @param source3
      *            a Single to be concatenated
      * @return a Flowable that emits items emitted by the three source Singles, one after the other.
      * @see <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
      */
     @SuppressWarnings("unchecked")
     public static <T> Flowable<T> concat(
-            SingleSource<? extends T> s1, SingleSource<? extends T> s2,
-            SingleSource<? extends T> s3
+            SingleSource<? extends T> source1, SingleSource<? extends T> source2,
+            SingleSource<? extends T> source3
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        ObjectHelper.requireNonNull(s3, "s3 is null");
-        return concat(Flowable.fromArray(s1, s2, s3));
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        return concat(Flowable.fromArray(source1, source2, source3));
     }
     
     /**
@@ -193,27 +193,27 @@
      * </dl>
      * 
      * @param <T> the common value type
-     * @param s1
+     * @param source1
      *            a Single to be concatenated
-     * @param s2
+     * @param source2
      *            a Single to be concatenated
-     * @param s3
+     * @param source3
      *            a Single to be concatenated
-     * @param s4
+     * @param source4
      *            a Single to be concatenated
      * @return a Flowable that emits items emitted by the four source Singles, one after the other.
      * @see <a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>
      */
     @SuppressWarnings("unchecked")
     public static <T> Flowable<T> concat(
-            SingleSource<? extends T> s1, SingleSource<? extends T> s2,
-            SingleSource<? extends T> s3, SingleSource<? extends T> s4
+            SingleSource<? extends T> source1, SingleSource<? extends T> source2,
+            SingleSource<? extends T> source3, SingleSource<? extends T> source4
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        ObjectHelper.requireNonNull(s3, "s3 is null");
-        ObjectHelper.requireNonNull(s4, "s4 is null");
-        return concat(Flowable.fromArray(s1, s2, s3, s4));
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        return concat(Flowable.fromArray(source1, source2, source3, source4));
     }
     
     /**
@@ -258,7 +258,7 @@
     }
 
     /**
-     * Calls a Callable for each individual SingleObserver to return the actula Single source to
+     * Calls a Callable for each individual SingleObserver to return the actual Single source to
      * be subscribe to.
      * <dl>
      * <dt><b>Scheduler:</b></dt>
@@ -565,20 +565,20 @@
      * </dl>
      * 
      * @param <T> the common value type
-     * @param s1
+     * @param source1
      *            a Single to be merged
-     * @param s2
+     * @param source2
      *            a Single to be merged
      * @return a Flowable that emits all of the items emitted by the source Singles
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
      */
     @SuppressWarnings("unchecked")
     public static <T> Flowable<T> merge(
-            SingleSource<? extends T> s1, SingleSource<? extends T> s2
+            SingleSource<? extends T> source1, SingleSource<? extends T> source2
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        return merge(Flowable.fromArray(s1, s2));
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        return merge(Flowable.fromArray(source1, source2));
     }
     
     /**
@@ -594,24 +594,24 @@
      * </dl>
      * 
      * @param <T> the common value type
-     * @param s1
+     * @param source1
      *            a Single to be merged
-     * @param s2
+     * @param source2
      *            a Single to be merged
-     * @param s3
+     * @param source3
      *            a Single to be merged
      * @return a Flowable that emits all of the items emitted by the source Singles
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
      */
     @SuppressWarnings("unchecked")
     public static <T> Flowable<T> merge(
-            SingleSource<? extends T> s1, SingleSource<? extends T> s2,
-            SingleSource<? extends T> s3
+            SingleSource<? extends T> source1, SingleSource<? extends T> source2,
+            SingleSource<? extends T> source3
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        ObjectHelper.requireNonNull(s3, "s3 is null");
-        return merge(Flowable.fromArray(s1, s2, s3));
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        return merge(Flowable.fromArray(source1, source2, source3));
     }
     
     /**
@@ -627,27 +627,27 @@
      * </dl>
      * 
      * @param <T> the common value type
-     * @param s1
+     * @param source1
      *            a Single to be merged
-     * @param s2
+     * @param source2
      *            a Single to be merged
-     * @param s3
+     * @param source3
      *            a Single to be merged
-     * @param s4
+     * @param source4
      *            a Single to be merged
      * @return a Flowable that emits all of the items emitted by the source Singles
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
      */
     @SuppressWarnings("unchecked")
     public static <T> Flowable<T> merge(
-            SingleSource<? extends T> s1, SingleSource<? extends T> s2,
-            SingleSource<? extends T> s3, SingleSource<? extends T> s4
+            SingleSource<? extends T> source1, SingleSource<? extends T> source2,
+            SingleSource<? extends T> source3, SingleSource<? extends T> source4
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        ObjectHelper.requireNonNull(s3, "s3 is null");
-        ObjectHelper.requireNonNull(s4, "s4 is null");
-        return merge(Flowable.fromArray(s1, s2, s3, s4));
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        return merge(Flowable.fromArray(source1, source2, source3, source4));
     }
     
     /**
@@ -849,9 +849,9 @@
      * @param <T1> the first source Single's value type
      * @param <T2> the second source Single's value type
      * @param <R> the result value type
-     * @param s1
+     * @param source1
      *            the first source Single
-     * @param s2
+     * @param source2
      *            a second source Single
      * @param zipper
      *            a function that, when applied to the item emitted by each of the source Singles, results in an
@@ -861,12 +861,12 @@
      */
     @SuppressWarnings("unchecked")
     public static <T1, T2, R> Single<R> zip(
-            SingleSource<? extends T1> s1, SingleSource<? extends T2> s2,
+            SingleSource<? extends T1> source1, SingleSource<? extends T2> source2,
             BiFunction<? super T1, ? super T2, ? extends R> zipper
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        return zipArray(Functions.toFunction(zipper), s1, s2);
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        return zipArray(Functions.toFunction(zipper), source1, source2);
     }
 
     /**
@@ -883,11 +883,11 @@
      * @param <T2> the second source Single's value type
      * @param <T3> the third source Single's value type
      * @param <R> the result value type
-     * @param s1
+     * @param source1
      *            the first source Single
-     * @param s2
+     * @param source2
      *            a second source Single
-     * @param s3
+     * @param source3
      *            a third source Single
      * @param zipper
      *            a function that, when applied to the item emitted by each of the source Singles, results in an
@@ -897,14 +897,14 @@
      */
     @SuppressWarnings("unchecked")
     public static <T1, T2, T3, R> Single<R> zip(
-            SingleSource<? extends T1> s1, SingleSource<? extends T2> s2,
-            SingleSource<? extends T3> s3,
+            SingleSource<? extends T1> source1, SingleSource<? extends T2> source2,
+            SingleSource<? extends T3> source3,
             Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        ObjectHelper.requireNonNull(s3, "s3 is null");
-        return zipArray(Functions.toFunction(zipper), s1, s2, s3);
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        return zipArray(Functions.toFunction(zipper), source1, source2, source3);
     }
 
     /**
@@ -922,13 +922,13 @@
      * @param <T3> the third source Single's value type
      * @param <T4> the fourth source Single's value type
      * @param <R> the result value type
-     * @param s1
+     * @param source1
      *            the first source Single
-     * @param s2
+     * @param source2
      *            a second source Single
-     * @param s3
+     * @param source3
      *            a third source Single
-     * @param s4
+     * @param source4
      *            a fourth source Single
      * @param zipper
      *            a function that, when applied to the item emitted by each of the source Singles, results in an
@@ -938,15 +938,15 @@
      */
     @SuppressWarnings("unchecked")
     public static <T1, T2, T3, T4, R> Single<R> zip(
-            SingleSource<? extends T1> s1, SingleSource<? extends T2> s2,
-            SingleSource<? extends T3> s3, SingleSource<? extends T4> s4,
+            SingleSource<? extends T1> source1, SingleSource<? extends T2> source2,
+            SingleSource<? extends T3> source3, SingleSource<? extends T4> source4,
             Function4<? super T1, ? super T2, ? super T3, ? super T4, ? extends R> zipper
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        ObjectHelper.requireNonNull(s3, "s3 is null");
-        ObjectHelper.requireNonNull(s4, "s4 is null");
-        return zipArray(Functions.toFunction(zipper), s1, s2, s3, s4);
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4);
     }
 
     /**
@@ -965,15 +965,15 @@
      * @param <T4> the fourth source Single's value type
      * @param <T5> the fifth source Single's value type
      * @param <R> the result value type
-     * @param s1
+     * @param source1
      *            the first source Single
-     * @param s2
+     * @param source2
      *            a second source Single
-     * @param s3
+     * @param source3
      *            a third source Single
-     * @param s4
+     * @param source4
      *            a fourth source Single
-     * @param s5
+     * @param source5
      *            a fifth source Single
      * @param zipper
      *            a function that, when applied to the item emitted by each of the source Singles, results in an
@@ -983,17 +983,17 @@
      */
     @SuppressWarnings("unchecked")
     public static <T1, T2, T3, T4, T5, R> Single<R> zip(
-            SingleSource<? extends T1> s1, SingleSource<? extends T2> s2,
-            SingleSource<? extends T3> s3, SingleSource<? extends T4> s4,
-            SingleSource<? extends T5> s5,
+            SingleSource<? extends T1> source1, SingleSource<? extends T2> source2,
+            SingleSource<? extends T3> source3, SingleSource<? extends T4> source4,
+            SingleSource<? extends T5> source5,
             Function5<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R> zipper
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        ObjectHelper.requireNonNull(s3, "s3 is null");
-        ObjectHelper.requireNonNull(s4, "s4 is null");
-        ObjectHelper.requireNonNull(s5, "s5 is null");
-        return zipArray(Functions.toFunction(zipper), s1, s2, s3, s4, s5);
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5);
     }
 
     /**
@@ -1013,17 +1013,17 @@
      * @param <T5> the fifth source Single's value type
      * @param <T6> the sixth source Single's value type
      * @param <R> the result value type
-     * @param s1
+     * @param source1
      *            the first source Single
-     * @param s2
+     * @param source2
      *            a second source Single
-     * @param s3
+     * @param source3
      *            a third source Single
-     * @param s4
+     * @param source4
      *            a fourth source Single
-     * @param s5
+     * @param source5
      *            a fifth source Single
-     * @param s6
+     * @param source6
      *            a sixth source Single
      * @param zipper
      *            a function that, when applied to the item emitted by each of the source Singles, results in an
@@ -1033,18 +1033,18 @@
      */
     @SuppressWarnings("unchecked")
     public static <T1, T2, T3, T4, T5, T6, R> Single<R> zip(
-            SingleSource<? extends T1> s1, SingleSource<? extends T2> s2,
-            SingleSource<? extends T3> s3, SingleSource<? extends T4> s4,
-            SingleSource<? extends T5> s5, SingleSource<? extends T6> s6,
+            SingleSource<? extends T1> source1, SingleSource<? extends T2> source2,
+            SingleSource<? extends T3> source3, SingleSource<? extends T4> source4,
+            SingleSource<? extends T5> source5, SingleSource<? extends T6> source6,
             Function6<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R> zipper
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        ObjectHelper.requireNonNull(s3, "s3 is null");
-        ObjectHelper.requireNonNull(s4, "s4 is null");
-        ObjectHelper.requireNonNull(s5, "s5 is null");
-        ObjectHelper.requireNonNull(s6, "s6 is null");
-        return zipArray(Functions.toFunction(zipper), s1, s2, s3, s4, s5, s6);
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
+        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6);
     }
 
     /**
@@ -1065,19 +1065,19 @@
      * @param <T6> the sixth source Single's value type
      * @param <T7> the seventh source Single's value type
      * @param <R> the result value type
-     * @param s1
+     * @param source1
      *            the first source Single
-     * @param s2
+     * @param source2
      *            a second source Single
-     * @param s3
+     * @param source3
      *            a third source Single
-     * @param s4
+     * @param source4
      *            a fourth source Single
-     * @param s5
+     * @param source5
      *            a fifth source Single
-     * @param s6
+     * @param source6
      *            a sixth source Single
-     * @param s7
+     * @param source7
      *            a seventh source Single
      * @param zipper
      *            a function that, when applied to the item emitted by each of the source Singles, results in an
@@ -1087,20 +1087,20 @@
      */
     @SuppressWarnings("unchecked")
     public static <T1, T2, T3, T4, T5, T6, T7, R> Single<R> zip(
-            SingleSource<? extends T1> s1, SingleSource<? extends T2> s2,
-            SingleSource<? extends T3> s3, SingleSource<? extends T4> s4,
-            SingleSource<? extends T5> s5, SingleSource<? extends T6> s6,
-            SingleSource<? extends T7> s7,
+            SingleSource<? extends T1> source1, SingleSource<? extends T2> source2,
+            SingleSource<? extends T3> source3, SingleSource<? extends T4> source4,
+            SingleSource<? extends T5> source5, SingleSource<? extends T6> source6,
+            SingleSource<? extends T7> source7,
             Function7<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R> zipper
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        ObjectHelper.requireNonNull(s3, "s3 is null");
-        ObjectHelper.requireNonNull(s4, "s4 is null");
-        ObjectHelper.requireNonNull(s5, "s5 is null");
-        ObjectHelper.requireNonNull(s6, "s6 is null");
-        ObjectHelper.requireNonNull(s7, "s7 is null");
-        return zipArray(Functions.toFunction(zipper), s1, s2, s3, s4, s5, s6, s7);
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
+        ObjectHelper.requireNonNull(source7, "source7 is null");
+        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6, source7);
     }
     
     /**
@@ -1122,21 +1122,21 @@
      * @param <T7> the seventh source Single's value type
      * @param <T8> the eighth source Single's value type
      * @param <R> the result value type
-     * @param s1
+     * @param source1
      *            the first source Single
-     * @param s2
+     * @param source2
      *            a second source Single
-     * @param s3
+     * @param source3
      *            a third source Single
-     * @param s4
+     * @param source4
      *            a fourth source Single
-     * @param s5
+     * @param source5
      *            a fifth source Single
-     * @param s6
+     * @param source6
      *            a sixth source Single
-     * @param s7
+     * @param source7
      *            a seventh source Single
-     * @param s8
+     * @param source8
      *            an eighth source Single
      * @param zipper
      *            a function that, when applied to the item emitted by each of the source Singles, results in an
@@ -1146,21 +1146,21 @@
      */
     @SuppressWarnings("unchecked")
     public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Single<R> zip(
-            SingleSource<? extends T1> s1, SingleSource<? extends T2> s2,
-            SingleSource<? extends T3> s3, SingleSource<? extends T4> s4,
-            SingleSource<? extends T5> s5, SingleSource<? extends T6> s6,
-            SingleSource<? extends T7> s7, SingleSource<? extends T8> s8,
+            SingleSource<? extends T1> source1, SingleSource<? extends T2> source2,
+            SingleSource<? extends T3> source3, SingleSource<? extends T4> source4,
+            SingleSource<? extends T5> source5, SingleSource<? extends T6> source6,
+            SingleSource<? extends T7> source7, SingleSource<? extends T8> source8,
             Function8<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R> zipper
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        ObjectHelper.requireNonNull(s3, "s3 is null");
-        ObjectHelper.requireNonNull(s4, "s4 is null");
-        ObjectHelper.requireNonNull(s5, "s5 is null");
-        ObjectHelper.requireNonNull(s6, "s6 is null");
-        ObjectHelper.requireNonNull(s7, "s7 is null");
-        ObjectHelper.requireNonNull(s8, "s8 is null");
-        return zipArray(Functions.toFunction(zipper), s1, s2, s3, s4, s5, s6, s7, s8);
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
+        ObjectHelper.requireNonNull(source7, "source7 is null");
+        ObjectHelper.requireNonNull(source8, "source8 is null");
+        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6, source7, source8);
     }
     
     /**
@@ -1183,23 +1183,23 @@
      * @param <T8> the eighth source Single's value type
      * @param <T9> the ninth source Single's value type
      * @param <R> the result value type
-     * @param s1
+     * @param source1
      *            the first source Single
-     * @param s2
+     * @param source2
      *            a second source Single
-     * @param s3
+     * @param source3
      *            a third source Single
-     * @param s4
+     * @param source4
      *            a fourth source Single
-     * @param s5
+     * @param source5
      *            a fifth source Single
-     * @param s6
+     * @param source6
      *            a sixth source Single
-     * @param s7
+     * @param source7
      *            a seventh source Single
-     * @param s8
+     * @param source8
      *            an eighth source Single
-     * @param s9
+     * @param source9
      *            a ninth source Single
      * @param zipper
      *            a function that, when applied to the item emitted by each of the source Singles, results in an
@@ -1209,23 +1209,23 @@
      */
     @SuppressWarnings("unchecked")
     public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Single<R> zip(
-            SingleSource<? extends T1> s1, SingleSource<? extends T2> s2,
-            SingleSource<? extends T3> s3, SingleSource<? extends T4> s4,
-            SingleSource<? extends T5> s5, SingleSource<? extends T6> s6,
-            SingleSource<? extends T7> s7, SingleSource<? extends T8> s8,
-            SingleSource<? extends T9> s9,
+            SingleSource<? extends T1> source1, SingleSource<? extends T2> source2,
+            SingleSource<? extends T3> source3, SingleSource<? extends T4> source4,
+            SingleSource<? extends T5> source5, SingleSource<? extends T6> source6,
+            SingleSource<? extends T7> source7, SingleSource<? extends T8> source8,
+            SingleSource<? extends T9> source9,
             Function9<? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R> zipper
      ) {
-        ObjectHelper.requireNonNull(s1, "s1 is null");
-        ObjectHelper.requireNonNull(s2, "s2 is null");
-        ObjectHelper.requireNonNull(s3, "s3 is null");
-        ObjectHelper.requireNonNull(s4, "s4 is null");
-        ObjectHelper.requireNonNull(s5, "s5 is null");
-        ObjectHelper.requireNonNull(s6, "s6 is null");
-        ObjectHelper.requireNonNull(s7, "s7 is null");
-        ObjectHelper.requireNonNull(s8, "s8 is null");
-        ObjectHelper.requireNonNull(s9, "s9 is null");
-        return zipArray(Functions.toFunction(zipper), s1, s2, s3, s4, s5, s6, s7, s8, s9);
+        ObjectHelper.requireNonNull(source1, "source1 is null");
+        ObjectHelper.requireNonNull(source2, "source2 is null");
+        ObjectHelper.requireNonNull(source3, "source3 is null");
+        ObjectHelper.requireNonNull(source4, "source4 is null");
+        ObjectHelper.requireNonNull(source5, "source5 is null");
+        ObjectHelper.requireNonNull(source6, "source6 is null");
+        ObjectHelper.requireNonNull(source7, "source7 is null");
+        ObjectHelper.requireNonNull(source8, "source8 is null");
+        ObjectHelper.requireNonNull(source9, "source9 is null");
+        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6, source7, source8, source9);
     }
 
     /**
@@ -1646,7 +1646,7 @@ public final Completable flatMapCompletable(final Function<? super T, ? extends
     }
     
     /**
-     * Blockingly waits until the current Single signals a success value (which is returned) or
+     * Waits in a blocking fashion until the current Single signals a success value (which is returned) or
      * an exception (which is propagated).
      * <dl>
      * <dt><b>Scheduler:</b></dt>
diff --git a/src/main/java/io/reactivex/SingleObserver.java b/src/main/java/io/reactivex/SingleObserver.java
index 658b702c94..2c684d749b 100644
--- a/src/main/java/io/reactivex/SingleObserver.java
+++ b/src/main/java/io/reactivex/SingleObserver.java
@@ -34,7 +34,7 @@
     /**
      * Provides the SingleObserver with the means of cancelling (disposing) the
      * connection (channel) with the Single in both
-     * synchronous (from within {@link #onSubscribe(Disposable)} itself) and asynchronous manner. 
+     * synchronous (from within {@code onSubscribe(Disposable)} itself) and asynchronous manner.
      * @param d the Disposable instance whose {@link Disposable#dispose()} can
      * be called anytime to cancel the connection
      * @since 2.0
diff --git a/src/main/java/io/reactivex/disposables/CompositeDisposable.java b/src/main/java/io/reactivex/disposables/CompositeDisposable.java
index e0fcceab9e..ed6197ff58 100644
--- a/src/main/java/io/reactivex/disposables/CompositeDisposable.java
+++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java
@@ -104,7 +104,7 @@ public boolean add(Disposable d) {
     }
 
     /**
-     * Atomically adds the givel array of Disposables to the container or
+     * Atomically adds the given array of Disposables to the container or
      * disposes them all if the container has been disposed.
      * @param ds the array of Disposables
      * @return true if the operation was successful, false if the container has been disposed
diff --git a/src/main/java/io/reactivex/disposables/Disposables.java b/src/main/java/io/reactivex/disposables/Disposables.java
index 3f050c4077..4c3664370b 100644
--- a/src/main/java/io/reactivex/disposables/Disposables.java
+++ b/src/main/java/io/reactivex/disposables/Disposables.java
@@ -89,8 +89,8 @@ public static Disposable from(Subscription subscription) {
     }
 
     /**
-     * Returns a new, undisposed Disposable instance.
-     * @return a new, undisposed Disposable instance
+     * Returns a new, non-disposed Disposable instance.
+     * @return a new, non-disposed Disposable instance
      */
     public static Disposable empty() {
         return from(Functions.EMPTY_RUNNABLE);
diff --git a/src/main/java/io/reactivex/exceptions/CompositeException.java b/src/main/java/io/reactivex/exceptions/CompositeException.java
index 81d1b0b4b1..eb95c49841 100644
--- a/src/main/java/io/reactivex/exceptions/CompositeException.java
+++ b/src/main/java/io/reactivex/exceptions/CompositeException.java
@@ -194,30 +194,30 @@ public void printStackTrace(PrintWriter s) {
      *            stream to print to
      */
     private void printStackTrace(PrintStreamOrWriter s) {
-        StringBuilder bldr = new StringBuilder(128);
-        bldr.append(this).append('\n');
+        StringBuilder b = new StringBuilder(128);
+        b.append(this).append('\n');
         for (StackTraceElement myStackElement : getStackTrace()) {
-            bldr.append("\tat ").append(myStackElement).append('\n');
+            b.append("\tat ").append(myStackElement).append('\n');
         }
         int i = 1;
         for (Throwable ex : exceptions) {
-            bldr.append("  ComposedException ").append(i).append(" :\n");
-            appendStackTrace(bldr, ex, "\t");
+            b.append("  ComposedException ").append(i).append(" :\n");
+            appendStackTrace(b, ex, "\t");
             i++;
         }
         synchronized (s.lock()) {
-            s.println(bldr.toString());
+            s.println(b.toString());
         }
     }
 
-    private void appendStackTrace(StringBuilder bldr, Throwable ex, String prefix) {
-        bldr.append(prefix).append(ex).append('\n');
+    private void appendStackTrace(StringBuilder b, Throwable ex, String prefix) {
+        b.append(prefix).append(ex).append('\n');
         for (StackTraceElement stackElement : ex.getStackTrace()) {
-            bldr.append("\t\tat ").append(stackElement).append('\n');
+            b.append("\t\tat ").append(stackElement).append('\n');
         }
         if (ex.getCause() != null) {
-            bldr.append("\tCaused by: ");
-            appendStackTrace(bldr, ex.getCause(), "");
+            b.append("\tCaused by: ");
+            appendStackTrace(b, ex.getCause(), "");
         }
     }
 
@@ -314,10 +314,10 @@ public boolean isEmpty() {
     }
     
     /**
-     * Returns the root cause of {@code e}. If {@code e.getCause()} returns {@null} or {@code e}, just return {@code e} itself.
+     * Returns the root cause of {@code e}. If {@code e.getCause()} returns {@code null} or {@code e}, just return {@code e} itself.
      *
      * @param e the {@link Throwable} {@code e}.
-     * @return The root cause of {@code e}. If {@code e.getCause()} returns {@null} or {@code e}, just return {@code e} itself.
+     * @return The root cause of {@code e}. If {@code e.getCause()} returns {@code null} or {@code e}, just return {@code e} itself.
      */
     private Throwable getRootCause(Throwable e) {
         Throwable root = e.getCause();
diff --git a/src/main/java/io/reactivex/internal/disposables/ArrayCompositeDisposable.java b/src/main/java/io/reactivex/internal/disposables/ArrayCompositeDisposable.java
index 8464098bc3..5bb0227101 100644
--- a/src/main/java/io/reactivex/internal/disposables/ArrayCompositeDisposable.java
+++ b/src/main/java/io/reactivex/internal/disposables/ArrayCompositeDisposable.java
@@ -34,8 +34,8 @@ public ArrayCompositeDisposable(int capacity) {
 
     /**
      * Sets the resource at the specified index and disposes the old resource.
-     * @param index
-     * @param resource
+     * @param index the index of the resource to set
+     * @param resource the new resource
      * @return true if the resource has ben set, false if the composite has been disposed
      */
     public boolean setResource(int index, Disposable resource) {
@@ -56,8 +56,8 @@ public boolean setResource(int index, Disposable resource) {
     
     /**
      * Replaces the resource at the specified index and returns the old resource.
-     * @param index
-     * @param resource
+     * @param index the index of the resource to replace
+     * @param resource the new resource
      * @return the old resource, can be null
      */
     public Disposable replaceResource(int index, Disposable resource) {
diff --git a/src/main/java/io/reactivex/internal/functions/Functions.java b/src/main/java/io/reactivex/internal/functions/Functions.java
index 8c22254845..58c422e900 100644
--- a/src/main/java/io/reactivex/internal/functions/Functions.java
+++ b/src/main/java/io/reactivex/internal/functions/Functions.java
@@ -192,7 +192,7 @@ public void accept(Throwable error) {
         }
     };
 
-    public static final LongConsumer EMPTY_LONGCONSUMER = new LongConsumer() {
+    public static final LongConsumer EMPTY_LONG_CONSUMER = new LongConsumer() {
         @Override
         public void accept(long v) { }
     };
@@ -485,12 +485,12 @@ public boolean test(T t) throws Exception {
         return new BooleanSupplierPredicateReverse<T>(supplier);
     }
 
-    static final class TimestampingFunction<T> implements Function<T, Timed<T>> {
+    static final class TimestampFunction<T> implements Function<T, Timed<T>> {
         final TimeUnit unit;
         
         final Scheduler scheduler;
 
-        public TimestampingFunction(TimeUnit unit, Scheduler scheduler) {
+        public TimestampFunction(TimeUnit unit, Scheduler scheduler) {
             this.unit = unit;
             this.scheduler = scheduler;
         }
@@ -502,7 +502,7 @@ public TimestampingFunction(TimeUnit unit, Scheduler scheduler) {
     }
     
     public static <T> Function<T, Timed<T>> timestampWith(TimeUnit unit, Scheduler scheduler) {
-        return new TimestampingFunction<T>(unit, scheduler);
+        return new TimestampFunction<T>(unit, scheduler);
     }
 
     static final class ToMapKeySelector<K, T> implements BiConsumer<Map<K, T>, T> {
diff --git a/src/main/java/io/reactivex/internal/functions/ObjectHelper.java b/src/main/java/io/reactivex/internal/functions/ObjectHelper.java
index 396a138205..3471c8eee9 100644
--- a/src/main/java/io/reactivex/internal/functions/ObjectHelper.java
+++ b/src/main/java/io/reactivex/internal/functions/ObjectHelper.java
@@ -29,7 +29,7 @@
      * @return the object itself
      * @throws NullPointerException if object is null
      */
-    public static final <T> T requireNonNull(T object, String message) {
+    public static <T> T requireNonNull(T object, String message) {
         if (object == null) {
             throw new NullPointerException(message);
         }
@@ -85,7 +85,7 @@ public boolean test(Object o1, Object o2) {
     /**
      * Returns a BiPredicate that compares its parameters via Objects.equals().
      * @param <T> the value type
-     * @return the bipredicate
+     * @return the bi-predicate instance
      */
     @SuppressWarnings("unchecked")
     public static <T> BiPredicate<T, T> equalsPredicate() {
diff --git a/src/main/java/io/reactivex/internal/fuseable/ScalarCallable.java b/src/main/java/io/reactivex/internal/fuseable/ScalarCallable.java
index 9c78a4f749..7fc2664cd2 100644
--- a/src/main/java/io/reactivex/internal/fuseable/ScalarCallable.java
+++ b/src/main/java/io/reactivex/internal/fuseable/ScalarCallable.java
@@ -18,7 +18,7 @@
  * A marker interface indicating that a scalar, constant value
  * is held by the implementing reactive type which can be
  * safely extracted during assembly time can be used for
- * optimiziation.
+ * optimization.
  * <p>
  * Implementors of {@link #call()} should not throw any exception.
  * <p>
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableAwait.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableAwait.java
index fed980da55..1bb609fedf 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableAwait.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableAwait.java
@@ -49,7 +49,7 @@ public void onSubscribe(Disposable d) {
         
         if (cdl.getCount() == 0) {
             if (err[0] != null) {
-                Exceptions.propagate(err[0]);
+                throw Exceptions.propagate(err[0]);
             }
             return;
         }
@@ -59,7 +59,7 @@ public void onSubscribe(Disposable d) {
             throw Exceptions.propagate(ex);
         }
         if (err[0] != null) {
-            Exceptions.propagate(err[0]);
+            throw Exceptions.propagate(err[0]);
         }
     }
     
@@ -91,7 +91,7 @@ public void onSubscribe(Disposable d) {
         
         if (cdl.getCount() == 0) {
             if (err[0] != null) {
-                Exceptions.propagate(err[0]);
+                throw Exceptions.propagate(err[0]);
             }
             return true;
         }
@@ -103,7 +103,7 @@ public void onSubscribe(Disposable d) {
         }
         if (b) {
             if (err[0] != null) {
-                Exceptions.propagate(err[0]);
+                throw Exceptions.propagate(err[0]);
             }
         }
         return b;
@@ -182,7 +182,6 @@ public void onSubscribe(Disposable d) {
         if (b) {
             return err[0];
         }
-        Exceptions.propagate(new TimeoutException());
-        return null;
+        throw Exceptions.propagate(new TimeoutException());
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeArray.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeArray.java
index dbf586c9dc..fcbe76970b 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeArray.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeArray.java
@@ -44,10 +44,10 @@ public void subscribeActual(final CompletableObserver s) {
                 NullPointerException npe = new NullPointerException("A completable source is null");
                 if (once.compareAndSet(false, true)) {
                     s.onError(npe);
-                    return;
                 } else {
                     RxJavaPlugins.onError(npe);
                 }
+                return;
             }
             
             c.subscribe(new CompletableObserver() {
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java
index fe636a56fd..9e7c42696b 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterator.java
@@ -67,8 +67,7 @@ public boolean hasNext() {
             if (d) {
                 Throwable e = error;
                 if (e != null) {
-                    Exceptions.propagate(e);
-                    return false;
+                    throw Exceptions.propagate(e);
                 } else
                 if (empty) {
                     return false;
@@ -82,8 +81,7 @@ public boolean hasNext() {
                     }
                 } catch (InterruptedException ex) {
                     run();
-                    Exceptions.propagate(ex);
-                    return false;
+                    throw Exceptions.propagate(ex);
                 } finally {
                     lock.unlock();
                 }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableLatest.java b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableLatest.java
index 2bbb1a2670..2e2ac86e6b 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableLatest.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableLatest.java
@@ -58,12 +58,12 @@
         final AtomicReference<Notification<T>> value = new AtomicReference<Notification<T>>();
 
         // iterator's notification
-        Notification<T> iNotif;
+        Notification<T> iteratorNotification;
 
         @Override
         public void onNext(Notification<T> args) {
-            boolean wasntAvailable = value.getAndSet(args) == null;
-            if (wasntAvailable) {
+            boolean wasNotAvailable = value.getAndSet(args) == null;
+            if (wasNotAvailable) {
                 notify.release();
             }
         }
@@ -80,36 +80,36 @@ public void onComplete() {
 
         @Override
         public boolean hasNext() {
-            if (iNotif != null && iNotif.isOnError()) {
-                throw Exceptions.propagate(iNotif.getError());
+            if (iteratorNotification != null && iteratorNotification.isOnError()) {
+                throw Exceptions.propagate(iteratorNotification.getError());
             }
-            if (iNotif == null || iNotif.isOnNext()) {
-                if (iNotif == null) {
+            if (iteratorNotification == null || iteratorNotification.isOnNext()) {
+                if (iteratorNotification == null) {
                     try {
                         notify.acquire();
                     } catch (InterruptedException ex) {
                         dispose();
                         Thread.currentThread().interrupt();
-                        iNotif = Notification.createOnError(ex);
+                        iteratorNotification = Notification.createOnError(ex);
                         throw Exceptions.propagate(ex);
                     }
 
                     Notification<T> n = value.getAndSet(null);
-                    iNotif = n;
-                    if (iNotif.isOnError()) {
-                        throw Exceptions.propagate(iNotif.getError());
+                    iteratorNotification = n;
+                    if (n.isOnError()) {
+                        throw Exceptions.propagate(n.getError());
                     }
                 }
             }
-            return iNotif.isOnNext();
+            return iteratorNotification.isOnNext();
         }
 
         @Override
         public T next() {
             if (hasNext()) {
-                if (iNotif.isOnNext()) {
-                    T v = iNotif.getValue();
-                    iNotif = null;
+                if (iteratorNotification.isOnNext()) {
+                    T v = iteratorNotification.getValue();
+                    iteratorNotification = null;
                     return v;
                 }
             }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java
index b2adb9fbff..e8cf3d4c8b 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java
@@ -61,7 +61,7 @@
     static final class MostRecentObserver<T> extends DefaultSubscriber<T> {
         volatile Object value;
         
-        private MostRecentObserver(T value) {
+        MostRecentObserver(T value) {
             this.value = NotificationLite.next(value);
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableNext.java b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableNext.java
index 0365a9a8f5..0e4214864d 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableNext.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableNext.java
@@ -50,7 +50,7 @@
 
     }
 
-    // test needs to access the observer.waiting flag non-blockingly.
+    // test needs to access the observer.waiting flag
     static final class NextIterator<T> implements Iterator<T> {
 
         private final NextObserver<T> observer;
@@ -61,7 +61,7 @@
         private Throwable error;
         private boolean started;
 
-        private NextIterator(Publisher<? extends T> items, NextObserver<T> observer) {
+        NextIterator(Publisher<? extends T> items, NextObserver<T> observer) {
             this.items = items;
             this.observer = observer;
         }
@@ -78,11 +78,8 @@ public boolean hasNext() {
                 // the iterator has reached the end.
                 return false;
             }
-            if (!isNextConsumed) {
-                // next has not been used yet.
-                return true;
-            }
-            return moveToNext();
+            // next has not been used yet.
+            return !isNextConsumed || moveToNext();
         }
 
         private boolean moveToNext() {
@@ -90,7 +87,7 @@ private boolean moveToNext() {
                 if (!started) {
                     started = true;
                     // if not started, start now
-                    observer.setWaiting(1);
+                    observer.setWaiting();
                     Flowable.<T>fromPublisher(items)
                     .materialize().subscribe(observer);
                 }
@@ -173,11 +170,11 @@ public void onNext(Notification<T> args) {
         }
         
         public Notification<T> takeNext() throws InterruptedException {
-            setWaiting(1);
+            setWaiting();
             return buf.take();
         }
-        void setWaiting(int value) {
-            waiting.set(value);
+        void setWaiting() {
+            waiting.set(1);
         }
     }
 }
\ No newline at end of file
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java
index ba74f953d2..ff120f6a7c 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java
@@ -64,7 +64,7 @@
                 if (o == BlockingSubscriber.TERMINATED) {
                     break;
                 }
-                if (NotificationLite.acceptFull(o, subscriber)) {
+                if (NotificationLite.acceptFull(v, subscriber)) {
                     break;
                 }
             }
@@ -108,7 +108,7 @@ public void accept(Subscription s) {
         BlockingHelper.awaitForComplete(cdl, ls);
         Throwable e = error[0];
         if (e != null) {
-            Exceptions.propagate(e);
+            throw Exceptions.propagate(e);
         }
     }
     
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java
index fc3a80c92a..7f9929c5cf 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java
@@ -95,7 +95,7 @@ public void onSubscribe(Subscription s) {
         
         @Override
         public void onNext(T t) {
-            synchronized (t) {
+            synchronized (this) {
                 for (U b : buffers) {
                     b.add(t);
                 }
@@ -235,7 +235,7 @@ void close(U b, Disposable d) {
             }
             
             if (e) {
-                fastpathOrderedEmitMax(b, false, this);
+                fastPathOrderedEmitMax(b, false, this);
             }
             
             if (resources.remove(d)) {
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java
index 0328ad6891..c2dff49870 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java
@@ -42,10 +42,10 @@ public FlowableBufferBoundarySupplier(Publisher<T> source, Callable<? extends Pu
     
     @Override
     protected void subscribeActual(Subscriber<? super U> s) {
-        source.subscribe(new BufferBondarySupplierSubscriber<T, U, B>(new SerializedSubscriber<U>(s), bufferSupplier, boundarySupplier));
+        source.subscribe(new BufferBoundarySupplierSubscriber<T, U, B>(new SerializedSubscriber<U>(s), bufferSupplier, boundarySupplier));
     }
 
-    static final class BufferBondarySupplierSubscriber<T, U extends Collection<? super T>, B>
+    static final class BufferBoundarySupplierSubscriber<T, U extends Collection<? super T>, B>
     extends QueueDrainSubscriber<T, U, U> implements Subscriber<T>, Subscription, Disposable {
         /** */
         final Callable<U> bufferSupplier;
@@ -57,8 +57,8 @@ protected void subscribeActual(Subscriber<? super U> s) {
         
         U buffer;
         
-        public BufferBondarySupplierSubscriber(Subscriber<? super U> actual, Callable<U> bufferSupplier,
-                Callable<? extends Publisher<B>> boundarySupplier) {
+        public BufferBoundarySupplierSubscriber(Subscriber<? super U> actual, Callable<U> bufferSupplier,
+                                                Callable<? extends Publisher<B>> boundarySupplier) {
             super(actual, new MpscLinkedQueue<U>());
             this.bufferSupplier = bufferSupplier;
             this.boundarySupplier = boundarySupplier;
@@ -237,7 +237,7 @@ void next() {
             
             boundary.subscribe(bs);
             
-            fastpathEmitMax(b, false, this);
+            fastPathEmitMax(b, false, this);
         }
         
         @Override
@@ -260,11 +260,11 @@ public boolean accept(Subscriber<? super U> a, U v) {
     }
     
     static final class BufferBoundarySubscriber<T, U extends Collection<? super T>, B> extends DisposableSubscriber<B> {
-        final BufferBondarySupplierSubscriber<T, U, B> parent;
+        final BufferBoundarySupplierSubscriber<T, U, B> parent;
         
         boolean once;
         
-        public BufferBoundarySubscriber(BufferBondarySupplierSubscriber<T, U, B> parent) {
+        public BufferBoundarySubscriber(BufferBoundarySupplierSubscriber<T, U, B> parent) {
             this.parent = parent;
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferExactBoundary.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferExactBoundary.java
index cc78725c60..4877d4df53 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferExactBoundary.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferExactBoundary.java
@@ -39,10 +39,10 @@ public FlowableBufferExactBoundary(Publisher<T> source, Publisher<B> boundary, C
 
     @Override
     protected void subscribeActual(Subscriber<? super U> s) {
-        source.subscribe(new BufferExactBondarySubscriber<T, U, B>(new SerializedSubscriber<U>(s), bufferSupplier, boundary));
+        source.subscribe(new BufferExactBoundarySubscriber<T, U, B>(new SerializedSubscriber<U>(s), bufferSupplier, boundary));
     }
     
-    static final class BufferExactBondarySubscriber<T, U extends Collection<? super T>, B>
+    static final class BufferExactBoundarySubscriber<T, U extends Collection<? super T>, B>
     extends QueueDrainSubscriber<T, U, U> implements Subscriber<T>, Subscription, Disposable {
         /** */
         final Callable<U> bufferSupplier;
@@ -54,8 +54,8 @@ protected void subscribeActual(Subscriber<? super U> s) {
         
         U buffer;
         
-        public BufferExactBondarySubscriber(Subscriber<? super U> actual, Callable<U> bufferSupplier,
-                Publisher<B> boundary) {
+        public BufferExactBoundarySubscriber(Subscriber<? super U> actual, Callable<U> bufferSupplier,
+                                             Publisher<B> boundary) {
             super(actual, new MpscLinkedQueue<U>());
             this.bufferSupplier = bufferSupplier;
             this.boundary = boundary;
@@ -180,7 +180,7 @@ void next() {
                 buffer = next;
             }
             
-            fastpathEmitMax(b, false, this);
+            fastPathEmitMax(b, false, this);
         }
         
         @Override
@@ -202,9 +202,9 @@ public boolean accept(Subscriber<? super U> a, U v) {
     }
     
     static final class BufferBoundarySubscriber<T, U extends Collection<? super T>, B> extends DisposableSubscriber<B> {
-        final BufferExactBondarySubscriber<T, U, B> parent;
+        final BufferExactBoundarySubscriber<T, U, B> parent;
         
-        public BufferBoundarySubscriber(BufferExactBondarySubscriber<T, U, B> parent) {
+        public BufferBoundarySubscriber(BufferExactBoundarySubscriber<T, U, B> parent) {
             this.parent = parent;
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
index 008089cc3b..fa9a242212 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
@@ -237,7 +237,7 @@ public void run() {
                 return;
             }
 
-            fastpathEmitMax(current, false, this);
+            fastPathEmitMax(current, false, this);
         }
         
         @Override
@@ -265,11 +265,11 @@ public boolean isDisposed() {
         final long timeskip;
         final TimeUnit unit;
         final Worker w;
-        
+        final List<U> buffers;
+
         Subscription s;
         
-        List<U> buffers;
-        
+
         public BufferSkipBoundedSubscriber(Subscriber<? super U> actual, 
                 Callable<U> bufferSupplier, long timespan,
                 long timeskip, TimeUnit unit, Worker w) {
@@ -323,7 +323,7 @@ public void run() {
                         buffers.remove(b);
                     }
                     
-                    fastpathOrderedEmitMax(b, false, w);
+                    fastPathOrderedEmitMax(b, false, w);
                 }
             }, timespan, unit);
         }
@@ -415,7 +415,7 @@ public void run() {
                         buffers.remove(b);
                     }
                     
-                    fastpathOrderedEmitMax(b, false, w);
+                    fastPathOrderedEmitMax(b, false, w);
                 }
             }, timespan, unit);
         }
@@ -518,7 +518,7 @@ public void onNext(T t) {
                 timer.dispose();
             }
             
-            fastpathOrderedEmitMax(b, false, this);
+            fastPathOrderedEmitMax(b, false, this);
             
             try {
                 b = bufferSupplier.call();
@@ -640,7 +640,7 @@ public void run() {
                 buffer = next;
             }
 
-            fastpathOrderedEmitMax(current, false, this);
+            fastPathOrderedEmitMax(current, false, this);
         }
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java
index e142c12535..db1ac371d2 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java
@@ -63,7 +63,8 @@
     /**
      * Private constructor because state needs to be shared between the Observable body and
      * the onSubscribe function.
-     * @param state
+     * @param source the upstream source whose signals to cache
+     * @param state the cache state object performing the caching and replaying
      */
     private FlowableCache(Flowable<T> source, CacheState<T> state) {
         super(source);
@@ -97,15 +98,15 @@ protected void subscribeActual(Subscriber<? super T> t) {
     
     /**
      * Returns true if there are observers subscribed to this observable.
-     * @return
+     * @return true if the cache has Subscribers
      */
-    /* public */ boolean hasObservers() {
+    /* public */ boolean hasSubscribers() {
         return state.producers.length != 0;
     }
     
     /**
      * Returns the number of events currently cached.
-     * @return
+     * @return the number of currently cached event count
      */
     /* public */ int cachedEventCount() {
         return state.size();
@@ -114,7 +115,7 @@ protected void subscribeActual(Subscriber<? super T> t) {
     /**
      * Contains the active child producers and the values to replay.
      *
-     * @param <T>
+     * @param <T> the value type of the cached items
      */
     static final class CacheState<T> extends LinkedArrayList implements Subscriber<T> {
         /** The source observable to connect to. */
@@ -141,7 +142,7 @@ public CacheState(Flowable<? extends T> source, int capacityHint) {
         }
         /**
          * Adds a ReplayProducer to the producers array atomically.
-         * @param p
+         * @param p the target ReplaySubscription wrapping a downstream Subscriber with state
          */
         public void addProducer(ReplaySubscription<T> p) {
             // guarding by connection to save on allocating another object
@@ -157,7 +158,7 @@ public void addProducer(ReplaySubscription<T> p) {
         }
         /**
          * Removes the ReplayProducer (if present) from the producers array atomically.
-         * @param p
+         * @param p the target ReplaySubscription wrapping a downstream Subscriber with state
          */
         public void removeProducer(ReplaySubscription<T> p) {
             synchronized (connection) {
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatArray.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatArray.java
index cb72e5746c..59dd95603a 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatArray.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatArray.java
@@ -94,8 +94,8 @@ public void onError(Throwable t) {
         @Override
         public void onComplete() {
             if (wip.getAndIncrement() == 0) {
-                Publisher<? extends T>[] srcs = sources;
-                int n = srcs.length;
+                Publisher<? extends T>[] sources = this.sources;
+                int n = sources.length;
                 int i = index;
                 for (;;) {
                     
@@ -113,7 +113,7 @@ public void onComplete() {
                         return;
                     }
                     
-                    Publisher<? extends T> p = srcs[i];
+                    Publisher<? extends T> p = sources[i];
                     
                     if (p == null) {
                         Throwable ex = new NullPointerException("A Publisher entry is null");
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java
index 0ab6eb35a6..3fb9df6173 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java
@@ -75,11 +75,11 @@ protected void subscribeActual(Subscriber<? super R> s) {
         final AtomicReference<Throwable> error;
         
         final AtomicLong requested;
-        
+
+        final SpscLinkedArrayQueue<InnerQueuedSubscriber<R>> subscribers;
+
         Subscription s;
-        
-        SpscLinkedArrayQueue<InnerQueuedSubscriber<R>> subscribers;
-        
+
         volatile boolean cancelled;
         
         volatile boolean done;
@@ -353,7 +353,7 @@ public void drain() {
                             inner = null;
                             current = null;
                             s.request(1);
-                            continue outer;
+                            continue;
                         }
                     }
                 }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChanged.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChanged.java
index 5019976e29..a2581f7340 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChanged.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinctUntilChanged.java
@@ -161,10 +161,7 @@ public boolean tryOnNext(T t) {
                     return false;
                 }
                 last = t;
-                if (equal) {
-                    return false;
-                }
-                return actual.tryOnNext(t);
+                return !equal && actual.tryOnNext(t);
             }
             hasValue = true;
             last = t;
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableError.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableError.java
index 25845e6de9..b925996f7f 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableError.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableError.java
@@ -34,7 +34,6 @@ public void subscribeActual(Subscriber<? super T> s) {
         } catch (Throwable t) {
             Exceptions.throwIfFatal(t);
             error = t;
-            return;
         }
         if (error == null) {
             error = new NullPointerException();
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java
index 28d8d49222..9c342ccd37 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java
@@ -66,9 +66,9 @@ public void subscribeActual(Subscriber<? super R> s) {
             Iterator<? extends R> it;
 
             try {
-                Iterable<? extends R> iter = mapper.apply(v);
+                Iterable<? extends R> iterable = mapper.apply(v);
 
-                it = iter.iterator();
+                it = iterable.iterator();
             } catch (Throwable ex) {
                 Exceptions.throwIfFatal(ex);
                 EmptySubscription.error(ex, s);
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableMap.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableMap.java
index 3a4c995aa9..d2d4914e71 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableMap.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableMap.java
@@ -14,6 +14,7 @@
 
 package io.reactivex.internal.operators.flowable;
 
+import io.reactivex.internal.functions.ObjectHelper;
 import org.reactivestreams.*;
 
 import io.reactivex.functions.Function;
@@ -58,7 +59,7 @@ public void onNext(T t) {
             U v;
             
             try {
-                v = nullCheck(mapper.apply(t), "The mapper function returned a null value.");
+                v = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper function returned a null value.");
             } catch (Throwable ex) {
                 fail(ex);
                 return;
@@ -74,7 +75,7 @@ public int requestFusion(int mode) {
         @Override
         public U poll() throws Exception {
             T t = qs.poll();
-            return t != null ? nullCheck(mapper.apply(t), "The mapper function returned a null value.") : null;
+            return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), "The mapper function returned a null value.") : null;
         }
     }
 
@@ -100,7 +101,7 @@ public void onNext(T t) {
             U v;
             
             try {
-                v = nullCheck(mapper.apply(t), "The mapper function returned a null value.");
+                v = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper function returned a null value.");
             } catch (Throwable ex) {
                 fail(ex);
                 return;
@@ -121,7 +122,7 @@ public boolean tryOnNext(T t) {
             U v;
             
             try {
-                v = nullCheck(mapper.apply(t), "The mapper function returned a null value.");
+                v = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper function returned a null value.");
             } catch (Throwable ex) {
                 fail(ex);
                 return true;
@@ -137,7 +138,7 @@ public int requestFusion(int mode) {
         @Override
         public U poll() throws Exception {
             T t = qs.poll();
-            return t != null ? nullCheck(mapper.apply(t), "The mapper function returned a null value.") : null;
+            return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), "The mapper function returned a null value.") : null;
         }
     }
 
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java
index 69cac70227..b9bc6c3270 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java
@@ -173,9 +173,8 @@ public void cancel() {
             cancelled = true;
             s.cancel();
             
-            Deque<T> dq = deque;
             if (getAndIncrement() == 0) {
-                clear(dq);
+                clear(deque);
             }
         }
         
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
index 60062da33a..fda3311221 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java
@@ -87,7 +87,7 @@ public void subscribe(Subscriber<? super T> child) {
                          */
                         continue;
                         /*
-                         * Note: although technically corrent, concurrent disconnects can cause 
+                         * Note: although technically correct, concurrent disconnects can cause
                          * unexpected behavior such as child subscribers never receiving anything 
                          * (unless connected again). An alternative approach, similar to 
                          * PublishSubject would be to immediately terminate such child 
@@ -313,7 +313,7 @@ boolean add(InnerProducer<T> producer) {
                 if (producers.compareAndSet(c, u)) {
                     return true;
                 }
-                // if failed, some other operation succeded (another add, remove or termination)
+                // if failed, some other operation succeeded (another add, remove or termination)
                 // so retry
             }
         }
@@ -402,7 +402,7 @@ boolean checkTerminated(Object term, boolean empty) {
                                 ip.child.onComplete();
                             }
                         } finally {
-                            // we explicitely unsubscribe/disconnect from the upstream
+                            // we explicitly unsubscribe/disconnect from the upstream
                             // after we sent out the terminal event to child subscribers
                             dispose();
                         }
@@ -422,7 +422,7 @@ boolean checkTerminated(Object term, boolean empty) {
                             ip.child.onError(t);
                         }
                     } finally {
-                        // we explicitely unsubscribe/disconnect from the upstream
+                        // we explicitly unsubscribe/disconnect from the upstream
                         // after we sent out the terminal event to child subscribers
                         dispose();
                     }
@@ -463,7 +463,7 @@ void dispatch() {
             try {
                 for (;;) {
                     /*
-                     * We need to read terminalEvent before checking the queue for emptyness because
+                     * We need to read terminalEvent before checking the queue for emptiness because
                      * all enqueue happens before setting the terminal event.
                      * If it were the other way around, when the emission is paused between
                      * checking isEmpty and checking terminalEvent, some other thread might
@@ -671,7 +671,7 @@ public void request(long n) {
                 }
                 // try setting the new request value
                 if (compareAndSet(r, u)) {
-                    // if successful, notify the parent dispacher this child can receive more
+                    // if successful, notify the parent dispatcher this child can receive more
                     // elements
                     parent.dispatch();
                     return;
@@ -711,7 +711,7 @@ public long produced(long n) {
                 }
                 // try updating the request value
                 if (compareAndSet(r, u)) {
-                    // and return the udpated value
+                    // and return the updated value
                     return u;
                 }
                 // otherwise, some concurrent activity happened and we need to retry
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
index b40cbe7d2f..1a8d3e08dd 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java
@@ -53,8 +53,8 @@ public Object call() {
      * ConnectableObservable via a selector function.
      * @param <U> the connectable observable type
      * @param <R> the result type
-     * @param connectableFactory
-     * @param selector
+     * @param connectableFactory the factory that returns a ConnectableFlowable for each individual subscriber
+     * @param selector the function that receives a Flowable and should return another Flowable that will be subscribed to
      * @return the new Observable instance
      */
     public static <U, R> Flowable<R> multicastSelector(
@@ -107,8 +107,8 @@ public void accept(Disposable r) {
      * Child Subscribers will observe the events of the ConnectableObservable on the
      * specified scheduler.
      * @param <T> the value type
-     * @param co
-     * @param scheduler
+     * @param co the ConnectableFlowable to wrap
+     * @param scheduler the target scheduler
      * @return the new ConnectableObservable instance
      */
     public static <T> ConnectableFlowable<T> observeOn(final ConnectableFlowable<T> co, final Scheduler scheduler) {
@@ -129,7 +129,7 @@ protected void subscribeActual(Subscriber<? super T> s) {
     /**
      * Creates a replaying ConnectableObservable with an unbounded buffer.
      * @param <T> the value type
-     * @param source
+     * @param source the source Flowable to use
      * @return the new ConnectableObservable instance
      */
     @SuppressWarnings("unchecked")
@@ -140,8 +140,8 @@ protected void subscribeActual(Subscriber<? super T> s) {
     /**
      * Creates a replaying ConnectableObservable with a size bound buffer.
      * @param <T> the value type
-     * @param source
-     * @param bufferSize
+     * @param source the source Flowable to use
+     * @param bufferSize the maximum number of elements to hold
      * @return the new ConnectableObservable instance
      */
     public static <T> ConnectableFlowable<T> create(Flowable<T> source,
@@ -160,10 +160,10 @@ protected void subscribeActual(Subscriber<? super T> s) {
     /**
      * Creates a replaying ConnectableObservable with a time bound buffer.
      * @param <T> the value type
-     * @param source
-     * @param maxAge
-     * @param unit
-     * @param scheduler
+     * @param source the source Flowable to use
+     * @param maxAge the maximum age of entries
+     * @param unit the unit of measure of the age amount
+     * @param scheduler the target scheduler providing the current time
      * @return the new ConnectableObservable instance
      */
     public static <T> ConnectableFlowable<T> create(Flowable<T> source,
@@ -174,11 +174,11 @@ protected void subscribeActual(Subscriber<? super T> s) {
     /**
      * Creates a replaying ConnectableObservable with a size and time bound buffer.
      * @param <T> the value type
-     * @param source
-     * @param maxAge
-     * @param unit
-     * @param scheduler
-     * @param bufferSize
+     * @param source the source Flowable to use
+     * @param maxAge the maximum age of entries
+     * @param unit the unit of measure of the age amount
+     * @param scheduler the target scheduler providing the current time
+     * @param bufferSize the maximum number of elements to hold
      * @return the new NbpConnectableObservable instance
      */
     public static <T> ConnectableFlowable<T> create(Flowable<T> source,
@@ -222,7 +222,7 @@ public void subscribe(Subscriber<? super T> child) {
                         // create a new subscriber to source
                         ReplaySubscriber<T> u = new ReplaySubscriber<T>(buf);
                         // let's try setting it as the current subscriber-to-source
-                        if (!curr.compareAndSet(r, u)) {
+                        if (!curr.compareAndSet(null, u)) {
                             // didn't work, maybe someone else did it or the current subscriber 
                             // to source has just finished
                             continue;
@@ -414,7 +414,7 @@ boolean add(InnerSubscription<T> producer) {
                 if (producers.compareAndSet(c, u)) {
                     return true;
                 }
-                // if failed, some other operation succeded (another add, remove or termination)
+                // if failed, some other operation succeeded (another add, remove or termination)
                 // so retry
             }
         }
@@ -665,7 +665,7 @@ public void request(long n) {
                 if (compareAndSet(r, u)) {
                     // increment the total request counter
                     BackpressureHelper.add(totalRequested, n);
-                    // if successful, notify the parent dispacher this child can receive more
+                    // if successful, notify the parent dispatcher this child can receive more
                     // elements
                     parent.manageRequests();
                     
@@ -702,7 +702,7 @@ public long produced(long n) {
                 }
                 // try updating the request value
                 if (compareAndSet(r, u)) {
-                    // and return the udpated value
+                    // and return the updated value
                     return u;
                 }
                 // otherwise, some concurrent activity happened and we need to retry
@@ -743,7 +743,7 @@ public void dispose() {
         }
         /**
          * Convenience method to auto-cast the index object.
-         * @return
+         * @return the current index object
          */
         @SuppressWarnings("unchecked")
         <U> U index() {
@@ -758,12 +758,12 @@ public void dispose() {
     interface ReplayBuffer<T> {
         /**
          * Adds a regular value to the buffer.
-         * @param value
+         * @param value the next value to store
          */
         void next(T value);
         /**
          * Adds a terminal exception to the buffer
-         * @param e
+         * @param e the Throwable instance
          */
         void error(Throwable e);
         /**
@@ -775,7 +775,7 @@ public void dispose() {
          * subscriber inside the output if there
          * is new value and requests available at the
          * same time.
-         * @param output
+         * @param output the receiver of the events
          */
         void replay(InnerSubscription<T> output);
     }
@@ -829,15 +829,15 @@ public void replay(InnerSubscription<T> output) {
                 }
                 int sourceIndex = size;
                 
-                Integer destIndexObject = output.index();
-                int destIndex = destIndexObject != null ? destIndexObject.intValue() : 0;
+                Integer destinationIndexObject = output.index();
+                int destinationIndex = destinationIndexObject != null ? destinationIndexObject : 0;
                 
                 long r = output.get();
                 long r0 = r; // NOPMD
                 long e = 0L;
                 
-                while (r != 0L && destIndex < sourceIndex) {
-                    Object o = get(destIndex);
+                while (r != 0L && destinationIndex < sourceIndex) {
+                    Object o = get(destinationIndex);
                     try {
                         if (NotificationLite.accept(o, child)) {
                             return;
@@ -853,12 +853,12 @@ public void replay(InnerSubscription<T> output) {
                     if (output.isDisposed()) {
                         return;
                     }
-                    destIndex++;
+                    destinationIndex++;
                     r--;
                     e++;
                 }
                 if (e != 0L) {
-                    output.index = destIndex;
+                    output.index = destinationIndex;
                     if (r0 != Long.MAX_VALUE) {
                         output.produced(e);
                     }
@@ -912,7 +912,7 @@ public BoundedReplayBuffer() {
         
         /**
          * Add a new node to the linked list.
-         * @param n
+         * @param n the Node instance to add
          */
         final void addLast(Node n) {
             tail.set(n);
@@ -945,7 +945,7 @@ final void removeFirst() {
         }
         /**
          * Arranges the given node is the new head from now on.
-         * @param n
+         * @param n the Node instance to set as first
          */
         final void setFirst(Node n) {
             set(n);
@@ -1051,8 +1051,8 @@ public final void replay(InnerSubscription<T> output) {
         /**
          * Override this to wrap the NotificationLite object into a
          * container to be used later by truncate.
-         * @param value
-         * @return
+         * @param value the value to transform into the internal representation
+         * @return the transformed value
          */
         Object enterTransform(Object value) {
             return value;
@@ -1060,8 +1060,8 @@ Object enterTransform(Object value) {
         /**
          * Override this to unwrap the transformed value into a
          * NotificationLite object.
-         * @param value
-         * @return
+         * @param value the input value to transform to the external representation
+         * @return the transformed value
          */
         Object leaveTransform(Object value) {
             return value;
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimed.java
index c1d79f4d82..295ef6ba9c 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSkipLastTimed.java
@@ -83,11 +83,9 @@ public void onSubscribe(Subscription s) {
         
         @Override
         public void onNext(T t) {
-            final SpscLinkedArrayQueue<Object> q = queue;
-
             long now = scheduler.now(unit);
-            
-            q.offer(now, t);
+
+            queue.offer(now, t);
 
             drain();
         }
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java
index 13dfba464b..13b610f541 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySupplier.java
@@ -126,7 +126,6 @@ public void onSubscribe(Subscription s) {
                 windows.getAndIncrement();
                 s.request(Long.MAX_VALUE);
                 p.subscribe(inner);
-                return;
             }
         }
         
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
index 4cddf13a61..76519d5fb3 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
@@ -720,7 +720,6 @@ public void run() {
             } else {
                 s.cancel();
                 actual.onError(new IllegalStateException("Could not emit the first window due to lack of requests"));
-                return;
             }
         }
         
@@ -843,7 +842,7 @@ void drainLoop() {
                             }
                         } else {
                             for (UnicastProcessor<T> w : ws) {
-                                w.onError(e);
+                                w.onComplete();
                             }
                         }
                         ws.clear();
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
index 21a988f040..65377a3479 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java
@@ -143,7 +143,7 @@ public void cancel() {
             }
         }
 
-        void error(Throwable e, int index) {
+        void error(Throwable e) {
             if (ExceptionHelper.addThrowable(error, e)) {
                 drain();
             } else {
@@ -322,8 +322,7 @@ void drain() {
 
                 if (e != 0L) {
 
-                    for (int j = 0; j < n; j++) {
-                        ZipSubscriber<T, R> inner = qs[j];
+                    for (ZipSubscriber<T, R> inner : qs) {
                         inner.request(e);
                     }
 
@@ -409,7 +408,7 @@ public void onNext(T t) {
         @Override
         public void onError(Throwable t) {
             if (sourceMode != QueueSubscription.ASYNC) {
-                parent.error(t, index);
+                parent.error(t);
             }
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterator.java b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterator.java
index a4942eda6a..cfc75d79dd 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterator.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterator.java
@@ -57,8 +57,7 @@ public boolean hasNext() {
             if (d) {
                 Throwable e = error;
                 if (e != null) {
-                    Exceptions.propagate(e);
-                    return false;
+                    throw Exceptions.propagate(e);
                 } else
                 if (empty) {
                     return false;
@@ -72,8 +71,7 @@ public boolean hasNext() {
                     }
                 } catch (InterruptedException ex) {
                     run();
-                    Exceptions.propagate(ex);
-                    return false;
+                    throw Exceptions.propagate(ex);
                 } finally {
                     lock.unlock();
                 }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java
index e37f233361..6d332964c5 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java
@@ -57,7 +57,7 @@
     /** Observer of source, iterator for output. */
     static final class LatestObserverIterator<T> extends DisposableObserver<Notification<T>> implements Iterator<T> {
         // iterator's notification
-        Notification<T> iNotif;
+        Notification<T> iteratorNotification;
 
         final Semaphore notify = new Semaphore(0);
         // observer's notification
@@ -65,8 +65,8 @@
 
         @Override
         public void onNext(Notification<T> args) {
-            boolean wasntAvailable = value.getAndSet(args) == null;
-            if (wasntAvailable) {
+            boolean wasNotAvailable = value.getAndSet(args) == null;
+            if (wasNotAvailable) {
                 notify.release();
             }
         }
@@ -83,36 +83,36 @@ public void onComplete() {
 
         @Override
         public boolean hasNext() {
-            if (iNotif != null && iNotif.isOnError()) {
-                throw Exceptions.propagate(iNotif.getError());
+            if (iteratorNotification != null && iteratorNotification.isOnError()) {
+                throw Exceptions.propagate(iteratorNotification.getError());
             }
-            if (iNotif == null || iNotif.isOnNext()) {
-                if (iNotif == null) {
+            if (iteratorNotification == null || iteratorNotification.isOnNext()) {
+                if (iteratorNotification == null) {
                     try {
                         notify.acquire();
                     } catch (InterruptedException ex) {
                         dispose();
                         Thread.currentThread().interrupt();
-                        iNotif = Notification.createOnError(ex);
+                        iteratorNotification = Notification.createOnError(ex);
                         throw Exceptions.propagate(ex);
                     }
 
                     Notification<T> n = value.getAndSet(null);
-                    iNotif = n;
-                    if (iNotif.isOnError()) {
-                        throw Exceptions.propagate(iNotif.getError());
+                    iteratorNotification = n;
+                    if (n.isOnError()) {
+                        throw Exceptions.propagate(n.getError());
                     }
                 }
             }
-            return iNotif.isOnNext();
+            return iteratorNotification.isOnNext();
         }
 
         @Override
         public T next() {
             if (hasNext()) {
-                if (iNotif.isOnNext()) {
-                    T v = iNotif.getValue();
-                    iNotif = null;
+                if (iteratorNotification.isOnNext()) {
+                    T v = iteratorNotification.getValue();
+                    iteratorNotification = null;
                     return v;
                 }
             }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableMostRecent.java b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableMostRecent.java
index 8c46b5ebf9..75434de3f9 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableMostRecent.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableMostRecent.java
@@ -61,7 +61,7 @@
     static final class MostRecentObserver<T> extends DefaultObserver<T> {
         volatile Object value;
         
-        private MostRecentObserver(T value) {
+        MostRecentObserver(T value) {
             this.value = NotificationLite.next(value);
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java
index 4710f601de..86df3e4f9f 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java
@@ -49,7 +49,7 @@
 
     }
 
-    // test needs to access the observer.waiting flag non-blockingly.
+    // test needs to access the observer.waiting flag
     static final class NextIterator<T> implements Iterator<T> {
 
         private final NextObserver<T> observer;
@@ -60,7 +60,7 @@
         private Throwable error;
         private boolean started;
 
-        private NextIterator(Observable<? extends T> items, NextObserver<T> observer) {
+        NextIterator(Observable<? extends T> items, NextObserver<T> observer) {
             this.items = items;
             this.observer = observer;
         }
@@ -77,11 +77,8 @@ public boolean hasNext() {
                 // the iterator has reached the end.
                 return false;
             }
-            if (!isNextConsumed) {
-                // next has not been used yet.
-                return true;
-            }
-            return moveToNext();
+            // next has not been used yet.
+            return !isNextConsumed || moveToNext();
         }
 
         private boolean moveToNext() {
@@ -89,7 +86,7 @@ private boolean moveToNext() {
                 if (!started) {
                     started = true;
                     // if not started, start now
-                    observer.setWaiting(1);
+                    observer.setWaiting();
                     @SuppressWarnings("unchecked")
                     Observable<T> nbpObservable = (Observable<T>)items;
                     nbpObservable.materialize().subscribe(observer);
@@ -173,11 +170,11 @@ public void onNext(Notification<T> args) {
         }
         
         public Notification<T> takeNext() throws InterruptedException {
-            setWaiting(1);
+            setWaiting();
             return buf.take();
         }
-        void setWaiting(int value) {
-            waiting.set(value);
+        void setWaiting() {
+            waiting.set(1);
         }
     }
 }
\ No newline at end of file
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableAmb.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableAmb.java
index 1eebc055f0..f7cbdb489c 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableAmb.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAmb.java
@@ -38,7 +38,7 @@ public void subscribeActual(Observer<? super T> s) {
             sources = new Observable[8];
             for (ObservableSource<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
-                    Observable<? extends T>[] b = new Observable[count + (count >> 2)];
+                    ObservableSource<? extends T>[] b = new ObservableSource[count + (count >> 2)];
                     System.arraycopy(sources, 0, b, 0, count);
                     sources = b;
                 }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java
index 09cefeb64f..cf79477b5c 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java
@@ -65,7 +65,7 @@
                 if (o == BlockingSubscriber.TERMINATED) {
                     break;
                 }
-                if (NotificationLite.acceptFull(o, subscriber)) {
+                if (NotificationLite.acceptFull(v, subscriber)) {
                     break;
                 }
             }
@@ -108,7 +108,7 @@ public void accept(Disposable s) {
         BlockingHelper.awaitForComplete(cdl, ls);
         Throwable e = error[0];
         if (e != null) {
-            Exceptions.propagate(e);
+            throw Exceptions.propagate(e);
         }
     }
     
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java
index 564b972a1e..41eec23387 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java
@@ -93,7 +93,7 @@ public void onSubscribe(Disposable s) {
         
         @Override
         public void onNext(T t) {
-            synchronized (t) {
+            synchronized (this) {
                 for (U b : buffers) {
                     b.add(t);
                 }
@@ -221,7 +221,7 @@ void close(U b, Disposable d) {
             }
             
             if (e) {
-                fastpathOrderedEmit(b, false, this);
+                fastPathOrderedEmit(b, false, this);
             }
             
             if (resources.remove(d)) {
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundarySupplier.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundarySupplier.java
index 2a729e0646..7c769587d3 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundarySupplier.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundarySupplier.java
@@ -40,10 +40,10 @@ public ObservableBufferBoundarySupplier(ObservableSource<T> source, Callable<? e
 
     @Override
     protected void subscribeActual(Observer<? super U> t) {
-        source.subscribe(new BufferBondarySupplierSubscriber<T, U, B>(new SerializedObserver<U>(t), bufferSupplier, boundarySupplier));
+        source.subscribe(new BufferBoundarySupplierSubscriber<T, U, B>(new SerializedObserver<U>(t), bufferSupplier, boundarySupplier));
     }
     
-    static final class BufferBondarySupplierSubscriber<T, U extends Collection<? super T>, B>
+    static final class BufferBoundarySupplierSubscriber<T, U extends Collection<? super T>, B>
     extends QueueDrainObserver<T, U, U> implements Observer<T>, Disposable {
         /** */
         final Callable<U> bufferSupplier;
@@ -55,8 +55,8 @@ protected void subscribeActual(Observer<? super U> t) {
         
         U buffer;
         
-        public BufferBondarySupplierSubscriber(Observer<? super U> actual, Callable<U> bufferSupplier,
-                Callable<? extends ObservableSource<B>> boundarySupplier) {
+        public BufferBoundarySupplierSubscriber(Observer<? super U> actual, Callable<U> bufferSupplier,
+                                                Callable<? extends ObservableSource<B>> boundarySupplier) {
             super(actual, new MpscLinkedQueue<U>());
             this.bufferSupplier = bufferSupplier;
             this.boundarySupplier = boundarySupplier;
@@ -232,7 +232,7 @@ void next() {
             
             boundary.subscribe(bs);
             
-            fastpathEmit(b, false, this);
+            fastPathEmit(b, false, this);
         }
         
         @Override
@@ -244,11 +244,11 @@ public void accept(Observer<? super U> a, U v) {
     
     static final class BufferBoundarySubscriber<T, U extends Collection<? super T>, B> 
     extends DisposableObserver<B> {
-        final BufferBondarySupplierSubscriber<T, U, B> parent;
+        final BufferBoundarySupplierSubscriber<T, U, B> parent;
         
         boolean once;
         
-        public BufferBoundarySubscriber(BufferBondarySupplierSubscriber<T, U, B> parent) {
+        public BufferBoundarySubscriber(BufferBoundarySupplierSubscriber<T, U, B> parent) {
             this.parent = parent;
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferExactBoundary.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferExactBoundary.java
index f8c2eda13f..f8923b3933 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferExactBoundary.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferExactBoundary.java
@@ -38,10 +38,10 @@ public ObservableBufferExactBoundary(ObservableSource<T> source, ObservableSourc
     
     @Override
     protected void subscribeActual(Observer<? super U> t) {
-        source.subscribe(new BufferExactBondarySubscriber<T, U, B>(new SerializedObserver<U>(t), bufferSupplier, boundary));
+        source.subscribe(new BufferExactBoundarySubscriber<T, U, B>(new SerializedObserver<U>(t), bufferSupplier, boundary));
     }
     
-    static final class BufferExactBondarySubscriber<T, U extends Collection<? super T>, B>
+    static final class BufferExactBoundarySubscriber<T, U extends Collection<? super T>, B>
     extends QueueDrainObserver<T, U, U> implements Observer<T>, Disposable {
         /** */
         final Callable<U> bufferSupplier;
@@ -53,8 +53,8 @@ protected void subscribeActual(Observer<? super U> t) {
         
         U buffer;
         
-        public BufferExactBondarySubscriber(Observer<? super U> actual, Callable<U> bufferSupplier,
-                ObservableSource<B> boundary) {
+        public BufferExactBoundarySubscriber(Observer<? super U> actual, Callable<U> bufferSupplier,
+                                             ObservableSource<B> boundary) {
             super(actual, new MpscLinkedQueue<U>());
             this.bufferSupplier = bufferSupplier;
             this.boundary = boundary;
@@ -176,7 +176,7 @@ void next() {
                 buffer = next;
             }
             
-            fastpathEmit(b, false, this);
+            fastPathEmit(b, false, this);
         }
         
         @Override
@@ -188,9 +188,9 @@ public void accept(Observer<? super U> a, U v) {
     
     static final class BufferBoundarySubscriber<T, U extends Collection<? super T>, B> 
     extends DisposableObserver<B> {
-        final BufferExactBondarySubscriber<T, U, B> parent;
+        final BufferExactBoundarySubscriber<T, U, B> parent;
         
-        public BufferBoundarySubscriber(BufferExactBondarySubscriber<T, U, B> parent) {
+        public BufferBoundarySubscriber(BufferExactBoundarySubscriber<T, U, B> parent) {
             this.parent = parent;
         }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
index 0b0bbbe83e..32c34c5f77 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java
@@ -232,7 +232,7 @@ public void run() {
                 return;
             }
 
-            fastpathEmit(current, false, this);
+            fastPathEmit(current, false, this);
         }
         
         @Override
@@ -248,12 +248,12 @@ public void accept(Observer<? super U> a, U v) {
         final long timeskip;
         final TimeUnit unit;
         final Worker w;
-        
+        final List<U> buffers;
+
+
         Disposable s;
         
-        List<U> buffers;
-        
-        public BufferSkipBoundedSubscriber(Observer<? super U> actual, 
+        public BufferSkipBoundedSubscriber(Observer<? super U> actual,
                 Callable<U> bufferSupplier, long timespan,
                 long timeskip, TimeUnit unit, Worker w) {
             super(actual, new MpscLinkedQueue<U>());
@@ -302,7 +302,7 @@ public void run() {
                             buffers.remove(b);
                         }
                         
-                        fastpathOrderedEmit(b, false, w);
+                        fastPathOrderedEmit(b, false, w);
                     }
                 }, timespan, unit);
             }
@@ -398,7 +398,7 @@ public void run() {
                         buffers.remove(b);
                     }
                     
-                    fastpathOrderedEmit(b, false, w);
+                    fastPathOrderedEmit(b, false, w);
                 }
             }, timespan, unit);
         }
@@ -497,7 +497,7 @@ public void onNext(T t) {
                 timer.dispose();
             }
             
-            fastpathOrderedEmit(b, false, this);
+            fastPathOrderedEmit(b, false, this);
             
             try {
                 b = bufferSupplier.call();
@@ -608,7 +608,7 @@ public void run() {
                 buffer = next;
             }
 
-            fastpathOrderedEmit(current, false, this);
+            fastPathOrderedEmit(current, false, this);
         }
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableCache.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableCache.java
index f5a70c9cda..10a0a7e1c0 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableCache.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCache.java
@@ -62,8 +62,8 @@
     /**
      * Private constructor because state needs to be shared between the Observable body and
      * the onSubscribe function.
-     * @param onSubscribe
-     * @param state
+     * @param source the source Observable to cache
+     * @param state the cache state object
      */
     private ObservableCache(Observable<T> source, CacheState<T> state) {
         super(source);
@@ -74,7 +74,7 @@ private ObservableCache(Observable<T> source, CacheState<T> state) {
     @Override
     protected void subscribeActual(Observer<? super T> t) {
         // we can connect first because we replay everything anyway
-        ReplaySubscription<T> rp = new ReplaySubscription<T>(t, state);
+        ReplayDisposable<T> rp = new ReplayDisposable<T>(t, state);
         state.addProducer(rp);
         
         t.onSubscribe(rp);
@@ -97,7 +97,7 @@ protected void subscribeActual(Observer<? super T> t) {
     
     /**
      * Returns true if there are observers subscribed to this observable.
-     * @return
+     * @return true if the cache has downstream Observers
      */
     /* public */ boolean hasObservers() {
         return state.producers.length != 0;
@@ -105,7 +105,7 @@ protected void subscribeActual(Observer<? super T> t) {
     
     /**
      * Returns the number of events currently cached.
-     * @return
+     * @return the current number of elements in the cache
      */
     /* public */ int cachedEventCount() {
         return state.size();
@@ -122,9 +122,9 @@ protected void subscribeActual(Observer<? super T> t) {
         /** Holds onto the subscriber connected to source. */
         final SequentialDisposable connection;
         /** Guarded by connection (not this). */
-        volatile ReplaySubscription<?>[] producers;
+        volatile ReplayDisposable<?>[] producers;
         /** The default empty array of producers. */
-        static final ReplaySubscription<?>[] EMPTY = new ReplaySubscription<?>[0];
+        static final ReplayDisposable<?>[] EMPTY = new ReplayDisposable<?>[0];
         
         /** Set to true after connection. */
         volatile boolean isConnected;
@@ -142,15 +142,15 @@ public CacheState(Observable<? extends T> source, int capacityHint) {
         }
         /**
          * Adds a ReplayProducer to the producers array atomically.
-         * @param p
+         * @param p the target ReplayDisposable wrapping a downstream Observer with additional state
          */
-        public void addProducer(ReplaySubscription<T> p) {
+        public void addProducer(ReplayDisposable<T> p) {
             // guarding by connection to save on allocating another object
             // thus there are two distinct locks guarding the value-addition and child come-and-go
             synchronized (connection) {
-                ReplaySubscription<?>[] a = producers;
+                ReplayDisposable<?>[] a = producers;
                 int n = a.length;
-                ReplaySubscription<?>[] b = new ReplaySubscription<?>[n + 1];
+                ReplayDisposable<?>[] b = new ReplayDisposable<?>[n + 1];
                 System.arraycopy(a, 0, b, 0, n);
                 b[n] = p;
                 producers = b;
@@ -158,11 +158,11 @@ public void addProducer(ReplaySubscription<T> p) {
         }
         /**
          * Removes the ReplayProducer (if present) from the producers array atomically.
-         * @param p
+         * @param p the target ReplayDisposable wrapping a downstream Observer with additional state
          */
-        public void removeProducer(ReplaySubscription<T> p) {
+        public void removeProducer(ReplayDisposable<T> p) {
             synchronized (connection) {
-                ReplaySubscription<?>[] a = producers;
+                ReplayDisposable<?>[] a = producers;
                 int n = a.length;
                 int j = -1;
                 for (int i = 0; i < n; i++) {
@@ -178,7 +178,7 @@ public void removeProducer(ReplaySubscription<T> p) {
                     producers = EMPTY;
                     return;
                 }
-                ReplaySubscription<?>[] b = new ReplaySubscription<?>[n - 1];
+                ReplayDisposable<?>[] b = new ReplayDisposable<?>[n - 1];
                 System.arraycopy(a, 0, b, 0, j);
                 System.arraycopy(a, j + 1, b, j, n - j - 1);
                 producers = b;
@@ -230,8 +230,8 @@ public void onComplete() {
          * Signals all known children there is work to do.
          */
         void dispatch() {
-            ReplaySubscription<?>[] a = producers;
-            for (ReplaySubscription<?> rp : a) {
+            ReplayDisposable<?>[] a = producers;
+            for (ReplayDisposable<?> rp : a) {
                 rp.replay();
             }
         }
@@ -242,7 +242,7 @@ void dispatch() {
      *
      * @param <T>
      */
-    static final class ReplaySubscription<T> implements Disposable {
+    static final class ReplayDisposable<T> implements Disposable {
         /** The actual child subscriber. */
         final Observer<? super T> child;
         /** The cache state object. */
@@ -271,7 +271,7 @@ void dispatch() {
         /** Set if the Subscription has been cancelled/disposed. */
         volatile boolean cancelled;
         
-        public ReplaySubscription(Observer<? super T> child, CacheState<T> state) {
+        public ReplayDisposable(Observer<? super T> child, CacheState<T> state) {
             this.child = child;
             this.state = state;
         }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java
index dda0c5666e..8d85c73293 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java
@@ -41,7 +41,7 @@ protected void subscribeActual(Observer<? super U> t) {
         }
         
         if (u == null) {
-            EmptyDisposable.error(new NullPointerException("The inital supplier returned a null value"), t);
+            EmptyDisposable.error(new NullPointerException("The initialSupplier returned a null value"), t);
             return;
         }
         
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java
index b29daf1f49..aa35fc25eb 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java
@@ -52,7 +52,7 @@ public void subscribeActual(Observer<? super R> s) {
             sources = new Observable[8];
             for (ObservableSource<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
-                    Observable<? extends T>[] b = new Observable[count + (count >> 2)];
+                    ObservableSource<? extends T>[] b = new ObservableSource[count + (count >> 2)];
                     System.arraycopy(sources, 0, b, 0, count);
                     sources = b;
                 }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java
index d9dfbfc783..7e4224ffcd 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java
@@ -48,8 +48,8 @@ public void subscribeActual(Observer<? super U> s) {
         }
         
         if (delayErrors == ErrorMode.IMMEDIATE) {
-            SerializedObserver<U> ssub = new SerializedObserver<U>(s);
-            source.subscribe(new SourceSubscriber<T, U>(ssub, mapper, bufferSize));
+            SerializedObserver<U> serial = new SerializedObserver<U>(s);
+            source.subscribe(new SourceSubscriber<T, U>(serial, mapper, bufferSize));
         } else {
             source.subscribe(new ConcatMapDelayErrorObserver<T, U>(s, mapper, bufferSize, delayErrors == ErrorMode.END));
         }
@@ -229,7 +229,7 @@ void drain() {
                 if (decrementAndGet() == 0) {
                     break;
                 }
-            };
+            }
         }
         
         static final class InnerSubscriber<U> implements Observer<U> {
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableError.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableError.java
index 6d5ca44c28..8f81b957a5 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableError.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableError.java
@@ -32,7 +32,6 @@ public void subscribeActual(Observer<? super T> s) {
         } catch (Throwable t) {
             Exceptions.throwIfFatal(t);
             error = t;
-            return;
         }
         if (error == null) {
             error = new NullPointerException();
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableGenerate.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableGenerate.java
index 93046006c9..52c8fac04a 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableGenerate.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableGenerate.java
@@ -77,6 +77,7 @@ public void run() {
             S s = state;
             
             if (cancelled) {
+                state = null;
                 dispose(s);
                 return;
             }
@@ -86,6 +87,7 @@ public void run() {
             for (;;) {
                 
                 if (cancelled) {
+                    state = null;
                     dispose(s);
                     return;
                 }
@@ -94,6 +96,7 @@ public void run() {
                     s = f.apply(s, this);
                 } catch (Throwable ex) {
                     Exceptions.throwIfFatal(ex);
+                    state = null;
                     cancelled = true;
                     actual.onError(ex);
                     return;
@@ -101,6 +104,7 @@ public void run() {
                 
                 if (terminate) {
                     cancelled = true;
+                    state = null;
                     dispose(s);
                     return;
                 }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java b/src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java
index 26c8358c32..a127dda87a 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservablePublish.java
@@ -85,7 +85,7 @@ public void subscribe(Observer<? super T> child) {
                          */
                         continue;
                         /*
-                         * Note: although technically corrent, concurrent disconnects can cause 
+                         * Note: although technically correct, concurrent disconnects can cause
                          * unexpected behavior such as child subscribers never receiving anything 
                          * (unless connected again). An alternative approach, similar to 
                          * PublishSubject would be to immediately terminate such child 
@@ -341,7 +341,7 @@ boolean add(InnerProducer<T> producer) {
                 if (producers.compareAndSet(c, u)) {
                     return true;
                 }
-                // if failed, some other operation succeded (another add, remove or termination)
+                // if failed, some other operation succeeded (another add, remove or termination)
                 // so retry
             }
         }
@@ -430,7 +430,7 @@ boolean checkTerminated(Object term, boolean empty) {
                                 ip.child.onComplete();
                             }
                         } finally {
-                            // we explicitely unsubscribe/disconnect from the upstream
+                            // we explicitly unsubscribe/disconnect from the upstream
                             // after we sent out the terminal event to child subscribers
                             dispose();
                         }
@@ -450,7 +450,7 @@ boolean checkTerminated(Object term, boolean empty) {
                             ip.child.onError(t);
                         }
                     } finally {
-                        // we explicitely unsubscribe/disconnect from the upstream
+                        // we explicitly unsubscribe/disconnect from the upstream
                         // after we sent out the terminal event to child subscribers
                         dispose();
                     }
@@ -491,7 +491,7 @@ void dispatch() {
             try {
                 for (;;) {
                     /*
-                     * We need to read terminalEvent before checking the queue for emptyness because
+                     * We need to read terminalEvent before checking the queue for emptiness because
                      * all enqueue happens before setting the terminal event.
                      * If it were the other way around, when the emission is paused between
                      * checking isEmpty and checking terminalEvent, some other thread might
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableRedo.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableRedo.java
index ca5e17ebfe..5e15fef66d 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableRedo.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRedo.java
@@ -35,7 +35,6 @@ public ObservableRedo(ObservableSource<T> source,
     @Override
     public void subscribeActual(Observer<? super T> s) {
         
-        // FIXE use BehaviorSubject? (once available)
         BehaviorSubject<Notification<Object>> subject = BehaviorSubject.create();
         
         final RedoSubscriber<T> parent = new RedoSubscriber<T>(s, subject, source);
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java
index d2bacf99c6..538606aebb 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java
@@ -50,10 +50,10 @@ public Object call() {
     /**
      * Given a connectable observable factory, it multicasts over the generated
      * ConnectableObservable via a selector function.
-     * @param <U> the value type of the NbpConnectableObservable
+     * @param <U> the value type of the ConnectableObservable
      * @param <R> the result value type
-     * @param connectableFactory
-     * @param selector
+     * @param connectableFactory the factory that returns a ConnectableObservable for each individual subscriber
+     * @param selector the function that receives a Observable and should return another Observable that will be subscribed to
      * @return the new NbpObservable instance
      */
     public static <U, R> Observable<R> multicastSelector(
@@ -124,8 +124,8 @@ protected void subscribeActual(Observer<? super T> observer) {
     /**
      * Creates a replaying ConnectableObservable with a size bound buffer.
      * @param <T> the value type
-     * @param source
-     * @param bufferSize
+     * @param source the source Flowable to use
+     * @param bufferSize the maximum number of elements to hold
      * @return the new NbpConnectableObservable instance
      */
     public static <T> ConnectableObservable<T> create(Observable<T> source,
@@ -144,10 +144,10 @@ protected void subscribeActual(Observer<? super T> observer) {
     /**
      * Creates a replaying ConnectableObservable with a time bound buffer.
      * @param <T> the value type
-     * @param source
-     * @param maxAge
-     * @param unit
-     * @param scheduler
+     * @param source the source Flowable to use
+     * @param maxAge the maximum age of entries
+     * @param unit the unit of measure of the age amount
+     * @param scheduler the target scheduler providing the current time
      * @return the new NbpConnectableObservable instance
      */
     public static <T> ConnectableObservable<T> create(Observable<T> source,
@@ -158,11 +158,11 @@ protected void subscribeActual(Observer<? super T> observer) {
     /**
      * Creates a replaying ConnectableObservable with a size and time bound buffer.
      * @param <T> the value type
-     * @param source
-     * @param maxAge
-     * @param unit
-     * @param scheduler
-     * @param bufferSize
+     * @param source the source Flowable to use
+     * @param maxAge the maximum age of entries
+     * @param unit the unit of measure of the age amount
+     * @param scheduler the target scheduler providing the current time
+     * @param bufferSize the maximum number of elements to hold
      * @return the new NbpConnectableObservable instance
      */
     public static <T> ConnectableObservable<T> create(Observable<T> source,
@@ -207,7 +207,7 @@ public void subscribe(Observer<? super T> child) {
                         
                         ReplaySubscriber<T> u = new ReplaySubscriber<T>(buf);
                         // let's try setting it as the current subscriber-to-source
-                        if (!curr.compareAndSet(r, u)) {
+                        if (!curr.compareAndSet(null, u)) {
                             // didn't work, maybe someone else did it or the current subscriber 
                             // to source has just finished
                             continue;
@@ -397,7 +397,7 @@ boolean add(InnerSubscription<T> producer) {
                 if (producers.compareAndSet(c, u)) {
                     return true;
                 }
-                // if failed, some other operation succeded (another add, remove or termination)
+                // if failed, some other operation succeeded (another add, remove or termination)
                 // so retry
             }
         }
@@ -552,7 +552,7 @@ public void dispose() {
         }
         /**
          * Convenience method to auto-cast the index object.
-         * @return
+         * @return the index Object or null
          */
         @SuppressWarnings("unchecked")
         <U> U index() {
@@ -567,12 +567,12 @@ public void dispose() {
     interface ReplayBuffer<T> {
         /**
          * Adds a regular value to the buffer.
-         * @param value
+         * @param value the value to be stored in the buffer
          */
         void next(T value);
         /**
          * Adds a terminal exception to the buffer
-         * @param e
+         * @param e the error to be stored in the buffer
          */
         void error(Throwable e);
         /**
@@ -584,7 +584,7 @@ public void dispose() {
          * subscriber inside the output if there
          * is new value and requests available at the
          * same time.
-         * @param output
+         * @param output the receiver of the buffered events
          */
         void replay(InnerSubscription<T> output);
     }
@@ -638,11 +638,11 @@ public void replay(InnerSubscription<T> output) {
                 }
                 int sourceIndex = size;
                 
-                Integer destIndexObject = output.index();
-                int destIndex = destIndexObject != null ? destIndexObject.intValue() : 0;
+                Integer destinationIndexObject = output.index();
+                int destinationIndex = destinationIndexObject != null ? destinationIndexObject : 0;
                 
-                while (destIndex < sourceIndex) {
-                    Object o = get(destIndex);
+                while (destinationIndex < sourceIndex) {
+                    Object o = get(destinationIndex);
                     try {
                         if (NotificationLite.accept(o, child)) {
                             return;
@@ -658,10 +658,10 @@ public void replay(InnerSubscription<T> output) {
                     if (output.isDisposed()) {
                         return;
                     }
-                    destIndex++;
+                    destinationIndex++;
                 }
 
-                output.index = destIndex;
+                output.index = destinationIndex;
                 
                 synchronized (output) {
                     if (!output.missed) {
@@ -707,7 +707,7 @@ public BoundedReplayBuffer() {
         
         /**
          * Add a new node to the linked list.
-         * @param n
+         * @param n the Node instance to add as last
          */
         final void addLast(Node n) {
             tail.set(n);
@@ -740,7 +740,7 @@ final void removeFirst() {
         }
         /**
          * Arranges the given node is the new head from now on.
-         * @param n
+         * @param n the Node instance to set as first
          */
         final void setFirst(Node n) {
             set(n);
@@ -833,8 +833,8 @@ public final void replay(InnerSubscription<T> output) {
         /**
          * Override this to wrap the NotificationLite object into a
          * container to be used later by truncate.
-         * @param value
-         * @return
+         * @param value the value to transform into the internal representation
+         * @return the transformed value
          */
         Object enterTransform(Object value) {
             return value;
@@ -842,8 +842,8 @@ Object enterTransform(Object value) {
         /**
          * Override this to unwrap the transformed value into a
          * NotificationLite object.
-         * @param value
-         * @return
+         * @param value the value in the internal representation to transform
+         * @return the transformed value
          */
         Object leaveTransform(Object value) {
             return value;
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleTimed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleTimed.java
index d01a8d226a..e5bbdff235 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleTimed.java
@@ -69,7 +69,6 @@ public void onSubscribe(Disposable s) {
                     Disposable d = scheduler.schedulePeriodicallyDirect(this, period, period, unit);
                     if (!timer.compareAndSet(null, d)) {
                         d.dispose();
-                        return;
                     }
                 }
             }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindow.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindow.java
index 0e29834302..b3b9f5cb95 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindow.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindow.java
@@ -83,13 +83,15 @@ public void onNext(T t) {
                 actual.onNext(w);
             }
 
-            w.onNext(t);
-            if (++size >= count) {
-                size = 0;
-                window = null;
-                w.onComplete();
-                if (cancelled) {
-                    s.dispose();
+            if (w != null) {
+                w.onNext(t);
+                if (++size >= count) {
+                    size = 0;
+                    window = null;
+                    w.onComplete();
+                    if (cancelled) {
+                        s.dispose();
+                    }
                 }
             }
         }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
index ff1819e9d3..66dcb2d87e 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySupplier.java
@@ -110,7 +110,6 @@ public void onSubscribe(Disposable s) {
                 if (boundary.compareAndSet(null, inner)) {
                     windows.getAndIncrement();
                     p.subscribe(inner);
-                    return;
                 }
             }
         }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java
index e3d014ac27..4bf445573c 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java
@@ -121,7 +121,6 @@ public void onSubscribe(Disposable s) {
                     Disposable d = scheduler.schedulePeriodicallyDirect(this, timespan, timespan, unit);
                     if (!timer.compareAndSet(null, d)) {
                         d.dispose();
-                        return;
                     }
                     
                 }
@@ -343,7 +342,6 @@ public void onSubscribe(Disposable s) {
                 
                 if (!timer.compareAndSet(null, d)) {
                     d.dispose();
-                    return;
                 }
             }
         }
@@ -728,7 +726,7 @@ void drainLoop() {
                             }
                         } else {
                             for (UnicastSubject<T> w : ws) {
-                                w.onError(e);
+                                w.onComplete();
                             }
                         }
                         ws.clear();
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromMany.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromMany.java
index 9a159c9a46..86d6381cdc 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromMany.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFromMany.java
@@ -104,7 +104,7 @@ public R apply(T t) throws Exception {
         
         final Function<? super Object[], R> combiner;
         
-        final WithlatestInnerSubscriber[] subscribers;
+        final WithLatestInnerSubscriber[] subscribers;
         
         final AtomicReferenceArray<Object> values;
         
@@ -117,9 +117,9 @@ public R apply(T t) throws Exception {
         public WithLatestFromObserver(Observer<? super R> actual, Function<? super Object[], R> combiner, int n) {
             this.actual = actual;
             this.combiner = combiner;
-            WithlatestInnerSubscriber[] s = new WithlatestInnerSubscriber[n];
+            WithLatestInnerSubscriber[] s = new WithLatestInnerSubscriber[n];
             for (int i = 0; i < n; i++) {
-                s[i] = new WithlatestInnerSubscriber(this, i);
+                s[i] = new WithLatestInnerSubscriber(this, i);
             }
             this.subscribers = s;
             this.values = new AtomicReferenceArray<Object>(n);
@@ -128,7 +128,7 @@ public WithLatestFromObserver(Observer<? super R> actual, Function<? super Objec
         }
         
         void subscribe(ObservableSource<?>[] others, int n) {
-            WithlatestInnerSubscriber[] subscribers = this.subscribers;
+            WithLatestInnerSubscriber[] subscribers = this.subscribers;
             AtomicReference<Disposable> s = this.d;
             for (int i = 0; i < n; i++) {
                 if (DisposableHelper.isDisposed(s.get()) || done) {
@@ -229,7 +229,7 @@ void innerComplete(int index, boolean nonEmpty) {
         }
         
         void cancelAllBut(int index) {
-            WithlatestInnerSubscriber[] subscribers = this.subscribers;
+            WithLatestInnerSubscriber[] subscribers = this.subscribers;
             for (int i = 0; i < subscribers.length; i++) {
                 if (i != index) {
                     subscribers[i].dispose();
@@ -238,7 +238,7 @@ void cancelAllBut(int index) {
         }
     }
 
-    static final class WithlatestInnerSubscriber 
+    static final class WithLatestInnerSubscriber
     extends AtomicReference<Disposable>
     implements Observer<Object>, Disposable {
         /** */
@@ -250,7 +250,7 @@ void cancelAllBut(int index) {
         
         boolean hasValue;
         
-        public WithlatestInnerSubscriber(WithLatestFromObserver<?, ?> parent, int index) {
+        public WithLatestInnerSubscriber(WithLatestFromObserver<?, ?> parent, int index) {
             this.parent = parent;
             this.index = index;
         }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java
index 262eae12bd..dd354f262d 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java
@@ -52,7 +52,7 @@ public void subscribeActual(Observer<? super R> s) {
             sources = new Observable[8];
             for (ObservableSource<? extends T> p : sourcesIterable) {
                 if (count == sources.length) {
-                    Observable<? extends T>[] b = new Observable[count + (count >> 2)];
+                    ObservableSource<? extends T>[] b = new ObservableSource[count + (count >> 2)];
                     System.arraycopy(sources, 0, b, 0, count);
                     sources = b;
                 }
diff --git a/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java
index e53bb564ff..b3abc75818 100644
--- a/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java
+++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java
@@ -95,10 +95,7 @@ else if (currConsumerNode != lvProducerNode()) {
     
     @Override
     public boolean offer(T v1, T v2) {
-        if (offer(v1)) {
-            return offer(v2); 
-        }
-        return false;
+        return offer(v1) && offer(v2);
     }
     
     @Override
diff --git a/src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java b/src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java
index d1f64ace23..ed07812a6f 100644
--- a/src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java
+++ b/src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java
@@ -75,10 +75,7 @@ else if (null != lvElement(offset)){
     @Override
     public boolean offer(E v1, E v2) {
         // FIXME 
-        if (offer(v1)) {
-            return offer(v2);
-        }
-        return false;
+        return offer(v1) && offer(v2);
     }
 
     @Override
diff --git a/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
index a0f0fd097e..f1f0a31183 100644
--- a/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
+++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java
@@ -34,9 +34,11 @@
     
     int producerLookAheadStep;
     long producerLookAhead;
-    int producerMask;
+
+    final int producerMask;
+
     AtomicReferenceArray<Object> producerBuffer;
-    int consumerMask;
+    final int consumerMask;
     AtomicReferenceArray<Object> consumerBuffer;
     final AtomicLong consumerIndex = new AtomicLong();
 
diff --git a/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java
index f626c56f82..672f038e6c 100644
--- a/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java
+++ b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java
@@ -31,7 +31,7 @@
     static final FixedSchedulerPool NONE = new FixedSchedulerPool(0);
     /** Manages a fixed number of workers. */
     private static final String THREAD_NAME_PREFIX = "RxComputationThreadPool";
-    private static final RxThreadFactory THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX);
+    static final RxThreadFactory THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX);
     /** 
      * Key to setting the maximum number of computation scheduler threads.
      * Zero or less is interpreted as use available. Capped by available.
@@ -46,10 +46,10 @@
 
     static {
         int maxThreads = Integer.getInteger(KEY_MAX_THREADS, 0);
-        int ncpu = Runtime.getRuntime().availableProcessors();
+        int cpuCount = Runtime.getRuntime().availableProcessors();
         int max;
-        if (maxThreads <= 0 || maxThreads > ncpu) {
-            max = ncpu;
+        if (maxThreads <= 0 || maxThreads > cpuCount) {
+            max = cpuCount;
         } else {
             max = maxThreads;
         }
diff --git a/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java b/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java
index d9038e18c0..dd6941c80a 100644
--- a/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java
+++ b/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java
@@ -29,17 +29,17 @@
  */
 public final class IoScheduler extends Scheduler {
     private static final String WORKER_THREAD_NAME_PREFIX = "RxCachedThreadScheduler";
-    private static final RxThreadFactory WORKER_THREAD_FACTORY =
+    static final RxThreadFactory WORKER_THREAD_FACTORY =
             new RxThreadFactory(WORKER_THREAD_NAME_PREFIX);
 
     private static final String EVICTOR_THREAD_NAME_PREFIX = "RxCachedWorkerPoolEvictor";
-    private static final RxThreadFactory EVICTOR_THREAD_FACTORY =
+    static final RxThreadFactory EVICTOR_THREAD_FACTORY =
             new RxThreadFactory(EVICTOR_THREAD_NAME_PREFIX);
 
     private static final long KEEP_ALIVE_TIME = 60;
     private static final TimeUnit KEEP_ALIVE_UNIT = TimeUnit.SECONDS;
     
-    static final ThreadWorker SHUTDOWN_THREADWORKER;
+    static final ThreadWorker SHUTDOWN_THREAD_WORKER;
     final AtomicReference<CachedWorkerPool> pool;
     
     static final CachedWorkerPool NONE;
@@ -47,14 +47,14 @@
         NONE = new CachedWorkerPool(0, null);
         NONE.shutdown();
 
-        SHUTDOWN_THREADWORKER = new ThreadWorker(new RxThreadFactory("RxCachedThreadSchedulerShutdown"));
-        SHUTDOWN_THREADWORKER.dispose();
+        SHUTDOWN_THREAD_WORKER = new ThreadWorker(new RxThreadFactory("RxCachedThreadSchedulerShutdown"));
+        SHUTDOWN_THREAD_WORKER.dispose();
     }
     
     static final class CachedWorkerPool {
         private final long keepAliveTime;
         private final ConcurrentLinkedQueue<ThreadWorker> expiringWorkerQueue;
-        private final CompositeDisposable allWorkers;
+        final CompositeDisposable allWorkers;
         private final ScheduledExecutorService evictorService;
         private final Future<?> evictorTask;
 
@@ -86,7 +86,7 @@ public void run() {
 
         ThreadWorker get() {
             if (allWorkers.isDisposed()) {
-                return SHUTDOWN_THREADWORKER;
+                return SHUTDOWN_THREAD_WORKER;
             }
             while (!expiringWorkerQueue.isEmpty()) {
                 ThreadWorker threadWorker = expiringWorkerQueue.poll();
diff --git a/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
index 4876f061f9..9f8eb35eba 100644
--- a/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
+++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
@@ -31,8 +31,7 @@
     volatile boolean disposed;
     
     public NewThreadWorker(ThreadFactory threadFactory) {
-        ScheduledExecutorService exec = SchedulerPoolFactory.create(threadFactory);
-        executor = exec;
+        executor = SchedulerPoolFactory.create(threadFactory);
     }
 
     @Override
@@ -51,9 +50,9 @@ public Disposable schedule(final Runnable action, long delayTime, TimeUnit unit)
     /**
      * Schedules the given runnable on the underlying executor directly and
      * returns its future wrapped into a Disposable.
-     * @param run
-     * @param delayTime
-     * @param unit
+     * @param run the Runnable to execute in a delayed fashion
+     * @param delayTime the delay amount
+     * @param unit the delay time unit
      * @return the ScheduledRunnable instance
      */
     public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) {
@@ -75,10 +74,10 @@ public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit un
     /**
      * Schedules the given runnable periodically on the underlying executor directly
      * and returns its future wrapped into a Disposable.
-     * @param run
-     * @param initialDelay
-     * @param period
-     * @param unit
+     * @param run the Runnable to execute in a periodic fashion
+     * @param initialDelay the initial delay amount
+     * @param period the repeat period amount
+     * @param unit the time unit for both the initialDelay and period
      * @return the ScheduledRunnable instance
      */
     public Disposable schedulePeriodicallyDirect(final Runnable run, long initialDelay, long period, TimeUnit unit) {
diff --git a/src/main/java/io/reactivex/internal/schedulers/RxThreadFactory.java b/src/main/java/io/reactivex/internal/schedulers/RxThreadFactory.java
index a4ba7ff38f..55910afcf5 100644
--- a/src/main/java/io/reactivex/internal/schedulers/RxThreadFactory.java
+++ b/src/main/java/io/reactivex/internal/schedulers/RxThreadFactory.java
@@ -22,7 +22,7 @@
     
     final String prefix;
     
-    static volatile boolean CREATE_TRACE = false;
+    static volatile boolean CREATE_TRACE;
     
     public RxThreadFactory(String prefix) {
         this.prefix = prefix;
diff --git a/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java b/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
index e7ce7d0cff..2174adec2f 100644
--- a/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
+++ b/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
@@ -62,7 +62,7 @@ public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
     }
 
     static final class TrampolineWorker extends Scheduler.Worker implements Disposable {
-        private final PriorityBlockingQueue<TimedRunnable> queue = new PriorityBlockingQueue<TimedRunnable>();
+        final PriorityBlockingQueue<TimedRunnable> queue = new PriorityBlockingQueue<TimedRunnable>();
         
         private final AtomicInteger wip = new AtomicInteger();
 
diff --git a/src/main/java/io/reactivex/internal/subscribers/completable/SubscriberCompletableObserver.java b/src/main/java/io/reactivex/internal/subscribers/completable/SubscriberCompletableObserver.java
index 98da540c2a..d0ff7f2ebb 100644
--- a/src/main/java/io/reactivex/internal/subscribers/completable/SubscriberCompletableObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/completable/SubscriberCompletableObserver.java
@@ -49,7 +49,7 @@ public void onSubscribe(Disposable d) {
 
     @Override
     public void request(long n) {
-        // ingored, no values emitted anyway
+        // ignored, no values emitted anyway
     }
 
     @Override
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableConditionalSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableConditionalSubscriber.java
index 6010f1a504..4b2d17bfc9 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableConditionalSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableConditionalSubscriber.java
@@ -16,7 +16,6 @@
 import org.reactivestreams.Subscription;
 
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -111,10 +110,7 @@ protected final void next(R value) {
      * false indicates dropped value
      */
     protected final boolean tryNext(R value) {
-        if (done) {
-            return false;
-        }
-        return actual.tryOnNext(value);
+        return !done && actual.tryOnNext(value);
     }
     
     @Override
@@ -146,16 +142,6 @@ public void onComplete() {
         actual.onComplete();
     }
     
-    /**
-     * Checks if the value is null and if so, throws a NullPointerException.
-     * @param value the value to check
-     * @param message the message to indicate the source of the value
-     * @return the value if not null
-     */
-    protected final <V> V nullCheck(V value, String message) {
-        return ObjectHelper.requireNonNull(value, message);
-    }
-    
     /**
      * Calls the upstream's QueueSubscription.requestFusion with the mode and
      * saves the established mode in {@link #sourceMode}.
@@ -202,7 +188,7 @@ protected final int transitiveBoundaryFusion(int mode) {
     }
 
     // --------------------------------------------------------------
-    // Default implementation of the RS and QS protocol (overridable)
+    // Default implementation of the RS and QS protocol (can be overridden)
     // --------------------------------------------------------------
     
     @Override
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableSubscriber.java
index 926804041e..d39e8bcb43 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableSubscriber.java
@@ -16,7 +16,6 @@
 import org.reactivestreams.*;
 
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.QueueSubscription;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -131,16 +130,6 @@ public void onComplete() {
         actual.onComplete();
     }
     
-    /**
-     * Checks if the value is null and if so, throws a NullPointerException.
-     * @param value the value to check
-     * @param message the message to indicate the source of the value
-     * @return the value if not null
-     */
-    protected final <V> V nullCheck(V value, String message) {
-        return ObjectHelper.requireNonNull(value, message);
-    }
-    
     /**
      * Calls the upstream's QueueSubscription.requestFusion with the mode and
      * saves the established mode in {@link #sourceMode}.
@@ -187,7 +176,7 @@ protected final int transitiveBoundaryFusion(int mode) {
     }
 
     // --------------------------------------------------------------
-    // Default implementation of the RS and QS protocol (overridable)
+    // Default implementation of the RS and QS protocol (can be overridden)
     // --------------------------------------------------------------
     
     @Override
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java
index e43b4c7562..896b61b0f8 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java
@@ -80,7 +80,7 @@ public final T blockingGet() {
         
         Throwable e = error;
         if (e != null) {
-            Exceptions.propagate(e);
+            throw Exceptions.propagate(e);
         }
         return value;
     }
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/QueueDrainSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/QueueDrainSubscriber.java
index 0cf40a15eb..1ce9607520 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/QueueDrainSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/QueueDrainSubscriber.java
@@ -63,7 +63,7 @@ public final boolean fastEnter() {
         return wip.get() == 0 && wip.compareAndSet(0, 1);
     }
     
-    protected final void fastpathEmit(U value, boolean delayError) {
+    protected final void fastPathEmit(U value, boolean delayError) {
         final Subscriber<? super V> s = actual;
         final SimpleQueue<U> q = queue;
         
@@ -89,7 +89,7 @@ protected final void fastpathEmit(U value, boolean delayError) {
         QueueDrainHelper.drainLoop(q, s, delayError, this);
     }
 
-    protected final void fastpathEmitMax(U value, boolean delayError, Disposable dispose) {
+    protected final void fastPathEmitMax(U value, boolean delayError, Disposable dispose) {
         final Subscriber<? super V> s = actual;
         final SimpleQueue<U> q = queue;
         
@@ -118,7 +118,7 @@ protected final void fastpathEmitMax(U value, boolean delayError, Disposable dis
         QueueDrainHelper.drainMaxLoop(q, s, delayError, dispose, this);
     }
 
-    protected final void fastpathOrderedEmitMax(U value, boolean delayError, Disposable dispose) {
+    protected final void fastPathOrderedEmitMax(U value, boolean delayError, Disposable dispose) {
         final Subscriber<? super V> s = actual;
         final SimpleQueue<U> q = queue;
         
@@ -154,10 +154,10 @@ protected final void fastpathOrderedEmitMax(U value, boolean delayError, Disposa
 
     /**
      * Makes sure the fast-path emits in order.
-     * @param value
-     * @param delayError
+     * @param value the value to emit or queue up
+     * @param delayError if true, errors are delayed until the source has terminated
      */
-    protected final void fastpathOrderedEmit(U value, boolean delayError) {
+    protected final void fastPathOrderedEmit(U value, boolean delayError) {
         final Subscriber<? super V> s = actual;
         final SimpleQueue<U> q = queue;
         
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/BasicFuseableObserver.java b/src/main/java/io/reactivex/internal/subscribers/observable/BasicFuseableObserver.java
index 1a3830fee9..935abf2341 100644
--- a/src/main/java/io/reactivex/internal/subscribers/observable/BasicFuseableObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/BasicFuseableObserver.java
@@ -187,7 +187,7 @@ protected final int transitiveBoundaryFusion(int mode) {
     }
 
     // --------------------------------------------------------------
-    // Default implementation of the RS and QS protocol (overridable)
+    // Default implementation of the RS and QS protocol (can be overridden)
     // --------------------------------------------------------------
     
     @Override
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/BlockingSingleObserver.java b/src/main/java/io/reactivex/internal/subscribers/observable/BlockingSingleObserver.java
index 7ece21c51a..7a7ceec343 100644
--- a/src/main/java/io/reactivex/internal/subscribers/observable/BlockingSingleObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/BlockingSingleObserver.java
@@ -76,7 +76,7 @@ public final T blockingGet() {
         
         Throwable e = error;
         if (e != null) {
-            Exceptions.propagate(e);
+            throw Exceptions.propagate(e);
         }
         return value;
     }
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/QueueDrainObserver.java b/src/main/java/io/reactivex/internal/subscribers/observable/QueueDrainObserver.java
index 01038c517e..c031a0ff18 100644
--- a/src/main/java/io/reactivex/internal/subscribers/observable/QueueDrainObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/QueueDrainObserver.java
@@ -61,7 +61,7 @@ public final boolean fastEnter() {
         return wip.get() == 0 && wip.compareAndSet(0, 1);
     }
     
-    protected final void fastpathEmit(U value, boolean delayError, Disposable dispose) {
+    protected final void fastPathEmit(U value, boolean delayError, Disposable dispose) {
         final Observer<? super V> s = actual;
         final SimpleQueue<U> q = queue;
         
@@ -81,10 +81,10 @@ protected final void fastpathEmit(U value, boolean delayError, Disposable dispos
 
     /**
      * Makes sure the fast-path emits in order.
-     * @param value
-     * @param delayError
+     * @param value the value to emit or queue up
+     * @param delayError if true, errors are delayed until the source has terminated
      */
-    protected final void fastpathOrderedEmit(U value, boolean delayError, Disposable disposable) {
+    protected final void fastPathOrderedEmit(U value, boolean delayError, Disposable disposable) {
         final Observer<? super V> s = actual;
         final SimpleQueue<U> q = queue;
         
diff --git a/src/main/java/io/reactivex/internal/subscriptions/ArrayCompositeSubscription.java b/src/main/java/io/reactivex/internal/subscriptions/ArrayCompositeSubscription.java
index 76d966c69d..043e208bba 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/ArrayCompositeSubscription.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/ArrayCompositeSubscription.java
@@ -36,8 +36,8 @@ public ArrayCompositeSubscription(int capacity) {
 
     /**
      * Sets the resource at the specified index and disposes the old resource.
-     * @param index
-     * @param resource
+     * @param index the index of the resource to set
+     * @param resource the new resource
      * @return true if the resource has ben set, false if the composite has been disposed
      */
     public boolean setResource(int index, Subscription resource) {
@@ -58,8 +58,8 @@ public boolean setResource(int index, Subscription resource) {
     
     /**
      * Replaces the resource at the specified index and returns the old resource.
-     * @param index
-     * @param resource
+     * @param index the index of the resource to replace
+     * @param resource the new resource
      * @return the old resource, can be null
      */
     public Subscription replaceResource(int index, Subscription resource) {
diff --git a/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java b/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java
index d081614d7e..79dffb4582 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java
@@ -81,7 +81,7 @@ public boolean isDisposed() {
     /**
      * Sets a new resource and disposes the currently held resource.
      * @param r the new resource to set
-     * @return false if this AyncSubscription has been cancelled/disposed
+     * @return false if this AsyncSubscription has been cancelled/disposed
      * @see #replaceResource(Disposable)
      */
     public boolean setResource(Disposable r) {
diff --git a/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java b/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
index 0d945a607d..61c76c7bb3 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
@@ -44,13 +44,13 @@
     /** Constant for the this state. */
     static final long CANCELLED = 4;
 
-    /** Constant for the {@link fusionState} field. */
+    /** Constant for the {@link #fusionState} field. */
     static final int NOT_FUSED = 0;
-    /** Constant for the {@link fusionState} field. */
+    /** Constant for the {@link #fusionState} field. */
     static final int EMPTY = 1;
-    /** Constant for the {@link fusionState} field. */
+    /** Constant for the {@link #fusionState} field. */
     static final int HAS_VALUE = 2;
-    /** Constant for the {@link fusionState} field. */
+    /** Constant for the {@link #fusionState} field. */
     static final int CONSUMED = 3;
     
     public DeferredScalarSubscription(Subscriber<? super T> actual) {
diff --git a/src/main/java/io/reactivex/internal/subscriptions/ScalarSubscription.java b/src/main/java/io/reactivex/internal/subscriptions/ScalarSubscription.java
index c715eba829..492a1091b8 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/ScalarSubscription.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/ScalarSubscription.java
@@ -49,10 +49,9 @@ public void request(long n) {
             return;
         }
         if (compareAndSet(NO_REQUEST, REQUESTED)) {
-            T v = value;
             Subscriber<? super T> s = subscriber;
 
-            s.onNext(v);
+            s.onNext(value);
             if (get() != CANCELLED) {
                 s.onComplete();
             }
diff --git a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
index 8bc83f7718..bb66811bd6 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
@@ -133,7 +133,7 @@ public static boolean setOnce(AtomicReference<Subscription> field, Subscription
 
     /**
      * Atomically sets the subscription on the field but does not
-     * cancel the previouls subscription.
+     * cancel the previous subscription.
      * @param field the target field to set the new subscription on
      * @param s the new subscription
      * @return true if the operation succeeded, false if the target field
diff --git a/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java b/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
index 4f772f8566..c9f41ac3bc 100644
--- a/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
+++ b/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
@@ -22,7 +22,7 @@
  */
 public class AppendOnlyLinkedArrayList<T> {
     final int capacity;
-    Object[] head;
+    final Object[] head;
     Object[] tail;
     int offset;
     
@@ -65,7 +65,7 @@ public void setFirst(T value) {
     /**
      * Loops through all elements of the list.
      * @param consumer the consumer of elements
-     * @throws Exception
+     * @throws Exception if the consumer throws
      */
     @SuppressWarnings("unchecked")
     public void forEach(Consumer<? super T> consumer) throws Exception {
@@ -87,7 +87,7 @@ public void forEach(Consumer<? super T> consumer) throws Exception {
      * Loops over all elements of the array until a null element is encountered or
      * the given predicate returns true.
      * @param consumer the consumer of values that returns true if the forEach should terminate
-     * @throws Exception
+     * @throws Exception if the predicate throws
      */
     @SuppressWarnings("unchecked")
     public void forEachWhile(Predicate<? super T> consumer) throws Exception {
diff --git a/src/main/java/io/reactivex/internal/util/LinkedArrayList.java b/src/main/java/io/reactivex/internal/util/LinkedArrayList.java
index 5c617ad0e9..ff736edd8e 100644
--- a/src/main/java/io/reactivex/internal/util/LinkedArrayList.java
+++ b/src/main/java/io/reactivex/internal/util/LinkedArrayList.java
@@ -40,7 +40,7 @@
     int indexInTail;
     /**
      * Constructor with the capacity hint of each array segment.
-     * @param capacityHint
+     * @param capacityHint the expected number of elements to hold (can grow beyond that)
      */
     public LinkedArrayList(int capacityHint) {
         this.capacityHint = capacityHint;
diff --git a/src/main/java/io/reactivex/internal/util/NotificationLite.java b/src/main/java/io/reactivex/internal/util/NotificationLite.java
index 6d2e4f818c..81f3de0215 100644
--- a/src/main/java/io/reactivex/internal/util/NotificationLite.java
+++ b/src/main/java/io/reactivex/internal/util/NotificationLite.java
@@ -35,7 +35,7 @@
         @Override
         public String toString() {
             return "NotificationLite.Complete";
-        };
+        }
     }
     
     /**
diff --git a/src/main/java/io/reactivex/internal/util/OpenHashSet.java b/src/main/java/io/reactivex/internal/util/OpenHashSet.java
index 51eb6d85f1..d15e21785a 100644
--- a/src/main/java/io/reactivex/internal/util/OpenHashSet.java
+++ b/src/main/java/io/reactivex/internal/util/OpenHashSet.java
@@ -141,9 +141,7 @@ public void clear(Consumer<? super T> clearAction) throws Exception {
             return;
         }
         T[] a = keys;
-        int len = a.length;
-        for (int i = 0; i < len; i++) {
-            T e = a[i];
+        for (T e : a) {
             if (e != null) {
                 clearAction.accept(e);
             }
diff --git a/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
index 45d6e57b01..e9e486227c 100644
--- a/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
+++ b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
@@ -34,8 +34,8 @@
      * A fast-path queue-drain serialization logic.
      * <p>The decrementing of the state is left to the drain callback.
      * @param <T> the instance type
-     * @param instance
-     * @param fastPath called if the instance is uncontended.
+     * @param instance the work-in-progress counter
+     * @param fastPath called if the instance is not contended.
      * @param queue called if the instance is contended to queue up work
      * @param drain called if the instance transitions to the drain state successfully
      */
@@ -57,14 +57,14 @@
 
     /**
      * A fast-path queue-drain serialization logic with the ability to leave the state
-     * in fastpath/drain mode or not continue after the call to queue.
+     * in fast-path/drain mode or not continue after the call to queue.
      * <p>The decrementing of the state is left to the drain callback.
      * @param <T> the instance type
-     * @param instance
-     * @param fastPath
-     * @param queue
-     * @param drain
-     * @throws Exception
+     * @param instance the work-in-progress counter
+     * @param fastPath called if the instance is not contended.
+     * @param queue called if the instance is contended to queue up work
+     * @param drain called if the instance transitions to the drain state successfully
+     * @throws Exception if the callbacks throw
      */
     public static <T> void queueDrainIf(AtomicInteger instance,
             BooleanSupplier fastPath, BooleanSupplier queue, Runnable drain) throws Exception  {
@@ -90,10 +90,10 @@
      * A fast-path queue-drain serialization logic where the drain is looped until
      * the instance state reaches 0 again.
      * @param <T> the instance type
-     * @param instance
-     * @param fastPath
-     * @param queue
-     * @param drain
+     * @param instance the work-in-progress counter
+     * @param fastPath called if the instance is not contended.
+     * @param queue called if the instance is contended to queue up work
+     * @param drain called if the instance transitions to the drain state successfully
      */
     public static <T> void queueDrainLoop(AtomicInteger instance,
             Runnable fastPath, Runnable queue, Runnable drain) {
@@ -121,13 +121,13 @@
     
     /**
      * A fast-path queue-drain serialization logic with looped drain call and the ability to leave the state
-     * in fastpath/drain mode or not continue after the call to queue.
+     * in fast-path/drain mode or not continue after the call to queue.
      * @param <T> the instance type
-     * @param instance
-     * @param fastPath
-     * @param queue
-     * @param drain
-     * @throws Exception
+     * @param instance the work-in-progress counter
+     * @param fastPath called if the instance is not contended.
+     * @param queue called if the instance is contended to queue up work
+     * @param drain called if the instance transitions to the drain state successfully
+     * @throws Exception if the callbacks throw
      */
     public static <T> void queueDrainLoopIf(AtomicInteger instance,
             BooleanSupplier fastPath, BooleanSupplier queue, BooleanSupplier drain) throws Exception {
@@ -255,7 +255,7 @@
                 if (r != 0L) {
                     if (qd.accept(a, v)) {
                         if (r != Long.MAX_VALUE) {
-                            r = qd.produced(1);
+                            qd.produced(1);
                         }
                     }
                 } else {
@@ -419,7 +419,7 @@ public static void request(Subscription s, int prefetch) {
     static final long REQUESTED_MASK = 0x7FFFFFFFFFFFFFFFL;
 
     /**
-     * Accumulates requests (validated) and handles the completed mode draining of the queue based on the requests.
+     * Accumulates requests (not validated) and handles the completed mode draining of the queue based on the requests.
      * 
      * <p>
      * Post-completion backpressure handles the case when a source produces values based on
@@ -430,11 +430,11 @@ public static void request(Subscription s, int prefetch) {
      * in completed mode, requests no-longer reach the upstream but help in draining the queue.
      *
      * @param <T> the value type emitted
-     * @param n
-     * @param actual
-     * @param queue
-     * @param state
-     * @param isCancelled
+     * @param n the request amount, positive (not validated)
+     * @param actual the target Subscriber to send events to
+     * @param queue the queue to drain if in the post-complete state
+     * @param state holds the request amount and the post-completed flag
+     * @param isCancelled a supplier that returns true if the drain has been cancelled
      * @return true if the state indicates a completion state.
      */
     public static <T> boolean postCompleteRequest(long n,
@@ -478,11 +478,11 @@ static boolean isCancelled(BooleanSupplier cancelled) {
     /**
      * Drains the queue based on the outstanding requests in post-completed mode (only!).
      *
-     * @param n
-     * @param actual
-     * @param queue
-     * @param state
-     * @param isCancelled
+     * @param n the current request amount
+     * @param actual the target Subscriber to send events to
+     * @param queue the queue to drain if in the post-complete state
+     * @param state holds the request amount and the post-completed flag
+     * @param isCancelled a supplier that returns true if the drain has been cancelled
      * @return true if the queue was completely drained or the drain process was cancelled
      */
     static <T> boolean postCompleteDrain(long n,
@@ -575,10 +575,10 @@ static boolean isCancelled(BooleanSupplier cancelled) {
      * allowed.
      *
      * @param <T> the value type emitted
-     * @param actual
-     * @param queue
-     * @param state
-     * @param isCancelled
+     * @param actual the target Subscriber to send events to
+     * @param queue the queue to drain if in the post-complete state
+     * @param state holds the request amount and the post-completed flag
+     * @param isCancelled a supplier that returns true if the drain has been cancelled
      */
     public static <T> void postComplete(Subscriber<? super T> actual,
                                         Queue<T> queue,
diff --git a/src/main/java/io/reactivex/observers/SafeObserver.java b/src/main/java/io/reactivex/observers/SafeObserver.java
index 3d99e59d6f..ee53f4391a 100644
--- a/src/main/java/io/reactivex/observers/SafeObserver.java
+++ b/src/main/java/io/reactivex/observers/SafeObserver.java
@@ -148,9 +148,13 @@ public void onError(Throwable t) {
             }
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
-            t2.suppress(e);
-            
-            RxJavaPlugins.onError(t2);
+            if (t2 == null) {
+                RxJavaPlugins.onError(e);
+            } else {
+                t2.suppress(e);
+
+                RxJavaPlugins.onError(t2);
+            }
         }
     }
     
diff --git a/src/main/java/io/reactivex/observers/TestObserver.java b/src/main/java/io/reactivex/observers/TestObserver.java
index 4e26e8757f..c71f58f562 100644
--- a/src/main/java/io/reactivex/observers/TestObserver.java
+++ b/src/main/java/io/reactivex/observers/TestObserver.java
@@ -29,7 +29,7 @@
  * An Observer that records events and allows making assertions about them.
  *
  * <p>You can override the onSubscribe, onNext, onError, onComplete and
- * cancel methods but not the others (this is by desing).
+ * cancel methods but not the others (this is by design).
  * 
  * <p>The TestSubscriber implements Disposable for convenience where dispose calls cancel.
  * 
@@ -138,19 +138,20 @@ public void onSubscribe(Disposable s) {
                         }
                         completions++;
                     } catch (Throwable ex) {
-                        // Exceptions.throwIfFatal(e); TODO add fatals?
+                        // Exceptions.throwIfFatal(e); TODO add fatal exceptions?
                         errors.add(ex);
                     }
                     return;
                 }
             }
         }
-        
-        actual.onSubscribe(s);
-        
+
         if (cancelled) {
             return;
         }
+
+        actual.onSubscribe(s);
+        
     }
     
     @Override
@@ -170,7 +171,7 @@ public void onNext(T t) {
                     values.add(t);
                 }
             } catch (Throwable ex) {
-                // Exceptions.throwIfFatal(e); TODO add fatals?
+                // Exceptions.throwIfFatal(e); TODO add fatal exceptions?
                 errors.add(ex);
             }
             return;
@@ -237,7 +238,7 @@ public final boolean isCancelled() {
     
     /**
      * Cancels the TestObserver (before or after the subscription happened).
-     * <p>This operation is threadsafe.
+     * <p>This operation is thread-safe.
      * <p>This method is provided as a convenience when converting Flowable tests that cancel.
      */
     public final void cancel() {
@@ -348,17 +349,14 @@ public final boolean hasSubscription() {
      * @see #awaitTerminalEvent(long, TimeUnit)
      */
     public final boolean await(long time, TimeUnit unit) throws InterruptedException {
-        if (done.getCount() == 0) {
-            return true;
-        }
-        return done.await(time, unit);
+        return done.getCount() == 0 || done.await(time, unit);
     }
     
     // assertion methods
     
     /**
      * Fail with the given message and add the sequence of errors as suppressed ones.
-     * <p>Note this is delibarately the only fail method. Most of the times an assertion
+     * <p>Note this is deliberately the only fail method. Most of the times an assertion
      * would fail but it is possible it was due to an exception somewhere. This construct
      * will capture those potential errors and report it along with the original failure.
      * 
@@ -563,19 +561,17 @@ static String valueAndClass(Object o) {
      * <p>This helps asserting when the order of the values is not guaranteed, i.e., when merging
      * asynchronous streams.
      * 
-     * @param values the collection of values expected in any order
+     * @param expected the collection of values expected in any order
      * @return this;
      */
-    public final TestObserver<T> assertValueSet(Collection<? extends T> values) {
+    public final TestObserver<T> assertValueSet(Collection<? extends T> expected) {
         int s = this.values.size();
-        if (s != values.size()) {
-            fail("Value count differs; Expected: " + values.size() + " " + values
+        if (s != expected.size()) {
+            fail("Value count differs; Expected: " + expected.size() + " " + expected
             + ", Actual: " + s + " " + this.values);
         }
-        for (int i = 0; i < s; i++) {
-            T v = this.values.get(i);
-            
-            if (!values.contains(v)) {
+        for (T v : this.values) {
+            if (!expected.contains(v)) {
                 fail("Value not in the expected collection: " + valueAndClass(v));
             }
         }
@@ -716,6 +712,7 @@ public final boolean awaitTerminalEvent(long duration, TimeUnit unit) {
             Throwable e = errors.get(0);
             if (e == null) {
                 fail("Error is null");
+                return this;
             }
             String errorMessage = e.getMessage();
             if (!ObjectHelper.equals(message, errorMessage)) {
diff --git a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
index 7c5386bac4..406c570995 100644
--- a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
@@ -463,7 +463,7 @@ public static void setSingleSchedulerHandler(Function<Scheduler, Scheduler> hand
     }
 
     /**
-     * Rewokes the lockdown, only for testing purposes.
+     * Revokes the lockdown, only for testing purposes.
      */
     /* test. */static void unlock() {
         lockdown = false;
@@ -630,10 +630,10 @@ public static void setOnObservableAssembly(Function<Observable, Observable> onOb
     
     /**
      * Sets the specific hook function.
-     * @param onObservableAssembly the hook function to set, null allowed
+     * @param onConnectableObservableAssembly the hook function to set, null allowed
      */
     @SuppressWarnings("rawtypes")
-    public static void setOnConnectableObservableAssembly(Function<ConnectableObservable, ConnectableObservable> onObservableAssembly) {
+    public static void setOnConnectableObservableAssembly(Function<ConnectableObservable, ConnectableObservable> onConnectableObservableAssembly) {
         if (lockdown) {
             throw new IllegalStateException("Plugins can't be changed anymore");
         }
@@ -829,7 +829,7 @@ public static Completable onAssembly(Completable source) {
 
     /**
      * Wraps the call to the function in try-catch and propagates thrown
-     * checked exceptions as runtimeexception.
+     * checked exceptions as RuntimeException.
      * @param <T> the input type
      * @param <R> the output type
      * @param f the function to call, not null (not verified)
@@ -847,7 +847,7 @@ public static Completable onAssembly(Completable source) {
 
     /**
      * Wraps the call to the function in try-catch and propagates thrown
-     * checked exceptions as runtimeexception.
+     * checked exceptions as RuntimeException.
      * @param <T> the first input type
      * @param <U> the second input type
      * @param <R> the output type
diff --git a/src/main/java/io/reactivex/processors/FlowableProcessor.java b/src/main/java/io/reactivex/processors/FlowableProcessor.java
index e2c42e1382..77f5ab1b66 100644
--- a/src/main/java/io/reactivex/processors/FlowableProcessor.java
+++ b/src/main/java/io/reactivex/processors/FlowableProcessor.java
@@ -72,4 +72,4 @@
         }
         return new SerializedProcessor<T>(this);
     }
-}
+}
\ No newline at end of file
diff --git a/src/main/java/io/reactivex/processors/PublishProcessor.java b/src/main/java/io/reactivex/processors/PublishProcessor.java
index 4cfdefd031..3f8e25363e 100644
--- a/src/main/java/io/reactivex/processors/PublishProcessor.java
+++ b/src/main/java/io/reactivex/processors/PublishProcessor.java
@@ -338,7 +338,7 @@ public PublishSubscriber(Subscriber<? super T> actual, State<T> state) {
         
         @Override
         public void onSubscribe(Subscription s) {
-            // not called because requests are handled locally and cancel is forwared to state
+            // not called because requests are handled locally and cancel is forwarded to state
         }
         
         @Override
diff --git a/src/main/java/io/reactivex/processors/ReplayProcessor.java b/src/main/java/io/reactivex/processors/ReplayProcessor.java
index 2a8c66d689..393751f75f 100644
--- a/src/main/java/io/reactivex/processors/ReplayProcessor.java
+++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java
@@ -642,7 +642,7 @@ public void replay(ReplaySubscription<T> rs) {
             final Subscriber<? super T> a = rs.actual;
 
             Integer indexObject = (Integer)rs.index;
-            int index = 0;
+            int index;
             if (indexObject != null) {
                 index = indexObject;
             } else {
@@ -782,8 +782,7 @@ void trim() {
         
         @Override
         public void add(T value) {
-            Object o = value;
-            Node<Object> n = new Node<Object>(o);
+            Node<Object> n = new Node<Object>(value);
             Node<Object> t = tail;
 
             tail = n;
@@ -800,8 +799,7 @@ public void add(T value) {
         
         @Override
         public void addFinal(Object notificationLite) {
-            Object o = notificationLite;
-            Node<Object> n = new Node<Object>(o);
+            Node<Object> n = new Node<Object>(notificationLite);
             Node<Object> t = tail;
 
             tail = n;
@@ -1048,8 +1046,7 @@ void trimFinal() {
         
         @Override
         public void add(T value) {
-            Object o = value;
-            TimedNode<Object> n = new TimedNode<Object>(o, scheduler.now(unit));
+            TimedNode<Object> n = new TimedNode<Object>(value, scheduler.now(unit));
             TimedNode<Object> t = tail;
 
             tail = n;
@@ -1066,8 +1063,7 @@ public void add(T value) {
         
         @Override
         public void addFinal(Object notificationLite) {
-            Object o = notificationLite;
-            TimedNode<Object> n = new TimedNode<Object>(o, Long.MAX_VALUE);
+            TimedNode<Object> n = new TimedNode<Object>(notificationLite, Long.MAX_VALUE);
             TimedNode<Object> t = tail;
 
             tail = n;
diff --git a/src/main/java/io/reactivex/processors/SerializedProcessor.java b/src/main/java/io/reactivex/processors/SerializedProcessor.java
index 6eba65feef..b0ea637a75 100644
--- a/src/main/java/io/reactivex/processors/SerializedProcessor.java
+++ b/src/main/java/io/reactivex/processors/SerializedProcessor.java
@@ -29,7 +29,7 @@
 /* public */ final class SerializedProcessor<T> extends FlowableProcessor<T> {
     /** The actual subscriber to serialize Subscriber calls to. */
     final FlowableProcessor<T> actual;
-    /** Indicates an emission is going on, guarted by this. */
+    /** Indicates an emission is going on, guarded by this. */
     boolean emitting;
     /** If not null, it holds the missed NotificationLite events. */
     AppendOnlyLinkedArrayList<Object> queue;
@@ -107,7 +107,6 @@ public void onError(Throwable t) {
         synchronized (this) {
             if (done) {
                 reportError = true;
-                return;
             } else {
                 done = true;
                 if (emitting) {
diff --git a/src/main/java/io/reactivex/processors/UnicastProcessor.java b/src/main/java/io/reactivex/processors/UnicastProcessor.java
index 4a6f77d7cb..e7bbcecace 100644
--- a/src/main/java/io/reactivex/processors/UnicastProcessor.java
+++ b/src/main/java/io/reactivex/processors/UnicastProcessor.java
@@ -36,7 +36,7 @@
  * or the Subscribers receive the terminal event (error or completion) if this
  * Subject has terminated.
  * 
- * @param <T> the value type unicasted
+ * @param <T> the value type received and emitted by this Subject subclass
  */
 public final class UnicastProcessor<T> extends FlowableProcessor<T> {
 
diff --git a/src/main/java/io/reactivex/schedulers/Schedulers.java b/src/main/java/io/reactivex/schedulers/Schedulers.java
index 4c752256b7..7243c88270 100644
--- a/src/main/java/io/reactivex/schedulers/Schedulers.java
+++ b/src/main/java/io/reactivex/schedulers/Schedulers.java
@@ -132,7 +132,7 @@ public static Scheduler from(Executor executor) {
     
     /**
      * Shuts down those standard Schedulers which support the SchedulerLifecycle interface.
-     * <p>The operation is idempotent and threadsafe.
+     * <p>The operation is idempotent and thread-safe.
      */
     public static void shutdown() {
         computation().shutdown();
@@ -145,7 +145,7 @@ public static void shutdown() {
     
     /**
      * Starts those standard Schedulers which support the SchedulerLifecycle interface.
-     * <p>The operation is idempotent and threadsafe.
+     * <p>The operation is idempotent and thread-safe.
      */
     public static void start() {
         computation().start();
diff --git a/src/main/java/io/reactivex/schedulers/TestScheduler.java b/src/main/java/io/reactivex/schedulers/TestScheduler.java
index 1894852019..4ea1c2b014 100644
--- a/src/main/java/io/reactivex/schedulers/TestScheduler.java
+++ b/src/main/java/io/reactivex/schedulers/TestScheduler.java
@@ -28,18 +28,18 @@
  */
 public final class TestScheduler extends Scheduler {
     /** The ordered queue for the runnable tasks. */
-    private final Queue<TimedRunnable> queue = new PriorityBlockingQueue<TimedRunnable>(11);
+    final Queue<TimedRunnable> queue = new PriorityBlockingQueue<TimedRunnable>(11);
     /** The per-scheduler global order counter. */
     long counter;
     // Storing time in nanoseconds internally.
-    private volatile long time;
+    volatile long time;
 
     static final class TimedRunnable implements Comparable<TimedRunnable> {
 
-        private final long time;
-        private final Runnable run;
-        private final TestWorker scheduler;
-        private final long count; // for differentiating tasks at same time
+        final long time;
+        final Runnable run;
+        final TestWorker scheduler;
+        final long count; // for differentiating tasks at same time
 
         TimedRunnable(TestWorker scheduler, long time, Runnable run, long count) {
             this.time = time;
@@ -100,10 +100,10 @@ public void triggerActions() {
         triggerActions(time);
     }
 
-    private void triggerActions(long targetTimeInNanos) {
+    private void triggerActions(long targetTimeInNanoseconds) {
         while (!queue.isEmpty()) {
             TimedRunnable current = queue.peek();
-            if (current.time > targetTimeInNanos) {
+            if (current.time > targetTimeInNanoseconds) {
                 break;
             }
             // if scheduled time is 0 (immediate) use current virtual time
@@ -115,7 +115,7 @@ private void triggerActions(long targetTimeInNanos) {
                 current.run.run();
             }
         }
-        time = targetTimeInNanos;
+        time = targetTimeInNanoseconds;
     }
 
     @Override
diff --git a/src/main/java/io/reactivex/schedulers/Timed.java b/src/main/java/io/reactivex/schedulers/Timed.java
index d85d1f3e3d..70bb430606 100644
--- a/src/main/java/io/reactivex/schedulers/Timed.java
+++ b/src/main/java/io/reactivex/schedulers/Timed.java
@@ -87,7 +87,7 @@ public boolean equals(Object other) {
     @Override
     public int hashCode() {
          int h = value != null ? value.hashCode() : 0;
-         h = h * 31 + (int)((time >>> 31) ^ (time & 0xFFFFFFFF));
+         h = h * 31 + (int)((time >>> 31) ^ time);
          h = h * 31 + unit.hashCode();
          return h;
     }
diff --git a/src/main/java/io/reactivex/subjects/BehaviorSubject.java b/src/main/java/io/reactivex/subjects/BehaviorSubject.java
index 55224be4f5..a282045c12 100644
--- a/src/main/java/io/reactivex/subjects/BehaviorSubject.java
+++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java
@@ -359,7 +359,6 @@ public void subscribe(Observer<? super T> s) {
         public void onSubscribe(Disposable s) {
             if (done) {
                 s.dispose();
-                return;
             }
         }
         
@@ -513,10 +512,7 @@ void emitNext(Object value, long stateIndex) {
 
         @Override
         public boolean test(Object o) {
-            if (cancelled) {
-                return true;
-            }
-            return NotificationLite.accept(o, actual);
+            return cancelled || NotificationLite.accept(o, actual);
         }
         
         void emitLoop() {
diff --git a/src/main/java/io/reactivex/subjects/ReplaySubject.java b/src/main/java/io/reactivex/subjects/ReplaySubject.java
index e3af46961c..396c487046 100644
--- a/src/main/java/io/reactivex/subjects/ReplaySubject.java
+++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java
@@ -633,7 +633,7 @@ public void replay(ReplayDisposable<T> rs) {
             final Observer<? super T> a = rs.actual;
 
             Integer indexObject = (Integer)rs.index;
-            int index = 0;
+            int index;
             if (indexObject != null) {
                 index = indexObject;
             } else {
@@ -757,8 +757,7 @@ void trim() {
         
         @Override
         public void add(T value) {
-            Object o = value;
-            Node<Object> n = new Node<Object>(o);
+            Node<Object> n = new Node<Object>(value);
             Node<Object> t = tail;
 
             tail = n;
@@ -775,8 +774,7 @@ public void add(T value) {
         
         @Override
         public void addFinal(Object notificationLite) {
-            Object o = notificationLite;
-            Node<Object> n = new Node<Object>(o);
+            Node<Object> n = new Node<Object>(notificationLite);
             Node<Object> t = tail;
 
             tail = n;
@@ -1005,8 +1003,7 @@ void trimFinal() {
         
         @Override
         public void add(T value) {
-            Object o = value;
-            TimedNode<Object> n = new TimedNode<Object>(o, scheduler.now(unit));
+            TimedNode<Object> n = new TimedNode<Object>(value, scheduler.now(unit));
             TimedNode<Object> t = tail;
 
             tail = n;
@@ -1023,8 +1020,7 @@ public void add(T value) {
         
         @Override
         public void addFinal(Object notificationLite) {
-            Object o = notificationLite;
-            TimedNode<Object> n = new TimedNode<Object>(o, Long.MAX_VALUE);
+            TimedNode<Object> n = new TimedNode<Object>(notificationLite, Long.MAX_VALUE);
             TimedNode<Object> t = tail;
 
             tail = n;
diff --git a/src/main/java/io/reactivex/subjects/SerializedSubject.java b/src/main/java/io/reactivex/subjects/SerializedSubject.java
index 60bc4f3b75..25cd07be46 100644
--- a/src/main/java/io/reactivex/subjects/SerializedSubject.java
+++ b/src/main/java/io/reactivex/subjects/SerializedSubject.java
@@ -29,7 +29,7 @@
 /* public */ final class SerializedSubject<T> extends Subject<T> {
     /** The actual subscriber to serialize Subscriber calls to. */
     final Subject<T> actual;
-    /** Indicates an emission is going on, guarted by this. */
+    /** Indicates an emission is going on, guarded by this. */
     boolean emitting;
     /** If not null, it holds the missed NotificationLite events. */
     AppendOnlyLinkedArrayList<Object> queue;
@@ -89,7 +89,6 @@ public void onError(Throwable t) {
         synchronized (this) {
             if (done) {
                 reportError = true;
-                return;
             } else {
                 done = true;
                 if (emitting) {
diff --git a/src/main/java/io/reactivex/subjects/UnicastSubject.java b/src/main/java/io/reactivex/subjects/UnicastSubject.java
index a9e9495baa..cf98abcece 100644
--- a/src/main/java/io/reactivex/subjects/UnicastSubject.java
+++ b/src/main/java/io/reactivex/subjects/UnicastSubject.java
@@ -33,7 +33,7 @@
  * or the Subscribers receive the terminal event (error or completion) if this
  * Subject has terminated.
  * 
- * @param <T> the value type unicasted
+ * @param <T> the value type received and emitted by this Subject subclass
  */
 public final class UnicastSubject<T> extends Subject<T> {
     /** The subject state. */
@@ -325,7 +325,7 @@ public void onComplete() {
     
     @Override
     public boolean hasObservers() {
-        return state.subscriber != null;
+        return state.subscriber.get() != null;
     }
     
     @Override
diff --git a/src/main/java/io/reactivex/subscribers/TestSubscriber.java b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
index 4638caf4c7..6c12819827 100644
--- a/src/main/java/io/reactivex/subscribers/TestSubscriber.java
+++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
@@ -31,7 +31,7 @@
  * A subscriber that records events and allows making assertions about them.
  *
  * <p>You can override the onSubscribe, onNext, onError, onComplete, request and
- * cancel methods but not the others (this is by desing).
+ * cancel methods but not the others (this is by design).
  * 
  * <p>The TestSubscriber implements Disposable for convenience where dispose calls cancel.
  * 
@@ -170,7 +170,7 @@ public void onSubscribe(Subscription s) {
                         }
                         completions++;
                     } catch (Throwable ex) {
-                        // Exceptions.throwIfFatal(e); TODO add fatals?
+                        // Exceptions.throwIfFatal(e); TODO add fatal exceptions?
                         errors.add(ex);
                     }
                     return;
@@ -220,7 +220,7 @@ public void onNext(T t) {
                     values.add(t);
                 }
             } catch (Throwable ex) {
-                // Exceptions.throwIfFatal(e); TODO add fatals?
+                // Exceptions.throwIfFatal(e); TODO add fatal exceptions?
                 errors.add(ex);
             }
             return;
@@ -412,17 +412,14 @@ public final boolean hasSubscription() {
      * @see #awaitTerminalEvent(long, TimeUnit)
      */
     public final boolean await(long time, TimeUnit unit) throws InterruptedException {
-        if (done.getCount() == 0) {
-            return true;
-        }
-        return done.await(time, unit);
+        return done.getCount() == 0 || done.await(time, unit);
     }
     
     // assertion methods
     
     /**
      * Fail with the given message and add the sequence of errors as suppressed ones.
-     * <p>Note this is delibarately the only fail method. Most of the times an assertion
+     * <p>Note this is deliberately the only fail method. Most of the times an assertion
      * would fail but it is possible it was due to an exception somewhere. This construct
      * will capture those potential errors and report it along with the original failure.
      * 
@@ -627,19 +624,17 @@ static String valueAndClass(Object o) {
      * <p>This helps asserting when the order of the values is not guaranteed, i.e., when merging
      * asynchronous streams.
      * 
-     * @param values the collection of values expected in any order
+     * @param expected the collection of values expected in any order
      * @return this
      */
-    public final TestSubscriber<T> assertValueSet(Collection<? extends T> values) {
+    public final TestSubscriber<T> assertValueSet(Collection<? extends T> expected) {
         int s = this.values.size();
-        if (s != values.size()) {
-            fail("Value count differs; Expected: " + values.size() + " " + values
+        if (s != expected.size()) {
+            fail("Value count differs; Expected: " + expected.size() + " " + expected
             + ", Actual: " + s + " " + this.values);
         }
-        for (int i = 0; i < s; i++) {
-            T v = this.values.get(i);
-            
-            if (!values.contains(v)) {
+        for (T v : this.values) {
+            if (!expected.contains(v)) {
                 fail("Value not in the expected collection: " + valueAndClass(v));
             }
         }
@@ -780,6 +775,7 @@ public final boolean awaitTerminalEvent(long duration, TimeUnit unit) {
             Throwable e = errors.get(0);
             if (e == null) {
                 fail("Error is null");
+                return this;
             }
             String errorMessage = e.getMessage();
             if (!ObjectHelper.equals(message, errorMessage)) {
diff --git a/src/test/java/io/reactivex/completable/CompletableTest.java b/src/test/java/io/reactivex/completable/CompletableTest.java
index d371515004..44c99ed4bc 100644
--- a/src/test/java/io/reactivex/completable/CompletableTest.java
+++ b/src/test/java/io/reactivex/completable/CompletableTest.java
@@ -3855,7 +3855,7 @@ public void onComplete() {
         Assert.assertTrue("Closure called before onComplete", doneAfter.get());
     }
     
-    @Test(timeout = 5000)
+    @Test
     public void doAfterTerminateWithError() {
         final AtomicBoolean doneAfter = new AtomicBoolean();
         
@@ -3867,13 +3867,13 @@ public void run() {
         });
         
         try {
-            c.blockingAwait();
+            c.blockingAwait(5, TimeUnit.SECONDS);
             Assert.fail("Did not throw TestException");
         } catch (TestException ex) {
             // expected
         }
         
-        Assert.assertFalse("Closure called", doneAfter.get());
+        Assert.assertTrue("Closure not called", doneAfter.get());
     }
     
     @Test(expected = NullPointerException.class)
diff --git a/src/test/java/io/reactivex/flowable/FlowableNullTests.java b/src/test/java/io/reactivex/flowable/FlowableNullTests.java
index 6da26d9b4e..1bb3302b48 100644
--- a/src/test/java/io/reactivex/flowable/FlowableNullTests.java
+++ b/src/test/java/io/reactivex/flowable/FlowableNullTests.java
@@ -1666,7 +1666,7 @@ public void onErrorReturnFunctionNull() {
     
     @Test(expected = NullPointerException.class)
     public void onErrorReturnValueNull() {
-        just1.onErrorReturnValue(null);
+        just1.onErrorReturnItem(null);
     }
 
     @Test(expected = NullPointerException.class)
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
index cf8be85802..72ed20f5ba 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java
@@ -42,7 +42,7 @@ public void testColdReplayNoBackpressure() {
         source.subscribe(ts);
 
         assertTrue("Source is not connected!", source.isConnected());
-        assertFalse("Subscribers retained!", source.hasObservers());
+        assertFalse("Subscribers retained!", source.hasSubscribers());
         
         ts.assertNoErrors();
         ts.assertTerminated();
@@ -65,7 +65,7 @@ public void testColdReplayBackpressure() {
         source.subscribe(ts);
 
         assertTrue("Source is not connected!", source.isConnected());
-        assertTrue("Subscribers not retained!", source.hasObservers());
+        assertTrue("Subscribers not retained!", source.hasSubscribers());
         
         ts.assertNoErrors();
         ts.assertNotComplete();
@@ -77,7 +77,7 @@ public void testColdReplayBackpressure() {
         }
         
         ts.dispose();
-        assertFalse("Subscribers retained!", source.hasObservers());
+        assertFalse("Subscribers retained!", source.hasSubscribers());
     }
     
     @Test
@@ -151,7 +151,7 @@ public void testTake() {
         ts.assertComplete();
         ts.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
 //        ts.assertUnsubscribed(); // FIXME no longer valid 
-        assertFalse(cached.hasObservers());
+        assertFalse(cached.hasSubscribers());
     }
     
     @Test
diff --git a/src/test/java/io/reactivex/observable/ObservableNullTests.java b/src/test/java/io/reactivex/observable/ObservableNullTests.java
index 2737e04df5..662c998ff4 100644
--- a/src/test/java/io/reactivex/observable/ObservableNullTests.java
+++ b/src/test/java/io/reactivex/observable/ObservableNullTests.java
@@ -1723,7 +1723,7 @@ public void onErrorReturnFunctionNull() {
     
     @Test(expected = NullPointerException.class)
     public void onErrorReturnValueNull() {
-        just1.onErrorReturnValue(null);
+        just1.onErrorReturnItem(null);
     }
 
     @Test(expected = NullPointerException.class)
