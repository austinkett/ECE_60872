diff --git a/src/main/java/io/reactivex/internal/operators/single/SingleCache.java b/src/main/java/io/reactivex/internal/operators/single/SingleCache.java
index 97eaec22df..fc54fd7946 100644
--- a/src/main/java/io/reactivex/internal/operators/single/SingleCache.java
+++ b/src/main/java/io/reactivex/internal/operators/single/SingleCache.java
@@ -13,97 +13,166 @@
 
 package io.reactivex.internal.operators.single;
 
-import java.util.*;
 import java.util.concurrent.atomic.*;
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.EmptyDisposable;
-import io.reactivex.internal.util.NotificationLite;
 
-public final class SingleCache<T> extends Single<T> {
+public final class SingleCache<T> extends Single<T> implements SingleObserver<T> {
 
+    @SuppressWarnings("rawtypes")
+    static final CacheDisposable[] EMPTY = new CacheDisposable[0];
+    @SuppressWarnings("rawtypes")
+    static final CacheDisposable[] TERMINATED = new CacheDisposable[0];
+    
     final SingleSource<? extends T> source;
     
     final AtomicInteger wip;
-    final AtomicReference<Object> notification;
-    final List<SingleObserver<? super T>> subscribers;
 
+    final AtomicReference<CacheDisposable<T>[]> observers;
+    
+    T value;
+    
+    Throwable error;
+    
+    @SuppressWarnings("unchecked")
     public SingleCache(SingleSource<? extends T> source) {
         this.source = source;
         this.wip = new AtomicInteger();
-        this.notification = new AtomicReference<Object>();
-        this.subscribers = new ArrayList<SingleObserver<? super T>>();
+        this.observers = new AtomicReference<CacheDisposable<T>[]>(EMPTY);
     }
 
     @Override
-    protected void subscribeActual(SingleObserver<? super T> s) {
-
-        Object o = notification.get();
-        if (o != null) {
-            s.onSubscribe(EmptyDisposable.INSTANCE);
-            if (NotificationLite.isError(o)) {
-                s.onError(NotificationLite.getError(o));
+    protected void subscribeActual(final SingleObserver<? super T> s) {
+        CacheDisposable<T> d = new CacheDisposable<T>(s, this);
+        s.onSubscribe(d);
+        
+        if (add(d)) {
+            if (d.isDisposed()) {
+                remove(d);
+            }
+        } else {
+            Throwable ex = error;
+            if (ex != null) {
+                s.onError(ex);
             } else {
-                s.onSuccess(NotificationLite.<T>getValue(o));
+                s.onSuccess(value);
             }
             return;
         }
         
-        synchronized (subscribers) {
-            o = notification.get();
-            if (o == null) {
-                subscribers.add(s);
+        if (wip.getAndIncrement() == 0) {
+            source.subscribe(this);
+        }
+    }
+
+    boolean add(CacheDisposable<T> observer) {
+        for (;;) {
+            CacheDisposable<T>[] a = observers.get();
+            if (a == TERMINATED) {
+                return false;
+            }
+            int n = a.length;
+            @SuppressWarnings("unchecked")
+            CacheDisposable<T>[] b = new CacheDisposable[n + 1];
+            System.arraycopy(a, 0, b, 0, n);
+            b[n] = observer;
+            if (observers.compareAndSet(a, b)) {
+                return true;
             }
         }
-        if (o != null) {
-            s.onSubscribe(EmptyDisposable.INSTANCE);
-            if (NotificationLite.isError(o)) {
-                s.onError(NotificationLite.getError(o));
+    }
+    
+    @SuppressWarnings("unchecked")
+    void remove(CacheDisposable<T> observer) {
+        for (;;) {
+            CacheDisposable<T>[] a = observers.get();
+            int n = a.length;
+            if (n == 0) {
+                return;
+            }
+            
+            int j = -1;
+            for (int i = 0; i < n; i++) {
+                if (a[i] == observer) {
+                    j = i;
+                    break;
+                }
+            }
+            
+            if (j < 0) {
+                return;
+            }
+            
+            CacheDisposable<T>[] b;
+            
+            if (n == 1) {
+                b = EMPTY;
             } else {
-                s.onSuccess(NotificationLite.<T>getValue(o));
+                b = new CacheDisposable[n - 1];
+                System.arraycopy(a, 0, b, 0, j);
+                System.arraycopy(a, j + 1, b, j, n - j - 1);
+            }
+            if (observers.compareAndSet(a, b)) {
+                return;
             }
-            return;
         }
+    }
+
+    @Override
+    public void onSubscribe(Disposable d) {
+        // not supported by this operator
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Override
+    public void onSuccess(T value) {
+        this.value = value;
         
-        if (wip.getAndIncrement() != 0) {
-            return;
+        for (CacheDisposable<T> d : observers.getAndSet(TERMINATED)) {
+            if (!d.isDisposed()) {
+                d.actual.onSuccess(value);
+            }
         }
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Override
+    public void onError(Throwable e) {
+        this.error = e;
         
-        source.subscribe(new SingleObserver<T>() {
-
-            @Override
-            public void onSubscribe(Disposable d) {
-                
+        for (CacheDisposable<T> d : observers.getAndSet(TERMINATED)) {
+            if (!d.isDisposed()) {
+                d.actual.onError(e);
             }
+        }
+    }
+    
+    static final class CacheDisposable<T> 
+    extends AtomicBoolean
+    implements Disposable {
+        /** */
+        private static final long serialVersionUID = 7514387411091976596L;
 
-            @Override
-            public void onSuccess(T value) {
-                notification.set(NotificationLite.next(value));
-                List<SingleObserver<? super T>> list;
-                synchronized (subscribers) {
-                    list = new ArrayList<SingleObserver<? super T>>(subscribers);
-                    subscribers.clear();
-                }
-                for (SingleObserver<? super T> s1 : list) {
-                    s1.onSuccess(value);
-                }
-            }
+        final SingleObserver<? super T> actual;
+        
+        final SingleCache<T> parent;
 
-            @Override
-            public void onError(Throwable e) {
-                notification.set(NotificationLite.error(e));
-                List<SingleObserver<? super T>> list;
-                synchronized (subscribers) {
-                    list = new ArrayList<SingleObserver<? super T>>(subscribers);
-                    subscribers.clear();
-                }
-                for (SingleObserver<? super T> s1 : list) {
-                    s1.onError(e);
-                }
+        public CacheDisposable(SingleObserver<? super T> actual, SingleCache<T> parent) {
+            this.actual = actual;
+            this.parent = parent;
+        }
+        
+        @Override
+        public boolean isDisposed() {
+            return get();
+        }
+        
+        @Override
+        public void dispose() {
+            if (compareAndSet(false, true)) {
+                parent.remove(this);
             }
-            
-        });
+        }
     }
-
 }
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/EmptyObserver.java b/src/main/java/io/reactivex/internal/subscribers/observable/EmptyObserver.java
deleted file mode 100644
index b11018b1b6..0000000000
--- a/src/main/java/io/reactivex/internal/subscribers/observable/EmptyObserver.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/**
- * Copyright 2016 Netflix, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
- * the License for the specific language governing permissions and limitations under the License.
- */
-
-package io.reactivex.internal.subscribers.observable;
-
-import io.reactivex.Observer;
-import io.reactivex.disposables.Disposable;
-import io.reactivex.plugins.RxJavaPlugins;
-
-/**
- * A subscriber that ignores all events (onError is forwarded to RxJavaPlugins though).
- */
-public enum EmptyObserver implements Observer<Object> {
-    /** Empty instance that reports error to the plugins. */
-    INSTANCE(false),
-    /** Empty instance that disposes disposables. */
-    DISPOSED(true);
-    
-    private final boolean disposeDisposable;
-    
-    EmptyObserver(boolean disposeDisposable) {
-        this.disposeDisposable = disposeDisposable;
-    }
-    
-    @Override
-    public void onSubscribe(Disposable d) {
-        if (disposeDisposable) {
-            d.dispose();
-        }
-    }
-    
-    @Override
-    public void onNext(Object t) {
-        
-    }
-    
-    @Override
-    public void onError(Throwable t) {
-        RxJavaPlugins.onError(t);
-    }
-    
-    @Override
-    public void onComplete() {
-        
-    }
-}
diff --git a/src/main/java/io/reactivex/subjects/PublishSubject.java b/src/main/java/io/reactivex/subjects/PublishSubject.java
index 2fb13a27d0..6eedea6c1d 100644
--- a/src/main/java/io/reactivex/subjects/PublishSubject.java
+++ b/src/main/java/io/reactivex/subjects/PublishSubject.java
@@ -13,10 +13,10 @@
 
 package io.reactivex.subjects;
 
-import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.*;
 
 import io.reactivex.*;
-import io.reactivex.disposables.*;
+import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.EmptyDisposable;
 import io.reactivex.internal.util.NotificationLite;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -115,16 +115,17 @@ public boolean hasThrowable() {
         return NotificationLite.isError(state.get());
     }
     
-    static final class State<T> extends AtomicReference<Object> implements ObservableSource<T>, Observer<T> {
+    static final class State<T> extends AtomicReference<Object> 
+    implements ObservableSource<T> {
         /** */
         private static final long serialVersionUID = 4876574210612691772L;
 
-        final AtomicReference<Observer<? super T>[]> subscribers = new AtomicReference<Observer<? super T>[]>();
+        final AtomicReference<PublishDisposable<? super T>[]> subscribers = new AtomicReference<PublishDisposable<? super T>[]>();
         
         @SuppressWarnings("rawtypes")
-        static final Observer[] EMPTY = new Observer[0];
+        static final PublishDisposable[] EMPTY = new PublishDisposable[0];
         @SuppressWarnings("rawtypes")
-        static final Observer[] TERMINATED = new Observer[0];
+        static final PublishDisposable[] TERMINATED = new PublishDisposable[0];
 
         volatile boolean done;
         
@@ -133,16 +134,16 @@ public State() {
             subscribers.lazySet(EMPTY);
         }
         
-        boolean add(Observer<? super T> s) {
+        boolean add(PublishDisposable<? super T> s) {
             for (;;) {
-                Observer<? super T>[] a = subscribers.get();
+                PublishDisposable<? super T>[] a = subscribers.get();
                 if (a == TERMINATED) {
                     return false;
                 }
                 int n = a.length;
                 
                 @SuppressWarnings("unchecked")
-                Observer<? super T>[] b = new Observer[n + 1];
+                PublishDisposable<? super T>[] b = new PublishDisposable[n + 1];
                 System.arraycopy(a, 0, b, 0, n);
                 b[n] = s;
                 
@@ -153,16 +154,16 @@ boolean add(Observer<? super T> s) {
         }
         
         @SuppressWarnings("unchecked")
-        void remove(Observer<? super T> s) {
+        void remove(PublishDisposable<? super T> s) {
             for (;;) {
-                Observer<? super T>[] a = subscribers.get();
+                PublishDisposable<? super T>[] a = subscribers.get();
                 if (a == TERMINATED || a == EMPTY) {
                     return;
                 }
                 int n = a.length;
                 int j = -1;
                 for (int i = 0; i < n; i++) {
-                    Observer<? super T> e = a[i];
+                    PublishDisposable<? super T> e = a[i];
                     if (e.equals(s)) {
                         j = i;
                         break;
@@ -171,11 +172,11 @@ void remove(Observer<? super T> s) {
                 if (j < 0) {
                     return;
                 }
-                Observer<? super T>[] b;
+                PublishDisposable<? super T>[] b;
                 if (n == 1) {
                     b = EMPTY;
                 } else {
-                    b = new Observer[n - 1];
+                    b = new PublishDisposable[n - 1];
                     System.arraycopy(a, 0, b, 0, j);
                     System.arraycopy(a, j + 1, b, j, n - j - 1);
                 }
@@ -186,12 +187,9 @@ void remove(Observer<? super T> s) {
         }
         
         @SuppressWarnings("unchecked")
-        Observer<? super T>[] terminate(Object notification) {
+        PublishDisposable<? super T>[] terminate(Object notification) {
             if (compareAndSet(null, notification)) {
-                Observer<? super T>[] a = subscribers.get();
-                if (a != TERMINATED) {
-                    return subscribers.getAndSet(TERMINATED);
-                }
+                return subscribers.getAndSet(TERMINATED);
             }
             return TERMINATED;
         }
@@ -212,16 +210,11 @@ public void subscribe(final Observer<? super T> t) {
                 emit(t, v);
                 return;
             }
-            Disposable d = Disposables.from(new Runnable() {
-                @Override
-                public void run() {
-                    remove(t);
-                }
-            });
+            PublishDisposable<T> d = new PublishDisposable<T>(t, this);
             t.onSubscribe(d);
-            if (add(t)) {
+            if (add(d)) {
                 if (d.isDisposed()) {
-                    remove(t);
+                    remove(d);
                 }
                 return;
             }
@@ -229,14 +222,6 @@ public void run() {
             emit(t, v);
         }
         
-        @Override
-        public void onSubscribe(Disposable d) {
-            if (done) {
-                d.dispose();
-            }
-        }
-        
-        @Override
         public void onNext(T value) {
             if (done) {
                 return;
@@ -245,12 +230,13 @@ public void onNext(T value) {
                 onError(new NullPointerException("The value is null"));
                 return;
             }
-            for (Observer<? super T> v : subscribers.get()) {
-                v.onNext(value);
+            for (PublishDisposable<? super T> v : subscribers.get()) {
+                if (!v.get()) {
+                    v.actual.onNext(value);
+                }
             }
         }
         
-        @Override
         public void onError(Throwable e) {
             if (done) {
                 RxJavaPlugins.onError(e);
@@ -261,19 +247,48 @@ public void onError(Throwable e) {
                 e = new NullPointerException();
             }
 
-            for (Observer<? super T> v : terminate(NotificationLite.error(e))) {
-                v.onError(e);
+            for (PublishDisposable<? super T> v : terminate(NotificationLite.error(e))) {
+                if (!v.get()) {
+                    v.actual.onError(e);
+                }
             }
         }
         
-        @Override
         public void onComplete() {
             if (done) {
                 return;
             }
             done = true;
-            for (Observer<? super T> v : terminate(NotificationLite.complete())) {
-                v.onComplete();
+            for (PublishDisposable<? super T> v : terminate(NotificationLite.complete())) {
+                if (!v.get()) {
+                    v.actual.onComplete();
+                }
+            }
+        }
+    }
+    
+    static final class PublishDisposable<T> extends AtomicBoolean implements Disposable {
+        /** */
+        private static final long serialVersionUID = 2734660924929727368L;
+
+        final Observer<? super T> actual;
+
+        final State<T> parent;
+        
+        public PublishDisposable(Observer<? super T> actual, State<T> parent) {
+            this.actual = actual;
+            this.parent = parent;
+        }
+        
+        @Override
+        public boolean isDisposed() {
+            return get();
+        }
+        
+        @Override
+        public void dispose() {
+            if (compareAndSet(false, true)) {
+                parent.remove(this);
             }
         }
     }
diff --git a/src/test/java/io/reactivex/TestHelper.java b/src/test/java/io/reactivex/TestHelper.java
index 6457159eb6..e71ff5fe27 100644
--- a/src/test/java/io/reactivex/TestHelper.java
+++ b/src/test/java/io/reactivex/TestHelper.java
@@ -217,24 +217,19 @@ public void run() {
             }
         });
         
-        s.scheduleDirect(new Runnable() {
-            @Override
-            public void run() {
-                if (count.decrementAndGet() != 0) {
-                    while (count.get() != 0);
-                }
-                
-                try {
-                    try {
-                        r2.run();
-                    } catch (Throwable ex) {
-                        errors[1] = ex;
-                    }
-                } finally {
-                    cdl.countDown();
-                }
+        if (count.decrementAndGet() != 0) {
+            while (count.get() != 0);
+        }
+        
+        try {
+            try {
+                r2.run();
+            } catch (Throwable ex) {
+                errors[1] = ex;
             }
-        });
+        } finally {
+            cdl.countDown();
+        }
         
         try {
             if (!cdl.await(5, TimeUnit.SECONDS)) {
diff --git a/src/test/java/io/reactivex/exceptions/ExceptionsTest.java b/src/test/java/io/reactivex/exceptions/ExceptionsTest.java
index 3cba90d6f4..92ba65b40c 100644
--- a/src/test/java/io/reactivex/exceptions/ExceptionsTest.java
+++ b/src/test/java/io/reactivex/exceptions/ExceptionsTest.java
@@ -15,29 +15,22 @@
  */
 package io.reactivex.exceptions;
 
-import io.reactivex.Observable;
-import io.reactivex.ObservableSource;
-import io.reactivex.Observer;
-import io.reactivex.Single;
-import io.reactivex.SingleObserver;
-import io.reactivex.SingleSource;
-import io.reactivex.TestHelper;
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.*;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.functions.Consumer;
-import io.reactivex.functions.Function;
+import io.reactivex.functions.*;
 import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.observables.GroupedObservable;
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.subjects.PublishSubject;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.reactivestreams.Subscriber;
-import org.reactivestreams.Subscription;
-
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 
 public class ExceptionsTest {
     
@@ -472,4 +465,30 @@ public void manualThrowIfFatal() {
             // expected
         }
     }
+
+    @Test
+    public void manualPropagate() {
+        
+        try {
+            Exceptions.propagate(new InternalError());
+            fail("Didn't throw exception");
+        } catch (InternalError ex) {
+            // expected
+        }
+        
+        try {
+            throw Exceptions.propagate(new IllegalArgumentException());
+        } catch (IllegalArgumentException ex) {
+            // expected
+        }
+
+        try {
+            throw ExceptionHelper.wrapOrThrow(new IOException());
+        } catch (RuntimeException ex) {
+            if (!(ex.getCause() instanceof IOException)) {
+                fail(ex.toString() + ": should have thrown RuntimeException(IOException)");
+            }
+        }
+    }
+
 }
diff --git a/src/test/java/io/reactivex/processors/PublishProcessorTest.java b/src/test/java/io/reactivex/processors/PublishProcessorTest.java
index 94e8488297..d587bd0a1b 100644
--- a/src/test/java/io/reactivex/processors/PublishProcessorTest.java
+++ b/src/test/java/io/reactivex/processors/PublishProcessorTest.java
@@ -445,7 +445,7 @@ public void subscribeTo() {
     }
     
     @Test
-    public void testRequestValidation() {
+    public void requestValidation() {
         TestHelper.assertBadRequestReported(PublishProcessor.create());
     }
     
@@ -576,20 +576,14 @@ public void terminateRace() throws Exception {
             
             TestSubscriber<Integer> ts = pp.test();
             
-            final AtomicInteger count = new AtomicInteger(2);
-            
             Runnable task = new Runnable() {
                 @Override
                 public void run() {
-                    if (count.decrementAndGet() != 0) {
-                        while (count.get() != 0);
-                    }
                     pp.onComplete();
                 }
             };
-            
-            Schedulers.newThread().scheduleDirect(task);
-            Schedulers.newThread().scheduleDirect(task);
+
+            TestHelper.race(task, task, Schedulers.io());
             
             ts
             .awaitDone(5, TimeUnit.SECONDS)
@@ -605,34 +599,20 @@ public void addRemoveRance() throws Exception {
             
             final TestSubscriber<Integer> ts = pp.test();
             
-            final AtomicInteger count = new AtomicInteger(2);
-            
-            final CountDownLatch cdl = new CountDownLatch(2);
-            
-            Schedulers.newThread().scheduleDirect(new Runnable() {
+            Runnable r1 = new Runnable() {
                 @Override
                 public void run() {
-                    if (count.decrementAndGet() != 0) {
-                        while (count.get() != 0);
-                    }
                     pp.subscribe();
-                    
-                    cdl.countDown();
                 }
-            });
-            Schedulers.newThread().scheduleDirect(new Runnable() {
+            };
+            Runnable r2 = new Runnable() {
                 @Override
                 public void run() {
-                    if (count.decrementAndGet() != 0) {
-                        while (count.get() != 0);
-                    }
                     ts.cancel();
-                    
-                    cdl.countDown();
                 }
-            });
-            
-            assertTrue(cdl.await(5, TimeUnit.SECONDS));
+            };
+
+            TestHelper.race(r1, r2, Schedulers.io());
         }
     }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/processors/ReplayProcessorTest.java b/src/test/java/io/reactivex/processors/ReplayProcessorTest.java
index 6198749ef3..170178d888 100644
--- a/src/test/java/io/reactivex/processors/ReplayProcessorTest.java
+++ b/src/test/java/io/reactivex/processors/ReplayProcessorTest.java
@@ -907,4 +907,113 @@ public void testBackpressureHonoredTimeBound() {
         ts.assertComplete();
         ts.assertNoErrors();
     }
+    
+    @Test
+    public void createInvalidCapacity() {
+        try {
+            ReplayProcessor.create(-99);
+            fail("Didn't throw IllegalArgumentException");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("capacityHint > 0 required but it was -99", ex.getMessage());
+        }
+    }
+
+    @Test
+    public void createWithSizeInvalidCapacity() {
+        try {
+            ReplayProcessor.createWithSize(-99);
+            fail("Didn't throw IllegalArgumentException");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("size > 0 required but it was -99", ex.getMessage());
+        }
+    }
+
+    @Test
+    public void createWithTimeAndSizeInvalidCapacity() {
+        try {
+            ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), -99);
+            fail("Didn't throw IllegalArgumentException");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("size > 0 required but it was -99", ex.getMessage());
+        }
+    }
+
+    @Test
+    public void hasSubscribers() {
+        ReplayProcessor<Integer> rp = ReplayProcessor.create();
+        
+        assertFalse(rp.hasSubscribers());
+        
+        TestSubscriber<Integer> ts = rp.test();
+        
+        assertTrue(rp.hasSubscribers());
+        
+        ts.cancel();
+        
+        assertFalse(rp.hasSubscribers());
+    }
+    
+    @Test
+    public void peekStateUnbounded() {
+        ReplayProcessor<Integer> rp = ReplayProcessor.create();
+        
+        rp.onNext(1);
+        
+        assertEquals((Integer)1, rp.getValue());
+        
+        assertEquals(1, rp.getValues()[0]);
+    }
+
+    @Test
+    public void peekStateTimeAndSize() {
+        ReplayProcessor<Integer> rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), 1);
+        
+        rp.onNext(1);
+        
+        assertEquals((Integer)1, rp.getValue());
+        
+        assertEquals(1, rp.getValues()[0]);
+
+        rp.onNext(2);
+
+        assertEquals((Integer)2, rp.getValue());
+        
+        assertEquals(2, rp.getValues()[0]);
+
+        assertEquals((Integer)2, rp.getValues(new Integer[0])[0]);
+
+        assertEquals((Integer)2, rp.getValues(new Integer[1])[0]);
+
+        Integer[] a = new Integer[2];
+        assertEquals((Integer)2, rp.getValues(a)[0]);
+        assertNull(a[1]);
+    }
+
+    @Test
+    public void peekStateTimeAndSizeValue() {
+        ReplayProcessor<Integer> rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), 1);
+    
+        assertNull(rp.getValue());
+        
+        assertEquals(0, rp.getValues().length);
+        
+        assertNull(rp.getValues(new Integer[2])[0]);
+
+        rp.onComplete();
+
+        assertNull(rp.getValue());
+        
+        assertEquals(0, rp.getValues().length);
+
+        assertNull(rp.getValues(new Integer[2])[0]);
+
+        rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), 1);
+        rp.onError(new TestException());
+        
+        assertNull(rp.getValue());
+        
+        assertEquals(0, rp.getValues().length);
+
+        assertNull(rp.getValues(new Integer[2])[0]);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/single/SingleCacheTest.java b/src/test/java/io/reactivex/single/SingleCacheTest.java
new file mode 100644
index 0000000000..11a3f302c2
--- /dev/null
+++ b/src/test/java/io/reactivex/single/SingleCacheTest.java
@@ -0,0 +1,135 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.single;
+
+import org.junit.Test;
+
+import io.reactivex.Single;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.subjects.PublishSubject;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class SingleCacheTest {
+
+    @Test
+    public void normal() {
+        Single<Integer> cache = Single.just(1).cache();
+        
+        cache
+        .test()
+        .assertResult(1);
+
+        cache
+        .test()
+        .assertResult(1);
+    }
+
+    @Test
+    public void error() {
+        Single<Object> cache = Single.error(new TestException())
+        .cache();
+
+        cache
+        .test()
+        .assertFailure(TestException.class);
+
+        cache
+        .test()
+        .assertFailure(TestException.class);
+    }
+
+    @Test
+    public void delayed() {
+        PublishSubject<Integer> ps = PublishSubject.create();
+        Single<Integer> cache = ps.toSingle().cache();
+
+        TestSubscriber<Integer> ts1 = cache.test();
+
+        TestSubscriber<Integer> ts2 = cache.test();
+        
+        ps.onNext(1);
+        ps.onComplete();
+        
+        ts1.assertResult(1);
+        ts2.assertResult(1);
+    }
+
+    @Test
+    public void delayedDisposed() {
+        PublishSubject<Integer> ps = PublishSubject.create();
+        Single<Integer> cache = ps.toSingle().cache();
+
+        TestSubscriber<Integer> ts1 = cache.test();
+
+        TestSubscriber<Integer> ts2 = cache.test();
+
+        ts1.cancel();
+        
+        ps.onNext(1);
+        ps.onComplete();
+        
+        ts1.assertNoValues().assertNoErrors().assertNotComplete();
+        ts2.assertResult(1);
+    }
+
+    @Test
+    public void crossCancel() {
+        PublishSubject<Integer> ps = PublishSubject.create();
+        Single<Integer> cache = ps.toSingle().cache();
+
+        final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();
+
+        TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                ts1.cancel();
+            }
+        };
+
+        cache.toFlowable().subscribe(ts2);
+        cache.toFlowable().subscribe(ts1);
+        
+        ps.onNext(1);
+        ps.onComplete();
+        
+        ts1.assertNoValues().assertNoErrors().assertNotComplete();
+        ts2.assertResult(1);
+    }
+
+    @Test
+    public void crossCancelOnError() {
+        PublishSubject<Integer> ps = PublishSubject.create();
+        Single<Integer> cache = ps.toSingle().cache();
+
+        final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();
+
+        TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>() {
+            @Override
+            public void onError(Throwable t) {
+                super.onError(t);
+                ts1.cancel();
+            }
+        };
+
+        cache.toFlowable().subscribe(ts2);
+        cache.toFlowable().subscribe(ts1);
+        
+        ps.onError(new TestException());
+        
+        ts1.assertNoValues().assertNoErrors().assertNotComplete();
+        ts2.assertFailure(TestException.class);
+    }
+
+}
diff --git a/src/test/java/io/reactivex/single/SingleSubscribeTest.java b/src/test/java/io/reactivex/single/SingleSubscribeTest.java
new file mode 100644
index 0000000000..352a0e4536
--- /dev/null
+++ b/src/test/java/io/reactivex/single/SingleSubscribeTest.java
@@ -0,0 +1,74 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.single;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import io.reactivex.Single;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.*;
+
+public class SingleSubscribeTest {
+
+    @Test
+    public void consumer() {
+        final Integer[] value = { null };
+        
+        Single.just(1).subscribe(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                value[0] = v;
+            }
+        });
+        
+        assertEquals((Integer)1, value[0]);
+    }
+
+    @Test
+    public void biconsumer() {
+        final Object[] value = { null, null };
+        
+        Single.just(1).subscribe(new BiConsumer<Integer, Throwable>() {
+            @Override
+            public void accept(Integer v, Throwable e) throws Exception {
+                value[0] = v;
+                value[1] = e;
+            }
+        });
+        
+        assertEquals((Integer)1, value[0]);
+        assertNull(value[1]);
+    }
+
+    @Test
+    public void biconsumerError() {
+        final Object[] value = { null, null };
+        
+        TestException ex = new TestException();
+        
+        Single.error(ex).subscribe(new BiConsumer<Object, Throwable>() {
+            @Override
+            public void accept(Object v, Throwable e) throws Exception {
+                value[0] = v;
+                value[1] = e;
+            }
+        });
+        
+        assertNull(value[0]);
+        assertEquals(ex, value[1]);
+    }
+
+}
diff --git a/src/test/java/io/reactivex/subjects/PublishSubjectTest.java b/src/test/java/io/reactivex/subjects/PublishSubjectTest.java
index 825fce7728..490d7ee35e 100644
--- a/src/test/java/io/reactivex/subjects/PublishSubjectTest.java
+++ b/src/test/java/io/reactivex/subjects/PublishSubjectTest.java
@@ -18,16 +18,18 @@
 import static org.mockito.Mockito.*;
 
 import java.util.ArrayList;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.junit.Test;
+import org.junit.*;
 import org.mockito.*;
 
 import io.reactivex.*;
+import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.TestException;
 import io.reactivex.functions.*;
 import io.reactivex.observers.*;
-import io.reactivex.processors.PublishProcessor;
+import io.reactivex.schedulers.Schedulers;
 
 public class PublishSubjectTest {
 
@@ -338,7 +340,7 @@ public void onComplete() {
 //        PublishSubject<String> ps = PublishSubject.create();
 //
 //        ps.subscribe();
-//        TestSubscriber<String> ts = new TestSubscriber<String>();
+//        TestObserver<String> ts = new TestObserver<String>();
 //        ps.subscribe(ts);
 //
 //        try {
@@ -361,7 +363,7 @@ public void onComplete() {
 //
 //        ps.subscribe();
 //        ps.subscribe();
-//        TestSubscriber<String> ts = new TestSubscriber<String>();
+//        TestObserver<String> ts = new TestObserver<String>();
 //        ps.subscribe(ts);
 //        ps.subscribe();
 //        ps.subscribe();
@@ -379,7 +381,7 @@ public void onComplete() {
 //    }
     @Test
     public void testCurrentStateMethodsNormal() {
-        PublishProcessor<Object> as = PublishProcessor.create();
+        PublishSubject<Object> as = PublishSubject.create();
         
         assertFalse(as.hasThrowable());
         assertFalse(as.hasComplete());
@@ -400,7 +402,7 @@ public void testCurrentStateMethodsNormal() {
     
     @Test
     public void testCurrentStateMethodsEmpty() {
-        PublishProcessor<Object> as = PublishProcessor.create();
+        PublishSubject<Object> as = PublishSubject.create();
         
         assertFalse(as.hasThrowable());
         assertFalse(as.hasComplete());
@@ -414,7 +416,7 @@ public void testCurrentStateMethodsEmpty() {
     }
     @Test
     public void testCurrentStateMethodsError() {
-        PublishProcessor<Object> as = PublishProcessor.create();
+        PublishSubject<Object> as = PublishSubject.create();
         
         assertFalse(as.hasThrowable());
         assertFalse(as.hasComplete());
@@ -426,4 +428,283 @@ public void testCurrentStateMethodsError() {
         assertFalse(as.hasComplete());
         assertTrue(as.getThrowable() instanceof TestException);
     }
+
+    @Ignore("Observable doesn't do backpressure")
+    @Test
+    public void requestValidation() {
+//        TestHelper.assertBadRequestReported(PublishSubject.create());
+    }
+    
+    @Test
+    public void crossCancel() {
+        final TestObserver<Integer> ts1 = new TestObserver<Integer>();
+        TestObserver<Integer> ts2 = new TestObserver<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                super.onNext(t);
+                ts1.cancel();
+            }
+        };
+        
+        PublishSubject<Integer> pp = PublishSubject.create();
+        
+        pp.subscribe(ts2);
+        pp.subscribe(ts1);
+        
+        pp.onNext(1);
+        
+        ts2.assertValue(1);
+        
+        ts1.assertNoValues();
+    }
+
+    @Test
+    public void crossCancelOnError() {
+        final TestObserver<Integer> ts1 = new TestObserver<Integer>();
+        TestObserver<Integer> ts2 = new TestObserver<Integer>() {
+            @Override
+            public void onError(Throwable t) {
+                super.onError(t);
+                ts1.cancel();
+            }
+        };
+        
+        PublishSubject<Integer> pp = PublishSubject.create();
+        
+        pp.subscribe(ts2);
+        pp.subscribe(ts1);
+        
+        pp.onError(new TestException());
+        
+        ts2.assertError(TestException.class);
+        
+        ts1.assertNoErrors();
+    }
+
+    @Test
+    public void crossCancelOnComplete() {
+        final TestObserver<Integer> ts1 = new TestObserver<Integer>();
+        TestObserver<Integer> ts2 = new TestObserver<Integer>() {
+            @Override
+            public void onComplete() {
+                super.onComplete();
+                ts1.cancel();
+            }
+        };
+        
+        PublishSubject<Integer> pp = PublishSubject.create();
+        
+        pp.subscribe(ts2);
+        pp.subscribe(ts1);
+        
+        pp.onComplete();
+        
+        ts2.assertComplete();
+        
+        ts1.assertNotComplete();
+    }
+    
+    @Test
+    @Ignore("Observable doesn't do backpressure")
+    public void backpressureOverflow() {
+//        PublishSubject<Integer> pp = PublishSubject.create();
+//        
+//        TestObserver<Integer> ts = pp.test(0L);
+//        
+//        pp.onNext(1);
+//        
+//        ts.assertNoValues()
+//        .assertNotComplete()
+//        .assertError(MissingBackpressureException.class)
+//        ;
+    }
+    
+    @Test
+    public void onSubscribeCancelsImmediately() {
+        PublishSubject<Integer> pp = PublishSubject.create();
+        
+        TestObserver<Integer> ts = pp.test();
+        
+        pp.subscribe(new Observer<Integer>() {
+
+            @Override
+            public void onSubscribe(Disposable s) {
+                s.dispose();
+                s.dispose();
+            }
+
+            @Override
+            public void onNext(Integer t) {
+                
+            }
+
+            @Override
+            public void onError(Throwable t) {
+                
+            }
+
+            @Override
+            public void onComplete() {
+                
+            }
+            
+        });
+        
+        ts.cancel();
+        
+        assertFalse(pp.hasObservers());
+    }
+    
+    @Test
+    public void terminateRace() throws Exception {
+        
+        for (int i = 0; i < 100; i++) {
+            final PublishSubject<Integer> pp = PublishSubject.create();
+            
+            TestObserver<Integer> ts = pp.test();
+            
+            Runnable task = new Runnable() {
+                @Override
+                public void run() {
+                    pp.onComplete();
+                }
+            };
+
+            TestHelper.race(task, task, Schedulers.io());
+            
+            ts
+            .awaitDone(5, TimeUnit.SECONDS)
+            .assertResult();
+        }
+    }
+    
+    @Test
+    public void addRemoveRance() throws Exception {
+        
+        for (int i = 0; i < 100; i++) {
+            final PublishSubject<Integer> pp = PublishSubject.create();
+            
+            final TestObserver<Integer> ts = pp.test();
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    pp.subscribe();
+                }
+            };
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    ts.cancel();
+                }
+            };
+
+            TestHelper.race(r1, r2, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void addTerminateRance() throws Exception {
+        
+        for (int i = 0; i < 100; i++) {
+            final PublishSubject<Integer> pp = PublishSubject.create();
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    pp.subscribe();
+                }
+            };
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    pp.onComplete();
+                }
+            };
+
+            TestHelper.race(r1, r2, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void addCompleteRance() throws Exception {
+        
+        for (int i = 0; i < 100; i++) {
+            final PublishSubject<Integer> pp = PublishSubject.create();
+            
+            final TestObserver<Integer> ts = new TestObserver<Integer>();
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    pp.subscribe(ts);
+                }
+            };
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    pp.onComplete();
+                }
+            };
+
+            TestHelper.race(r1, r2, Schedulers.io());
+            
+            ts.awaitDone()
+            .assertResult();
+        }
+    }
+
+    @Test
+    public void subscribeToAfterComplete() {
+        PublishSubject<Integer> pp = PublishSubject.create();
+        
+        pp.onComplete();
+        
+        PublishSubject<Integer> pp2 = PublishSubject.create();
+        
+        pp2.subscribe(pp);
+        
+        assertFalse(pp2.hasObservers());
+    }
+    
+    @Test
+    public void nullOnNext() {
+        PublishSubject<Integer> pp = PublishSubject.create();
+        
+        TestObserver<Integer> ts = pp.test();
+        
+        assertTrue(pp.hasObservers());
+        
+        pp.onNext(null);
+        
+        ts.assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    public void nullOnError() {
+        PublishSubject<Integer> pp = PublishSubject.create();
+        
+        TestObserver<Integer> ts = pp.test();
+        
+        pp.onError(null);
+        
+        ts.assertFailure(NullPointerException.class);
+    }
+    
+    @Test
+    public void subscribedTo() {
+        PublishSubject<Integer> pp = PublishSubject.create();
+        PublishSubject<Integer> pp2 = PublishSubject.create();
+        
+        pp.subscribe(pp2);
+        
+        TestObserver<Integer> ts = pp2.test();
+        
+        pp.onNext(1);
+        pp.onNext(2);
+        pp.onComplete();
+        
+        ts.assertResult(1, 2);
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java b/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java
index f06250148d..4b40b03d9c 100644
--- a/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java
+++ b/src/test/java/io/reactivex/subjects/ReplaySubjectTest.java
@@ -819,4 +819,113 @@ public void testGetValuesUnbounded() {
         assertArrayEquals(expected, rs.getValues());
         
     }
+
+    public void createInvalidCapacity() {
+        try {
+            ReplaySubject.create(-99);
+            fail("Didn't throw IllegalArgumentException");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("capacityHint > 0 required but it was -99", ex.getMessage());
+        }
+    }
+
+    @Test
+    public void createWithSizeInvalidCapacity() {
+        try {
+            ReplaySubject.createWithSize(-99);
+            fail("Didn't throw IllegalArgumentException");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("size > 0 required but it was -99", ex.getMessage());
+        }
+    }
+
+    @Test
+    public void createWithTimeAndSizeInvalidCapacity() {
+        try {
+            ReplaySubject.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), -99);
+            fail("Didn't throw IllegalArgumentException");
+        } catch (IllegalArgumentException ex) {
+            assertEquals("size > 0 required but it was -99", ex.getMessage());
+        }
+    }
+
+    @Test
+    public void hasSubscribers() {
+        ReplaySubject<Integer> rp = ReplaySubject.create();
+        
+        assertFalse(rp.hasObservers());
+        
+        TestObserver<Integer> ts = rp.test();
+        
+        assertTrue(rp.hasObservers());
+        
+        ts.cancel();
+        
+        assertFalse(rp.hasObservers());
+    }
+    
+    @Test
+    public void peekStateUnbounded() {
+        ReplaySubject<Integer> rp = ReplaySubject.create();
+        
+        rp.onNext(1);
+        
+        assertEquals((Integer)1, rp.getValue());
+        
+        assertEquals(1, rp.getValues()[0]);
+    }
+
+    @Test
+    public void peekStateTimeAndSize() {
+        ReplaySubject<Integer> rp = ReplaySubject.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), 1);
+        
+        rp.onNext(1);
+        
+        assertEquals((Integer)1, rp.getValue());
+        
+        assertEquals(1, rp.getValues()[0]);
+
+        rp.onNext(2);
+
+        assertEquals((Integer)2, rp.getValue());
+        
+        assertEquals(2, rp.getValues()[0]);
+
+        assertEquals((Integer)2, rp.getValues(new Integer[0])[0]);
+
+        assertEquals((Integer)2, rp.getValues(new Integer[1])[0]);
+
+        Integer[] a = new Integer[2];
+        assertEquals((Integer)2, rp.getValues(a)[0]);
+        assertNull(a[1]);
+    }
+
+    @Test
+    public void peekStateTimeAndSizeValue() {
+        ReplaySubject<Integer> rp = ReplaySubject.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), 1);
+    
+        assertNull(rp.getValue());
+        
+        assertEquals(0, rp.getValues().length);
+        
+        assertNull(rp.getValues(new Integer[2])[0]);
+
+        rp.onComplete();
+
+        assertNull(rp.getValue());
+        
+        assertEquals(0, rp.getValues().length);
+
+        assertNull(rp.getValues(new Integer[2])[0]);
+
+        rp = ReplaySubject.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), 1);
+        rp.onError(new TestException());
+        
+        assertNull(rp.getValue());
+        
+        assertEquals(0, rp.getValues().length);
+
+        assertNull(rp.getValues(new Integer[2])[0]);
+    }
+
 }
\ No newline at end of file
