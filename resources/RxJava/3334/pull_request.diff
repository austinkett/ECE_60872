diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java
index 5c57327701..c5bd7a996b 100644
--- a/src/main/java/io/reactivex/Observable.java
+++ b/src/main/java/io/reactivex/Observable.java
@@ -21,6 +21,7 @@
 
 import org.reactivestreams.*;
 
+import io.reactivex.annotations.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.*;
 import io.reactivex.internal.operators.*;
@@ -54,14 +55,16 @@
         
     }
 
-
+    /** The default buffer size. */
     static final int BUFFER_SIZE;
     static {
         BUFFER_SIZE = Math.max(16, Integer.getInteger("rx2.buffer-size", 128));
     }
 
+    /** An empty observable instance as there is no need to instantiate this more than once. */
     static final Observable<Object> EMPTY = create(PublisherEmptySource.INSTANCE);
 
+    /** A never observable instance as there is no need to instantiate this more than once. */
     static final Observable<Object> NEVER = create(s -> s.onSubscribe(EmptySubscription.INSTANCE));
 
     public static <T> Observable<T> amb(Iterable<? extends Publisher<? extends T>> sources) {
@@ -69,6 +72,8 @@
         return create(new PublisherAmb<>(null, sources));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T> Observable<T> amb(Publisher<? extends T>... sources) {
         Objects.requireNonNull(sources);
@@ -86,19 +91,27 @@ public static int bufferSize() {
         return BUFFER_SIZE;
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T, R> Observable<R> combineLatest(Function<? super Object[], ? extends R> combiner, boolean delayError, int bufferSize, Publisher<? extends T>... sources) {
         return combineLatest(sources, combiner, delayError, bufferSize);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, R> Observable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> combiner) {
         return combineLatest(sources, combiner, false, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, R> Observable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> combiner, boolean delayError) {
         return combineLatest(sources, combiner, delayError, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, R> Observable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> combiner, boolean delayError, int bufferSize) {
         Objects.requireNonNull(sources);
         Objects.requireNonNull(combiner);
@@ -109,14 +122,20 @@ public static int bufferSize() {
         return create(new PublisherCombineLatest<>(null, sources, combiner, s, delayError));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {
         return combineLatest(sources, combiner, false, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, boolean delayError) {
         return combineLatest(sources, combiner, delayError, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, boolean delayError, int bufferSize) {
         validateBufferSize(bufferSize);
         Objects.requireNonNull(combiner);
@@ -128,6 +147,8 @@ public static int bufferSize() {
         return create(new PublisherCombineLatest<>(sources, null, combiner, s, delayError));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, R> Observable<R> combineLatest(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
             BiFunction<? super T1, ? super T2, ? extends R> combiner) {
@@ -135,6 +156,8 @@ public static int bufferSize() {
         return combineLatest(f, false, bufferSize(), p1, p2);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, R> Observable<R> combineLatest(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
             Publisher<? extends T3> p3, 
@@ -142,6 +165,8 @@ public static int bufferSize() {
         return combineLatest(combiner, false, bufferSize(), p1, p2, p3);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, R> Observable<R> combineLatest(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
             Publisher<? extends T3> p3, Publisher<? extends T4> p4,
@@ -149,6 +174,8 @@ public static int bufferSize() {
         return combineLatest(combiner, false, bufferSize(), p1, p2, p3, p4);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, T5, R> Observable<R> combineLatest(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
             Publisher<? extends T3> p3, Publisher<? extends T4> p4,
@@ -157,6 +184,8 @@ public static int bufferSize() {
         return combineLatest(combiner, false, bufferSize(), p1, p2, p3, p4, p5);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, T5, T6, R> Observable<R> combineLatest(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
             Publisher<? extends T3> p3, Publisher<? extends T4> p4,
@@ -165,6 +194,8 @@ public static int bufferSize() {
         return combineLatest(combiner, false, bufferSize(), p1, p2, p3, p4, p5, p6);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, R> Observable<R> combineLatest(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
             Publisher<? extends T3> p3, Publisher<? extends T4> p4,
@@ -174,6 +205,8 @@ public static int bufferSize() {
         return combineLatest(combiner, false, bufferSize(), p1, p2, p3, p4, p5, p6, p7);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Observable<R> combineLatest(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
             Publisher<? extends T3> p3, Publisher<? extends T4> p4,
@@ -183,6 +216,8 @@ public static int bufferSize() {
         return combineLatest(combiner, false, bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Observable<R> combineLatest(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
             Publisher<? extends T3> p3, Publisher<? extends T4> p4,
@@ -193,27 +228,56 @@ public static int bufferSize() {
         return combineLatest(combiner, false, bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8, p9);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> concat(int prefetch, Iterable<? extends Publisher<? extends T>> sources) {
         Objects.requireNonNull(sources);
         return fromIterable(sources).concatMap(v -> v, prefetch);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static <T> Observable<T> concat(Iterable<? extends Publisher<? extends T>> sources) {
+        Objects.requireNonNull(sources);
+        return fromIterable(sources).concatMap(v -> v);
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static final <T> Observable<T> concat(Publisher<? extends Publisher<? extends T>> sources) {
+        return concat(sources, bufferSize());
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static final <T> Observable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {
+        return fromPublisher(sources).concatMap(v -> v);
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> concat(Publisher<? extends T> p1, Publisher<? extends T> p2) {
         return concatArray(p1, p2);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> concat(
             Publisher<? extends T> p1, Publisher<? extends T> p2,
             Publisher<? extends T> p3) {
         return concatArray(p1, p2, p3);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> concat(
             Publisher<? extends T> p1, Publisher<? extends T> p2,
             Publisher<? extends T> p3, Publisher<? extends T> p4) {
         return concatArray(p1, p2, p3, p4);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> concat(
             Publisher<? extends T> p1, Publisher<? extends T> p2, 
             Publisher<? extends T> p3, Publisher<? extends T> p4,
@@ -222,6 +286,8 @@ public static int bufferSize() {
         return concatArray(p1, p2, p3, p4, p5);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> concat(
             Publisher<? extends T> p1, Publisher<? extends T> p2, 
             Publisher<? extends T> p3, Publisher<? extends T> p4,
@@ -230,6 +296,8 @@ public static int bufferSize() {
         return concatArray(p1, p2, p3, p4, p5, p6);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> concat(
             Publisher<? extends T> p1, Publisher<? extends T> p2,
             Publisher<? extends T> p3, Publisher<? extends T> p4,
@@ -239,6 +307,8 @@ public static int bufferSize() {
         return concatArray(p1, p2, p3, p4, p5, p6, p7);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> concat(
             Publisher<? extends T> p1, Publisher<? extends T> p2, 
             Publisher<? extends T> p3, Publisher<? extends T> p4,
@@ -248,6 +318,8 @@ public static int bufferSize() {
         return concatArray(p1, p2, p3, p4, p5, p6, p7, p8);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> concat(
             Publisher<? extends T> p1, Publisher<? extends T> p2, 
             Publisher<? extends T> p3, Publisher<? extends T> p4,
@@ -258,21 +330,20 @@ public static int bufferSize() {
         return concatArray(p1, p2, p3, p4, p5, p6, p7, p8, p9);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T> Observable<T> concatArray(int prefetch, Publisher<? extends T>... sources) {
         Objects.requireNonNull(sources);
         return fromArray(sources).concatMap(v -> v, prefetch);
     }
 
-    public static <T> Observable<T> concat(Iterable<? extends Publisher<? extends T>> sources) {
-        Objects.requireNonNull(sources);
-        return fromIterable(sources).concatMap(v -> v);
-    }
-
     /**
      *
      * TODO named this way because of overload conflict with concat(Publisher&lt;Publisher&gt)
      */
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T> Observable<T> concatArray(Publisher<? extends T>... sources) {
         if (sources.length == 0) {
@@ -284,31 +355,43 @@ public static int bufferSize() {
         return fromArray(sources).concatMap(v -> v);
     }
 
+    @BackpressureSupport(BackpressureKind.NONE)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> create(Publisher<T> onSubscribe) {
         Objects.requireNonNull(onSubscribe);
         onSubscribe = RxJavaPlugins.onCreate(onSubscribe);
         return new Observable<>(onSubscribe);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> defer(Supplier<? extends Publisher<? extends T>> supplier) {
         return create(new PublisherDefer<>(supplier));
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SuppressWarnings("unchecked")
     public static <T> Observable<T> empty() {
         return (Observable<T>)EMPTY;
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> error(Supplier<? extends Throwable> errorSupplier) {
         Objects.requireNonNull(errorSupplier);
         return create(new PublisherErrorSource<>(errorSupplier));
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> error(Throwable e) {
         Objects.requireNonNull(e);
         return error(() -> e);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T> Observable<T> fromArray(T... values) {
         Objects.requireNonNull(values);
@@ -322,11 +405,15 @@ public static int bufferSize() {
     }
 
     // TODO match naming with RxJava 1.x
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> fromCallable(Callable<? extends T> supplier) {
         Objects.requireNonNull(supplier);
         return create(new PublisherScalarAsyncSource<>(supplier));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> fromFuture(CompletableFuture<? extends T> future) {
         Objects.requireNonNull(future);
         return create(new PublisherCompletableFutureSource<>(future));
@@ -337,6 +424,8 @@ public static int bufferSize() {
      * if necessary, one can use composition to achieve it:
      * futureObservable.doOnCancel(() -> future.cancel(true));
      */
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> fromFuture(Future<? extends T> future) {
         if (future instanceof CompletableFuture) {
             return fromFuture((CompletableFuture<? extends T>)future);
@@ -347,6 +436,8 @@ public static int bufferSize() {
         return o;
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit) {
         Objects.requireNonNull(future);
         Objects.requireNonNull(unit);
@@ -354,23 +445,31 @@ public static int bufferSize() {
         return o;
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public static <T> Observable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit, Scheduler scheduler) {
         Objects.requireNonNull(scheduler);
         Observable<T> o = fromFuture(future, timeout, unit); 
         return o.subscribeOn(scheduler);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.IO)
     public static <T> Observable<T> fromFuture(Future<? extends T> future, Scheduler scheduler) {
         Objects.requireNonNull(scheduler);
         Observable<T> o = fromFuture(future);
         return o.subscribeOn(Schedulers.io());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> fromIterable(Iterable<? extends T> source) {
         Objects.requireNonNull(source);
         return create(new PublisherIterableSource<>(source));
     }
-
+    
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SuppressWarnings("unchecked")
     public static <T> Observable<T> fromPublisher(Publisher<? extends T> publisher) {
         if (publisher instanceof Observable) {
@@ -381,11 +480,15 @@ public static int bufferSize() {
         return create(s -> publisher.subscribe(s)); // javac fails to compile publisher::subscribe, Eclipse is just fine
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> fromStream(Stream<? extends T> stream) {
         Objects.requireNonNull(stream);
         return create(new PublisherStreamSource<>(stream));
     }
-    
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> generate(Consumer<Subscriber<T>> generator) {
         Objects.requireNonNull(generator);
         return generate(() -> null, (s, o) -> {
@@ -394,6 +497,8 @@ public static int bufferSize() {
         }, s -> { });
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, S> Observable<T> generate(Supplier<S> initialState, BiConsumer<S, Subscriber<T>> generator) {
         Objects.requireNonNull(generator);
         return generate(initialState, (s, o) -> {
@@ -402,6 +507,8 @@ public static int bufferSize() {
         }, s -> { });
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, S> Observable<T> generate(Supplier<S> initialState, BiConsumer<S, Subscriber<T>> generator, Consumer<? super S> disposeState) {
         Objects.requireNonNull(generator);
         return generate(initialState, (s, o) -> {
@@ -410,10 +517,14 @@ public static int bufferSize() {
         }, disposeState);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, S> Observable<T> generate(Supplier<S> initialState, BiFunction<S, Subscriber<T>, S> generator) {
         return generate(initialState, generator, s -> { });
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, S> Observable<T> generate(Supplier<S> initialState, BiFunction<S, Subscriber<T>, S> generator, Consumer<? super S> disposeState) {
         Objects.requireNonNull(initialState);
         Objects.requireNonNull(generator);
@@ -421,10 +532,14 @@ public static int bufferSize() {
         return create(new PublisherGenerate<>(initialState, generator, disposeState));
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public static Observable<Long> interval(long initialDelay, long period, TimeUnit unit) {
         return interval(initialDelay, period, unit, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public static Observable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {
         if (initialDelay < 0) {
             initialDelay = 0L;
@@ -438,18 +553,26 @@ public static int bufferSize() {
         return create(new PublisherIntervalSource(initialDelay, period, unit, scheduler));
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public static Observable<Long> interval(long period, TimeUnit unit) {
         return interval(period, period, unit, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public static Observable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {
         return interval(period, period, unit, scheduler);
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {
         return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {
 
         long end = start + (count - 1);
@@ -469,87 +592,224 @@ public static int bufferSize() {
         return create(new PublisherIntervalRangeSource(start, end, initialDelay, period, unit, scheduler));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> just(T value) {
         Objects.requireNonNull(value);
         return create(new PublisherScalarSource<>(value));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static final <T> Observable<T> just(T v1, T v2) {
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        
+        return fromArray(v1, v2);
+    }
+
+    
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static final <T> Observable<T> just(T v1, T v2, T v3) {
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        
+        return fromArray(v1, v2, v3);
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4) {
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
+        
+        return fromArray(v1, v2, v3, v4);
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5) {
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
+        Objects.requireNonNull(v5, "The fifth value is null");
+        
+        return fromArray(v1, v2, v3, v4, v5);
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6) {
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
+        Objects.requireNonNull(v5, "The fifth value is null");
+        
+        return fromArray(v1, v2, v3, v4, v5, v6);
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7) {
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
+        Objects.requireNonNull(v5, "The fifth value is null");
+        Objects.requireNonNull(v6, "The sixth value is null");
+        Objects.requireNonNull(v7, "The seventh value is null");
+        
+        return fromArray(v1, v2, v3, v4, v5, v6, v7);
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8) {
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
+        Objects.requireNonNull(v5, "The fifth value is null");
+        Objects.requireNonNull(v6, "The sixth value is null");
+        Objects.requireNonNull(v7, "The seventh value is null");
+        Objects.requireNonNull(v8, "The eigth value is null");
+        
+        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8);
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9) {
+        Objects.requireNonNull(v1, "The first value is null");
+        Objects.requireNonNull(v2, "The second value is null");
+        Objects.requireNonNull(v3, "The third value is null");
+        Objects.requireNonNull(v4, "The fourth value is null");
+        Objects.requireNonNull(v5, "The fifth value is null");
+        Objects.requireNonNull(v6, "The sixth value is null");
+        Objects.requireNonNull(v7, "The seventh value is null");
+        Objects.requireNonNull(v8, "The eigth value is null");
+        Objects.requireNonNull(v9, "The ninth is null");
+        
+        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9);
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> merge(int maxConcurrency, int bufferSize, Iterable<? extends Publisher<? extends T>> sources) {
         return fromIterable(sources).flatMap(v -> v, false, maxConcurrency, bufferSize);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T> Observable<T> merge(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {
         return fromArray(sources).flatMap(v -> v, false, maxConcurrency, bufferSize);
     }
 
-    public static <T> Observable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {
-        return fromIterable(sources).flatMap(v -> v, maxConcurrency);
-    }
-
-    
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T> Observable<T> merge(int maxConcurrency, Publisher<? extends T>... sources) {
         return fromArray(sources).flatMap(v -> v, maxConcurrency);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> merge(Iterable<? extends Publisher<? extends T>> sources) {
         return fromIterable(sources).flatMap(v -> v);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static <T> Observable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {
+        return fromIterable(sources).flatMap(v -> v, maxConcurrency);
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> merge(Publisher<? extends Publisher<? extends T>> sources) {
         return merge(sources, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> merge(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {
         return fromPublisher(sources).flatMap(v -> v, maxConcurrency);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T> Observable<T> merge(Publisher<? extends T>... sources) {
         return fromArray(sources).flatMap(v -> v, sources.length);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> mergeDelayError(boolean delayErrors, Iterable<? extends Publisher<? extends T>> sources) {
         return fromIterable(sources).flatMap(v -> v, true);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> mergeDelayError(int maxConcurrency, int bufferSize, Iterable<? extends Publisher<? extends T>> sources) {
         return fromIterable(sources).flatMap(v -> v, true, maxConcurrency, bufferSize);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T> Observable<T> mergeDelayError(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {
         return fromArray(sources).flatMap(v -> v, true, maxConcurrency, bufferSize);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> mergeDelayError(int maxConcurrency, Iterable<? extends Publisher<? extends T>> sources) {
         return fromIterable(sources).flatMap(v -> v, true, maxConcurrency);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T> Observable<T> mergeDelayError(int maxConcurrency, Publisher<? extends T>... sources) {
         return fromArray(sources).flatMap(v -> v, true, maxConcurrency);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources) {
         return mergeDelayError(sources, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {
         return fromPublisher(sources).flatMap(v -> v, true, maxConcurrency);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T> Observable<T> mergeDelayError(Publisher<? extends T>... sources) {
         return fromArray(sources).flatMap(v -> v, true, sources.length);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SuppressWarnings("unchecked")
     public static <T> Observable<T> never() {
         return (Observable<T>)NEVER;
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static Observable<Integer> range(int start, int count) {
         if (count < 0) {
             throw new IllegalArgumentException("count >= required but it was " + count);
@@ -570,19 +830,27 @@ public static int bufferSize() {
      *
      * @deprecated use composition
      */
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     @Deprecated
     public static Observable<Integer> range(int start, int count, Scheduler scheduler) {
         return range(start, count).subscribeOn(scheduler);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2) {
         return sequenceEqual(p1, p2, Objects::equals, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, BiPredicate<? super T, ? super T> isEqual) {
         return sequenceEqual(p1, p2, isEqual, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, BiPredicate<? super T, ? super T> isEqual, int bufferSize) {
         Objects.requireNonNull(p1);
         Objects.requireNonNull(p2);
@@ -591,22 +859,32 @@ public static int bufferSize() {
         return create(new PublisherSequenceEqual<>(p1, p2, isEqual, bufferSize));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, int bufferSize) {
         return sequenceEqual(p1, p2, Objects::equals, bufferSize);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> switchOnNext(int bufferSize, Publisher<? extends Publisher<? extends T>> sources) {
         return fromPublisher(sources).switchMap(v -> v, bufferSize);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T> Observable<T> switchOnNext(Publisher<? extends Publisher<? extends T>> sources) {
         return fromPublisher(sources).switchMap(v -> v);
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public static Observable<Long> timer(long delay, TimeUnit unit) {
         return timer(delay, unit, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public static Observable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {
         if (delay < 0) {
             delay = 0L;
@@ -628,10 +906,14 @@ public static int bufferSize() {
         };
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, D> Observable<T> using(Supplier<? extends D> resourceSupplier, Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> disposer) {
         return using(resourceSupplier, sourceSupplier, disposer, true);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, D> Observable<T> using(Supplier<? extends D> resourceSupplier, Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> disposer, boolean eager) {
         Objects.requireNonNull(resourceSupplier);
         Objects.requireNonNull(sourceSupplier);
@@ -645,36 +927,57 @@ private static void validateBufferSize(int bufferSize) {
         }
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public static <T, R> Observable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {
+        Objects.requireNonNull(zipper);
+        Objects.requireNonNull(sources);
+        return create(new PublisherZip<>(null, sources, zipper, bufferSize(), false));
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, R> Observable<R> zip(Publisher<? extends Publisher<? extends T>> sources, Function<Object[], R> zipper) {
         return fromPublisher(sources).toList().flatMap(list -> {
             return zipIterable(zipper, false, bufferSize(), list);
         });
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, R> Observable<R> zip(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
             BiFunction<? super T1, ? super T2, ? extends R> zipper) {
         return zipArray(toFunction(zipper), false, bufferSize(), p1, p2);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, R> Observable<R> zip(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
             BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError) {
         return zipArray(toFunction(zipper), delayError, bufferSize(), p1, p2);
     }
 
+    
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, R> Observable<R> zip(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, 
             BiFunction<? super T1, ? super T2, ? extends R> zipper, boolean delayError, int bufferSize) {
         return zipArray(toFunction(zipper), delayError, bufferSize, p1, p2);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, R> Observable<R> zip(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3, 
             Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper) {
         return zipArray(zipper, false, bufferSize(), p1, p2, p3);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, R> Observable<R> zip(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
             Publisher<? extends T4> p4,
@@ -682,6 +985,8 @@ private static void validateBufferSize(int bufferSize) {
         return zipArray(zipper, false, bufferSize(), p1, p2, p3, p4);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, T5, R> Observable<R> zip(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
             Publisher<? extends T4> p4, Publisher<? extends T5> p5,
@@ -689,6 +994,8 @@ private static void validateBufferSize(int bufferSize) {
         return zipArray(zipper, false, bufferSize(), p1, p2, p3, p4, p5);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, T5, T6, R> Observable<R> zip(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
             Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
@@ -696,6 +1003,8 @@ private static void validateBufferSize(int bufferSize) {
         return zipArray(zipper, false, bufferSize(), p1, p2, p3, p4, p5, p6);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, R> Observable<R> zip(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
             Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
@@ -704,6 +1013,8 @@ private static void validateBufferSize(int bufferSize) {
         return zipArray(zipper, false, bufferSize(), p1, p2, p3, p4, p5, p6, p7);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, R> Observable<R> zip(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
             Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
@@ -712,6 +1023,8 @@ private static void validateBufferSize(int bufferSize) {
         return zipArray(zipper, false, bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> Observable<R> zip(
             Publisher<? extends T1> p1, Publisher<? extends T2> p2, Publisher<? extends T3> p3,
             Publisher<? extends T4> p4, Publisher<? extends T5> p5, Publisher<? extends T6> p6,
@@ -720,6 +1033,8 @@ private static void validateBufferSize(int bufferSize) {
         return zipArray(zipper, false, bufferSize(), p1, p2, p3, p4, p5, p6, p7, p8, p9);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public static <T, R> Observable<R> zipArray(Function<? super Object[], ? extends R> zipper, 
             boolean delayError, int bufferSize, Publisher<? extends T>... sources) {
@@ -731,6 +1046,8 @@ private static void validateBufferSize(int bufferSize) {
         return create(new PublisherZip<>(sources, null, zipper, bufferSize, delayError));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public static <T, R> Observable<R> zipIterable(Function<? super Object[], ? extends R> zipper,
             boolean delayError, int bufferSize, 
             Iterable<? extends Publisher<? extends T>> sources) {
@@ -740,80 +1057,103 @@ private static void validateBufferSize(int bufferSize) {
         return create(new PublisherZip<>(null, sources, zipper, bufferSize, delayError));
     }
 
-    public static <T, R> Observable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {
-        Objects.requireNonNull(zipper);
-        Objects.requireNonNull(sources);
-        return create(new PublisherZip<>(null, sources, zipper, bufferSize(), false));
-    }
-
-    
     final Publisher<T> onSubscribe;
-
+    
     protected Observable(Publisher<T> onSubscribe) {
         this.onSubscribe = onSubscribe;
     }
-
+    
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<Boolean> all(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
         return lift(new OperatorAll<>(predicate));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> ambWith(Publisher<? extends T> other) {
         return amb(this, other);
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<Boolean> any(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
         return lift(new OperatorAny<>(predicate));
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> asObservable() {
         return create(s -> this.subscribe(s));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<List<T>> buffer(int count) {
         return buffer(count, count);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<List<T>> buffer(int count, int skip) {
         return buffer(count, skip, ArrayList::new);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U extends Collection<? super T>> Observable<U> buffer(int count, int skip, Supplier<U> bufferSupplier) {
         return lift(new OperatorBuffer<>(count, skip, bufferSupplier));
     }
-
+    
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U extends Collection<? super T>> Observable<U> buffer(int count, Supplier<U> bufferSupplier) {
         return buffer(count, count, bufferSupplier);
     }
-
+    
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {
         return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayList::new);
     }
-    
+
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {
         return buffer(timespan, timeskip, unit, scheduler, ArrayList::new);
     }
-    
+
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final <U extends Collection<? super T>> Observable<U> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, Supplier<U> bufferSupplier) {
         Objects.requireNonNull(unit);
         Objects.requireNonNull(scheduler);
         Objects.requireNonNull(bufferSupplier);
         return lift(new OperatorBufferTimed<>(timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false));
     }
-
+    
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<List<T>> buffer(long timespan, TimeUnit unit) {
         return buffer(timespan, unit, Integer.MAX_VALUE, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<List<T>> buffer(long timespan, TimeUnit unit, int count) {
         return buffer(timespan, unit, count, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<List<T>> buffer(long timespan, TimeUnit unit, int count, Scheduler scheduler) {
         return buffer(timespan, unit, count, scheduler, ArrayList::new, false);
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final <U extends Collection<? super T>> Observable<U> buffer(
             long timespan, TimeUnit unit, 
             int count, Scheduler scheduler, 
@@ -828,16 +1168,22 @@ protected Observable(Publisher<T> onSubscribe) {
         return lift(new OperatorBufferTimed<>(timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler) {
         return buffer(timespan, unit, Integer.MAX_VALUE, scheduler, ArrayList::new, false);
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <TOpening, TClosing> Observable<List<T>> buffer(
             Observable<? extends TOpening> bufferOpenings, 
             Function<? super TOpening, ? extends Publisher<? extends TClosing>> bufferClosingSelector) {
         return buffer(bufferOpenings, bufferClosingSelector, ArrayList::new);
     }
-    
+
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <TOpening, TClosing, U extends Collection<? super T>> Observable<U> buffer(
             Observable<? extends TOpening> bufferOpenings, 
             Function<? super TOpening, ? extends Publisher<? extends TClosing>> bufferClosingSelector,
@@ -847,7 +1193,9 @@ protected Observable(Publisher<T> onSubscribe) {
         Objects.requireNonNull(bufferSupplier);
         return lift(new OperatorBufferBoundary<>(bufferOpenings, bufferClosingSelector, bufferSupplier));
     }
-    
+
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <B> Observable<List<T>> buffer(Observable<B> boundary) {
         /*
          * XXX: javac complains if this is not manually cast, Eclipse is fine
@@ -855,66 +1203,82 @@ protected Observable(Publisher<T> onSubscribe) {
         return buffer(boundary, (Supplier<List<T>>)ArrayList::new);
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <B> Observable<List<T>> buffer(Observable<B> boundary, int initialCapacity) {
         return buffer(boundary, () -> new ArrayList<>(initialCapacity));
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <B, U extends Collection<? super T>> Observable<U> buffer(Observable<B> boundary, Supplier<U> bufferSupplier) {
         Objects.requireNonNull(boundary);
         Objects.requireNonNull(bufferSupplier);
         return lift(new OperatorBufferExactBoundary<>(boundary, bufferSupplier));
     }
-    
+
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <B> Observable<List<T>> buffer(Supplier<? extends Observable<B>> boundarySupplier) {
         return buffer(boundarySupplier, ArrayList::new);
         
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <B, U extends Collection<? super T>> Observable<U> buffer(Supplier<? extends Observable<B>> boundarySupplier, Supplier<U> bufferSupplier) {
         Objects.requireNonNull(boundarySupplier);
         Objects.requireNonNull(bufferSupplier);
         return lift(new OperatorBufferBoundarySupplier<>(boundarySupplier, bufferSupplier));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> cache() {
         return CachedObservable.from(this);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> cache(int capacityHint) {
         return CachedObservable.from(this, capacityHint);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<U> cast(Class<U> clazz) {
         return map(clazz::cast);
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<U> collect(Supplier<? extends U> initialValueSupplier, BiConsumer<? super U, ? super T> collector) {
         Objects.requireNonNull(initialValueSupplier);
         Objects.requireNonNull(collector);
         return lift(new OperatorCollect<>(initialValueSupplier, collector));
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<U> collectInto(U initialValue, BiConsumer<? super U, ? super T> collector) {
         return collect(() -> initialValue, collector);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     // TODO generics
     public final <R> Observable<R> compose(Transformer<T, R> composer) {
         return fromPublisher(to(composer));
     }
 
-    public static final <T> Observable<T> concat(Publisher<? extends Publisher<? extends T>> sources) {
-        return concat(sources, bufferSize());
-    }
-
-    public static final <T> Observable<T> concat(Publisher<? extends Publisher<? extends T>> sources, int bufferSize) {
-        return fromPublisher(sources).concatMap(v -> v);
-    }
-
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {
         return concatMap(mapper, 2);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) {
         Objects.requireNonNull(mapper);
         if (prefetch <= 0) {
@@ -923,66 +1287,94 @@ protected Observable(Publisher<T> onSubscribe) {
         return lift(new OperatorConcatMap<>(mapper, prefetch));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {
         return concatMap(v -> new PublisherIterableSource<>(mapper.apply(v)));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<U> concatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper, int prefetch) {
         return concatMap(v -> new PublisherIterableSource<>(mapper.apply(v)), prefetch);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> concatWith(Publisher<? extends T> other) {
         Objects.requireNonNull(other);
         return concat(this, other);
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<Boolean> contains(Object o) {
         Objects.requireNonNull(o);
         return any(v -> Objects.equals(v, o));
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<Long> count() {
         return lift(OperatorCount.instance());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<T> debounce(Function<? super T, ? extends Publisher<U>> debounceSelector) {
         Objects.requireNonNull(debounceSelector);
         return lift(new OperatorDebounce<>(debounceSelector));
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<T> debounce(long timeout, TimeUnit unit) {
         return debounce(timeout, unit, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {
         Objects.requireNonNull(unit);
         Objects.requireNonNull(scheduler);
         return lift(new OperatorDebounceTimed<>(timeout, unit, scheduler));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> defaultIfEmpty(T value) {
         Objects.requireNonNull(value);
         return switchIfEmpty(just(value));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     // TODO a more efficient implementation if necessary
     public final <U> Observable<T> delay(Function<? super T, ? extends Publisher<U>> itemDelay) {
         Objects.requireNonNull(itemDelay);
         return flatMap(v -> fromPublisher(itemDelay.apply(v)).take(1).map(u -> v).defaultIfEmpty(v));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<T> delay(long delay, TimeUnit unit) {
         return delay(delay, unit, Schedulers.computation(), false);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<T> delay(long delay, TimeUnit unit, boolean delayError) {
         return delay(delay, unit, Schedulers.computation(), delayError);
     }
-
+    
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler) {
         return delay(delay, unit, scheduler, false);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {
         Objects.requireNonNull(unit);
         Objects.requireNonNull(scheduler);
@@ -990,15 +1382,21 @@ protected Observable(Publisher<T> onSubscribe) {
         return lift(new OperatorDelay<>(delay, unit, scheduler, delayError));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, V> Observable<T> delay(Supplier<? extends Publisher<U>> delaySupplier,
             Function<? super T, ? extends Publisher<V>> itemDelay) {
         return delaySubscription(delaySupplier).delay(itemDelay);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<T> delaySubscription(long delay, TimeUnit unit) {
         return delaySubscription(delay, unit, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     // TODO a more efficient implementation if necessary
     public final Observable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {
         Objects.requireNonNull(unit);
@@ -1007,43 +1405,64 @@ protected Observable(Publisher<T> onSubscribe) {
         return timer(delay, unit, scheduler).flatMap(v -> this);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<T> delaySubscription(Supplier<? extends Publisher<U>> delaySupplier) {
         return fromCallable(delaySupplier::get).take(1).flatMap(v -> this);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <T2> Observable<T2> dematerialize() {
         @SuppressWarnings("unchecked")
         Observable<Try<Optional<T2>>> m = (Observable<Try<Optional<T2>>>)this;
         return m.lift(OperatorDematerialize.instance());
     }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> distinct() {
         return distinct(v -> v, HashSet::new);
     }
-    
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K> Observable<T> distinct(Function<? super T, K> keySelector) {
         return distinct(keySelector, HashSet::new);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K> Observable<T> distinct(Function<? super T, K> keySelector, Supplier<? extends Collection<? super K>> collectionSupplier) {
         return lift(OperatorDistinct.withCollection(keySelector, collectionSupplier));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> distinctUntilChanged() {
         return lift(OperatorDistinct.untilChanged());
     }
-
+    
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K> Observable<T> distinctUntilChanged(Function<? super T, K> keySelector) {
         return lift(OperatorDistinct.untilChanged(keySelector));
     }
-
+    
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> doOnCancel(Runnable onCancel) {
         return doOnLifecycle(s -> { }, n -> { }, onCancel);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> doOnComplete(Runnable onComplete) {
         return doOnEach(v -> { }, e -> { }, onComplete, () -> { });
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     private Observable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Runnable onComplete, Runnable onAfterTerminate) {
         Objects.requireNonNull(onNext);
         Objects.requireNonNull(onError);
@@ -1051,7 +1470,9 @@ protected Observable(Publisher<T> onSubscribe) {
         Objects.requireNonNull(onAfterTerminate);
         return lift(new OperatorDoOnEach<>(onNext, onError, onComplete, onAfterTerminate));
     }
-
+    
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> doOnEach(Consumer<? super Try<Optional<T>>> consumer) {
         return doOnEach(
                 v -> consumer.accept(Try.ofValue(Optional.of(v))),
@@ -1061,43 +1482,61 @@ protected Observable(Publisher<T> onSubscribe) {
                 );
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> doOnEach(Subscriber<? super T> observer) {
         return doOnEach(observer::onNext, observer::onError, observer::onComplete, () -> { });
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> doOnError(Consumer<? super Throwable> onError) {
         return doOnEach(v -> { }, onError, () -> { }, () -> { });
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> doOnLifecycle(Consumer<? super Subscription> onSubscribe, LongConsumer onRequest, Runnable onCancel) {
         return lift(s -> new SubscriptionLambdaSubscriber<>(s, onSubscribe, onRequest, onCancel));
     }
-    
+
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> doOnNext(Consumer<? super T> onNext) {
         return doOnEach(onNext, e -> { }, () -> { }, () -> { });
     }
-    
+
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> doOnRequest(LongConsumer onRequest) {
         return doOnLifecycle(s -> { }, onRequest, () -> { });
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> doOnSubscribe(Consumer<? super Subscription> onSubscribe) {
         return doOnLifecycle(onSubscribe, n -> { }, () -> { });
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> doOnTerminate(Runnable onTerminate) {
         return doOnEach(v -> { }, e -> onTerminate.run(), onTerminate, () -> { });
     }
-    
+
     /**
      *
      * @deprecated use {@link #doOnCancel(Runnable)} instead
      */
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     @Deprecated
     public final Observable<T> doOnUnsubscribe(Runnable onUnsubscribe) {
         return doOnCancel(onUnsubscribe);
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> elementAt(long index) {
         if (index < 0) {
             throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);
@@ -1105,6 +1544,8 @@ protected Observable(Publisher<T> onSubscribe) {
         return lift(new OperatorElementAt<>(index, null));
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> elementAt(long index, T defaultValue) {
         if (index < 0) {
             throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);
@@ -1113,20 +1554,29 @@ protected Observable(Publisher<T> onSubscribe) {
         return lift(new OperatorElementAt<>(index, defaultValue));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> endWith(Iterable<? extends T> values) {
         return concatArray(this, fromIterable(values));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> endWith(Publisher<? extends T> other) {
         Objects.requireNonNull(other);
         return concatArray(this, other);
     }
 
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> endWith(T value) {
         Objects.requireNonNull(value);
         return concatArray(this, just(value));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public final Observable<T> endWithArray(T... values) {
         Observable<T> fromArray = fromArray(values);
@@ -1139,45 +1589,74 @@ protected Observable(Publisher<T> onSubscribe) {
     /**
      * @deprecated use {@link #any(Predicate)}
      */
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     @Deprecated
     public final Observable<Boolean> exists(Predicate<? super T> predicate) {
         return any(predicate);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> filter(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
         return lift(new OperatorFilter<>(predicate));
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> finallyDo(Runnable onFinally) {
         return doOnEach(v -> { }, e -> { }, () -> { }, onFinally);
     }
 
+    @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> first() {
         return take(1).single();
     }
 
+    @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> first(T defaultValue) {
         return take(1).single(defaultValue);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {
         return flatMap(mapper, false, bufferSize(), bufferSize());
     }
 
-
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors) {
         return flatMap(mapper, delayErrors, bufferSize(), bufferSize());
     }
 
-    public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> resultSelector) {
-        return flatMap(mapper, resultSelector, false, bufferSize(), bufferSize());
-    }
-
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean delayErrors, int maxConcurrency) {
         return flatMap(mapper, delayErrors, maxConcurrency, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, 
+            boolean delayErrors, int maxConcurrency, int bufferSize) {
+        Objects.requireNonNull(mapper);
+        if (maxConcurrency <= 0) {
+            throw new IllegalArgumentException("maxConcurrency > 0 required but it was " + maxConcurrency);
+        }
+        validateBufferSize(bufferSize);
+        if (onSubscribe instanceof PublisherScalarSource) {
+            PublisherScalarSource<T> scalar = (PublisherScalarSource<T>) onSubscribe;
+            return create(scalar.flatMap(mapper));
+        }
+        return lift(new OperatorFlatMap<>(mapper, delayErrors, maxConcurrency, bufferSize));
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> flatMap(
             Function<? super T, ? extends Publisher<? extends R>> onNextMapper, 
             Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper, 
@@ -1185,6 +1664,8 @@ protected Observable(Publisher<T> onSubscribe) {
         return merge(lift(new OperatorMapNotification<>(onNextMapper, onErrorMapper, onCompleteSupplier)));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> flatMap(
             Function<? super T, ? extends Publisher<? extends R>> onNextMapper, 
             Function<Throwable, ? extends Publisher<? extends R>> onErrorMapper, 
@@ -1193,32 +1674,32 @@ protected Observable(Publisher<T> onSubscribe) {
         return merge(lift(new OperatorMapNotification<>(onNextMapper, onErrorMapper, onCompleteSupplier)), maxConcurrency);
     }
 
-    public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, 
-            boolean delayErrors, int maxConcurrency, int bufferSize) {
-        Objects.requireNonNull(mapper);
-        if (maxConcurrency <= 0) {
-            throw new IllegalArgumentException("maxConcurrency > 0 required but it was " + maxConcurrency);
-        }
-        validateBufferSize(bufferSize);
-        if (onSubscribe instanceof PublisherScalarSource) {
-            PublisherScalarSource<T> scalar = (PublisherScalarSource<T>) onSubscribe;
-            return create(scalar.flatMap(mapper));
-        }
-        return lift(new OperatorFlatMap<>(mapper, delayErrors, maxConcurrency, bufferSize));
-    }
-
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int maxConcurrency) {
         return flatMap(mapper, false, maxConcurrency, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> resultSelector) {
+        return flatMap(mapper, resultSelector, false, bufferSize(), bufferSize());
+    }
+
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError) {
         return flatMap(mapper, combiner, delayError, bufferSize(), bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError, int maxConcurrency) {
         return flatMap(mapper, combiner, delayError, maxConcurrency, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError, int maxConcurrency, int bufferSize) {
         return flatMap(t -> {
             Observable<U> u = fromPublisher(mapper.apply(t));
@@ -1226,36 +1707,50 @@ protected Observable(Publisher<T> onSubscribe) {
         }, delayError, maxConcurrency, bufferSize);
     }
 
-    // TODO rest of the new zip overloads (got tired copy-pasting)
-
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, int maxConcurrency) {
         return flatMap(mapper, combiner, false, maxConcurrency, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<U> flatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper) {
         return flatMap(v -> new PublisherIterableSource<>(mapper.apply(v)));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, V> Observable<V> flatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends V> resultSelector) {
         return flatMap(t -> new PublisherIterableSource<>(mapper.apply(t)), resultSelector, false, bufferSize(), bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<U> flatMapIterable(Function<? super T, ? extends Iterable<? extends U>> mapper, int bufferSize) {
         return flatMap(v -> new PublisherIterableSource<>(mapper.apply(v)), false, bufferSize);
     }
 
+    @BackpressureSupport(BackpressureKind.NONE)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Disposable forEach(Consumer<? super T> onNext) {
         return subscribe(onNext);
     }
 
+    @BackpressureSupport(BackpressureKind.NONE)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Disposable forEachWhile(Predicate<? super T> onNext) {
         return forEachWhile(onNext, RxJavaPlugins::onError, () -> { });
     }
 
+    @BackpressureSupport(BackpressureKind.NONE)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError) {
         return forEachWhile(onNext, onError, () -> { });
     }
 
+    @BackpressureSupport(BackpressureKind.NONE)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError,
             Runnable onComplete) {
         Objects.requireNonNull(onNext);
@@ -1274,24 +1769,34 @@ public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? sup
         });
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {
         return groupBy(keySelector, v -> v, false, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector, boolean delayError) {
         return groupBy(keySelector, v -> v, delayError, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, 
             Function<? super T, ? extends V> valueSelector) {
         return groupBy(keySelector, valueSelector, false, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, 
             Function<? super T, ? extends V> valueSelector, boolean delayError) {
         return groupBy(keySelector, valueSelector, false, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, 
             Function<? super T, ? extends V> valueSelector, 
             boolean delayError, int bufferSize) {
@@ -1302,105 +1807,32 @@ public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? sup
         return lift(new OperatorGroupBy<>(keySelector, valueSelector, bufferSize, delayError));
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> ignoreElements() {
         return lift(OperatorIgnoreElements.instance());
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<Boolean> isEmpty() {
         return all(v -> false);
     }
 
-    public static final <T> Observable<T> just(T v1, T v2) {
-        Objects.requireNonNull(v1, "The first value is null");
-        Objects.requireNonNull(v2, "The second value is null");
-        
-        return fromArray(v1, v2);
-    }
-
-    public static final <T> Observable<T> just(T v1, T v2, T v3) {
-        Objects.requireNonNull(v1, "The first value is null");
-        Objects.requireNonNull(v2, "The second value is null");
-        Objects.requireNonNull(v3, "The third value is null");
-        
-        return fromArray(v1, v2, v3);
-    }
-
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4) {
-        Objects.requireNonNull(v1, "The first value is null");
-        Objects.requireNonNull(v2, "The second value is null");
-        Objects.requireNonNull(v3, "The third value is null");
-        Objects.requireNonNull(v4, "The fourth value is null");
-        
-        return fromArray(v1, v2, v3, v4);
-    }
-
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5) {
-        Objects.requireNonNull(v1, "The first value is null");
-        Objects.requireNonNull(v2, "The second value is null");
-        Objects.requireNonNull(v3, "The third value is null");
-        Objects.requireNonNull(v4, "The fourth value is null");
-        Objects.requireNonNull(v5, "The fifth value is null");
-        
-        return fromArray(v1, v2, v3, v4, v5);
-    }
-
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6) {
-        Objects.requireNonNull(v1, "The first value is null");
-        Objects.requireNonNull(v2, "The second value is null");
-        Objects.requireNonNull(v3, "The third value is null");
-        Objects.requireNonNull(v4, "The fourth value is null");
-        Objects.requireNonNull(v5, "The fifth value is null");
-        
-        return fromArray(v1, v2, v3, v4, v5, v6);
-    }
-
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7) {
-        Objects.requireNonNull(v1, "The first value is null");
-        Objects.requireNonNull(v2, "The second value is null");
-        Objects.requireNonNull(v3, "The third value is null");
-        Objects.requireNonNull(v4, "The fourth value is null");
-        Objects.requireNonNull(v5, "The fifth value is null");
-        Objects.requireNonNull(v6, "The sixth value is null");
-        Objects.requireNonNull(v7, "The seventh value is null");
-        
-        return fromArray(v1, v2, v3, v4, v5, v6, v7);
-    }
-
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8) {
-        Objects.requireNonNull(v1, "The first value is null");
-        Objects.requireNonNull(v2, "The second value is null");
-        Objects.requireNonNull(v3, "The third value is null");
-        Objects.requireNonNull(v4, "The fourth value is null");
-        Objects.requireNonNull(v5, "The fifth value is null");
-        Objects.requireNonNull(v6, "The sixth value is null");
-        Objects.requireNonNull(v7, "The seventh value is null");
-        Objects.requireNonNull(v8, "The eigth value is null");
-        
-        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8);
-    }
-
-    public static final <T> Observable<T> just(T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9) {
-        Objects.requireNonNull(v1, "The first value is null");
-        Objects.requireNonNull(v2, "The second value is null");
-        Objects.requireNonNull(v3, "The third value is null");
-        Objects.requireNonNull(v4, "The fourth value is null");
-        Objects.requireNonNull(v5, "The fifth value is null");
-        Objects.requireNonNull(v6, "The sixth value is null");
-        Objects.requireNonNull(v7, "The seventh value is null");
-        Objects.requireNonNull(v8, "The eigth value is null");
-        Objects.requireNonNull(v9, "The ninth is null");
-        
-        return fromArray(v1, v2, v3, v4, v5, v6, v7, v8, v9);
-    }
-
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> last() {
         return takeLast(1).single();
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> last(T defaultValue) {
         return takeLast(1).single(defaultValue);
     }
 
+    @BackpressureSupport(BackpressureKind.SPECIAL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> lift(Operator<? extends R, ? super T> lifter) {
         Objects.requireNonNull(lifter);
         // using onSubscribe so the fusing has access to the underlying raw Publisher
@@ -1410,149 +1842,215 @@ public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? sup
     /**
      * @deprecated use {@link #take(long)} instead
      */
+    @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN
+    @SchedulerSupport(SchedulerKind.NONE)
     @Deprecated
     public final Observable<T> limit(long n) {
         return take(n);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> map(Function<? super T, ? extends R> mapper) {
         return lift(new OperatorMap<>(mapper));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<Try<Optional<T>>> materialize() {
         return lift(OperatorMaterialize.instance());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> mergeWith(Publisher<? extends T> other) {
         return merge(this, other);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @Deprecated
     public final Observable<Observable<T>> nest() {
         return just(this);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> observeOn(Scheduler scheduler) {
         return observeOn(scheduler, false, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> observeOn(Scheduler scheduler, boolean delayError) {
         return observeOn(scheduler, delayError, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {
         Objects.requireNonNull(scheduler);
         validateBufferSize(bufferSize);
         return lift(new OperatorObserveOn<>(scheduler, delayError, bufferSize));
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<U> ofType(Class<U> clazz) {
         return filter(clazz::isInstance).cast(clazz);
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onBackpressureBuffer() {
         return onBackpressureBuffer(bufferSize(), false, true);
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onBackpressureBuffer(boolean delayError) {
         return onBackpressureBuffer(bufferSize(), true, true);
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onBackpressureBuffer(int bufferSize) {
         return onBackpressureBuffer(bufferSize, false, false);
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onBackpressureBuffer(int bufferSize, boolean delayError) {
         return onBackpressureBuffer(bufferSize, true, false);
     }
 
+    @BackpressureSupport(BackpressureKind.SPECIAL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onBackpressureBuffer(int bufferSize, boolean delayError, boolean unbounded) {
         validateBufferSize(bufferSize);
         return lift(new OperatorOnBackpressureBuffer<>(bufferSize, unbounded, delayError, () -> { }));
     }
 
+    @BackpressureSupport(BackpressureKind.SPECIAL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onBackpressureBuffer(int bufferSize, boolean delayError, boolean unbounded, Runnable onOverflow) {
         return lift(new OperatorOnBackpressureBuffer<>(bufferSize, unbounded, delayError, onOverflow));
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onBackpressureBuffer(int bufferSize, Runnable onOverflow) {
         return onBackpressureBuffer(bufferSize, false, false, onOverflow);
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onBackpressureDrop() {
         return lift(OperatorOnBackpressureDrop.instance());
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onBackpressureDrop(Consumer<? super T> onDrop) {
         return lift(new OperatorOnBackpressureDrop<>(onDrop));
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onBackpressureLatest() {
         return lift(OperatorOnBackpressureLatest.instance());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onErrorResumeNext(Function<? super Throwable, ? extends Publisher<? extends T>> resumeFunction) {
         Objects.requireNonNull(resumeFunction);
         return lift(new OperatorOnErrorNext<>(resumeFunction, false));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onErrorResumeNext(Publisher<? extends T> next) {
         Objects.requireNonNull(next);
         return onErrorResumeNext(e -> next);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {
         Objects.requireNonNull(valueSupplier);
         return lift(new OperatorOnErrorReturn<>(valueSupplier));
     }
 
     // TODO would result in ambiguity with onErrorReturn(Function)
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onErrorReturnValue(T value) {
         Objects.requireNonNull(value);
         return onErrorReturn(e -> value);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> onExceptionResumeNext(Publisher<? extends T> next) {
         Objects.requireNonNull(next);
         return lift(new OperatorOnErrorNext<>(e -> next, true));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final ConnectableObservable<T> publish() {
         return publish(bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> publish(Function<? super Observable<T>, ? extends Publisher<R>> selector) {
         return publish(selector, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> publish(Function<? super Observable<T>, ? extends Publisher<R>> selector, int bufferSize) {
         validateBufferSize(bufferSize);
         Objects.requireNonNull(selector);
         return OperatorPublish.create(this, selector, bufferSize);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final ConnectableObservable<T> publish(int bufferSize) {
         validateBufferSize(bufferSize);
         return OperatorPublish.create(this, bufferSize);
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> reduce(BiFunction<T, T, T> reducer) {
         return scan(reducer).last();
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> reduce(R seed, BiFunction<R, ? super T, R> reducer) {
         return scan(seed, reducer).last();
     }
 
     // Naming note, a plain scan would cause ambiguity with the value-seeded version
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> reduceWith(Supplier<R> seedSupplier, BiFunction<R, ? super T, R> reducer) {
         return scanWith(seedSupplier, reducer).last();
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> repeat() {
         return repeat(Long.MAX_VALUE);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> repeat(long times) {
         if (times < 0) {
             throw new IllegalArgumentException("times >= 0 required but it was " + times);
@@ -1568,6 +2066,8 @@ public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? sup
      * @deprecated use composition
      */
     @Deprecated
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> repeat(long times, Scheduler scheduler) {
         return repeat(times).subscribeOn(scheduler);
     }
@@ -1576,15 +2076,21 @@ public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? sup
      *
      * @deprecated use composition
      */
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     @Deprecated
     public final Observable<T> repeat(Scheduler scheduler) {
         return repeat().subscribeOn(scheduler);
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> repeatUntil(BooleanSupplier stop) {
         return create(new PublisherRepeatUntil<>(this, stop));
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> repeatWhen(Function<? super Observable<Void>, ? extends Publisher<?>> handler) {
         Objects.requireNonNull(handler);
         
@@ -1595,24 +2101,34 @@ public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? sup
         return create(new PublisherRedo<>(this, f));
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final ConnectableObservable<T> replay() {
         return OperatorReplay.createFrom(this);
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Publisher<R>> selector) {
         Objects.requireNonNull(selector);
         return OperatorReplay.multicastSelector(this::replay, selector);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Publisher<R>> selector, final int bufferSize) {
         Objects.requireNonNull(selector);
         return OperatorReplay.multicastSelector(() -> replay(bufferSize), selector);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Publisher<R>> selector, int bufferSize, long time, TimeUnit unit) {
         return replay(selector, bufferSize, time, unit, Schedulers.computation());
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Publisher<R>> selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
         if (bufferSize < 0) {
             throw new IllegalArgumentException("bufferSize < 0");
@@ -1621,32 +2137,46 @@ public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? sup
         return OperatorReplay.multicastSelector(() -> replay(bufferSize, time, unit, scheduler), selector);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final <R> Observable<R> replay(final Function<? super Observable<T>, ? extends Publisher<R>> selector, final int bufferSize, final Scheduler scheduler) {
         return OperatorReplay.multicastSelector(() -> replay(bufferSize), 
                 t -> fromPublisher(selector.apply(t)).observeOn(scheduler));
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Publisher<R>> selector, long time, TimeUnit unit) {
         return replay(selector, time, unit, Schedulers.computation());
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final <R> Observable<R> replay(Function<? super Observable<T>, ? extends Publisher<R>> selector, final long time, final TimeUnit unit, final Scheduler scheduler) {
         return OperatorReplay.multicastSelector(() -> replay(time, unit, scheduler), selector);
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final <R> Observable<R> replay(final Function<? super Observable<T>, ? extends Publisher<R>> selector, final Scheduler scheduler) {
         return OperatorReplay.multicastSelector(() -> replay(), 
                 t -> fromPublisher(selector.apply(t)).observeOn(scheduler));
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final ConnectableObservable<T> replay(final int bufferSize) {
         return OperatorReplay.create(this, bufferSize);
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final ConnectableObservable<T> replay(int bufferSize, long time, TimeUnit unit) {
         return replay(bufferSize, time, unit, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final ConnectableObservable<T> replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
         if (bufferSize < 0) {
             throw new IllegalArgumentException("bufferSize < 0");
@@ -1654,32 +2184,54 @@ public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? sup
         return OperatorReplay.create(this, time, unit, scheduler, bufferSize);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final ConnectableObservable<T> replay(final int bufferSize, final Scheduler scheduler) {
         return OperatorReplay.observeOn(replay(bufferSize), scheduler);
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final ConnectableObservable<T> replay(long time, TimeUnit unit) {
         return replay(time, unit, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final ConnectableObservable<T> replay(final long time, final TimeUnit unit, final Scheduler scheduler) {
         return OperatorReplay.create(this, time, unit, scheduler);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final ConnectableObservable<T> replay(final Scheduler scheduler) {
         Objects.requireNonNull(scheduler);
         return OperatorReplay.observeOn(replay(), scheduler);
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> retry() {
         return retry(Long.MAX_VALUE, e -> true);
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public final Observable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {
+        Objects.requireNonNull(predicate);
+        
+        return create(new PublisherRetryBiPredicate<>(this, predicate));
+    }
+    
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> retry(long times) {
         return retry(times, e -> true);
     }
     
     // Retries at most times or until the predicate returns false, whichever happens first
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> retry(long times, Predicate<? super Throwable> predicate) {
         if (times < 0) {
             throw new IllegalArgumentException("times >= 0 required but it was " + times);
@@ -1689,20 +2241,20 @@ public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? sup
         return create(new PublisherRetryPredicate<>(this, times, predicate));
     }
     
-    public final Observable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {
-        Objects.requireNonNull(predicate);
-        
-        return create(new PublisherRetryBiPredicate<>(this, predicate));
-    }
-    
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> retry(Predicate<? super Throwable> predicate) {
         return retry(Long.MAX_VALUE, predicate);
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> retryUntil(BooleanSupplier stop) {
         return retry(Long.MAX_VALUE, e -> !stop.getAsBoolean());
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> retryWhen(
             Function<? super Observable<? extends Throwable>, ? extends Publisher<?>> handler) {
         Objects.requireNonNull(handler);
@@ -1717,6 +2269,8 @@ public final Disposable forEachWhile(Predicate<? super T> onNext, Consumer<? sup
     }
     
     // TODO decide if safe subscription or unsafe should be the default
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final void safeSubscribe(Subscriber<? super T> s) {
         Objects.requireNonNull(s);
         if (s instanceof SafeSubscriber) {
@@ -1726,55 +2280,77 @@ public final void safeSubscribe(Subscriber<? super T> s) {
         }
     }
     
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<T> sample(long period, TimeUnit unit) {
         return sample(period, unit, Schedulers.computation());
     }
     
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {
         Objects.requireNonNull(unit);
         Objects.requireNonNull(scheduler);
         return lift(new OperatorSampleTimed<>(period, unit, scheduler));
     }
     
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<T> sample(Publisher<U> sampler) {
         Objects.requireNonNull(sampler);
         return lift(new OperatorSamplePublisher<>(sampler));
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> scan(BiFunction<T, T, T> accumulator) {
         Objects.requireNonNull(accumulator);
         return lift(new OperatorScan<>(accumulator));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> scan(R seed, BiFunction<R, ? super T, R> accumulator) {
         Objects.requireNonNull(seed);
         return scanWith(() -> seed, accumulator);
     }
     
     // Naming note, a plain scan would cause ambiguity with the value-seeded version
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> scanWith(Supplier<R> seedSupplier, BiFunction<R, ? super T, R> accumulator) {
         Objects.requireNonNull(seedSupplier);
         Objects.requireNonNull(accumulator);
         return lift(new OperatorScanSeed<>(seedSupplier, accumulator));
     }
     
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> serialize() {
         return lift(s -> new SerializedSubscriber<>(s));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> share() {
         return publish().refCount();
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> single() {
         return lift(OperatorSingle.instanceNoDefault());
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> single(T defaultValue) {
         Objects.requireNonNull(defaultValue);
         return lift(new OperatorSingle<>(defaultValue));
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> skip(long n) {
 //        if (n < 0) {
 //            throw new IllegalArgumentException("n >= 0 required but it was " + n);
@@ -1786,11 +2362,15 @@ public final void safeSubscribe(Subscriber<? super T> s) {
     return lift(new OperatorSkip<>(n));
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> skip(long time, TimeUnit unit, Scheduler scheduler) {
         // TODO consider inlining this behavior
         return skipUntil(timer(time, unit, scheduler));
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> skipLast(int n) {
         if (n < 0) {
             throw new IndexOutOfBoundsException("n >= 0 required but it was " + n);
@@ -1801,22 +2381,32 @@ public final void safeSubscribe(Subscriber<? super T> s) {
         return lift(new OperatorSkipLast<>(n));
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.TRAMPOLINE)
     public final Observable<T> skipLast(long time, TimeUnit unit) {
         return skipLast(time, unit, Schedulers.trampoline(), false, bufferSize());
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.TRAMPOLINE)
     public final Observable<T> skipLast(long time, TimeUnit unit, boolean delayError) {
         return skipLast(time, unit, Schedulers.trampoline(), delayError, bufferSize());
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) {
         return skipLast(time, unit, scheduler, false, bufferSize());
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {
         return skipLast(time, unit, scheduler, delayError, bufferSize());
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {
         Objects.requireNonNull(unit);
         Objects.requireNonNull(scheduler);
@@ -1826,30 +2416,42 @@ public final void safeSubscribe(Subscriber<? super T> s) {
         return lift(new OperatorSkipLastTimed<>(time, unit, scheduler, s, delayError));
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<T> skipUntil(Publisher<? extends U> other) {
         Objects.requireNonNull(other);
         return lift(new OperatorSkipUntil<>(other));
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> skipWhile(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
         return lift(new OperatorSkipWhile<>(predicate));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> startWith(Iterable<? extends T> values) {
         return concatArray(fromIterable(values), this);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> startWith(Publisher<? extends T> other) {
         Objects.requireNonNull(other);
         return concatArray(other, this);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> startWith(T value) {
         Objects.requireNonNull(value);
         return concatArray(just(value), this);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SafeVarargs
     public final Observable<T> startWithArray(T... values) {
         Observable<T> fromArray = fromArray(values);
@@ -1859,23 +2461,33 @@ public final void safeSubscribe(Subscriber<? super T> s) {
         return concatArray(fromArray, this);
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Disposable subscribe() {
         return subscribe(v -> { }, RxJavaPlugins::onError, () -> { }, s -> s.request(Long.MAX_VALUE));
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Disposable subscribe(Consumer<? super T> onNext) {
         return subscribe(onNext, RxJavaPlugins::onError, () -> { }, s -> s.request(Long.MAX_VALUE));
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError) {
         return subscribe(onNext, onError, () -> { }, s -> s.request(Long.MAX_VALUE));
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, 
             Runnable onComplete) {
         return subscribe(onNext, onError, onComplete, s -> s.request(Long.MAX_VALUE));
     }
     
+    @BackpressureSupport(BackpressureKind.SPECIAL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, 
             Runnable onComplete, Consumer<? super Subscription> onSubscribe) {
         Objects.requireNonNull(onNext);
@@ -1891,6 +2503,8 @@ public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super T
     }
 
     // TODO decide if safe subscription or unsafe should be the default
+    @BackpressureSupport(BackpressureKind.SPECIAL)
+    @SchedulerSupport(SchedulerKind.NONE)
     @Override
     public final void subscribe(Subscriber<? super T> s) {
         Objects.requireNonNull(s);
@@ -1920,49 +2534,69 @@ private void subscribeActual(Subscriber<? super T> s) {
         }
     }
     
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> subscribeOn(Scheduler scheduler) {
         return subscribeOn(scheduler, true);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> subscribeOn(Scheduler scheduler, boolean requestOn) {
         Objects.requireNonNull(scheduler);
         return create(new PublisherSubscribeOn<>(this, scheduler, requestOn));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> switchIfEmpty(Publisher<? extends T> other) {
         Objects.requireNonNull(other);
         return lift(new OperatorSwitchIfEmpty<>(other));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {
         return switchMap(mapper, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> Observable<R> switchMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int bufferSize) {
         Objects.requireNonNull(mapper);
         validateBufferSize(bufferSize);
         return lift(new OperatorSwitchMap<>(mapper, bufferSize));
     }
 
+    @BackpressureSupport(BackpressureKind.SPECIAL) // may trigger UNBOUNDED_IN
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> take(long n) {
         if (n < 0) {
             throw new IllegalArgumentException("n >= required but it was " + n);
         } else
         if (n == 0) {
-            return empty();
+         // FIXME may want to subscribe an cancel immediately
+//            return lift(s -> CancelledSubscriber.INSTANCE);
+            return empty(); 
         }
         return lift(new OperatorTake<>(n));
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> take(long time, TimeUnit unit, Scheduler scheduler) {
         // TODO consider inlining this behavior
         return takeUntil(timer(time, unit, scheduler));
     }
     
+    @BackpressureSupport(BackpressureKind.SPECIAL) // may trigger UNBOUNDED_IN
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> takeFirst(Predicate<? super T> predicate) {
         return filter(predicate).take(1);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> takeLast(int n) {
         if (n < 0) {
             throw new IndexOutOfBoundsException("n >= required but it was " + n);
@@ -1976,14 +2610,20 @@ private void subscribeActual(Subscriber<? super T> s) {
         return lift(new OperatorTakeLast<>(n));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.TRAMPOLINE)
     public final Observable<T> takeLast(long count, long time, TimeUnit unit) {
         return takeLast(count, time, unit, Schedulers.trampoline(), false, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler) {
         return takeLast(count, time, unit, scheduler, false, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {
         Objects.requireNonNull(unit);
         Objects.requireNonNull(scheduler);
@@ -1994,123 +2634,182 @@ private void subscribeActual(Subscriber<? super T> s) {
         return lift(new OperatorTakeLastTimed<>(count, time, unit, scheduler, bufferSize, delayError));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.TRAMPOLINE)
     public final Observable<T> takeLast(long time, TimeUnit unit) {
         return takeLast(time, unit, Schedulers.trampoline(), false, bufferSize());
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.TRAMPOLINE)
     public final Observable<T> takeLast(long time, TimeUnit unit, boolean delayError) {
         return takeLast(time, unit, Schedulers.trampoline(), delayError, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler) {
         return takeLast(time, unit, scheduler, false, bufferSize());
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {
         return takeLast(time, unit, scheduler, delayError, bufferSize());
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {
         return takeLast(Long.MAX_VALUE, time, unit, scheduler, delayError, bufferSize);
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<List<T>> takeLastBuffer(int count) {
         return takeLast(count).toList();
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.TRAMPOLINE)
     public final Observable<List<T>> takeLastBuffer(int count, long time, TimeUnit unit) {
         return takeLast(count, time, unit).toList();
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<List<T>> takeLastBuffer(int count, long time, TimeUnit unit, Scheduler scheduler) {
         return takeLast(count, time, unit, scheduler).toList();
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.TRAMPOLINE)
     public final Observable<List<T>> takeLastBuffer(long time, TimeUnit unit) {
         return takeLast(time, unit).toList();
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<List<T>> takeLastBuffer(long time, TimeUnit unit, Scheduler scheduler) {
         return takeLast(time, unit, scheduler).toList();
     }
+    
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> takeUntil(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
         return lift(new OperatorTakeUntilPredicate<>(predicate));
     }
     
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U> Observable<T> takeUntil(Publisher<U> other) {
         Objects.requireNonNull(other);
         return lift(new OperatorTakeUntil<>(other));
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<T> takeWhile(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
         return lift(new OperatorTakeWhile<>(predicate));
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<T> throttleFirst(long windowDuration, TimeUnit unit) {
         return throttleFirst(windowDuration, unit, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) {
         return lift(new OperatorThrottleFirstTimed<T>(skipDuration, unit, scheduler));
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<T> throttleLast(long intervalDuration, TimeUnit unit) {
         return sample(intervalDuration, unit);
     }
     
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {
         return sample(intervalDuration, unit, scheduler);
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit) {
         return debounce(timeout, unit);
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {
         return debounce(timeout, unit, scheduler);
     }
     
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.TRAMPOLINE)
     public final Observable<Timed<T>> timeInterval() {
         return timeInterval(TimeUnit.MILLISECONDS, Schedulers.trampoline());
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<Timed<T>> timeInterval(Scheduler scheduler) {
         return timeInterval(TimeUnit.MILLISECONDS, scheduler);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.TRAMPOLINE)
     public final Observable<Timed<T>> timeInterval(TimeUnit unit) {
         return timeInterval(unit, Schedulers.trampoline());
     }
     
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<Timed<T>> timeInterval(TimeUnit unit, Scheduler scheduler) {
         return lift(new OperatorTimeInterval<>(unit, scheduler));
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <V> Observable<T> timeout(Function<? super T, ? extends Publisher<V>> timeoutSelector) {
         return timeout0(null, timeoutSelector, null);
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <V> Observable<T> timeout(Function<? super T, ? extends Publisher<V>> timeoutSelector, Observable<? extends T> other) {
         Objects.requireNonNull(other);
         return timeout0(null, timeoutSelector, other);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<T> timeout(long timeout, TimeUnit timeUnit) {
         return timeout0(timeout, timeUnit, null, Schedulers.computation());
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<T> timeout(long timeout, TimeUnit timeUnit, Observable<? extends T> other) {
         Objects.requireNonNull(other);
         return timeout0(timeout, timeUnit, other, Schedulers.computation());
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> timeout(long timeout, TimeUnit timeUnit, Observable<? extends T> other, Scheduler scheduler) {
         Objects.requireNonNull(other);
         return timeout0(timeout, timeUnit, other, scheduler);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {
         return timeout0(timeout, timeUnit, null, scheduler);
     }
@@ -2121,6 +2820,8 @@ private void subscribeActual(Subscriber<? super T> s) {
         return timeout0(firstTimeoutSelector, timeoutSelector, null);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, V> Observable<T> timeout(
             Supplier<? extends Publisher<U>> firstTimeoutSelector, 
             Function<? super T, ? extends Publisher<V>> timeoutSelector, 
@@ -2137,7 +2838,7 @@ private void subscribeActual(Subscriber<? super T> s) {
         return lift(new OperatorTimeoutTimed<T>(timeout, timeUnit, scheduler, other));
     }
 
-    public final <U, V> Observable<T> timeout0(
+    private <U, V> Observable<T> timeout0(
             Supplier<? extends Publisher<U>> firstTimeoutSelector, 
             Function<? super T, ? extends Publisher<V>> timeoutSelector, 
                     Publisher<? extends T> other) {
@@ -2145,35 +2846,51 @@ private void subscribeActual(Subscriber<? super T> s) {
         return lift(new OperatorTimeout<T, U, V>(firstTimeoutSelector, timeoutSelector, other));
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.TRAMPOLINE)
     public final Observable<Timed<T>> timestamp() {
         return timestamp(TimeUnit.MILLISECONDS, Schedulers.trampoline());
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<Timed<T>> timestamp(Scheduler scheduler) {
         return timestamp(TimeUnit.MILLISECONDS, scheduler);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.TRAMPOLINE)
     public final Observable<Timed<T>> timestamp(TimeUnit unit) {
         return timestamp(unit, Schedulers.trampoline());
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<Timed<T>> timestamp(TimeUnit unit, Scheduler scheduler) {
         return map(v -> new Timed<>(v, scheduler.now(unit), unit));
     }
 
     // TODO generics
+    @BackpressureSupport(BackpressureKind.SPECIAL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <R> R to(Function<? super Observable<T>, R> converter) {
         return converter.apply(this);
     }
 
+    @BackpressureSupport(BackpressureKind.SPECIAL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final BlockingObservable<T> toBlocking() {
         return BlockingObservable.from(this);
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<List<T>> toList() {
         return lift(OperatorToList.defaultInstance());
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<List<T>> toList(int capacityHint) {
         if (capacityHint <= 0) {
             throw new IllegalArgumentException("capacityHint > 0 required but it was " + capacityHint);
@@ -2181,11 +2898,15 @@ private void subscribeActual(Subscriber<? super T> s) {
         return lift(new OperatorToList<>(() -> new ArrayList<>(capacityHint)));
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U extends Collection<? super T>> Observable<U> toList(Supplier<U> collectionSupplier) {
         Objects.requireNonNull(collectionSupplier);
         return lift(new OperatorToList<>(collectionSupplier));
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K> Observable<Map<K, T>> toMap(Function<? super T, ? extends K> keySelector) {
         return collect(HashMap::new, (m, t) -> {
             K key = keySelector.apply(t);
@@ -2193,6 +2914,8 @@ private void subscribeActual(Subscriber<? super T> s) {
         });
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K, V> Observable<Map<K, V>> toMap(Function<? super T, ? extends K> keySelector, Function<? super T, ? extends V> valueSelector) {
         return collect(HashMap::new, (m, t) -> {
             K key = keySelector.apply(t);
@@ -2201,6 +2924,8 @@ private void subscribeActual(Subscriber<? super T> s) {
         });
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K, V> Observable<Map<K, V>> toMap(Function<? super T, ? extends K> keySelector, 
             Function<? super T, ? extends V> valueSelector,
             Supplier<? extends Map<K, V>> mapSupplier) {
@@ -2211,6 +2936,8 @@ private void subscribeActual(Subscriber<? super T> s) {
         });
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K> Observable<Map<K, Collection<T>>> toMultimap(Function<? super T, ? extends K> keySelector) {
         Function<? super T, ? extends T> valueSelector = v -> v;
         Supplier<Map<K, Collection<T>>> mapSupplier = HashMap::new;
@@ -2218,20 +2945,16 @@ private void subscribeActual(Subscriber<? super T> s) {
         return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <K, V> Observable<Map<K, Collection<V>>> toMultimap(Function<? super T, ? extends K> keySelector, Function<? super T, ? extends V> valueSelector) {
         Supplier<Map<K, Collection<V>>> mapSupplier = HashMap::new;
         Function<K, Collection<V>> collectionFactory = k -> new ArrayList<>();
         return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);
     }
     
-    public final <K, V> Observable<Map<K, Collection<V>>> toMultimap(
-            Function<? super T, ? extends K> keySelector, 
-            Function<? super T, ? extends V> valueSelector,
-            Supplier<Map<K, Collection<V>>> mapSupplier
-            ) {
-        return toMultimap(keySelector, valueSelector, mapSupplier, k -> new ArrayList<>());
-    }
-    
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SuppressWarnings("unchecked")
     public final <K, V> Observable<Map<K, Collection<V>>> toMultimap(
             Function<? super T, ? extends K> keySelector, 
@@ -2253,19 +2976,37 @@ private void subscribeActual(Subscriber<? super T> s) {
         });
     }
     
-    public final Single<T> toSingle() {
-        return Single.fromPublisher(this);
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public final <K, V> Observable<Map<K, Collection<V>>> toMultimap(
+            Function<? super T, ? extends K> keySelector, 
+            Function<? super T, ? extends V> valueSelector,
+            Supplier<Map<K, Collection<V>>> mapSupplier
+            ) {
+        return toMultimap(keySelector, valueSelector, mapSupplier, k -> new ArrayList<>());
     }
     
+    @BackpressureSupport(BackpressureKind.NONE)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final NbpObservable<T> toNbpObservable() {
         return NbpObservable.fromPublisher(this);
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public final Single<T> toSingle() {
+        return Single.fromPublisher(this);
+    }
+    
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SuppressWarnings({ "unchecked", "rawtypes"})
     public final Observable<List<T>> toSortedList() {
         return toSortedList((Comparator)Comparator.naturalOrder());
     }
     
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<List<T>> toSortedList(Comparator<? super T> comparator) {
         Objects.requireNonNull(comparator);
         return toList().map(v -> {
@@ -2274,6 +3015,8 @@ private void subscribeActual(Subscriber<? super T> s) {
         });
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<List<T>> toSortedList(Comparator<? super T> comparator, int capacityHint) {
         Objects.requireNonNull(comparator);
         return toList(capacityHint).map(v -> {
@@ -2282,30 +3025,42 @@ private void subscribeActual(Subscriber<? super T> s) {
         });
     }
 
+    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
+    @SchedulerSupport(SchedulerKind.NONE)
     @SuppressWarnings({ "unchecked", "rawtypes"})
     public final Observable<List<T>> toSortedList(int capacityHint) {
         return toSortedList((Comparator)Comparator.naturalOrder(), capacityHint);
     }
 
+    @BackpressureSupport(BackpressureKind.SPECIAL)
+    @SchedulerSupport(SchedulerKind.NONE)
     // TODO decide if safe subscription or unsafe should be the default
     public final void unsafeSubscribe(Subscriber<? super T> s) {
         Objects.requireNonNull(s);
         subscribeActual(s);
     }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<T> unsubscribeOn(Scheduler scheduler) {
         Objects.requireNonNull(scheduler);
         return lift(new OperatorUnsubscribeOn<>(scheduler));
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<Observable<T>> window(long count) {
         return window(count, count, bufferSize());
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<Observable<T>> window(long count, long skip) {
         return window(count, skip, bufferSize());
     }
     
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final Observable<Observable<T>> window(long count, long skip, int bufferSize) {
         if (skip <= 0) {
             throw new IllegalArgumentException("skip > 0 required but it was " + skip);
@@ -2317,14 +3072,20 @@ public final void unsafeSubscribe(Subscriber<? super T> s) {
         return lift(new OperatorWindow<>(count, skip, bufferSize));
     }
     
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit) {
         return window(timespan, timeskip, unit, Schedulers.computation(), bufferSize());
     }
     
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {
         return window(timespan, timeskip, unit, scheduler, bufferSize());
     }
     
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<Observable<T>> window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {
         validateBufferSize(bufferSize);
         Objects.requireNonNull(scheduler);
@@ -2332,35 +3093,49 @@ public final void unsafeSubscribe(Subscriber<? super T> s) {
         return lift(new OperatorWindowTimed<>(timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false));
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<Observable<T>> window(long timespan, TimeUnit unit) {
         return window(timespan, unit, Schedulers.computation(), Long.MAX_VALUE, false);
     }
     
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<Observable<T>> window(long timespan, TimeUnit unit, 
             long count) {
         return window(timespan, unit, Schedulers.computation(), count, false);
     }
     
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.COMPUTATION)
     public final Observable<Observable<T>> window(long timespan, TimeUnit unit, 
             long count, boolean restart) {
         return window(timespan, unit, Schedulers.computation(), count, restart);
     }
     
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<Observable<T>> window(long timespan, TimeUnit unit, 
             Scheduler scheduler) {
         return window(timespan, unit, scheduler, Long.MAX_VALUE, false);
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<Observable<T>> window(long timespan, TimeUnit unit, 
             Scheduler scheduler, long count) {
         return window(timespan, unit, scheduler, count, false);
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<Observable<T>> window(long timespan, TimeUnit unit, 
             Scheduler scheduler, long count, boolean restart) {
         return window(timespan, unit, scheduler, count, restart, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.CUSTOM)
     public final Observable<Observable<T>> window(
             long timespan, TimeUnit unit, Scheduler scheduler, 
             long count, boolean restart, int bufferSize) {
@@ -2373,34 +3148,48 @@ public final void unsafeSubscribe(Subscriber<? super T> s) {
         return lift(new OperatorWindowTimed<>(timespan, timespan, unit, scheduler, count, bufferSize, restart));
     }
     
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <B> Observable<Observable<T>> window(Publisher<B> boundary) {
         return window(boundary, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <B> Observable<Observable<T>> window(Publisher<B> boundary, int bufferSize) {
         return lift(new OperatorWindowBoundary<>(boundary, bufferSize));
     }
 
-    public final <B> Observable<Observable<T>> window(Supplier<? extends Publisher<B>> boundary) {
-        return window(boundary, bufferSize());
-    }
-
-    public final <B> Observable<Observable<T>> window(Supplier<? extends Publisher<B>> boundary, int bufferSize) {
-        return lift(new OperatorWindowBoundarySupplier<>(boundary, bufferSize));
-    }
-    
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, V> Observable<Observable<T>> window(
             Publisher<U> windowOpen, 
             Function<? super U, ? extends Publisher<V>> windowClose) {
         return window(windowOpen, windowClose, bufferSize());
     }
 
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, V> Observable<Observable<T>> window(
             Publisher<U> windowOpen, 
             Function<? super U, ? extends Publisher<V>> windowClose, int bufferSize) {
         return lift(new OperatorWindowBoundarySelector<>(windowOpen, windowClose, bufferSize));
     }
+    
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public final <B> Observable<Observable<T>> window(Supplier<? extends Publisher<B>> boundary) {
+        return window(boundary, bufferSize());
+    }
+
+    @BackpressureSupport(BackpressureKind.ERROR)
+    @SchedulerSupport(SchedulerKind.NONE)
+    public final <B> Observable<Observable<T>> window(Supplier<? extends Publisher<B>> boundary, int bufferSize) {
+        return lift(new OperatorWindowBoundarySupplier<>(boundary, bufferSize));
+    }
 
+    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, R> Observable<R> withLatestFrom(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> combiner) {
         Objects.requireNonNull(other);
         Objects.requireNonNull(combiner);
@@ -2408,18 +3197,26 @@ public final void unsafeSubscribe(Subscriber<? super T> s) {
         return lift(new OperatorWithLatestFrom<>(combiner, other));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, R> Observable<R> zipWith(Iterable<? extends U> other,  BiFunction<? super T, ? super U, ? extends R> zipper) {
         return create(new PublisherZipIterable<>(this, other, zipper));
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, R> Observable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper) {
         return zip(this, other, zipper);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, R> Observable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError) {
         return zip(this, other, zipper, delayError);
     }
 
+    @BackpressureSupport(BackpressureKind.FULL)
+    @SchedulerSupport(SchedulerKind.NONE)
     public final <U, R> Observable<R> zipWith(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> zipper, boolean delayError, int bufferSize) {
         return zip(this, other, zipper, delayError, bufferSize);
     }
diff --git a/src/main/java/io/reactivex/annotations/BackpressureKind.java b/src/main/java/io/reactivex/annotations/BackpressureKind.java
new file mode 100644
index 0000000000..b56288eddb
--- /dev/null
+++ b/src/main/java/io/reactivex/annotations/BackpressureKind.java
@@ -0,0 +1,47 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.annotations;
+
+/**
+ * Enumeration for various kinds of backpressure support.
+ */
+public enum BackpressureKind {
+    /**
+     * The backpressure-related requests pass through this operator without change
+     */
+    PASS_THROUGH,
+    /**
+     * The operator fully supports backpressure and may coordinate downstream requests
+     * with upstream requests through batching, arbitration or by other means.
+     */
+    FULL,
+    /**
+     * The operator performs special backpressure management; see the associated javadoc.
+     */
+    SPECIAL,
+    /**
+     * The operator requests Long.MAX_VALUE from upstream but respects the backpressure
+     * of the downstream.
+     */
+    UNBOUNDED_IN,
+    /**
+     * The operator will emit a MissingBackpressureException if the downstream didn't request
+     * enough or in time.
+     */
+    ERROR,
+    /**
+     * The operator ignores all kinds of backpressure and may overflow the downstream.
+     */
+    NONE
+}
diff --git a/src/main/java/io/reactivex/annotations/BackpressureSupport.java b/src/main/java/io/reactivex/annotations/BackpressureSupport.java
new file mode 100644
index 0000000000..26d280b7cb
--- /dev/null
+++ b/src/main/java/io/reactivex/annotations/BackpressureSupport.java
@@ -0,0 +1,30 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.annotations;
+
+import java.lang.annotation.*;
+
+/**
+ * Indicates the backpressure support kind of the associated operator or class.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+@Target({ElementType.METHOD, ElementType.TYPE})
+public @interface BackpressureSupport {
+    /**
+     * The backpressure supported by this method or class.
+     * @return backpressure supported by this method or class.
+     */
+    BackpressureKind value();
+}
diff --git a/src/main/java/io/reactivex/annotations/Beta.java b/src/main/java/io/reactivex/annotations/Beta.java
new file mode 100644
index 0000000000..97be083ed9
--- /dev/null
+++ b/src/main/java/io/reactivex/annotations/Beta.java
@@ -0,0 +1,22 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.annotations;
+
+/**
+ * Indicates the feature is in beta state: it will be most likely stay but
+ * the signature may change between versions without warning.
+ */
+public @interface Beta {
+
+}
diff --git a/src/main/java/io/reactivex/annotations/Experimental.java b/src/main/java/io/reactivex/annotations/Experimental.java
new file mode 100644
index 0000000000..43c2d88e97
--- /dev/null
+++ b/src/main/java/io/reactivex/annotations/Experimental.java
@@ -0,0 +1,22 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.annotations;
+
+/**
+ * Indicates the feature is in experimental state: its existence, signature or behavior
+ * might change without warning from one release to the next.
+ */
+public @interface Experimental {
+
+}
diff --git a/src/main/java/io/reactivex/annotations/SchedulerKind.java b/src/main/java/io/reactivex/annotations/SchedulerKind.java
new file mode 100644
index 0000000000..6da76ae9b5
--- /dev/null
+++ b/src/main/java/io/reactivex/annotations/SchedulerKind.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.annotations;
+
+/**
+ * Indicates what scheduler the method or class uses by default
+ */
+public enum SchedulerKind {
+    /**
+     * The operator/class doesn't use schedulers.
+     */
+    NONE,
+    /**
+     * The operator/class runs on the computation scheduler or takes timing information from it.
+     */
+    COMPUTATION,
+    /**
+     * The operator/class runs on the io scheduler or takes timing information from it.
+     */
+    IO,
+    /**
+     * The operator/class runs on the new thread scheduler or takes timing information from it.
+     */
+    NEW_THREAD,
+    /**
+     * The operator/class runs on the trampoline scheduler or takes timing information from it.
+     */
+    TRAMPOLINE,
+    /**
+     * The operator/class runs on the single scheduler or takes timing information from it.
+     */
+    SINGLE,
+    /**
+     * The operator/class requires a scheduler to be manually specified.
+     */
+    CUSTOM
+}
diff --git a/src/main/java/io/reactivex/annotations/SchedulerSupport.java b/src/main/java/io/reactivex/annotations/SchedulerSupport.java
new file mode 100644
index 0000000000..06a085c300
--- /dev/null
+++ b/src/main/java/io/reactivex/annotations/SchedulerSupport.java
@@ -0,0 +1,30 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.annotations;
+
+import java.lang.annotation.*;
+
+/**
+ * Indicates what kind of scheduler the class or method uses.
+ */
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+@Target({ElementType.METHOD, ElementType.TYPE})
+public @interface SchedulerSupport {
+    /**
+     * The kind of scheduler the class or method uses.
+     * @return the kind of scheduler the class or method uses
+     */
+    SchedulerKind value();
+}
diff --git a/src/main/java/io/reactivex/disposables/RefCountDisposable.java b/src/main/java/io/reactivex/disposables/RefCountDisposable.java
index 707ed707ef..863dd1c252 100644
--- a/src/main/java/io/reactivex/disposables/RefCountDisposable.java
+++ b/src/main/java/io/reactivex/disposables/RefCountDisposable.java
@@ -27,14 +27,27 @@
     volatile int count;
     static final AtomicIntegerFieldUpdater<RefCountDisposable> COUNT =
             AtomicIntegerFieldUpdater.newUpdater(RefCountDisposable.class, "count");
-    
+
+    volatile int once;
+    static final AtomicIntegerFieldUpdater<RefCountDisposable> ONCE =
+            AtomicIntegerFieldUpdater.newUpdater(RefCountDisposable.class, "once");
+
     public RefCountDisposable(Disposable resource) {
         Objects.requireNonNull(resource);
         RESOURCE.lazySet(this, resource);
+        COUNT.lazySet(this, 1);
     }
     
     @Override
     public void dispose() {
+        if (ONCE.compareAndSet(this, 0, 1)) {
+            if (COUNT.decrementAndGet(this) == 0) {
+                disposeActual();
+            }
+        }
+    }
+    
+    void disposeActual() {
         Disposable d = resource;
         if (d != DISPOSED) {
             d = RESOURCE.getAndSet(this, DISPOSED);
@@ -51,7 +64,7 @@ public Disposable get() {
     
     void release() {
         if (COUNT.decrementAndGet(this) == 0) {
-            dispose();
+            disposeActual();
         }
     }
     
diff --git a/src/main/java/io/reactivex/internal/disposables/SetCompositeResource.java b/src/main/java/io/reactivex/internal/disposables/SetCompositeResource.java
index d82e76d2ee..fa190a5bb5 100644
--- a/src/main/java/io/reactivex/internal/disposables/SetCompositeResource.java
+++ b/src/main/java/io/reactivex/internal/disposables/SetCompositeResource.java
@@ -16,7 +16,7 @@
 import java.util.function.Consumer;
 
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.util.OpenHashSet;
+import io.reactivex.internal.util.*;
 
 /**
  * A set-based composite resource with custom disposer callback.
@@ -143,7 +143,7 @@ public void dispose() {
                 set = null;
             }
             if (s != null) {
-                s.forEach(disposer);
+                disposeAll(s);
             }
         }
     }
@@ -163,8 +163,14 @@ public void clear() {
                 set = null;
             }
             if (s != null) {
-                s.forEach(disposer);
+                disposeAll(s);
             }
         }
     }
+    void disposeAll(OpenHashSet<T> s) {
+        Throwable ex = s.forEachSuppress(disposer);
+        if (ex != null) {
+            Exceptions.propagate(ex);
+        }
+    }
 }
diff --git a/src/main/java/io/reactivex/internal/util/OpenHashSet.java b/src/main/java/io/reactivex/internal/util/OpenHashSet.java
index 0bcde4ef6b..a318ebdee9 100644
--- a/src/main/java/io/reactivex/internal/util/OpenHashSet.java
+++ b/src/main/java/io/reactivex/internal/util/OpenHashSet.java
@@ -21,6 +21,8 @@
 import java.util.Arrays;
 import java.util.function.Consumer;
 
+import io.reactivex.exceptions.CompositeException;
+
 /**
  * A simple open hash set with add, remove and clear capabilities only.
  * <p>Doesn't support nor checks for {@code null}s.
@@ -191,6 +193,34 @@ public void forEach(Consumer<? super T> consumer) {
             }
         }
     }
+
+    /**
+     * Loops through all values in the set and collects any exceptions from the consumer
+     * into a Throwable.
+     * @param consumer the consumer to call
+     * @return if not null, contains a CompositeException with all the suppressed exceptions
+     */
+    public Throwable forEachSuppress(Consumer<? super T> consumer) {
+        CompositeException ex = null;
+        int count = 0;
+        for (T k : keys) {
+            if (k != null) {
+                try {
+                    consumer.accept(k);
+                } catch (Throwable e) {
+                    if (ex == null) {
+                        ex = new CompositeException();
+                    }
+                    count++;
+                    ex.addSuppressed(e);
+                }
+            }
+        }
+        if (count == 1) {
+            return ex.getSuppressed()[0];
+        }
+        return ex;
+    }
     
     public boolean isEmpty() {
         return size == 0;
diff --git a/src/test/java/io/reactivex/disposables/CompositeDisposableTest.java b/src/test/java/io/reactivex/disposables/CompositeDisposableTest.java
new file mode 100644
index 0000000000..9c8375cd2b
--- /dev/null
+++ b/src/test/java/io/reactivex/disposables/CompositeDisposableTest.java
@@ -0,0 +1,297 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.disposables;
+
+import static org.junit.Assert.*;
+
+import java.util.*;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.Test;
+
+import io.reactivex.exceptions.CompositeException;
+
+public class CompositeDisposableTest {
+
+    @Test
+    public void testSuccess() {
+        final AtomicInteger counter = new AtomicInteger();
+        CompositeDisposable s = new CompositeDisposable();
+        s.add(new Disposable() {
+
+            @Override
+            public void dispose() {
+                counter.incrementAndGet();
+            }
+
+        });
+
+        s.add(new Disposable() {
+
+            @Override
+            public void dispose() {
+                counter.incrementAndGet();
+            }
+        });
+
+        s.dispose();
+
+        assertEquals(2, counter.get());
+    }
+
+    @Test(timeout = 1000)
+    public void shouldUnsubscribeAll() throws InterruptedException {
+        final AtomicInteger counter = new AtomicInteger();
+        final CompositeDisposable s = new CompositeDisposable();
+
+        final int count = 10;
+        final CountDownLatch start = new CountDownLatch(1);
+        for (int i = 0; i < count; i++) {
+            s.add(new Disposable() {
+
+                @Override
+                public void dispose() {
+                    counter.incrementAndGet();
+                }
+            });
+        }
+
+        final List<Thread> threads = new ArrayList<>();
+        for (int i = 0; i < count; i++) {
+            final Thread t = new Thread() {
+                @Override
+                public void run() {
+                    try {
+                        start.await();
+                        s.dispose();
+                    } catch (final InterruptedException e) {
+                        fail(e.getMessage());
+                    }
+                }
+            };
+            t.start();
+            threads.add(t);
+        }
+
+        start.countDown();
+        for (final Thread t : threads) {
+            t.join();
+        }
+
+        assertEquals(count, counter.get());
+    }
+
+    @Test
+    public void testException() {
+        final AtomicInteger counter = new AtomicInteger();
+        CompositeDisposable s = new CompositeDisposable();
+        s.add(new Disposable() {
+
+            @Override
+            public void dispose() {
+                throw new RuntimeException("failed on first one");
+            }
+
+        });
+
+        s.add(new Disposable() {
+
+            @Override
+            public void dispose() {
+                counter.incrementAndGet();
+            }
+
+        });
+
+        try {
+            s.dispose();
+            fail("Expecting an exception");
+        } catch (RuntimeException e) {
+            // we expect this
+            assertEquals(e.getMessage(), "failed on first one");
+        }
+
+        // we should still have disposed to the second one
+        assertEquals(1, counter.get());
+    }
+
+    @Test
+    public void testCompositeException() {
+        final AtomicInteger counter = new AtomicInteger();
+        CompositeDisposable s = new CompositeDisposable();
+        s.add(new Disposable() {
+
+            @Override
+            public void dispose() {
+                throw new RuntimeException("failed on first one");
+            }
+
+        });
+
+        s.add(new Disposable() {
+
+            @Override
+            public void dispose() {
+                throw new RuntimeException("failed on second one too");
+            }
+        });
+
+        s.add(new Disposable() {
+
+            @Override
+            public void dispose() {
+                counter.incrementAndGet();
+            }
+
+        });
+
+        try {
+            s.dispose();
+            fail("Expecting an exception");
+        } catch (CompositeException e) {
+            // we expect this
+            assertEquals(e.getExceptions().size(), 2);
+        }
+
+        // we should still have disposed to the second one
+        assertEquals(1, counter.get());
+    }
+
+    @Test
+    public void testRemoveUnsubscribes() {
+        BooleanDisposable s1 = new BooleanDisposable();
+        BooleanDisposable s2 = new BooleanDisposable();
+
+        CompositeDisposable s = new CompositeDisposable();
+        s.add(s1);
+        s.add(s2);
+
+        s.remove(s1);
+
+        assertTrue(s1.isDisposed());
+        assertFalse(s2.isDisposed());
+    }
+
+    @Test
+    public void testClear() {
+        BooleanDisposable s1 = new BooleanDisposable();
+        BooleanDisposable s2 = new BooleanDisposable();
+
+        CompositeDisposable s = new CompositeDisposable();
+        s.add(s1);
+        s.add(s2);
+
+        assertFalse(s1.isDisposed());
+        assertFalse(s2.isDisposed());
+
+        s.clear();
+
+        assertTrue(s1.isDisposed());
+        assertTrue(s2.isDisposed());
+        assertFalse(s.isDisposed());
+
+        BooleanDisposable s3 = new BooleanDisposable();
+
+        s.add(s3);
+        s.dispose();
+
+        assertTrue(s3.isDisposed());
+        assertTrue(s.isDisposed());
+    }
+
+    @Test
+    public void testUnsubscribeIdempotence() {
+        final AtomicInteger counter = new AtomicInteger();
+        CompositeDisposable s = new CompositeDisposable();
+        s.add(new Disposable() {
+
+            @Override
+            public void dispose() {
+                counter.incrementAndGet();
+            }
+
+        });
+
+        s.dispose();
+        s.dispose();
+        s.dispose();
+
+        // we should have only disposed once
+        assertEquals(1, counter.get());
+    }
+
+    @Test(timeout = 1000)
+    public void testUnsubscribeIdempotenceConcurrently()
+            throws InterruptedException {
+        final AtomicInteger counter = new AtomicInteger();
+        final CompositeDisposable s = new CompositeDisposable();
+
+        final int count = 10;
+        final CountDownLatch start = new CountDownLatch(1);
+        s.add(new Disposable() {
+
+            @Override
+            public void dispose() {
+                counter.incrementAndGet();
+            }
+
+        });
+
+        final List<Thread> threads = new ArrayList<>();
+        for (int i = 0; i < count; i++) {
+            final Thread t = new Thread() {
+                @Override
+                public void run() {
+                    try {
+                        start.await();
+                        s.dispose();
+                    } catch (final InterruptedException e) {
+                        fail(e.getMessage());
+                    }
+                }
+            };
+            t.start();
+            threads.add(t);
+        }
+
+        start.countDown();
+        for (final Thread t : threads) {
+            t.join();
+        }
+
+        // we should have only disposed once
+        assertEquals(1, counter.get());
+    }
+    @Test
+    public void testTryRemoveIfNotIn() {
+        CompositeDisposable csub = new CompositeDisposable();
+        
+        CompositeDisposable csub1 = new CompositeDisposable();
+        CompositeDisposable csub2 = new CompositeDisposable();
+        
+        csub.add(csub1);
+        csub.remove(csub1);
+        csub.add(csub2);
+        
+        csub.remove(csub1); // try removing agian
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void testAddingNullDisposableIllegal() {
+        CompositeDisposable csub = new CompositeDisposable();
+        csub.add(null);
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/disposables/DisposablesTest.java b/src/test/java/io/reactivex/disposables/DisposablesTest.java
new file mode 100644
index 0000000000..2572d2a43a
--- /dev/null
+++ b/src/test/java/io/reactivex/disposables/DisposablesTest.java
@@ -0,0 +1,48 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.disposables;
+
+import static org.mockito.Mockito.*;
+
+import org.junit.Test;
+
+
+public class DisposablesTest {
+
+    @Test
+    public void testUnsubscribeOnlyOnce() {
+        Runnable dispose = mock(Runnable.class);
+        Disposable subscription = Disposables.from(dispose);
+        subscription.dispose();
+        subscription.dispose();
+        verify(dispose, times(1)).run();
+    }
+
+    @Test
+    public void testEmpty() {
+        Disposable empty = Disposables.empty();
+        // FIXME not assertable
+//        assertFalse(empty.isUnsubscribed());
+        empty.dispose();
+        // FIXME not assertable
+//        assertTrue(empty.isUnsubscribed());
+    }
+
+    @Test
+    public void testUnsubscribed() {
+        // FIXME not assertable
+        /*Disposable disposed = */Disposables.disposed();
+//        assertTrue(disposed.isUnsubscribed());
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/disposables/MultipleAssignmentDisposableTest.java b/src/test/java/io/reactivex/disposables/MultipleAssignmentDisposableTest.java
new file mode 100644
index 0000000000..6962d57ec8
--- /dev/null
+++ b/src/test/java/io/reactivex/disposables/MultipleAssignmentDisposableTest.java
@@ -0,0 +1,72 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.disposables;
+
+import static org.mockito.Mockito.*;
+
+import org.junit.*;
+
+public class MultipleAssignmentDisposableTest {
+
+    Runnable dispose;
+    Disposable s;
+
+    @Before
+    public void before() {
+        dispose = mock(Runnable.class);
+        s = Disposables.from(dispose);
+    }
+
+    @Test
+    public void testNoUnsubscribeWhenReplaced() {
+        MultipleAssignmentDisposable mas = new MultipleAssignmentDisposable();
+
+        mas.set(s);
+        mas.set(Disposables.empty());
+        mas.dispose();
+
+        verify(dispose, never()).run();
+    }
+
+    @Test
+    public void testUnsubscribeWhenParentUnsubscribes() {
+        MultipleAssignmentDisposable mas = new MultipleAssignmentDisposable();
+        mas.set(s);
+        mas.dispose();
+        mas.dispose();
+
+        verify(dispose, times(1)).run();
+
+        Assert.assertEquals(true, mas.isDisposed());
+    }
+
+    @Test
+    public void subscribingWhenUnsubscribedCausesImmediateUnsubscription() {
+        MultipleAssignmentDisposable mas = new MultipleAssignmentDisposable();
+        mas.dispose();
+        Disposable underlying = mock(Disposable.class);
+        mas.set(underlying);
+        verify(underlying).dispose();
+    }
+
+    @Test
+    public void testDisposableRemainsAfterUnsubscribe() {
+        MultipleAssignmentDisposable mas = new MultipleAssignmentDisposable();
+
+        mas.set(s);
+        mas.dispose();
+        // FIXME MultipleAssignmentDisposable no longer retains the reference after diposing
+        Assert.assertNotSame(s, mas.get());
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/disposables/RefCountDisposableTest.java b/src/test/java/io/reactivex/disposables/RefCountDisposableTest.java
new file mode 100644
index 0000000000..1c59a1da25
--- /dev/null
+++ b/src/test/java/io/reactivex/disposables/RefCountDisposableTest.java
@@ -0,0 +1,112 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.disposables;
+
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.InOrder;
+
+public class RefCountDisposableTest {
+    Runnable main;
+    RefCountDisposable rcs;
+
+    @Before
+    public void before() {
+        main = mock(Runnable.class);
+        rcs = new RefCountDisposable(Disposables.from(main));
+    }
+
+    @Test
+    public void testImmediateUnsubscribe() {
+        InOrder inOrder = inOrder(main);
+
+        rcs.dispose();
+
+        inOrder.verify(main, times(1)).run();
+
+        rcs.dispose();
+
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testRCSUnsubscribeBeforeClient() {
+        InOrder inOrder = inOrder(main);
+
+        Disposable s = rcs.get();
+
+        rcs.dispose();
+
+        inOrder.verify(main, never()).run();
+
+        s.dispose();
+
+        inOrder.verify(main, times(1)).run();
+
+        rcs.dispose();
+        s.dispose();
+
+        inOrder.verifyNoMoreInteractions();
+
+    }
+
+    @Test
+    public void testMultipleClientsUnsubscribeFirst() {
+        InOrder inOrder = inOrder(main);
+
+        Disposable s1 = rcs.get();
+        Disposable s2 = rcs.get();
+
+        s1.dispose();
+        inOrder.verify(main, never()).run();
+        s2.dispose();
+        inOrder.verify(main, never()).run();
+
+        rcs.dispose();
+        inOrder.verify(main, times(1)).run();
+
+        s1.dispose();
+        s2.dispose();
+        rcs.dispose();
+
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testMultipleClientsMainUnsubscribeFirst() {
+        InOrder inOrder = inOrder(main);
+
+        Disposable s1 = rcs.get();
+        Disposable s2 = rcs.get();
+
+        rcs.dispose();
+        inOrder.verify(main, never()).run();
+        s1.dispose();
+        inOrder.verify(main, never()).run();
+        s2.dispose();
+
+        inOrder.verify(main, times(1)).run();
+
+        s1.dispose();
+        s2.dispose();
+        rcs.dispose();
+
+        inOrder.verifyNoMoreInteractions();
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/disposables/SerialDisposableTests.java b/src/test/java/io/reactivex/disposables/SerialDisposableTests.java
new file mode 100644
index 0000000000..7b25c53d55
--- /dev/null
+++ b/src/test/java/io/reactivex/disposables/SerialDisposableTests.java
@@ -0,0 +1,192 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.disposables;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+import java.util.*;
+import java.util.concurrent.CountDownLatch;
+
+import org.junit.*;
+import org.junit.runner.RunWith;
+import org.mockito.runners.MockitoJUnitRunner;
+
+@RunWith(MockitoJUnitRunner.class)
+public class SerialDisposableTests {
+    private SerialDisposable serialDisposable;
+
+    @Before
+    public void setUp() {
+        serialDisposable = new SerialDisposable();
+    }
+
+    @Test
+    public void unsubscribingWithoutUnderlyingDoesNothing() {
+        serialDisposable.dispose();
+    }
+
+    @Test
+    public void getDisposableShouldReturnset() {
+        final Disposable underlying = mock(Disposable.class);
+        serialDisposable.set(underlying);
+        assertSame(underlying, serialDisposable.get());
+
+        final Disposable another = mock(Disposable.class);
+        serialDisposable.set(another);
+        assertSame(another, serialDisposable.get());
+    }
+
+    @Test
+    public void unsubscribingTwiceDoesUnsubscribeOnce() {
+        Disposable underlying = mock(Disposable.class);
+        serialDisposable.set(underlying);
+
+        serialDisposable.dispose();
+        verify(underlying).dispose();
+
+        serialDisposable.dispose();
+        verifyNoMoreInteractions(underlying);
+    }
+
+    @Test
+    public void settingSameDisposableTwiceDoesUnsubscribeIt() {
+        Disposable underlying = mock(Disposable.class);
+        serialDisposable.set(underlying);
+        verifyZeroInteractions(underlying);
+        serialDisposable.set(underlying);
+        verify(underlying).dispose();
+    }
+
+    @Test
+    public void unsubscribingWithSingleUnderlyingUnsubscribes() {
+        Disposable underlying = mock(Disposable.class);
+        serialDisposable.set(underlying);
+        underlying.dispose();
+        verify(underlying).dispose();
+    }
+
+    @Test
+    public void replacingFirstUnderlyingCausesUnsubscription() {
+        Disposable first = mock(Disposable.class);
+        serialDisposable.set(first);
+        Disposable second = mock(Disposable.class);
+        serialDisposable.set(second);
+        verify(first).dispose();
+    }
+
+    @Test
+    public void whenUnsubscribingSecondUnderlyingUnsubscribed() {
+        Disposable first = mock(Disposable.class);
+        serialDisposable.set(first);
+        Disposable second = mock(Disposable.class);
+        serialDisposable.set(second);
+        serialDisposable.dispose();
+        verify(second).dispose();
+    }
+
+    @Test
+    public void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscription() {
+        serialDisposable.dispose();
+        Disposable underlying = mock(Disposable.class);
+        serialDisposable.set(underlying);
+        verify(underlying).dispose();
+    }
+
+    @Test(timeout = 1000)
+    public void settingUnderlyingWhenUnsubscribedCausesImmediateUnsubscriptionConcurrently()
+            throws InterruptedException {
+        final Disposable firstSet = mock(Disposable.class);
+        serialDisposable.set(firstSet);
+
+        final CountDownLatch start = new CountDownLatch(1);
+
+        final int count = 10;
+        final CountDownLatch end = new CountDownLatch(count);
+
+        final List<Thread> threads = new ArrayList<>();
+        for (int i = 0; i < count; i++) {
+            final Thread t = new Thread() {
+                @Override
+                public void run() {
+                    try {
+                        start.await();
+                        serialDisposable.dispose();
+                    } catch (InterruptedException e) {
+                        fail(e.getMessage());
+                    } finally {
+                        end.countDown();
+                    }
+                }
+            };
+            t.start();
+            threads.add(t);
+        }
+
+        final Disposable underlying = mock(Disposable.class);
+        start.countDown();
+        serialDisposable.set(underlying);
+        end.await();
+        verify(firstSet).dispose();
+        verify(underlying).dispose();
+
+        for (final Thread t : threads) {
+            t.join();
+        }
+    }
+
+    @Test
+    public void concurrentSetDisposableShouldNotInterleave()
+            throws InterruptedException {
+        final int count = 10;
+        final List<Disposable> subscriptions = new ArrayList<>();
+
+        final CountDownLatch start = new CountDownLatch(1);
+        final CountDownLatch end = new CountDownLatch(count);
+
+        final List<Thread> threads = new ArrayList<>();
+        for (int i = 0; i < count; i++) {
+            final Disposable subscription = mock(Disposable.class);
+            subscriptions.add(subscription);
+
+            final Thread t = new Thread() {
+                @Override
+                public void run() {
+                    try {
+                        start.await();
+                        serialDisposable.set(subscription);
+                    } catch (InterruptedException e) {
+                        fail(e.getMessage());
+                    } finally {
+                        end.countDown();
+                    }
+                }
+            };
+            t.start();
+            threads.add(t);
+        }
+
+        start.countDown();
+        end.await();
+        serialDisposable.dispose();
+
+        for (final Disposable subscription : subscriptions) {
+            verify(subscription).dispose();
+        }
+
+        for (final Thread t : threads) {
+            t.join();
+        }
+    }
+}
\ No newline at end of file
