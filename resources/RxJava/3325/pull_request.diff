diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java
index 058c8ab8a2..5f2cfabd8d 100644
--- a/src/main/java/io/reactivex/Observable.java
+++ b/src/main/java/io/reactivex/Observable.java
@@ -1948,9 +1948,9 @@ private void subscribeActual(Subscriber<? super T> s) {
         if (n < 0) {
             throw new IllegalArgumentException("n >= required but it was " + n);
         } else
-            if (n == 0) {
-                return empty();
-            }
+        if (n == 0) {
+            return empty();
+        }
         return lift(new OperatorTake<>(n));
     }
 
@@ -1965,7 +1965,7 @@ private void subscribeActual(Subscriber<? super T> s) {
 
     public final Observable<T> takeLast(int n) {
         if (n < 0) {
-            throw new IllegalArgumentException("n >= required but it was " + n);
+            throw new IndexOutOfBoundsException("n >= required but it was " + n);
         } else
         if (n == 0) {
             return ignoreElements();
@@ -1989,7 +1989,7 @@ private void subscribeActual(Subscriber<? super T> s) {
         Objects.requireNonNull(scheduler);
         validateBufferSize(bufferSize);
         if (count < 0) {
-            throw new IllegalArgumentException("count >= 0 required but it was " + count);
+            throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);
         }
         return lift(new OperatorTakeLastTimed<>(count, time, unit, scheduler, bufferSize, delayError));
     }
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java b/src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java
index 35bc0a2188..e423e5b836 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java
@@ -19,6 +19,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.Observable.Operator;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
@@ -92,11 +93,11 @@ public void onComplete() {
         
         @Override
         public void request(long n) {
-            if (n <= 0) {
-                RxJavaPlugins.onError(new IllegalArgumentException("n > 0 required but it was " + n));
+            if (SubscriptionHelper.validateRequest(n)) {
                 return;
             }
             BackpressureHelper.add(REQUESTED, this, n);
+            drain();
         }
         
         @Override
diff --git a/src/main/java/io/reactivex/internal/operators/OperatorTakeLastTimed.java b/src/main/java/io/reactivex/internal/operators/OperatorTakeLastTimed.java
index f3665d6680..63b0d71138 100644
--- a/src/main/java/io/reactivex/internal/operators/OperatorTakeLastTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLastTimed.java
@@ -191,6 +191,10 @@ void drain() {
                             return;
                         }
                         
+                        if ((Long)ts < scheduler.now(unit) - time) {
+                            continue;
+                        }
+                        
                         a.onNext(o);
                         
                         r--;
@@ -204,7 +208,7 @@ void drain() {
                     }
                 }
                 
-                missed = getAndSet(-missed);
+                missed = addAndGet(-missed);
                 if (missed == 0) {
                     break;
                 }
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorMergeTest.java b/src/test/java/io/reactivex/internal/operators/OperatorMergeTest.java
index 543342d8df..ec8adf3954 100644
--- a/src/test/java/io/reactivex/internal/operators/OperatorMergeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/OperatorMergeTest.java
@@ -208,6 +208,14 @@ public void testMergeArrayWithThreading() {
         verify(stringObserver, times(1)).onComplete();
     }
 
+    @Test
+    public void testSynchronizationOfMultipleSequencesLoop() throws Throwable {
+        for (int i = 0; i < 100; i++) {
+            System.out.println("testSynchronizationOfMultipleSequencesLoop > " + i);
+            testSynchronizationOfMultipleSequences();
+        }
+    }
+    
     @Test
     public void testSynchronizationOfMultipleSequences() throws Throwable {
         final TestASynchronousObservable o1 = new TestASynchronousObservable();
@@ -237,8 +245,11 @@ public void onNext(String v) {
                 totalCounter.incrementAndGet();
                 concurrentCounter.incrementAndGet();
                 try {
-                    // wait here until we're done asserting
-                    endLatch.await();
+                    // avoid deadlocking the main thread
+                    if (Thread.currentThread().getName().equals("TestASynchronousObservable")) {
+                        // wait here until we're done asserting
+                        endLatch.await();
+                    }
                 } catch (InterruptedException e) {
                     e.printStackTrace();
                     throw new RuntimeException("failed", e);
@@ -380,7 +391,7 @@ public void run() {
                     }
                 }
 
-            });
+            }, "TestASynchronousObservable");
             t.start();
         }
     }
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorTakeLastOneTest.java b/src/test/java/io/reactivex/internal/operators/OperatorTakeLastOneTest.java
new file mode 100644
index 0000000000..dde6930ccf
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorTakeLastOneTest.java
@@ -0,0 +1,137 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.junit.Assert.*;
+
+import java.util.*;
+import java.util.concurrent.atomic.*;
+import java.util.function.Consumer;
+
+import org.junit.Test;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class OperatorTakeLastOneTest {
+
+    @Test
+    public void testLastOfManyReturnsLast() {
+        TestSubscriber<Integer> s = new TestSubscriber<>();
+        Observable.range(1, 10).takeLast(1).subscribe(s);
+        s.assertValue(10);
+        s.assertNoErrors();
+        s.assertTerminated();
+        // NO longer assertable
+//        s.assertUnsubscribed();
+    }
+
+    @Test
+    public void testLastOfEmptyReturnsEmpty() {
+        TestSubscriber<Object> s = new TestSubscriber<>();
+        Observable.empty().takeLast(1).subscribe(s);
+        s.assertNoValues();
+        s.assertNoErrors();
+        s.assertTerminated();
+        // NO longer assertable
+//      s.assertUnsubscribed();
+    }
+
+    @Test
+    public void testLastOfOneReturnsLast() {
+        TestSubscriber<Integer> s = new TestSubscriber<>();
+        Observable.just(1).takeLast(1).subscribe(s);
+        s.assertValue(1);
+        s.assertNoErrors();
+        s.assertTerminated();
+        // NO longer assertable
+//      s.assertUnsubscribed();
+    }
+
+    @Test
+    public void testUnsubscribesFromUpstream() {
+        final AtomicBoolean unsubscribed = new AtomicBoolean(false);
+        Runnable unsubscribeAction = new Runnable() {
+            @Override
+            public void run() {
+                unsubscribed.set(true);
+            }
+        };
+        Observable.just(1).doOnCancel(unsubscribeAction)
+                .takeLast(1).subscribe();
+        assertTrue(unsubscribed.get());
+    }
+
+    @Test
+    public void testLastWithBackpressure() {
+        MySubscriber<Integer> s = new MySubscriber<>(0);
+        Observable.just(1).takeLast(1).subscribe(s);
+        assertEquals(0, s.list.size());
+        s.requestMore(1);
+        assertEquals(1, s.list.size());
+    }
+    
+    @Test
+    public void testTakeLastZeroProcessesAllItemsButIgnoresThem() {
+        final AtomicInteger upstreamCount = new AtomicInteger();
+        final int num = 10;
+        long count = Observable.range(1,num).doOnNext(new Consumer<Integer>() {
+
+            @Override
+            public void accept(Integer t) {
+                upstreamCount.incrementAndGet();
+            }})
+            .takeLast(0).count().toBlocking().single();
+        assertEquals(num, upstreamCount.get());
+        assertEquals(0L, count);
+    }
+    
+    private static class MySubscriber<T> extends Observer<T> {
+
+        private long initialRequest;
+
+        MySubscriber(long initialRequest) {
+            this.initialRequest = initialRequest;
+        }
+
+        final List<T> list = new ArrayList<>();
+
+        public void requestMore(long n) {
+            request(n);
+        }
+
+        @Override
+        public void onStart() {
+            request(initialRequest);
+        }
+
+        @Override
+        public void onComplete() {
+
+        }
+
+        @Override
+        public void onError(Throwable e) {
+
+        }
+
+        @Override
+        public void onNext(T t) {
+            list.add(t);
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorTakeLastTest.java b/src/test/java/io/reactivex/internal/operators/OperatorTakeLastTest.java
new file mode 100644
index 0000000000..5878556eff
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorTakeLastTest.java
@@ -0,0 +1,316 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
+
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Function;
+
+import org.junit.*;
+import org.mockito.InOrder;
+import org.reactivestreams.Subscriber;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.TestHelper;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class OperatorTakeLastTest {
+
+    @Test
+    public void testTakeLastEmpty() {
+        Observable<String> w = Observable.empty();
+        Observable<String> take = w.takeLast(2);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        take.subscribe(observer);
+        verify(observer, never()).onNext(any(String.class));
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testTakeLast1() {
+        Observable<String> w = Observable.just("one", "two", "three");
+        Observable<String> take = w.takeLast(2);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        InOrder inOrder = inOrder(observer);
+        take.subscribe(observer);
+        inOrder.verify(observer, times(1)).onNext("two");
+        inOrder.verify(observer, times(1)).onNext("three");
+        verify(observer, never()).onNext("one");
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testTakeLast2() {
+        Observable<String> w = Observable.just("one");
+        Observable<String> take = w.takeLast(10);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        take.subscribe(observer);
+        verify(observer, times(1)).onNext("one");
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testTakeLastWithZeroCount() {
+        Observable<String> w = Observable.just("one");
+        Observable<String> take = w.takeLast(0);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        take.subscribe(observer);
+        verify(observer, never()).onNext("one");
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    @Ignore("Null values no longer allowed")
+    public void testTakeLastWithNull() {
+        Observable<String> w = Observable.just("one", null, "three");
+        Observable<String> take = w.takeLast(2);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        take.subscribe(observer);
+        verify(observer, never()).onNext("one");
+        verify(observer, times(1)).onNext(null);
+        verify(observer, times(1)).onNext("three");
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test(expected = IndexOutOfBoundsException.class)
+    public void testTakeLastWithNegativeCount() {
+        Observable.just("one").takeLast(-1);
+    }
+
+    @Test
+    public void testBackpressure1() {
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        Observable.range(1, 100000).takeLast(1)
+        .observeOn(Schedulers.newThread())
+        .map(newSlowProcessor()).subscribe(ts);
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        ts.assertValue(100000);
+    }
+
+    @Test
+    public void testBackpressure2() {
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        Observable.range(1, 100000).takeLast(Observable.bufferSize() * 4)
+        .observeOn(Schedulers.newThread()).map(newSlowProcessor()).subscribe(ts);
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        assertEquals(Observable.bufferSize() * 4, ts.valueCount());
+    }
+
+    private Function<Integer, Integer> newSlowProcessor() {
+        return new Function<Integer, Integer>() {
+            int c = 0;
+
+            @Override
+            public Integer apply(Integer i) {
+                if (c++ < 100) {
+                    try {
+                        Thread.sleep(1);
+                    } catch (InterruptedException e) {
+                    }
+                }
+                return i;
+            }
+
+        };
+    }
+
+    @Test
+    public void testIssue1522() {
+        // https://github.com/ReactiveX/RxJava/issues/1522
+        assertEquals(0, Observable
+                .empty()
+                .count()
+                .filter(v -> false)
+                .toList()
+                .toBlocking().single().size());
+    }
+
+    @Test
+    public void testIgnoreRequest1() {
+        // If `takeLast` does not ignore `request` properly, StackOverflowError will be thrown.
+        Observable.range(0, 100000).takeLast(100000).subscribe(new Observer<Integer>() {
+
+            @Override
+            public void onStart() {
+                request(Long.MAX_VALUE);
+            }
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+            }
+
+            @Override
+            public void onNext(Integer integer) {
+                request(Long.MAX_VALUE);
+            }
+        });
+    }
+
+    @Test
+    public void testIgnoreRequest2() {
+        // If `takeLast` does not ignore `request` properly, StackOverflowError will be thrown.
+        Observable.range(0, 100000).takeLast(100000).subscribe(new Observer<Integer>() {
+
+            @Override
+            public void onStart() {
+                request(1);
+            }
+
+            @Override
+            public void onComplete() {
+            }
+
+            @Override
+            public void onError(Throwable e) {
+            }
+
+            @Override
+            public void onNext(Integer integer) {
+                request(1);
+            }
+        });
+    }
+
+    @Test(timeout = 30000)
+    public void testIgnoreRequest3() {
+        // If `takeLast` does not ignore `request` properly, it will enter an infinite loop.
+        Observable.range(0, 100000).takeLast(100000).subscribe(new Observer<Integer>() {
+
+            @Override
+            public void onStart() {
+                request(1);
+            }
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+            }
+
+            @Override
+            public void onNext(Integer integer) {
+                request(Long.MAX_VALUE);
+            }
+        });
+    }
+
+
+    @Test
+    public void testIgnoreRequest4() {
+        // If `takeLast` does not ignore `request` properly, StackOverflowError will be thrown.
+        Observable.range(0, 100000).takeLast(100000).subscribe(new Observer<Integer>() {
+
+            @Override
+            public void onStart() {
+                request(Long.MAX_VALUE);
+            }
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+            }
+
+            @Override
+            public void onNext(Integer integer) {
+                request(1);
+            }
+        });
+    }
+    
+    @Test
+    public void testUnsubscribeTakesEffectEarlyOnFastPath() {
+        final AtomicInteger count = new AtomicInteger();
+        Observable.range(0, 100000).takeLast(100000).subscribe(new Observer<Integer>() {
+
+            @Override
+            public void onStart() {
+                request(Long.MAX_VALUE);
+            }
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+            }
+
+            @Override
+            public void onNext(Integer integer) {
+                count.incrementAndGet();
+                cancel();
+            }
+        });
+        assertEquals(1,count.get());
+    }
+    
+    @Test(timeout=10000)
+    public void testRequestOverflow() {
+        final List<Integer> list = new ArrayList<>();
+        Observable.range(1, 100).takeLast(50).subscribe(new Observer<Integer>() {
+
+            @Override
+            public void onStart() {
+                request(2);
+            }
+            
+            @Override
+            public void onComplete() {
+                
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                
+            }
+
+            @Override
+            public void onNext(Integer t) {
+                list.add(t);
+                request(Long.MAX_VALUE-1);
+            }});
+        assertEquals(50, list.size());
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorTakeLastTimedTest.java b/src/test/java/io/reactivex/internal/operators/OperatorTakeLastTimedTest.java
new file mode 100644
index 0000000000..e72b6bc95c
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorTakeLastTimedTest.java
@@ -0,0 +1,203 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
+
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Test;
+import org.mockito.InOrder;
+import org.reactivestreams.Subscriber;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.subjects.PublishSubject;
+
+public class OperatorTakeLastTimedTest {
+
+    @Test(expected = IndexOutOfBoundsException.class)
+    public void testTakeLastTimedWithNegativeCount() {
+        Observable.just("one").takeLast(-1, 1, TimeUnit.SECONDS);
+    }
+
+    @Test
+    public void takeLastTimed() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishSubject<Object> source = PublishSubject.create();
+
+        // FIXME time unit now matters!
+        Observable<Object> result = source.takeLast(1000, TimeUnit.MILLISECONDS, scheduler);
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+
+        InOrder inOrder = inOrder(o);
+
+        result.subscribe(o);
+
+        source.onNext(1); // T: 0ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(2); // T: 250ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(3); // T: 500ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(4); // T: 750ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(5); // T: 1000ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onComplete(); // T: 1250ms
+
+        inOrder.verify(o, times(1)).onNext(2);
+        inOrder.verify(o, times(1)).onNext(3);
+        inOrder.verify(o, times(1)).onNext(4);
+        inOrder.verify(o, times(1)).onNext(5);
+        inOrder.verify(o, times(1)).onComplete();
+
+        verify(o, never()).onError(any(Throwable.class));
+    }
+
+    @Test
+    public void takeLastTimedDelayCompletion() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishSubject<Object> source = PublishSubject.create();
+
+        // FIXME time unit now matters
+        Observable<Object> result = source.takeLast(1000, TimeUnit.MILLISECONDS, scheduler);
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+
+        InOrder inOrder = inOrder(o);
+
+        result.subscribe(o);
+
+        source.onNext(1); // T: 0ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(2); // T: 250ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(3); // T: 500ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(4); // T: 750ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(5); // T: 1000ms
+        scheduler.advanceTimeBy(1250, TimeUnit.MILLISECONDS);
+        source.onComplete(); // T: 2250ms
+
+        inOrder.verify(o, times(1)).onComplete();
+
+        verify(o, never()).onNext(any());
+        verify(o, never()).onError(any(Throwable.class));
+    }
+
+    @Test
+    public void takeLastTimedWithCapacity() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishSubject<Object> source = PublishSubject.create();
+
+        // FIXME time unit now matters!
+        Observable<Object> result = source.takeLast(2, 1000, TimeUnit.MILLISECONDS, scheduler);
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+
+        InOrder inOrder = inOrder(o);
+
+        result.subscribe(o);
+
+        source.onNext(1); // T: 0ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(2); // T: 250ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(3); // T: 500ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(4); // T: 750ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(5); // T: 1000ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onComplete(); // T: 1250ms
+
+        inOrder.verify(o, times(1)).onNext(4);
+        inOrder.verify(o, times(1)).onNext(5);
+        inOrder.verify(o, times(1)).onComplete();
+
+        verify(o, never()).onError(any(Throwable.class));
+    }
+
+    @Test
+    public void takeLastTimedThrowingSource() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishSubject<Object> source = PublishSubject.create();
+
+        Observable<Object> result = source.takeLast(1, TimeUnit.SECONDS, scheduler);
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+
+        InOrder inOrder = inOrder(o);
+
+        result.subscribe(o);
+
+        source.onNext(1); // T: 0ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(2); // T: 250ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(3); // T: 500ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(4); // T: 750ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(5); // T: 1000ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onError(new TestException()); // T: 1250ms
+
+        inOrder.verify(o, times(1)).onError(any(TestException.class));
+
+        verify(o, never()).onNext(any());
+        verify(o, never()).onComplete();
+    }
+
+    @Test
+    public void takeLastTimedWithZeroCapacity() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishSubject<Object> source = PublishSubject.create();
+
+        Observable<Object> result = source.takeLast(0, 1, TimeUnit.SECONDS, scheduler);
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+
+        InOrder inOrder = inOrder(o);
+
+        result.subscribe(o);
+
+        source.onNext(1); // T: 0ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(2); // T: 250ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(3); // T: 500ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(4); // T: 750ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onNext(5); // T: 1000ms
+        scheduler.advanceTimeBy(250, TimeUnit.MILLISECONDS);
+        source.onComplete(); // T: 1250ms
+
+        inOrder.verify(o, times(1)).onComplete();
+
+        verify(o, never()).onNext(any());
+        verify(o, never()).onError(any(Throwable.class));
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorTakeTest.java b/src/test/java/io/reactivex/internal/operators/OperatorTakeTest.java
new file mode 100644
index 0000000000..1de2f8b290
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorTakeTest.java
@@ -0,0 +1,423 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.*;
+import static org.mockito.Mockito.*;
+
+import java.util.Arrays;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+import java.util.function.*;
+
+import org.junit.*;
+import org.mockito.InOrder;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.subscriptions.*;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class OperatorTakeTest {
+
+    @Test
+    public void testTake1() {
+        Observable<String> w = Observable.fromIterable(Arrays.asList("one", "two", "three"));
+        Observable<String> take = w.take(2);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        take.subscribe(observer);
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onNext("two");
+        verify(observer, never()).onNext("three");
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testTake2() {
+        Observable<String> w = Observable.fromIterable(Arrays.asList("one", "two", "three"));
+        Observable<String> take = w.take(1);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        take.subscribe(observer);
+        verify(observer, times(1)).onNext("one");
+        verify(observer, never()).onNext("two");
+        verify(observer, never()).onNext("three");
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testTakeWithError() {
+        Observable.fromIterable(Arrays.asList(1, 2, 3)).take(1)
+        .map(new Function<Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1) {
+                throw new IllegalArgumentException("some error");
+            }
+        }).toBlocking().single();
+    }
+
+    @Test
+    public void testTakeWithErrorHappeningInOnNext() {
+        Observable<Integer> w = Observable.fromIterable(Arrays.asList(1, 2, 3))
+                .take(2).map(new Function<Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1) {
+                throw new IllegalArgumentException("some error");
+            }
+        });
+
+        Subscriber<Integer> observer = TestHelper.mockSubscriber();
+        w.subscribe(observer);
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, times(1)).onError(any(IllegalArgumentException.class));
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testTakeWithErrorHappeningInTheLastOnNext() {
+        Observable<Integer> w = Observable.fromIterable(Arrays.asList(1, 2, 3)).take(1).map(new Function<Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1) {
+                throw new IllegalArgumentException("some error");
+            }
+        });
+
+        Subscriber<Integer> observer = TestHelper.mockSubscriber();
+        w.subscribe(observer);
+        InOrder inOrder = inOrder(observer);
+        inOrder.verify(observer, times(1)).onError(any(IllegalArgumentException.class));
+        inOrder.verifyNoMoreInteractions();
+    }
+
+    @Test
+    public void testTakeDoesntLeakErrors() {
+        Observable<String> source = Observable.create(new Publisher<String>() {
+            @Override
+            public void subscribe(Subscriber<? super String> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onNext("one");
+                observer.onError(new Throwable("test failed"));
+            }
+        });
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+
+        source.take(1).subscribe(observer);
+
+        verify(observer).onSubscribe((Subscription)notNull());
+        verify(observer, times(1)).onNext("one");
+        // even though onError is called we take(1) so shouldn't see it
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+        verifyNoMoreInteractions(observer);
+    }
+
+    @Test
+    @Ignore("take(0) is now empty() and doesn't even subscribe to the original source")
+    public void testTakeZeroDoesntLeakError() {
+        final AtomicBoolean subscribed = new AtomicBoolean(false);
+        BooleanSubscription bs = new BooleanSubscription();
+        Observable<String> source = Observable.create(new Publisher<String>() {
+            @Override
+            public void subscribe(Subscriber<? super String> observer) {
+                subscribed.set(true);
+                observer.onSubscribe(bs);
+                observer.onError(new Throwable("test failed"));
+            }
+        });
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+
+        source.take(0).subscribe(observer);
+        assertTrue("source subscribed", subscribed.get());
+        assertTrue("source unsubscribed", bs.isCancelled());
+
+        verify(observer, never()).onNext(anyString());
+        // even though onError is called we take(0) so shouldn't see it
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+        verifyNoMoreInteractions(observer);
+    }
+
+    @Test
+    public void testUnsubscribeAfterTake() {
+        TestObservableFunc f = new TestObservableFunc("one", "two", "three");
+        Observable<String> w = Observable.create(f);
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        
+        Observable<String> take = w.take(1);
+        take.subscribe(observer);
+
+        // wait for the Observable to complete
+        try {
+            f.t.join();
+        } catch (Throwable e) {
+            e.printStackTrace();
+            fail(e.getMessage());
+        }
+
+        System.out.println("TestObservable thread finished");
+        verify(observer).onSubscribe((Subscription)notNull());
+        verify(observer, times(1)).onNext("one");
+        verify(observer, never()).onNext("two");
+        verify(observer, never()).onNext("three");
+        verify(observer, times(1)).onComplete();
+        // FIXME no longer assertable
+//        verify(s, times(1)).unsubscribe();
+        verifyNoMoreInteractions(observer);
+    }
+
+    @Test(timeout = 2000)
+    public void testUnsubscribeFromSynchronousInfiniteObservable() {
+        final AtomicLong count = new AtomicLong();
+        INFINITE_OBSERVABLE.take(10).subscribe(new Consumer<Long>() {
+
+            @Override
+            public void accept(Long l) {
+                count.set(l);
+            }
+
+        });
+        assertEquals(10, count.get());
+    }
+
+    @Test(timeout = 2000)
+    public void testMultiTake() {
+        final AtomicInteger count = new AtomicInteger();
+        Observable.create(new Publisher<Integer>() {
+
+            @Override
+            public void subscribe(Subscriber<? super Integer> s) {
+                BooleanSubscription bs = new BooleanSubscription();
+                s.onSubscribe(bs);
+                for (int i = 0; !bs.isCancelled(); i++) {
+                    System.out.println("Emit: " + i);
+                    count.incrementAndGet();
+                    s.onNext(i);
+                }
+            }
+
+        }).take(100).take(1).toBlocking().forEach(new Consumer<Integer>() {
+
+            @Override
+            public void accept(Integer t1) {
+                System.out.println("Receive: " + t1);
+
+            }
+
+        });
+
+        assertEquals(1, count.get());
+    }
+
+    private static class TestObservableFunc implements Publisher<String> {
+
+        final String[] values;
+        Thread t = null;
+
+        public TestObservableFunc(String... values) {
+            this.values = values;
+        }
+
+        @Override
+        public void subscribe(final Subscriber<? super String> observer) {
+            observer.onSubscribe(EmptySubscription.INSTANCE);
+            System.out.println("TestObservable subscribed to ...");
+            t = new Thread(new Runnable() {
+
+                @Override
+                public void run() {
+                    try {
+                        System.out.println("running TestObservable thread");
+                        for (String s : values) {
+                            System.out.println("TestObservable onNext: " + s);
+                            observer.onNext(s);
+                        }
+                        observer.onComplete();
+                    } catch (Throwable e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+
+            });
+            System.out.println("starting TestObservable thread");
+            t.start();
+            System.out.println("done starting TestObservable thread");
+        }
+    }
+
+    private static Observable<Long> INFINITE_OBSERVABLE = Observable.create(new Publisher<Long>() {
+
+        @Override
+        public void subscribe(Subscriber<? super Long> op) {
+            BooleanSubscription bs = new BooleanSubscription();
+            op.onSubscribe(bs);
+            long l = 1;
+            while (!bs.isCancelled()) {
+                op.onNext(l++);
+            }
+            op.onComplete();
+        }
+
+    });
+    
+    @Test(timeout = 2000)
+    public void testTakeObserveOn() {
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        TestSubscriber<Object> ts = new TestSubscriber<>(o);
+        
+        INFINITE_OBSERVABLE.onBackpressureDrop()
+        .observeOn(Schedulers.newThread()).take(1).subscribe(ts);
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+        
+        verify(o).onNext(1L);
+        verify(o, never()).onNext(2L);
+        verify(o).onComplete();
+        verify(o, never()).onError(any(Throwable.class));
+    }
+    
+    @Test
+    public void testProducerRequestThroughTake() {
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        ts.request(3);
+        final AtomicLong requested = new AtomicLong();
+        Observable.create(new Publisher<Integer>() {
+
+            @Override
+            public void subscribe(Subscriber<? super Integer> s) {
+                s.onSubscribe(new Subscription() {
+
+                    @Override
+                    public void request(long n) {
+                        requested.set(n);
+                    }
+
+                    @Override
+                    public void cancel() {
+                        
+                    }
+                });
+            }
+
+        }).take(3).subscribe(ts);
+        // FIXME take triggers fast-path
+        assertEquals(Long.MAX_VALUE, requested.get());
+    }
+    
+    @Test
+    public void testProducerRequestThroughTakeIsModified() {
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        ts.request(3);
+        final AtomicLong requested = new AtomicLong();
+        Observable.create(new Publisher<Integer>() {
+
+            @Override
+            public void subscribe(Subscriber<? super Integer> s) {
+                s.onSubscribe(new Subscription() {
+
+                    @Override
+                    public void request(long n) {
+                        requested.set(n);
+                    }
+
+                    @Override
+                    public void cancel() {
+                        
+                    }
+                });
+            }
+
+        }).take(1).subscribe(ts);
+        //FIXME take triggers fast path if downstream requests more than the limit
+        assertEquals(Long.MAX_VALUE, requested.get());
+    }
+    
+    @Test
+    public void testInterrupt() throws InterruptedException {
+        final AtomicReference<Object> exception = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        Observable.just(1).subscribeOn(Schedulers.computation()).take(1)
+        .subscribe(new Consumer<Integer>() {
+
+            @Override
+            public void accept(Integer t1) {
+                try {
+                    Thread.sleep(100);
+                } catch (Exception e) {
+                    exception.set(e);
+                    e.printStackTrace();
+                } finally {
+                    latch.countDown();
+                }
+            }
+
+        });
+
+        latch.await();
+        assertNull(exception.get());
+    }
+    
+    @Test
+    public void testDoesntRequestMoreThanNeededFromUpstream() throws InterruptedException {
+        final AtomicLong requests = new AtomicLong();
+        TestSubscriber<Long> ts = new TestSubscriber<>((Long)null);
+        Observable.interval(100, TimeUnit.MILLISECONDS)
+            //
+            .doOnRequest(new LongConsumer() {
+                @Override
+                public void accept(long n) {
+                    System.out.println(n);
+                    requests.addAndGet(n);
+            }})
+            //
+            .take(2)
+            //
+            .subscribe(ts);
+        Thread.sleep(50);
+        ts.request(1);
+        ts.request(1);
+        ts.request(1);
+        ts.awaitTerminalEvent();
+        ts.assertComplete();
+        ts.assertNoErrors();
+        // FIXME take triggers fast-path and the addition above turns into Long.MIN_VALUE
+        assertEquals(Long.MIN_VALUE, requests.get());
+    }
+    
+    @Test
+    public void takeFinalValueThrows() {
+        Observable<Integer> source = Observable.just(1).take(1);
+        
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                throw new TestException();
+            }
+        };
+        
+        source.safeSubscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertError(TestException.class);
+        ts.assertNotComplete();
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorTakeTimedTest.java b/src/test/java/io/reactivex/internal/operators/OperatorTakeTimedTest.java
new file mode 100644
index 0000000000..f584adb464
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorTakeTimedTest.java
@@ -0,0 +1,126 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
+
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Test;
+import org.mockito.InOrder;
+import org.reactivestreams.Subscriber;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.subjects.PublishSubject;
+
+public class OperatorTakeTimedTest {
+
+    @Test
+    public void testTakeTimed() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishSubject<Integer> source = PublishSubject.create();
+
+        Observable<Integer> result = source.take(1, TimeUnit.SECONDS, scheduler);
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+
+        result.subscribe(o);
+
+        source.onNext(1);
+        source.onNext(2);
+        source.onNext(3);
+
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        source.onNext(4);
+
+        InOrder inOrder = inOrder(o);
+        inOrder.verify(o).onNext(1);
+        inOrder.verify(o).onNext(2);
+        inOrder.verify(o).onNext(3);
+        inOrder.verify(o).onComplete();
+        inOrder.verifyNoMoreInteractions();
+
+        verify(o, never()).onNext(4);
+        verify(o, never()).onError(any(Throwable.class));
+    }
+
+    @Test
+    public void testTakeTimedErrorBeforeTime() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishSubject<Integer> source = PublishSubject.create();
+
+        Observable<Integer> result = source.take(1, TimeUnit.SECONDS, scheduler);
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+
+        result.subscribe(o);
+
+        source.onNext(1);
+        source.onNext(2);
+        source.onNext(3);
+        source.onError(new TestException());
+
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        source.onNext(4);
+
+        InOrder inOrder = inOrder(o);
+        inOrder.verify(o).onNext(1);
+        inOrder.verify(o).onNext(2);
+        inOrder.verify(o).onNext(3);
+        inOrder.verify(o).onError(any(TestException.class));
+        inOrder.verifyNoMoreInteractions();
+
+        verify(o, never()).onComplete();
+        verify(o, never()).onNext(4);
+    }
+
+    @Test
+    public void testTakeTimedErrorAfterTime() {
+        TestScheduler scheduler = new TestScheduler();
+
+        PublishSubject<Integer> source = PublishSubject.create();
+
+        Observable<Integer> result = source.take(1, TimeUnit.SECONDS, scheduler);
+
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+
+        result.subscribe(o);
+
+        source.onNext(1);
+        source.onNext(2);
+        source.onNext(3);
+
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+
+        source.onNext(4);
+        source.onError(new TestException());
+
+        InOrder inOrder = inOrder(o);
+        inOrder.verify(o).onNext(1);
+        inOrder.verify(o).onNext(2);
+        inOrder.verify(o).onNext(3);
+        inOrder.verify(o).onComplete();
+        inOrder.verifyNoMoreInteractions();
+
+        verify(o, never()).onNext(4);
+        verify(o, never()).onError(any(TestException.class));
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorTakeUntilPredicateTest.java b/src/test/java/io/reactivex/internal/operators/OperatorTakeUntilPredicateTest.java
new file mode 100644
index 0000000000..eb006c7269
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorTakeUntilPredicateTest.java
@@ -0,0 +1,128 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
+
+import java.util.function.Predicate;
+
+import org.junit.Test;
+import org.reactivestreams.Subscriber;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.subscribers.TestSubscriber;
+;
+
+public class OperatorTakeUntilPredicateTest {
+    @Test
+    public void takeEmpty() {
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        
+        Observable.empty().takeUntil(v -> true).subscribe(o);
+        
+        verify(o, never()).onNext(any());
+        verify(o, never()).onError(any(Throwable.class));
+        verify(o).onComplete();
+    }
+    @Test
+    public void takeAll() {
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        
+        Observable.just(1, 2).takeUntil(v -> false).subscribe(o);
+        
+        verify(o).onNext(1);
+        verify(o).onNext(2);
+        verify(o, never()).onError(any(Throwable.class));
+        verify(o).onComplete();
+    }
+    @Test
+    public void takeFirst() {
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        
+        Observable.just(1, 2).takeUntil(v -> true).subscribe(o);
+        
+        verify(o).onNext(1);
+        verify(o, never()).onNext(2);
+        verify(o, never()).onError(any(Throwable.class));
+        verify(o).onComplete();
+    }
+    @Test
+    public void takeSome() {
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        
+        Observable.just(1, 2, 3).takeUntil(t1 -> t1 == 2)
+        .subscribe(o);
+        
+        verify(o).onNext(1);
+        verify(o).onNext(2);
+        verify(o, never()).onNext(3);
+        verify(o, never()).onError(any(Throwable.class));
+        verify(o).onComplete();
+    }
+    @Test
+    public void functionThrows() {
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        
+        Observable.just(1, 2, 3).takeUntil((Predicate<Integer>)(t1 -> {
+                throw new TestException("Forced failure");
+        })).subscribe(o);
+        
+        verify(o).onNext(1);
+        verify(o, never()).onNext(2);
+        verify(o, never()).onNext(3);
+        verify(o).onError(any(TestException.class));
+        verify(o, never()).onComplete();
+    }
+    @Test
+    public void sourceThrows() {
+        Subscriber<Object> o = TestHelper.mockSubscriber();
+        
+        Observable.just(1)
+        .concatWith(Observable.<Integer>error(new TestException()))
+        .concatWith(Observable.just(2))
+        .takeUntil(v -> false).subscribe(o);
+        
+        verify(o).onNext(1);
+        verify(o, never()).onNext(2);
+        verify(o).onError(any(TestException.class));
+        verify(o, never()).onComplete();
+    }
+    @Test
+    public void backpressure() {
+        TestSubscriber<Integer> ts = new TestSubscriber<>(5L);
+        
+        Observable.range(1, 1000).takeUntil(v -> false).subscribe(ts);
+        
+        ts.assertNoErrors();
+        ts.assertValues(1, 2, 3, 4, 5);
+        ts.assertNotComplete();
+    }
+    
+    @Test
+    public void testErrorIncludesLastValueAsCause() {
+        TestSubscriber<String> ts = new TestSubscriber<>();
+        final TestException e = new TestException("Forced failure");
+        Observable.just("abc").takeUntil((Predicate<String>)(t -> {
+                throw e;
+        })).subscribe(ts);
+        
+        ts.assertTerminated();
+        ts.assertNotComplete();
+        ts.assertError(TestException.class);
+        // FIXME last cause value is not saved
+//        assertTrue(ts.errors().get(0).getCause().getMessage().contains("abc"));
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorTakeUntilTest.java b/src/test/java/io/reactivex/internal/operators/OperatorTakeUntilTest.java
new file mode 100644
index 0000000000..015d8657a2
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorTakeUntilTest.java
@@ -0,0 +1,273 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+import org.junit.Test;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.subjects.PublishSubject;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class OperatorTakeUntilTest {
+
+    @Test
+    public void testTakeUntil() {
+        Subscription sSource = mock(Subscription.class);
+        Subscription sOther = mock(Subscription.class);
+        TestObservable source = new TestObservable(sSource);
+        TestObservable other = new TestObservable(sOther);
+
+        Subscriber<String> result = TestHelper.mockSubscriber();
+        Observable<String> stringObservable = Observable.create(source)
+                .takeUntil(Observable.create(other));
+        stringObservable.subscribe(result);
+        source.sendOnNext("one");
+        source.sendOnNext("two");
+        other.sendOnNext("three");
+        source.sendOnNext("four");
+        source.sendOnCompleted();
+        other.sendOnCompleted();
+
+        verify(result, times(1)).onNext("one");
+        verify(result, times(1)).onNext("two");
+        verify(result, times(0)).onNext("three");
+        verify(result, times(0)).onNext("four");
+        verify(sSource, times(1)).cancel();
+        verify(sOther, times(1)).cancel();
+
+    }
+
+    @Test
+    public void testTakeUntilSourceCompleted() {
+        Subscription sSource = mock(Subscription.class);
+        Subscription sOther = mock(Subscription.class);
+        TestObservable source = new TestObservable(sSource);
+        TestObservable other = new TestObservable(sOther);
+
+        Subscriber<String> result = TestHelper.mockSubscriber();
+        Observable<String> stringObservable = Observable.create(source).takeUntil(Observable.create(other));
+        stringObservable.subscribe(result);
+        source.sendOnNext("one");
+        source.sendOnNext("two");
+        source.sendOnCompleted();
+
+        verify(result, times(1)).onNext("one");
+        verify(result, times(1)).onNext("two");
+        verify(sSource, times(1)).cancel();
+        verify(sOther, times(1)).cancel();
+
+    }
+
+    @Test
+    public void testTakeUntilSourceError() {
+        Subscription sSource = mock(Subscription.class);
+        Subscription sOther = mock(Subscription.class);
+        TestObservable source = new TestObservable(sSource);
+        TestObservable other = new TestObservable(sOther);
+        Throwable error = new Throwable();
+
+        Subscriber<String> result = TestHelper.mockSubscriber();
+        Observable<String> stringObservable = Observable.create(source).takeUntil(Observable.create(other));
+        stringObservable.subscribe(result);
+        source.sendOnNext("one");
+        source.sendOnNext("two");
+        source.sendOnError(error);
+        source.sendOnNext("three");
+
+        verify(result, times(1)).onNext("one");
+        verify(result, times(1)).onNext("two");
+        verify(result, times(0)).onNext("three");
+        verify(result, times(1)).onError(error);
+        verify(sSource, times(1)).cancel();
+        verify(sOther, times(1)).cancel();
+
+    }
+
+    @Test
+    public void testTakeUntilOtherError() {
+        Subscription sSource = mock(Subscription.class);
+        Subscription sOther = mock(Subscription.class);
+        TestObservable source = new TestObservable(sSource);
+        TestObservable other = new TestObservable(sOther);
+        Throwable error = new Throwable();
+
+        Subscriber<String> result = TestHelper.mockSubscriber();
+        Observable<String> stringObservable = Observable.create(source).takeUntil(Observable.create(other));
+        stringObservable.subscribe(result);
+        source.sendOnNext("one");
+        source.sendOnNext("two");
+        other.sendOnError(error);
+        source.sendOnNext("three");
+
+        verify(result, times(1)).onNext("one");
+        verify(result, times(1)).onNext("two");
+        verify(result, times(0)).onNext("three");
+        verify(result, times(1)).onError(error);
+        verify(result, times(0)).onComplete();
+        verify(sSource, times(1)).cancel();
+        verify(sOther, times(1)).cancel();
+
+    }
+
+    /**
+     * If the 'other' onCompletes then we unsubscribe from the source and onComplete
+     */
+    @Test
+    public void testTakeUntilOtherCompleted() {
+        Subscription sSource = mock(Subscription.class);
+        Subscription sOther = mock(Subscription.class);
+        TestObservable source = new TestObservable(sSource);
+        TestObservable other = new TestObservable(sOther);
+
+        Subscriber<String> result = TestHelper.mockSubscriber();
+        Observable<String> stringObservable = Observable.create(source).takeUntil(Observable.create(other));
+        stringObservable.subscribe(result);
+        source.sendOnNext("one");
+        source.sendOnNext("two");
+        other.sendOnCompleted();
+        source.sendOnNext("three");
+
+        verify(result, times(1)).onNext("one");
+        verify(result, times(1)).onNext("two");
+        verify(result, times(0)).onNext("three");
+        verify(result, times(1)).onComplete();
+        verify(sSource, times(1)).cancel();
+        verify(sOther, times(1)).cancel(); // unsubscribed since SafeSubscriber unsubscribes after onComplete
+
+    }
+
+    private static class TestObservable implements Publisher<String> {
+
+        Subscriber<? super String> observer;
+        Subscription s;
+
+        public TestObservable(Subscription s) {
+            this.s = s;
+        }
+
+        /* used to simulate subscription */
+        public void sendOnCompleted() {
+            observer.onComplete();
+        }
+
+        /* used to simulate subscription */
+        public void sendOnNext(String value) {
+            observer.onNext(value);
+        }
+
+        /* used to simulate subscription */
+        public void sendOnError(Throwable e) {
+            observer.onError(e);
+        }
+
+        @Override
+        public void subscribe(Subscriber<? super String> observer) {
+            this.observer = observer;
+            observer.onSubscribe(s);
+        }
+    }
+    
+    @Test
+    public void testUntilFires() {
+        PublishSubject<Integer> source = PublishSubject.create();
+        PublishSubject<Integer> until = PublishSubject.create();
+        
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        
+        source.takeUntil(until).unsafeSubscribe(ts);
+
+        assertTrue(source.hasSubscribers());
+        assertTrue(until.hasSubscribers());
+
+        source.onNext(1);
+        
+        ts.assertValue(1);
+        until.onNext(1);
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertTerminated();
+        
+        assertFalse("Source still has observers", source.hasSubscribers());
+        assertFalse("Until still has observers", until.hasSubscribers());
+        assertFalse("TestSubscriber is unsubscribed", ts.isCancelled());
+    }
+    @Test
+    public void testMainCompletes() {
+        PublishSubject<Integer> source = PublishSubject.create();
+        PublishSubject<Integer> until = PublishSubject.create();
+        
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        
+        source.takeUntil(until).unsafeSubscribe(ts);
+
+        assertTrue(source.hasSubscribers());
+        assertTrue(until.hasSubscribers());
+
+        source.onNext(1);
+        source.onComplete();
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertTerminated();
+        
+        assertFalse("Source still has observers", source.hasSubscribers());
+        assertFalse("Until still has observers", until.hasSubscribers());
+        assertFalse("TestSubscriber is unsubscribed", ts.isCancelled());
+    }
+    @Test
+    public void testDownstreamUnsubscribes() {
+        PublishSubject<Integer> source = PublishSubject.create();
+        PublishSubject<Integer> until = PublishSubject.create();
+        
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        
+        source.takeUntil(until).take(1).unsafeSubscribe(ts);
+
+        assertTrue(source.hasSubscribers());
+        assertTrue(until.hasSubscribers());
+
+        source.onNext(1);
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertTerminated();
+        
+        assertFalse("Source still has observers", source.hasSubscribers());
+        assertFalse("Until still has observers", until.hasSubscribers());
+        assertFalse("TestSubscriber is unsubscribed", ts.isCancelled());
+    }
+    public void testBackpressure() {
+        PublishSubject<Integer> until = PublishSubject.create();
+        
+        TestSubscriber<Integer> ts = new TestSubscriber<>((Long)null);
+        
+        Observable.range(1, 10).takeUntil(until).unsafeSubscribe(ts);
+
+        assertTrue(until.hasSubscribers());
+
+        ts.request(1);
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertNotComplete();
+        
+        assertFalse("Until still has observers", until.hasSubscribers());
+        assertFalse("TestSubscriber is unsubscribed", ts.isCancelled());
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorTakeWhileTest.java b/src/test/java/io/reactivex/internal/operators/OperatorTakeWhileTest.java
new file mode 100644
index 0000000000..e7a2b70c27
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/OperatorTakeWhileTest.java
@@ -0,0 +1,274 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators;
+
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
+
+import java.util.function.Predicate;
+
+import org.junit.*;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.subjects.*;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class OperatorTakeWhileTest {
+
+    @Test
+    public void testTakeWhile1() {
+        Observable<Integer> w = Observable.just(1, 2, 3);
+        Observable<Integer> take = w.takeWhile(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer input) {
+                return input < 3;
+            }
+        });
+
+        Subscriber<Integer> observer = TestHelper.mockSubscriber();
+        take.subscribe(observer);
+        verify(observer, times(1)).onNext(1);
+        verify(observer, times(1)).onNext(2);
+        verify(observer, never()).onNext(3);
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testTakeWhileOnSubject1() {
+        Subject<Integer, Integer> s = PublishSubject.create();
+        Observable<Integer> take = s.takeWhile(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer input) {
+                return input < 3;
+            }
+        });
+
+        Subscriber<Integer> observer = TestHelper.mockSubscriber();
+        take.subscribe(observer);
+
+        s.onNext(1);
+        s.onNext(2);
+        s.onNext(3);
+        s.onNext(4);
+        s.onNext(5);
+        s.onComplete();
+
+        verify(observer, times(1)).onNext(1);
+        verify(observer, times(1)).onNext(2);
+        verify(observer, never()).onNext(3);
+        verify(observer, never()).onNext(4);
+        verify(observer, never()).onNext(5);
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testTakeWhile2() {
+        Observable<String> w = Observable.just("one", "two", "three");
+        Observable<String> take = w.takeWhile(new Predicate<String>() {
+            int index = 0;
+
+            @Override
+            public boolean test(String input) {
+                return index++ < 2;
+            }
+        });
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        take.subscribe(observer);
+        verify(observer, times(1)).onNext("one");
+        verify(observer, times(1)).onNext("two");
+        verify(observer, never()).onNext("three");
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onComplete();
+    }
+
+    @Test
+    public void testTakeWhileDoesntLeakErrors() {
+        Observable<String> source = Observable.create(new Publisher<String>() {
+            @Override
+            public void subscribe(Subscriber<? super String> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                observer.onNext("one");
+                observer.onError(new Throwable("test failed"));
+            }
+        });
+
+        source.takeWhile(new Predicate<String>() {
+            @Override
+            public boolean test(String s) {
+                return false;
+            }
+        }).toBlocking().last("");
+    }
+
+    @Test
+    public void testTakeWhileProtectsPredicateCall() {
+        TestObservable source = new TestObservable(mock(Subscription.class), "one");
+        final RuntimeException testException = new RuntimeException("test exception");
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        Observable<String> take = Observable.create(source)
+                .takeWhile(new Predicate<String>() {
+            @Override
+            public boolean test(String s) {
+                throw testException;
+            }
+        });
+        take.subscribe(observer);
+
+        // wait for the Observable to complete
+        try {
+            source.t.join();
+        } catch (Throwable e) {
+            e.printStackTrace();
+            fail(e.getMessage());
+        }
+
+        verify(observer, never()).onNext(any(String.class));
+        verify(observer, times(1)).onError(testException);
+    }
+
+    @Test
+    public void testUnsubscribeAfterTake() {
+        Subscription s = mock(Subscription.class);
+        TestObservable w = new TestObservable(s, "one", "two", "three");
+
+        Subscriber<String> observer = TestHelper.mockSubscriber();
+        Observable<String> take = Observable.create(w)
+                .takeWhile(new Predicate<String>() {
+            int index = 0;
+
+            @Override
+            public boolean test(String s) {
+                return index++ < 1;
+            }
+        });
+        take.subscribe(observer);
+
+        // wait for the Observable to complete
+        try {
+            w.t.join();
+        } catch (Throwable e) {
+            e.printStackTrace();
+            fail(e.getMessage());
+        }
+
+        System.out.println("TestObservable thread finished");
+        verify(observer, times(1)).onNext("one");
+        verify(observer, never()).onNext("two");
+        verify(observer, never()).onNext("three");
+        verify(s, times(1)).cancel();
+    }
+
+    private static class TestObservable implements Publisher<String> {
+
+        final Subscription s;
+        final String[] values;
+        Thread t = null;
+
+        public TestObservable(Subscription s, String... values) {
+            this.s = s;
+            this.values = values;
+        }
+
+        @Override
+        public void subscribe(final Subscriber<? super String> observer) {
+            System.out.println("TestObservable subscribed to ...");
+            observer.onSubscribe(s);
+            t = new Thread(new Runnable() {
+
+                @Override
+                public void run() {
+                    try {
+                        System.out.println("running TestObservable thread");
+                        for (String s : values) {
+                            System.out.println("TestObservable onNext: " + s);
+                            observer.onNext(s);
+                        }
+                        observer.onComplete();
+                    } catch (Throwable e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+
+            });
+            System.out.println("starting TestObservable thread");
+            t.start();
+            System.out.println("done starting TestObservable thread");
+        }
+    }
+    
+    @Test
+    public void testBackpressure() {
+        Observable<Integer> source = Observable.range(1, 1000).takeWhile(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer t1) {
+                return t1 < 100;
+            }
+        });
+        TestSubscriber<Integer> ts = new TestSubscriber<>(5L);
+        
+        source.subscribe(ts);
+        
+        ts.assertNoErrors();
+        ts.assertValues(1, 2, 3, 4, 5);
+        
+        ts.request(5);
+
+        ts.assertNoErrors();
+        ts.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+    }
+    
+    @Test
+    public void testNoUnsubscribeDownstream() {
+        Observable<Integer> source = Observable.range(1, 1000).takeWhile(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer t1) {
+                return t1 < 2;
+            }
+        });
+        TestSubscriber<Integer> ts = new TestSubscriber<>();
+        
+        source.unsafeSubscribe(ts);
+        
+        ts.assertNoErrors();
+        ts.assertValue(1);
+        
+        Assert.assertFalse("Unsubscribed!", ts.isCancelled());
+    }
+    
+    @Test
+    public void testErrorCauseIncludesLastValue() {
+        TestSubscriber<String> ts = new TestSubscriber<>();
+        Observable.just("abc").takeWhile(new Predicate<String>() {
+            @Override
+            public boolean test(String t1) {
+                throw new TestException();
+            }
+        }).subscribe(ts);
+        
+        ts.assertTerminated();
+        ts.assertNoValues();
+        ts.assertError(TestException.class);
+        // FIXME last cause value not recorded
+//        assertTrue(ts.getOnErrorEvents().get(0).getCause().getMessage().contains("abc"));
+    }
+    
+}
\ No newline at end of file
