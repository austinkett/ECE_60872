diff --git a/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java b/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java
index 52c7ead18e..4b03f311e3 100644
--- a/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java
+++ b/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java
@@ -97,8 +97,8 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
         }
         return super.schedulePeriodicallyDirect(run, initialDelay, period, unit);
     }
-    
-    static final class ExecutorWorker extends Scheduler.Worker implements Runnable {
+    /* public: test support. */
+    public static final class ExecutorWorker extends Scheduler.Worker implements Runnable {
         final Executor executor;
         
         final MpscLinkedQueue<Runnable> queue;
@@ -109,6 +109,8 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
         static final AtomicIntegerFieldUpdater<ExecutorWorker> WIP =
                 AtomicIntegerFieldUpdater.newUpdater(ExecutorWorker.class, "wip");
         
+        final SetCompositeResource<Disposable> tasks = new SetCompositeResource<>(Disposable::dispose);
+        
         public ExecutorWorker(Executor executor) {
             this.executor = executor;
             this.queue = new MpscLinkedQueue<>();
@@ -153,26 +155,56 @@ public Disposable schedule(Runnable run, long delay, TimeUnit unit) {
 
             MultipleAssignmentResource<Disposable> mar = new MultipleAssignmentResource<>(Disposable::dispose, first);
             
-            Disposable delayed;
-
             Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
             
-            Runnable r = () -> mar.setResource(schedule(decoratedRun));
+            ScheduledRunnable sr = new ScheduledRunnable(() -> {
+                mar.setResource(schedule(decoratedRun));
+            }, tasks);
+            tasks.add(sr);
             
             if (executor instanceof ScheduledExecutorService) {
                 try {
-                    Future<?> f = ((ScheduledExecutorService)executor).schedule(r, delay, unit);
-                    delayed = () -> f.cancel(true);
+                    Future<?> f = ((ScheduledExecutorService)executor).schedule(sr, delay, unit);
+                    sr.setFuture(f);
                 } catch (RejectedExecutionException ex) {
                     disposed = true;
                     RxJavaPlugins.onError(ex);
                     return EmptyDisposable.INSTANCE;
                 }
             } else {
-                delayed = HELPER.scheduleDirect(r, delay, unit);
+                Disposable d = HELPER.scheduleDirect(sr, delay, unit);
+                sr.setFuture(new Future<Object>() {
+                    @Override
+                    public boolean cancel(boolean mayInterruptIfRunning) {
+                        d.dispose();
+                        return false;
+                    }
+
+                    @Override
+                    public boolean isCancelled() {
+                        return false;
+                    }
+
+                    @Override
+                    public boolean isDone() {
+                        return false;
+                    }
+
+                    @Override
+                    public Object get() throws InterruptedException, ExecutionException {
+                        return null;
+                    }
+
+                    @Override
+                    public Object get(long timeout, TimeUnit unit)
+                            throws InterruptedException, ExecutionException, TimeoutException {
+                        return null;
+                    }
+                    
+                });
             }
             
-            first.setResource(delayed);
+            first.setResource(sr);
             
             return mar;
         }
@@ -181,6 +213,7 @@ public Disposable schedule(Runnable run, long delay, TimeUnit unit) {
         public void dispose() {
             if (!disposed) {
                 disposed = true;
+                tasks.dispose();
                 if (WIP.getAndIncrement(this) == 0) {
                     queue.clear();
                 }
diff --git a/src/main/java/io/reactivex/schedulers/Schedulers.java b/src/main/java/io/reactivex/schedulers/Schedulers.java
index f680ae819a..d3548b5166 100644
--- a/src/main/java/io/reactivex/schedulers/Schedulers.java
+++ b/src/main/java/io/reactivex/schedulers/Schedulers.java
@@ -93,4 +93,20 @@ public static Scheduler immediate() {
     public static Scheduler from(Executor executor) {
         return new ExecutorScheduler(executor);
     }
+    
+    public static void shutdown() {
+        computation().shutdown();
+        io().shutdown();
+        newThread().shutdown();
+        single().shutdown();
+        trampoline().shutdown();
+    }
+    
+    public static void start() {
+        computation().start();
+        io().start();
+        newThread().start();
+        single().start();
+        trampoline().start();
+    }
 }
diff --git a/src/test/java/io/reactivex/GroupByTests.java b/src/test/java/io/reactivex/GroupByTests.java
index 0982fccfa1..da5c3e6b72 100644
--- a/src/test/java/io/reactivex/GroupByTests.java
+++ b/src/test/java/io/reactivex/GroupByTests.java
@@ -27,7 +27,10 @@ public void testTakeUnsubscribesOnGroupBy() {
         .groupBy(event -> event.type)
         .take(1)
         .toBlocking()
-        .forEach(System.out::println);
+        .forEach(v -> {
+            System.out.println(v);
+            v.take(1).subscribe();  // FIXME groups need consumption to a certain degree to cancel upstream
+        });
 
         System.out.println("**** finished");
     }
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java b/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java
index 748a01f378..d8fb67ec5d 100644
--- a/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java
+++ b/src/test/java/io/reactivex/internal/operators/OperatorConcatTest.java
@@ -129,6 +129,14 @@ public void testSimpleAsyncConcat() {
         inOrder.verify(observer, times(1)).onNext("six");
     }
 
+    @Test
+    public void testNestedAsyncConcatLoop() throws Throwable {
+        for (int i = 0; i < 100; i++) {
+            System.out.println("testNestedAsyncConcat >> " + i);
+            testNestedAsyncConcat();
+        }
+    }
+    
     /**
      * Test an async Observable that emits more async Observables
      */
@@ -242,8 +250,8 @@ public void run() {
         inOrder.verify(observer, times(1)).onNext("eight");
         inOrder.verify(observer, times(1)).onNext("nine");
 
-        inOrder.verify(observer, times(1)).onComplete();
         verify(observer, never()).onError(any(Throwable.class));
+        inOrder.verify(observer, times(1)).onComplete();
     }
 
     @Test
@@ -469,7 +477,7 @@ public void cancel() {
         private final List<T> values;
         private Thread t = null;
         private int count = 0;
-        private boolean subscribed = true;
+        private volatile boolean subscribed = true;
         private final CountDownLatch once;
         private final CountDownLatch okToContinue;
         private final CountDownLatch threadHasStarted = new CountDownLatch(1);
diff --git a/src/test/java/io/reactivex/internal/operators/OperatorOnErrorResumeNextViaObservableTest.java b/src/test/java/io/reactivex/internal/operators/OperatorOnErrorResumeNextViaObservableTest.java
index ffa68db907..9903b63561 100644
--- a/src/test/java/io/reactivex/internal/operators/OperatorOnErrorResumeNextViaObservableTest.java
+++ b/src/test/java/io/reactivex/internal/operators/OperatorOnErrorResumeNextViaObservableTest.java
@@ -100,7 +100,7 @@ public String apply(String s) {
     
     @Test
     @Ignore("Publishers should not throw")
-    public void testResumeNextWithFailedOnSubscribe() {
+    public void testResumeNextWithFailureOnSubscribe() {
         Observable<String> testObservable = Observable.create(new Publisher<String>() {
 
             @Override
@@ -122,7 +122,7 @@ public void subscribe(Subscriber<? super String> t1) {
     
     @Test
     @Ignore("Publishers should not throw")
-    public void testResumeNextWithFailedOnSubscribeAsync() {
+    public void testResumeNextWithFailureOnSubscribeAsync() {
         Observable<String> testObservable = Observable.create(new Publisher<String>() {
 
             @Override
diff --git a/src/test/java/io/reactivex/schedulers/AbstractSchedulerConcurrencyTests.java b/src/test/java/io/reactivex/schedulers/AbstractSchedulerConcurrencyTests.java
new file mode 100644
index 0000000000..b9c33554fa
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/AbstractSchedulerConcurrencyTests.java
@@ -0,0 +1,419 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import static org.junit.Assert.*;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+import java.util.function.*;
+
+import org.junit.Test;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.Scheduler.Worker;
+import io.reactivex.subscribers.AsyncObserver;
+
+/**
+ * Base tests for schedulers that involve threads (concurrency).
+ * 
+ * These can only run on Schedulers that launch threads since they expect async/concurrent behavior.
+ * 
+ * The Current/Immediate schedulers will not work with these tests.
+ */
+public abstract class AbstractSchedulerConcurrencyTests extends AbstractSchedulerTests {
+
+    /**
+     * Bug report: https://github.com/ReactiveX/RxJava/issues/431
+     */
+    @Test
+    public final void testUnSubscribeForScheduler() throws InterruptedException {
+        final AtomicInteger countReceived = new AtomicInteger();
+        final AtomicInteger countGenerated = new AtomicInteger();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Observable.interval(50, TimeUnit.MILLISECONDS)
+                .map(new Function<Long, Long>() {
+                    @Override
+                    public Long apply(Long aLong) {
+                        countGenerated.incrementAndGet();
+                        return aLong;
+                    }
+                })
+                .subscribeOn(getScheduler())
+                .observeOn(getScheduler())
+                .subscribe(new Observer<Long>() {
+                    @Override
+                    public void onComplete() {
+                        System.out.println("--- completed");
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        System.out.println("--- onError");
+                    }
+
+                    @Override
+                    public void onNext(Long args) {
+                        if (countReceived.incrementAndGet() == 2) {
+                            cancel();
+                            latch.countDown();
+                        }
+                        System.out.println("==> Received " + args);
+                    }
+                });
+
+        latch.await(1000, TimeUnit.MILLISECONDS);
+
+        System.out.println("----------- it thinks it is finished ------------------ ");
+        Thread.sleep(100);
+
+        assertEquals(2, countGenerated.get());
+    }
+
+    @Test
+    public void testUnsubscribeRecursiveScheduleFromOutside() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final CountDownLatch unsubscribeLatch = new CountDownLatch(1);
+        final AtomicInteger counter = new AtomicInteger();
+        final Worker inner = getScheduler().createWorker();
+        try {
+            inner.schedule(new Runnable() {
+    
+                @Override
+                public void run() {
+                    inner.schedule(new Runnable() {
+    
+                        int i = 0;
+    
+                        @Override
+                        public void run() {
+                            System.out.println("Run: " + i++);
+                            if (i == 10) {
+                                latch.countDown();
+                                try {
+                                    // wait for unsubscribe to finish so we are not racing it
+                                    unsubscribeLatch.await();
+                                } catch (InterruptedException e) {
+                                    // we expect the countDown if unsubscribe is not working
+                                    // or to be interrupted if unsubscribe is successful since 
+                                    // the unsubscribe will interrupt it as it is calling Future.cancel(true)
+                                    // so we will ignore the stacktrace
+                                }
+                            }
+    
+                            counter.incrementAndGet();
+                            inner.schedule(this);
+                        }
+                    });
+                }
+    
+            });
+    
+            latch.await();
+            inner.dispose();
+            unsubscribeLatch.countDown();
+            Thread.sleep(200); // let time pass to see if the scheduler is still doing work
+            assertEquals(10, counter.get());
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public void testUnsubscribeRecursiveScheduleFromInside() throws InterruptedException {
+        final CountDownLatch unsubscribeLatch = new CountDownLatch(1);
+        final AtomicInteger counter = new AtomicInteger();
+        final Worker inner = getScheduler().createWorker();
+        try {
+            inner.schedule(new Runnable() {
+    
+                @Override
+                public void run() {
+                    inner.schedule(new Runnable() {
+    
+                        int i = 0;
+    
+                        @Override
+                        public void run() {
+                            System.out.println("Run: " + i++);
+                            if (i == 10) {
+                                inner.dispose();
+                            }
+    
+                            counter.incrementAndGet();
+                            inner.schedule(this);
+                        }
+                    });
+                }
+    
+            });
+    
+            unsubscribeLatch.countDown();
+            Thread.sleep(200); // let time pass to see if the scheduler is still doing work
+            assertEquals(10, counter.get());
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public void testUnsubscribeRecursiveScheduleWithDelay() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final CountDownLatch unsubscribeLatch = new CountDownLatch(1);
+        final AtomicInteger counter = new AtomicInteger();
+        final Worker inner = getScheduler().createWorker();
+        
+        try {
+            inner.schedule(new Runnable() {
+    
+                @Override
+                public void run() {
+                    inner.schedule(new Runnable() {
+    
+                        long i = 1L;
+    
+                        @Override
+                        public void run() {
+                            if (i++ == 10) {
+                                latch.countDown();
+                                try {
+                                    // wait for unsubscribe to finish so we are not racing it
+                                    unsubscribeLatch.await();
+                                } catch (InterruptedException e) {
+                                    // we expect the countDown if unsubscribe is not working
+                                    // or to be interrupted if unsubscribe is successful since 
+                                    // the unsubscribe will interrupt it as it is calling Future.cancel(true)
+                                    // so we will ignore the stacktrace
+                                }
+                            }
+    
+                            counter.incrementAndGet();
+                            inner.schedule(this, 10, TimeUnit.MILLISECONDS);
+                        }
+                    }, 10, TimeUnit.MILLISECONDS);
+                }
+            });
+    
+            latch.await();
+            inner.dispose();
+            unsubscribeLatch.countDown();
+            Thread.sleep(200); // let time pass to see if the scheduler is still doing work
+            assertEquals(10, counter.get());
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public void recursionFromOuterActionAndUnsubscribeInside() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final Worker inner = getScheduler().createWorker();
+        try {
+            inner.schedule(new Runnable() {
+    
+                int i = 0;
+    
+                @Override
+                public void run() {
+                    i++;
+                    if (i % 100000 == 0) {
+                        System.out.println(i + "  Total Memory: " + Runtime.getRuntime().totalMemory() + "  Free: " + Runtime.getRuntime().freeMemory());
+                    }
+                    if (i < 1000000L) {
+                        inner.schedule(this);
+                    } else {
+                        latch.countDown();
+                    }
+                }
+            });
+    
+            latch.await();
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public void testRecursion() throws InterruptedException {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final Worker inner = getScheduler().createWorker();
+        try {
+            inner.schedule(new Runnable() {
+    
+                private long i = 0;
+    
+                @Override
+                public void run() {
+                    i++;
+                    if (i % 100000 == 0) {
+                        System.out.println(i + "  Total Memory: " + Runtime.getRuntime().totalMemory() + "  Free: " + Runtime.getRuntime().freeMemory());
+                    }
+                    if (i < 1000000L) {
+                        inner.schedule(this);
+                    } else {
+                        latch.countDown();
+                    }
+                }
+            });
+    
+            latch.await();
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public void testRecursionAndOuterUnsubscribe() throws InterruptedException {
+        // use latches instead of Thread.sleep
+        final CountDownLatch latch = new CountDownLatch(10);
+        final CountDownLatch completionLatch = new CountDownLatch(1);
+        final Worker inner = getScheduler().createWorker();
+        try {
+            Observable<Integer> obs = Observable.create(new Publisher<Integer>() {
+                @Override
+                public void subscribe(final Subscriber<? super Integer> observer) {
+                    inner.schedule(new Runnable() {
+                        @Override
+                        public void run() {
+                            observer.onNext(42);
+                            latch.countDown();
+    
+                            // this will recursively schedule this task for execution again
+                            inner.schedule(this);
+                        }
+                    });
+    
+                    observer.onSubscribe(new Subscription() {
+    
+                        @Override
+                        public void cancel() {
+                            inner.dispose();
+                            observer.onComplete();
+                            completionLatch.countDown();
+                        }
+                        
+                        @Override
+                        public void request(long n) {
+                            
+                        }
+                    });
+    
+                }
+            });
+    
+            final AtomicInteger count = new AtomicInteger();
+            final AtomicBoolean completed = new AtomicBoolean(false);
+            AsyncObserver<Integer> s = new AsyncObserver<Integer>() {
+                @Override
+                public void onComplete() {
+                    System.out.println("Completed");
+                    completed.set(true);
+                }
+    
+                @Override
+                public void onError(Throwable e) {
+                    System.out.println("Error");
+                }
+    
+                @Override
+                public void onNext(Integer args) {
+                    count.incrementAndGet();
+                    System.out.println(args);
+                }
+            };
+            obs.subscribe(s);
+    
+            if (!latch.await(5000, TimeUnit.MILLISECONDS)) {
+                fail("Timed out waiting on onNext latch");
+            }
+    
+            // now unsubscribe and ensure it stops the recursive loop
+            s.dispose();
+            System.out.println("unsubscribe");
+    
+            if (!completionLatch.await(5000, TimeUnit.MILLISECONDS)) {
+                fail("Timed out waiting on completion latch");
+            }
+    
+            // the count can be 10 or higher due to thread scheduling of the unsubscribe vs the scheduler looping to emit the count
+            assertTrue(count.get() >= 10);
+            assertTrue(completed.get());
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public final void testSubscribeWithScheduler() throws InterruptedException {
+        final Scheduler scheduler = getScheduler();
+
+        final AtomicInteger count = new AtomicInteger();
+
+        Observable<Integer> o1 = Observable.<Integer> just(1, 2, 3, 4, 5);
+
+        o1.subscribe(new Consumer<Integer>() {
+
+            @Override
+            public void accept(Integer t) {
+                System.out.println("Thread: " + Thread.currentThread().getName());
+                System.out.println("t: " + t);
+                count.incrementAndGet();
+            }
+        });
+
+        // the above should be blocking so we should see a count of 5
+        assertEquals(5, count.get());
+
+        count.set(0);
+
+        // now we'll subscribe with a scheduler and it should be async
+
+        final String currentThreadName = Thread.currentThread().getName();
+
+        // latches for deterministically controlling the test below across threads
+        final CountDownLatch latch = new CountDownLatch(5);
+        final CountDownLatch first = new CountDownLatch(1);
+
+        o1.subscribeOn(scheduler).subscribe(new Consumer<Integer>() {
+
+            @Override
+            public void accept(Integer t) {
+                try {
+                    // we block the first one so we can assert this executes asynchronously with a count
+                    first.await(1000, TimeUnit.SECONDS);
+                } catch (InterruptedException e) {
+                    throw new RuntimeException("The latch should have released if we are async.", e);
+                }
+
+                assertFalse(Thread.currentThread().getName().equals(currentThreadName));
+                System.out.println("Thread: " + Thread.currentThread().getName());
+                System.out.println("t: " + t);
+                count.incrementAndGet();
+                latch.countDown();
+            }
+        });
+
+        // assert we are async
+        assertEquals(0, count.get());
+        // release the latch so it can go forward
+        first.countDown();
+
+        // wait for all 5 responses
+        latch.await();
+        assertEquals(5, count.get());
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/AbstractSchedulerTests.java b/src/test/java/io/reactivex/schedulers/AbstractSchedulerTests.java
new file mode 100644
index 0000000000..6b40c3fc32
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/AbstractSchedulerTests.java
@@ -0,0 +1,499 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+import java.util.function.*;
+
+import org.junit.Test;
+import org.mockito.InOrder;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.reactivestreams.*;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.Scheduler;
+import io.reactivex.internal.subscriptions.*;
+
+/**
+ * Base tests for all schedulers including Immediate/Current.
+ */
+public abstract class AbstractSchedulerTests {
+
+    /**
+     * The scheduler to test
+     */
+    protected abstract Scheduler getScheduler();
+
+    @Test
+    public void testNestedActions() throws InterruptedException {
+        Scheduler scheduler = getScheduler();
+        final Scheduler.Worker inner = scheduler.createWorker();
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+    
+            final Runnable firstStepStart = mock(Runnable.class);
+            final Runnable firstStepEnd = mock(Runnable.class);
+    
+            final Runnable secondStepStart = mock(Runnable.class);
+            final Runnable secondStepEnd = mock(Runnable.class);
+    
+            final Runnable thirdStepStart = mock(Runnable.class);
+            final Runnable thirdStepEnd = mock(Runnable.class);
+    
+            final Runnable firstAction = new Runnable() {
+                @Override
+                public void run() {
+                    firstStepStart.run();
+                    firstStepEnd.run();
+                    latch.countDown();
+                }
+            };
+            final Runnable secondAction = new Runnable() {
+                @Override
+                public void run() {
+                    secondStepStart.run();
+                    inner.schedule(firstAction);
+                    secondStepEnd.run();
+    
+                }
+            };
+            final Runnable thirdAction = new Runnable() {
+                @Override
+                public void run() {
+                    thirdStepStart.run();
+                    inner.schedule(secondAction);
+                    thirdStepEnd.run();
+                }
+            };
+    
+            InOrder inOrder = inOrder(firstStepStart, firstStepEnd, secondStepStart, secondStepEnd, thirdStepStart, thirdStepEnd);
+    
+            inner.schedule(thirdAction);
+    
+            latch.await();
+    
+            inOrder.verify(thirdStepStart, times(1)).run();
+            inOrder.verify(thirdStepEnd, times(1)).run();
+            inOrder.verify(secondStepStart, times(1)).run();
+            inOrder.verify(secondStepEnd, times(1)).run();
+            inOrder.verify(firstStepStart, times(1)).run();
+            inOrder.verify(firstStepEnd, times(1)).run();
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public final void testNestedScheduling() {
+
+        Observable<Integer> ids = Observable.fromIterable(Arrays.asList(1, 2)).subscribeOn(getScheduler());
+
+        Observable<String> m = ids.flatMap(new Function<Integer, Observable<String>>() {
+
+            @Override
+            public Observable<String> apply(Integer id) {
+                return Observable.fromIterable(Arrays.asList("a-" + id, "b-" + id)).subscribeOn(getScheduler())
+                        .map(new Function<String, String>() {
+
+                            @Override
+                            public String apply(String s) {
+                                return "names=>" + s;
+                            }
+                        });
+            }
+
+        });
+
+        List<String> strings = m.toList().toBlocking().last();
+
+        assertEquals(4, strings.size());
+        // because flatMap does a merge there is no guarantee of order
+        assertTrue(strings.contains("names=>a-1"));
+        assertTrue(strings.contains("names=>a-2"));
+        assertTrue(strings.contains("names=>b-1"));
+        assertTrue(strings.contains("names=>b-2"));
+    }
+
+    /**
+     * The order of execution is nondeterministic.
+     * 
+     * @throws InterruptedException
+     */
+    @SuppressWarnings("rawtypes")
+    @Test
+    public final void testSequenceOfActions() throws InterruptedException {
+        final Scheduler scheduler = getScheduler();
+        final Scheduler.Worker inner = scheduler.createWorker();
+        try {
+            final CountDownLatch latch = new CountDownLatch(2);
+            final Runnable first = mock(Runnable.class);
+            final Runnable second = mock(Runnable.class);
+    
+            // make it wait until both the first and second are called
+            doAnswer(new Answer() {
+    
+                @Override
+                public Object answer(InvocationOnMock invocation) throws Throwable {
+                    try {
+                        return invocation.getMock();
+                    } finally {
+                        latch.countDown();
+                    }
+                }
+            }).when(first).run();
+            doAnswer(new Answer() {
+    
+                @Override
+                public Object answer(InvocationOnMock invocation) throws Throwable {
+                    try {
+                        return invocation.getMock();
+                    } finally {
+                        latch.countDown();
+                    }
+                }
+            }).when(second).run();
+    
+            inner.schedule(first);
+            inner.schedule(second);
+    
+            latch.await();
+    
+            verify(first, times(1)).run();
+            verify(second, times(1)).run();
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public void testSequenceOfDelayedActions() throws InterruptedException {
+        Scheduler scheduler = getScheduler();
+        final Scheduler.Worker inner = scheduler.createWorker();
+        
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final Runnable first = mock(Runnable.class);
+            final Runnable second = mock(Runnable.class);
+    
+            inner.schedule(new Runnable() {
+                @Override
+                public void run() {
+                    inner.schedule(first, 30, TimeUnit.MILLISECONDS);
+                    inner.schedule(second, 10, TimeUnit.MILLISECONDS);
+                    inner.schedule(new Runnable() {
+    
+                        @Override
+                        public void run() {
+                            latch.countDown();
+                        }
+                    }, 40, TimeUnit.MILLISECONDS);
+                }
+            });
+    
+            latch.await();
+            InOrder inOrder = inOrder(first, second);
+    
+            inOrder.verify(second, times(1)).run();
+            inOrder.verify(first, times(1)).run();
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public void testMixOfDelayedAndNonDelayedActions() throws InterruptedException {
+        Scheduler scheduler = getScheduler();
+        final Scheduler.Worker inner = scheduler.createWorker();
+        
+        try {
+            final CountDownLatch latch = new CountDownLatch(1);
+            final Runnable first = mock(Runnable.class);
+            final Runnable second = mock(Runnable.class);
+            final Runnable third = mock(Runnable.class);
+            final Runnable fourth = mock(Runnable.class);
+    
+            inner.schedule(new Runnable() {
+                @Override
+                public void run() {
+                    inner.schedule(first);
+                    inner.schedule(second, 300, TimeUnit.MILLISECONDS);
+                    inner.schedule(third, 100, TimeUnit.MILLISECONDS);
+                    inner.schedule(fourth);
+                    inner.schedule(new Runnable() {
+    
+                        @Override
+                        public void run() {
+                            latch.countDown();
+                        }
+                    }, 400, TimeUnit.MILLISECONDS);
+                }
+            });
+    
+            latch.await();
+            InOrder inOrder = inOrder(first, second, third, fourth);
+    
+            inOrder.verify(first, times(1)).run();
+            inOrder.verify(fourth, times(1)).run();
+            inOrder.verify(third, times(1)).run();
+            inOrder.verify(second, times(1)).run();
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public final void testRecursiveExecution() throws InterruptedException {
+        final Scheduler scheduler = getScheduler();
+        final Scheduler.Worker inner = scheduler.createWorker();
+        
+        try {
+            
+            final AtomicInteger i = new AtomicInteger();
+            final CountDownLatch latch = new CountDownLatch(1);
+            inner.schedule(new Runnable() {
+    
+                @Override
+                public void run() {
+                    if (i.incrementAndGet() < 100) {
+                        inner.schedule(this);
+                    } else {
+                        latch.countDown();
+                    }
+                }
+            });
+    
+            latch.await();
+            assertEquals(100, i.get());
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public final void testRecursiveExecutionWithDelayTime() throws InterruptedException {
+        Scheduler scheduler = getScheduler();
+        final Scheduler.Worker inner = scheduler.createWorker();
+        
+        try {
+            final AtomicInteger i = new AtomicInteger();
+            final CountDownLatch latch = new CountDownLatch(1);
+    
+            inner.schedule(new Runnable() {
+    
+                int state = 0;
+    
+                @Override
+                public void run() {
+                    i.set(state);
+                    if (state++ < 100) {
+                        inner.schedule(this, 1, TimeUnit.MILLISECONDS);
+                    } else {
+                        latch.countDown();
+                    }
+                }
+    
+            });
+    
+            latch.await();
+            assertEquals(100, i.get());
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public final void testRecursiveSchedulerInObservable() {
+        Observable<Integer> obs = Observable.create(new Publisher<Integer>() {
+            @Override
+            public void subscribe(final Subscriber<? super Integer> observer) {
+                final Scheduler.Worker inner = getScheduler().createWorker();
+
+                AsyncSubscription as = new AsyncSubscription();
+                observer.onSubscribe(as);
+                as.setResource(inner);
+                
+                inner.schedule(new Runnable() {
+                    int i = 0;
+
+                    @Override
+                    public void run() {
+                        if (i > 42) {
+                            observer.onComplete();
+                            return;
+                        }
+
+                        observer.onNext(i++);
+
+                        inner.schedule(this);
+                    }
+                });
+            }
+        });
+
+        final AtomicInteger lastValue = new AtomicInteger();
+        obs.toBlocking().forEach(new Consumer<Integer>() {
+
+            @Override
+            public void accept(Integer v) {
+                System.out.println("Value: " + v);
+                lastValue.set(v);
+            }
+        });
+
+        assertEquals(42, lastValue.get());
+    }
+
+    @Test
+    public final void testConcurrentOnNextFailsValidation() throws InterruptedException {
+        final int count = 10;
+        final CountDownLatch latch = new CountDownLatch(count);
+        Observable<String> o = Observable.create(new Publisher<String>() {
+
+            @Override
+            public void subscribe(final Subscriber<? super String> observer) {
+                observer.onSubscribe(EmptySubscription.INSTANCE);
+                for (int i = 0; i < count; i++) {
+                    final int v = i;
+                    new Thread(new Runnable() {
+
+                        @Override
+                        public void run() {
+                            observer.onNext("v: " + v);
+
+                            latch.countDown();
+                        }
+                    }).start();
+                }
+            }
+        });
+
+        ConcurrentObserverValidator<String> observer = new ConcurrentObserverValidator<>();
+        // this should call onNext concurrently
+        o.subscribe(observer);
+
+        if (!observer.completed.await(3000, TimeUnit.MILLISECONDS)) {
+            fail("timed out");
+        }
+
+        if (observer.error.get() == null) {
+            fail("We expected error messages due to concurrency");
+        }
+    }
+
+    @Test
+    public final void testObserveOn() throws InterruptedException {
+        final Scheduler scheduler = getScheduler();
+
+        Observable<String> o = Observable.fromArray("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten");
+
+        ConcurrentObserverValidator<String> observer = new ConcurrentObserverValidator<>();
+
+        o.observeOn(scheduler).subscribe(observer);
+
+        if (!observer.completed.await(3000, TimeUnit.MILLISECONDS)) {
+            fail("timed out");
+        }
+
+        if (observer.error.get() != null) {
+            observer.error.get().printStackTrace();
+            fail("Error: " + observer.error.get().getMessage());
+        }
+    }
+
+    @Test
+    public final void testSubscribeOnNestedConcurrency() throws InterruptedException {
+        final Scheduler scheduler = getScheduler();
+
+        Observable<String> o = Observable.fromArray("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten")
+                .flatMap(new Function<String, Observable<String>>() {
+
+                    @Override
+                    public Observable<String> apply(final String v) {
+                        return Observable.create(new Publisher<String>() {
+
+                            @Override
+                            public void subscribe(Subscriber<? super String> observer) {
+                                observer.onSubscribe(EmptySubscription.INSTANCE);
+                                observer.onNext("value_after_map-" + v);
+                                observer.onComplete();
+                            }
+                        }).subscribeOn(scheduler);
+                    }
+                });
+
+        ConcurrentObserverValidator<String> observer = new ConcurrentObserverValidator<>();
+
+        o.subscribe(observer);
+
+        if (!observer.completed.await(3000, TimeUnit.MILLISECONDS)) {
+            fail("timed out");
+        }
+
+        if (observer.error.get() != null) {
+            observer.error.get().printStackTrace();
+            fail("Error: " + observer.error.get().getMessage());
+        }
+    }
+
+    /**
+     * Used to determine if onNext is being invoked concurrently.
+     * 
+     * @param <T>
+     */
+    private static class ConcurrentObserverValidator<T> extends Observer<T> {
+
+        final AtomicInteger concurrentCounter = new AtomicInteger();
+        final AtomicReference<Throwable> error = new AtomicReference<>();
+        final CountDownLatch completed = new CountDownLatch(1);
+
+        @Override
+        public void onComplete() {
+            completed.countDown();
+        }
+
+        @Override
+        public void onError(Throwable e) {
+            error.set(e);
+            completed.countDown();
+        }
+
+        @Override
+        public void onNext(T args) {
+            int count = concurrentCounter.incrementAndGet();
+            System.out.println("ConcurrentObserverValidator.onNext: " + args);
+            if (count > 1) {
+                onError(new RuntimeException("we should not have concurrent execution of onNext"));
+            }
+            try {
+                try {
+                    // take some time so other onNext calls could pile up (I haven't yet thought of a way to do this without sleeping)
+                    Thread.sleep(50);
+                } catch (InterruptedException e) {
+                    // ignore
+                }
+            } finally {
+                concurrentCounter.decrementAndGet();
+            }
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/CachedThreadSchedulerTest.java b/src/test/java/io/reactivex/schedulers/CachedThreadSchedulerTest.java
new file mode 100644
index 0000000000..b2d3091055
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/CachedThreadSchedulerTest.java
@@ -0,0 +1,85 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import static org.junit.Assert.assertTrue;
+
+import java.util.function.*;
+
+import org.junit.*;
+
+import io.reactivex.*;
+import io.reactivex.Scheduler.Worker;
+
+public class CachedThreadSchedulerTest extends AbstractSchedulerConcurrencyTests {
+
+    @Override
+    protected Scheduler getScheduler() {
+        return Schedulers.io();
+    }
+
+    /**
+     * IO scheduler defaults to using CachedThreadScheduler
+     */
+    @Test
+    public final void testIOScheduler() {
+
+        Observable<Integer> o1 = Observable.just(1, 2, 3, 4, 5);
+        Observable<Integer> o2 = Observable.just(6, 7, 8, 9, 10);
+        Observable<String> o = Observable.merge(o1, o2).map(new Function<Integer, String>() {
+
+            @Override
+            public String apply(Integer t) {
+                assertTrue(Thread.currentThread().getName().startsWith("RxCachedThreadScheduler"));
+                return "Value_" + t + "_Thread_" + Thread.currentThread().getName();
+            }
+        });
+
+        o.subscribeOn(Schedulers.io()).toBlocking().forEach(new Consumer<String>() {
+
+            @Override
+            public void accept(String t) {
+                System.out.println("t: " + t);
+            }
+        });
+    }
+
+    @Test
+    @Ignore("Unhandled errors are no longer thrown")
+    public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
+        SchedulerTests.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
+    }
+
+    @Test
+    public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
+        SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
+    }
+    
+    @Test(timeout = 30000)
+    public void testCancelledTaskRetention() throws InterruptedException {
+        Worker w = Schedulers.io().createWorker();
+        try {
+            ExecutorSchedulerTest.testCancelledRetention(w, false);
+        } finally {
+            w.dispose();
+        }
+        w = Schedulers.io().createWorker();
+        try {
+            ExecutorSchedulerTest.testCancelledRetention(w, true);
+        } finally {
+            w.dispose();
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/ComputationSchedulerTests.java b/src/test/java/io/reactivex/schedulers/ComputationSchedulerTests.java
new file mode 100644
index 0000000000..7ed0644185
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/ComputationSchedulerTests.java
@@ -0,0 +1,165 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import static org.junit.Assert.*;
+
+import java.util.HashMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.function.*;
+
+import org.junit.*;
+
+import io.reactivex.*;
+import io.reactivex.Scheduler.Worker;
+
+public class ComputationSchedulerTests extends AbstractSchedulerConcurrencyTests {
+
+    @Override
+    protected Scheduler getScheduler() {
+        // this is an implementation of ExecutorScheduler
+        return Schedulers.computation();
+    }
+
+    @Test
+    public void testThreadSafetyWhenSchedulerIsHoppingBetweenThreads() {
+
+        final int NUM = 1000000;
+        final CountDownLatch latch = new CountDownLatch(1);
+        final HashMap<String, Integer> map = new HashMap<>();
+
+        final Scheduler.Worker inner = Schedulers.computation().createWorker();
+        
+        try {
+            inner.schedule(new Runnable() {
+    
+                private HashMap<String, Integer> statefulMap = map;
+                int nonThreadSafeCounter = 0;
+    
+                @Override
+                public void run() {
+                    Integer i = statefulMap.get("a");
+                    if (i == null) {
+                        i = 1;
+                        statefulMap.put("a", i);
+                        statefulMap.put("b", i);
+                    } else {
+                        i++;
+                        statefulMap.put("a", i);
+                        statefulMap.put("b", i);
+                    }
+                    nonThreadSafeCounter++;
+                    statefulMap.put("nonThreadSafeCounter", nonThreadSafeCounter);
+                    if (i < NUM) {
+                        inner.schedule(this);
+                    } else {
+                        latch.countDown();
+                    }
+                }
+            });
+    
+            try {
+                latch.await();
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+    
+            System.out.println("Count A: " + map.get("a"));
+            System.out.println("Count B: " + map.get("b"));
+            System.out.println("nonThreadSafeCounter: " + map.get("nonThreadSafeCounter"));
+    
+            assertEquals(NUM, map.get("a").intValue());
+            assertEquals(NUM, map.get("b").intValue());
+            assertEquals(NUM, map.get("nonThreadSafeCounter").intValue());
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public final void testComputationThreadPool1() {
+        Observable<Integer> o1 = Observable.<Integer> just(1, 2, 3, 4, 5);
+        Observable<Integer> o2 = Observable.<Integer> just(6, 7, 8, 9, 10);
+        Observable<String> o = Observable.<Integer> merge(o1, o2).map(new Function<Integer, String>() {
+
+            @Override
+            public String apply(Integer t) {
+                assertTrue(Thread.currentThread().getName().startsWith("RxComputationThreadPool"));
+                return "Value_" + t + "_Thread_" + Thread.currentThread().getName();
+            }
+        });
+
+        o.subscribeOn(Schedulers.computation()).toBlocking().forEach(new Consumer<String>() {
+
+            @Override
+            public void accept(String t) {
+                System.out.println("t: " + t);
+            }
+        });
+    }
+
+
+    @Test
+    public final void testMergeWithExecutorScheduler() {
+
+        final String currentThreadName = Thread.currentThread().getName();
+
+        Observable<Integer> o1 = Observable.<Integer> just(1, 2, 3, 4, 5);
+        Observable<Integer> o2 = Observable.<Integer> just(6, 7, 8, 9, 10);
+        Observable<String> o = Observable.<Integer> merge(o1, o2).subscribeOn(Schedulers.computation()).map(new Function<Integer, String>() {
+
+            @Override
+            public String apply(Integer t) {
+                assertFalse(Thread.currentThread().getName().equals(currentThreadName));
+                assertTrue(Thread.currentThread().getName().startsWith("RxComputationThreadPool"));
+                return "Value_" + t + "_Thread_" + Thread.currentThread().getName();
+            }
+        });
+
+        o.toBlocking().forEach(new Consumer<String>() {
+
+            @Override
+            public void accept(String t) {
+                System.out.println("t: " + t);
+            }
+        });
+    }
+
+    @Test
+    @Ignore("Unhandled errors are no longer thrown")
+    public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
+        SchedulerTests.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
+    }
+
+    @Test
+    public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
+        SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
+    }
+    
+    @Test(timeout = 30000)
+    public void testCancelledTaskRetention() throws InterruptedException {
+        Worker w = Schedulers.computation().createWorker();
+        try {
+            ExecutorSchedulerTest.testCancelledRetention(w, false);
+        } finally {
+            w.dispose();
+        }
+        w = Schedulers.computation().createWorker();
+        try {
+            ExecutorSchedulerTest.testCancelledRetention(w, true);
+        } finally {
+            w.dispose();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java b/src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java
new file mode 100644
index 0000000000..ef53811add
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/ExecutorSchedulerTest.java
@@ -0,0 +1,278 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import static org.junit.Assert.*;
+
+import java.lang.management.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.*;
+
+import io.reactivex.Scheduler;
+import io.reactivex.Scheduler.Worker;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.schedulers.RxThreadFactory;
+
+public class ExecutorSchedulerTest extends AbstractSchedulerConcurrencyTests {
+
+    final static Executor executor = Executors.newFixedThreadPool(2, new RxThreadFactory("TestCustomPool-"));
+    
+    @Override
+    protected Scheduler getScheduler() {
+        return Schedulers.from(executor);
+    }
+
+    @Test
+    @Ignore("Unhandled errors are no longer thrown")
+    public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
+        SchedulerTests.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
+    }
+
+    @Test
+    public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
+        SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
+    }
+    
+    public static void testCancelledRetention(Scheduler.Worker w, boolean periodic) throws InterruptedException {
+        System.out.println("Wait before GC");
+        Thread.sleep(1000);
+        
+        System.out.println("GC");
+        System.gc();
+        
+        Thread.sleep(1000);
+
+        
+        MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();
+        MemoryUsage memHeap = memoryMXBean.getHeapMemoryUsage();
+        long initial = memHeap.getUsed();
+        
+        System.out.printf("Starting: %.3f MB%n", initial / 1024.0 / 1024.0);
+
+        int n = 500 * 1000;
+        if (periodic) {
+            final CountDownLatch cdl = new CountDownLatch(n);
+            final Runnable action = new Runnable() {
+                @Override
+                public void run() {
+                    cdl.countDown();
+                }
+            };
+            for (int i = 0; i < n; i++) {
+                if (i % 50000 == 0) {
+                    System.out.println("  -> still scheduling: " + i);
+                }
+                w.schedulePeriodically(action, 0, 1, TimeUnit.DAYS);
+            }
+            
+            System.out.println("Waiting for the first round to finish...");
+            cdl.await();
+        } else {
+            for (int i = 0; i < n; i++) {
+                if (i % 50000 == 0) {
+                    System.out.println("  -> still scheduling: " + i);
+                }
+                w.schedule(() -> { }, 1, TimeUnit.DAYS);
+            }
+        }
+        
+        memHeap = memoryMXBean.getHeapMemoryUsage();
+        long after = memHeap.getUsed();
+        System.out.printf("Peak: %.3f MB%n", after / 1024.0 / 1024.0);
+        
+        w.dispose();
+        
+        System.out.println("Wait before second GC");
+        Thread.sleep(1000 + 2000);
+        
+        System.out.println("Second GC");
+        System.gc();
+        
+        Thread.sleep(1000);
+        
+        memHeap = memoryMXBean.getHeapMemoryUsage();
+        long finish = memHeap.getUsed();
+        System.out.printf("After: %.3f MB%n", finish / 1024.0 / 1024.0);
+        
+        if (finish > initial * 5) {
+            fail(String.format("Tasks retained: %.3f -> %.3f -> %.3f", initial / 1024 / 1024.0, after / 1024 / 1024.0, finish / 1024 / 1024d));
+        }
+    }
+    
+    @Test(timeout = 30000)
+    public void testCancelledTaskRetention() throws InterruptedException {
+        ExecutorService exec = Executors.newSingleThreadExecutor();
+        Scheduler s = Schedulers.from(exec);
+        try {
+            Scheduler.Worker w = s.createWorker();
+            try {
+                testCancelledRetention(w, false);
+            } finally {
+                w.dispose();
+            }
+            
+            w = s.createWorker();
+            try {
+                testCancelledRetention(w, true);
+            } finally {
+                w.dispose();
+            }
+        } finally {
+            exec.shutdownNow();
+        }
+    }
+    
+    /** A simple executor which queues tasks and executes them one-by-one if executeOne() is called. */
+    static final class TestExecutor implements Executor {
+        final ConcurrentLinkedQueue<Runnable> queue = new ConcurrentLinkedQueue<>();
+        @Override
+        public void execute(Runnable command) {
+            queue.offer(command);
+        }
+        public void executeOne() {
+            Runnable r = queue.poll();
+            if (r != null) {
+                r.run();
+            }
+        }
+        public void executeAll() {
+            Runnable r;
+            while ((r = queue.poll()) != null) {
+                r.run();
+            }
+        }
+    }
+    
+    @Test
+    public void testCancelledTasksDontRun() {
+        final AtomicInteger calls = new AtomicInteger();
+        Runnable task = new Runnable() {
+            @Override
+            public void run() {
+                calls.getAndIncrement();
+            }
+        };
+        TestExecutor exec = new TestExecutor();
+        Scheduler custom = Schedulers.from(exec);
+        Worker w = custom.createWorker();
+        try {
+            Disposable s1 = w.schedule(task);
+            Disposable s2 = w.schedule(task);
+            Disposable s3 = w.schedule(task);
+            
+            s1.dispose();
+            s2.dispose();
+            s3.dispose();
+            
+            exec.executeAll();
+            
+            assertEquals(0, calls.get());
+        } finally {
+            w.dispose();
+        }
+    }
+    @Test
+    public void testCancelledWorkerDoesntRunTasks() {
+        final AtomicInteger calls = new AtomicInteger();
+        Runnable task = new Runnable() {
+            @Override
+            public void run() {
+                calls.getAndIncrement();
+            }
+        };
+        TestExecutor exec = new TestExecutor();
+        Scheduler custom = Schedulers.from(exec);
+        Worker w = custom.createWorker();
+        try {
+            w.schedule(task);
+            w.schedule(task);
+            w.schedule(task);
+        } finally {
+            w.dispose();
+        }
+        exec.executeAll();
+        assertEquals(0, calls.get());
+    }
+    
+    // FIXME the internal structure changed and these can't be tested
+//    
+//    @Test
+//    public void testNoTimedTaskAfterScheduleRetention() throws InterruptedException {
+//        Executor e = new Executor() {
+//            @Override
+//            public void execute(Runnable command) {
+//                command.run();
+//            }
+//        };
+//        ExecutorWorker w = (ExecutorWorker)Schedulers.from(e).createWorker();
+//        
+//        w.schedule(() -> { }, 50, TimeUnit.MILLISECONDS);
+//        
+//        assertTrue(w.tasks.hasSubscriptions());
+//        
+//        Thread.sleep(150);
+//        
+//        assertFalse(w.tasks.hasSubscriptions());
+//    }
+//    
+//    @Test
+//    public void testNoTimedTaskPartRetention() {
+//        Executor e = new Executor() {
+//            @Override
+//            public void execute(Runnable command) {
+//                
+//            }
+//        };
+//        ExecutorWorker w = (ExecutorWorker)Schedulers.from(e).createWorker();
+//        
+//        Disposable s = w.schedule(() -> { }, 1, TimeUnit.DAYS);
+//        
+//        assertTrue(w.tasks.hasSubscriptions());
+//        
+//        s.dispose();
+//        
+//        assertFalse(w.tasks.hasSubscriptions());
+//    }
+//    
+//    @Test
+//    public void testNoPeriodicTimedTaskPartRetention() throws InterruptedException {
+//        Executor e = new Executor() {
+//            @Override
+//            public void execute(Runnable command) {
+//                command.run();
+//            }
+//        };
+//        ExecutorWorker w = (ExecutorWorker)Schedulers.from(e).createWorker();
+//        
+//        final CountDownLatch cdl = new CountDownLatch(1);
+//        final Runnable action = new Runnable() {
+//            @Override
+//            public void run() {
+//                cdl.countDown();
+//            }
+//        };
+//        
+//        Disposable s = w.schedulePeriodically(action, 0, 1, TimeUnit.DAYS);
+//        
+//        assertTrue(w.tasks.hasSubscriptions());
+//        
+//        cdl.await();
+//        
+//        s.dispose();
+//        
+//        assertFalse(w.tasks.hasSubscriptions());
+//    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java b/src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java
new file mode 100644
index 0000000000..3ec60e9742
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java
@@ -0,0 +1,77 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import org.junit.*;
+
+import io.reactivex.Scheduler;
+
+public class NewThreadSchedulerTest extends AbstractSchedulerConcurrencyTests {
+
+    @Override
+    protected Scheduler getScheduler() {
+        return Schedulers.newThread();
+    }
+
+    @Test
+    @Ignore("Unhandled errors are no longer thrown")
+    public final void testUnhandledErrorIsDeliveredToThreadHandler() throws InterruptedException {
+        SchedulerTests.testUnhandledErrorIsDeliveredToThreadHandler(getScheduler());
+    }
+
+    @Test
+    public final void testHandledErrorIsNotDeliveredToThreadHandler() throws InterruptedException {
+        SchedulerTests.testHandledErrorIsNotDeliveredToThreadHandler(getScheduler());
+    }
+    
+    // FIXME no longer testable due to internal changes
+//    @Test(timeout = 3000)
+//    public void testNoSelfInterrupt() throws InterruptedException {
+//        Scheduler.Worker worker = Schedulers.newThread().createWorker();
+//        try {
+//            final CountDownLatch run = new CountDownLatch(1);
+//            final CountDownLatch done = new CountDownLatch(1);
+//            final AtomicReference<Throwable> exception = new AtomicReference<>();
+//            final AtomicBoolean interruptFlag = new AtomicBoolean();
+//            
+//            ScheduledRunnable sa = (ScheduledRunnable)worker.schedule(new Runnable() {
+//                @Override
+//                public void run() {
+//                    try {
+//                        run.await();
+//                    } catch (InterruptedException ex) {
+//                        exception.set(ex);
+//                    }
+//                }
+//            });
+//            
+//            sa.add(new Disposable() {
+//                @Override
+//                public void dispose() {
+//                    interruptFlag.set(Thread.currentThread().isInterrupted());
+//                    done.countDown();
+//                }
+//            });
+//            
+//            run.countDown();
+//            
+//            done.await();
+//            
+//            Assert.assertEquals(null, exception.get());
+//            Assert.assertFalse("Interrupted?!", interruptFlag.get());
+//        } finally {
+//            worker.dispose();
+//        }
+//    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/SchedulerLifecycleTest.java b/src/test/java/io/reactivex/schedulers/SchedulerLifecycleTest.java
new file mode 100644
index 0000000000..fbdfba5e81
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/SchedulerLifecycleTest.java
@@ -0,0 +1,133 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import static org.junit.Assert.*;
+
+import java.util.*;
+import java.util.concurrent.*;
+
+import org.junit.Test;
+
+import io.reactivex.Scheduler.Worker;
+import io.reactivex.disposables.CompositeDisposable;
+
+public class SchedulerLifecycleTest {
+    @Test
+    public void testShutdown() throws InterruptedException {
+        tryOutSchedulers();
+        
+        System.out.println("testShutdown >> Giving time threads to spin-up");
+        Thread.sleep(500);
+        
+        Set<Thread> rxThreads = new HashSet<>();
+        for (Thread t : Thread.getAllStackTraces().keySet()) {
+            if (t.getName().startsWith("Rx")) {
+                rxThreads.add(t);
+            }
+        }
+        Schedulers.shutdown();
+        System.out.println("testShutdown >> Giving time to threads to stop");
+        Thread.sleep(500);
+        
+        StringBuilder b = new StringBuilder();
+        for (Thread t : rxThreads) {
+            if (t.isAlive()) {
+                b.append("Thread " + t + " failed to shutdown\r\n");
+                for (StackTraceElement ste : t.getStackTrace()) {
+                    b.append("  ").append(ste).append("\r\n");
+                }
+            }
+        }
+        if (b.length() > 0) {
+            System.out.print(b);
+            System.out.println("testShutdown >> Restarting schedulers...");
+            Schedulers.start(); // restart them anyways
+            fail("Rx Threads were still alive:\r\n" + b);
+        }
+        
+        System.out.println("testShutdown >> Restarting schedulers...");
+        Schedulers.start();
+        
+        tryOutSchedulers();
+    }
+
+    private void tryOutSchedulers() throws InterruptedException {
+        final CountDownLatch cdl = new CountDownLatch(4);
+        
+        final Runnable countAction = new Runnable() {
+            @Override
+            public void run() {
+                cdl.countDown();
+            }
+        };
+        
+        CompositeDisposable csub = new CompositeDisposable();
+        
+        try {
+            Worker w1 = Schedulers.computation().createWorker();
+            csub.add(w1);
+            w1.schedule(countAction);
+            
+            Worker w2 = Schedulers.io().createWorker();
+            csub.add(w2);
+            w2.schedule(countAction);
+            
+            Worker w3 = Schedulers.newThread().createWorker();
+            csub.add(w3);
+            w3.schedule(countAction);
+            
+            Worker w4 = Schedulers.single().createWorker();
+            csub.add(w4);
+            w4.schedule(countAction);
+            
+            
+            if (!cdl.await(3, TimeUnit.SECONDS)) {
+                fail("countAction was not run by every worker");
+            }
+        } finally {
+            csub.dispose();
+        }
+    }
+    
+    @Test
+    public void testStartIdempotence() throws InterruptedException {
+        tryOutSchedulers();
+        
+        System.out.println("testStartIdempotence >> giving some time");
+        Thread.sleep(500);
+        
+        Set<Thread> rxThreads = new HashSet<>();
+        for (Thread t : Thread.getAllStackTraces().keySet()) {
+            if (t.getName().startsWith("Rx")) {
+                rxThreads.add(t);
+                System.out.println("testStartIdempotence >> " + t);
+            }
+        }
+        System.out.println("testStartIdempotence >> trying to start again");
+        Schedulers.start();
+        System.out.println("testStartIdempotence >> giving some time again");
+        Thread.sleep(500);
+        
+        Set<Thread> rxThreads2 = new HashSet<>();
+        for (Thread t : Thread.getAllStackTraces().keySet()) {
+            if (t.getName().startsWith("Rx")) {
+                rxThreads2.add(t);
+                System.out.println("testStartIdempotence >>>> " + t);
+            }
+        }
+        
+        assertEquals(rxThreads, rxThreads2);
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/SchedulerTests.java b/src/test/java/io/reactivex/schedulers/SchedulerTests.java
new file mode 100644
index 0000000000..6bbfd468f7
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/SchedulerTests.java
@@ -0,0 +1,134 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import static org.junit.Assert.*;
+
+import java.util.concurrent.*;
+
+import io.reactivex.*;
+
+final class SchedulerTests {
+    private SchedulerTests() {
+        // No instances.
+    }
+
+    /**
+     * Verifies that the given Scheduler delivers unhandled errors to its executing thread's
+     * {@link java.lang.Thread.UncaughtExceptionHandler}.
+     * <p>
+     * Schedulers which execute on a separate thread from their calling thread should exhibit this behavior. Schedulers
+     * which execute on their calling thread may not.
+     */
+    static void testUnhandledErrorIsDeliveredToThreadHandler(Scheduler scheduler) throws InterruptedException {
+        Thread.UncaughtExceptionHandler originalHandler = Thread.getDefaultUncaughtExceptionHandler();
+        try {
+            CapturingUncaughtExceptionHandler handler = new CapturingUncaughtExceptionHandler();
+            Thread.setDefaultUncaughtExceptionHandler(handler);
+            IllegalStateException error = new IllegalStateException("Should be delivered to handler");
+            Observable.error(error)
+                    .subscribeOn(scheduler)
+                    .subscribe();
+
+            if (!handler.completed.await(3, TimeUnit.SECONDS)) {
+                fail("timed out");
+            }
+
+            assertEquals("Should have received exactly 1 exception", 1, handler.count);
+            Throwable cause = handler.caught;
+            while (cause != null) {
+                if (error.equals(cause)) break;
+                if (cause == cause.getCause()) break;
+                cause = cause.getCause();
+            }
+            assertEquals("Our error should have been delivered to the handler", error, cause);
+        } finally {
+            Thread.setDefaultUncaughtExceptionHandler(originalHandler);
+        }
+    }
+
+    /**
+     * Verifies that the given Scheduler does not deliver handled errors to its executing Thread's
+     * {@link java.lang.Thread.UncaughtExceptionHandler}.
+     * <p>
+     * This is a companion test to {@link #testUnhandledErrorIsDeliveredToThreadHandler}, and is needed only for the
+     * same Schedulers.
+     */
+    static void testHandledErrorIsNotDeliveredToThreadHandler(Scheduler scheduler) throws InterruptedException {
+        Thread.UncaughtExceptionHandler originalHandler = Thread.getDefaultUncaughtExceptionHandler();
+        try {
+            CapturingUncaughtExceptionHandler handler = new CapturingUncaughtExceptionHandler();
+            CapturingObserver<Object> observer = new CapturingObserver<>();
+            Thread.setDefaultUncaughtExceptionHandler(handler);
+            IllegalStateException error = new IllegalStateException("Should be delivered to handler");
+            Observable.error(error)
+                    .subscribeOn(scheduler)
+                    .subscribe(observer);
+
+            if (!observer.completed.await(3, TimeUnit.SECONDS)) {
+                fail("timed out");
+            }
+
+            assertEquals("Handler should not have received anything", 0, handler.count);
+            assertEquals("Observer should have received an error", 1, observer.errorCount);
+            assertEquals("Observer should not have received a next value", 0, observer.nextCount);
+
+            Throwable cause = observer.error;
+            while (cause != null) {
+                if (error.equals(cause)) break;
+                if (cause == cause.getCause()) break;
+                cause = cause.getCause();
+            }
+            assertEquals("Our error should have been delivered to the observer", error, cause);
+        } finally {
+            Thread.setDefaultUncaughtExceptionHandler(originalHandler);
+        }
+    }
+
+    private static final class CapturingUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
+        int count = 0;
+        Throwable caught;
+        CountDownLatch completed = new CountDownLatch(1);
+
+        @Override
+        public void uncaughtException(Thread t, Throwable e) {
+            count++;
+            caught = e;
+            completed.countDown();
+        }
+    }
+
+    private static final class CapturingObserver<T> extends Observer<T> {
+        CountDownLatch completed = new CountDownLatch(1);
+        int errorCount = 0;
+        int nextCount = 0;
+        Throwable error;
+
+        @Override
+        public void onComplete() {
+        }
+
+        @Override
+        public void onError(Throwable e) {
+            errorCount++;
+            error = e;
+            completed.countDown();
+        }
+
+        @Override
+        public void onNext(T t) {
+            nextCount++;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java b/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java
new file mode 100644
index 0000000000..0489a55ffb
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java
@@ -0,0 +1,219 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Matchers.anyLong;
+import static org.mockito.Mockito.*;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Function;
+
+import org.junit.Test;
+import org.mockito.*;
+import org.reactivestreams.*;
+
+import io.reactivex.*;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+
+public class TestSchedulerTest {
+
+    @SuppressWarnings("unchecked")
+    // mocking is unchecked, unfortunately
+    @Test
+    public final void testPeriodicScheduling() {
+        final Function<Long, Void> calledOp = mock(Function.class);
+
+        final TestScheduler scheduler = new TestScheduler();
+        final Scheduler.Worker inner = scheduler.createWorker();
+        
+        try {
+            inner.schedulePeriodically(new Runnable() {
+                @Override
+                public void run() {
+                    System.out.println(scheduler.now(TimeUnit.MILLISECONDS));
+                    calledOp.apply(scheduler.now(TimeUnit.MILLISECONDS));
+                }
+            }, 1, 2, TimeUnit.SECONDS);
+    
+            verify(calledOp, never()).apply(anyLong());
+    
+            InOrder inOrder = Mockito.inOrder(calledOp);
+    
+            scheduler.advanceTimeBy(999L, TimeUnit.MILLISECONDS);
+            inOrder.verify(calledOp, never()).apply(anyLong());
+    
+            scheduler.advanceTimeBy(1L, TimeUnit.MILLISECONDS);
+            inOrder.verify(calledOp, times(1)).apply(1000L);
+    
+            scheduler.advanceTimeBy(1999L, TimeUnit.MILLISECONDS);
+            inOrder.verify(calledOp, never()).apply(3000L);
+    
+            scheduler.advanceTimeBy(1L, TimeUnit.MILLISECONDS);
+            inOrder.verify(calledOp, times(1)).apply(3000L);
+    
+            scheduler.advanceTimeBy(5L, TimeUnit.SECONDS);
+            inOrder.verify(calledOp, times(1)).apply(5000L);
+            inOrder.verify(calledOp, times(1)).apply(7000L);
+    
+            inner.dispose();
+            scheduler.advanceTimeBy(11L, TimeUnit.SECONDS);
+            inOrder.verify(calledOp, never()).apply(anyLong());
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    // mocking is unchecked, unfortunately
+    @Test
+    public final void testPeriodicSchedulingUnsubscription() {
+        final Function<Long, Void> calledOp = mock(Function.class);
+
+        final TestScheduler scheduler = new TestScheduler();
+        final Scheduler.Worker inner = scheduler.createWorker();
+
+        try {
+            final Disposable subscription = inner.schedulePeriodically(new Runnable() {
+                @Override
+                public void run() {
+                    System.out.println(scheduler.now(TimeUnit.MILLISECONDS));
+                    calledOp.apply(scheduler.now(TimeUnit.MILLISECONDS));
+                }
+            }, 1, 2, TimeUnit.SECONDS);
+    
+            verify(calledOp, never()).apply(anyLong());
+    
+            InOrder inOrder = Mockito.inOrder(calledOp);
+    
+            scheduler.advanceTimeBy(999L, TimeUnit.MILLISECONDS);
+            inOrder.verify(calledOp, never()).apply(anyLong());
+    
+            scheduler.advanceTimeBy(1L, TimeUnit.MILLISECONDS);
+            inOrder.verify(calledOp, times(1)).apply(1000L);
+    
+            scheduler.advanceTimeBy(1999L, TimeUnit.MILLISECONDS);
+            inOrder.verify(calledOp, never()).apply(3000L);
+    
+            scheduler.advanceTimeBy(1L, TimeUnit.MILLISECONDS);
+            inOrder.verify(calledOp, times(1)).apply(3000L);
+    
+            scheduler.advanceTimeBy(5L, TimeUnit.SECONDS);
+            inOrder.verify(calledOp, times(1)).apply(5000L);
+            inOrder.verify(calledOp, times(1)).apply(7000L);
+    
+            subscription.dispose();
+            scheduler.advanceTimeBy(11L, TimeUnit.SECONDS);
+            inOrder.verify(calledOp, never()).apply(anyLong());
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public final void testImmediateUnsubscribes() {
+        TestScheduler s = new TestScheduler();
+        final Scheduler.Worker inner = s.createWorker();
+        final AtomicInteger counter = new AtomicInteger(0);
+        
+        try {
+            inner.schedule(new Runnable() {
+    
+                @Override
+                public void run() {
+                    counter.incrementAndGet();
+                    System.out.println("counter: " + counter.get());
+                    inner.schedule(this);
+                }
+    
+            });
+            inner.dispose();
+            assertEquals(0, counter.get());
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public final void testImmediateUnsubscribes2() {
+        TestScheduler s = new TestScheduler();
+        final Scheduler.Worker inner = s.createWorker();
+        try {
+            final AtomicInteger counter = new AtomicInteger(0);
+    
+            final Disposable subscription = inner.schedule(new Runnable() {
+    
+                @Override
+                public void run() {
+                    counter.incrementAndGet();
+                    System.out.println("counter: " + counter.get());
+                    inner.schedule(this);
+                }
+    
+            });
+            subscription.dispose();
+            assertEquals(0, counter.get());
+        } finally {
+            inner.dispose();
+        }
+    }
+
+    @Test
+    public final void testNestedSchedule() {
+        final TestScheduler scheduler = new TestScheduler();
+        final Scheduler.Worker inner = scheduler.createWorker();
+        
+        try {
+            final Runnable calledOp = mock(Runnable.class);
+    
+            Observable<Object> poller;
+            poller = Observable.create(new Publisher<Object>() {
+                @Override
+                public void subscribe(final Subscriber<? super Object> aSubscriber) {
+                    BooleanSubscription bs = new BooleanSubscription();
+                    aSubscriber.onSubscribe(bs);
+                    inner.schedule(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (!bs.isCancelled()) {
+                                calledOp.run();
+                                inner.schedule(this, 5, TimeUnit.SECONDS);
+                            }
+                        }
+                    });
+                }
+            });
+    
+            InOrder inOrder = Mockito.inOrder(calledOp);
+    
+            Disposable sub;
+            sub = poller.subscribe();
+    
+            scheduler.advanceTimeTo(6, TimeUnit.SECONDS);
+            inOrder.verify(calledOp, times(2)).run();
+    
+            sub.dispose();
+            scheduler.advanceTimeTo(11, TimeUnit.SECONDS);
+            inOrder.verify(calledOp, never()).run();
+    
+            sub = poller.subscribe();
+            scheduler.advanceTimeTo(12, TimeUnit.SECONDS);
+            inOrder.verify(calledOp, times(1)).run();
+        } finally {
+            inner.dispose();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/TrampolineSchedulerTest.java b/src/test/java/io/reactivex/schedulers/TrampolineSchedulerTest.java
new file mode 100644
index 0000000000..8f8d190344
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/TrampolineSchedulerTest.java
@@ -0,0 +1,150 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import static org.junit.Assert.*;
+
+import java.util.*;
+import java.util.concurrent.TimeUnit;
+import java.util.function.*;
+
+import org.junit.Test;
+import org.reactivestreams.Subscriber;
+
+import io.reactivex.*;
+import io.reactivex.Observable;
+import io.reactivex.Scheduler.Worker;
+import io.reactivex.disposables.*;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class TrampolineSchedulerTest extends AbstractSchedulerTests {
+
+    @Override
+    protected Scheduler getScheduler() {
+        return Schedulers.trampoline();
+    }
+
+    @Test
+    public final void testMergeWithCurrentThreadScheduler1() {
+
+        final String currentThreadName = Thread.currentThread().getName();
+
+        Observable<Integer> o1 = Observable.<Integer> just(1, 2, 3, 4, 5);
+        Observable<Integer> o2 = Observable.<Integer> just(6, 7, 8, 9, 10);
+        Observable<String> o = Observable.<Integer> merge(o1, o2).subscribeOn(Schedulers.trampoline()).map(new Function<Integer, String>() {
+
+            @Override
+            public String apply(Integer t) {
+                assertTrue(Thread.currentThread().getName().equals(currentThreadName));
+                return "Value_" + t + "_Thread_" + Thread.currentThread().getName();
+            }
+        });
+
+        o.toBlocking().forEach(new Consumer<String>() {
+
+            @Override
+            public void accept(String t) {
+                System.out.println("t: " + t);
+            }
+        });
+    }
+
+    @Test
+    public void testNestedTrampolineWithUnsubscribe() {
+        final ArrayList<String> workDone = new ArrayList<>();
+        final CompositeDisposable workers = new CompositeDisposable();
+        Worker worker = Schedulers.trampoline().createWorker();
+        try {
+            workers.add(worker);
+            worker.schedule(new Runnable() {
+    
+                @Override
+                public void run() {
+                    workers.add(doWorkOnNewTrampoline("A", workDone));
+                }
+    
+            });
+    
+            final Worker worker2 = Schedulers.trampoline().createWorker();
+            workers.add(worker2);
+            worker2.schedule(new Runnable() {
+    
+                @Override
+                public void run() {
+                    workers.add(doWorkOnNewTrampoline("B", workDone));
+                    // we unsubscribe worker2 ... it should not affect work scheduled on a separate Trampline.Worker
+                    worker2.dispose();
+                }
+    
+            });
+        
+            assertEquals(6, workDone.size());
+            assertEquals(Arrays.asList("A.1", "A.B.1", "A.B.2", "B.1", "B.B.1", "B.B.2"), workDone);
+        } finally {
+            workers.dispose();
+        }
+    }
+
+    /**
+     * This is a regression test for #1702. Concurrent work scheduling that is improperly synchronized can cause an
+     * action to be added or removed onto the priority queue during a poll, which can result in NPEs during queue
+     * sifting. While it is difficult to isolate the issue directly, we can easily trigger the behavior by spamming the
+     * trampoline with enqueue requests from multiple threads concurrently.
+     */
+    @Test
+    public void testTrampolineWorkerHandlesConcurrentScheduling() {
+        final Worker trampolineWorker = Schedulers.trampoline().createWorker();
+        final Subscriber<Object> observer = TestHelper.mockSubscriber();
+        final TestSubscriber<Disposable> ts = new TestSubscriber<>(observer);
+
+        // Spam the trampoline with actions.
+        Observable.range(0, 50)
+                .flatMap(count -> Observable.interval(1, TimeUnit.MICROSECONDS).map(
+                        count1 -> trampolineWorker.schedule(() -> {})).take(100))
+                .subscribeOn(Schedulers.computation())
+                .subscribe(ts);
+        ts.awaitTerminalEvent();
+        ts.assertNoErrors();
+    }
+
+    private static Worker doWorkOnNewTrampoline(final String key, final ArrayList<String> workDone) {
+        Worker worker = Schedulers.trampoline().createWorker();
+        worker.schedule(new Runnable() {
+
+            @Override
+            public void run() {
+                String msg = key + ".1";
+                workDone.add(msg);
+                System.out.println(msg);
+                Worker worker3 = Schedulers.trampoline().createWorker();
+                worker3.schedule(createPrintAction(key + ".B.1", workDone));
+                worker3.schedule(createPrintAction(key + ".B.2", workDone));
+            }
+
+        });
+        return worker;
+    }
+
+    private static Runnable createPrintAction(final String message, final ArrayList<String> workDone) {
+        return new Runnable() {
+
+            @Override
+            public void run() {
+                System.out.println(message);
+                workDone.add(message);
+            }
+
+        };
+    }
+}
\ No newline at end of file
