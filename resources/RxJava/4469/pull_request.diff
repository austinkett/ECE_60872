diff --git a/src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java b/src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java
index 3d3ed581a4..50c1769093 100644
--- a/src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java
+++ b/src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java
@@ -124,10 +124,12 @@ void drain() {
                 } else
                 if (NotificationLite.isDisposable(v)) {
                     Disposable next = NotificationLite.getDisposable(v);
-                    if (s != null) {
-                        s.dispose();
+                    s.dispose();
+                    if (!cancelled) {
+                        s = next;
+                    } else {
+                        next.dispose();
                     }
-                    s = next;
                 } else 
                 if (NotificationLite.isError(v)) {
                     q.clear();
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java
index e116fdca5c..1f842ca688 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java
@@ -15,11 +15,9 @@
 package io.reactivex.internal.operators.observable;
 
 import io.reactivex.*;
-import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.disposables.DisposableHelper;
-import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.internal.functions.ObjectHelper;
+import io.reactivex.internal.subscribers.observable.BasicFuseableObserver;
 
 public final class ObservableMap<T, U> extends AbstractObservableWithUpstream<T, U> {
     final Function<? super T, ? extends U> function;
@@ -31,75 +29,49 @@ public ObservableMap(ObservableSource<T> source, Function<? super T, ? extends U
     
     @Override
     public void subscribeActual(Observer<? super U> t) {
-        source.subscribe(new MapperSubscriber<T, U>(t, function));
+        source.subscribe(new MapObserver<T, U>(t, function));
     }
     
-    static final class MapperSubscriber<T, U> implements Observer<T>, Disposable {
-        final Observer<? super U> actual;
-        final Function<? super T, ? extends U> function;
-        
-        Disposable subscription;
-        
-        boolean done;
-        
-        public MapperSubscriber(Observer<? super U> actual, Function<? super T, ? extends U> function) {
-            this.actual = actual;
-            this.function = function;
-        }
-        @Override
-        public void onSubscribe(Disposable s) {
-            if (DisposableHelper.validate(this.subscription, s)) {
-                subscription = s;
-                actual.onSubscribe(this);
-            }
+
+    static final class MapObserver<T, U> extends BasicFuseableObserver<T, U> {
+        final Function<? super T, ? extends U> mapper;
+
+        public MapObserver(Observer<? super U> actual, Function<? super T, ? extends U> mapper) {
+            super(actual);
+            this.mapper = mapper;
         }
+
         @Override
         public void onNext(T t) {
             if (done) {
                 return;
             }
-            U u;
-            try {
-                u = function.apply(t);
-            } catch (Throwable e) {
-                Exceptions.throwIfFatal(e);
-                subscription.dispose();
-                onError(e);
-                return;
-            }
-            if (u == null) {
-                subscription.dispose();
-                onError(new NullPointerException("Value returned by the function is null"));
-                return;
-            }
-            actual.onNext(u);
-        }
-        @Override
-        public void onError(Throwable t) {
-            if (done) {
-                RxJavaPlugins.onError(t);
+            
+            if (sourceMode != NONE) {
+                actual.onNext(null);
                 return;
             }
-            done = true;
-            actual.onError(t);
-        }
-        @Override
-        public void onComplete() {
-            if (done) {
+            
+            U v;
+            
+            try {
+                v = ObjectHelper.requireNonNull(mapper.apply(t), "The mapper function returned a null value.");
+            } catch (Throwable ex) {
+                fail(ex);
                 return;
             }
-            done = true;
-            actual.onComplete();
+            actual.onNext(v);
         }
-        
+
         @Override
-        public boolean isDisposed() {
-            return subscription.isDisposed();
+        public int requestFusion(int mode) {
+            return transitiveBoundaryFusion(mode);
         }
-        
+
         @Override
-        public void dispose() {
-            subscription.dispose();
+        public U poll() throws Exception {
+            T t = qs.poll();
+            return t != null ? ObjectHelper.<U>requireNonNull(mapper.apply(t), "The mapper function returned a null value.") : null;
         }
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableRange.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableRange.java
index 1f2153eaaa..a54561eabc 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableRange.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRange.java
@@ -45,6 +45,8 @@ protected void subscribeActual(Observer<? super Integer> o) {
         
         long index;
         
+        boolean fused;
+        
         public RangeDisposable(Observer<? super Integer> actual, long start, long end) {
             this.actual = actual;
             this.index = start;
@@ -52,6 +54,9 @@ public RangeDisposable(Observer<? super Integer> actual, long start, long end) {
         }
         
         void run() {
+            if (fused) {
+                return;
+            }
             Observer<? super Integer> actual = this.actual;
             long e = end;
             for (long i = index; i != e && get() == 0; i++) {
@@ -107,7 +112,11 @@ public boolean isDisposed() {
 
         @Override
         public int requestFusion(int mode) {
-            return mode & SYNC;
+            if ((mode & SYNC) != 0) {
+                fused = true;
+                return SYNC;
+            }
+            return NONE;
         }
     }
 }
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java
index 9a1912c31c..8430174a56 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSingleSubscriber.java
@@ -16,11 +16,11 @@
 
 import org.reactivestreams.*;
 
-import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.ExceptionHelper;
 
 public abstract class BlockingSingleSubscriber<T> extends CountDownLatch
-implements Subscriber<T>, Disposable {
+implements Subscriber<T> {
 
     T value;
     Throwable error;
@@ -35,11 +35,14 @@ public BlockingSingleSubscriber() {
 
     @Override
     public final void onSubscribe(Subscription s) {
-        this.s = s;
-        if (!cancelled) {
-            s.request(Long.MAX_VALUE);
-            if (cancelled) {
-                s.cancel();
+        if (SubscriptionHelper.validate(this.s, s)) {
+            this.s = s;
+            if (!cancelled) {
+                s.request(Long.MAX_VALUE);
+                if (cancelled) {
+                    this.s = SubscriptionHelper.CANCELLED;
+                    s.cancel();
+                }
             }
         }
     }
@@ -49,20 +52,6 @@ public final void onComplete() {
         countDown();
     }
     
-    @Override
-    public final void dispose() {
-        cancelled = true;
-        Subscription s = this.s;
-        if (s != null) {
-            s.cancel();
-        }
-    }
-    
-    @Override
-    public final boolean isDisposed() {
-        return cancelled;
-    }
-    
     /**
      * Block until the first value arrives and return it, otherwise
      * return null for an empty source and rethrow any exception.
@@ -73,7 +62,11 @@ public final T blockingGet() {
             try {
                 await();
             } catch (InterruptedException ex) {
-                dispose();
+                Subscription s = this.s;
+                this.s = SubscriptionHelper.CANCELLED;
+                if (s != null) {
+                    s.cancel();
+                }
                 throw ExceptionHelper.wrapOrThrow(ex);
             }
         }
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSubscriber.java
index 2f3a5e9874..4506a56c52 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BlockingSubscriber.java
@@ -35,14 +35,9 @@ public BlockingSubscriber(Queue<Object> queue) {
     
     @Override
     public void onSubscribe(Subscription s) {
-        if (!compareAndSet(null, s)) {
-            s.cancel();
-            if (get() != SubscriptionHelper.CANCELLED) {
-                onError(new IllegalStateException("Subscription already set"));
-            }
-            return;
+        if (SubscriptionHelper.setOnce(this, s)) {
+            queue.offer(NotificationLite.subscription(this));
         }
-        queue.offer(NotificationLite.subscription(this));
     }
     
     @Override
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/FutureSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/FutureSubscriber.java
index 2d30c28106..ec63ec0798 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/FutureSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/FutureSubscriber.java
@@ -123,22 +123,17 @@ public void onNext(T t) {
 
     @Override
     public void onError(Throwable t) {
-        if (error == null) {
+        for (;;) {
+            Subscription a = s.get();
+            if (a == this || a == SubscriptionHelper.CANCELLED) {
+                RxJavaPlugins.onError(t);
+                return;
+            }
             error = t;
-
-            for (;;) {
-                Subscription a = s.get();
-                if (a == this || a == SubscriptionHelper.CANCELLED) {
-                    RxJavaPlugins.onError(t);
-                    return;
-                }
-                if (s.compareAndSet(a, this)) {
-                    countDown();
-                    return;
-                }
+            if (s.compareAndSet(a, this)) {
+                countDown();
+                return;
             }
-        } else {
-            RxJavaPlugins.onError(t);
         }
     }
 
diff --git a/src/main/java/io/reactivex/internal/subscriptions/ArrayCompositeSubscription.java b/src/main/java/io/reactivex/internal/subscriptions/ArrayCompositeSubscription.java
index 043e208bba..a4954300e4 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/ArrayCompositeSubscription.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/ArrayCompositeSubscription.java
@@ -44,7 +44,9 @@ public boolean setResource(int index, Subscription resource) {
         for (;;) {
             Subscription o = get(index);
             if (o == SubscriptionHelper.CANCELLED) {
-                resource.cancel();
+                if (resource != null) {
+                    resource.cancel();
+                }
                 return false;
             }
             if (compareAndSet(index, o, resource)) {
@@ -66,7 +68,9 @@ public Subscription replaceResource(int index, Subscription resource) {
         for (;;) {
             Subscription o = get(index);
             if (o == SubscriptionHelper.CANCELLED) {
-                resource.cancel();
+                if (resource != null) {
+                    resource.cancel();
+                }
                 return null;
             }
             if (compareAndSet(index, o, resource)) {
diff --git a/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java b/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java
index 79dffb4582..7f6e03e43d 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/AsyncSubscription.java
@@ -19,7 +19,6 @@
 
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
-import io.reactivex.internal.util.BackpressureHelper;
 
 /**
  * A subscription implementation that arbitrates exactly one other Subscription and can
@@ -47,19 +46,7 @@ public AsyncSubscription(Disposable resource) {
     
     @Override
     public void request(long n) {
-        Subscription s = actual.get();
-        if (s != null) {
-            s.request(n);
-        } else if (SubscriptionHelper.validate(n)) {
-            BackpressureHelper.add(this, n);
-            s = actual.get();
-            if (s != null) {
-                long mr = getAndSet(0L);
-                if (mr != 0L) {
-                    s.request(mr);
-                }
-            }
-        }
+        SubscriptionHelper.deferredRequest(actual, this, n);
     }
     
     @Override
@@ -100,27 +87,8 @@ public boolean replaceResource(Disposable r) {
     /**
      * Sets the given subscription if there isn't any subscription held.
      * @param s the first and only subscription to set
-     * @return false if this AsyncSubscription has been cancelled/disposed
      */
-    public boolean setSubscription(Subscription s) {
-        for (;;) {
-            Subscription a = actual.get();
-            if (a == SubscriptionHelper.CANCELLED) {
-                s.cancel();
-                return false;
-            }
-            if (a != null) {
-                s.cancel();
-                SubscriptionHelper.reportSubscriptionSet();
-                return true;
-            }
-            if (actual.compareAndSet(null, s)) {
-                long mr = getAndSet(0L);
-                if (mr != 0L) {
-                    s.request(mr);
-                }
-                return true;
-            }
-        }
+    public void setSubscription(Subscription s) {
+        SubscriptionHelper.deferredSetOnce(actual, this, s);
     }
 }
diff --git a/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java b/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
index 6a7fe40b3c..570bd1ad21 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/DeferredScalarSubscription.java
@@ -82,11 +82,13 @@ public final void request(long n) {
                 if (state == NO_REQUEST_HAS_VALUE) {
                     if (compareAndSet(NO_REQUEST_HAS_VALUE, HAS_REQUEST_HAS_VALUE)) {
                         T v = value;
-                        value = null;
-                        Subscriber<? super T> a = actual;
-                        a.onNext(v);
-                        if (get() != CANCELLED) {
-                            a.onComplete();
+                        if (v != null) {
+                            value = null;
+                            Subscriber<? super T> a = actual;
+                            a.onNext(v);
+                            if (get() != CANCELLED) {
+                                a.onComplete();
+                            }
                         }
                     }
                     return;
diff --git a/src/main/java/io/reactivex/internal/subscriptions/FullArbiter.java b/src/main/java/io/reactivex/internal/subscriptions/FullArbiter.java
index f026df995c..641675d2cf 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/FullArbiter.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/FullArbiter.java
@@ -18,6 +18,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.queue.SpscLinkedArrayQueue;
 import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -87,9 +88,13 @@ void dispose() {
 
     public boolean setSubscription(Subscription s) {
         if (cancelled) {
+            if (s != null) {
+                s.cancel();
+            }
             return false;
         }
 
+        ObjectHelper.requireNonNull(s, "s is null");
         queue.offer(this.s, NotificationLite.subscription(s));
         drain();
         return true;
@@ -143,9 +148,7 @@ void drain() {
                     long mr = missedRequested.getAndSet(0L);
                     if (mr != 0L) {
                         requested = BackpressureHelper.addCap(requested, mr);
-                        if (s != null) {
-                            s.request(mr);
-                        }
+                        s.request(mr);
                     }
                 } else 
                 if (o != s) {
@@ -153,13 +156,14 @@ void drain() {
                 } else
                 if (NotificationLite.isSubscription(v)) {
                     Subscription next = NotificationLite.getSubscription(v);
-                    if (s != null) {
-                        s.cancel();
-                    }
-                    s = next;
-                    long r = requested;
-                    if (r != 0L) {
-                        next.request(r);
+                    if (!cancelled) {
+                        s = next;
+                        long r = requested;
+                        if (r != 0L) {
+                            next.request(r);
+                        }
+                    } else {
+                        next.cancel();
                     }
                 } else 
                 if (NotificationLite.isError(v)) {
diff --git a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java
index d1e32f5a82..91503e2f55 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java
@@ -65,15 +65,6 @@ public SubscriptionArbiter() {
         missedProduced = new AtomicLong();
     }
     
-    /**
-     * When setting a new subscription via set(), should
-     * the previous subscription be cancelled?
-     * @return true if cancellation is needed
-     */
-    protected boolean shouldCancelCurrent() {
-        return true;
-    }
-    
     /**
      * Atomically sets a new subscription.
      * @param s the subscription to set, not null (verified)
@@ -89,7 +80,7 @@ public final void setSubscription(Subscription s) {
         if (get() == 0 && compareAndSet(0, 1)) {
             Subscription a = actual;
             
-            if (a != null && shouldCancelCurrent()) {
+            if (a != null) {
                 a.cancel();
             }
             
@@ -109,7 +100,7 @@ public final void setSubscription(Subscription s) {
         }
 
         Subscription a = missedSubscription.getAndSet(s);
-        if (a != null && shouldCancelCurrent()) {
+        if (a != null) {
             a.cancel();
         }
         drain();
@@ -150,38 +141,6 @@ public final void request(long n) {
         }
     }
 
-    public final void producedOne() {
-        if (unbounded) {
-            return;
-        }
-        if (get() == 0 && compareAndSet(0, 1)) {
-            long r = requested;
-
-            if (r != Long.MAX_VALUE) {
-                r--;
-                if (r < 0L) {
-                    SubscriptionHelper.reportMoreProduced(r);
-                    r = 0;
-                }
-                requested = r;
-            } else {
-                unbounded = true;
-            }
-
-            if (decrementAndGet() == 0) {
-                return;
-            }
-
-            drainLoop();
-
-            return;
-        }
-
-        BackpressureHelper.add(missedProduced, 1L);
-
-        drain();
-    }
-
     public final void produced(long n) {
         if (unbounded) {
             return;
@@ -196,8 +155,6 @@ public final void produced(long n) {
                     u = 0;
                 }
                 requested = u;
-            } else {
-                unbounded = true;
             }
 
             if (decrementAndGet() == 0) {
@@ -283,7 +240,7 @@ final void drainLoop() {
                 }
 
                 if (ms != null) {
-                    if (a != null && shouldCancelCurrent()) {
+                    if (a != null) {
                         a.cancel();
                     }
                     actual = ms;
diff --git a/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java b/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
index 87ea265c3a..a73b9eb918 100644
--- a/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
+++ b/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
@@ -98,7 +98,7 @@ public void forEachWhile(Predicate<? super T> consumer) throws Exception {
     public <S> void forEachWhile(S state, BiPredicate<? super S, ? super T> consumer) throws Exception {
         Object[] a = head;
         final int c = capacity;
-        while (a != null) {
+        for (;;) {
             for (int i = 0; i < c; i++) {
                 Object o = a[i];
                 if (o == null) {
diff --git a/src/main/java/io/reactivex/observers/SafeObserver.java b/src/main/java/io/reactivex/observers/SafeObserver.java
index af0c662cd0..e4dad90035 100644
--- a/src/main/java/io/reactivex/observers/SafeObserver.java
+++ b/src/main/java/io/reactivex/observers/SafeObserver.java
@@ -55,6 +55,7 @@ public void onSubscribe(Disposable s) {
                 } catch (Throwable e1) {
                     Exceptions.throwIfFatal(e1);
                     RxJavaPlugins.onError(new CompositeException(e, e1));
+                    return;
                 }
                 RxJavaPlugins.onError(e);
             }
@@ -111,6 +112,7 @@ public void onNext(T t) {
     }
     
     void onNextNoSubscription() {
+        done = true;
         
         Throwable ex = new NullPointerException("Subscription not set!");
         
@@ -181,13 +183,14 @@ public void onComplete() {
         if (done) {
             return;
         }
+
+        done = true;
+
         if (s == null) {
             onCompleteNoSubscription();
             return;
         }
 
-        done = true;
-
         try {
             actual.onComplete();
         } catch (Throwable e) {
diff --git a/src/main/java/io/reactivex/observers/TestObserver.java b/src/main/java/io/reactivex/observers/TestObserver.java
index 9930f071c3..94daa0c32a 100644
--- a/src/main/java/io/reactivex/observers/TestObserver.java
+++ b/src/main/java/io/reactivex/observers/TestObserver.java
@@ -700,9 +700,6 @@ public final boolean awaitTerminalEvent(long duration, TimeUnit unit) {
         } else
         if (s == 1) {
             Throwable e = errors.get(0);
-            if (e == null) {
-                throw fail("Error is null");
-            }
             String errorMessage = e.getMessage();
             if (!ObjectHelper.equals(message, errorMessage)) {
                 throw fail("Error message differs; Expected: " + message + ", Actual: " + errorMessage);
@@ -763,7 +760,7 @@ public final boolean awaitTerminalEvent(long duration, TimeUnit unit) {
                 throw new AssertionError("Fusion mode different. Expected: " + fusionModeToString(mode)
                 + ", actual: " + fusionModeToString(m));
             } else {
-                throw new AssertionError("Upstream is not fuseable");
+                throw fail("Upstream is not fuseable");
             }
         }
         return this;
diff --git a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
index 8b1cb69a28..dda6063a85 100644
--- a/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java
@@ -665,10 +665,10 @@ public static void setOnFlowableSubscribe(BiFunction<Flowable, Subscriber, Subsc
     
     /**
      * Sets the specific hook function.
-     * @param onFlowableSubscribe the hook function to set, null allowed
+     * @param onMaybeSubscribe the hook function to set, null allowed
      */
     @SuppressWarnings("rawtypes")
-    public static void setOnMaybeSubscribe(BiFunction<Maybe, MaybeObserver, MaybeObserver> onFlowableSubscribe) {
+    public static void setOnMaybeSubscribe(BiFunction<Maybe, MaybeObserver, MaybeObserver> onMaybeSubscribe) {
         if (lockdown) {
             throw new IllegalStateException("Plugins can't be changed anymore");
         }
diff --git a/src/main/java/io/reactivex/schedulers/Schedulers.java b/src/main/java/io/reactivex/schedulers/Schedulers.java
index 7243c88270..7fd023a2f9 100644
--- a/src/main/java/io/reactivex/schedulers/Schedulers.java
+++ b/src/main/java/io/reactivex/schedulers/Schedulers.java
@@ -45,8 +45,9 @@
         NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(NewThreadScheduler.instance());
     }
     
+    /** Utility class. */
     private Schedulers() {
-        throw new IllegalStateException("No instances");
+        throw new IllegalStateException("No instances!");
     }
     
     /**
diff --git a/src/main/java/io/reactivex/subscribers/SafeSubscriber.java b/src/main/java/io/reactivex/subscribers/SafeSubscriber.java
index d55d76ba87..f18ae2f6be 100644
--- a/src/main/java/io/reactivex/subscribers/SafeSubscriber.java
+++ b/src/main/java/io/reactivex/subscribers/SafeSubscriber.java
@@ -15,7 +15,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.exceptions.*;
-import io.reactivex.internal.subscriptions.EmptySubscription;
+import io.reactivex.internal.subscriptions.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 /**
@@ -24,11 +24,11 @@
  *
  * @param <T> the value type
  */
-public final class SafeSubscriber<T> implements Subscriber<T> {
+public final class SafeSubscriber<T> implements Subscriber<T>, Subscription {
     /** The actual Subscriber. */
     final Subscriber<? super T> actual;
     /** The subscription. */
-    Subscription subscription;
+    Subscription s;
     /** Indicates a terminal state. */
     boolean done;
     
@@ -42,63 +42,82 @@ public SafeSubscriber(Subscriber<? super T> actual) {
     
     @Override
     public void onSubscribe(Subscription s) {
-        if (done) {
-            return;
-        }
-        if (this.subscription != null) {
-            IllegalStateException ise = new IllegalStateException("Subscription already set!");
+        if (SubscriptionHelper.validate(this.s, s)) {
+            this.s = s;
             try {
-                s.cancel();
+                actual.onSubscribe(this);
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                ise.initCause(e);
+                done = true;
+                // can't call onError because the actual's state may be corrupt at this point
+                try {
+                    s.cancel();
+                } catch (Throwable e1) {
+                    Exceptions.throwIfFatal(e1);
+                    RxJavaPlugins.onError(new CompositeException(e, e1));
+                    return;
+                }
+                RxJavaPlugins.onError(e);
             }
-            onError(ise);
+        }
+    }
+
+    @Override
+    public void onNext(T t) {
+        if (done) {
             return;
         }
         if (s == null) {
-            subscription = EmptySubscription.INSTANCE;
-            onError(new NullPointerException("Subscription is null!"));
+            onNextNoSubscription();
+            return;
+        }
+
+        if (t == null) {
+            Throwable ex = new NullPointerException();
+            try {
+                s.cancel();
+            } catch (Throwable e1) {
+                Exceptions.throwIfFatal(e1);
+                onError(new CompositeException(ex, e1));
+                return;
+            }
+            onError(ex);
             return;
         }
-        this.subscription = s;
+        
         try {
-            actual.onSubscribe(s);
+            actual.onNext(t);
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
-            done = true;
-            // can't call onError because the actual's state may be corrupt at this point
             try {
                 s.cancel();
             } catch (Throwable e1) {
                 Exceptions.throwIfFatal(e1);
-                CompositeException ce = new CompositeException(); // NOPMD
-                ce.suppress(e1);
-                ce.suppress(e);
-                e = ce;
+                onError(new CompositeException(e, e1));
+                return;
             }
-            RxJavaPlugins.onError(e);
+            onError(e);
         }
     }
     
-    @Override
-    public void onNext(T t) {
-        if (done) {
-            return;
-        }
-        if (t == null) {
-            onError(new NullPointerException());
-            return;
-        }
-        if (subscription == null) {
-            onError(null); // null is okay here, onError checks for subscription == null first
+    void onNextNoSubscription() {
+        done = true;
+        Throwable ex = new NullPointerException("Subscription not set!");
+        
+        try {
+            actual.onSubscribe(EmptySubscription.INSTANCE);
+        } catch (Throwable e) {
+            Exceptions.throwIfFatal(e);
+            // can't call onError because the actual's state may be corrupt at this point
+            RxJavaPlugins.onError(new CompositeException(ex, e));
             return;
         }
         try {
-            actual.onNext(t);
+            actual.onError(ex);
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
-            onError(e);
+            // if onError failed, all that's left is to report the error to plugins
+            RxJavaPlugins.onError(new CompositeException(ex, e));
         }
     }
     
@@ -109,7 +128,7 @@ public void onError(Throwable t) {
         }
         done = true;
         
-        if (subscription == null) {
+        if (s == null) {
             CompositeException t2 = new CompositeException(t, new NullPointerException("Subscription not set!"));
             
             try {
@@ -134,32 +153,16 @@ public void onError(Throwable t) {
             return;
         }
         
-        CompositeException t2 = null;
         if (t == null) {
             t = new NullPointerException();
         }
 
         try {
-            subscription.cancel();
-        } catch (Throwable e) {
-            Exceptions.throwIfFatal(e);
-            t2 = new CompositeException(e, t);
-        }
-
-        try {
-            if (t2 != null) {
-                actual.onError(t2);
-            } else {
-                actual.onError(t);
-            }
-        } catch (Throwable e) {
-            Exceptions.throwIfFatal(e);
-            if (t2 == null) {
-                t2 = new CompositeException(t, e);
-            } else {
-                t2.suppress(e);
-            }
-            RxJavaPlugins.onError(t2);
+            actual.onError(t);
+        } catch (Throwable ex) {
+            Exceptions.throwIfFatal(ex);
+            
+            RxJavaPlugins.onError(new CompositeException(t, ex));
         }
     }
     
@@ -168,31 +171,69 @@ public void onComplete() {
         if (done) {
             return;
         }
-        if (subscription == null) {
-            onError(null); // null is okay here, onError checks for subscription == null first
+        done = true;
+
+        if (s == null) {
+            onCompleteNoSubscription();
             return;
         }
 
-        done = true;
 
         try {
-            subscription.cancel();
+            actual.onComplete();
+        } catch (Throwable e) {
+            Exceptions.throwIfFatal(e);
+            RxJavaPlugins.onError(e);
+        }
+    }
+
+    void onCompleteNoSubscription() {
+        
+        Throwable ex = new NullPointerException("Subscription not set!");
+        
+        try {
+            actual.onSubscribe(EmptySubscription.INSTANCE);
+        } catch (Throwable e) {
+            Exceptions.throwIfFatal(e);
+            // can't call onError because the actual's state may be corrupt at this point
+            RxJavaPlugins.onError(new CompositeException(ex, e));
+            return;
+        }
+        try {
+            actual.onError(ex);
+        } catch (Throwable e) {
+            Exceptions.throwIfFatal(e);
+            // if onError failed, all that's left is to report the error to plugins
+            RxJavaPlugins.onError(new CompositeException(ex, e));
+        }
+    }
+    
+    @Override
+    public void request(long n) {
+        try {
+            s.request(n);
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
             try {
-                actual.onError(e);
+                s.cancel();
             } catch (Throwable e1) {
                 Exceptions.throwIfFatal(e1);
-                RxJavaPlugins.onError(new CompositeException(e1, e));
+                RxJavaPlugins.onError(new CompositeException(e, e1));
+                return;
             }
+            RxJavaPlugins.onError(e);
             return;
         }
-        
+    }
+    
+    @Override
+    public void cancel() {
         try {
-            actual.onComplete();
-        } catch (Throwable e) {
-            Exceptions.throwIfFatal(e);
-            RxJavaPlugins.onError(e);
+            s.cancel();
+        } catch (Throwable e1) {
+            Exceptions.throwIfFatal(e1);
+            RxJavaPlugins.onError(e1);
+            return;
         }
     }
 }
diff --git a/src/main/java/io/reactivex/subscribers/TestSubscriber.java b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
index c2f8676a5f..2a92944989 100644
--- a/src/main/java/io/reactivex/subscribers/TestSubscriber.java
+++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java
@@ -43,8 +43,6 @@
 public class TestSubscriber<T> implements Subscriber<T>, Subscription, Disposable {
     /** The actual subscriber to forward events to. */
     private final Subscriber<? super T> actual;
-    /** The initial request amount if not null. */
-    private final long initialRequest;
     /** The latch that indicates an onError or onCompleted has been called. */
     private final CountDownLatch done;
     /** The list of values received. */
@@ -60,10 +58,10 @@
     private volatile boolean cancelled;
 
     /** Holds the current subscription if any. */
-    private final AtomicReference<Subscription> subscription = new AtomicReference<Subscription>();
+    private final AtomicReference<Subscription> subscription;
     
     /** Holds the requested amount until a subscription arrives. */
-    private final AtomicLong missedRequested = new AtomicLong();
+    private final AtomicLong missedRequested;
     
     private boolean checkSubscriptionOnce;
 
@@ -91,6 +89,16 @@
     public static <T> TestSubscriber<T> create(long initialRequested) {
         return new TestSubscriber<T>(initialRequested);
     }
+    
+    /**
+     * Constructs a forwarding TestSubscriber.
+     * @param <T> the value type received
+     * @param delegate the actual Subscriber to forward events to
+     * @return the new TestObserver instance
+     */
+    public static <T> TestSubscriber<T> create(Subscriber<? super T> delegate) {
+        return new TestSubscriber<T>(delegate);
+    }
 
     /**
      * Constructs a non-forwarding TestSubscriber with an initial request value of Long.MAX_VALUE.
@@ -126,10 +134,11 @@ public TestSubscriber(Subscriber<? super T> actual) {
      */
     public TestSubscriber(Subscriber<? super T> actual, long initialRequest) {
         this.actual = actual;
-        this.initialRequest = initialRequest;
         this.values = new ArrayList<T>();
         this.errors = new ArrayList<Throwable>();
         this.done = new CountDownLatch(1);
+        this.subscription = new AtomicReference<Subscription>();
+        this.missedRequested = new AtomicLong(initialRequest);
     }
     
     @SuppressWarnings("unchecked")
@@ -149,10 +158,6 @@ public void onSubscribe(Subscription s) {
             return;
         }
         
-        if (cancelled) {
-            s.cancel();
-        }
-        
         if (initialFusionMode != 0) {
             if (s instanceof QueueSubscription) {
                 qs = (QueueSubscription<T>)s;
@@ -181,14 +186,6 @@ public void onSubscribe(Subscription s) {
         
         actual.onSubscribe(s);
         
-        if (cancelled) {
-            return;
-        }
-        
-        if (initialRequest != 0L) {
-            s.request(initialRequest);
-        }
-        
         long mr = missedRequested.getAndSet(0L);
         if (mr != 0L) {
             s.request(mr);
@@ -277,22 +274,7 @@ public void onComplete() {
     
     @Override
     public final void request(long n) {
-        if (!SubscriptionHelper.validate(n)) {
-            return;
-        }
-        Subscription s = subscription.get();
-        if (s != null) {
-            s.request(n);
-        } else {
-            BackpressureHelper.add(missedRequested, n);
-            s = subscription.get();
-            if (s != null) {
-                long mr = missedRequested.getAndSet(0L);
-                if (mr != 0L) {
-                    s.request(mr);
-                }
-            }
-        }
+        SubscriptionHelper.deferredRequest(subscription, missedRequested, n);
     }
     
     @Override
@@ -412,7 +394,7 @@ public final boolean hasSubscription() {
      * 
      * @param message the message to use
      */
-    private void fail(String message) {
+    private AssertionError fail(String message) {
         StringBuilder b = new StringBuilder(64 + message.length());
         b.append(message);
         
@@ -436,7 +418,7 @@ private void fail(String message) {
         if (!ce.isEmpty()) {
             ae.initCause(ce);
         }
-        throw ae;
+        return ae;
     }
     
     /**
@@ -446,10 +428,10 @@ private void fail(String message) {
     public final TestSubscriber<T> assertComplete() {
         long c = completions;
         if (c == 0) {
-            fail("Not completed");
+            throw fail("Not completed");
         } else
         if (c > 1) {
-            fail("Multiple completions: " + c);
+            throw fail("Multiple completions: " + c);
         }
         return this;
     }
@@ -461,10 +443,10 @@ private void fail(String message) {
     public final TestSubscriber<T> assertNotComplete() {
         long c = completions;
         if (c == 1) {
-            fail("Completed!");
+            throw fail("Completed!");
         } else 
         if (c > 1) {
-            fail("Multiple completions: " + c);
+            throw fail("Multiple completions: " + c);
         }
         return this;
     }
@@ -476,7 +458,7 @@ private void fail(String message) {
     public final TestSubscriber<T> assertNoErrors() {
         int s = errors.size();
         if (s != 0) {
-            fail("Error(s) present: " + errors);
+            throw fail("Error(s) present: " + errors);
         }
         return this;
     }
@@ -494,14 +476,14 @@ private void fail(String message) {
     public final TestSubscriber<T> assertError(Throwable error) {
         int s = errors.size();
         if (s == 0) {
-            fail("No errors");
+            throw fail("No errors");
         }
         if (errors.contains(error)) {
             if (s != 1) {
-                fail("Error present but other errors as well");
+                throw fail("Error present but other errors as well");
             }
         } else {
-            fail("Error not present");
+            throw fail("Error not present");
         }
         return this;
     }
@@ -515,7 +497,7 @@ private void fail(String message) {
     public final TestSubscriber<T> assertError(Class<? extends Throwable> errorClass) {
         int s = errors.size();
         if (s == 0) {
-            fail("No errors");
+            throw fail("No errors");
         }
         
         boolean found = false;
@@ -529,10 +511,10 @@ private void fail(String message) {
         
         if (found) {
             if (s != 1) {
-                fail("Error present but other errors as well");
+                throw fail("Error present but other errors as well");
             }
         } else {
-            fail("Error not present");
+            throw fail("Error not present");
         }
         return this;
     }
@@ -546,11 +528,11 @@ private void fail(String message) {
     public final TestSubscriber<T> assertValue(T value) {
         int s = values.size();
         if (s != 1) {
-            fail("Expected: " + valueAndClass(value) + ", Actual: " + values);
+            throw fail("Expected: " + valueAndClass(value) + ", Actual: " + values);
         }
         T v = values.get(0);
         if (!ObjectHelper.equals(value, v)) {
-            fail("Expected: " + valueAndClass(value) + ", Actual: " + valueAndClass(v));
+            throw fail("Expected: " + valueAndClass(value) + ", Actual: " + valueAndClass(v));
         }
         return this;
     }
@@ -571,7 +553,7 @@ static String valueAndClass(Object o) {
     public final TestSubscriber<T> assertValueCount(int count) {
         int s = values.size();
         if (s != count) {
-            fail("Value counts differ; Expected: " + count + ", Actual: " + s);
+            throw fail("Value counts differ; Expected: " + count + ", Actual: " + s);
         }
         return this;
     }
@@ -593,14 +575,14 @@ static String valueAndClass(Object o) {
     public final TestSubscriber<T> assertValues(T... values) {
         int s = this.values.size();
         if (s != values.length) {
-            fail("Value count differs; Expected: " + values.length + " " + Arrays.toString(values)
+            throw fail("Value count differs; Expected: " + values.length + " " + Arrays.toString(values)
             + ", Actual: " + s + " " + this.values);
         }
         for (int i = 0; i < s; i++) {
             T v = this.values.get(i);
             T u = values[i];
             if (!ObjectHelper.equals(u, v)) {
-                fail("Values at position " + i + " differ; Expected: " + valueAndClass(u) + ", Actual: " + valueAndClass(v));
+                throw fail("Values at position " + i + " differ; Expected: " + valueAndClass(u) + ", Actual: " + valueAndClass(v));
             }
         }
         return this;
@@ -615,14 +597,13 @@ static String valueAndClass(Object o) {
      * @return this
      */
     public final TestSubscriber<T> assertValueSet(Collection<? extends T> expected) {
-        int s = this.values.size();
-        if (s != expected.size()) {
-            fail("Value count differs; Expected: " + expected.size() + " " + expected
-            + ", Actual: " + s + " " + this.values);
+        if (expected.isEmpty()) {
+            assertNoValues();
+            return this;
         }
         for (T v : this.values) {
             if (!expected.contains(v)) {
-                fail("Value not in the expected collection: " + valueAndClass(v));
+                throw fail("Value not in the expected collection: " + valueAndClass(v));
             }
         }
         return this;
@@ -637,23 +618,32 @@ static String valueAndClass(Object o) {
         int i = 0;
         Iterator<T> vit = values.iterator();
         Iterator<? extends T> it = sequence.iterator();
-        boolean itNext = false;
-        boolean vitNext = false;
-        while ((itNext = it.hasNext()) && (vitNext = vit.hasNext())) {
+        boolean actualNext = false;
+        boolean expectedNext = false;
+        for (;;) {
+            actualNext = it.hasNext();
+            expectedNext = vit.hasNext();
+
+            if (!actualNext || !expectedNext) {
+                break;
+            }
+            
             T v = it.next();
             T u = vit.next();
             
             if (!ObjectHelper.equals(u, v)) {
-                fail("Values at position " + i + " differ; Expected: " + valueAndClass(u) + ", Actual: " + valueAndClass(v));
+                throw fail("Values at position " + i + " differ; Expected: " + valueAndClass(u) + ", Actual: " + valueAndClass(v));
             }
             i++;
+            actualNext = false;
+            expectedNext = false;
         }
         
-        if (itNext && !vitNext) {
-            fail("More values received than expected (" + i + ")");
+        if (actualNext) {
+            throw fail("More values received than expected (" + i + ")");
         }
-        if (!itNext && !vitNext) {
-            fail("Fever values received than expected (" + i + ")");
+        if (expectedNext) {
+            throw fail("Fever values received than expected (" + i + ")");
         }
         return this;
     }
@@ -664,19 +654,19 @@ static String valueAndClass(Object o) {
      */
     public final TestSubscriber<T> assertTerminated() {
         if (done.getCount() != 0) {
-            fail("Subscriber still running!");
+            throw fail("Subscriber still running!");
         }
         long c = completions;
         if (c > 1) {
-            fail("Terminated with multiple completions: " + c);
+            throw fail("Terminated with multiple completions: " + c);
         }
         int s = errors.size();
         if (s > 1) {
-            fail("Terminated with multiple errors: " + s);
+            throw fail("Terminated with multiple errors: " + s);
         }
         
         if (c != 0 && s != 0) {
-            fail("Terminated with multiple completions and errors: " + c);
+            throw fail("Terminated with multiple completions and errors: " + c);
         }
         return this;
     }
@@ -687,7 +677,7 @@ static String valueAndClass(Object o) {
      */
     public final TestSubscriber<T> assertNotTerminated() {
         if (done.getCount() == 0) {
-            fail("Subscriber terminated!");
+            throw fail("Subscriber terminated!");
         }
         return this;
     }
@@ -698,7 +688,7 @@ static String valueAndClass(Object o) {
      */
     public final TestSubscriber<T> assertSubscribed() {
         if (subscription.get() == null) {
-            fail("Not subscribed!");
+            throw fail("Not subscribed!");
         }
         return this;
     }
@@ -709,10 +699,10 @@ static String valueAndClass(Object o) {
      */
     public final TestSubscriber<T> assertNotSubscribed() {
         if (subscription.get() != null) {
-            fail("Subscribed!");
+            throw fail("Subscribed!");
         } else
         if (!errors.isEmpty()) {
-            fail("Not subscribed but errors found");
+            throw fail("Not subscribed but errors found");
         }
         return this;
     }
@@ -756,20 +746,16 @@ public final boolean awaitTerminalEvent(long duration, TimeUnit unit) {
     public final TestSubscriber<T> assertErrorMessage(String message) {
         int s = errors.size();
         if (s == 0) {
-            fail("No errors");
+            throw fail("No errors");
         } else
         if (s == 1) {
             Throwable e = errors.get(0);
-            if (e == null) {
-                fail("Error is null");
-                return this;
-            }
             String errorMessage = e.getMessage();
             if (!ObjectHelper.equals(message, errorMessage)) {
-                fail("Error message differs; Expected: " + message + ", Actual: " + errorMessage);
+                throw fail("Error message differs; Expected: " + message + ", Actual: " + errorMessage);
             }
         } else {
-            fail("Multiple errors");
+            throw fail("Multiple errors");
         }
         return this;
     }
@@ -824,13 +810,13 @@ public final boolean awaitTerminalEvent(long duration, TimeUnit unit) {
                 throw new AssertionError("Fusion mode different. Expected: " + fusionModeToString(mode)
                 + ", actual: " + fusionModeToString(m));
             } else {
-                throw new AssertionError("Upstream is not fuseable");
+                throw fail("Upstream is not fuseable");
             }
         }
         return this;
     }
     
-    private String fusionModeToString(int mode) {
+    static String fusionModeToString(int mode) {
         switch (mode) {
         case QueueSubscription.NONE : return "NONE";
         case QueueSubscription.SYNC : return "SYNC";
@@ -939,21 +925,6 @@ public final boolean await(long time, TimeUnit unit) throws InterruptedException
         return done.getCount() == 0 || done.await(time, unit);
     }
     
-    /**
-     * Awaits until the internal latch is counted down.
-     * <p>If the wait times out or gets interrupted, the TestSubscriber is cancelled.
-     * @return this
-     * @throws InterruptedException if the wait is interrupted
-     */
-    public final TestSubscriber<T> awaitDone() throws InterruptedException {
-        try {
-            done.await();
-        } catch (InterruptedException ex) {
-            cancel();
-        }
-        return this;
-    }
-    
     /**
      * Awaits until the internal latch is counted down for the specified duration.
      * <p>If the wait times out or gets interrupted, the TestSubscriber is cancelled.
@@ -988,7 +959,7 @@ public final boolean await(long time, TimeUnit unit) throws InterruptedException
     /**
      * A subscriber that ignores all events and does not report errors.
      */
-    private enum EmptySubscriber implements Subscriber<Object> {
+    enum EmptySubscriber implements Subscriber<Object> {
         INSTANCE;
 
         @Override
diff --git a/src/test/java/io/reactivex/TestHelper.java b/src/test/java/io/reactivex/TestHelper.java
index 6c020683bb..4172e17502 100644
--- a/src/test/java/io/reactivex/TestHelper.java
+++ b/src/test/java/io/reactivex/TestHelper.java
@@ -27,9 +27,11 @@
 import org.mockito.stubbing.Answer;
 import org.reactivestreams.*;
 
+import io.reactivex.disposables.*;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.Consumer;
 import io.reactivex.internal.fuseable.SimpleQueue;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.internal.util.ExceptionHelper;
 import io.reactivex.observers.TestObserver;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -405,4 +407,135 @@ public void accept(TestObserver<T> ts) throws Exception {
             }
         };
     }
+    
+    /**
+     * Calls onSubscribe twice and checks if it doesn't affect the first Subscription while
+     * reporting it to plugin error handler.
+     * @param subscriber the target
+     */
+    public static void doubleOnSubscribe(Subscriber<?> subscriber) {
+        List<Throwable> errors = trackPluginErrors();
+        try {
+            BooleanSubscription s1 = new BooleanSubscription();
+            
+            subscriber.onSubscribe(s1);
+            
+            BooleanSubscription s2 = new BooleanSubscription();
+            
+            subscriber.onSubscribe(s2);
+            
+            assertFalse(s1.isCancelled());
+            
+            assertTrue(s2.isCancelled());
+            
+            assertError(errors, 0, IllegalStateException.class, "Subscription already set!");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    /**
+     * Calls onSubscribe twice and checks if it doesn't affect the first Disposable while
+     * reporting it to plugin error handler.
+     * @param subscriber the target
+     */
+    public static void doubleOnSubscribe(Observer<?> subscriber) {
+        List<Throwable> errors = trackPluginErrors();
+        try {
+            Disposable d1 = Disposables.empty();
+            
+            subscriber.onSubscribe(d1);
+            
+            Disposable d2 = Disposables.empty();
+            
+            subscriber.onSubscribe(d2);
+            
+            assertFalse(d1.isDisposed());
+            
+            assertTrue(d2.isDisposed());
+            
+            assertError(errors, 0, IllegalStateException.class, "Disposable already set!");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    /**
+     * Calls onSubscribe twice and checks if it doesn't affect the first Disposable while
+     * reporting it to plugin error handler.
+     * @param subscriber the target
+     */
+    public static void doubleOnSubscribe(SingleObserver<?> subscriber) {
+        List<Throwable> errors = trackPluginErrors();
+        try {
+            Disposable d1 = Disposables.empty();
+            
+            subscriber.onSubscribe(d1);
+            
+            Disposable d2 = Disposables.empty();
+            
+            subscriber.onSubscribe(d2);
+            
+            assertFalse(d1.isDisposed());
+            
+            assertTrue(d2.isDisposed());
+            
+            assertError(errors, 0, IllegalStateException.class, "Disposable already set!");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    /**
+     * Calls onSubscribe twice and checks if it doesn't affect the first Disposable while
+     * reporting it to plugin error handler.
+     * @param subscriber the target
+     */
+    public static void doubleOnSubscribe(CompletableObserver subscriber) {
+        List<Throwable> errors = trackPluginErrors();
+        try {
+            Disposable d1 = Disposables.empty();
+            
+            subscriber.onSubscribe(d1);
+            
+            Disposable d2 = Disposables.empty();
+            
+            subscriber.onSubscribe(d2);
+            
+            assertFalse(d1.isDisposed());
+            
+            assertTrue(d2.isDisposed());
+            
+            assertError(errors, 0, IllegalStateException.class, "Disposable already set!");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    /**
+     * Calls onSubscribe twice and checks if it doesn't affect the first Disposable while
+     * reporting it to plugin error handler.
+     * @param subscriber the target
+     */
+    public static void doubleOnSubscribe(MaybeObserver<?> subscriber) {
+        List<Throwable> errors = trackPluginErrors();
+        try {
+            Disposable d1 = Disposables.empty();
+            
+            subscriber.onSubscribe(d1);
+            
+            Disposable d2 = Disposables.empty();
+            
+            subscriber.onSubscribe(d2);
+            
+            assertFalse(d1.isDisposed());
+            
+            assertTrue(d2.isDisposed());
+            
+            assertError(errors, 0, IllegalStateException.class, "Disposable already set!");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
 }
diff --git a/src/test/java/io/reactivex/disposables/DisposablesTest.java b/src/test/java/io/reactivex/disposables/DisposablesTest.java
index 6f4d725178..8e63345c22 100644
--- a/src/test/java/io/reactivex/disposables/DisposablesTest.java
+++ b/src/test/java/io/reactivex/disposables/DisposablesTest.java
@@ -14,15 +14,20 @@
 package io.reactivex.disposables;
 
 import static org.junit.Assert.*;
+import static org.mockito.Matchers.anyInt;
 import static org.mockito.Mockito.*;
 
 import java.io.IOException;
-import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.List;
+import java.util.concurrent.atomic.*;
 
 import org.junit.Test;
+import org.reactivestreams.Subscription;
 
 import io.reactivex.TestHelper;
 import io.reactivex.functions.Action;
+import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.schedulers.Schedulers;
 
 public class DisposablesTest {
@@ -132,4 +137,41 @@ public void run() {
             TestHelper.race(r, r, Schedulers.io());
         }
     }
+
+    @Test(expected = NullPointerException.class)
+    public void fromSubscriptionNull() {
+        Disposables.fromSubscription(null);
+    }
+    
+    @Test
+    public void fromSubscription() {
+        Subscription s = mock(Subscription.class);
+        
+        Disposables.fromSubscription(s).dispose();
+        
+        verify(s).cancel();
+        verify(s, never()).request(anyInt());
+    }
+    
+    @Test
+    public void setOnceTwice() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+
+            AtomicReference<Disposable> target = new AtomicReference<Disposable>();
+            Disposable d = Disposables.empty();
+            
+            DisposableHelper.setOnce(target, d);
+            
+            Disposable d1 = Disposables.empty();
+            
+            DisposableHelper.setOnce(target, d1);
+            
+            assertTrue(d1.isDisposed());
+            
+            TestHelper.assertError(errors, 0, IllegalStateException.class, "Disposable already set!");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java b/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
index 33132eda7f..d6b52fd6b1 100644
--- a/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
+++ b/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
@@ -84,7 +84,7 @@ public void cancel() {
 
     @Test
     public void testRequestFromChainedOperator() throws Exception {
-        TestSubscriber<String> s = new TestSubscriber<String>();
+        TestSubscriber<String> s = new TestSubscriber<String>(10L);
         FlowableOperator<String, String> o = new FlowableOperator<String, String>() {
             @Override
             public Subscriber<? super String> apply(final Subscriber<? super String> s1) {
@@ -113,7 +113,6 @@ public void onNext(String t) {
                 };
             }
         };
-        s.request(10);
         Subscriber<? super String> ns = o.apply(s);
 
         final AtomicLong r = new AtomicLong();
@@ -190,7 +189,7 @@ public void cancel() {
 
     @Test
     public void testRequestFromDecoupledOperatorThatRequestsN() throws Exception {
-        TestSubscriber<String> s = new TestSubscriber<String>();
+        TestSubscriber<String> s = new TestSubscriber<String>(10L);
         final AtomicLong innerR = new AtomicLong();
         FlowableOperator<String, String> o = new FlowableOperator<String, String>() {
             @Override
@@ -238,7 +237,6 @@ public void onNext(String t) {
                 return as;
             }
         };
-        s.request(10);
         Subscriber<? super String> ns = o.apply(s);
 
         final AtomicLong r = new AtomicLong();
@@ -263,8 +261,7 @@ public void cancel() {
 
     @Test
     public void testRequestToFlowable() {
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
-        ts.request(3);
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(3L);
         final AtomicLong requested = new AtomicLong();
         Flowable.<Integer>unsafeCreate(new Publisher<Integer>() {
             @Override
diff --git a/src/test/java/io/reactivex/internal/disposables/ObserverFullArbiterTest.java b/src/test/java/io/reactivex/internal/disposables/ObserverFullArbiterTest.java
new file mode 100644
index 0000000000..576727266b
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/disposables/ObserverFullArbiterTest.java
@@ -0,0 +1,128 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.disposables;
+
+import static org.junit.Assert.*;
+
+import java.util.List;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.disposables.ObserverFullArbiter;
+import io.reactivex.internal.util.NotificationLite;
+import io.reactivex.observers.TestObserver;
+import io.reactivex.plugins.RxJavaPlugins;
+
+public class ObserverFullArbiterTest {
+
+    @Test
+    public void setSubscriptionAfterCancel() {
+        ObserverFullArbiter<Integer> fa = new ObserverFullArbiter<Integer>(new TestObserver<Integer>(), null, 128);
+                
+        fa.dispose();
+        
+        Disposable bs = Disposables.empty();
+        
+        assertFalse(fa.setSubscription(bs));
+        
+        assertFalse(fa.setSubscription(null));
+    }
+    
+    @Test
+    public void cancelAfterPoll() {
+        ObserverFullArbiter<Integer> fa = new ObserverFullArbiter<Integer>(new TestObserver<Integer>(), null, 128);
+
+        Disposable bs = Disposables.empty();
+        
+        fa.queue.offer(fa.s, NotificationLite.disposable(bs));
+
+        assertFalse(fa.isDisposed());
+
+        fa.dispose();
+        
+        assertTrue(fa.isDisposed());
+        
+        fa.drain();
+        
+        assertTrue(bs.isDisposed());
+    }
+    
+    @Test
+    public void errorAfterCancel() {
+        ObserverFullArbiter<Integer> fa = new ObserverFullArbiter<Integer>(new TestObserver<Integer>(), null, 128);
+
+        Disposable bs = Disposables.empty();
+
+        fa.dispose();
+
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            fa.onError(new TestException(), bs);
+            
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void cancelAfterError() {
+        ObserverFullArbiter<Integer> fa = new ObserverFullArbiter<Integer>(new TestObserver<Integer>(), null, 128);
+
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            fa.queue.offer(fa.s, NotificationLite.error(new TestException()));
+            
+            fa.dispose();
+            
+            fa.drain();
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void offerDifferentSubscription() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        
+        ObserverFullArbiter<Integer> fa = new ObserverFullArbiter<Integer>(ts, null, 128);
+
+        Disposable bs = Disposables.empty();
+        
+        fa.queue.offer(bs, NotificationLite.next(1));
+        
+        fa.drain();
+        
+        ts.assertNoValues();
+    }
+    
+    @Test
+    public void dontEnterDrain() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+
+        ObserverFullArbiter<Integer> fa = new ObserverFullArbiter<Integer>(ts, null, 128);
+
+        fa.queue.offer(fa.s, NotificationLite.next(1));
+        
+        fa.wip.getAndIncrement();
+        
+        fa.drain();
+        
+        ts.assertNoValues();
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
index 930cfd8057..bc2fe55525 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
@@ -297,7 +297,7 @@ public void testUsingDisposesEagerlyBeforeCompletion() {
         
         observable.safeSubscribe(observer);
 
-        assertEquals(Arrays.asList("disposed", "completed", "unsub"), events);
+        assertEquals(Arrays.asList("disposed", "completed"), events);
 
     }
 
@@ -324,7 +324,7 @@ public void testUsingDoesNotDisposesEagerlyBeforeCompletion() {
         
         observable.safeSubscribe(observer);
 
-        assertEquals(Arrays.asList("completed", "unsub", "disposed"), events);
+        assertEquals(Arrays.asList("completed", "disposed"), events);
 
     }
 
@@ -354,7 +354,7 @@ public void testUsingDisposesEagerlyBeforeError() {
         
         observable.safeSubscribe(observer);
 
-        assertEquals(Arrays.asList("disposed", "error", "unsub"), events);
+        assertEquals(Arrays.asList("disposed", "error"), events);
 
     }
     
@@ -382,7 +382,7 @@ public void testUsingDoesNotDisposesEagerlyBeforeError() {
         
         observable.safeSubscribe(observer);
 
-        assertEquals(Arrays.asList("error", "unsub", "disposed"), events);
+        assertEquals(Arrays.asList("error", "disposed"), events);
     }
 
     private static Action createUnsubAction(final List<String> events) {
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleMiscTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleMiscTest.java
index 9681d235bb..3b15050d23 100644
--- a/src/test/java/io/reactivex/internal/operators/single/SingleMiscTest.java
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleMiscTest.java
@@ -235,7 +235,7 @@ public boolean test(Throwable e) throws Exception {
     public void timeout() throws Exception {
         Single.never().timeout(100, TimeUnit.MILLISECONDS, Schedulers.io())
         .test()
-        .awaitDone()
+        .awaitDone(5, TimeUnit.SECONDS)
         .assertFailure(TimeoutException.class);
     }
 
@@ -244,7 +244,7 @@ public void timeoutOther() throws Exception {
         Single.never()
         .timeout(100, TimeUnit.MILLISECONDS, Schedulers.io(), Single.just(1))
         .test()
-        .awaitDone()
+        .awaitDone(5, TimeUnit.SECONDS)
         .assertResult(1);
     }
     
diff --git a/src/test/java/io/reactivex/internal/subscribers/flowable/BlockingSubscriberTest.java b/src/test/java/io/reactivex/internal/subscribers/flowable/BlockingSubscriberTest.java
new file mode 100644
index 0000000000..3ca14fbb86
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/subscribers/flowable/BlockingSubscriberTest.java
@@ -0,0 +1,130 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscribers.flowable;
+
+import static org.junit.Assert.*;
+
+import java.util.ArrayDeque;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.junit.Test;
+import org.reactivestreams.Subscription;
+
+import io.reactivex.TestHelper;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+
+public class BlockingSubscriberTest {
+
+    @Test
+    public void doubleOnSubscribe() {
+        TestHelper.doubleOnSubscribe(new BlockingSubscriber<Integer>(new ArrayDeque<Object>()));
+    }
+    
+    @Test
+    public void cancel() {
+        BlockingSubscriber<Integer> bq = new BlockingSubscriber<Integer>(new ArrayDeque<Object>());
+
+        assertFalse(bq.isCancelled());
+        
+        bq.cancel();
+        
+        assertTrue(bq.isCancelled());
+        
+        bq.cancel();
+        
+        assertTrue(bq.isCancelled());
+    }
+    
+    @Test
+    public void blockingFirstDoubleOnSubscribe() {
+        TestHelper.doubleOnSubscribe(new BlockingFirstSubscriber<Integer>());
+    }
+
+    @Test(timeout = 5000)
+    public void blockingFirstTimeout() {
+        BlockingFirstSubscriber<Integer> bf = new BlockingFirstSubscriber<Integer>();
+        
+        Thread.currentThread().interrupt();
+        
+        try {
+            bf.blockingGet();
+            fail("Should have thrown!");
+        } catch (RuntimeException ex) {
+            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
+        }
+    }
+
+    @Test(timeout = 5000)
+    public void blockingFirstTimeout2() {
+        BlockingFirstSubscriber<Integer> bf = new BlockingFirstSubscriber<Integer>();
+        
+        bf.onSubscribe(new BooleanSubscription());
+        
+        Thread.currentThread().interrupt();
+        
+        try {
+            bf.blockingGet();
+            fail("Should have thrown!");
+        } catch (RuntimeException ex) {
+            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
+        }
+    }
+
+    @Test
+    public void cancelOnRequest() {
+        
+        final BlockingFirstSubscriber<Integer> bf = new BlockingFirstSubscriber<Integer>();
+        
+        final AtomicBoolean b = new AtomicBoolean();
+        
+        Subscription s = new Subscription() {
+            @Override
+            public void request(long n) {
+                bf.cancelled = true;
+            }
+            @Override
+            public void cancel() {
+                b.set(true);
+            }
+        };
+        
+        bf.onSubscribe(s);
+        
+        assertTrue(b.get());
+    }
+    
+    @Test
+    public void cancelUpfront() {
+        
+        final BlockingFirstSubscriber<Integer> bf = new BlockingFirstSubscriber<Integer>();
+        
+        final AtomicBoolean b = new AtomicBoolean();
+
+        bf.cancelled = true;
+
+        Subscription s = new Subscription() {
+            @Override
+            public void request(long n) {
+                b.set(true);
+            }
+            @Override
+            public void cancel() {
+            }
+        };
+        
+        bf.onSubscribe(s);
+        
+        assertFalse(b.get());
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/subscribers/flowable/EmptyComponentTest.java b/src/test/java/io/reactivex/internal/subscribers/flowable/EmptyComponentTest.java
new file mode 100644
index 0000000000..5325dadb3d
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/subscribers/flowable/EmptyComponentTest.java
@@ -0,0 +1,73 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscribers.flowable;
+
+import static org.junit.Assert.assertTrue;
+
+import java.util.List;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.subscribers.flowable.EmptyComponent;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
+
+public class EmptyComponentTest {
+
+    @Test
+    public void normal() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        
+        try {
+            TestHelper.checkEnum(EmptyComponent.class);
+            
+            EmptyComponent c = EmptyComponent.INSTANCE;
+            
+            assertTrue(c.isDisposed());
+            
+            c.request(10);
+            
+            c.request(-10);
+            
+            Disposable d = Disposables.empty();
+            
+            c.onSubscribe(d);
+            
+            assertTrue(d.isDisposed());
+            
+            BooleanSubscription s = new BooleanSubscription();
+            
+            c.onSubscribe(s);
+            
+            assertTrue(s.isCancelled());
+            
+            c.onNext(null);
+            
+            c.onNext(1);
+            
+            c.onComplete();
+            
+            c.onError(new TestException());
+            
+            c.cancel();
+            
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/subscribers/flowable/FutureSubscriberTest.java b/src/test/java/io/reactivex/internal/subscribers/flowable/FutureSubscriberTest.java
new file mode 100644
index 0000000000..b5cce62887
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/subscribers/flowable/FutureSubscriberTest.java
@@ -0,0 +1,270 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscribers.flowable;
+
+import static org.junit.Assert.*;
+
+import java.util.*;
+import java.util.concurrent.*;
+
+import org.junit.*;
+
+import io.reactivex.TestHelper;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.schedulers.Schedulers;
+
+public class FutureSubscriberTest {
+
+    FutureSubscriber<Integer> fs;
+    
+    @Before
+    public void before() {
+        fs = new FutureSubscriber<Integer>();
+    }
+    
+    @Test
+    public void cancel() throws Exception {
+        assertFalse(fs.isDone());
+        
+        assertFalse(fs.isCancelled());
+        
+        fs.cancel();
+
+        fs.cancel();
+
+        fs.request(10);
+        
+        fs.request(-99);
+        
+        fs.cancel(false);
+        
+        assertTrue(fs.isDone());
+        
+        assertTrue(fs.isCancelled());
+        
+        try {
+            fs.get();
+            fail("Should have thrown");
+        } catch (CancellationException ex) {
+            // expected
+        }
+        
+        try {
+            fs.get(1, TimeUnit.MILLISECONDS);
+            fail("Should have thrown");
+        } catch (CancellationException ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void onError() throws Exception {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        
+        try {
+            fs.onError(new TestException("One"));
+            
+            fs.onError(new TestException("Two"));
+            
+            try {
+                fs.get(5, TimeUnit.MILLISECONDS);
+            } catch (ExecutionException ex) {
+                assertTrue(ex.toString(), ex.getCause() instanceof TestException);
+                assertEquals("One", ex.getCause().getMessage());
+            }
+            
+            TestHelper.assertError(errors, 0, TestException.class, "Two");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void onNext() throws Exception {
+        fs.onNext(1);
+        fs.onComplete();
+        
+        assertEquals(1, fs.get(5, TimeUnit.MILLISECONDS).intValue());
+    }
+    
+    @Test
+    public void onSubscribe() throws Exception {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        
+        try {
+            
+            BooleanSubscription s = new BooleanSubscription();
+            
+            fs.onSubscribe(s);
+
+            BooleanSubscription s2 = new BooleanSubscription();
+            
+            fs.onSubscribe(s2);
+            
+            assertFalse(s.isCancelled());
+            assertTrue(s2.isCancelled());
+            
+            TestHelper.assertError(errors, 0, IllegalStateException.class, "Subscription already set!");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void cancelRace() {
+        for (int i = 0; i < 500; i++) {
+            final FutureSubscriber<Integer> fs = new FutureSubscriber<Integer>();
+            
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    fs.cancel(false);
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.single());
+        }
+    }
+    
+    @Test
+    public void await() throws Exception {
+        Schedulers.single().scheduleDirect(new Runnable() {
+            @Override
+            public void run() {
+                fs.onNext(1);
+                fs.onComplete();
+            }
+        }, 100, TimeUnit.MILLISECONDS);
+        
+        assertEquals(1, fs.get(5, TimeUnit.SECONDS).intValue());
+    }
+    
+    @Test
+    public void onErrorCancelRace() {
+        for (int i = 0; i < 500; i++) {
+            final FutureSubscriber<Integer> fs = new FutureSubscriber<Integer>();
+            
+            final TestException ex = new TestException();
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    fs.cancel(false);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    fs.onError(ex);
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+        }
+    }
+    
+    @Test
+    public void onCompleteCancelRace() {
+        for (int i = 0; i < 500; i++) {
+            final FutureSubscriber<Integer> fs = new FutureSubscriber<Integer>();
+            
+            if (i % 3 == 0) {
+                fs.onSubscribe(new BooleanSubscription());
+            }
+
+            if (i % 2 == 0) {
+                fs.onNext(1);
+            }
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    fs.cancel(false);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    fs.onComplete();
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+        }
+    }
+    
+    @Test
+    public void onErrorOnComplete() throws Exception {
+        fs.onError(new TestException("One"));
+        fs.onComplete();
+        
+        try {
+            fs.get(5, TimeUnit.MILLISECONDS);
+        } catch (ExecutionException ex) {
+            assertTrue(ex.toString(), ex.getCause() instanceof TestException);
+            assertEquals("One", ex.getCause().getMessage());
+        }
+    }
+    
+    @Test
+    public void onCompleteOnError() throws Exception {
+        fs.onComplete();
+        fs.onError(new TestException("One"));
+        
+        try {
+            assertNull(fs.get(5, TimeUnit.MILLISECONDS));
+        } catch (ExecutionException ex) {
+            assertTrue(ex.toString(), ex.getCause() instanceof NoSuchElementException);
+        }
+    }
+    
+    @Test
+    public void cancelOnError() throws Exception {
+        fs.cancel(true);
+        fs.onError(new TestException("One"));
+        
+        try {
+            fs.get(5, TimeUnit.MILLISECONDS);
+            fail("Should have thrown");
+        } catch (CancellationException ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void cancelOnComplete() throws Exception {
+        fs.cancel(true);
+        fs.onComplete();
+        
+        try {
+            fs.get(5, TimeUnit.MILLISECONDS);
+            fail("Should have thrown");
+        } catch (CancellationException ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void onNextThenOnCompleteTwice() throws Exception {
+        fs.onNext(1);
+        fs.onComplete();
+        fs.onComplete();
+
+        assertEquals(1, fs.get(5, TimeUnit.MILLISECONDS).intValue());
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/subscriptions/ArrayCompositeSubscriptionTest.java b/src/test/java/io/reactivex/internal/subscriptions/ArrayCompositeSubscriptionTest.java
new file mode 100644
index 0000000000..bfb0fd9c29
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/subscriptions/ArrayCompositeSubscriptionTest.java
@@ -0,0 +1,137 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscriptions;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.schedulers.Schedulers;
+
+public class ArrayCompositeSubscriptionTest {
+
+    @Test
+    public void set() {
+        ArrayCompositeSubscription ac = new ArrayCompositeSubscription(1);
+        
+        BooleanSubscription bs1 = new BooleanSubscription();
+        
+        ac.setResource(0, bs1);
+        
+        assertFalse(bs1.isCancelled());
+        
+        BooleanSubscription bs2 = new BooleanSubscription();
+        
+        ac.setResource(0, bs2);
+        
+        assertTrue(bs1.isCancelled());
+        
+        assertFalse(bs2.isCancelled());
+
+        assertFalse(ac.isDisposed());
+
+        ac.dispose();
+        
+        assertTrue(bs2.isCancelled());
+        
+        assertTrue(ac.isDisposed());
+        
+        BooleanSubscription bs3 = new BooleanSubscription();
+
+        assertFalse(ac.setResource(0, bs3));
+        
+        assertTrue(bs3.isCancelled());
+        
+        assertFalse(ac.setResource(0, null));
+    }
+
+    @Test
+    public void replace() {
+        ArrayCompositeSubscription ac = new ArrayCompositeSubscription(1);
+        
+        BooleanSubscription bs1 = new BooleanSubscription();
+        
+        ac.replaceResource(0, bs1);
+        
+        assertFalse(bs1.isCancelled());
+        
+        BooleanSubscription bs2 = new BooleanSubscription();
+        
+        ac.replaceResource(0, bs2);
+        
+        assertFalse(bs1.isCancelled());
+        
+        assertFalse(bs2.isCancelled());
+
+        assertFalse(ac.isDisposed());
+
+        ac.dispose();
+        
+        assertTrue(bs2.isCancelled());
+        
+        assertTrue(ac.isDisposed());
+        
+        BooleanSubscription bs3 = new BooleanSubscription();
+
+        ac.replaceResource(0, bs3);
+        
+        assertTrue(bs3.isCancelled());
+        
+        ac.replaceResource(0, null);
+    }
+    
+    @Test
+    public void disposeRace() {
+        for (int i = 0; i < 500; i++) {
+            final ArrayCompositeSubscription ac = new ArrayCompositeSubscription(1000);
+            
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    ac.dispose();
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.single());
+        }
+    }
+
+    @Test
+    public void setReplaceRace() {
+        for (int i = 0; i < 500; i++) {
+            final ArrayCompositeSubscription ac = new ArrayCompositeSubscription(1);
+            
+            final BooleanSubscription s1 = new BooleanSubscription();
+            final BooleanSubscription s2 = new BooleanSubscription();
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    ac.setResource(0, s1);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    ac.replaceResource(0, s2);
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+        }
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/subscriptions/AsyncSubscriptionTest.java b/src/test/java/io/reactivex/internal/subscriptions/AsyncSubscriptionTest.java
index 78b748357b..069b05dbc8 100644
--- a/src/test/java/io/reactivex/internal/subscriptions/AsyncSubscriptionTest.java
+++ b/src/test/java/io/reactivex/internal/subscriptions/AsyncSubscriptionTest.java
@@ -29,7 +29,7 @@ public void testNoResource() {
         
         Subscription s = mock(Subscription.class);
         
-        assertTrue(as.setSubscription(s));
+        as.setSubscription(s);
         
         as.request(1);
         
@@ -47,7 +47,7 @@ public void testRequestBeforeSet() {
         
         as.request(1);
 
-        assertTrue(as.setSubscription(s));
+        as.setSubscription(s);
         
         as.cancel();
         
@@ -64,7 +64,7 @@ public void testCancelBeforeSet() {
         as.request(1);
         as.cancel();
 
-        assertFalse(as.setSubscription(s));
+        as.setSubscription(s);
         
         verify(s, never()).request(1);
         verify(s).cancel();
@@ -76,11 +76,11 @@ public void testSingleSet() {
         
         Subscription s = mock(Subscription.class);
         
-        assertTrue(as.setSubscription(s));
+        as.setSubscription(s);
 
         Subscription s1 = mock(Subscription.class);
 
-        assertTrue(as.setSubscription(s1));
+        as.setSubscription(s1);
         
         assertSame(as.actual.get(), s);
         
@@ -151,7 +151,7 @@ public void testReplaceResource2() {
 
         Disposable r2 = mock(Disposable.class);
         
-        assertTrue(as.replaceResource(r2));
+        as.replaceResource(r2);
 
         as.cancel();
         
@@ -167,7 +167,7 @@ public void testSetResourceAfterCancel() {
         
         Disposable r = mock(Disposable.class);
         
-        assertFalse(as.setResource(r));
+        as.setResource(r);
 
         verify(r).dispose();
     }
@@ -179,7 +179,7 @@ public void testReplaceResourceAfterCancel() {
 
         Disposable r = mock(Disposable.class);
         
-        assertFalse(as.replaceResource(r));
+        as.replaceResource(r);
         
         verify(r).dispose();
     }
@@ -190,7 +190,7 @@ public void testCancelOnce() {
         AsyncSubscription as = new AsyncSubscription(r);
         Subscription s = mock(Subscription.class);
         
-        assertTrue(as.setSubscription(s));
+        as.setSubscription(s);
         
         as.cancel();
         as.cancel();
@@ -200,4 +200,15 @@ public void testCancelOnce() {
         verify(s).cancel();
         verify(r).dispose();
     }
+    
+    @Test
+    public void disposed() {
+        AsyncSubscription as = new AsyncSubscription();
+        
+        assertFalse(as.isDisposed());
+        
+        as.dispose();
+        
+        assertTrue(as.isDisposed());
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/subscriptions/DeferredScalarSubscriptionTest.java b/src/test/java/io/reactivex/internal/subscriptions/DeferredScalarSubscriptionTest.java
new file mode 100644
index 0000000000..a2f0eef98a
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/subscriptions/DeferredScalarSubscriptionTest.java
@@ -0,0 +1,139 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscriptions;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.internal.fuseable.QueueSubscription;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class DeferredScalarSubscriptionTest {
+
+    @Test
+    public void queueSubscriptionSyncRejected() {
+        DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<Integer>(new TestSubscriber<Integer>());
+        
+        assertEquals(QueueSubscription.NONE, ds.requestFusion(QueueSubscription.SYNC));
+    }
+
+    @Test
+    public void clear() {
+        DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<Integer>(new TestSubscriber<Integer>());
+        
+        ds.value = 1;
+        
+        ds.clear();
+        
+        assertEquals(DeferredScalarSubscription.FUSED_CONSUMED, ds.get());
+        assertNull(ds.value);
+    }
+
+    @Test
+    public void cancel() {
+        DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<Integer>(new TestSubscriber<Integer>());
+        
+        assertTrue(ds.tryCancel());
+
+        assertFalse(ds.tryCancel());
+    }
+    
+    @Test
+    public void completeCancelRace() {
+        for (int i = 0; i < 500; i++) {
+            final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<Integer>(new TestSubscriber<Integer>());
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    ds.complete(1);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    ds.cancel();
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+        }
+    }
+    
+    @Test
+    public void requestClearRace() {
+        for (int i = 0; i < 5000; i++) {
+            TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
+            
+            final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<Integer>(ts);
+            ts.onSubscribe(ds);
+            ds.complete(1);
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    ds.request(1);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    ds.value = null;
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+            
+            if (ts.valueCount() >= 1) {
+                ts.assertValue(1);
+            }
+        }
+    }
+    
+    @Test
+    public void requestCancelRace() {
+        for (int i = 0; i < 5000; i++) {
+            TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
+            
+            final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<Integer>(ts);
+            ts.onSubscribe(ds);
+            ds.complete(1);
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    ds.request(1);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    ds.cancel();
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+            
+            if (ts.valueCount() >= 1) {
+                ts.assertValue(1);
+            }
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/subscriptions/FullArbiterTest.java b/src/test/java/io/reactivex/internal/subscriptions/FullArbiterTest.java
new file mode 100644
index 0000000000..f175c32028
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/subscriptions/FullArbiterTest.java
@@ -0,0 +1,129 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscriptions;
+
+import static org.junit.Assert.*;
+
+import java.util.List;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.util.NotificationLite;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class FullArbiterTest {
+
+    @Test
+    public void initialRequested() {
+        FullArbiter.INITIAL.request(-99);
+    }
+
+    @Test
+    public void initialCancel() {
+        FullArbiter.INITIAL.cancel();
+    }
+    
+    @Test
+    public void invalidDeferredRequest() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            new FullArbiter<Integer>(new TestSubscriber<Integer>(), null, 128).request(-99);
+            
+            TestHelper.assertError(errors, 0, IllegalArgumentException.class, "n > 0 required but it was -99");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void setSubscriptionAfterCancel() {
+        FullArbiter<Integer> fa = new FullArbiter<Integer>(new TestSubscriber<Integer>(), null, 128);
+                
+        fa.cancel();
+        
+        BooleanSubscription bs = new BooleanSubscription();
+        
+        assertFalse(fa.setSubscription(bs));
+        
+        assertFalse(fa.setSubscription(null));
+    }
+    
+    @Test
+    public void cancelAfterPoll() {
+        FullArbiter<Integer> fa = new FullArbiter<Integer>(new TestSubscriber<Integer>(), null, 128);
+
+        BooleanSubscription bs = new BooleanSubscription();
+        
+        fa.queue.offer(fa.s, NotificationLite.subscription(bs));
+        
+        fa.cancel();
+        
+        fa.drain();
+        
+        assertTrue(bs.isCancelled());
+    }
+    
+    @Test
+    public void errorAfterCancel() {
+        FullArbiter<Integer> fa = new FullArbiter<Integer>(new TestSubscriber<Integer>(), null, 128);
+
+        BooleanSubscription bs = new BooleanSubscription();
+
+        fa.cancel();
+
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            fa.onError(new TestException(), bs);
+            
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void cancelAfterError() {
+        FullArbiter<Integer> fa = new FullArbiter<Integer>(new TestSubscriber<Integer>(), null, 128);
+
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            fa.queue.offer(fa.s, NotificationLite.error(new TestException()));
+            
+            fa.cancel();
+            
+            fa.drain();
+            TestHelper.assertError(errors, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void offerDifferentSubscription() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        FullArbiter<Integer> fa = new FullArbiter<Integer>(ts, null, 128);
+
+        BooleanSubscription bs = new BooleanSubscription();
+        
+        fa.queue.offer(bs, NotificationLite.next(1));
+        
+        fa.drain();
+        
+        ts.assertNoValues();
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/subscriptions/QueueSubscriptionTest.java b/src/test/java/io/reactivex/internal/subscriptions/QueueSubscriptionTest.java
new file mode 100644
index 0000000000..d73957606d
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/subscriptions/QueueSubscriptionTest.java
@@ -0,0 +1,118 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscriptions;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+import io.reactivex.TestHelper;
+
+public class QueueSubscriptionTest {
+    static final class EmptyQS extends BasicQueueSubscription<Integer> {
+
+        /**
+         * 
+         */
+        private static final long serialVersionUID = -5312809687598840520L;
+
+        @Override
+        public int requestFusion(int mode) {
+            return 0;
+        }
+
+        @Override
+        public Integer poll() throws Exception {
+            return null;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+
+        @Override
+        public void clear() {
+            
+        }
+
+        @Override
+        public void request(long n) {
+            
+        }
+
+        @Override
+        public void cancel() {
+            
+        }
+        
+    }
+
+    static final class EmptyIntQS extends BasicIntQueueSubscription<Integer> {
+
+        /**
+         * 
+         */
+        private static final long serialVersionUID = -1374033403007296252L;
+
+        @Override
+        public int requestFusion(int mode) {
+            return 0;
+        }
+
+        @Override
+        public Integer poll() throws Exception {
+            return null;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+
+        @Override
+        public void clear() {
+            
+        }
+
+        @Override
+        public void request(long n) {
+            
+        }
+
+        @Override
+        public void cancel() {
+            
+        }
+        
+    }
+
+    @Test
+    public void noOfferBasic() {
+        TestHelper.assertNoOffer(new EmptyQS());
+    }
+    
+    @Test
+    public void noOfferBasicInt() {
+        TestHelper.assertNoOffer(new EmptyIntQS());
+    }
+    
+    @Test
+    public void empty() {
+        TestHelper.checkEnum(EmptySubscription.class);
+        
+        assertEquals("EmptySubscription", EmptySubscription.INSTANCE.toString());
+        
+        TestHelper.assertNoOffer(EmptySubscription.INSTANCE);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/subscriptions/ScalarSubscriptionTest.java b/src/test/java/io/reactivex/internal/subscriptions/ScalarSubscriptionTest.java
new file mode 100644
index 0000000000..ada8ffe8d5
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/subscriptions/ScalarSubscriptionTest.java
@@ -0,0 +1,50 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscriptions;
+
+import java.util.List;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class ScalarSubscriptionTest {
+
+    @Test
+    public void badRequest() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
+        
+        ScalarSubscription<Integer> sc = new ScalarSubscription<Integer>(ts, 1);
+        
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            sc.request(-99);
+            
+            TestHelper.assertError(errors, 0, IllegalArgumentException.class, "n > 0 required but it was -99");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void noOffer() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);
+        
+        ScalarSubscription<Integer> sc = new ScalarSubscription<Integer>(ts, 1);
+        
+        TestHelper.assertNoOffer(sc);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/subscriptions/SubscriptionArbiterTest.java b/src/test/java/io/reactivex/internal/subscriptions/SubscriptionArbiterTest.java
new file mode 100644
index 0000000000..4b403c771f
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/subscriptions/SubscriptionArbiterTest.java
@@ -0,0 +1,184 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscriptions;
+
+import static org.junit.Assert.*;
+
+import java.util.List;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.plugins.RxJavaPlugins;
+
+public class SubscriptionArbiterTest {
+
+    @Test
+    public void setSubscriptionMissed() {
+        SubscriptionArbiter sa = new SubscriptionArbiter();
+        
+        sa.getAndIncrement();
+        
+        BooleanSubscription bs1 = new BooleanSubscription();
+        
+        sa.setSubscription(bs1);
+        
+        BooleanSubscription bs2 = new BooleanSubscription();
+        
+        sa.setSubscription(bs2);
+        
+        assertTrue(bs1.isCancelled());
+        
+        assertFalse(bs2.isCancelled());
+    }
+    
+    @Test
+    public void invalidDeferredRequest() {
+        SubscriptionArbiter sa = new SubscriptionArbiter();
+        
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            sa.request(-99);
+            
+            TestHelper.assertError(errors, 0, IllegalArgumentException.class, "n > 0 required but it was -99");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void unbounded() {
+        SubscriptionArbiter sa = new SubscriptionArbiter();
+        
+        sa.request(Long.MAX_VALUE);
+        
+        assertEquals(Long.MAX_VALUE, sa.requested);
+        
+        assertTrue(sa.isUnbounded());
+        
+        sa.unbounded = false;
+        
+        sa.request(Long.MAX_VALUE);
+        
+        assertEquals(Long.MAX_VALUE, sa.requested);
+        
+        sa.produced(1);
+        
+        assertEquals(Long.MAX_VALUE, sa.requested);
+        
+        sa.unbounded = false;
+
+        sa.produced(Long.MAX_VALUE);
+        
+        assertEquals(Long.MAX_VALUE, sa.requested);
+    }
+    
+    @Test
+    public void cancelled() {
+        SubscriptionArbiter sa = new SubscriptionArbiter();
+        sa.cancelled = true;
+        
+        BooleanSubscription bs1 = new BooleanSubscription();
+        
+        sa.missedSubscription.set(bs1);
+        
+        sa.getAndIncrement();
+        
+        sa.drainLoop();
+        
+        assertTrue(bs1.isCancelled());
+    }
+    
+    @Test
+    public void drainUnbounded() {
+        SubscriptionArbiter sa = new SubscriptionArbiter();
+        
+        sa.getAndIncrement();
+
+        sa.requested = Long.MAX_VALUE;
+        
+        sa.drainLoop();
+    }
+
+    @Test
+    public void drainMissedRequested() {
+        SubscriptionArbiter sa = new SubscriptionArbiter();
+        
+        sa.getAndIncrement();
+
+        sa.requested = 0;
+        
+        sa.missedRequested.set(1);
+        
+        sa.drainLoop();
+        
+        assertEquals(1, sa.requested);
+    }
+
+    @Test
+    public void drainMissedRequestedProduced() {
+        SubscriptionArbiter sa = new SubscriptionArbiter();
+        
+        sa.getAndIncrement();
+
+        sa.requested = 0;
+        
+        sa.missedRequested.set(Long.MAX_VALUE);
+        
+        sa.missedProduced.set(1);
+        
+        sa.drainLoop();
+        
+        assertEquals(Long.MAX_VALUE, sa.requested);
+    }
+
+    @Test
+    public void drainMissedRequestedMoreProduced() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            SubscriptionArbiter sa = new SubscriptionArbiter();
+            
+            sa.getAndIncrement();
+    
+            sa.requested = 0;
+            
+            sa.missedRequested.set(1);
+            
+            sa.missedProduced.set(2);
+            
+            sa.drainLoop();
+            
+            assertEquals(0, sa.requested);
+            
+            TestHelper.assertError(errors, 0, IllegalStateException.class, "More produced than requested: -1");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void missedSubscriptionNoPrior() {
+        SubscriptionArbiter sa = new SubscriptionArbiter();
+        
+        sa.getAndIncrement();
+
+        BooleanSubscription bs1 = new BooleanSubscription();
+
+        sa.missedSubscription.set(bs1);
+        
+        sa.drainLoop();
+        
+        assertSame(bs1, sa.actual);
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/subscriptions/SubscriptionHelperTest.java b/src/test/java/io/reactivex/internal/subscriptions/SubscriptionHelperTest.java
new file mode 100644
index 0000000000..1746a8009b
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/subscriptions/SubscriptionHelperTest.java
@@ -0,0 +1,234 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscriptions;
+
+import static org.junit.Assert.*;
+
+import java.util.List;
+import java.util.concurrent.atomic.*;
+
+import org.junit.Test;
+import org.reactivestreams.Subscription;
+
+import io.reactivex.TestHelper;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.schedulers.Schedulers;
+
+public class SubscriptionHelperTest {
+
+    @Test
+    public void checkEnum() {
+        TestHelper.checkEnum(SubscriptionHelper.class);
+    }
+    
+    @Test
+    public void validateNullThrows() {
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            SubscriptionHelper.validate(null, null);
+            
+            TestHelper.assertError(errors, 0, NullPointerException.class, "next is null");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void cancelNoOp() {
+        SubscriptionHelper.CANCELLED.cancel();
+    }
+    
+    @Test
+    public void set() {
+        AtomicReference<Subscription> s = new AtomicReference<Subscription>();
+        
+        BooleanSubscription bs1 = new BooleanSubscription();
+        
+        assertTrue(SubscriptionHelper.set(s, bs1));
+        
+        BooleanSubscription bs2 = new BooleanSubscription();
+        
+        assertTrue(SubscriptionHelper.set(s, bs2));
+        
+        assertTrue(bs1.isCancelled());
+        
+        assertFalse(bs2.isCancelled());
+    }
+    
+    @Test
+    public void replace() {
+        AtomicReference<Subscription> s = new AtomicReference<Subscription>();
+        
+        BooleanSubscription bs1 = new BooleanSubscription();
+        
+        assertTrue(SubscriptionHelper.replace(s, bs1));
+        
+        BooleanSubscription bs2 = new BooleanSubscription();
+        
+        assertTrue(SubscriptionHelper.replace(s, bs2));
+        
+        assertFalse(bs1.isCancelled());
+        
+        assertFalse(bs2.isCancelled());
+    }
+    
+    @Test
+    public void cancelRace() {
+        for (int i = 0; i < 500; i++) {
+            final AtomicReference<Subscription> s = new AtomicReference<Subscription>();
+            
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    SubscriptionHelper.cancel(s);
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.single());
+        }
+    }
+    
+    @Test
+    public void setRace() {
+        for (int i = 0; i < 500; i++) {
+            final AtomicReference<Subscription> s = new AtomicReference<Subscription>();
+
+            final BooleanSubscription bs1 = new BooleanSubscription();
+            final BooleanSubscription bs2 = new BooleanSubscription();
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    SubscriptionHelper.set(s, bs1);
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    SubscriptionHelper.set(s, bs2);
+                }
+            };
+
+            TestHelper.race(r1, r2, Schedulers.single());
+            
+            assertTrue(bs1.isCancelled() ^ bs2.isCancelled());
+        }
+    }
+    
+    @Test
+    public void replaceRace() {
+        for (int i = 0; i < 500; i++) {
+            final AtomicReference<Subscription> s = new AtomicReference<Subscription>();
+
+            final BooleanSubscription bs1 = new BooleanSubscription();
+            final BooleanSubscription bs2 = new BooleanSubscription();
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    SubscriptionHelper.replace(s, bs1);
+                }
+            };
+
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    SubscriptionHelper.replace(s, bs2);
+                }
+            };
+
+            TestHelper.race(r1, r2, Schedulers.single());
+            
+            assertFalse(bs1.isCancelled());
+            assertFalse(bs2.isCancelled());
+        }
+    }
+
+    @Test
+    public void cancelAndChange() {
+        AtomicReference<Subscription> s = new AtomicReference<Subscription>();
+        
+        SubscriptionHelper.cancel(s);
+        
+        BooleanSubscription bs1 = new BooleanSubscription();
+        assertFalse(SubscriptionHelper.set(s, bs1));
+        assertTrue(bs1.isCancelled());
+
+        assertFalse(SubscriptionHelper.set(s, null));
+
+        BooleanSubscription bs2 = new BooleanSubscription();
+        assertFalse(SubscriptionHelper.replace(s, bs2));
+        assertTrue(bs2.isCancelled());
+        
+        assertFalse(SubscriptionHelper.replace(s, null));
+    }
+
+    @Test
+    public void invalidDeferredRequest() {
+        AtomicReference<Subscription> s = new AtomicReference<Subscription>();
+        AtomicLong r = new AtomicLong();
+        
+        List<Throwable> errors = TestHelper.trackPluginErrors();
+        try {
+            SubscriptionHelper.deferredRequest(s, r, -99);
+            
+            TestHelper.assertError(errors, 0, IllegalArgumentException.class, "n > 0 required but it was -99");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void deferredRace() {
+        for (int i = 0; i < 500; i++) {
+            final AtomicReference<Subscription> s = new AtomicReference<Subscription>();
+            final AtomicLong r = new AtomicLong();
+            
+            final AtomicLong q = new AtomicLong();
+            
+            final Subscription a = new Subscription() {
+                @Override
+                public void request(long n) {
+                    q.addAndGet(n);
+                }
+                
+                @Override
+                public void cancel() {
+                    
+                }
+            };
+
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    SubscriptionHelper.deferredSetOnce(s, r, a);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    SubscriptionHelper.deferredRequest(s, r, 1);
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+            
+            assertSame(a, s.get());
+            assertEquals(1, q.get());
+            assertEquals(0, r.get());
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/observers/SerializedObserverTest.java b/src/test/java/io/reactivex/observers/SerializedObserverTest.java
index 2c302d5c92..900dfcad76 100644
--- a/src/test/java/io/reactivex/observers/SerializedObserverTest.java
+++ b/src/test/java/io/reactivex/observers/SerializedObserverTest.java
@@ -212,7 +212,7 @@ public void runConcurrencyTest() {
             TestConcurrencySubscriber tw = new TestConcurrencySubscriber();
             // we need Synchronized + SafeSubscriber to handle synchronization plus life-cycle
             Subscriber<String> w = serializedSubscriber(new SafeSubscriber<String>(tw));
-            w.onSubscribe(EmptySubscription.INSTANCE);
+            w.onSubscribe(new BooleanSubscription());
 
             Future<?> f1 = tp.submit(new OnNextThread(w, 12000));
             Future<?> f2 = tp.submit(new OnNextThread(w, 5000));
diff --git a/src/test/java/io/reactivex/observers/TestObserverTest.java b/src/test/java/io/reactivex/observers/TestObserverTest.java
index 69d0cd93c8..9d02c16d91 100644
--- a/src/test/java/io/reactivex/observers/TestObserverTest.java
+++ b/src/test/java/io/reactivex/observers/TestObserverTest.java
@@ -18,7 +18,7 @@
 
 import java.io.IOException;
 import java.util.*;
-import java.util.concurrent.*;
+import java.util.concurrent.TimeUnit;
 
 import org.junit.*;
 import org.junit.rules.ExpectedException;
@@ -26,14 +26,17 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.Observable;
+import io.reactivex.Observer;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.TestException;
-import io.reactivex.functions.Consumer;
+import io.reactivex.functions.*;
 import io.reactivex.internal.fuseable.QueueDisposable;
 import io.reactivex.internal.operators.observable.ObservableScalarXMap.ScalarDisposable;
 import io.reactivex.internal.subscriptions.EmptySubscription;
 import io.reactivex.processors.PublishProcessor;
 import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subjects.UnicastSubject;
 import io.reactivex.subscribers.TestSubscriber;
 
 public class TestObserverTest {
@@ -448,7 +451,14 @@ public void assertFuseable() {
         } catch (AssertionError ex) {
             // expected
         }
-        
+
+        try {
+            ts.assertFusionMode(QueueDisposable.SYNC);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
         ts = TestObserver.create();
         ts.setInitialFusionMode(QueueDisposable.ANY);
         
@@ -647,6 +657,10 @@ public void onNext() {
         ts.assertValue(1);
         
         assertEquals(Arrays.asList(Arrays.asList(1), Collections.emptyList(), Collections.emptyList()), ts.getEvents());
+        
+        ts.onComplete();
+        
+        assertEquals(Arrays.asList(Arrays.asList(1), Collections.emptyList(), Collections.singletonList(Notification.createOnComplete())), ts.getEvents());
     }
     
     @Test
@@ -876,4 +890,234 @@ public void assertValueSequence() {
             // expected
         }
     }
+    
+    @Test
+    public void assertEmpty() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        
+        try {
+            ts.assertEmpty();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        ts.onSubscribe(Disposables.empty());
+        
+        ts.assertEmpty();
+        
+        ts.onNext(1);
+        
+        try {
+            ts.assertEmpty();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void awaitDoneTimed() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+
+        Thread.currentThread().interrupt();
+        
+        try {
+            ts.awaitDone(5, TimeUnit.SECONDS);
+        } catch (RuntimeException ex) {
+            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
+        }
+    }
+    
+    @Test
+    public void assertNotSubscribed() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+
+        ts.assertNotSubscribed();
+        
+        ts.errors().add(new TestException());
+ 
+        try {
+            ts.assertNotSubscribed();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void assertErrorMultiple() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        
+        TestException e = new TestException();
+        ts.errors().add(e);
+        ts.errors().add(new TestException());
+ 
+        try {
+            ts.assertError(TestException.class);
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        try {
+            ts.assertError(e);
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        try {
+            ts.assertErrorMessage("");
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void assertComplete() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+
+        ts.onSubscribe(Disposables.empty());
+        
+        try {
+            ts.assertComplete();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        ts.onComplete();
+        
+        ts.assertComplete();
+        
+        ts.onComplete();
+        
+        try {
+            ts.assertComplete();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+
+    @Test
+    public void completeWithoutOnSubscribe() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        
+        ts.onComplete();
+        
+        ts.assertError(IllegalStateException.class);
+    }
+
+    @Test
+    public void completeDelegateThrows() {
+        TestObserver<Integer> ts = new TestObserver<Integer>(new Observer<Integer>() {
+
+            @Override
+            public void onSubscribe(Disposable d) {
+                
+            }
+
+            @Override
+            public void onNext(Integer value) {
+                
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                throw new TestException();
+            }
+
+            @Override
+            public void onComplete() {
+                throw new TestException();
+            }
+            
+        });
+
+        ts.onSubscribe(Disposables.empty());
+
+        try {
+            ts.onComplete();
+            throw new RuntimeException("Should have thrown!");
+        } catch (TestException ex) {
+            assertTrue(ts.isTerminated());
+        }
+    }
+    
+    @Test
+    public void errorDelegateThrows() {
+        TestObserver<Integer> ts = new TestObserver<Integer>(new Observer<Integer>() {
+
+            @Override
+            public void onSubscribe(Disposable d) {
+                
+            }
+
+            @Override
+            public void onNext(Integer value) {
+                
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                throw new TestException();
+            }
+
+            @Override
+            public void onComplete() {
+                throw new TestException();
+            }
+            
+        });
+
+        ts.onSubscribe(Disposables.empty());
+
+        try {
+            ts.onError(new IOException());
+            throw new RuntimeException("Should have thrown!");
+        } catch (TestException ex) {
+            assertTrue(ts.isTerminated());
+        }
+    }
+    
+    @Test
+    public void syncQueueThrows() {
+        TestObserver<Object> ts = new TestObserver<Object>();
+        ts.setInitialFusionMode(QueueDisposable.SYNC);
+        
+        Observable.range(1, 5)
+        .map(new Function<Integer, Object>() {
+            @Override
+            public Object apply(Integer v) throws Exception { throw new TestException(); }
+        })
+        .subscribe(ts);
+        
+        ts.assertSubscribed()
+        .assertFuseable()
+        .assertFusionMode(QueueDisposable.SYNC)
+        .assertFailure(TestException.class);
+    }
+    
+    @Test
+    public void asyncQueueThrows() {
+        TestObserver<Object> ts = new TestObserver<Object>();
+        ts.setInitialFusionMode(QueueDisposable.ANY);
+        
+        UnicastSubject<Integer> up = UnicastSubject.create();
+        
+        up
+        .map(new Function<Integer, Object>() {
+            @Override
+            public Object apply(Integer v) throws Exception { throw new TestException(); }
+        })
+        .subscribe(ts);
+        
+        up.onNext(1);
+        
+        ts.assertSubscribed()
+        .assertFuseable()
+        .assertFusionMode(QueueDisposable.ASYNC)
+        .assertFailure(TestException.class);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java
index 0f23f28a89..b334730cc0 100644
--- a/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java
+++ b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java
@@ -39,6 +39,7 @@
 import io.reactivex.internal.functions.Functions;
 import io.reactivex.internal.operators.completable.CompletableError;
 import io.reactivex.internal.operators.flowable.FlowableRange;
+import io.reactivex.internal.operators.maybe.MaybeError;
 import io.reactivex.internal.operators.observable.ObservableRange;
 import io.reactivex.internal.operators.single.SingleJust;
 import io.reactivex.internal.schedulers.ImmediateThinScheduler;
@@ -1016,6 +1017,20 @@ public void subscribeActual(CompletableObserver t) {
             };
 
             assertSame(cos, RxJavaPlugins.onAssembly(cos));
+
+            assertNull(RxJavaPlugins.onAssembly((Maybe)null));
+
+            assertNull(RxJavaPlugins.onSchedule(null));
+
+            Maybe myb = new Maybe() {
+                @Override
+                public void subscribeActual(MaybeObserver t) {
+                    
+                }
+            };
+
+            assertSame(myb, RxJavaPlugins.onAssembly(myb));
+            
             
             assertNull(RxJavaPlugins.onSchedule(null));
             
@@ -1023,7 +1038,7 @@ public void subscribeActual(CompletableObserver t) {
             
             assertSame(action, RxJavaPlugins.onSchedule(action));
             
-            class AllSubscriber implements Subscriber, Observer, SingleObserver, CompletableObserver {
+            class AllSubscriber implements Subscriber, Observer, SingleObserver, CompletableObserver, MaybeObserver {
 
                 @Override
                 public void onSuccess(Object value) {
@@ -1075,6 +1090,10 @@ public void onComplete() {
             
             assertSame(all, RxJavaPlugins.onSubscribe(Completable.never(), all));
 
+            assertNull(RxJavaPlugins.onSubscribe(Maybe.never(), null));
+            
+            assertSame(all, RxJavaPlugins.onSubscribe(Maybe.never(), all));
+
             // These hooks don't exist in 2.0
 //            Subscription subscription = Subscriptions.empty();
 //            
@@ -1599,4 +1618,81 @@ public Subscriber apply(Flowable f, Subscriber s) throws Exception {
         }
     }
 
+
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void maybeCreate() {
+        try {
+            RxJavaPlugins.setOnMaybeAssembly(new Function<Maybe, Maybe>() {
+                @Override
+                public Maybe apply(Maybe t) {
+                    return new MaybeError(new TestException());
+                }
+            });
+            
+            Maybe.empty()
+            .test()
+            .assertNoValues()
+            .assertNotComplete()
+            .assertError(TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        Maybe.empty()
+        .test()
+        .assertNoValues()
+        .assertNoErrors()
+        .assertComplete();
+    }
+    
+    @Test
+    @SuppressWarnings("rawtypes")
+    public void maybeStart() {
+        try {
+            RxJavaPlugins.setOnMaybeSubscribe(new BiFunction<Maybe, MaybeObserver, MaybeObserver>() {
+                @Override
+                public MaybeObserver apply(Maybe o, final MaybeObserver t) {
+                    return new MaybeObserver() {
+                        @Override
+                        public void onSubscribe(Disposable d) {
+                            t.onSubscribe(d);
+                        }
+                        
+                        @SuppressWarnings("unchecked")
+                        @Override
+                        public void onSuccess(Object value) {
+                            t.onSuccess(value);
+                        }
+                        
+                        @Override
+                        public void onError(Throwable e) {
+                            t.onError(e);
+                        }
+                        
+                        @Override
+                        public void onComplete() {
+                            t.onError(new TestException());
+                        }
+                    };
+                }
+            });
+            
+            Maybe.empty()
+            .test()
+            .assertNoValues()
+            .assertNotComplete()
+            .assertError(TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        // make sure the reset worked
+        
+        Maybe.empty()
+        .test()
+        .assertNoValues()
+        .assertNoErrors()
+        .assertComplete();
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/SchedulerTest.java b/src/test/java/io/reactivex/schedulers/SchedulerTest.java
index ab6b5a61f7..5261f06c74 100644
--- a/src/test/java/io/reactivex/schedulers/SchedulerTest.java
+++ b/src/test/java/io/reactivex/schedulers/SchedulerTest.java
@@ -239,4 +239,9 @@ public void run() {
             RxJavaPlugins.reset();
         }
     }
+    
+    @Test
+    public void schedulersUtility() {
+        TestHelper.checkUtilityClass(Schedulers.class);
+    }
 }
diff --git a/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java b/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java
index d5a37e379b..d27933fde4 100644
--- a/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java
+++ b/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java
@@ -13,7 +13,7 @@
 
 package io.reactivex.schedulers;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 import static org.mockito.Matchers.anyLong;
 import static org.mockito.Mockito.*;
 
@@ -25,10 +25,12 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.functions.Function;
 import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.internal.util.ExceptionHelper;
+import io.reactivex.schedulers.TestScheduler.*;
 
 public class TestSchedulerTest {
 
@@ -225,5 +227,32 @@ public void run() {
             inner.dispose();
         }
     }
+    
+    @Test
+    public void timedRunnableToString() {
+        TimedRunnable r = new TimedRunnable((TestWorker) new TestScheduler().createWorker(), 5, new Runnable() {
+            @Override
+            public void run() {
+                // TODO Auto-generated method stub
+                
+            }
+            @Override
+            public String toString() {
+                return "Runnable";
+            }
+        }, 1);
+        
+        assertEquals("TimedRunnable(time = 5, run = Runnable)", r.toString());
+    }
+    
+    @Test
+    public void workerDisposed() {
+        TestScheduler scheduler = new TestScheduler();
+        
+        Worker w = scheduler.createWorker();
+        w.dispose();
+        assertTrue(w.isDisposed());
+    }
+    
 
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/schedulers/TimedTest.java b/src/test/java/io/reactivex/schedulers/TimedTest.java
new file mode 100644
index 0000000000..99eb7ae8ac
--- /dev/null
+++ b/src/test/java/io/reactivex/schedulers/TimedTest.java
@@ -0,0 +1,87 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.schedulers;
+
+import java.util.concurrent.TimeUnit;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+public class TimedTest {
+
+    @Test
+    public void properties() {
+        Timed<Integer> timed = new Timed<Integer>(1, 5, TimeUnit.SECONDS);
+        
+        assertEquals(1, timed.value().intValue());
+        assertEquals(5, timed.time());
+        assertEquals(5000, timed.time(TimeUnit.MILLISECONDS));
+        assertSame(TimeUnit.SECONDS, timed.unit());
+    }
+    
+    @Test
+    public void hashCodeOf() {
+        Timed<Integer> t1 = new Timed<Integer>(1, 5, TimeUnit.SECONDS);
+        
+        assertEquals(TimeUnit.SECONDS.hashCode() + 31 * (5 + 31 * 1), t1.hashCode());
+
+        Timed<Integer> t2 = new Timed<Integer>(null, 5, TimeUnit.SECONDS);
+        
+        assertEquals(TimeUnit.SECONDS.hashCode() + 31 * (5 + 31 * 0), t2.hashCode());
+    }
+    
+    @Test
+    public void equalsWith() {
+        Timed<Integer> t1 = new Timed<Integer>(1, 5, TimeUnit.SECONDS);
+        Timed<Integer> t2 = new Timed<Integer>(1, 5, TimeUnit.SECONDS);
+        Timed<Integer> t3 = new Timed<Integer>(2, 5, TimeUnit.SECONDS);
+        Timed<Integer> t4 = new Timed<Integer>(1, 4, TimeUnit.SECONDS);
+        Timed<Integer> t5 = new Timed<Integer>(1, 5, TimeUnit.MINUTES);
+        
+        assertEquals(t1, t1);
+        assertEquals(t1, t2);
+        
+        assertNotEquals(t1, t3);
+        assertNotEquals(t1, t4);
+        assertNotEquals(t2, t3);
+        assertNotEquals(t2, t4);
+        assertNotEquals(t2, t5);
+
+        assertNotEquals(t3, t1);
+        assertNotEquals(t3, t2);
+        assertNotEquals(t3, t4);
+        assertNotEquals(t3, t5);
+        
+        assertNotEquals(t4, t1);
+        assertNotEquals(t4, t2);
+        assertNotEquals(t4, t3);
+        assertNotEquals(t4, t5);
+        
+        assertNotEquals(t5, t1);
+        assertNotEquals(t5, t2);
+        assertNotEquals(t5, t3);
+        assertNotEquals(t5, t4);
+        
+        assertNotEquals(new Object(), t1);
+        
+        assertFalse(t1.equals(new Object()));
+    }
+    
+    @Test
+    public void toStringOf() {
+        Timed<Integer> t1 = new Timed<Integer>(1, 5, TimeUnit.SECONDS);
+        
+        assertEquals("Timed[time=5, unit=SECONDS, value=1]", t1.toString());
+    }
+}
diff --git a/src/test/java/io/reactivex/subscribers/SafeSubscriberTest.java b/src/test/java/io/reactivex/subscribers/SafeSubscriberTest.java
index 84094f4aae..92496f67ec 100644
--- a/src/test/java/io/reactivex/subscribers/SafeSubscriberTest.java
+++ b/src/test/java/io/reactivex/subscribers/SafeSubscriberTest.java
@@ -13,14 +13,21 @@
 
 package io.reactivex.subscribers;
 
+import static org.junit.Assert.*;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.*;
 
-import org.junit.Test;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.junit.*;
 import org.mockito.Mockito;
 import org.reactivestreams.*;
 
 import io.reactivex.*;
+import io.reactivex.exceptions.*;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public class SafeSubscriberTest {
 
@@ -148,4 +155,892 @@ public void request(long n) {
         }
 
     }
+
+    @Test
+    public void onNextFailure() {
+        AtomicReference<Throwable> onError = new AtomicReference<Throwable>();
+        try {
+            OBSERVER_ONNEXT_FAIL(onError).onNext("one");
+            fail("expects exception to be thrown");
+        } catch (Exception e) {
+            assertNull(onError.get());
+            assertTrue(e instanceof SafeSubscriberTestException);
+            assertEquals("onNextFail", e.getMessage());
+        }
+    }
+
+    @Test
+    public void onNextFailureSafe() {
+        AtomicReference<Throwable> onError = new AtomicReference<Throwable>();
+        try {
+            SafeSubscriber<String> safeObserver = new SafeSubscriber<String>(OBSERVER_ONNEXT_FAIL(onError));
+            safeObserver.onSubscribe(new BooleanSubscription());
+            safeObserver.onNext("one");
+            assertNotNull(onError.get());
+            assertTrue(onError.get() instanceof SafeSubscriberTestException);
+            assertEquals("onNextFail", onError.get().getMessage());
+        } catch (Exception e) {
+            fail("expects exception to be passed to onError");
+        }
+    }
+
+    @Test
+    public void onCompletedFailure() {
+        AtomicReference<Throwable> onError = new AtomicReference<Throwable>();
+        try {
+            OBSERVER_ONCOMPLETED_FAIL(onError).onComplete();
+            fail("expects exception to be thrown");
+        } catch (Exception e) {
+            assertNull(onError.get());
+            assertTrue(e instanceof SafeSubscriberTestException);
+            assertEquals("onCompletedFail", e.getMessage());
+        }
+    }
+
+    @Test
+    public void onErrorFailure() {
+        try {
+            OBSERVER_ONERROR_FAIL().onError(new SafeSubscriberTestException("error!"));
+            fail("expects exception to be thrown");
+        } catch (Exception e) {
+            assertTrue(e instanceof SafeSubscriberTestException);
+            assertEquals("onErrorFail", e.getMessage());
+        }
+    }
+
+    @Test
+    @Ignore("Observers can't throw")
+    public void onErrorFailureSafe() {
+        try {
+            new SafeSubscriber<String>(OBSERVER_ONERROR_FAIL()).onError(new SafeSubscriberTestException("error!"));
+            fail("expects exception to be thrown");
+        } catch (Exception e) {
+            e.printStackTrace();
+            assertTrue(e instanceof RuntimeException);
+            assertEquals("Error occurred when trying to propagate error to Subscriber.onError", e.getMessage());
+
+            Throwable e2 = e.getCause();
+            assertTrue(e2 instanceof CompositeException);
+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();
+            assertEquals(2, innerExceptions.size());
+
+            Throwable e3 = innerExceptions.get(0);
+            assertTrue(e3 instanceof SafeSubscriberTestException);
+            assertEquals("error!", e3.getMessage());
+
+            Throwable e4 = innerExceptions.get(1);
+            assertTrue(e4 instanceof SafeSubscriberTestException);
+            assertEquals("onErrorFail", e4.getMessage());
+        }
+    }
+
+    @Test
+    @Ignore("Observers can't throw")
+    public void onErrorNotImplementedFailureSafe() {
+        try {
+            new SafeSubscriber<String>(OBSERVER_ONERROR_NOTIMPLEMENTED()).onError(new SafeSubscriberTestException("error!"));
+            fail("expects exception to be thrown");
+        } catch (Exception e) {
+//            assertTrue(e instanceof OnErrorNotImplementedException);
+            assertTrue(e.getCause() instanceof SafeSubscriberTestException);
+            assertEquals("error!", e.getCause().getMessage());
+        }
+    }
+
+    @Test
+    public void onNextOnErrorFailure() {
+        try {
+            OBSERVER_ONNEXT_ONERROR_FAIL().onNext("one");
+            fail("expects exception to be thrown");
+        } catch (Exception e) {
+            e.printStackTrace();
+            assertTrue(e instanceof SafeSubscriberTestException);
+            assertEquals("onNextFail", e.getMessage());
+        }
+    }
+
+    @Test
+    @Ignore("Observers can't throw")
+    public void onNextOnErrorFailureSafe() {
+        try {
+            new SafeSubscriber<String>(OBSERVER_ONNEXT_ONERROR_FAIL()).onNext("one");
+            fail("expects exception to be thrown");
+        } catch (Exception e) {
+            e.printStackTrace();
+            assertTrue(e instanceof RuntimeException);
+            assertEquals("Error occurred when trying to propagate error to Subscriber.onError", e.getMessage());
+
+            Throwable e2 = e.getCause();
+            assertTrue(e2 instanceof CompositeException);
+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();
+            assertEquals(2, innerExceptions.size());
+
+            Throwable e3 = innerExceptions.get(0);
+            assertTrue(e3 instanceof SafeSubscriberTestException);
+            assertEquals("onNextFail", e3.getMessage());
+
+            Throwable e4 = innerExceptions.get(1);
+            assertTrue(e4 instanceof SafeSubscriberTestException);
+            assertEquals("onErrorFail", e4.getMessage());
+        }
+    }
+
+    static final Subscription THROWING_DISPOSABLE = new Subscription() {
+
+        @Override
+        public void cancel() {
+            // break contract by throwing exception
+            throw new SafeSubscriberTestException("failure from unsubscribe");
+        }
+        
+        @Override
+        public void request(long n) {
+            // ignored
+        }
+    };
+    
+    @Test
+    @Ignore("Observers can't throw")
+    public void onCompleteSuccessWithUnsubscribeFailure() {
+        Subscriber<String> o = OBSERVER_SUCCESS();
+        try {
+            o.onSubscribe(THROWING_DISPOSABLE);
+            new SafeSubscriber<String>(o).onComplete();
+            fail("expects exception to be thrown");
+        } catch (Exception e) {
+            e.printStackTrace();
+
+            // FIXME no longer assertable
+//            assertTrue(o.isUnsubscribed());
+//            assertTrue(e instanceof UnsubscribeFailedException);
+            assertTrue(e.getCause() instanceof SafeSubscriberTestException);
+            assertEquals("failure from unsubscribe", e.getMessage());
+            // expected since onError fails so SafeSubscriber can't help
+        }
+    }
+
+    @Test
+    @Ignore("Observers can't throw")
+    public void onErrorSuccessWithUnsubscribeFailure() {
+        AtomicReference<Throwable> onError = new AtomicReference<Throwable>();
+        Subscriber<String> o = OBSERVER_SUCCESS(onError);
+        try {
+            o.onSubscribe(THROWING_DISPOSABLE);
+            new SafeSubscriber<String>(o).onError(new SafeSubscriberTestException("failed"));
+            fail("we expect the unsubscribe failure to cause an exception to be thrown");
+        } catch (Exception e) {
+            e.printStackTrace();
+
+            // FIXME no longer assertable
+//            assertTrue(o.isUnsubscribed());
+
+            // we still expect onError to have received something before unsubscribe blew up
+            assertNotNull(onError.get());
+            assertTrue(onError.get() instanceof SafeSubscriberTestException);
+            assertEquals("failed", onError.get().getMessage());
+
+            // now assert the exception that was thrown
+            RuntimeException onErrorFailedException = (RuntimeException) e;
+            assertTrue(onErrorFailedException.getCause() instanceof SafeSubscriberTestException);
+            assertEquals("failure from unsubscribe", e.getMessage());
+        }
+    }
+
+    @Test
+    @Ignore("Observers can't throw")
+    public void onErrorFailureWithUnsubscribeFailure() {
+        Subscriber<String> o = OBSERVER_ONERROR_FAIL();
+        try {
+            o.onSubscribe(THROWING_DISPOSABLE);
+            new SafeSubscriber<String>(o).onError(new SafeSubscriberTestException("onError failure"));
+            fail("expects exception to be thrown");
+        } catch (Exception e) {
+            e.printStackTrace();
+
+            // FIXME no longer assertable
+//            assertTrue(o.isUnsubscribed());
+
+            // assertions for what is expected for the actual failure propagated to onError which then fails
+            assertTrue(e instanceof RuntimeException);
+            assertEquals("Error occurred when trying to propagate error to Subscriber.onError and during unsubscription.", e.getMessage());
+
+            Throwable e2 = e.getCause();
+            assertTrue(e2 instanceof CompositeException);
+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();
+            assertEquals(3, innerExceptions.size());
+
+            Throwable e3 = innerExceptions.get(0);
+            assertTrue(e3 instanceof SafeSubscriberTestException);
+            assertEquals("onError failure", e3.getMessage());
+
+            Throwable e4 = innerExceptions.get(1);
+            assertTrue(e4 instanceof SafeSubscriberTestException);
+            assertEquals("onErrorFail", e4.getMessage());
+
+            Throwable e5 = innerExceptions.get(2);
+            assertTrue(e5 instanceof SafeSubscriberTestException);
+            assertEquals("failure from unsubscribe", e5.getMessage());
+        }
+    }
+
+    @Test
+    @Ignore("Observers can't throw")
+    public void onErrorNotImplementedFailureWithUnsubscribeFailure() {
+        Subscriber<String> o = OBSERVER_ONERROR_NOTIMPLEMENTED();
+        try {
+            o.onSubscribe(THROWING_DISPOSABLE);
+            new SafeSubscriber<String>(o).onError(new SafeSubscriberTestException("error!"));
+            fail("expects exception to be thrown");
+        } catch (Exception e) {
+            e.printStackTrace();
+
+            // FIXME no longer assertable
+//            assertTrue(o.isUnsubscribed());
+
+            // assertions for what is expected for the actual failure propagated to onError which then fails
+            assertTrue(e instanceof RuntimeException);
+            assertEquals("Subscriber.onError not implemented and error while unsubscribing.", e.getMessage());
+
+            Throwable e2 = e.getCause();
+            assertTrue(e2 instanceof CompositeException);
+            List<Throwable> innerExceptions = ((CompositeException) e2).getExceptions();
+            assertEquals(2, innerExceptions.size());
+
+            Throwable e3 = innerExceptions.get(0);
+            assertTrue(e3 instanceof SafeSubscriberTestException);
+            assertEquals("error!", e3.getMessage());
+
+            Throwable e4 = innerExceptions.get(1);
+            assertTrue(e4 instanceof SafeSubscriberTestException);
+            assertEquals("failure from unsubscribe", e4.getMessage());
+        }
+    }
+
+    private static Subscriber<String> OBSERVER_SUCCESS() {
+        return new DefaultSubscriber<String>() {
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+
+            }
+
+            @Override
+            public void onNext(String args) {
+
+            }
+        };
+
+    }
+
+    private static Subscriber<String> OBSERVER_SUCCESS(final AtomicReference<Throwable> onError) {
+        return new DefaultSubscriber<String>() {
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                onError.set(e);
+            }
+
+            @Override
+            public void onNext(String args) {
+
+            }
+        };
+
+    }
+
+    private static Subscriber<String> OBSERVER_ONNEXT_FAIL(final AtomicReference<Throwable> onError) {
+        return new DefaultSubscriber<String>() {
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                onError.set(e);
+            }
+
+            @Override
+            public void onNext(String args) {
+                throw new SafeSubscriberTestException("onNextFail");
+            }
+        };
+
+    }
+
+    private static Subscriber<String> OBSERVER_ONNEXT_ONERROR_FAIL() {
+        return new DefaultSubscriber<String>() {
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                throw new SafeSubscriberTestException("onErrorFail");
+            }
+
+            @Override
+            public void onNext(String args) {
+                throw new SafeSubscriberTestException("onNextFail");
+            }
+
+        };
+    }
+
+    private static Subscriber<String> OBSERVER_ONERROR_FAIL() {
+        return new DefaultSubscriber<String>() {
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                throw new SafeSubscriberTestException("onErrorFail");
+            }
+
+            @Override
+            public void onNext(String args) {
+
+            }
+
+        };
+    }
+
+    private static Subscriber<String> OBSERVER_ONERROR_NOTIMPLEMENTED() {
+        return new DefaultSubscriber<String>() {
+
+            @Override
+            public void onComplete() {
+
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                throw new RuntimeException(e);
+//                throw new OnErrorNotImplementedException(e);
+            }
+
+            @Override
+            public void onNext(String args) {
+
+            }
+
+        };
+    }
+
+    private static Subscriber<String> OBSERVER_ONCOMPLETED_FAIL(final AtomicReference<Throwable> onError) {
+        return new DefaultSubscriber<String>() {
+
+            @Override
+            public void onComplete() {
+                throw new SafeSubscriberTestException("onCompletedFail");
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                onError.set(e);
+            }
+
+            @Override
+            public void onNext(String args) {
+
+            }
+
+        };
+    }
+
+    @SuppressWarnings("serial")
+    private static class SafeSubscriberTestException extends RuntimeException {
+        public SafeSubscriberTestException(String message) {
+            super(message);
+        }
+    }
+    
+    @Test
+    @Ignore("Observers can't throw")
+    public void testOnCompletedThrows() {
+        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
+        SafeSubscriber<Integer> s = new SafeSubscriber<Integer>(new DefaultSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                
+            }
+            @Override
+            public void onError(Throwable e) {
+                error.set(e);
+            }
+            @Override
+            public void onComplete() {
+                throw new TestException();
+            }
+        });
+        
+        try {
+            s.onComplete();
+            Assert.fail();
+        } catch (RuntimeException e) {
+           assertNull(error.get());
+        }
+    }
+    
+    @Test
+    public void testActual() {
+        Subscriber<Integer> actual = new DefaultSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+            }
+            @Override
+            public void onError(Throwable e) {
+            }
+            @Override
+            public void onComplete() {
+            }
+        };
+        SafeSubscriber<Integer> s = new SafeSubscriber<Integer>(actual);
+
+        assertSame(actual, s.actual);
+    }
+    
+    @Test
+    public void dispose() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        SafeSubscriber<Integer> so = new SafeSubscriber<Integer>(ts);
+        
+        BooleanSubscription d = new BooleanSubscription();
+        
+        so.onSubscribe(d);
+        
+        ts.dispose();
+        
+        assertTrue(d.isCancelled());
+        
+//        assertTrue(so.isDisposed());
+    }
+
+    @Test
+    public void onNextAfterComplete() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        SafeSubscriber<Integer> so = new SafeSubscriber<Integer>(ts);
+        
+        BooleanSubscription d = new BooleanSubscription();
+        
+        so.onSubscribe(d);
+
+        so.onComplete();
+        
+        so.onNext(1);
+        
+        so.onError(new TestException());
+        
+        so.onComplete();
+        
+        ts.assertResult();
+    }
+
+    @Test
+    public void onNextNull() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        SafeSubscriber<Integer> so = new SafeSubscriber<Integer>(ts);
+        
+        BooleanSubscription d = new BooleanSubscription();
+        
+        so.onSubscribe(d);
+
+        so.onNext(null);
+        
+        ts.assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    public void onNextWithoutOnSubscribe() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        SafeSubscriber<Integer> so = new SafeSubscriber<Integer>(ts);
+        
+        so.onNext(1);
+        
+        ts.assertFailureAndMessage(NullPointerException.class, "Subscription not set!");
+    }
+
+    @Test
+    public void onErrorWithoutOnSubscribe() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        SafeSubscriber<Integer> so = new SafeSubscriber<Integer>(ts);
+        
+        so.onError(new TestException());
+        
+        ts.assertFailure(CompositeException.class);
+        
+        TestHelper.assertError(ts, 0, TestException.class);
+        TestHelper.assertError(ts, 1, NullPointerException.class, "Subscription not set!");
+    }
+
+    @Test
+    public void onCompleteWithoutOnSubscribe() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        SafeSubscriber<Integer> so = new SafeSubscriber<Integer>(ts);
+        
+        so.onComplete();
+        
+        ts.assertFailureAndMessage(NullPointerException.class, "Subscription not set!");
+    }
+
+    @Test
+    public void onNextNormal() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        SafeSubscriber<Integer> so = new SafeSubscriber<Integer>(ts);
+        
+        BooleanSubscription d = new BooleanSubscription();
+        
+        so.onSubscribe(d);
+
+        so.onNext(1);
+        so.onComplete();
+        
+        ts.assertResult(1);
+    }
+    
+    static final class CrashDummy implements Subscriber<Object>, Subscription {
+        boolean crashOnSubscribe;
+        int crashOnNext;
+        boolean crashOnError;
+        boolean crashOnComplete;
+        
+        boolean crashDispose;
+        
+        Throwable error;
+        
+        public CrashDummy(boolean crashOnSubscribe, int crashOnNext, 
+                boolean crashOnError, boolean crashOnComplete, boolean crashDispose) {
+            this.crashOnSubscribe = crashOnSubscribe;
+            this.crashOnNext = crashOnNext;
+            this.crashOnError = crashOnError;
+            this.crashOnComplete = crashOnComplete;
+            this.crashDispose = crashDispose;
+        }
+
+        @Override
+        public void cancel() {
+            if (crashDispose) {
+                throw new TestException("dispose()");
+            }
+        }
+
+        @Override
+        public void request(long n) {
+            // TODO
+        }
+
+        @Override
+        public void onSubscribe(Subscription s) {
+            if (crashOnSubscribe) {
+                throw new TestException("onSubscribe()");
+            }
+        }
+
+        @Override
+        public void onNext(Object value) {
+            if (--crashOnNext == 0) {
+                throw new TestException("onNext(" + value + ")");
+            }
+        }
+
+        @Override
+        public void onError(Throwable e) {
+            if (crashOnError) {
+                throw new TestException("onError(" + e + ")");
+            }
+            error = e;
+        }
+
+        @Override
+        public void onComplete() {
+            if (crashOnComplete) {
+                throw new TestException("onComplete()");
+            }
+        }
+        
+        public SafeSubscriber<Object> toSafe() {
+            return new SafeSubscriber<Object>(this);
+        }
+        
+        public CrashDummy assertError(Class<? extends Throwable> clazz) {
+            if (!clazz.isInstance(error)) {
+                throw new AssertionError("Different error: " + error);
+            }
+            return this;
+        }
+        
+        public CrashDummy assertInnerError(int index, Class<? extends Throwable> clazz) {
+            List<Throwable> cel = TestHelper.compositeList(error);
+            TestHelper.assertError(cel, index, clazz);
+            return this;
+        }
+
+        public CrashDummy assertInnerError(int index, Class<? extends Throwable> clazz, String message) {
+            List<Throwable> cel = TestHelper.compositeList(error);
+            TestHelper.assertError(cel, index, clazz, message);
+            return this;
+        }
+
+    }
+
+    @Test
+    public void onNextOnErrorCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, true, false, false);
+            SafeSubscriber<Object> so = cd.toSafe();
+            so.onSubscribe(cd);
+            
+            so.onNext(1);
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, TestException.class, "onNext(1)");
+            TestHelper.assertError(ce, 1, TestException.class, "onError(io.reactivex.exceptions.TestException: onNext(1))");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onNextDisposeCrash() {
+        CrashDummy cd = new CrashDummy(false, 1, false, false, true);
+        SafeSubscriber<Object> so = cd.toSafe();
+        so.onSubscribe(cd);
+        
+        so.onNext(1);
+
+        cd.assertError(CompositeException.class);
+        cd.assertInnerError(0, TestException.class, "onNext(1)");
+        cd.assertInnerError(1, TestException.class, "dispose()");
+    }
+
+    @Test
+    public void onSubscribeTwice() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, false, false, false);
+            SafeSubscriber<Object> so = cd.toSafe();
+            so.onSubscribe(cd);
+            so.onSubscribe(cd);
+            
+            TestHelper.assertError(list, 0, IllegalStateException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onSubscribeCrashes() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(true, 1, false, false, false);
+            SafeSubscriber<Object> so = cd.toSafe();
+            so.onSubscribe(cd);
+            
+            TestHelper.assertError(list, 0, TestException.class, "onSubscribe()");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onSubscribeAndDisposeCrashes() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(true, 1, false, false, true);
+            SafeSubscriber<Object> so = cd.toSafe();
+            so.onSubscribe(cd);
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, TestException.class, "onSubscribe()");
+            TestHelper.assertError(ce, 1, TestException.class, "dispose()");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onNextOnSubscribeCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(true, 1, false, false, false);
+            SafeSubscriber<Object> so = cd.toSafe();
+
+            so.onNext(1);
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, NullPointerException.class, "Subscription not set!");
+            TestHelper.assertError(ce, 1, TestException.class, "onSubscribe()");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void onNextNullDisposeCrashes() {
+        CrashDummy cd = new CrashDummy(false, 1, false, false, true);
+        SafeSubscriber<Object> so = cd.toSafe();
+        so.onSubscribe(cd);
+        
+        so.onNext(null);
+        
+        cd.assertInnerError(0, NullPointerException.class);
+        cd.assertInnerError(1, TestException.class, "dispose()");
+    }
+
+    @Test
+    public void noSubscribeOnErrorCrashes() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, true, false, false);
+            SafeSubscriber<Object> so = cd.toSafe();
+
+            so.onNext(1);
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, NullPointerException.class, "Subscription not set!");
+            TestHelper.assertError(ce, 1, TestException.class, "onError(java.lang.NullPointerException: Subscription not set!)");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onErrorNull() {
+        CrashDummy cd = new CrashDummy(false, 1, false, false, false);
+        SafeSubscriber<Object> so = cd.toSafe();
+        so.onSubscribe(cd);
+        
+        so.onError(null);
+        
+        cd.assertError(NullPointerException.class);
+    }
+
+    @Test
+    public void onErrorNoSubscribeCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(true, 1, false, false, false);
+            SafeSubscriber<Object> so = cd.toSafe();
+            
+            so.onError(new TestException());
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, TestException.class);
+            TestHelper.assertError(ce, 1, NullPointerException.class, "Subscription not set!");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onErrorNoSubscribeOnErrorCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, true, false, false);
+            SafeSubscriber<Object> so = cd.toSafe();
+            
+            so.onError(new TestException());
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, TestException.class);
+            TestHelper.assertError(ce, 1, NullPointerException.class, "Subscription not set!");
+            TestHelper.assertError(ce, 2, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteteCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, false, true, false);
+            SafeSubscriber<Object> so = cd.toSafe();
+            
+            so.onSubscribe(cd);
+            
+            so.onComplete();
+            
+            TestHelper.assertError(list, 0, TestException.class, "onComplete()");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteteNoSubscribeCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(true, 1, false, true, false);
+            SafeSubscriber<Object> so = cd.toSafe();
+            
+            so.onComplete();
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, NullPointerException.class, "Subscription not set!");
+            TestHelper.assertError(ce, 1, TestException.class, "onSubscribe()");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteteNoSubscribeOnErrorCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, true, true, false);
+            SafeSubscriber<Object> so = cd.toSafe();
+            
+            so.onComplete();
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, NullPointerException.class, "Subscription not set!");
+            TestHelper.assertError(ce, 1, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java b/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java
index f6b4990cab..3f4682a4a1 100644
--- a/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java
+++ b/src/test/java/io/reactivex/subscribers/TestSubscriberTest.java
@@ -16,21 +16,23 @@
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 
-import java.util.Arrays;
+import java.io.IOException;
+import java.util.*;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.junit.*;
 import org.junit.rules.ExpectedException;
 import org.mockito.InOrder;
-import org.reactivestreams.Subscriber;
+import org.reactivestreams.*;
 
 import io.reactivex.*;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.exceptions.*;
-import io.reactivex.functions.Action;
-import io.reactivex.internal.subscriptions.EmptySubscription;
-import io.reactivex.processors.PublishProcessor;
+import io.reactivex.functions.*;
+import io.reactivex.internal.fuseable.QueueSubscription;
+import io.reactivex.internal.subscriptions.*;
+import io.reactivex.processors.*;
 import io.reactivex.schedulers.Schedulers;
 
 public class TestSubscriberTest {
@@ -617,4 +619,884 @@ public void onError(Throwable e) {
         
         ts.awaitTerminalEvent();
     }
+
+    
+    @Test
+    public void createDelegate() {
+        TestSubscriber<Integer> ts1 = TestSubscriber.create();
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create(ts1);
+        
+        ts.assertNotSubscribed();
+
+        assertFalse(ts.hasSubscription());
+
+        ts.onSubscribe(new BooleanSubscription());
+        
+        try {
+            ts.assertNotSubscribed();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+        assertTrue(ts.hasSubscription());
+        
+        assertFalse(ts.isDisposed());
+        
+        ts.onNext(1);
+        ts.onError(new TestException());
+        ts.onComplete();
+        
+        ts1.assertValue(1).assertError(TestException.class).assertComplete();
+        
+        ts.dispose();
+        
+        assertTrue(ts.isDisposed());
+        
+        assertTrue(ts.isTerminated());
+        
+        assertSame(Thread.currentThread(), ts.lastThread());
+
+        try {
+            ts.assertNoValues();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+
+        try {
+            ts.assertValueCount(0);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+        
+        ts.assertValueSequence(Arrays.asList(1));
+        
+        try {
+            ts.assertValueSequence(Arrays.asList(2));
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+
+        ts.assertValueSet(Collections.singleton(1));
+
+        try {
+            ts.assertValueSet(Collections.singleton(2));
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+
+    }
+    
+    @Test
+    public void assertError() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        try {
+            ts.assertError(TestException.class);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+        try {
+            ts.assertError(new TestException());
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+        try {
+            ts.assertErrorMessage("");
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            
+        }
+
+        try {
+            ts.assertSubscribed();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            
+        }
+
+        try {
+            ts.assertTerminated();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            
+        }
+
+        ts.onSubscribe(new BooleanSubscription());
+
+        ts.assertSubscribed();
+        
+        ts.assertNoErrors();
+
+        TestException ex = new TestException("Forced failure");
+        
+        ts.onError(ex);
+
+        ts.assertError(ex);
+        
+        ts.assertError(TestException.class);
+
+        ts.assertErrorMessage("Forced failure");
+        
+        try {
+            ts.assertErrorMessage("");
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            
+        }
+        
+        try {
+            ts.assertError(new RuntimeException());
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+
+        try {
+            ts.assertError(IOException.class);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+
+        try {
+            ts.assertNoErrors();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+        
+        ts.assertTerminated();
+        
+        ts.assertValueCount(0);
+        
+        ts.assertNoValues();
+        
+        
+    }
+    
+    @Test
+    public void emptyObserverEnum() {
+        assertEquals(1, TestSubscriber.EmptySubscriber.values().length);
+        assertNotNull(TestSubscriber.EmptySubscriber.valueOf("INSTANCE"));
+    }
+    
+    @Test
+    public void valueAndClass() {
+        assertEquals("null", TestSubscriber.valueAndClass(null));
+        assertEquals("1 (class: Integer)", TestSubscriber.valueAndClass(1));
+    }
+    
+    @Test
+    public void assertFailure() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        ts.onSubscribe(new BooleanSubscription());
+        
+        ts.onError(new TestException("Forced failure"));
+
+        ts.assertFailure(TestException.class);
+        
+        ts.assertFailureAndMessage(TestException.class, "Forced failure");
+        
+        ts.onNext(1);
+
+        ts.assertFailure(TestException.class, 1);
+        
+        ts.assertFailureAndMessage(TestException.class, "Forced failure", 1);
+    }
+    
+    @Test
+    public void assertFuseable() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        ts.onSubscribe(new BooleanSubscription());
+        
+        ts.assertNotFuseable();
+        
+        try {
+            ts.assertFuseable();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        try {
+            ts.assertFusionMode(QueueSubscription.SYNC);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }        
+        ts = TestSubscriber.create();
+        ts.setInitialFusionMode(QueueSubscription.ANY);
+        
+        ts.onSubscribe(new ScalarSubscription<Integer>(ts, 1));
+        
+        ts.assertFuseable();
+        
+        ts.assertFusionMode(QueueSubscription.SYNC);
+        
+        try {
+            ts.assertFusionMode(QueueSubscription.NONE);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        try {
+            ts.assertNotFuseable();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+    }
+    
+    @Test
+    public void assertTerminated() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        ts.assertNotTerminated();
+        
+        ts.onError(null);
+        
+        try {
+            ts.assertNotTerminated();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void assertOf() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+       
+        ts.assertOf(new Consumer<TestSubscriber<Integer>>() {
+            @Override
+            public void accept(TestSubscriber<Integer> f) throws Exception {
+                f.assertNotSubscribed();
+            }
+        });
+        
+        try {
+            ts.assertOf(new Consumer<TestSubscriber<Integer>>() {
+                @Override
+                public void accept(TestSubscriber<Integer> f) throws Exception {
+                    f.assertSubscribed();
+                }
+            });
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        try {
+            ts.assertOf(new Consumer<TestSubscriber<Integer>>() {
+                @Override
+                public void accept(TestSubscriber<Integer> f) throws Exception {
+                    throw new IllegalArgumentException();
+                }
+            });
+            throw new RuntimeException("Should have thrown");
+        } catch (IllegalArgumentException ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void assertResult() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        ts.onSubscribe(new BooleanSubscription());
+        
+        ts.onComplete();
+        
+        ts.assertResult();
+        
+        try {
+            ts.assertResult(1);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        ts.onNext(1);
+        
+        ts.assertResult(1);
+        
+        try {
+            ts.assertResult(2);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        try {
+            ts.assertResult();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+    }
+    
+    @Test(timeout = 5000)
+    public void await() throws Exception {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        ts.onSubscribe(new BooleanSubscription());
+
+        assertFalse(ts.await(100, TimeUnit.MILLISECONDS));
+        
+        ts.awaitDone(100, TimeUnit.MILLISECONDS);
+        
+        assertTrue(ts.isDisposed());
+
+        assertFalse(ts.awaitTerminalEvent(100, TimeUnit.MILLISECONDS));
+        
+        assertEquals(0, ts.completions());
+        assertEquals(0, ts.errorCount());
+
+        ts.onComplete();
+        
+        assertTrue(ts.await(100, TimeUnit.MILLISECONDS));
+        
+        ts.await();
+        
+        ts.awaitDone(5, TimeUnit.SECONDS);
+        
+        assertEquals(1, ts.completions());
+        assertEquals(0, ts.errorCount());
+        
+        assertTrue(ts.awaitTerminalEvent());
+        
+        final TestSubscriber<Integer> ts1 = TestSubscriber.create();
+
+        ts1.onSubscribe(new BooleanSubscription());
+
+        Schedulers.single().scheduleDirect(new Runnable() {
+            @Override
+            public void run() {
+                ts1.onComplete();
+            }
+        }, 200, TimeUnit.MILLISECONDS);
+        
+        ts1.await();
+        
+        ts1.assertValueSet(Collections.<Integer>emptySet());
+    }
+    
+    @Test
+    public void errors() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        ts.onSubscribe(new BooleanSubscription());
+
+        assertEquals(0, ts.errors().size());
+        
+        ts.onError(new TestException());
+
+        assertEquals(1, ts.errors().size());
+        
+        TestHelper.assertError(ts.errors(), 0, TestException.class);
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void onNext() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        ts.onSubscribe(new BooleanSubscription());
+
+        assertEquals(0, ts.valueCount());
+        
+        assertEquals(Arrays.asList(), ts.values());
+        
+        ts.onNext(1);
+        
+        assertEquals(Arrays.asList(1), ts.values());
+        
+        ts.cancel();
+        
+        assertTrue(ts.isCancelled());
+        assertTrue(ts.isDisposed());
+        
+        ts.assertValue(1);
+        
+        assertEquals(Arrays.asList(Arrays.asList(1), Collections.emptyList(), Collections.emptyList()), ts.getEvents());
+        
+        ts.onComplete();
+        
+        assertEquals(Arrays.asList(Arrays.asList(1), Collections.emptyList(), Collections.singletonList(Notification.createOnComplete())), ts.getEvents());
+    }
+    
+    @Test
+    public void fusionModeToString() {
+        assertEquals("NONE", TestSubscriber.fusionModeToString(QueueSubscription.NONE));
+        assertEquals("SYNC", TestSubscriber.fusionModeToString(QueueSubscription.SYNC));
+        assertEquals("ASYNC", TestSubscriber.fusionModeToString(QueueSubscription.ASYNC));
+        assertEquals("Unknown(100)", TestSubscriber.fusionModeToString(100));
+    }
+    
+    @Test
+    public void multipleTerminals() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        ts.onSubscribe(new BooleanSubscription());
+
+        ts.assertNotComplete();
+
+        ts.onComplete();
+
+        try {
+            ts.assertNotComplete();
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+
+        ts.assertTerminated();
+        
+        ts.onComplete();
+        
+        try {
+            ts.assertComplete();
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+
+        try {
+            ts.assertTerminated();
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+
+        try {
+            ts.assertNotComplete();
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void assertValue() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        ts.onSubscribe(new BooleanSubscription());
+
+        try {
+            ts.assertValue(1);
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+        
+        ts.onNext(1);
+        
+        ts.assertValue(1);
+        
+        try {
+            ts.assertValue(2);
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+
+        ts.onNext(2);
+        
+        try {
+            ts.assertValue(1);
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+    }
+
+    @Test
+    public void onNextMisbehave() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        ts.onNext(1);
+        
+        ts.assertError(IllegalStateException.class);
+        
+        ts = TestSubscriber.create();
+        
+        ts.onSubscribe(new BooleanSubscription());
+        
+        ts.onNext(null);
+        
+        ts.assertFailure(NullPointerException.class, (Integer)null);
+    }
+    
+    @Test
+    public void awaitTerminalEventInterrupt() {
+        final TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        ts.onSubscribe(new BooleanSubscription());
+
+        Thread.currentThread().interrupt();
+        
+        ts.awaitTerminalEvent();
+
+        assertTrue(Thread.interrupted());
+        
+        Thread.currentThread().interrupt();
+
+        ts.awaitTerminalEvent(5, TimeUnit.SECONDS);
+
+        assertTrue(Thread.interrupted());
+    }
+    
+    @Test
+    public void assertTerminated2() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        ts.onSubscribe(new BooleanSubscription());
+
+        assertFalse(ts.isTerminated());
+        
+        ts.onError(new TestException());
+        ts.onError(new IOException());
+        
+        assertTrue(ts.isTerminated());
+        
+        try {
+            ts.assertTerminated();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        try {
+            ts.assertError(TestException.class);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+
+        ts = TestSubscriber.create();
+        
+        ts.onSubscribe(new BooleanSubscription());
+
+        ts.onError(new TestException());
+        ts.onComplete();
+
+        try {
+            ts.assertTerminated();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void onSubscribe() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        ts.onSubscribe(null);
+        
+        ts.assertError(NullPointerException.class);
+
+        ts = TestSubscriber.create();
+        
+        ts.onSubscribe(new BooleanSubscription());
+        
+        BooleanSubscription d1 = new BooleanSubscription();
+        
+        ts.onSubscribe(d1);
+        
+        assertTrue(d1.isCancelled());
+        
+        ts.assertError(IllegalStateException.class);
+
+        ts = TestSubscriber.create();
+        ts.dispose();
+        
+        d1 = new BooleanSubscription();
+        
+        ts.onSubscribe(d1);
+        
+        assertTrue(d1.isCancelled());
+        
+    }
+
+    @Test
+    public void assertValueSequence() {
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+
+        ts.onSubscribe(new BooleanSubscription());
+        
+        ts.onNext(1);
+        ts.onNext(2);
+        
+        try {
+            ts.assertValueSequence(Arrays.<Integer>asList());
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+        try {
+            ts.assertValueSequence(Arrays.asList(1));
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+        ts.assertValueSequence(Arrays.asList(1, 2));
+
+        try {
+            ts.assertValueSequence(Arrays.asList(1, 2, 3));
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void assertEmpty() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        try {
+            ts.assertEmpty();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        ts.onSubscribe(new BooleanSubscription());
+        
+        ts.assertEmpty();
+        
+        ts.onNext(1);
+        
+        try {
+            ts.assertEmpty();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void awaitDoneTimed() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+
+        Thread.currentThread().interrupt();
+        
+        try {
+            ts.awaitDone(5, TimeUnit.SECONDS);
+        } catch (RuntimeException ex) {
+            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);
+        }
+    }
+    
+    @Test
+    public void assertNotSubscribed() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+
+        ts.assertNotSubscribed();
+        
+        ts.errors().add(new TestException());
+ 
+        try {
+            ts.assertNotSubscribed();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void assertErrorMultiple() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        TestException e = new TestException();
+        ts.errors().add(e);
+        ts.errors().add(new TestException());
+ 
+        try {
+            ts.assertError(TestException.class);
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        try {
+            ts.assertError(e);
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        try {
+            ts.assertErrorMessage("");
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void assertComplete() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+
+        ts.onSubscribe(new BooleanSubscription());
+        
+        try {
+            ts.assertComplete();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        ts.onComplete();
+        
+        ts.assertComplete();
+        
+        ts.onComplete();
+        
+        try {
+            ts.assertComplete();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+
+    @Test
+    public void completeWithoutOnSubscribe() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        ts.onComplete();
+        
+        ts.assertError(IllegalStateException.class);
+    }
+
+    @Test
+    public void completeDelegateThrows() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(new Subscriber<Integer>() {
+
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+
+            @Override
+            public void onNext(Integer value) {
+                
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                throw new TestException();
+            }
+
+            @Override
+            public void onComplete() {
+                throw new TestException();
+            }
+            
+        });
+
+        ts.onSubscribe(new BooleanSubscription());
+
+        try {
+            ts.onComplete();
+            throw new RuntimeException("Should have thrown!");
+        } catch (TestException ex) {
+            assertTrue(ts.isTerminated());
+        }
+    }
+    
+    @Test
+    public void errorDelegateThrows() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>(new Subscriber<Integer>() {
+
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+
+            @Override
+            public void onNext(Integer value) {
+                
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                throw new TestException();
+            }
+
+            @Override
+            public void onComplete() {
+                throw new TestException();
+            }
+            
+        });
+
+        ts.onSubscribe(new BooleanSubscription());
+
+        try {
+            ts.onError(new IOException());
+            throw new RuntimeException("Should have thrown!");
+        } catch (TestException ex) {
+            assertTrue(ts.isTerminated());
+        }
+    }
+
+    
+    @Test
+    public void syncQueueThrows() {
+        TestSubscriber<Object> ts = new TestSubscriber<Object>();
+        ts.setInitialFusionMode(QueueSubscription.SYNC);
+        
+        Flowable.range(1, 5)
+        .map(new Function<Integer, Object>() {
+            @Override
+            public Object apply(Integer v) throws Exception { throw new TestException(); }
+        })
+        .subscribe(ts);
+        
+        ts.assertSubscribed()
+        .assertFuseable()
+        .assertFusionMode(QueueSubscription.SYNC)
+        .assertFailure(TestException.class);
+    }
+    
+    @Test
+    public void asyncQueueThrows() {
+        TestSubscriber<Object> ts = new TestSubscriber<Object>();
+        ts.setInitialFusionMode(QueueSubscription.ANY);
+        
+        UnicastProcessor<Integer> up = UnicastProcessor.create();
+        
+        up
+        .map(new Function<Integer, Object>() {
+            @Override
+            public Object apply(Integer v) throws Exception { throw new TestException(); }
+        })
+        .subscribe(ts);
+        
+        up.onNext(1);
+        
+        ts.assertSubscribed()
+        .assertFuseable()
+        .assertFusionMode(QueueSubscription.ASYNC)
+        .assertFailure(TestException.class);
+    }
+
 }
\ No newline at end of file
