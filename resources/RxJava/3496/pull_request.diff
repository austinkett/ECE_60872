diff --git a/CHANGES.md b/CHANGES.md
index 444b8f33e2..2187b97999 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,57 @@
 # RxJava Releases #
 
+### Version 1.1.0 – December 2 2015 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.1.0%7C)) ###
+
+* [Pull 3550] (https://github.com/ReactiveX/RxJava/pull/3550) Public API changes for 1.1.0 release
+
+#### Promotions to Public API
+
+* Subscriptions.unsubscribed
+* Subscribers.wrap
+* 2 RxJavaErrorHandler methods
+* Single + SingleSubscriber
+* Exceptions.throwIfAny
+* Observable.switchIfEmpty with Observable
+* BackpressureDrainManager
+* Observable.onBackpressureLatest
+* Observable.onBackpressureDrop with action
+* Observable.onBackpressureBuffer overloads
+* 2 Observable.merge overloads for maxConcurrent
+* TestSubscriber methods
+* Observable.takeUntil with predicate 
+
+#### Promotions to BETA
+
+* ConnectableObservable.autoConnect
+* Stateful Subject methods on ReplaySubject, PublishSubject, BehaviorSubject, and AsyncSubject
+
+#### Experimental APIs Removed
+
+* Observable.onBackpressureBlock
+* rx.observables.AbstractOnSubscribe
+* Removal of stateful methods from the generic rx.subjects.Subject abstract class
+
+### Version 1.0.17 – December 1 2015 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.17%7C)) ###
+
+* [Pull 3491] (https://github.com/ReactiveX/RxJava/pull/3491) Make scan's delayed Producer independent of event serialization
+* [Pull 3150] (https://github.com/ReactiveX/RxJava/pull/3150) Window operators now support backpressure in the inner observable
+* [Pull 3535] (https://github.com/ReactiveX/RxJava/pull/3535) Don't swallow fatal errors in OperatorZipIterable
+* [Pull 3528] (https://github.com/ReactiveX/RxJava/pull/3528) Avoid to call next when Iterator is drained
+* [Pull 3436] (https://github.com/ReactiveX/RxJava/pull/3436) Add action != null check in OperatorFinally
+* [Pull 3513] (https://github.com/ReactiveX/RxJava/pull/3513) Add shorter RxJavaPlugin class lookup approach
+
+### Version 1.0.16 – November 11 2015 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.16%7C)) ###
+
+* [Pull 3169] (https://github.com/ReactiveX/RxJava/pull/3169) Merge can now operate in horizontally unbounded mode
+* [Pull 3286] (https://github.com/ReactiveX/RxJava/pull/3286) Implements BlockingSingle
+* [Pull 3433] (https://github.com/ReactiveX/RxJava/pull/3433) Add Single.defer()
+* [Pull 3468] (https://github.com/ReactiveX/RxJava/pull/3468) Fix other places that may swallow OnErrorFailedException
+* [Pull 3485] (https://github.com/ReactiveX/RxJava/pull/3485) fix scan() not accepting a null initial value
+* [Pull 3488] (https://github.com/ReactiveX/RxJava/pull/3488) Replace all instances of Atomic*FieldUpdater with direct Atomic* instances
+* [Pull 3493] (https://github.com/ReactiveX/RxJava/pull/3493) fix for zip(Obs<Obs<T>>) backpressure problem
+* [Pull 3510] (https://github.com/ReactiveX/RxJava/pull/3510) eager concatMap to choose safe or unsafe queue based on platform
+* [Pull 3512] (https://github.com/ReactiveX/RxJava/pull/3512) fix SafeSubscriber documentation regarding unsubscribe
+
 ### Version 1.0.15 – October 9 2015 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.15%7C)) ###
 
 * [Pull 3438] (https://github.com/ReactiveX/RxJava/pull/3438) Better null tolerance in rx.exceptions.*Exception classes
diff --git a/src/main/java/rx/Completable.java b/src/main/java/rx/Completable.java
new file mode 100644
index 0000000000..003f21d8d0
--- /dev/null
+++ b/src/main/java/rx/Completable.java
@@ -0,0 +1,2217 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import rx.Observable.OnSubscribe;
+import rx.annotations.Experimental;
+import rx.exceptions.*;
+import rx.functions.*;
+import rx.internal.operators.*;
+import rx.internal.util.*;
+import rx.plugins.*;
+import rx.schedulers.Schedulers;
+import rx.subscriptions.*;
+
+/**
+ * Represents a deferred computation without any value but only indication for completion or exception.
+ * 
+ * The class follows a similar event pattern as Reactive-Streams: onSubscribe (onError|onComplete)?
+ */
+@Experimental
+public class Completable {
+    /**
+     * Callback used for building deferred computations that takes a CompletableSubscriber.
+     */
+    public interface CompletableOnSubscribe extends Action1<CompletableSubscriber> {
+        
+    }
+    
+    /**
+     * Convenience interface and callback used by the lift operator that given a child CompletableSubscriber,
+     * return a parent CompletableSubscriber that does any kind of lifecycle-related transformations.
+     */
+    public interface CompletableOperator extends Func1<CompletableSubscriber, CompletableSubscriber> {
+        
+    }
+    
+    /**
+     * Represents the subscription API callbacks when subscribing to a Completable instance.
+     */
+    public interface CompletableSubscriber {
+        /**
+         * Called once the deferred computation completes normally.
+         */
+        void onCompleted();
+        
+        /**
+         * Called once if the deferred computation 'throws' an exception.
+         * @param e the exception, not null.
+         */
+        void onError(Throwable e);
+        
+        /**
+         * Called once by the Completable to set a Subscription on this instance which
+         * then can be used to cancel the subscription at any time.
+         * @param d the Subscription instance to call dispose on for cancellation, not null
+         */
+        void onSubscribe(Subscription d);
+    }
+    
+    /**
+     * Convenience interface and callback used by the compose operator to turn a Completable into another
+     * Completable fluently.
+     */
+    public interface CompletableTransformer extends Func1<Completable, Completable> {
+        
+    }
+    
+    /** Single instance of a complete Completable. */
+    static final Completable COMPLETE = create(new CompletableOnSubscribe() {
+        @Override
+        public void call(CompletableSubscriber s) {
+            s.onSubscribe(Subscriptions.unsubscribed());
+            s.onCompleted();
+        }
+    });
+    
+    /** Single instance of a never Completable. */
+    static final Completable NEVER = create(new CompletableOnSubscribe() {
+        @Override
+        public void call(CompletableSubscriber s) {
+            s.onSubscribe(Subscriptions.unsubscribed());
+        }
+    });
+    
+    /** The error handler instance. */
+    static final RxJavaErrorHandler ERROR_HANDLER = RxJavaPlugins.getInstance().getErrorHandler();
+    
+    /**
+     * Returns a Completable which terminates as soon as one of the source Completables
+     * terminates (normally or with an error) and cancels all other Completables.
+     * @param sources the array of source Completables
+     * @return the new Completable instance
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable amb(final Completable... sources) {
+        requireNonNull(sources);
+        if (sources.length == 0) {
+            return complete();
+        }
+        if (sources.length == 1) {
+            return sources[0];
+        }
+        
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                final CompositeSubscription set = new CompositeSubscription();
+                s.onSubscribe(set);
+
+                final AtomicBoolean once = new AtomicBoolean();
+                
+                CompletableSubscriber inner = new CompletableSubscriber() {
+                    @Override
+                    public void onCompleted() {
+                        if (once.compareAndSet(false, true)) {
+                            set.unsubscribe();
+                            s.onCompleted();
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        if (once.compareAndSet(false, true)) {
+                            set.unsubscribe();
+                            s.onError(e);
+                        } else {
+                            ERROR_HANDLER.handleError(e);
+                        }
+                    }
+
+                    @Override
+                    public void onSubscribe(Subscription d) {
+                        set.add(d);
+                    }
+                    
+                };
+                
+                for (Completable c : sources) {
+                    if (set.isUnsubscribed()) {
+                        return;
+                    }
+                    if (c == null) {
+                        NullPointerException npe = new NullPointerException("One of the sources is null");
+                        if (once.compareAndSet(false, true)) {
+                            set.unsubscribe();
+                            s.onError(npe);
+                        } else {
+                            ERROR_HANDLER.handleError(npe);
+                        }
+                        return;
+                    }
+                    if (once.get() || set.isUnsubscribed()) {
+                        return;
+                    }
+                    
+                    // no need to have separate subscribers because inner is stateless
+                    c.subscribe(inner);
+                }
+            }
+        });
+    }
+    
+    /**
+     * Returns a Completable which terminates as soon as one of the source Completables
+     * terminates (normally or with an error) and cancels all other Completables.
+     * @param sources the array of source Completables
+     * @return the new Completable instance
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable amb(final Iterable<? extends Completable> sources) {
+        requireNonNull(sources);
+        
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                final CompositeSubscription set = new CompositeSubscription();
+                s.onSubscribe(set);
+
+                final AtomicBoolean once = new AtomicBoolean();
+                
+                CompletableSubscriber inner = new CompletableSubscriber() {
+                    @Override
+                    public void onCompleted() {
+                        if (once.compareAndSet(false, true)) {
+                            set.unsubscribe();
+                            s.onCompleted();
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        if (once.compareAndSet(false, true)) {
+                            set.unsubscribe();
+                            s.onError(e);
+                        } else {
+                            ERROR_HANDLER.handleError(e);
+                        }
+                    }
+
+                    @Override
+                    public void onSubscribe(Subscription d) {
+                        set.add(d);
+                    }
+                    
+                };
+                
+                Iterator<? extends Completable> it;
+                
+                try {
+                    it = sources.iterator();
+                } catch (Throwable e) {
+                    s.onError(e);
+                    return;
+                }
+                
+                if (it == null) {
+                    s.onError(new NullPointerException("The iterator returned is null"));
+                    return;
+                }
+                
+                boolean empty = true;
+                
+                for (;;) {
+                    if (once.get() || set.isUnsubscribed()) {
+                        return;
+                    }
+                    
+                    boolean b;
+                    
+                    try {
+                        b = it.hasNext();
+                    } catch (Throwable e) {
+                        if (once.compareAndSet(false, true)) {
+                            set.unsubscribe();
+                            s.onError(e);
+                        } else {
+                            ERROR_HANDLER.handleError(e);
+                        }
+                        return;
+                    }
+                    
+                    if (!b) {
+                        if (empty) {
+                            s.onCompleted();
+                        }
+                        break;
+                    }
+                    
+                    empty = false;
+                    
+                    if (once.get() || set.isUnsubscribed()) {
+                        return;
+                    }
+
+                    Completable c;
+                    
+                    try {
+                        c = it.next();
+                    } catch (Throwable e) {
+                        if (once.compareAndSet(false, true)) {
+                            set.unsubscribe();
+                            s.onError(e);
+                        } else {
+                            ERROR_HANDLER.handleError(e);
+                        }
+                        return;
+                    }
+                    
+                    if (c == null) {
+                        NullPointerException npe = new NullPointerException("One of the sources is null");
+                        if (once.compareAndSet(false, true)) {
+                            set.unsubscribe();
+                            s.onError(npe);
+                        } else {
+                            ERROR_HANDLER.handleError(npe);
+                        }
+                        return;
+                    }
+                    
+                    if (once.get() || set.isUnsubscribed()) {
+                        return;
+                    }
+                    
+                    // no need to have separate subscribers because inner is stateless
+                    c.subscribe(inner);
+                }
+            }
+        });
+    }
+    
+    /**
+     * Returns a Completable instance that completes immediately when subscribed to.
+     * @return a Completable instance that completes immediately 
+     */
+    public static Completable complete() {
+        return COMPLETE;
+    }
+    
+    /**
+     * Returns a Completable which completes only when all sources complete, one after another.
+     * @param sources the sources to concatenate
+     * @return the Completable instance which completes only when all sources complete
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable concat(Completable... sources) {
+        requireNonNull(sources);
+        if (sources.length == 0) {
+            return complete();
+        } else
+        if (sources.length == 1) {
+            return sources[0];
+        }
+        return create(new CompletableOnSubscribeConcatArray(sources));
+    }
+    
+    /**
+     * Returns a Completable which completes only when all sources complete, one after another.
+     * @param sources the sources to concatenate
+     * @return the Completable instance which completes only when all sources complete
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable concat(Iterable<? extends Completable> sources) {
+        requireNonNull(sources);
+        
+        return create(new CompletableOnSubscribeConcatIterable(sources));
+    }
+    
+    /**
+     * Returns a Completable which completes only when all sources complete, one after another.
+     * @param sources the sources to concatenate
+     * @return the Completable instance which completes only when all sources complete
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable concat(Observable<? extends Completable> sources) {
+        return concat(sources, 2);
+    }
+    
+    /**
+     * Returns a Completable which completes only when all sources complete, one after another.
+     * @param sources the sources to concatenate
+     * @param prefetch the number of sources to prefetch from the sources
+     * @return the Completable instance which completes only when all sources complete
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable concat(Observable<? extends Completable> sources, int prefetch) {
+        requireNonNull(sources);
+        if (prefetch < 1) {
+            throw new IllegalArgumentException("prefetch > 0 required but it was " + prefetch);
+        }
+        return create(new CompletableOnSubscribeConcat(sources, prefetch));
+    }
+    
+    /**
+     * Constructs a Completable instance by wrapping the given onSubscribe callback.
+     * @param onSubscribe the callback which will receive the CompletableSubscriber instances
+     * when the Completable is subscribed to.
+     * @return the created Completable instance
+     * @throws NullPointerException if onSubscribe is null
+     */
+    public static Completable create(CompletableOnSubscribe onSubscribe) {
+        requireNonNull(onSubscribe);
+        try {
+            // TODO plugin wrapping onSubscribe
+            
+            return new Completable(onSubscribe);
+        } catch (NullPointerException ex) {
+            throw ex;
+        } catch (Throwable ex) {
+            ERROR_HANDLER.handleError(ex);
+            throw toNpe(ex);
+        } 
+    }
+    
+    /**
+     * Defers the subscription to a Completable instance returned by a supplier.
+     * @param completableFunc0 the supplier that returns the Completable that will be subscribed to.
+     * @return the Completable instance
+     */
+    public static Completable defer(final Func0<? extends Completable> completableFunc0) {
+        requireNonNull(completableFunc0);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(CompletableSubscriber s) {
+                Completable c;
+                
+                try {
+                    c = completableFunc0.call();
+                } catch (Throwable e) {
+                    s.onSubscribe(Subscriptions.unsubscribed());
+                    s.onError(e);
+                    return;
+                }
+                
+                if (c == null) {
+                    s.onSubscribe(Subscriptions.unsubscribed());
+                    s.onError(new NullPointerException("The completable returned is null"));
+                    return;
+                }
+                
+                c.subscribe(s);
+            }
+        });
+    }
+    
+    /**
+     * Creates a Completable which calls the given error supplier for each subscriber
+     * and emits its returned Throwable.
+     * <p>
+     * If the errorFunc0 returns null, the child CompletableSubscribers will receive a
+     * NullPointerException.
+     * @param errorFunc0 the error supplier, not null
+     * @return the new Completable instance
+     * @throws NullPointerException if errorFunc0 is null
+     */
+    public static Completable error(final Func0<? extends Throwable> errorFunc0) {
+        requireNonNull(errorFunc0);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(CompletableSubscriber s) {
+                s.onSubscribe(Subscriptions.unsubscribed());
+                Throwable error;
+                
+                try {
+                    error = errorFunc0.call();
+                } catch (Throwable e) {
+                    error = e;
+                }
+                
+                if (error == null) {
+                    error = new NullPointerException("The error supplied is null");
+                }
+                s.onError(error);
+            }
+        });
+    }
+
+    /**
+     * Creates a Completable instance that emits the given Throwable exception to subscribers.
+     * @param error the Throwable instance to emit, not null
+     * @return the new Completable instance
+     * @throws NullPointerException if error is null
+     */
+    public static Completable error(final Throwable error) {
+        requireNonNull(error);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(CompletableSubscriber s) {
+                s.onSubscribe(Subscriptions.unsubscribed());
+                s.onError(error);
+            }
+        });
+    }
+    
+    /**
+     * Returns a Completable instance that runs the given Action0 for each subscriber and
+     * emits either an unchecked exception or simply completes.
+     * @param run the runnable to run for each subscriber
+     * @return the new Completable instance
+     * @throws NullPointerException if run is null
+     */
+    public static Completable fromAction(final Action0 action) {
+        requireNonNull(action);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(CompletableSubscriber s) {
+                BooleanSubscription bs = new BooleanSubscription();
+                s.onSubscribe(bs);
+                try {
+                    action.call();
+                } catch (Throwable e) {
+                    if (!bs.isUnsubscribed()) {
+                        s.onError(e);
+                    }
+                    return;
+                }
+                if (!bs.isUnsubscribed()) {
+                    s.onCompleted();
+                }
+            }
+        });
+    }
+    
+    /**
+     * Returns a Completable which when subscribed, executes the callable function, ignores its
+     * normal result and emits onError or onCompleted only.
+     * @param callable the callable instance to execute for each subscriber
+     * @return the new Completable instance
+     */
+    public static Completable fromCallable(final Callable<?> callable) {
+        requireNonNull(callable);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(CompletableSubscriber s) {
+                BooleanSubscription bs = new BooleanSubscription();
+                s.onSubscribe(bs);
+                try {
+                    callable.call();
+                } catch (Throwable e) {
+                    if (!bs.isUnsubscribed()) {
+                        s.onError(e);
+                    }
+                    return;
+                }
+                if (!bs.isUnsubscribed()) {
+                    s.onCompleted();
+                }
+            }
+        });
+    }
+    
+    /**
+     * Returns a Completable instance that reacts to the termination of the given Future in a blocking fashion.
+     * <p>
+     * Note that cancellation from any of the subscribers to this Completable will cancel the future.
+     * @param future the future to react to
+     * @return the new Completable instance
+     */
+    public static Completable fromFuture(Future<?> future) {
+        requireNonNull(future);
+        return fromObservable(Observable.from(future));
+    }
+    
+    /**
+     * Returns a Completable instance that subscribes to the given flowable, ignores all values and
+     * emits only the terminal event.
+     * @param flowable the Flowable instance to subscribe to, not null
+     * @return the new Completable instance
+     * @throws NullPointerException if flowable is null
+     */
+    public static Completable fromObservable(final Observable<?> flowable) {
+        requireNonNull(flowable);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber cs) {
+                Subscriber<Object> subscriber = new Subscriber<Object>() {
+
+                    @Override
+                    public void onCompleted() {
+                        cs.onCompleted();
+                    }
+
+                    @Override
+                    public void onError(Throwable t) {
+                        cs.onError(t);
+                    }
+
+                    @Override
+                    public void onNext(Object t) {
+                        // ignored
+                    }
+                };
+                cs.onSubscribe(subscriber);
+                flowable.unsafeSubscribe(subscriber);
+            }
+        });
+    }
+
+    /**
+     * Returns a Completable instance that when subscribed to, subscribes to the Single instance and
+     * emits a completion event if the single emits onSuccess or forwards any onError events.
+     * @param single the Single instance to subscribe to, not null
+     * @return the new Completable instance
+     * @throws NullPointerException if single is null
+     */
+    public static Completable fromSingle(final Single<?> single) {
+        requireNonNull(single);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                SingleSubscriber<Object> te = new SingleSubscriber<Object>() {
+
+                    @Override
+                    public void onError(Throwable e) {
+                        s.onError(e);
+                    }
+
+                    @Override
+                    public void onSuccess(Object value) {
+                        s.onCompleted();
+                    }
+                    
+                };
+                s.onSubscribe(te);
+                single.subscribe(te);
+            }
+        });
+    }
+    
+    /**
+     * Returns a Completable instance that subscribes to all sources at once and
+     * completes only when all source Completables complete or one of them emits an error.
+     * @param sources the iterable sequence of sources.
+     * @return the new Completable instance
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable merge(Completable... sources) {
+        requireNonNull(sources);
+        if (sources.length == 0) {
+            return complete();
+        } else
+        if (sources.length == 1) {
+            return sources[0];
+        }
+        return create(new CompletableOnSubscribeMergeArray(sources));
+    }
+    
+    /**
+     * Returns a Completable instance that subscribes to all sources at once and
+     * completes only when all source Completables complete or one of them emits an error.
+     * @param sources the iterable sequence of sources.
+     * @return the new Completable instance
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable merge(Iterable<? extends Completable> sources) {
+        requireNonNull(sources);
+        return create(new CompletableOnSubscribeMergeIterable(sources));
+    }
+
+    /**
+     * Returns a Completable instance that subscribes to all sources at once and
+     * completes only when all source Completables complete or one of them emits an error.
+     * @param sources the iterable sequence of sources.
+     * @return the new Completable instance
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable merge(Observable<? extends Completable> sources) {
+        return merge0(sources, Integer.MAX_VALUE, false);
+    }
+    
+    /**
+     * Returns a Completable instance that keeps subscriptions to a limited number of sources at once and
+     * completes only when all source Completables complete or one of them emits an error.
+     * @param sources the iterable sequence of sources.
+     * @param maxConcurrency the maximum number of concurrent subscriptions
+     * @return the new Completable instance
+     * @throws NullPointerException if sources is null
+     * @throws IllegalArgumentException if maxConcurrency is less than 1
+     */
+    public static Completable merge(Observable<? extends Completable> sources, int maxConcurrency) {
+        return merge0(sources, maxConcurrency, false);
+        
+    }
+    
+    /**
+     * Returns a Completable instance that keeps subscriptions to a limited number of sources at once and
+     * completes only when all source Completables terminate in one way or another, combining any exceptions
+     * thrown by either the sources Observable or the inner Completable instances.
+     * @param sources the iterable sequence of sources.
+     * @param maxConcurrency the maximum number of concurrent subscriptions
+     * @param delayErrors delay all errors from the main source and from the inner Completables?
+     * @return the new Completable instance
+     * @throws NullPointerException if sources is null
+     * @throws IllegalArgumentException if maxConcurrency is less than 1
+     */
+    protected static Completable merge0(Observable<? extends Completable> sources, int maxConcurrency, boolean delayErrors) {
+        requireNonNull(sources);
+        if (maxConcurrency < 1) {
+            throw new IllegalArgumentException("maxConcurrency > 0 required but it was " + maxConcurrency);
+        }
+        return create(new CompletableOnSubscribeMerge(sources, maxConcurrency, delayErrors));
+    }
+    
+    /**
+     * Returns a Completable that subscribes to all Completables in the source array and delays
+     * any error emitted by either the sources observable or any of the inner Completables until all of
+     * them terminate in a way or another.
+     * @param sources the array of Completables
+     * @return the new Completable instance
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable mergeDelayError(Completable... sources) {
+        requireNonNull(sources);
+        return create(new CompletableOnSubscribeMergeDelayErrorArray(sources));
+    }
+
+    /**
+     * Returns a Completable that subscribes to all Completables in the source sequence and delays
+     * any error emitted by either the sources observable or any of the inner Completables until all of
+     * them terminate in a way or another.
+     * @param sources the sequence of Completables
+     * @return the new Completable instance
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable mergeDelayError(Iterable<? extends Completable> sources) {
+        requireNonNull(sources);
+        return create(new CompletableOnSubscribeMergeDelayErrorIterable(sources));
+    }
+
+    /**
+     * Returns a Completable that subscribes to all Completables in the source sequence and delays
+     * any error emitted by either the sources observable or any of the inner Completables until all of
+     * them terminate in a way or another.
+     * @param sources the sequence of Completables
+     * @return the new Completable instance
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable mergeDelayError(Observable<? extends Completable> sources) {
+        return merge0(sources, Integer.MAX_VALUE, true);
+    }
+
+    
+    /**
+     * Returns a Completable that subscribes to a limited number of inner Completables at once in 
+     * the source sequence and delays any error emitted by either the sources 
+     * observable or any of the inner Completables until all of
+     * them terminate in a way or another.
+     * @param sources the sequence of Completables
+     * @return the new Completable instance
+     * @throws NullPointerException if sources is null
+     */
+    public static Completable mergeDelayError(Observable<? extends Completable> sources, int maxConcurrency) {
+        return merge0(sources, maxConcurrency, true);
+    }
+    
+    /**
+     * Returns a Completable that never calls onError or onComplete.
+     * @return the singleton instance that never calls onError or onComplete
+     */
+    public static Completable never() {
+        return NEVER;
+    }
+    
+    /**
+     * Java 7 backport: throws a NullPointerException if o is null.
+     * @param o the object to check
+     * @return the o value
+     * @throws NullPointerException if o is null
+     */
+    static <T> T requireNonNull(T o) {
+        if (o == null) {
+            throw new NullPointerException();
+        }
+        return o;
+    }
+    
+    /**
+     * Returns a Completable instance that fires its onComplete event after the given delay ellapsed.
+     * @param delay the delay time
+     * @param unit the delay unit
+     * @return the new Completable instance
+     */
+    public static Completable timer(long delay, TimeUnit unit) {
+        return timer(delay, unit, Schedulers.computation());
+    }
+    
+    /**
+     * Returns a Completable instance that fires its onComplete event after the given delay ellapsed
+     * by using the supplied scheduler.
+     * @param delay the delay time
+     * @param unit the delay unit
+     * @return the new Completable instance
+     */
+    public static Completable timer(final long delay, final TimeUnit unit, final Scheduler scheduler) {
+        requireNonNull(unit);
+        requireNonNull(scheduler);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                MultipleAssignmentSubscription mad = new MultipleAssignmentSubscription();
+                s.onSubscribe(mad);
+                if (!mad.isUnsubscribed()) {
+                    final Scheduler.Worker w = scheduler.createWorker();
+                    mad.set(w);
+                    w.schedule(new Action0() {
+                        @Override
+                        public void call() {
+                            try {
+                                s.onCompleted();
+                            } finally {
+                                w.unsubscribe();
+                            }
+                        }
+                    }, delay, unit);
+                }
+            }
+        });
+    }
+    
+    /**
+     * Creates a NullPointerException instance and sets the given Throwable as its initial cause.
+     * @param ex the Throwable instance to use as cause, not null (not verified)
+     * @return the created NullPointerException
+     */
+    static NullPointerException toNpe(Throwable ex) {
+        NullPointerException npe = new NullPointerException("Actually not, but can't pass out an exception otherwise...");
+        npe.initCause(ex);
+        return npe;
+    }
+    
+    /**
+     * Returns a Completable instance which manages a resource along 
+     * with a custom Completable instance while the subscription is active.
+     * <p>
+     * This overload performs an eager unsubscription before the terminal event is emitted.
+     * 
+     * @param resourceFunc0 the supplier that returns a resource to be managed. 
+     * @param completableFunc1 the function that given a resource returns a Completable instance that will be subscribed to
+     * @param disposer the consumer that disposes the resource created by the resource supplier
+     * @return the new Completable instance
+     */
+    public static <R> Completable using(Func0<R> resourceFunc0, 
+            Func1<? super R, ? extends Completable> completableFunc1, 
+            Action1<? super R> disposer) {
+        return using(resourceFunc0, completableFunc1, disposer, true);
+    }
+    
+    /**
+     * Returns a Completable instance which manages a resource along 
+     * with a custom Completable instance while the subscription is active and performs eager or lazy
+     * resource disposition.
+     * <p>
+     * If this overload performs a lazy unsubscription after the terminal event is emitted.
+     * Exceptions thrown at this time will be delivered to RxJavaPlugins only.
+     * 
+     * @param resourceFunc0 the supplier that returns a resource to be managed
+     * @param completableFunc1 the function that given a resource returns a non-null
+     * Completable instance that will be subscribed to
+     * @param disposer the consumer that disposes the resource created by the resource supplier
+     * @param eager if true, the resource is disposed before the terminal event is emitted, if false, the
+     * resource is disposed after the terminal event has been emitted
+     * @return the new Completable instance
+     */
+    public static <R> Completable using(final Func0<R> resourceFunc0, 
+            final Func1<? super R, ? extends Completable> completableFunc1, 
+            final Action1<? super R> disposer, 
+            final boolean eager) {
+        requireNonNull(resourceFunc0);
+        requireNonNull(completableFunc1);
+        requireNonNull(disposer);
+        
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                final R resource;
+                
+                try {
+                    resource = resourceFunc0.call();
+                } catch (Throwable e) {
+                    s.onSubscribe(Subscriptions.unsubscribed());
+                    s.onError(e);
+                    return;
+                }
+                
+                Completable cs;
+                
+                try {
+                    cs = completableFunc1.call(resource);
+                } catch (Throwable e) {
+                    try {
+                        disposer.call(resource);
+                    } catch (Throwable ex) {
+                        Exceptions.throwIfFatal(e);
+                        Exceptions.throwIfFatal(ex);
+
+                        s.onSubscribe(Subscriptions.unsubscribed());
+                        s.onError(new CompositeException(Arrays.asList(e, ex)));
+                        return;
+                    }
+                    Exceptions.throwIfFatal(e);
+                    
+                    s.onSubscribe(Subscriptions.unsubscribed());
+                    s.onError(e);
+                    return;
+                }
+                
+                if (cs == null) {
+                    try {
+                        disposer.call(resource);
+                    } catch (Throwable ex) {
+                        Exceptions.throwIfFatal(ex);
+
+                        s.onSubscribe(Subscriptions.unsubscribed());
+                        s.onError(new CompositeException(Arrays.asList(new NullPointerException("The completable supplied is null"), ex)));
+                        return;
+                    }
+                    s.onSubscribe(Subscriptions.unsubscribed());
+                    s.onError(new NullPointerException("The completable supplied is null"));
+                    return;
+                }
+                
+                final AtomicBoolean once = new AtomicBoolean();
+                
+                cs.subscribe(new CompletableSubscriber() {
+                    Subscription d;
+                    void dispose() {
+                        d.unsubscribe();
+                        if (once.compareAndSet(false, true)) {
+                            try {
+                                disposer.call(resource);
+                            } catch (Throwable ex) {
+                                ERROR_HANDLER.handleError(ex);
+                            }
+                        }
+                    }
+
+                    @Override
+                    public void onCompleted() {
+                        if (eager) {
+                            if (once.compareAndSet(false, true)) {
+                                try {
+                                    disposer.call(resource);
+                                } catch (Throwable ex) {
+                                    s.onError(ex);
+                                    return;
+                                }
+                            }
+                        }
+                        
+                        s.onCompleted();
+                        
+                        if (!eager) {
+                            dispose();
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        if (eager) {
+                            if (once.compareAndSet(false, true)) {
+                                try {
+                                    disposer.call(resource);
+                                } catch (Throwable ex) {
+                                    ex.addSuppressed(e);
+                                    e = ex;
+                                }
+                            }
+                        }
+                        
+                        s.onError(e);
+                        
+                        if (!eager) {
+                            dispose();
+                        }
+                    }
+                    
+                    @Override
+                    public void onSubscribe(Subscription d) {
+                        this.d = d;
+                        s.onSubscribe(Subscriptions.create(new Action0() {
+                            @Override
+                            public void call() {
+                                dispose();
+                            }
+                        }));
+                    }
+                });
+            }
+        });
+    }
+    
+    /** The actual subscription action. */
+    private final CompletableOnSubscribe onSubscribe;
+    
+    /**
+     * Constructs a Completable instance with the given onSubscribe callback.
+     * @param onSubscribe the callback that will receive CompletableSubscribers when they subscribe,
+     * not null (not verified)
+     */
+    protected Completable(CompletableOnSubscribe onSubscribe) {
+        this.onSubscribe = onSubscribe;
+    }
+    
+    /**
+     * Returns a Completable that emits the a terminated event of either this Completable
+     * or the other Completable whichever fires first.
+     * @param other the other Completable, not null
+     * @return the new Completable instance
+     * @throws NullPointerException if other is null
+     */
+    public final Completable ambWith(Completable other) {
+        requireNonNull(other);
+        return amb(this, other);
+    }
+    
+    /**
+     * Subscribes to and awaits the termination of this Completable instance in a blocking manner and
+     * rethrows any exception emitted.
+     * @throws RuntimeException wrapping an InterruptedException if the current thread is interrupted
+     */
+    public final void await() {
+        final CountDownLatch cdl = new CountDownLatch(1);
+        final Throwable[] err = new Throwable[1];
+        
+        subscribe(new CompletableSubscriber() {
+
+            @Override
+            public void onCompleted() {
+                cdl.countDown();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                err[0] = e;
+                cdl.countDown();
+            }
+
+            @Override
+            public void onSubscribe(Subscription d) {
+                // ignored
+            }
+            
+        });
+        
+        if (cdl.getCount() == 0) {
+            if (err[0] != null) {
+                Exceptions.propagate(err[0]);
+            }
+            return;
+        }
+        try {
+            cdl.await();
+        } catch (InterruptedException ex) {
+            throw Exceptions.propagate(ex);
+        }
+        if (err[0] != null) {
+            Exceptions.propagate(err[0]);
+        }
+    }
+    
+    /**
+     * Subscribes to and awaits the termination of this Completable instance in a blocking manner
+     * with a specific timeout and rethrows any exception emitted within the timeout window.
+     * @param timeout the timeout value
+     * @param unit the timeout unit
+     * @return true if the this Completable instance completed normally within the time limit,
+     * false if the timeout ellapsed before this Completable terminated.
+     * @throws RuntimeException wrapping an InterruptedException if the current thread is interrupted
+     */
+    public final boolean await(long timeout, TimeUnit unit) {
+        requireNonNull(unit);
+        
+        final CountDownLatch cdl = new CountDownLatch(1);
+        final Throwable[] err = new Throwable[1];
+        
+        subscribe(new CompletableSubscriber() {
+
+            @Override
+            public void onCompleted() {
+                cdl.countDown();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                err[0] = e;
+                cdl.countDown();
+            }
+
+            @Override
+            public void onSubscribe(Subscription d) {
+                // ignored
+            }
+            
+        });
+        
+        if (cdl.getCount() == 0) {
+            if (err[0] != null) {
+                Exceptions.propagate(err[0]);
+            }
+            return true;
+        }
+        boolean b;
+        try {
+             b = cdl.await(timeout, unit);
+        } catch (InterruptedException ex) {
+            throw Exceptions.propagate(ex);
+        }
+        if (b) {
+            if (err[0] != null) {
+                Exceptions.propagate(err[0]);
+            }
+        }
+        return b;
+    }
+    
+    /**
+     * Calls the given transformer function with this instance and returns the function's resulting
+     * Completable.
+     * @param transformer the transformer function, not null
+     * @return the Completable returned by the function
+     * @throws NullPointerException if transformer is null
+     */
+    public final Completable compose(CompletableTransformer transformer) {
+        return to(transformer);
+    }
+    
+    /**
+     * Returns an Observable which will subscribe to this Completable and once that is completed then 
+     * will subscribe to the {@code next} Observable. An error event from this Completable will be 
+     * propagated to the downstream subscriber and will result in skipping the subscription of the 
+     * Observable.  
+     * 
+     * @param next the Observable to subscribe after this Completable is completed, not null
+     * @return Observable that composes this Completable and next
+     * @throws NullPointerException if next is null
+     */
+    public final <T> Observable<T> andThen(Observable<T> next) {
+        requireNonNull(next);
+        return next.delaySubscription(toObservable());
+    }
+    
+    /**
+     * Concatenates this Completable with another Completable.
+     * @param other the other Completable, not null
+     * @return the new Completable which subscribes to this and then the other Completable
+     * @throws NullPointerException if other is null
+     */
+    public final Completable concatWith(Completable other) {
+        requireNonNull(other);
+        return concat(this, other);
+    }
+
+    /**
+     * Returns a Completable which delays the emission of the completion event by the given time.
+     * @param delay the delay time
+     * @param unit the delay unit
+     * @return the new Completable instance
+     * @throws NullPointerException if unit is null
+     */
+    public final Completable delay(long delay, TimeUnit unit) {
+        return delay(delay, unit, Schedulers.computation(), false);
+    }
+    
+    /**
+     * Returns a Completable which delays the emission of the completion event by the given time while
+     * running on the specified scheduler.
+     * @param delay the delay time
+     * @param unit the delay unit
+     * @param scheduler the scheduler to run the delayed completion on
+     * @return the new Completable instance
+     * @throws NullPointerException if unit or scheduler is null
+     */
+    public final Completable delay(long delay, TimeUnit unit, Scheduler scheduler) {
+        return delay(delay, unit, scheduler, false);
+    }
+    
+    /**
+     * Returns a Completable which delays the emission of the completion event, and optionally the error as well, by the given time while
+     * running on the specified scheduler.
+     * @param delay the delay time
+     * @param unit the delay unit
+     * @param scheduler the scheduler to run the delayed completion on
+     * @param delayError delay the error emission as well?
+     * @return the new Completable instance
+     * @throws NullPointerException if unit or scheduler is null
+     */
+    public final Completable delay(final long delay, final TimeUnit unit, final Scheduler scheduler, final boolean delayError) {
+        requireNonNull(unit);
+        requireNonNull(scheduler);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                final CompositeSubscription set = new CompositeSubscription();
+                
+                final Scheduler.Worker w = scheduler.createWorker();
+                set.add(w);
+                
+                subscribe(new CompletableSubscriber() {
+
+                    
+                    @Override
+                    public void onCompleted() {
+                        set.add(w.schedule(new Action0() {
+                            @Override
+                            public void call() {
+                                try {
+                                    s.onCompleted();
+                                } finally {
+                                    w.unsubscribe();
+                                }
+                            }
+                        }, delay, unit));
+                    }
+
+                    @Override
+                    public void onError(final Throwable e) {
+                        if (delayError) {
+                            set.add(w.schedule(new Action0() {
+                                @Override
+                                public void call() {
+                                    try {
+                                        s.onError(e);
+                                    } finally {
+                                        w.unsubscribe();
+                                    }
+                                }
+                            }, delay, unit));
+                        } else {
+                            s.onError(e);
+                        }
+                    }
+
+                    @Override
+                    public void onSubscribe(Subscription d) {
+                        set.add(d);
+                        s.onSubscribe(set);
+                    }
+                    
+                });
+            }
+        });
+    }
+
+    /**
+     * Returns a Completable which calls the given onComplete callback if this Completable completes.
+     * @param onComplete the callback to call when this emits an onComplete event
+     * @return the new Completable instance
+     * @throws NullPointerException if onComplete is null
+     */
+    public final Completable doOnComplete(Action0 onComplete) {
+        return doOnLifecycle(Actions.empty(), Actions.empty(), onComplete, Actions.empty(), Actions.empty());
+    }
+    
+    /**
+     * Returns a Completable which calls the giveon onUnsubscribe callback if the child subscriber cancels
+     * the subscription.
+     * @param onUnsubscribe the callback to call when the child subscriber cancels the subscription
+     * @return the new Completable instance
+     * @throws NullPointerException if onDispose is null
+     */
+    public final Completable doOnUnsubscribe(Action0 onUnsubscribe) {
+        return doOnLifecycle(Actions.empty(), Actions.empty(), Actions.empty(), Actions.empty(), onUnsubscribe);
+    }
+    
+    /**
+     * Returns a Completable which calls the given onError callback if this Completable emits an error.
+     * @param onError the error callback
+     * @return the new Completable instance
+     * @throws NullPointerException if onError is null
+     */
+    public final Completable doOnError(Action1<? super Throwable> onError) {
+        return doOnLifecycle(Actions.empty(), onError, Actions.empty(), Actions.empty(), Actions.empty());
+    }
+
+    /**
+     * Returns a Completable instance that calls the various callbacks on the specific
+     * lifecycle events.
+     * @param onSubscribe the consumer called when a CompletableSubscriber subscribes.
+     * @param onError the consumer called when this emits an onError event
+     * @param onComplete the runnable called just before when this Completable completes normally
+     * @param onAfterComplete the runnable called after this Completable completes normally
+     * @param onUnsubscribe the runnable called when the child cancels the subscription
+     * @return the new Completable instance
+     */
+    protected final Completable doOnLifecycle(
+            final Action1<? super Subscription> onSubscribe, 
+            final Action1<? super Throwable> onError, 
+            final Action0 onComplete, 
+            final Action0 onAfterComplete,
+            final Action0 onUnsubscribe) {
+        requireNonNull(onSubscribe);
+        requireNonNull(onError);
+        requireNonNull(onComplete);
+        requireNonNull(onAfterComplete);
+        requireNonNull(onUnsubscribe);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                subscribe(new CompletableSubscriber() {
+
+                    @Override
+                    public void onCompleted() {
+                        try {
+                            onComplete.call();
+                        } catch (Throwable e) {
+                            s.onError(e);
+                            return;
+                        }
+                        
+                        s.onCompleted();
+                        
+                        try {
+                            onAfterComplete.call();
+                        } catch (Throwable e) {
+                            ERROR_HANDLER.handleError(e);
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        try {
+                            onError.call(e);
+                        } catch (Throwable ex) {
+                            ex.addSuppressed(e);
+                            e = ex;
+                        }
+                        
+                        s.onError(e);
+                    }
+
+                    @Override
+                    public void onSubscribe(final Subscription d) {
+                        
+                        try {
+                            onSubscribe.call(d);
+                        } catch (Throwable ex) {
+                            d.unsubscribe();
+                            s.onSubscribe(Subscriptions.unsubscribed());
+                            s.onError(ex);
+                            return;
+                        }
+                        
+                        s.onSubscribe(Subscriptions.create(new Action0() {
+                            @Override
+                            public void call() {
+                                try {
+                                    onUnsubscribe.call();
+                                } catch (Throwable e) {
+                                    ERROR_HANDLER.handleError(e);
+                                }
+                                d.unsubscribe();
+                            }
+                        }));
+                    }
+                    
+                });
+            }
+        });
+    }
+    
+    /**
+     * Returns a Completable instance that calls the given onSubscribe callback with the disposable
+     * that child subscribers receive on subscription.
+     * @param onSubscribe the callback called when a child subscriber subscribes
+     * @return the new Completable instance
+     * @throws NullPointerException if onSubscribe is null
+     */
+    public final Completable doOnSubscribe(Action1<? super Subscription> onSubscribe) {
+        return doOnLifecycle(onSubscribe, Actions.empty(), Actions.empty(), Actions.empty(), Actions.empty());
+    }
+    
+    /**
+     * Returns a Completable instance that calls the given onTerminate callback just before this Completable
+     * completes normally or with an exception
+     * @param onTerminate the callback to call just before this Completable terminates
+     * @return the new Completable instance
+     */
+    public final Completable doOnTerminate(final Action0 onTerminate) {
+        return doOnLifecycle(Actions.empty(), new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) {
+                onTerminate.call();
+            }
+        }, onTerminate, Actions.empty(), Actions.empty());
+    }
+    
+    /**
+     * Returns a completable that first runs this Completable
+     * and then the other completable.
+     * <p>
+     * This is an alias for {@link #concatWith(Completable)}.
+     * @param other the other Completable, not null
+     * @return the new Completable instance
+     * @throws NullPointerException if other is null
+     */
+    public final Completable endWith(Completable other) {
+        return concatWith(other);
+    }
+    
+    /**
+     * Returns an Observable that first runs this Completable instance and
+     * resumes with the given next Observable.
+     * @param next the next Observable to continue
+     * @return the new Observable instance
+     * @throws NullPointerException if next is null
+     */
+    public final <T> Observable<T> endWith(Observable<T> next) {
+        return next.startWith(this.<T>toObservable());
+    }
+
+    /**
+     * Returns a Completable instace that calls the given onAfterComplete callback after this
+     * Completable completes normally.
+     * @param onAfterComplete the callback to call after this Completable emits an onComplete event.
+     * @return the new Completable instance
+     * @throws NullPointerException if onAfterComplete is null
+     */
+    public final Completable doAfterTerminate(Action0 onAfterComplete) {
+        return doOnLifecycle(Actions.empty(), Actions.empty(), Actions.empty(), onAfterComplete, Actions.empty());
+    }
+    
+    /**
+     * Subscribes to this Completable instance and blocks until it terminates, then returns null or
+     * the emitted exception if any.
+     * @return the throwable if this terminated with an error, null otherwise
+     * @throws RuntimeException that wraps an InterruptedException if the wait is interrupted
+     */
+    public final Throwable get() {
+        final CountDownLatch cdl = new CountDownLatch(1);
+        final Throwable[] err = new Throwable[1];
+        
+        subscribe(new CompletableSubscriber() {
+
+            @Override
+            public void onCompleted() {
+                cdl.countDown();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                err[0] = e;
+                cdl.countDown();
+            }
+
+            @Override
+            public void onSubscribe(Subscription d) {
+                // ignored
+            }
+            
+        });
+        
+        if (cdl.getCount() == 0) {
+            return err[0];
+        }
+        try {
+            cdl.await();
+        } catch (InterruptedException ex) {
+            throw Exceptions.propagate(ex);
+        }
+        return err[0];
+    }
+    
+    /**
+     * Subscribes to this Completable instance and blocks until it terminates or the specified timeout 
+     * ellapses, then returns null for normal termination or the emitted exception if any.
+     * @return the throwable if this terminated with an error, null otherwise
+     * @throws RuntimeException that wraps an InterruptedException if the wait is interrupted or
+     * TimeoutException if the specified timeout ellapsed before it
+     */
+    public final Throwable get(long timeout, TimeUnit unit) {
+        requireNonNull(unit);
+        
+        final CountDownLatch cdl = new CountDownLatch(1);
+        final Throwable[] err = new Throwable[1];
+        
+        subscribe(new CompletableSubscriber() {
+
+            @Override
+            public void onCompleted() {
+                cdl.countDown();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                err[0] = e;
+                cdl.countDown();
+            }
+
+            @Override
+            public void onSubscribe(Subscription d) {
+                // ignored
+            }
+            
+        });
+        
+        if (cdl.getCount() == 0) {
+            return err[0];
+        }
+        boolean b;
+        try {
+            b = cdl.await(timeout, unit);
+        } catch (InterruptedException ex) {
+            throw Exceptions.propagate(ex);
+        }
+        if (b) {
+            return err[0];
+        }
+        Exceptions.propagate(new TimeoutException());
+        return null;
+    }
+    
+    /**
+     * Lifts a CompletableSubscriber transformation into the chain of Completables.
+     * @param onLift the lifting function that transforms the child subscriber with a parent subscriber.
+     * @return the new Completable instance
+     * @throws NullPointerException if onLift is null
+     */
+    public final Completable lift(final CompletableOperator onLift) {
+        requireNonNull(onLift);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(CompletableSubscriber s) {
+                try {
+                    // TODO plugin wrapping
+
+                    CompletableSubscriber sw = onLift.call(s);
+                    
+                    subscribe(sw);
+                } catch (NullPointerException ex) {
+                    throw ex;
+                } catch (Throwable ex) {
+                    throw toNpe(ex);
+                }
+            }
+        });
+    }
+
+    /**
+     * Returns a Completable which subscribes to this and the other Completable and completes
+     * when both of them complete or one emits an error.
+     * @param other the other Completable instance
+     * @return the new Completable instance
+     * @throws NullPointerException if other is null
+     */
+    public final Completable mergeWith(Completable other) {
+        requireNonNull(other);
+        return merge(this, other);
+    }
+    
+    /**
+     * Returns a Completable which emits the terminal events from the thread of the specified scheduler.
+     * @param scheduler the scheduler to emit terminal events on
+     * @return the new Completable instance
+     * @throws NullPointerException if scheduler is null
+     */
+    public final Completable observeOn(final Scheduler scheduler) {
+        requireNonNull(scheduler);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                
+                final SubscriptionList ad = new SubscriptionList();
+                
+                final Scheduler.Worker w = scheduler.createWorker();
+                ad.add(w);
+                
+                s.onSubscribe(ad);
+                
+                subscribe(new CompletableSubscriber() {
+
+                    @Override
+                    public void onCompleted() {
+                        w.schedule(new Action0() {
+                            @Override
+                            public void call() {
+                                try {
+                                    s.onCompleted();
+                                } finally {
+                                    ad.unsubscribe();
+                                }
+                            }
+                        });
+                    }
+
+                    @Override
+                    public void onError(final Throwable e) {
+                        w.schedule(new Action0() {
+                            @Override
+                            public void call() {
+                                try {
+                                    s.onError(e);
+                                } finally {
+                                    ad.unsubscribe();
+                                }
+                            }
+                        });
+                    }
+
+                    @Override
+                    public void onSubscribe(Subscription d) {
+                        ad.add(d);
+                    }
+                    
+                });
+            }
+        });
+    }
+    
+    /**
+     * Returns a Completable instance that if this Completable emits an error, it will emit an onComplete
+     * and swallow the throwable.
+     * @return the new Completable instance
+     */
+    public final Completable onErrorComplete() {
+        return onErrorComplete(UtilityFunctions.alwaysTrue());
+    }
+
+    /**
+     * Returns a Completable instance that if this Completable emits an error and the predicate returns
+     * true, it will emit an onComplete and swallow the throwable.
+     * @param predicate the predicate to call when an Throwable is emitted which should return true
+     * if the Throwable should be swallowed and replaced with an onComplete.
+     * @return the new Completable instance
+     */
+    public final Completable onErrorComplete(final Func1<? super Throwable, Boolean> predicate) {
+        requireNonNull(predicate);
+        
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                subscribe(new CompletableSubscriber() {
+
+                    @Override
+                    public void onCompleted() {
+                        s.onCompleted();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        boolean b;
+                        
+                        try {
+                            b = predicate.call(e);
+                        } catch (Throwable ex) {
+                            e.addSuppressed(ex);
+                            s.onError(e);
+                            return;
+                        }
+                        
+                        if (b) {
+                            s.onCompleted();
+                        } else {
+                            s.onError(e);
+                        }
+                    }
+
+                    @Override
+                    public void onSubscribe(Subscription d) {
+                        s.onSubscribe(d);
+                    }
+                    
+                });
+            }
+        });
+    }
+    
+    /**
+     * Returns a Completable instance that when encounters an error from this Completable, calls the
+     * specified mapper function that returns another Completable instance for it and resumes the
+     * execution with it.
+     * @param errorMapper the mapper function that takes the error and should return a Completable as
+     * continuation.
+     * @return the new Completable instance
+     */
+    public final Completable onErrorResumeNext(final Func1<? super Throwable, ? extends Completable> errorMapper) {
+        requireNonNull(errorMapper);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                final SerialSubscription sd = new SerialSubscription();
+                subscribe(new CompletableSubscriber() {
+
+                    @Override
+                    public void onCompleted() {
+                        s.onCompleted();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        Completable c;
+                        
+                        try {
+                            c = errorMapper.call(e);
+                        } catch (Throwable ex) {
+                            ex.addSuppressed(e);
+                            s.onError(ex);
+                            return;
+                        }
+                        
+                        if (c == null) {
+                            NullPointerException npe = new NullPointerException("The completable returned is null");
+                            npe.addSuppressed(e);
+                            s.onError(npe);
+                            return;
+                        }
+                        
+                        c.subscribe(new CompletableSubscriber() {
+
+                            @Override
+                            public void onCompleted() {
+                                s.onCompleted();
+                            }
+
+                            @Override
+                            public void onError(Throwable e) {
+                                s.onError(e);
+                            }
+
+                            @Override
+                            public void onSubscribe(Subscription d) {
+                                sd.set(d);
+                            }
+                            
+                        });
+                    }
+
+                    @Override
+                    public void onSubscribe(Subscription d) {
+                        sd.set(d);
+                    }
+                    
+                });
+            }
+        });
+    }
+    
+    /**
+     * Returns a Completable that repeatedly subscribes to this Completable until cancelled.
+     * @return the new Completable instance
+     */
+    public final Completable repeat() {
+        return fromObservable(toObservable().repeat());
+    }
+    
+    /**
+     * Returns a Completable that subscribes repeatedly at most the given times to this Completable.
+     * @param times the number of times the resubscription should happen
+     * @return the new Completable instance
+     * @throws IllegalArgumentException if times is less than zero
+     */
+    public final Completable repeat(long times) {
+        return fromObservable(toObservable().repeat(times));
+    }
+    
+    /**
+     * Returns a Completable instance that repeats when the Publisher returned by the handler
+     * emits an item or completes when this Publisher emits a completed event.
+     * @param handler the function that transforms the stream of values indicating the completion of
+     * this Completable and returns a Publisher that emits items for repeating or completes to indicate the
+     * repetition should stop
+     * @return the new Completable instance
+     * @throws NullPointerException if stop is null
+     */
+    public final Completable repeatWhen(Func1<? super Observable<? extends Void>, ? extends Observable<?>> handler) {
+        requireNonNull(handler); // FIXME do a null check in Observable
+        return fromObservable(toObservable().repeatWhen(handler));
+    }
+    
+    /**
+     * Returns a Completable that retries this Completable as long as it emits an onError event.
+     * @return the new Completable instance
+     */
+    public final Completable retry() {
+        return fromObservable(toObservable().retry());
+    }
+    
+    /**
+     * Returns a Completable that retries this Completable in case of an error as long as the predicate
+     * returns true.
+     * @param predicate the predicate called when this emits an error with the repeat count and the latest exception
+     * and should return true to retry.
+     * @return the new Completable instance
+     */
+    public final Completable retry(Func2<Integer, Throwable, Boolean> predicate) {
+        return fromObservable(toObservable().retry(predicate));
+    }
+
+    /**
+     * Returns a Completable that when this Completable emits an error, retries at most the given
+     * number of times before giving up and emitting the last error.
+     * @param times the number of times the returned Completable should retry this Completable
+     * @return the new Completable instance
+     * @throws IllegalArgumentException if times is negative
+     */
+    public final Completable retry(long times) {
+        return fromObservable(toObservable().retry(times));
+    }
+
+    /**
+     * Returns a Completable which given a Publisher and when this Completable emits an error, delivers
+     * that error through an Observable and the Publisher should return a value indicating a retry in response
+     * or a terminal event indicating a termination.
+     * @param handler the handler that receives an Observable delivering Throwables and should return a Publisher that
+     * emits items to indicate retries or emits terminal events to indicate termination.
+     * @return the new Completable instance
+     * @throws NullPointerException if handler is null
+     */
+    public final Completable retryWhen(Func1<? super Observable<? extends Throwable>, ? extends Observable<?>> handler) {
+        return fromObservable(toObservable().retryWhen(handler));
+    }
+
+    /**
+     * Returns a Completable which first runs the other Completable
+     * then this completable if the other completed normally.
+     * @param other the other completable to run first
+     * @return the new Completable instance
+     * @throws NullPointerException if other is null
+     */
+    public final Completable startWith(Completable other) {
+        requireNonNull(other);
+        return concat(other, this);
+    }
+
+    /**
+     * Returns an Observable which first delivers the events
+     * of the other Observable then runs this Completable.
+     * @param other the other Observable to run first
+     * @return the new Observable instance
+     * @throws NullPointerException if other is null
+     */
+    public final <T> Observable<T> startWith(Observable<T> other) {
+        requireNonNull(other);
+        return this.<T>toObservable().startWith(other);
+    }
+    
+    /**
+     * Subscribes to this Completable and returns a Subscription which can be used to cancel
+     * the subscription.
+     * @return the Subscription that allows cancelling the subscription
+     */
+    public final Subscription subscribe() {
+        final MultipleAssignmentSubscription mad = new MultipleAssignmentSubscription();
+        subscribe(new CompletableSubscriber() {
+            @Override
+            public void onCompleted() {
+                // nothing to do
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                ERROR_HANDLER.handleError(e);
+            }
+            
+            @Override
+            public void onSubscribe(Subscription d) {
+                mad.set(d);
+            }
+        });
+        
+        return mad;
+    }
+    /**
+     * Subscribes to this Completable and calls the given Action0 when this Completable
+     * completes normally.
+     * <p>
+     * If this Completable emits an error, it is sent to ERROR_HANDLER.handleError and gets swallowed.
+     * @param onComplete the runnable called when this Completable completes normally
+     * @return the Subscription that allows cancelling the subscription
+     */
+    public final Subscription subscribe(final Action0 onComplete) {
+        requireNonNull(onComplete);
+        
+        final MultipleAssignmentSubscription mad = new MultipleAssignmentSubscription();
+        subscribe(new CompletableSubscriber() {
+            @Override
+            public void onCompleted() {
+                try {
+                    onComplete.call();
+                } catch (Throwable e) {
+                    ERROR_HANDLER.handleError(e);
+                }
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                ERROR_HANDLER.handleError(e);
+            }
+            
+            @Override
+            public void onSubscribe(Subscription d) {
+                mad.set(d);
+            }
+        });
+        
+        return mad;
+    }
+
+    /**
+     * Subscribes to this Completable and calls back either the onError or onComplete functions.
+     * 
+     * @param onError the consumer that is called if this Completable emits an error
+     * @param onComplete the runnable that is called if the Completable completes normally
+     * @return the Subscription that can be used for cancelling the subscription asynchronously
+     * @throws NullPointerException if either callback is null
+     */
+    public final Subscription subscribe(final Action1<? super Throwable> onError, final Action0 onComplete) {
+        requireNonNull(onError);
+        requireNonNull(onComplete);
+        
+        final MultipleAssignmentSubscription mad = new MultipleAssignmentSubscription();
+        subscribe(new CompletableSubscriber() {
+            @Override
+            public void onCompleted() {
+                try {
+                    onComplete.call();
+                } catch (Throwable e) {
+                    onError(e);
+                }
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                try {
+                    onError.call(e);
+                } catch (Throwable ex) {
+                    e.addSuppressed(ex);
+                    ERROR_HANDLER.handleError(e);
+                }
+            }
+            
+            @Override
+            public void onSubscribe(Subscription d) {
+                mad.set(d);
+            }
+        });
+        
+        return mad;
+    }
+    
+    /**
+     * Subscribes the given CompletableSubscriber to this Completable instance.
+     * @param s the CompletableSubscriber, not null
+     * @throws NullPointerException if s is null
+     */
+    public final void subscribe(CompletableSubscriber s) {
+        requireNonNull(s);
+        try {
+            // TODO plugin wrapping the subscriber
+            
+            onSubscribe.call(s);
+        } catch (NullPointerException ex) {
+            throw ex;
+        } catch (Throwable ex) {
+            ERROR_HANDLER.handleError(ex);
+            throw toNpe(ex);
+        }
+    }
+
+    /**
+     * Subscribes a reactive-streams Subscriber to this Completable instance which
+     * will receive only an onError or onComplete event.
+     * @param s the reactive-streams Subscriber, not null
+     * @throws NullPointerException if s is null
+     */
+    public final <T> void subscribe(Subscriber<T> s) {
+        requireNonNull(s);
+        try {
+            final Subscriber<?> sw = s; // FIXME hooking in 1.x is kind of strange to me
+            
+            if (sw == null) {
+                throw new NullPointerException("The RxJavaPlugins.onSubscribe returned a null Subscriber");
+            }
+            
+            subscribe(new CompletableSubscriber() {
+                @Override
+                public void onCompleted() {
+                    sw.onCompleted();
+                }
+                
+                @Override
+                public void onError(Throwable e) {
+                    sw.onError(e);
+                }
+                
+                @Override
+                public void onSubscribe(Subscription d) {
+                    sw.add(d);
+                }
+            });
+            
+        } catch (NullPointerException ex) {
+            throw ex;
+        } catch (Throwable ex) {
+            ERROR_HANDLER.handleError(ex);
+            throw toNpe(ex);
+        }
+    }
+
+    /**
+     * Returns a Completable which subscribes the child subscriber on the specified scheduler, making
+     * sure the subscription side-effects happen on that specific thread of the scheduler.
+     * @param scheduler the Scheduler to subscribe on
+     * @return the new Completable instance
+     * @throws NullPointerException if scheduler is null
+     */
+    public final Completable subscribeOn(final Scheduler scheduler) {
+        requireNonNull(scheduler);
+        
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                // FIXME cancellation of this schedule
+                
+                final Scheduler.Worker w = scheduler.createWorker();
+                
+                w.schedule(new Action0() {
+                    @Override
+                    public void call() {
+                        try {
+                            subscribe(s);
+                        } finally {
+                            w.unsubscribe();
+                        }
+                    }
+                });
+            }
+        });
+    }
+
+    /**
+     * Returns a Completable that runs this Completable and emits a TimeoutException in case
+     * this Completable doesn't complete within the given time.
+     * @param timeout the timeout value
+     * @param unit the timeout unit
+     * @return the new Completable instance
+     * @throws NullPointerException if unit is null
+     */
+    public final Completable timeout(long timeout, TimeUnit unit) {
+        return timeout0(timeout, unit, Schedulers.computation(), null);
+    }
+    
+    /**
+     * Returns a Completable that runs this Completable and switches to the other Completable
+     * in case this Completable doesn't complete within the given time.
+     * @param timeout the timeout value
+     * @param unit the timeout unit
+     * @param other the other Completable instance to switch to in case of a timeout
+     * @return the new Completable instance
+     * @throws NullPointerException if unit or other is null
+     */
+    public final Completable timeout(long timeout, TimeUnit unit, Completable other) {
+        requireNonNull(other);
+        return timeout0(timeout, unit, Schedulers.computation(), other);
+    }
+    
+    /**
+     * Returns a Completable that runs this Completable and emits a TimeoutException in case
+     * this Completable doesn't complete within the given time while "waiting" on the specified
+     * Scheduler.
+     * @param timeout the timeout value
+     * @param unit the timeout unit
+     * @param scheduler the scheduler to use to wait for completion
+     * @return the new Completable instance
+     * @throws NullPointerException if unit or scheduler is null
+     */
+    public final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler) {
+        return timeout0(timeout, unit, scheduler, null);
+    }
+    
+    /**
+     * Returns a Completable that runs this Completable and switches to the other Completable
+     * in case this Completable doesn't complete within the given time while "waiting" on
+     * the specified scheduler.
+     * @param timeout the timeout value
+     * @param unit the timeout unit
+     * @param scheduler the scheduler to use to wait for completion
+     * @param other the other Completable instance to switch to in case of a timeout
+     * @return the new Completable instance
+     * @throws NullPointerException if unit, scheduler or other is null
+     */
+    public final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler, Completable other) {
+        requireNonNull(other);
+        return timeout0(timeout, unit, scheduler, other);
+    }
+    
+    /**
+     * Returns a Completable that runs this Completable and optionally switches to the other Completable
+     * in case this Completable doesn't complete within the given time while "waiting" on
+     * the specified scheduler.
+     * @param timeout the timeout value
+     * @param unit the timeout unit
+     * @param scheduler the scheduler to use to wait for completion
+     * @param other the other Completable instance to switch to in case of a timeout, 
+     * if null a TimeoutException is emitted instead
+     * @return the new Completable instance
+     * @throws NullPointerException if unit or scheduler
+     */
+    public final Completable timeout0(long timeout, TimeUnit unit, Scheduler scheduler, Completable other) {
+        requireNonNull(unit);
+        requireNonNull(scheduler);
+        return create(new CompletableOnSubscribeTimeout(this, timeout, unit, scheduler, other));
+    }
+    
+    /**
+     * Allows fluent conversion to another type via a function callback.
+     * @param converter the function called with this which should return some other value.
+     * @return the converted value
+     * @throws NullPointerException if converter is null
+     */
+    public final <U> U to(Func1<? super Completable, U> converter) {
+        return converter.call(this);
+    }
+
+    /**
+     * Returns an Observable which when subscribed to subscribes to this Completable and
+     * relays the terminal events to the subscriber.
+     * @return the new Observable created
+     */
+    public final <T> Observable<T> toObservable() {
+        return Observable.create(new OnSubscribe<T>() {
+            @Override
+            public void call(Subscriber<? super T> s) {
+                subscribe(s);
+            }
+        });
+    }
+    
+    /**
+     * Convers this Completable into a Single which when this Completable completes normally,
+     * calls the given supplier and emits its returned value through onSuccess.
+     * @param completionValueFunc0 the value supplier called when this Completable completes normally
+     * @return the new Single instance
+     * @throws NullPointerException if completionValueFunc0 is null
+     */
+    public final <T> Single<T> toSingle(final Func0<? extends T> completionValueFunc0) {
+        requireNonNull(completionValueFunc0);
+        return Single.create(new rx.Single.OnSubscribe<T>() {
+            @Override
+            public void call(final SingleSubscriber<? super T> s) {
+                subscribe(new CompletableSubscriber() {
+
+                    @Override
+                    public void onCompleted() {
+                        T v;
+
+                        try {
+                            v = completionValueFunc0.call();
+                        } catch (Throwable e) {
+                            s.onError(e);
+                            return;
+                        }
+                        
+                        if (v == null) {
+                            s.onError(new NullPointerException("The value supplied is null"));
+                        } else {
+                            s.onSuccess(v);
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        s.onError(e);
+                    }
+
+                    @Override
+                    public void onSubscribe(Subscription d) {
+                        s.add(d);
+                    }
+                    
+                });
+            }
+        });
+    }
+    
+    /**
+     * Convers this Completable into a Single which when this Completable completes normally,
+     * emits the given value through onSuccess.
+     * @param completionValue the value to emit when this Completable completes normally
+     * @return the new Single instance
+     * @throws NullPointerException if completionValue is null
+     */
+    public final <T> Single<T> toSingleDefault(final T completionValue) {
+        requireNonNull(completionValue);
+        return toSingle(new Func0<T>() {
+            @Override
+            public T call() {
+                return completionValue;
+            }
+        });
+    }
+    
+    /**
+     * Returns a Completable which makes sure when a subscriber cancels the subscription, the 
+     * dispose is called on the specified scheduler
+     * @param scheduler the target scheduler where to execute the cancellation
+     * @return the new Completable instance
+     * @throws NullPointerException if scheduler is null
+     */
+    public final Completable unsubscribeOn(final Scheduler scheduler) {
+        requireNonNull(scheduler);
+        return create(new CompletableOnSubscribe() {
+            @Override
+            public void call(final CompletableSubscriber s) {
+                subscribe(new CompletableSubscriber() {
+
+                    @Override
+                    public void onCompleted() {
+                        s.onCompleted();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        s.onError(e);
+                    }
+
+                    @Override
+                    public void onSubscribe(final Subscription d) {
+                        s.onSubscribe(Subscriptions.create(new Action0() {
+                            @Override
+                            public void call() {
+                                final Scheduler.Worker w = scheduler.createWorker();
+                                w.schedule(new Action0() {
+                                    @Override
+                                    public void call() {
+                                        try {
+                                            d.unsubscribe();
+                                        } finally {
+                                            w.unsubscribe();
+                                        }
+                                    }
+                                });
+                            }
+                        }));
+                    }
+                    
+                });
+            }
+        });
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/Observable.java b/src/main/java/rx/Observable.java
index cf1686ad83..8e94b3fc0d 100644
--- a/src/main/java/rx/Observable.java
+++ b/src/main/java/rx/Observable.java
@@ -60,7 +60,7 @@ protected Observable(OnSubscribe<T> f) {
         this.onSubscribe = f;
     }
 
-    private static final RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();
+    static final RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();
 
     /**
      * Returns an Observable that will execute the specified function when a {@link Subscriber} subscribes to
@@ -227,11 +227,36 @@ public void call(Subscriber<? super R> o) {
      * @see <a href="http://reactivex.io/documentation/single.html">ReactiveX documentation: Single</a>
      * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
      */
-    @Experimental
+    @Beta
     public Single<T> toSingle() {
         return new Single<T>(OnSubscribeSingle.create(this));
     }
 
+    /**
+     * Returns a Completable that discards all onNext emissions (similar to
+     * {@code ignoreAllElements()}) and calls onCompleted when this source observable calls
+     * onCompleted. Error terminal events are propagated.
+     * <p>
+     * <img width="640" height="295" src=
+     * "https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toCompletable.png"
+     * alt="">
+     * <dl>
+     * <dt><b>Scheduler:</b></dt>
+     * <dd>{@code toCompletable} does not operate by default on a particular {@link Scheduler}.</dd>
+     * </dl>
+     *
+     * @return a Completable that calls onCompleted on it's subscriber when the source Observable
+     *         calls onCompleted
+     * @see <a href="http://reactivex.io/documentation/completable.html">ReactiveX documentation:
+     *      Completable</a>
+     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical
+     *        with the release number)
+     */
+    @Experimental
+    public Completable toCompletable() {
+        return Completable.fromObservable(this);
+    }
+    
 
     /* *********************************************************************************************************
      * Operators Below Here
@@ -1243,7 +1268,14 @@ public void call(Subscriber<? super Object> subscriber) {
      * @see <a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>
      */
     public final static <T> Observable<T> from(T[] array) {
-        return from(Arrays.asList(array));
+        int n = array.length;
+        if (n == 0) {
+            return empty();
+        } else
+        if (n == 1) {
+            return just(array[0]);
+        }
+        return create(new OnSubscribeFromArray<T>(array));
     }
 
     /**
@@ -1252,7 +1284,7 @@ public void call(Subscriber<? super Object> subscriber) {
      * <p>
      * <img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCallable.png" alt="">
      * <p>
-     * This allows you to defer the execution of the function you specify untl an observer subscribes to the
+     * This allows you to defer the execution of the function you specify until an observer subscribes to the
      * Observable. That is to say, it makes the function "lazy."
      * <dl>
      *   <dt><b>Scheduler:</b></dt>
@@ -1423,7 +1455,7 @@ public void call(Subscriber<? super Object> subscriber) {
     // suppress unchecked because we are using varargs inside the method
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> just(T t1, T t2) {
-        return from(Arrays.asList(t1, t2));
+        return from((T[])new Object[] { t1, t2 });
     }
 
     /**
@@ -1449,7 +1481,7 @@ public void call(Subscriber<? super Object> subscriber) {
     // suppress unchecked because we are using varargs inside the method
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> just(T t1, T t2, T t3) {
-        return from(Arrays.asList(t1, t2, t3));
+        return from((T[])new Object[] { t1, t2, t3 });
     }
 
     /**
@@ -1477,7 +1509,7 @@ public void call(Subscriber<? super Object> subscriber) {
     // suppress unchecked because we are using varargs inside the method
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> just(T t1, T t2, T t3, T t4) {
-        return from(Arrays.asList(t1, t2, t3, t4));
+        return from((T[])new Object[] { t1, t2, t3, t4 });
     }
 
     /**
@@ -1507,7 +1539,7 @@ public void call(Subscriber<? super Object> subscriber) {
     // suppress unchecked because we are using varargs inside the method
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> just(T t1, T t2, T t3, T t4, T t5) {
-        return from(Arrays.asList(t1, t2, t3, t4, t5));
+        return from((T[])new Object[] { t1, t2, t3, t4, t5 });
     }
 
     /**
@@ -1539,7 +1571,7 @@ public void call(Subscriber<? super Object> subscriber) {
     // suppress unchecked because we are using varargs inside the method
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> just(T t1, T t2, T t3, T t4, T t5, T t6) {
-        return from(Arrays.asList(t1, t2, t3, t4, t5, t6));
+        return from((T[])new Object[] { t1, t2, t3, t4, t5, t6 });
     }
 
     /**
@@ -1573,7 +1605,7 @@ public void call(Subscriber<? super Object> subscriber) {
     // suppress unchecked because we are using varargs inside the method
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> just(T t1, T t2, T t3, T t4, T t5, T t6, T t7) {
-        return from(Arrays.asList(t1, t2, t3, t4, t5, t6, t7));
+        return from((T[])new Object[] { t1, t2, t3, t4, t5, t6, t7 });
     }
 
     /**
@@ -1609,7 +1641,7 @@ public void call(Subscriber<? super Object> subscriber) {
     // suppress unchecked because we are using varargs inside the method
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> just(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8) {
-        return from(Arrays.asList(t1, t2, t3, t4, t5, t6, t7, t8));
+        return from((T[])new Object[] { t1, t2, t3, t4, t5, t6, t7, t8 });
     }
 
     /**
@@ -1647,7 +1679,7 @@ public void call(Subscriber<? super Object> subscriber) {
     // suppress unchecked because we are using varargs inside the method
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> just(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9) {
-        return from(Arrays.asList(t1, t2, t3, t4, t5, t6, t7, t8, t9));
+        return from((T[])new Object[] { t1, t2, t3, t4, t5, t6, t7, t8, t9 });
     }
 
     /**
@@ -1687,7 +1719,7 @@ public void call(Subscriber<? super Object> subscriber) {
     // suppress unchecked because we are using varargs inside the method
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> just(T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9, T t10) {
-        return from(Arrays.asList(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10));
+        return from((T[])new Object[] { t1, t2, t3, t4, t5, t6, t7, t8, t9, t10 });
     }
     
     /**
@@ -1789,9 +1821,8 @@ public void call(Subscriber<? super Object> subscriber) {
      * @throws IllegalArgumentException
      *             if {@code maxConcurrent} is less than or equal to 0
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     @SuppressWarnings({"unchecked", "rawtypes"})
     public final static <T> Observable<T> merge(Observable<? extends Observable<? extends T>> source, int maxConcurrent) {
         if (source.getClass() == ScalarSynchronousObservable.class) {
@@ -1821,7 +1852,7 @@ public void call(Subscriber<? super Object> subscriber) {
      */
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? extends T> t2) {
-        return merge(from(Arrays.asList(t1, t2)));
+        return merge(new Observable[] { t1, t2 });
     }
 
     /**
@@ -1847,7 +1878,7 @@ public void call(Subscriber<? super Object> subscriber) {
      */
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? extends T> t2, Observable<? extends T> t3) {
-        return merge(from(Arrays.asList(t1, t2, t3)));
+        return merge(new Observable[] { t1, t2, t3 });
     }
 
     /**
@@ -1875,7 +1906,7 @@ public void call(Subscriber<? super Object> subscriber) {
      */
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? extends T> t2, Observable<? extends T> t3, Observable<? extends T> t4) {
-        return merge(from(Arrays.asList(t1, t2, t3, t4)));
+        return merge(new Observable[] { t1, t2, t3, t4 });
     }
 
     /**
@@ -1905,7 +1936,7 @@ public void call(Subscriber<? super Object> subscriber) {
      */
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? extends T> t2, Observable<? extends T> t3, Observable<? extends T> t4, Observable<? extends T> t5) {
-        return merge(from(Arrays.asList(t1, t2, t3, t4, t5)));
+        return merge(new Observable[] { t1, t2, t3, t4, t5 });
     }
 
     /**
@@ -1937,7 +1968,7 @@ public void call(Subscriber<? super Object> subscriber) {
      */
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? extends T> t2, Observable<? extends T> t3, Observable<? extends T> t4, Observable<? extends T> t5, Observable<? extends T> t6) {
-        return merge(from(Arrays.asList(t1, t2, t3, t4, t5, t6)));
+        return merge(new Observable[] { t1, t2, t3, t4, t5, t6 });
     }
 
     /**
@@ -1971,7 +2002,7 @@ public void call(Subscriber<? super Object> subscriber) {
      */
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? extends T> t2, Observable<? extends T> t3, Observable<? extends T> t4, Observable<? extends T> t5, Observable<? extends T> t6, Observable<? extends T> t7) {
-        return merge(from(Arrays.asList(t1, t2, t3, t4, t5, t6, t7)));
+        return merge(new Observable[] { t1, t2, t3, t4, t5, t6, t7 });
     }
 
     /**
@@ -2007,7 +2038,7 @@ public void call(Subscriber<? super Object> subscriber) {
      */
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? extends T> t2, Observable<? extends T> t3, Observable<? extends T> t4, Observable<? extends T> t5, Observable<? extends T> t6, Observable<? extends T> t7, Observable<? extends T> t8) {
-        return merge(from(Arrays.asList(t1, t2, t3, t4, t5, t6, t7, t8)));
+        return merge(new Observable[] { t1, t2, t3, t4, t5, t6, t7, t8 });
     }
 
     /**
@@ -2045,7 +2076,7 @@ public void call(Subscriber<? super Object> subscriber) {
      */
     @SuppressWarnings("unchecked")
     public final static <T> Observable<T> merge(Observable<? extends T> t1, Observable<? extends T> t2, Observable<? extends T> t3, Observable<? extends T> t4, Observable<? extends T> t5, Observable<? extends T> t6, Observable<? extends T> t7, Observable<? extends T> t8, Observable<? extends T> t9) {
-        return merge(from(Arrays.asList(t1, t2, t3, t4, t5, t6, t7, t8, t9)));
+        return merge(new Observable[] { t1, t2, t3, t4, t5, t6, t7, t8, t9 });
     }
 
     /**
@@ -2088,9 +2119,8 @@ public void call(Subscriber<? super Object> subscriber) {
      *            the maximum number of Observables that may be subscribed to concurrently
      * @return an Observable that emits all of the items emitted by the Observables in the Array
      * @see <a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public final static <T> Observable<T> merge(Observable<? extends T>[] sequences, int maxConcurrent) {
         return merge(from(sequences), maxConcurrent);
     }
@@ -3641,6 +3671,15 @@ public final Boolean call(T first, T second) {
         return CachedObservable.from(this);
     }
 
+    /**
+     * @see #cacheWithInitialCapacity(int)
+     * @deprecated Use {@link #cacheWithInitialCapacity(int)} instead.
+     */
+    @Deprecated
+    public final Observable<T> cache(int initialCapacity) {
+        return cacheWithInitialCapacity(initialCapacity);
+    }
+
     /**
      * Caches emissions from the source Observable and replays them in order to any subsequent Subscribers.
      * This method has similar behavior to {@link #replay} except that this auto-subscribes to the source
@@ -3666,14 +3705,17 @@ public final Boolean call(T first, T second) {
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code cache} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
+     * <p>
+     * <em>Note:</em> The capacity hint is not an upper bound on cache size. For that, consider
+     * {@link #replay(int)} in combination with {@link ConnectableObservable#autoConnect()} or similar.
      * 
-     * @param capacityHint hint for number of items to cache (for optimizing underlying data structure)
+     * @param initialCapacity hint for number of items to cache (for optimizing underlying data structure)
      * @return an Observable that, when first subscribed to, caches all of its items and notifications for the
      *         benefit of subsequent subscribers
      * @see <a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>
      */
-    public final Observable<T> cache(int capacityHint) {
-        return CachedObservable.from(this, capacityHint);
+    public final Observable<T> cacheWithInitialCapacity(int initialCapacity) {
+        return CachedObservable.from(this, initialCapacity);
     }
 
     /**
@@ -3744,7 +3786,7 @@ public final R call(R state, T value) {
     /**
      * Returns a new Observable that emits items resulting from applying a function that you supply to each item
      * emitted by the source Observable, where that function returns an Observable, and then emitting the items
-     * that result from concatinating those resulting Observables.
+     * that result from concatenating those resulting Observables.
      * <p>
      * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png" alt="">
      * <dl>
@@ -3756,7 +3798,7 @@ public final R call(R state, T value) {
      *            a function that, when applied to an item emitted by the source Observable, returns an
      *            Observable
      * @return an Observable that emits the result of applying the transformation function to each item emitted
-     *         by the source Observable and concatinating the Observables obtained from this transformation
+     *         by the source Observable and concatenating the Observables obtained from this transformation
      * @see <a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>
      */
     public final <R> Observable<R> concatMap(Func1<? super T, ? extends Observable<? extends R>> func) {
@@ -4014,9 +4056,8 @@ public void call(Subscriber<? super T> subscriber) {
      *              the alternate Observable to subscribe to if the source does not emit any items
      * @return  an Observable that emits the items emitted by the source Observable or the items of an
      *          alternate Observable if the source Observable is empty.
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public final Observable<T> switchIfEmpty(Observable<? extends T> alternate) {
         return lift(new OperatorSwitchIfEmpty<T>(alternate));
     }
@@ -4177,7 +4218,7 @@ public void call(Subscriber<? super T> subscriber) {
      * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.o.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
-     *  <dd>This version of {@code delay} operates by default on the {@code compuation} {@link Scheduler}.</dd>
+     *  <dd>This method does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
      * 
      * @param subscriptionDelay
@@ -4191,6 +4232,32 @@ public void call(Subscriber<? super T> subscriber) {
         return create(new OnSubscribeDelaySubscriptionWithSelector<T, U>(this, subscriptionDelay));
     }
 
+    /**
+     * Returns an Observable that delays the subscription to this Observable
+     * until the other Observable emits an element or completes normally.
+     * <p>
+     * <dl>
+     *  <dt><b>Backpressure:</b></dt>
+     *  <dd>The operator forwards the backpressure requests to this Observable once
+     *  the subscription happens and requests Long.MAX_VALUE from the other Observable</dd>
+     *  <dt><b>Scheduler:</b></dt>
+     *  <dd>This method does not operate by default on a particular {@link Scheduler}.</dd>
+     * </dl>
+     * 
+     * @param <U> the value type of the other Observable, irrelevant
+     * @param other the other Observable that should trigger the subscription
+     *        to this Observable.
+     * @return an Observable that delays the subscription to this Observable
+     *         until the other Observable emits an element or completes normally.
+     */
+    @Experimental
+    public final <U> Observable<T> delaySubscription(Observable<U> other) {
+        if (other == null) {
+            throw new NullPointerException();
+        }
+        return create(new OnSubscribeDelaySubscriptionOther<T, U>(this, other));
+    }
+    
     /**
      * Returns an Observable that reverses the effect of {@link #materialize materialize} by transforming the
      * {@link Notification} objects emitted by the source Observable into the items or notifications they
@@ -5092,9 +5159,32 @@ public final void onNext(T args) {
      *         {@link Action0}
      * @see <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
      * @see #doOnTerminate(Action0)
+     * @deprecated use {@link #doAfterTerminate(Action0)} instead.
      */
+    @Deprecated
     public final Observable<T> finallyDo(Action0 action) {
-        return lift(new OperatorFinally<T>(action));
+        return lift(new OperatorDoAfterTerminate<T>(action));
+    }
+
+    /**
+     * Registers an {@link Action0} to be called when this Observable invokes either
+     * {@link Observer#onCompleted onCompleted} or {@link Observer#onError onError}.
+     * <p>
+     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/finallyDo.png" alt="">
+     * <dl>
+     *  <dt><b>Scheduler:</b></dt>
+     *  <dd>{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.</dd>
+     * </dl>
+     *
+     * @param action
+     *            an {@link Action0} to be invoked when the source Observable finishes
+     * @return an Observable that emits the same items as the source Observable, then invokes the
+     *         {@link Action0}
+     * @see <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
+     * @see #doOnTerminate(Action0)
+     */
+    public final Observable<T> doAfterTerminate(Action0 action) {
+        return lift(new OperatorDoAfterTerminate<T>(action));
     }
 
     /**
@@ -5487,14 +5577,17 @@ public final void forEach(final Action1<? super T> onNext, final Action1<Throwab
     
     /**
      * Groups the items emitted by an {@code Observable} according to a specified criterion, and emits these
-     * grouped items as {@link GroupedObservable}s, one {@code GroupedObservable} per group.
+     * grouped items as {@link GroupedObservable}s. The emitted {@code GroupedObservable} allows only a single 
+     * {@link Subscriber} during its lifetime and if this {@code Subscriber} unsubscribes before the 
+     * source terminates, the next emission by the source having the same key will trigger a new 
+     * {@code GroupedObservable} emission.
      * <p>
      * <img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png" alt="">
      * <p>
      * <em>Note:</em> A {@link GroupedObservable} will cache the items it is to emit until such time as it
      * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
      * {@code GroupedObservable}s that do not concern you. Instead, you can signal to them that they may
-     * discard their buffers by applying an operator like {@link #take}{@code (0)} to them.
+     * discard their buffers by applying an operator like {@link #ignoreElements} to them.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -5519,14 +5612,17 @@ public final void forEach(final Action1<? super T> onNext, final Action1<Throwab
     
     /**
      * Groups the items emitted by an {@code Observable} according to a specified criterion, and emits these
-     * grouped items as {@link GroupedObservable}s, one {@code GroupedObservable} per group.
+     * grouped items as {@link GroupedObservable}s. The emitted {@code GroupedObservable} allows only a single 
+     * {@link Subscriber} during its lifetime and if this {@code Subscriber} unsubscribes before the 
+     * source terminates, the next emission by the source having the same key will trigger a new 
+     * {@code GroupedObservable} emission.
      * <p>
      * <img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png" alt="">
      * <p>
      * <em>Note:</em> A {@link GroupedObservable} will cache the items it is to emit until such time as it
      * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
      * {@code GroupedObservable}s that do not concern you. Instead, you can signal to them that they may
-     * discard their buffers by applying an operator like {@link #take}{@code (0)} to them.
+     * discard their buffers by applying an operator like {@link #ignoreElements} to them.
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -5896,9 +5992,8 @@ public final Boolean call(T t) {
      *
      * @return the source Observable modified to buffer items up to the given capacity
      * @see <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Beta
     public final Observable<T> onBackpressureBuffer(long capacity) {
         return lift(new OperatorOnBackpressureBuffer<T>(capacity));
     }
@@ -5917,9 +6012,8 @@ public final Boolean call(T t) {
      *
      * @return the source Observable modified to buffer items up to the given capacity
      * @see <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Beta
     public final Observable<T> onBackpressureBuffer(long capacity, Action0 onOverflow) {
         return lift(new OperatorOnBackpressureBuffer<T>(capacity, onOverflow));
     }
@@ -5941,9 +6035,8 @@ public final Boolean call(T t) {
      * @return the source Observable modified to drop {@code onNext} notifications on overflow
      * @see <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
      * @Experimental The behavior of this can change at any time. 
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public final Observable<T> onBackpressureDrop(Action1<? super T> onDrop) {
         return lift(new OperatorOnBackpressureDrop<T>(onDrop));
     }
@@ -5968,72 +6061,6 @@ public final Boolean call(T t) {
         return lift(OperatorOnBackpressureDrop.<T>instance());
     }
     
-    /**
-     * Instructs an Observable that is emitting items faster than its observer can consume them to
-     * block the producer thread.
-     * <p>
-     * <img width="640" height="245" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.block.png" alt="">
-     * <p>
-     * The producer side can emit up to {@code maxQueueLength} onNext elements without blocking, but the
-     * consumer side considers the amount its downstream requested through {@code Producer.request(n)}
-     * and doesn't emit more than requested even if more is available. For example, using 
-     * {@code onBackpressureBlock(384).observeOn(Schedulers.io())} will not throw a MissingBackpressureException.
-     * <p>
-     * Note that if the upstream Observable does support backpressure, this operator ignores that capability
-     * and doesn't propagate any backpressure requests from downstream.
-     * <p>
-     * Warning! Using a chain like {@code source.onBackpressureBlock().subscribeOn(scheduler)} is prone to
-     * deadlocks because the consumption of the internal queue is scheduled behind a blocked emission by
-     * the subscribeOn. In order to avoid this, the operators have to be swapped in the chain: 
-     * {@code source.subscribeOn(scheduler).onBackpressureBlock()} and in general, no subscribeOn operator should follow
-     * this operator.
-     *  
-     * @param maxQueueLength the maximum number of items the producer can emit without blocking
-     * @return the source Observable modified to block {@code onNext} notifications on overflow
-     * @see <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
-     * @Experimental The behavior of this can change at any time.
-     * @deprecated The operator doesn't work properly with {@link #subscribeOn(Scheduler)} and is prone to
-     *             deadlocks. It will be removed/unavailable starting from 1.1.
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
-     */
-    @Experimental
-    @Deprecated
-    public final Observable<T> onBackpressureBlock(int maxQueueLength) {
-        return lift(new OperatorOnBackpressureBlock<T>(maxQueueLength));
-    }
-
-    /**
-     * Instructs an Observable that is emitting items faster than its observer can consume them to block the
-     * producer thread if the number of undelivered onNext events reaches the system-wide ring buffer size.
-     * <p>
-     * <img width="640" height="245" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.block.png" alt="">
-     * <p>
-     * The producer side can emit up to the system-wide ring buffer size onNext elements without blocking, but
-     * the consumer side considers the amount its downstream requested through {@code Producer.request(n)}
-     * and doesn't emit more than requested even if available.
-     * <p>
-     * Note that if the upstream Observable does support backpressure, this operator ignores that capability
-     * and doesn't propagate any backpressure requests from downstream.
-     * <p>
-     * Warning! Using a chain like {@code source.onBackpressureBlock().subscribeOn(scheduler)} is prone to
-     * deadlocks because the consumption of the internal queue is scheduled behind a blocked emission by
-     * the subscribeOn. In order to avoid this, the operators have to be swapped in the chain: 
-     * {@code source.subscribeOn(scheduler).onBackpressureBlock()} and in general, no subscribeOn operator should follow
-     * this operator.
-     * 
-     * @return the source Observable modified to block {@code onNext} notifications on overflow
-     * @see <a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>
-     * @Experimental The behavior of this can change at any time. 
-     * @deprecated The operator doesn't work properly with {@link #subscribeOn(Scheduler)} and is prone to
-     *             deadlocks. It will be removed/unavailable starting from 1.1.
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
-     */
-    @Experimental
-    @Deprecated
-    public final Observable<T> onBackpressureBlock() {
-        return onBackpressureBlock(rx.internal.util.RxRingBuffer.SIZE);
-    }
-    
     /**
      * Instructs an Observable that is emitting items faster than its observer can consume them to 
      * hold onto the latest value and emit that on request.
@@ -6050,10 +6077,8 @@ public final Boolean call(T t) {
      * requesting more than 1 from downstream doesn't guarantee a continuous delivery of onNext events.
      *
      * @return the source Observable modified so that it emits the most recently-received item upon request
-     * @Experimental The behavior of this can change at any time. 
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public final Observable<T> onBackpressureLatest() {
         return lift(OperatorOnBackpressureLatest.<T>instance());
     }
@@ -7929,7 +7954,8 @@ public Throwable call(Notification<?> notification) {
     }
 
     /**
-     * Subscribes to an Observable but ignore its emissions and notifications.
+     * Subscribes to an Observable and ignores {@code onNext} and {@code onCompleted} emissions. If an {@code onError} emission arrives then 
+     * {@link OnErrorNotImplementedException} is thrown. 
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -8304,7 +8330,7 @@ public final Subscription subscribe(Subscriber<? super T> subscriber) {
         if (this instanceof ScalarSynchronousObservable) {
             return ((ScalarSynchronousObservable<T>)this).scalarScheduleOn(scheduler);
         }
-        return nest().lift(new OperatorSubscribeOn<T>(scheduler));
+        return create(new OperatorSubscribeOn<T>(this, scheduler));
     }
 
     /**
@@ -8727,9 +8753,8 @@ else if (count == 1 )
      *         condition after each item, and then completes if the condition is satisfied.
      * @see <a href="http://reactivex.io/documentation/operators/takeuntil.html">ReactiveX operators documentation: TakeUntil</a>
      * @see Observable#takeWhile(Func1)
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public final Observable<T> takeUntil(final Func1<? super T, Boolean> stopPredicate) {
         return lift(new OperatorTakeUntilPredicate<T>(stopPredicate));
     }
diff --git a/src/main/java/rx/Scheduler.java b/src/main/java/rx/Scheduler.java
index 12922bc4a4..921528c875 100644
--- a/src/main/java/rx/Scheduler.java
+++ b/src/main/java/rx/Scheduler.java
@@ -43,6 +43,17 @@
  *    maintenance.
  */
 
+    /** 
+     * The tolerance for a clock drift in nanoseconds where the periodic scheduler will rebase. 
+     * <p>
+     * The associated system parameter, {@code rx.scheduler.drift-tolerance}, expects its value in minutes.
+     */
+    static final long CLOCK_DRIFT_TOLERANCE_NANOS;
+    static {
+        CLOCK_DRIFT_TOLERANCE_NANOS = TimeUnit.MINUTES.toNanos(
+                Long.getLong("rx.scheduler.drift-tolerance", 15));
+    }
+    
     /**
      * Retrieves or creates a new {@link Scheduler.Worker} that represents serial execution of actions.
      * <p>
@@ -109,17 +120,38 @@
          */
         public Subscription schedulePeriodically(final Action0 action, long initialDelay, long period, TimeUnit unit) {
             final long periodInNanos = unit.toNanos(period);
-            final long startInNanos = TimeUnit.MILLISECONDS.toNanos(now()) + unit.toNanos(initialDelay);
+            final long firstNowNanos = TimeUnit.MILLISECONDS.toNanos(now());
+            final long firstStartInNanos = firstNowNanos + unit.toNanos(initialDelay);
 
             final MultipleAssignmentSubscription mas = new MultipleAssignmentSubscription();
             final Action0 recursiveAction = new Action0() {
-                long count = 0;
+                long count;
+                long lastNowNanos = firstNowNanos;
+                long startInNanos = firstStartInNanos;
                 @Override
                 public void call() {
                     if (!mas.isUnsubscribed()) {
                         action.call();
-                        long nextTick = startInNanos + (++count * periodInNanos);
-                        mas.set(schedule(this, nextTick - TimeUnit.MILLISECONDS.toNanos(now()), TimeUnit.NANOSECONDS));
+                        
+                        long nextTick;
+                        
+                        long nowNanos = TimeUnit.MILLISECONDS.toNanos(now());
+                        // If the clock moved in a direction quite a bit, rebase the repetition period
+                        if (nowNanos + CLOCK_DRIFT_TOLERANCE_NANOS < lastNowNanos
+                                || nowNanos >= lastNowNanos + periodInNanos + CLOCK_DRIFT_TOLERANCE_NANOS) {
+                            nextTick = nowNanos + periodInNanos;
+                            /* 
+                             * Shift the start point back by the drift as if the whole thing
+                             * started count periods ago.
+                             */
+                            startInNanos = nextTick - (periodInNanos * (++count));
+                        } else {
+                            nextTick = startInNanos + (++count * periodInNanos);
+                        }
+                        lastNowNanos = nowNanos;
+                        
+                        long delay = nextTick - nowNanos;
+                        mas.set(schedule(this, delay, TimeUnit.NANOSECONDS));
                     }
                 }
             };
diff --git a/src/main/java/rx/Single.java b/src/main/java/rx/Single.java
index e47f9c40c7..4b5372f413 100644
--- a/src/main/java/rx/Single.java
+++ b/src/main/java/rx/Single.java
@@ -12,39 +12,19 @@
  */
 package rx;
 
-import java.util.concurrent.Callable;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
+import java.util.Collection;
+import java.util.concurrent.*;
 
 import rx.Observable.Operator;
-import rx.annotations.Experimental;
-import rx.exceptions.Exceptions;
-import rx.exceptions.OnErrorNotImplementedException;
-import rx.functions.Action1;
-import rx.functions.Func1;
-import rx.functions.Func2;
-import rx.functions.Func3;
-import rx.functions.Func4;
-import rx.functions.Func5;
-import rx.functions.Func6;
-import rx.functions.Func7;
-import rx.functions.Func8;
-import rx.functions.Func9;
-import rx.internal.operators.OnSubscribeToObservableFuture;
-import rx.internal.operators.OperatorDelay;
-import rx.internal.operators.OperatorDoOnEach;
-import rx.internal.operators.OperatorMap;
-import rx.internal.operators.OperatorObserveOn;
-import rx.internal.operators.OperatorOnErrorReturn;
-import rx.internal.operators.OperatorSubscribeOn;
-import rx.internal.operators.OperatorTimeout;
-import rx.internal.operators.OperatorZip;
+import rx.annotations.*;
+import rx.exceptions.*;
+import rx.functions.*;
+import rx.internal.operators.*;
 import rx.internal.producers.SingleDelayedProducer;
 import rx.observers.SafeSubscriber;
-import rx.plugins.RxJavaObservableExecutionHook;
-import rx.plugins.RxJavaPlugins;
+import rx.plugins.*;
 import rx.schedulers.Schedulers;
+import rx.singles.BlockingSingle;
 import rx.subscriptions.Subscriptions;
 
 /**
@@ -68,7 +48,7 @@
  *            the type of the item emitted by the Single
  * @since (If this class graduates from "Experimental" replace this parenthetical with the release number)
  */
-@Experimental
+@Beta
 public class Single<T> {
 
     final Observable.OnSubscribe<T> onSubscribe;
@@ -115,7 +95,7 @@ private Single(final Observable.OnSubscribe<T> f) {
         this.onSubscribe = f;
     }
 
-    private static final RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();
+    static final RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();
 
     /**
      * Returns a Single that will execute the specified function when a {@link SingleSubscriber} executes it or
@@ -1202,6 +1182,30 @@ public void onError(Throwable error) {
         return just(new Observable<?>[] { asObservable(o1), asObservable(o2), asObservable(o3), asObservable(o4), asObservable(o5), asObservable(o6), asObservable(o7), asObservable(o8), asObservable(o9) }).lift(new OperatorZip<R>(zipFunction));
     }
 
+    /**
+     * Returns a Single that emits the result of specified combiner function applied to combination of
+     * items emitted, in sequence, by an Iterable of other Singles.
+     * <p>
+     * {@code zip} applies this function in strict sequence.
+     * <p>
+     * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
+     * <dl>
+     *  <dt><b>Scheduler:</b></dt>
+     *  <dd>{@code zip} does not operate by default on a particular {@link Scheduler}.</dd>
+     * </dl>
+     *
+     * @param singles
+     *            an Iterable of source Singles
+     * @param zipFunction
+     *            a function that, when applied to an item emitted by each of the source Singles, results in
+     *            an item that will be emitted by the resulting Single
+     * @return a Single that emits the zipped results
+     * @see <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
+     */
+    public static <R> Single<R> zip(Iterable<? extends Single<?>> singles, FuncN<? extends R> zipFunction) {
+        return SingleOperatorZip.zip(iterableToArray(singles), zipFunction);
+    }
+
     /**
      * Returns an Observable that emits the item emitted by the source Single, then the item emitted by the
      * specified Single.
@@ -1270,7 +1274,7 @@ public void onError(Throwable error) {
      * <dt><b>Scheduler:</b></dt>
      * <dd>{@code map} does not operate by default on a particular {@link Scheduler}.</dd>
      * </dl>
-     * 
+     *
      * @param func
      *            a function to apply to the item emitted by the Single
      * @return a Single that emits the item from the source Single, transformed by the specified function
@@ -1678,8 +1682,43 @@ public void onNext(T t) {
      * @see <a href="http://www.grahamlea.com/2014/07/rxjava-threading-examples/">RxJava Threading Examples</a>
      * @see #observeOn
      */
-    public final Single<T> subscribeOn(Scheduler scheduler) {
-        return nest().lift(new OperatorSubscribeOn<T>(scheduler));
+    public final Single<T> subscribeOn(final Scheduler scheduler) {
+        return create(new OnSubscribe<T>() {
+            @Override
+            public void call(final SingleSubscriber<? super T> t) {
+                final Scheduler.Worker w = scheduler.createWorker();
+                t.add(w);
+               
+                w.schedule(new Action0() {
+                    @Override
+                    public void call() {
+                        SingleSubscriber<T> ssub = new SingleSubscriber<T>() {
+                            @Override
+                            public void onSuccess(T value) {
+                                try {
+                                    t.onSuccess(value);
+                                } finally {
+                                    w.unsubscribe();
+                                }
+                            }
+                            
+                            @Override
+                            public void onError(Throwable error) {
+                                try {
+                                    t.onError(error);
+                                } finally {
+                                    w.unsubscribe();
+                                }
+                            }
+                        };
+                        
+                        t.add(ssub);
+                        
+                        Single.this.subscribe(ssub);
+                    }
+                });
+            }
+        });    
     }
     
     /**
@@ -1794,6 +1833,21 @@ public void onNext(T t) {
         return lift(new OperatorTimeout<T>(timeout, timeUnit, asObservable(other), scheduler));
     }
 
+    /**
+     * Converts a Single into a {@link BlockingSingle} (a Single with blocking operators).
+     * <dl>
+     *  <dt><b>Scheduler:</b></dt>
+     *  <dd>{@code toBlocking} does not operate by default on a particular {@link Scheduler}.</dd>
+     * </dl>
+     *
+     * @return a {@code BlockingSingle} version of this Single.
+     * @see <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>
+     */
+    @Experimental
+    public final BlockingSingle<T> toBlocking() {
+        return BlockingSingle.from(this);
+    }
+
     /**
      * Returns a Single that emits the result of applying a specified function to the pair of items emitted by
      * the source Single and another specified Single.
@@ -1937,4 +1991,131 @@ public void onNext(T t) {
     public final Single<T> delay(long delay, TimeUnit unit) {
         return delay(delay, unit, Schedulers.computation());
     }
+
+    /**
+     * Returns a {@link Single} that calls a {@link Single} factory to create a {@link Single} for each new Observer
+     * that subscribes. That is, for each subscriber, the actual {@link Single} that subscriber observes is
+     * determined by the factory function.
+     * <p>
+     * <img width="640" height="340" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/defer.png" alt="">
+     * <p>
+     * The defer Observer allows you to defer or delay emitting value from a {@link Single} until such time as an
+     * Observer subscribes to the {@link Single}. This allows an {@link Observer} to easily obtain updates or a
+     * refreshed version of the sequence.
+     * <dl>
+     *  <dt><b>Scheduler:</b></dt>
+     *  <dd>{@code defer} does not operate by default on a particular {@link Scheduler}.</dd>
+     * </dl>
+     *
+     * @param singleFactory
+     *            the {@link Single} factory function to invoke for each {@link Observer} that subscribes to the
+     *            resulting {@link Single}.
+     * @param <T>
+     *            the type of the items emitted by the {@link Single}.
+     * @return a {@link Single} whose {@link Observer}s' subscriptions trigger an invocation of the given
+     *         {@link Single} factory function.
+     * @see <a href="http://reactivex.io/documentation/operators/defer.html">ReactiveX operators documentation: Defer</a>
+     */
+    @Experimental
+    public static <T> Single<T> defer(final Callable<Single<T>> singleFactory) {
+        return create(new OnSubscribe<T>() {
+            @Override
+            public void call(SingleSubscriber<? super T> singleSubscriber) {
+                Single<? extends T> single;
+
+                try {
+                    single = singleFactory.call();
+                } catch (Throwable t) {
+                    Exceptions.throwIfFatal(t);
+                    singleSubscriber.onError(t);
+                    return;
+                }
+
+                single.subscribe(singleSubscriber);
+            }
+        });
+    }
+
+    /**
+     * Modifies the source {@link Single} so that it invokes the given action when it is unsubscribed from
+     * its subscribers.
+     * <p>
+     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnUnsubscribe.png" alt="">
+     * <dl>
+     *  <dt><b>Scheduler:</b></dt>
+     *  <dd>{@code doOnUnsubscribe} does not operate by default on a particular {@link Scheduler}.</dd>
+     * </dl>
+     *
+     * @param action
+     *            the action that gets called when this {@link Single} is unsubscribed.
+     * @return the source {@link Single} modified so as to call this Action when appropriate.
+     * @see <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
+     */
+    @Experimental
+    public final Single<T> doOnUnsubscribe(final Action0 action) {
+        return lift(new OperatorDoOnUnsubscribe<T>(action));
+    }
+
+    /**
+     * Registers an {@link Action0} to be called when this {@link Single} invokes either
+     * {@link SingleSubscriber#onSuccess(Object)}  onSuccess} or {@link SingleSubscriber#onError onError}.
+     * <p>
+     * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/finallyDo.png" alt="">
+     * <dl>
+     *  <dt><b>Scheduler:</b></dt>
+     *  <dd>{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.</dd>
+     * </dl>
+     *
+     * @param action
+     *            an {@link Action0} to be invoked when the source {@link Single} finishes.
+     * @return a {@link Single} that emits the same item or error as the source {@link Single}, then invokes the
+     *         {@link Action0}
+     * @see <a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>
+     */
+    @Experimental
+    public final Single<T> doAfterTerminate(Action0 action) {
+        return lift(new OperatorDoAfterTerminate<T>(action));
+    }
+
+    /**
+     * FOR INTERNAL USE ONLY.
+     * <p>
+     * Converts {@link Iterable} of {@link Single} to array of {@link Single}.
+     *
+     * @param singlesIterable
+     *         non null iterable of {@link Single}.
+     * @return array of {@link Single} with same length as passed iterable.
+     */
+    @SuppressWarnings("unchecked")
+    static <T> Single<? extends T>[] iterableToArray(final Iterable<? extends Single<? extends T>> singlesIterable) {
+        final Single<? extends T>[] singlesArray;
+        int count;
+
+        if (singlesIterable instanceof Collection) {
+            Collection<? extends Single<? extends T>> list = (Collection<? extends Single<? extends T>>) singlesIterable;
+            count = list.size();
+            singlesArray = list.toArray(new Single[count]);
+        } else {
+            Single<? extends T>[] tempArray = new Single[8]; // Magic number used just to reduce number of allocations.
+            count = 0;
+            for (Single<? extends T> s : singlesIterable) {
+                if (count == tempArray.length) {
+                    Single<? extends T>[] sb = new Single[count + (count >> 2)];
+                    System.arraycopy(tempArray, 0, sb, 0, count);
+                    tempArray = sb;
+                }
+                tempArray[count] = s;
+                count++;
+            }
+
+            if (tempArray.length == count) {
+                singlesArray = tempArray;
+            } else {
+                singlesArray = new Single[count];
+                System.arraycopy(tempArray, 0, singlesArray, 0, count);
+            }
+        }
+
+        return singlesArray;
+    }
 }
diff --git a/src/main/java/rx/SingleSubscriber.java b/src/main/java/rx/SingleSubscriber.java
index 164933a1a3..7ab135e8ab 100644
--- a/src/main/java/rx/SingleSubscriber.java
+++ b/src/main/java/rx/SingleSubscriber.java
@@ -15,7 +15,7 @@
  */
 package rx;
 
-import rx.annotations.Experimental;
+import rx.annotations.Beta;
 import rx.internal.util.SubscriptionList;
 
 /**
@@ -29,8 +29,9 @@
  * @see <a href="http://reactivex.io/documentation/observable.html">ReactiveX documentation: Observable</a>
  * @param <T>
  *          the type of item the SingleSubscriber expects to observe
+ * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
  */
-@Experimental
+@Beta
 public abstract class SingleSubscriber<T> implements Subscription {
 
     private final SubscriptionList cs = new SubscriptionList();
diff --git a/src/main/java/rx/exceptions/CompositeException.java b/src/main/java/rx/exceptions/CompositeException.java
index 7d6e37e8b9..79a49a7e74 100644
--- a/src/main/java/rx/exceptions/CompositeException.java
+++ b/src/main/java/rx/exceptions/CompositeException.java
@@ -28,7 +28,7 @@
 /**
  * Represents an exception that is a composite of one or more other exceptions. A {@code CompositeException}
  * does not modify the structure of any exception it wraps, but at print-time it iterates through the list of
- * Throwables contained in the composit in order to print them all.
+ * Throwables contained in the composite in order to print them all.
  *
  * Its invariant is to contain an immutable, ordered (by insertion order), unique list of non-composite
  * exceptions. You can retrieve individual exceptions in this list with {@link #getExceptions()}.
diff --git a/src/main/java/rx/exceptions/Exceptions.java b/src/main/java/rx/exceptions/Exceptions.java
index 4701e2bb5f..dea54a9b26 100644
--- a/src/main/java/rx/exceptions/Exceptions.java
+++ b/src/main/java/rx/exceptions/Exceptions.java
@@ -152,9 +152,8 @@ public static Throwable getFinalCause(Throwable e) {
      * @param exceptions the collection of exceptions. If null or empty, no exception is thrown.
      * If the collection contains a single exception, that exception is either thrown as-is or wrapped into a
      * CompositeException. Multiple exceptions are wrapped into a CompositeException.
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public static void throwIfAny(List<? extends Throwable> exceptions) {
         if (exceptions != null && !exceptions.isEmpty()) {
             if (exceptions.size() == 1) {
diff --git a/src/main/java/rx/functions/Actions.java b/src/main/java/rx/functions/Actions.java
index 862bba221c..ea18eaed91 100644
--- a/src/main/java/rx/functions/Actions.java
+++ b/src/main/java/rx/functions/Actions.java
@@ -43,6 +43,9 @@ private Actions() {
             Action8<T0, T1, T2, T3, T4, T5, T6, T7>,
             Action9<T0, T1, T2, T3, T4, T5, T6, T7, T8>,
             ActionN {
+        EmptyAction() {
+        }
+
         @Override
         public void call() {
         }
diff --git a/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java b/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java
index 89d236aabb..9b6cf64bf2 100644
--- a/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java
+++ b/src/main/java/rx/internal/operators/BlockingOperatorMostRecent.java
@@ -63,8 +63,8 @@ private BlockingOperatorMostRecent() {
     private static final class MostRecentObserver<T> extends Subscriber<T> {
         final NotificationLite<T> nl = NotificationLite.instance();
         volatile Object value;
-        
-        private MostRecentObserver(T value) {
+
+        MostRecentObserver(T value) {
             this.value = nl.next(value);
         }
 
diff --git a/src/main/java/rx/internal/operators/BlockingOperatorNext.java b/src/main/java/rx/internal/operators/BlockingOperatorNext.java
index f81577f9b3..7a55a663eb 100644
--- a/src/main/java/rx/internal/operators/BlockingOperatorNext.java
+++ b/src/main/java/rx/internal/operators/BlockingOperatorNext.java
@@ -66,7 +66,7 @@ private BlockingOperatorNext() {
         private Throwable error = null;
         private boolean started = false;
 
-        private NextIterator(Observable<? extends T> items, NextObserver<T> observer) {
+        NextIterator(Observable<? extends T> items, NextObserver<T> observer) {
             this.items = items;
             this.observer = observer;
         }
@@ -149,6 +149,9 @@ public void remove() {
         private final BlockingQueue<Notification<? extends T>> buf = new ArrayBlockingQueue<Notification<? extends T>>(1);
         final AtomicInteger waiting = new AtomicInteger();
 
+        NextObserver() {
+        }
+
         @Override
         public void onCompleted() {
             // ignore
diff --git a/src/main/java/rx/internal/operators/BufferUntilSubscriber.java b/src/main/java/rx/internal/operators/BufferUntilSubscriber.java
index f486c397f7..5e794de018 100644
--- a/src/main/java/rx/internal/operators/BufferUntilSubscriber.java
+++ b/src/main/java/rx/internal/operators/BufferUntilSubscriber.java
@@ -187,7 +187,7 @@ public boolean hasObservers() {
     }
 
     @SuppressWarnings("rawtypes")
-    private final static Observer EMPTY_OBSERVER = new Observer() {
+    final static Observer EMPTY_OBSERVER = new Observer() {
 
         @Override
         public void onCompleted() {
diff --git a/src/main/java/rx/internal/operators/CompletableOnSubscribeConcat.java b/src/main/java/rx/internal/operators/CompletableOnSubscribeConcat.java
new file mode 100644
index 0000000000..c7da20df07
--- /dev/null
+++ b/src/main/java/rx/internal/operators/CompletableOnSubscribeConcat.java
@@ -0,0 +1,152 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.operators;
+
+import java.util.concurrent.atomic.*;
+
+import rx.*;
+import rx.Completable.*;
+import rx.exceptions.MissingBackpressureException;
+import rx.internal.util.unsafe.SpscArrayQueue;
+import rx.plugins.RxJavaPlugins;
+import rx.subscriptions.SerialSubscription;
+
+public final class CompletableOnSubscribeConcat implements CompletableOnSubscribe {
+    final Observable<? extends Completable> sources;
+    final int prefetch;
+    
+    public CompletableOnSubscribeConcat(Observable<? extends Completable> sources, int prefetch) {
+        this.sources = sources;
+        this.prefetch = prefetch;
+    }
+    
+    @Override
+    public void call(CompletableSubscriber s) {
+        CompletableConcatSubscriber parent = new CompletableConcatSubscriber(s, prefetch);
+        s.onSubscribe(parent);
+        sources.subscribe(parent);
+    }
+    
+    static final class CompletableConcatSubscriber
+    extends Subscriber<Completable> {
+        final CompletableSubscriber actual;
+        final int prefetch;
+        final SerialSubscription sr;
+        
+        final SpscArrayQueue<Completable> queue;
+        
+        volatile boolean done;
+
+        volatile int once;
+        static final AtomicIntegerFieldUpdater<CompletableConcatSubscriber> ONCE =
+                AtomicIntegerFieldUpdater.newUpdater(CompletableConcatSubscriber.class, "once");
+        
+        final ConcatInnerSubscriber inner;
+        
+        final AtomicInteger wip;
+        
+        public CompletableConcatSubscriber(CompletableSubscriber actual, int prefetch) {
+            this.actual = actual;
+            this.prefetch = prefetch;
+            this.queue = new SpscArrayQueue<Completable>(prefetch);
+            this.sr = new SerialSubscription();
+            this.inner = new ConcatInnerSubscriber();
+            this.wip = new AtomicInteger();
+            add(sr);
+            request(prefetch);
+        }
+        
+        @Override
+        public void onNext(Completable t) {
+            if (!queue.offer(t)) {
+                onError(new MissingBackpressureException());
+                return;
+            }
+            if (wip.getAndIncrement() == 0) {
+                next();
+            }
+        }
+        
+        @Override
+        public void onError(Throwable t) {
+            if (ONCE.compareAndSet(this, 0, 1)) {
+                actual.onError(t);
+                return;
+            }
+            RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
+        }
+        
+        @Override
+        public void onCompleted() {
+            if (done) {
+                return;
+            }
+            done = true;
+            if (wip.getAndIncrement() == 0) {
+                next();
+            }
+        }
+        
+        void innerError(Throwable e) {
+            unsubscribe();
+            onError(e);
+        }
+        
+        void innerComplete() {
+            if (wip.decrementAndGet() != 0) {
+                next();
+            }
+            if (!done) {
+                request(1);
+            }
+        }
+        
+        void next() {
+            boolean d = done;
+            Completable c = queue.poll();
+            if (c == null) {
+                if (d) {
+                    if (ONCE.compareAndSet(this, 0, 1)) {
+                        actual.onCompleted();
+                    }
+                    return;
+                }
+                RxJavaPlugins.getInstance().getErrorHandler().handleError(new IllegalStateException("Queue is empty?!"));
+                return;
+            }
+            
+            c.subscribe(inner);
+        }
+        
+        final class ConcatInnerSubscriber implements CompletableSubscriber {
+            @Override
+            public void onSubscribe(Subscription d) {
+                sr.set(d);
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                innerError(e);
+            }
+            
+            @Override
+            public void onCompleted() {
+                innerComplete();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/CompletableOnSubscribeConcatArray.java b/src/main/java/rx/internal/operators/CompletableOnSubscribeConcatArray.java
new file mode 100644
index 0000000000..c1f48f61b7
--- /dev/null
+++ b/src/main/java/rx/internal/operators/CompletableOnSubscribeConcatArray.java
@@ -0,0 +1,96 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.operators;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import rx.*;
+import rx.Completable.*;
+import rx.subscriptions.SerialSubscription;
+
+public final class CompletableOnSubscribeConcatArray implements CompletableOnSubscribe {
+    final Completable[] sources;
+    
+    public CompletableOnSubscribeConcatArray(Completable[] sources) {
+        this.sources = sources;
+    }
+    
+    @Override
+    public void call(CompletableSubscriber s) {
+        ConcatInnerSubscriber inner = new ConcatInnerSubscriber(s, sources);
+        s.onSubscribe(inner.sd);
+        inner.next();
+    }
+    
+    static final class ConcatInnerSubscriber extends AtomicInteger implements CompletableSubscriber {
+        /** */
+        private static final long serialVersionUID = -7965400327305809232L;
+
+        final CompletableSubscriber actual;
+        final Completable[] sources;
+        
+        int index;
+        
+        final SerialSubscription sd;
+        
+        public ConcatInnerSubscriber(CompletableSubscriber actual, Completable[] sources) {
+            this.actual = actual;
+            this.sources = sources;
+            this.sd = new SerialSubscription();
+        }
+        
+        @Override
+        public void onSubscribe(Subscription d) {
+            sd.set(d);
+        }
+        
+        @Override
+        public void onError(Throwable e) {
+            actual.onError(e);
+        }
+        
+        @Override
+        public void onCompleted() {
+            next();
+        }
+        
+        void next() {
+            if (sd.isUnsubscribed()) {
+                return;
+            }
+            
+            if (getAndIncrement() != 0) {
+                return;
+            }
+
+            Completable[] a = sources;
+            do {
+                if (sd.isUnsubscribed()) {
+                    return;
+                }
+                
+                int idx = index++;
+                if (idx == a.length) {
+                    actual.onCompleted();
+                    return;
+                }
+                
+                a[idx].subscribe(this);
+            } while (decrementAndGet() != 0);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/CompletableOnSubscribeConcatIterable.java b/src/main/java/rx/internal/operators/CompletableOnSubscribeConcatIterable.java
new file mode 100644
index 0000000000..fe6211153e
--- /dev/null
+++ b/src/main/java/rx/internal/operators/CompletableOnSubscribeConcatIterable.java
@@ -0,0 +1,135 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.operators;
+
+import java.util.Iterator;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import rx.*;
+import rx.Completable.*;
+import rx.subscriptions.*;
+
+public final class CompletableOnSubscribeConcatIterable implements CompletableOnSubscribe {
+    final Iterable<? extends Completable> sources;
+    
+    public CompletableOnSubscribeConcatIterable(Iterable<? extends Completable> sources) {
+        this.sources = sources;
+    }
+    
+    @Override
+    public void call(CompletableSubscriber s) {
+        
+        Iterator<? extends Completable> it;
+        
+        try {
+            it = sources.iterator();
+        } catch (Throwable e) {
+            s.onSubscribe(Subscriptions.unsubscribed());
+            s.onError(e);
+            return;
+        }
+        
+        if (it == null) {
+            s.onSubscribe(Subscriptions.unsubscribed());
+            s.onError(new NullPointerException("The iterator returned is null"));
+            return;
+        }
+        
+        ConcatInnerSubscriber inner = new ConcatInnerSubscriber(s, it);
+        s.onSubscribe(inner.sd);
+        inner.next();
+    }
+    
+    static final class ConcatInnerSubscriber extends AtomicInteger implements CompletableSubscriber {
+        /** */
+        private static final long serialVersionUID = -7965400327305809232L;
+
+        final CompletableSubscriber actual;
+        final Iterator<? extends Completable> sources;
+        
+        int index;
+        
+        final SerialSubscription sd;
+        
+        public ConcatInnerSubscriber(CompletableSubscriber actual, Iterator<? extends Completable> sources) {
+            this.actual = actual;
+            this.sources = sources;
+            this.sd = new SerialSubscription();
+        }
+        
+        @Override
+        public void onSubscribe(Subscription d) {
+            sd.set(d);
+        }
+        
+        @Override
+        public void onError(Throwable e) {
+            actual.onError(e);
+        }
+        
+        @Override
+        public void onCompleted() {
+            next();
+        }
+        
+        void next() {
+            if (sd.isUnsubscribed()) {
+                return;
+            }
+            
+            if (getAndIncrement() != 0) {
+                return;
+            }
+
+            Iterator<? extends Completable> a = sources;
+            do {
+                if (sd.isUnsubscribed()) {
+                    return;
+                }
+                
+                boolean b;
+                try {
+                    b = a.hasNext();
+                } catch (Throwable ex) {
+                    actual.onError(ex);
+                    return;
+                }
+                
+                if (!b) {
+                    actual.onCompleted();
+                    return;
+                }
+                
+                Completable c;
+                
+                try {
+                    c = a.next();
+                } catch (Throwable ex) {
+                    actual.onError(ex);
+                    return;
+                }
+                
+                if (c == null) {
+                    actual.onError(new NullPointerException("The completable returned is null"));
+                    return;
+                }
+                
+                c.subscribe(this);
+            } while (decrementAndGet() != 0);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/CompletableOnSubscribeMerge.java b/src/main/java/rx/internal/operators/CompletableOnSubscribeMerge.java
new file mode 100644
index 0000000000..2b1a3ad2f0
--- /dev/null
+++ b/src/main/java/rx/internal/operators/CompletableOnSubscribeMerge.java
@@ -0,0 +1,215 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.operators;
+
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.*;
+
+import rx.*;
+import rx.Completable.*;
+import rx.plugins.RxJavaPlugins;
+import rx.subscriptions.CompositeSubscription;
+
+public final class CompletableOnSubscribeMerge implements CompletableOnSubscribe {
+    final Observable<? extends Completable> source;
+    final int maxConcurrency;
+    final boolean delayErrors;
+    
+    public CompletableOnSubscribeMerge(Observable<? extends Completable> source, int maxConcurrency, boolean delayErrors) {
+        this.source = source;
+        this.maxConcurrency = maxConcurrency;
+        this.delayErrors = delayErrors;
+    }
+    
+    @Override
+    public void call(CompletableSubscriber s) {
+        CompletableMergeSubscriber parent = new CompletableMergeSubscriber(s, maxConcurrency, delayErrors);
+        s.onSubscribe(parent);
+        source.subscribe(parent);
+    }
+    
+    static final class CompletableMergeSubscriber
+    extends Subscriber<Completable> {
+        final CompletableSubscriber actual;
+        final CompositeSubscription set;
+        final int maxConcurrency;
+        final boolean delayErrors;
+        
+        volatile boolean done;
+        
+        volatile Queue<Throwable> errors;
+        @SuppressWarnings("rawtypes")
+        static final AtomicReferenceFieldUpdater<CompletableMergeSubscriber, Queue> ERRORS =
+                AtomicReferenceFieldUpdater.newUpdater(CompletableMergeSubscriber.class, Queue.class, "errors");
+        
+        volatile int once;
+        static final AtomicIntegerFieldUpdater<CompletableMergeSubscriber> ONCE =
+                AtomicIntegerFieldUpdater.newUpdater(CompletableMergeSubscriber.class, "once");
+        
+        final AtomicInteger wip;
+        
+        public CompletableMergeSubscriber(CompletableSubscriber actual, int maxConcurrency, boolean delayErrors) {
+            this.actual = actual;
+            this.maxConcurrency = maxConcurrency;
+            this.delayErrors = delayErrors;
+            this.set = new CompositeSubscription();
+            this.wip = new AtomicInteger(1);
+            if (maxConcurrency == Integer.MAX_VALUE) {
+                request(Long.MAX_VALUE);
+            } else {
+                request(maxConcurrency);
+            }
+        }
+        
+        Queue<Throwable> getOrCreateErrors() {
+            Queue<Throwable> q = errors;
+            
+            if (q != null) {
+                return q;
+            }
+            
+            q = new ConcurrentLinkedQueue<Throwable>();
+            if (ERRORS.compareAndSet(this, null, q)) {
+                return q;
+            }
+            return errors;
+        }
+
+        @Override
+        public void onNext(Completable t) {
+            if (done) {
+                return;
+            }
+
+            wip.getAndIncrement();
+            
+            t.subscribe(new CompletableSubscriber() {
+                Subscription d;
+                boolean innerDone;
+                @Override
+                public void onSubscribe(Subscription d) {
+                    this.d = d;
+                    set.add(d);
+                }
+                
+                @Override
+                public void onError(Throwable e) {
+                    if (innerDone) {
+                        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+                        return;
+                    }
+                    innerDone = true;
+                    set.remove(d);
+                    
+                    getOrCreateErrors().offer(e);
+                    
+                    terminate();
+                    
+                    if (delayErrors && !done) {
+                        request(1);
+                    }
+                }
+                
+                @Override
+                public void onCompleted() {
+                    if (innerDone) {
+                        return;
+                    }
+                    innerDone = true;
+                    set.remove(d);
+                    
+                    terminate();
+                    
+                    if (!done) {
+                        request(1);
+                    }
+                }
+            });
+        }
+
+        @Override
+        public void onError(Throwable t) {
+            if (done) {
+                RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
+                return;
+            }
+            getOrCreateErrors().offer(t);
+            done = true;
+            terminate();
+        }
+
+        @Override
+        public void onCompleted() {
+            if (done) {
+                return;
+            }
+            done = true;
+            terminate();
+        }
+
+        void terminate() {
+            if (wip.decrementAndGet() == 0) {
+                Queue<Throwable> q = errors;
+                if (q == null || q.isEmpty()) {
+                    actual.onCompleted();
+                } else {
+                    Throwable e = collectErrors(q);
+                    if (ONCE.compareAndSet(this, 0, 1)) {
+                        actual.onError(e);
+                    } else {
+                        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+                    }
+                }
+            } else
+            if (!delayErrors) {
+                Queue<Throwable> q = errors;
+                if (q != null && !q.isEmpty()) {
+                    Throwable e = collectErrors(q);
+                    if (ONCE.compareAndSet(this, 0, 1)) {
+                        actual.onError(e);
+                    } else {
+                        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+                    }
+                }
+            }
+        }
+    }
+    
+    /**
+     * Collects the Throwables from the queue, adding subsequent Throwables as suppressed to
+     * the first Throwable and returns it.
+     * @param q the queue to drain
+     * @return the Throwable containing all other Throwables as suppressed
+     */
+    public static Throwable collectErrors(Queue<Throwable> q) {
+        Throwable ex = null;
+        
+        Throwable t;
+        int count = 0;
+        while ((t = q.poll()) != null) {
+            if (count == 0) {
+                ex = t;
+            } else {
+                ex.addSuppressed(t);
+            }
+            
+            count++;
+        }
+        return ex;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeArray.java b/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeArray.java
new file mode 100644
index 0000000000..85d3d59b3a
--- /dev/null
+++ b/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeArray.java
@@ -0,0 +1,91 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.operators;
+
+import java.util.concurrent.atomic.*;
+
+import rx.*;
+import rx.Completable.*;
+import rx.plugins.RxJavaPlugins;
+import rx.subscriptions.CompositeSubscription;
+
+public final class CompletableOnSubscribeMergeArray implements CompletableOnSubscribe {
+    final Completable[] sources;
+    
+    public CompletableOnSubscribeMergeArray(Completable[] sources) {
+        this.sources = sources;
+    }
+    
+    @Override
+    public void call(final CompletableSubscriber s) {
+        final CompositeSubscription set = new CompositeSubscription();
+        final AtomicInteger wip = new AtomicInteger(sources.length + 1);
+        final AtomicBoolean once = new AtomicBoolean();
+        
+        s.onSubscribe(set);
+        
+        for (Completable c : sources) {
+            if (set.isUnsubscribed()) {
+                return;
+            }
+            
+            if (c == null) {
+                set.unsubscribe();
+                NullPointerException npe = new NullPointerException("A completable source is null");
+                if (once.compareAndSet(false, true)) {
+                    s.onError(npe);
+                    return;
+                } else {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(npe);
+                }
+            }
+            
+            c.subscribe(new CompletableSubscriber() {
+                @Override
+                public void onSubscribe(Subscription d) {
+                    set.add(d);
+                }
+
+                @Override
+                public void onError(Throwable e) {
+                    set.unsubscribe();
+                    if (once.compareAndSet(false, true)) {
+                        s.onError(e);
+                    } else {
+                        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+                    }
+                }
+
+                @Override
+                public void onCompleted() {
+                    if (wip.decrementAndGet() == 0) {
+                        if (once.compareAndSet(false, true)) {
+                            s.onCompleted();
+                        }
+                    }
+                }
+                
+            });
+        }
+        
+        if (wip.decrementAndGet() == 0) {
+            if (once.compareAndSet(false, true)) {
+                s.onCompleted();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeDelayErrorArray.java b/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeDelayErrorArray.java
new file mode 100644
index 0000000000..2a89afbaa2
--- /dev/null
+++ b/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeDelayErrorArray.java
@@ -0,0 +1,93 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.operators;
+
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import rx.*;
+import rx.Completable.*;
+import rx.subscriptions.CompositeSubscription;
+
+public final class CompletableOnSubscribeMergeDelayErrorArray implements CompletableOnSubscribe {
+    final Completable[] sources;
+    
+    public CompletableOnSubscribeMergeDelayErrorArray(Completable[] sources) {
+        this.sources = sources;
+    }
+    
+    @Override
+    public void call(final CompletableSubscriber s) {
+        final CompositeSubscription set = new CompositeSubscription();
+        final AtomicInteger wip = new AtomicInteger(sources.length + 1);
+        
+        final Queue<Throwable> q = new ConcurrentLinkedQueue<Throwable>();
+        
+        s.onSubscribe(set);
+        
+        for (Completable c : sources) {
+            if (set.isUnsubscribed()) {
+                return;
+            }
+            
+            if (c == null) {
+                q.offer(new NullPointerException("A completable source is null"));
+                wip.decrementAndGet();
+                continue;
+            }
+            
+            c.subscribe(new CompletableSubscriber() {
+                @Override
+                public void onSubscribe(Subscription d) {
+                    set.add(d);
+                }
+
+                @Override
+                public void onError(Throwable e) {
+                    q.offer(e);
+                    tryTerminate();
+                }
+
+                @Override
+                public void onCompleted() {
+                    tryTerminate();
+                }
+                
+                void tryTerminate() {
+                    if (wip.decrementAndGet() == 0) {
+                        if (q.isEmpty()) {
+                            s.onCompleted();
+                        } else {
+                            s.onError(CompletableOnSubscribeMerge.collectErrors(q));
+                        }
+                    }
+                }
+                
+            });
+        }
+        
+        if (wip.decrementAndGet() == 0) {
+            if (q.isEmpty()) {
+                s.onCompleted();
+            } else {
+                s.onError(CompletableOnSubscribeMerge.collectErrors(q));
+            }
+        }
+        
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeDelayErrorIterable.java b/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeDelayErrorIterable.java
new file mode 100644
index 0000000000..be783e6d6d
--- /dev/null
+++ b/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeDelayErrorIterable.java
@@ -0,0 +1,157 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.operators;
+
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import rx.*;
+import rx.Completable.*;
+import rx.internal.util.unsafe.MpscLinkedQueue;
+import rx.subscriptions.CompositeSubscription;
+
+public final class CompletableOnSubscribeMergeDelayErrorIterable implements CompletableOnSubscribe {
+    final Iterable<? extends Completable> sources;
+    
+    public CompletableOnSubscribeMergeDelayErrorIterable(Iterable<? extends Completable> sources) {
+        this.sources = sources;
+    }
+    
+    @Override
+    public void call(final CompletableSubscriber s) {
+        final CompositeSubscription set = new CompositeSubscription();
+        final AtomicInteger wip = new AtomicInteger(1);
+        
+        final Queue<Throwable> queue = new MpscLinkedQueue<Throwable>();
+        
+        s.onSubscribe(set);
+        
+        Iterator<? extends Completable> iterator;
+        
+        try {
+            iterator = sources.iterator();
+        } catch (Throwable e) {
+            s.onError(e);
+            return;
+        }
+        
+        if (iterator == null) {
+            s.onError(new NullPointerException("The source iterator returned is null"));
+            return;
+        }
+        
+        for (;;) {
+            if (set.isUnsubscribed()) {
+                return;
+            }
+            
+            boolean b;
+            try {
+                b = iterator.hasNext();
+            } catch (Throwable e) {
+                queue.offer(e);
+                if (wip.decrementAndGet() == 0) {
+                    if (queue.isEmpty()) {
+                        s.onCompleted();
+                    } else {
+                        s.onError(CompletableOnSubscribeMerge.collectErrors(queue));
+                    }
+                }
+                return;
+            }
+                    
+            if (!b) {
+                break;
+            }
+            
+            if (set.isUnsubscribed()) {
+                return;
+            }
+            
+            Completable c;
+            
+            try {
+                c = iterator.next();
+            } catch (Throwable e) {
+                queue.offer(e);
+                if (wip.decrementAndGet() == 0) {
+                    if (queue.isEmpty()) {
+                        s.onCompleted();
+                    } else {
+                        s.onError(CompletableOnSubscribeMerge.collectErrors(queue));
+                    }
+                }
+                return;
+            }
+            
+            if (set.isUnsubscribed()) {
+                return;
+            }
+            
+            if (c == null) {
+                NullPointerException e = new NullPointerException("A completable source is null");
+                queue.offer(e);
+                if (wip.decrementAndGet() == 0) {
+                    if (queue.isEmpty()) {
+                        s.onCompleted();
+                    } else {
+                        s.onError(CompletableOnSubscribeMerge.collectErrors(queue));
+                    }
+                }
+                return;
+            }
+            
+            wip.getAndIncrement();
+            
+            c.subscribe(new CompletableSubscriber() {
+                @Override
+                public void onSubscribe(Subscription d) {
+                    set.add(d);
+                }
+
+                @Override
+                public void onError(Throwable e) {
+                    queue.offer(e);
+                    tryTerminate();
+                }
+
+                @Override
+                public void onCompleted() {
+                    tryTerminate();
+                }
+                
+                void tryTerminate() {
+                    if (wip.decrementAndGet() == 0) {
+                        if (queue.isEmpty()) {
+                            s.onCompleted();
+                        } else {
+                            s.onError(CompletableOnSubscribeMerge.collectErrors(queue));
+                        }
+                    }
+                }
+            });
+        }
+        
+        if (wip.decrementAndGet() == 0) {
+            if (queue.isEmpty()) {
+                s.onCompleted();
+            } else {
+                s.onError(CompletableOnSubscribeMerge.collectErrors(queue));
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeIterable.java b/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeIterable.java
new file mode 100644
index 0000000000..7ad953e4de
--- /dev/null
+++ b/src/main/java/rx/internal/operators/CompletableOnSubscribeMergeIterable.java
@@ -0,0 +1,147 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.operators;
+
+import java.util.Iterator;
+import java.util.concurrent.atomic.*;
+
+import rx.*;
+import rx.Completable.*;
+import rx.plugins.RxJavaPlugins;
+import rx.subscriptions.CompositeSubscription;
+
+public final class CompletableOnSubscribeMergeIterable implements CompletableOnSubscribe {
+    final Iterable<? extends Completable> sources;
+    
+    public CompletableOnSubscribeMergeIterable(Iterable<? extends Completable> sources) {
+        this.sources = sources;
+    }
+    
+    @Override
+    public void call(final CompletableSubscriber s) {
+        final CompositeSubscription set = new CompositeSubscription();
+        final AtomicInteger wip = new AtomicInteger(1);
+        final AtomicBoolean once = new AtomicBoolean();
+        
+        s.onSubscribe(set);
+        
+        Iterator<? extends Completable> iterator;
+        
+        try {
+            iterator = sources.iterator();
+        } catch (Throwable e) {
+            s.onError(e);
+            return;
+        }
+        
+        if (iterator == null) {
+            s.onError(new NullPointerException("The source iterator returned is null"));
+            return;
+        }
+        
+        for (;;) {
+            if (set.isUnsubscribed()) {
+                return;
+            }
+            
+            boolean b;
+            try {
+                b = iterator.hasNext();
+            } catch (Throwable e) {
+                set.unsubscribe();
+                if (once.compareAndSet(false, true)) {
+                    s.onError(e);
+                } else {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+                }
+                return;
+            }
+                    
+            if (!b) {
+                break;
+            }
+            
+            if (set.isUnsubscribed()) {
+                return;
+            }
+            
+            Completable c;
+            
+            try {
+                c = iterator.next();
+            } catch (Throwable e) {
+                set.unsubscribe();
+                if (once.compareAndSet(false, true)) {
+                    s.onError(e);
+                } else {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+                }
+                return;
+            }
+            
+            if (set.isUnsubscribed()) {
+                return;
+            }
+            
+            if (c == null) {
+                set.unsubscribe();
+                NullPointerException npe = new NullPointerException("A completable source is null");
+                if (once.compareAndSet(false, true)) {
+                    s.onError(npe);
+                } else {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(npe);
+                }
+                return;
+            }
+            
+            wip.getAndIncrement();
+            
+            c.subscribe(new CompletableSubscriber() {
+                @Override
+                public void onSubscribe(Subscription d) {
+                    set.add(d);
+                }
+
+                @Override
+                public void onError(Throwable e) {
+                    set.unsubscribe();
+                    if (once.compareAndSet(false, true)) {
+                        s.onError(e);
+                    } else {
+                        RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+                    }
+                }
+
+                @Override
+                public void onCompleted() {
+                    if (wip.decrementAndGet() == 0) {
+                        if (once.compareAndSet(false, true)) {
+                            s.onCompleted();
+                        }
+                    }
+                }
+                
+            });
+        }
+        
+        if (wip.decrementAndGet() == 0) {
+            if (once.compareAndSet(false, true)) {
+                s.onCompleted();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/CompletableOnSubscribeTimeout.java b/src/main/java/rx/internal/operators/CompletableOnSubscribeTimeout.java
new file mode 100644
index 0000000000..2a9c8e31e2
--- /dev/null
+++ b/src/main/java/rx/internal/operators/CompletableOnSubscribeTimeout.java
@@ -0,0 +1,115 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.operators;
+
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import rx.*;
+import rx.Completable.*;
+import rx.functions.Action0;
+import rx.plugins.RxJavaPlugins;
+import rx.subscriptions.CompositeSubscription;
+
+public final class CompletableOnSubscribeTimeout implements CompletableOnSubscribe {
+    
+    final Completable source;
+    final long timeout;
+    final TimeUnit unit;
+    final Scheduler scheduler;
+    final Completable other;
+
+    public CompletableOnSubscribeTimeout(Completable source, long timeout, 
+            TimeUnit unit, Scheduler scheduler, Completable other) {
+        this.source = source;
+        this.timeout = timeout;
+        this.unit = unit;
+        this.scheduler = scheduler;
+        this.other = other;
+    }
+
+    @Override
+    public void call(final CompletableSubscriber s) {
+        final CompositeSubscription set = new CompositeSubscription();
+        s.onSubscribe(set);
+        
+        final AtomicBoolean once = new AtomicBoolean();
+        
+        Scheduler.Worker w = scheduler.createWorker();
+        
+        set.add(w);
+        w.schedule(new Action0() {
+            @Override
+            public void call() {
+                if (once.compareAndSet(false, true)) {
+                    set.clear();
+                    if (other == null) {
+                        s.onError(new TimeoutException());
+                    } else {
+                        other.subscribe(new CompletableSubscriber() {
+   
+                            @Override
+                            public void onSubscribe(Subscription d) {
+                                set.add(d);
+                            }
+   
+                            @Override
+                            public void onError(Throwable e) {
+                                set.unsubscribe();
+                                s.onError(e);
+                            }
+   
+                            @Override
+                            public void onCompleted() {
+                                set.unsubscribe();
+                                s.onCompleted();
+                            }
+                            
+                        });
+                    }
+                }
+            }
+        }, timeout, unit);
+        
+        source.subscribe(new CompletableSubscriber() {
+
+            @Override
+            public void onSubscribe(Subscription d) {
+                set.add(d);
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                if (once.compareAndSet(false, true)) {
+                    set.unsubscribe();
+                    s.onError(e);
+                } else {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+                }
+            }
+
+            @Override
+            public void onCompleted() {
+                if (once.compareAndSet(false, true)) {
+                    set.unsubscribe();
+                    s.onCompleted();
+                }
+            }
+            
+        });
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/NotificationLite.java b/src/main/java/rx/internal/operators/NotificationLite.java
index cd223e6784..0293beab95 100644
--- a/src/main/java/rx/internal/operators/NotificationLite.java
+++ b/src/main/java/rx/internal/operators/NotificationLite.java
@@ -71,7 +71,7 @@ public String toString() {
 
     private static class OnErrorSentinel implements Serializable {
         private static final long serialVersionUID = 3;
-        private final Throwable e;
+        final Throwable e;
 
         public OnErrorSentinel(Throwable e) {
             this.e = e;
diff --git a/src/main/java/rx/internal/operators/OnSubscribeAmb.java b/src/main/java/rx/internal/operators/OnSubscribeAmb.java
index 2ddd0dc820..2fe48d812f 100644
--- a/src/main/java/rx/internal/operators/OnSubscribeAmb.java
+++ b/src/main/java/rx/internal/operators/OnSubscribeAmb.java
@@ -271,7 +271,7 @@
         private final Selection<T> selection;
         private boolean chosen;
 
-        private AmbSubscriber(long requested, Subscriber<? super T> subscriber, Selection<T> selection) {
+        AmbSubscriber(long requested, Subscriber<? super T> subscriber, Selection<T> selection) {
             this.subscriber = subscriber;
             this.selection = selection;
             // initial request
@@ -434,7 +434,7 @@ public void request(long n) {
         });
     }
 
-    private static <T> void unsubscribeAmbSubscribers(Collection<AmbSubscriber<T>> ambSubscribers) {
+    static <T> void unsubscribeAmbSubscribers(Collection<AmbSubscriber<T>> ambSubscribers) {
         if(!ambSubscribers.isEmpty()) {
             for (AmbSubscriber<T> other : ambSubscribers) {
                 other.unsubscribe();
diff --git a/src/main/java/rx/internal/operators/OnSubscribeDelaySubscriptionOther.java b/src/main/java/rx/internal/operators/OnSubscribeDelaySubscriptionOther.java
new file mode 100644
index 0000000000..2a8b7e1601
--- /dev/null
+++ b/src/main/java/rx/internal/operators/OnSubscribeDelaySubscriptionOther.java
@@ -0,0 +1,79 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package rx.internal.operators;
+
+import rx.*;
+import rx.Observable.OnSubscribe;
+import rx.observers.Subscribers;
+import rx.plugins.*;
+import rx.subscriptions.SerialSubscription;
+
+/**
+ * Delays the subscription to the main source until the other
+ * observable fires an event or completes.
+ * @param <T> the main type
+ * @param <U> the other value type, ignored
+ */
+public final class OnSubscribeDelaySubscriptionOther<T, U> implements OnSubscribe<T> {
+    final Observable<? extends T> main;
+    final Observable<U> other;
+    
+    public OnSubscribeDelaySubscriptionOther(Observable<? extends T> main, Observable<U> other) {
+        this.main = main;
+        this.other = other;
+    }
+    
+    @Override
+    public void call(Subscriber<? super T> t) {
+        final Subscriber<T> child = Subscribers.wrap(t);
+        
+        final SerialSubscription serial = new SerialSubscription();
+        
+        Subscriber<U> otherSubscriber = new Subscriber<U>() {
+            boolean done;
+            @Override
+            public void onNext(U t) {
+                onCompleted();
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                if (done) {
+                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+                    return;
+                }
+                done = true;
+                child.onError(e);
+            }
+            
+            @Override
+            public void onCompleted() {
+                if (done) {
+                    return;
+                }
+                done = true;
+                serial.set(child);
+                
+                main.unsafeSubscribe(child);
+            }
+        };
+        
+        serial.set(otherSubscriber);
+        
+        other.unsafeSubscribe(otherSubscriber);
+    }
+}
diff --git a/src/main/java/rx/internal/operators/OnSubscribeFromArray.java b/src/main/java/rx/internal/operators/OnSubscribeFromArray.java
new file mode 100644
index 0000000000..623dcaa65f
--- /dev/null
+++ b/src/main/java/rx/internal/operators/OnSubscribeFromArray.java
@@ -0,0 +1,128 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.operators;
+
+import java.util.concurrent.atomic.AtomicLong;
+
+import rx.*;
+import rx.Observable.OnSubscribe;
+
+public final class OnSubscribeFromArray<T> implements OnSubscribe<T> {
+    final T[] array;
+    public OnSubscribeFromArray(T[] array) {
+        this.array = array;
+    }
+    
+    @Override
+    public void call(Subscriber<? super T> child) {
+        child.setProducer(new FromArrayProducer<T>(child, array));
+    }
+    
+    static final class FromArrayProducer<T>
+    extends AtomicLong
+    implements Producer {
+        /** */
+        private static final long serialVersionUID = 3534218984725836979L;
+        
+        final Subscriber<? super T> child;
+        final T[] array;
+        
+        int index;
+        
+        public FromArrayProducer(Subscriber<? super T> child, T[] array) {
+            this.child = child;
+            this.array = array;
+        }
+        
+        @Override
+        public void request(long n) {
+            if (n < 0) {
+                throw new IllegalArgumentException("n >= 0 required but it was " + n);
+            }
+            if (n == Long.MAX_VALUE) {
+                if (BackpressureUtils.getAndAddRequest(this, n) == 0) {
+                    fastPath();
+                }
+            } else
+            if (n != 0) {
+                if (BackpressureUtils.getAndAddRequest(this, n) == 0) {
+                    slowPath(n);
+                }
+            }
+        }
+        
+        void fastPath() {
+            final Subscriber<? super T> child = this.child;
+            
+            for (T t : array) {
+                if (child.isUnsubscribed()) {
+                    return;
+                }
+                
+                child.onNext(t);
+            }
+            
+            if (child.isUnsubscribed()) {
+                return;
+            }
+            child.onCompleted();
+        }
+        
+        void slowPath(long r) {
+            final Subscriber<? super T> child = this.child;
+            final T[] array = this.array;
+            final int n = array.length;
+            
+            long e = 0L;
+            int i = index;
+
+            for (;;) {
+                
+                while (r != 0L && i != n) {
+                    if (child.isUnsubscribed()) {
+                        return;
+                    }
+                    
+                    child.onNext(array[i]);
+                    
+                    i++;
+                    
+                    if (i == n) {
+                        if (!child.isUnsubscribed()) {
+                            child.onCompleted();
+                        }
+                        return;
+                    }
+                    
+                    r--;
+                    e--;
+                }
+                
+                r = get() + e;
+                
+                if (r == 0L) {
+                    index = i;
+                    r = addAndGet(e);
+                    if (r == 0L) {
+                        return;
+                    }
+                    e = 0L;
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java
index f4790e75bd..b94e35c35c 100644
--- a/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java
+++ b/src/main/java/rx/internal/operators/OnSubscribeFromIterable.java
@@ -55,7 +55,7 @@ public void call(final Subscriber<? super T> o) {
         private final Subscriber<? super T> o;
         private final Iterator<? extends T> it;
 
-        private IterableProducer(Subscriber<? super T> o, Iterator<? extends T> it) {
+        IterableProducer(Subscriber<? super T> o, Iterator<? extends T> it) {
             this.o = o;
             this.it = it;
         }
diff --git a/src/main/java/rx/internal/operators/OnSubscribeRange.java b/src/main/java/rx/internal/operators/OnSubscribeRange.java
index 383d17f28f..c7631b2cb9 100644
--- a/src/main/java/rx/internal/operators/OnSubscribeRange.java
+++ b/src/main/java/rx/internal/operators/OnSubscribeRange.java
@@ -46,7 +46,7 @@ public void call(final Subscriber<? super Integer> o) {
         private final int end;
         private long index;
 
-        private RangeProducer(Subscriber<? super Integer> o, int start, int end) {
+        RangeProducer(Subscriber<? super Integer> o, int start, int end) {
             this.o = o;
             this.index = start;
             this.end = end;
diff --git a/src/main/java/rx/internal/operators/OnSubscribeRedo.java b/src/main/java/rx/internal/operators/OnSubscribeRedo.java
index 6420e66451..d30ddc1343 100644
--- a/src/main/java/rx/internal/operators/OnSubscribeRedo.java
+++ b/src/main/java/rx/internal/operators/OnSubscribeRedo.java
@@ -67,7 +67,7 @@
     };
 
     public static final class RedoFinite implements Func1<Observable<? extends Notification<?>>, Observable<?>> {
-        private final long count;
+        final long count;
 
         public RedoFinite(long count) {
             this.count = count;
@@ -98,7 +98,7 @@ public RedoFinite(long count) {
     }
 
     public static final class RetryWithPredicate implements Func1<Observable<? extends Notification<?>>, Observable<? extends Notification<?>>> {
-        private final Func2<Integer, Throwable, Boolean> predicate;
+        final Func2<Integer, Throwable, Boolean> predicate;
 
         public RetryWithPredicate(Func2<Integer, Throwable, Boolean> predicate) {
             this.predicate = predicate;
@@ -173,10 +173,10 @@ public RetryWithPredicate(Func2<Integer, Throwable, Boolean> predicate) {
         return create(new OnSubscribeRedo<T>(source, notificationHandler, false, false, scheduler));
     }
 
-    private final Observable<T> source;
+    final Observable<T> source;
     private final Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> controlHandlerFunction;
-    private final boolean stopOnComplete;
-    private final boolean stopOnError;
+    final boolean stopOnComplete;
+    final boolean stopOnError;
     private final Scheduler scheduler;
 
     private OnSubscribeRedo(Observable<T> source, Func1<? super Observable<? extends Notification<?>>, ? extends Observable<?>> f, boolean stopOnComplete, boolean stopOnError,
diff --git a/src/main/java/rx/internal/operators/OnSubscribeRefCount.java b/src/main/java/rx/internal/operators/OnSubscribeRefCount.java
index cc422453f2..82ec0e6c38 100644
--- a/src/main/java/rx/internal/operators/OnSubscribeRefCount.java
+++ b/src/main/java/rx/internal/operators/OnSubscribeRefCount.java
@@ -38,13 +38,13 @@
 public final class OnSubscribeRefCount<T> implements OnSubscribe<T> {
 
     private final ConnectableObservable<? extends T> source;
-    private volatile CompositeSubscription baseSubscription = new CompositeSubscription();
-    private final AtomicInteger subscriptionCount = new AtomicInteger(0);
+    volatile CompositeSubscription baseSubscription = new CompositeSubscription();
+    final AtomicInteger subscriptionCount = new AtomicInteger(0);
 
     /**
      * Use this lock for every subscription and disconnect action.
      */
-    private final ReentrantLock lock = new ReentrantLock();
+    final ReentrantLock lock = new ReentrantLock();
 
     /**
      * Constructor.
diff --git a/src/main/java/rx/internal/operators/OnSubscribeToObservableFuture.java b/src/main/java/rx/internal/operators/OnSubscribeToObservableFuture.java
index 72adcf5d50..0f6e2e3f76 100644
--- a/src/main/java/rx/internal/operators/OnSubscribeToObservableFuture.java
+++ b/src/main/java/rx/internal/operators/OnSubscribeToObservableFuture.java
@@ -41,7 +41,7 @@ private OnSubscribeToObservableFuture() {
     }
 
     /* package accessible for unit tests */static class ToObservableFuture<T> implements OnSubscribe<T> {
-        private final Future<? extends T> that;
+        final Future<? extends T> that;
         private final long time;
         private final TimeUnit unit;
 
diff --git a/src/main/java/rx/internal/operators/OnSubscribeUsing.java b/src/main/java/rx/internal/operators/OnSubscribeUsing.java
index 4355e78221..4dd483b4cc 100644
--- a/src/main/java/rx/internal/operators/OnSubscribeUsing.java
+++ b/src/main/java/rx/internal/operators/OnSubscribeUsing.java
@@ -105,7 +105,7 @@ private Throwable disposeEagerlyIfRequested(final Action0 disposeOnceOnly) {
         private Action1<? super Resource> dispose;
         private Resource resource;
 
-        private DisposeAction(Action1<? super Resource> dispose, Resource resource) {
+        DisposeAction(Action1<? super Resource> dispose, Resource resource) {
             this.dispose = dispose;
             this.resource = resource;
             lazySet(false); // StoreStore barrier
diff --git a/src/main/java/rx/internal/operators/OperatorAll.java b/src/main/java/rx/internal/operators/OperatorAll.java
index 00845c7334..91160c048e 100644
--- a/src/main/java/rx/internal/operators/OperatorAll.java
+++ b/src/main/java/rx/internal/operators/OperatorAll.java
@@ -28,7 +28,7 @@
  * <img width="640" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/all.png" alt="">
  */
 public final class OperatorAll<T> implements Operator<Boolean, T> {
-    private final Func1<? super T, Boolean> predicate;
+    final Func1<? super T, Boolean> predicate;
 
     public OperatorAll(Func1<? super T, Boolean> predicate) {
         this.predicate = predicate;
diff --git a/src/main/java/rx/internal/operators/OperatorAny.java b/src/main/java/rx/internal/operators/OperatorAny.java
index ac84ec961f..50934a6513 100644
--- a/src/main/java/rx/internal/operators/OperatorAny.java
+++ b/src/main/java/rx/internal/operators/OperatorAny.java
@@ -27,8 +27,8 @@
  * an observable sequence satisfies a condition, otherwise <code>false</code>.
  */
 public final class OperatorAny<T> implements Operator<Boolean, T> {
-    private final Func1<? super T, Boolean> predicate;
-    private final boolean returnOnEmpty;
+    final Func1<? super T, Boolean> predicate;
+    final boolean returnOnEmpty;
 
     public OperatorAny(Func1<? super T, Boolean> predicate, boolean returnOnEmpty) {
         this.predicate = predicate;
diff --git a/src/main/java/rx/internal/operators/OperatorAsObservable.java b/src/main/java/rx/internal/operators/OperatorAsObservable.java
index 41f2cb3ebc..8efa3e8f6f 100644
--- a/src/main/java/rx/internal/operators/OperatorAsObservable.java
+++ b/src/main/java/rx/internal/operators/OperatorAsObservable.java
@@ -37,7 +37,7 @@
     public static <T> OperatorAsObservable<T> instance() {
         return (OperatorAsObservable<T>)Holder.INSTANCE;
     }
-    private OperatorAsObservable() { }
+    OperatorAsObservable() { }
     @Override
     public Subscriber<? super T> call(Subscriber<? super T> s) {
         return s;
diff --git a/src/main/java/rx/internal/operators/OperatorCast.java b/src/main/java/rx/internal/operators/OperatorCast.java
index 248fcb1970..825847b5ce 100644
--- a/src/main/java/rx/internal/operators/OperatorCast.java
+++ b/src/main/java/rx/internal/operators/OperatorCast.java
@@ -24,7 +24,7 @@
  */
 public class OperatorCast<T, R> implements Operator<R, T> {
 
-    private final Class<R> castClass;
+    final Class<R> castClass;
 
     public OperatorCast(Class<R> castClass) {
         this.castClass = castClass;
diff --git a/src/main/java/rx/internal/operators/OperatorConcat.java b/src/main/java/rx/internal/operators/OperatorConcat.java
index c3ab903658..8455cc55b3 100644
--- a/src/main/java/rx/internal/operators/OperatorConcat.java
+++ b/src/main/java/rx/internal/operators/OperatorConcat.java
@@ -50,7 +50,7 @@
     public static <T> OperatorConcat<T> instance() {
         return (OperatorConcat<T>)Holder.INSTANCE;
     }
-    private OperatorConcat() { }
+    OperatorConcat() { }
     @Override
     public Subscriber<? super Observable<? extends T>> call(final Subscriber<? super T> child) {
         final SerializedSubscriber<T> s = new SerializedSubscriber<T>(child);
diff --git a/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java b/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java
index df7c451287..f98639aff3 100644
--- a/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java
+++ b/src/main/java/rx/internal/operators/OperatorDebounceWithTime.java
@@ -163,7 +163,7 @@ public void emitAndComplete(Subscriber<T> onNextAndComplete, Subscriber<?> onErr
                 emitting = true;
             }
 
-            if  (localHasValue) {
+            if (localHasValue) {
                 try {
                     onNextAndComplete.onNext(localValue);
                 } catch (Throwable e) {
diff --git a/src/main/java/rx/internal/operators/OperatorDematerialize.java b/src/main/java/rx/internal/operators/OperatorDematerialize.java
index d9a154d795..5fd8d7fdfa 100644
--- a/src/main/java/rx/internal/operators/OperatorDematerialize.java
+++ b/src/main/java/rx/internal/operators/OperatorDematerialize.java
@@ -42,7 +42,7 @@
     public static OperatorDematerialize instance() {
         return Holder.INSTANCE; // using raw types because the type inference is not good enough
     }
-    private OperatorDematerialize() { }
+    OperatorDematerialize() { }
     @Override
     public Subscriber<? super Notification<T>> call(final Subscriber<? super T> child) {
         return new Subscriber<Notification<T>>(child) {
diff --git a/src/main/java/rx/internal/operators/OperatorFinally.java b/src/main/java/rx/internal/operators/OperatorDoAfterTerminate.java
similarity index 88%
rename from src/main/java/rx/internal/operators/OperatorFinally.java
rename to src/main/java/rx/internal/operators/OperatorDoAfterTerminate.java
index 64ee03d4a4..a56d28795c 100644
--- a/src/main/java/rx/internal/operators/OperatorFinally.java
+++ b/src/main/java/rx/internal/operators/OperatorDoAfterTerminate.java
@@ -29,10 +29,13 @@
  * 
  * @param <T> the value type
  */
-public final class OperatorFinally<T> implements Operator<T, T> {
+public final class OperatorDoAfterTerminate<T> implements Operator<T, T> {
     final Action0 action;
 
-    public OperatorFinally(Action0 action) {
+    public OperatorDoAfterTerminate(Action0 action) {
+        if (action == null) {
+            throw new NullPointerException("Action can not be null");
+        }
         this.action = action;
     }
 
diff --git a/src/main/java/rx/internal/operators/OperatorDoOnEach.java b/src/main/java/rx/internal/operators/OperatorDoOnEach.java
index 1e3a680dac..3e274b17c4 100644
--- a/src/main/java/rx/internal/operators/OperatorDoOnEach.java
+++ b/src/main/java/rx/internal/operators/OperatorDoOnEach.java
@@ -25,7 +25,7 @@
  * Converts the elements of an observable sequence to the specified type.
  */
 public class OperatorDoOnEach<T> implements Operator<T, T> {
-    private final Observer<? super T> doOnEachObserver;
+    final Observer<? super T> doOnEachObserver;
 
     public OperatorDoOnEach(Observer<? super T> doOnEachObserver) {
         this.doOnEachObserver = doOnEachObserver;
diff --git a/src/main/java/rx/internal/operators/OperatorDoOnRequest.java b/src/main/java/rx/internal/operators/OperatorDoOnRequest.java
index 2c77a584ca..d68c3497aa 100644
--- a/src/main/java/rx/internal/operators/OperatorDoOnRequest.java
+++ b/src/main/java/rx/internal/operators/OperatorDoOnRequest.java
@@ -28,7 +28,7 @@
  */
 public class OperatorDoOnRequest<T> implements Operator<T, T> {
 
-    private final Action1<Long> request;
+    final Action1<Long> request;
 
     public OperatorDoOnRequest(Action1<Long> request) {
         this.request = request;
@@ -55,7 +55,7 @@ public void request(long n) {
     private static final class ParentSubscriber<T> extends Subscriber<T> {
         private final Subscriber<? super T> child;
 
-        private ParentSubscriber(Subscriber<? super T> child) {
+        ParentSubscriber(Subscriber<? super T> child) {
             this.child = child;
         }
 
diff --git a/src/main/java/rx/internal/operators/OperatorElementAt.java b/src/main/java/rx/internal/operators/OperatorElementAt.java
index 19a156dfa2..516e73f282 100644
--- a/src/main/java/rx/internal/operators/OperatorElementAt.java
+++ b/src/main/java/rx/internal/operators/OperatorElementAt.java
@@ -26,9 +26,9 @@
  */
 public final class OperatorElementAt<T> implements Operator<T, T> {
 
-    private final int index;
-    private final boolean hasDefault;
-    private final T defaultValue;
+    final int index;
+    final boolean hasDefault;
+    final T defaultValue;
 
     public OperatorElementAt(int index) {
         this(index, null, false);
diff --git a/src/main/java/rx/internal/operators/OperatorFilter.java b/src/main/java/rx/internal/operators/OperatorFilter.java
index 2dbd827a94..3704dbc4a3 100644
--- a/src/main/java/rx/internal/operators/OperatorFilter.java
+++ b/src/main/java/rx/internal/operators/OperatorFilter.java
@@ -27,7 +27,7 @@
  */
 public final class OperatorFilter<T> implements Operator<T, T> {
 
-    private final Func1<? super T, Boolean> predicate;
+    final Func1<? super T, Boolean> predicate;
 
     public OperatorFilter(Func1<? super T, Boolean> predicate) {
         this.predicate = predicate;
diff --git a/src/main/java/rx/internal/operators/OperatorGroupBy.java b/src/main/java/rx/internal/operators/OperatorGroupBy.java
index 02efb20f3f..38edc0a68f 100644
--- a/src/main/java/rx/internal/operators/OperatorGroupBy.java
+++ b/src/main/java/rx/internal/operators/OperatorGroupBy.java
@@ -15,25 +15,17 @@
  */
 package rx.internal.operators;
 
-import java.util.Queue;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicLongFieldUpdater;
-
-import rx.Observable;
-import rx.Observable.OnSubscribe;
-import rx.Observable.Operator;
-import rx.exceptions.*;
-import rx.Observer;
-import rx.Producer;
-import rx.Subscriber;
-import rx.functions.Action0;
-import rx.functions.Func1;
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+
+import rx.*;
+import rx.Observable.*;
+import rx.functions.*;
+import rx.internal.producers.ProducerArbiter;
+import rx.internal.util.*;
 import rx.observables.GroupedObservable;
-import rx.subjects.Subject;
+import rx.plugins.RxJavaPlugins;
 import rx.subscriptions.Subscriptions;
 
 /**
@@ -49,381 +41,523 @@
  * @param <R>
  *            the value type of the groups
  */
-public class OperatorGroupBy<T, K, R> implements Operator<GroupedObservable<K, R>, T> {
+public final class OperatorGroupBy<T, K, V> implements Operator<GroupedObservable<K, V>, T>{
     final Func1<? super T, ? extends K> keySelector;
-    final Func1<? super T, ? extends R> valueSelector;
+    final Func1<? super T, ? extends V> valueSelector;
+    final int bufferSize;
+    final boolean delayError;
+    
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    public OperatorGroupBy(Func1<? super T, ? extends K> keySelector) {
+        this(keySelector, (Func1)UtilityFunctions.<T>identity(), RxRingBuffer.SIZE, false);
+    }
 
-    @SuppressWarnings("unchecked")
-    public OperatorGroupBy(final Func1<? super T, ? extends K> keySelector) {
-        this(keySelector, (Func1<T, R>) IDENTITY);
+    public OperatorGroupBy(Func1<? super T, ? extends K> keySelector, Func1<? super T, ? extends V> valueSelector) {
+        this(keySelector, valueSelector, RxRingBuffer.SIZE, false);
     }
 
-    public OperatorGroupBy(
-            Func1<? super T, ? extends K> keySelector,
-            Func1<? super T, ? extends R> valueSelector) {
+    public OperatorGroupBy(Func1<? super T, ? extends K> keySelector, Func1<? super T, ? extends V> valueSelector, int bufferSize, boolean delayError) {
         this.keySelector = keySelector;
         this.valueSelector = valueSelector;
+        this.bufferSize = bufferSize;
+        this.delayError = delayError;
     }
-
+    
     @Override
-    public Subscriber<? super T> call(final Subscriber<? super GroupedObservable<K, R>> child) {
-        return new GroupBySubscriber<K, T, R>(keySelector, valueSelector, child);
-    }
-
-    static final class GroupBySubscriber<K, T, R> extends Subscriber<T> {
-        private static final int MAX_QUEUE_SIZE = 1024;
-        final GroupBySubscriber<K, T, R> self = this;
-        final Func1<? super T, ? extends K> keySelector;
-        final Func1<? super T, ? extends R> elementSelector;
-        final Subscriber<? super GroupedObservable<K, R>> child;
+    public Subscriber<? super T> call(Subscriber<? super GroupedObservable<K, V>> t) {
+        final GroupBySubscriber<T, K, V> parent = new GroupBySubscriber<T, K, V>(t, keySelector, valueSelector, bufferSize, delayError);
 
-        // We should not call `unsubscribe()` until `groups.isEmpty() && child.isUnsubscribed()` is true.
-        // Use `WIP_FOR_UNSUBSCRIBE_UPDATER` to monitor these statuses and call `unsubscribe()` properly.
-        // Should check both when `child.unsubscribe` is called and any group is removed.
-        @SuppressWarnings("rawtypes")
-        static final AtomicIntegerFieldUpdater<GroupBySubscriber> WIP_FOR_UNSUBSCRIBE_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "wipForUnsubscribe");
-        volatile int wipForUnsubscribe = 1;
-
-        public GroupBySubscriber(
-                Func1<? super T, ? extends K> keySelector,
-                Func1<? super T, ? extends R> elementSelector,
-                Subscriber<? super GroupedObservable<K, R>> child) {
-            super();
-            this.keySelector = keySelector;
-            this.elementSelector = elementSelector;
-            this.child = child;
-            child.add(Subscriptions.create(new Action0() {
-
-                @Override
-                public void call() {
-                    if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(self) == 0) {
-                        self.unsubscribe();
-                    }
-                }
-
-            }));
-        }
-
-        private static class GroupState<K, T> {
-            private final Subject<T, T> s = BufferUntilSubscriber.create();
-            private final AtomicLong requested = new AtomicLong();
-            private final AtomicLong count = new AtomicLong();
-            private final Queue<Object> buffer = new ConcurrentLinkedQueue<Object>(); // TODO should this be lazily created?
-
-            public Observable<T> getObservable() {
-                return s;
+        t.add(Subscriptions.create(new Action0() {
+            @Override
+            public void call() {
+                parent.cancel();
             }
+        }));
 
-            public Observer<T> getObserver() {
-                return s;
-            }
+        t.setProducer(parent.producer);
+        
+        return parent;
+    }
 
+    public static final class GroupByProducer implements Producer {
+        final GroupBySubscriber<?, ?, ?> parent;
+        
+        public GroupByProducer(GroupBySubscriber<?, ?, ?> parent) {
+            this.parent = parent;
         }
-
-        private final ConcurrentHashMap<Object, GroupState<K, T>> groups = new ConcurrentHashMap<Object, GroupState<K, T>>();
-
-        private static final NotificationLite<Object> nl = NotificationLite.instance();
-
-        volatile int completionEmitted;
-
-        private static final int UNTERMINATED = 0;
-        private static final int TERMINATED_WITH_COMPLETED = 1;
-        private static final int TERMINATED_WITH_ERROR = 2;
-
-        // Must be one of `UNTERMINATED`, `TERMINATED_WITH_COMPLETED`, `TERMINATED_WITH_ERROR`
-        volatile int terminated = UNTERMINATED;
-
-        @SuppressWarnings("rawtypes")
-        static final AtomicIntegerFieldUpdater<GroupBySubscriber> COMPLETION_EMITTED_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "completionEmitted");
+        @Override
+        public void request(long n) {
+            parent.requestMore(n);
+        }
+    }
+    
+    public static final class GroupBySubscriber<T, K, V> 
+    extends Subscriber<T> {
+        final Subscriber<? super GroupedObservable<K, V>> actual;
+        final Func1<? super T, ? extends K> keySelector;
+        final Func1<? super T, ? extends V> valueSelector;
+        final int bufferSize;
+        final boolean delayError;
+        final Map<Object, GroupedUnicast<K, V>> groups;
+        final Queue<GroupedObservable<K, V>> queue;
+        final GroupByProducer producer;
+        
+        static final Object NULL_KEY = new Object();
+        
+        final ProducerArbiter s;
+        
+        volatile int cancelled;
         @SuppressWarnings("rawtypes")
-        static final AtomicIntegerFieldUpdater<GroupBySubscriber> TERMINATED_UPDATER = AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "terminated");
+        static final AtomicIntegerFieldUpdater<GroupBySubscriber> CANCELLED =
+                AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "cancelled");
 
         volatile long requested;
         @SuppressWarnings("rawtypes")
-        static final AtomicLongFieldUpdater<GroupBySubscriber> REQUESTED = AtomicLongFieldUpdater.newUpdater(GroupBySubscriber.class, "requested");
-
-        volatile long bufferedCount;
+        static final AtomicLongFieldUpdater<GroupBySubscriber> REQUESTED =
+                AtomicLongFieldUpdater.newUpdater(GroupBySubscriber.class, "requested");
+        
+        volatile int groupCount;
         @SuppressWarnings("rawtypes")
-        static final AtomicLongFieldUpdater<GroupBySubscriber> BUFFERED_COUNT = AtomicLongFieldUpdater.newUpdater(GroupBySubscriber.class, "bufferedCount");
+        static final AtomicIntegerFieldUpdater<GroupBySubscriber> GROUP_COUNT =
+                AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "groupCount");
+        
+        Throwable error;
+        volatile boolean done;
 
+        volatile int wip;
+        @SuppressWarnings("rawtypes")
+        static final AtomicIntegerFieldUpdater<GroupBySubscriber> WIP =
+                AtomicIntegerFieldUpdater.newUpdater(GroupBySubscriber.class, "wip");
+        
+        public GroupBySubscriber(Subscriber<? super GroupedObservable<K, V>> actual, Func1<? super T, ? extends K> keySelector, Func1<? super T, ? extends V> valueSelector, int bufferSize, boolean delayError) {
+            this.actual = actual;
+            this.keySelector = keySelector;
+            this.valueSelector = valueSelector;
+            this.bufferSize = bufferSize;
+            this.delayError = delayError;
+            this.groups = new ConcurrentHashMap<Object, GroupedUnicast<K, V>>();
+            this.queue = new ConcurrentLinkedQueue<GroupedObservable<K, V>>();
+            GROUP_COUNT.lazySet(this, 1);
+            this.s = new ProducerArbiter();
+            this.s.request(bufferSize);
+            this.producer = new GroupByProducer(this);
+        }
+        
         @Override
-        public void onStart() {
-            REQUESTED.set(this, MAX_QUEUE_SIZE);
-            request(MAX_QUEUE_SIZE);
+        public void setProducer(Producer s) {
+            this.s.setProducer(s);
         }
-
+        
         @Override
-        public void onCompleted() {
-            if (TERMINATED_UPDATER.compareAndSet(this, UNTERMINATED, TERMINATED_WITH_COMPLETED)) {
-                // if we receive onCompleted from our parent we onComplete children
-                // for each group check if it is ready to accept more events if so pass the oncomplete through else buffer it.
-                for (GroupState<K, T> group : groups.values()) {
-                    emitItem(group, nl.completed());
-                }
-
-                // special case (no groups emitted ... or all unsubscribed)
-                if (groups.isEmpty()) {
-                    // we must track 'completionEmitted' seperately from 'completed' since `completeInner` can result in childObserver.onCompleted() being emitted
-                    if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) {
-                        child.onCompleted();
-                    }
-                }
+        public void onNext(T t) {
+            if (done) {
+                return;
             }
-        }
 
-        @Override
-        public void onError(Throwable e) {
-            if (TERMINATED_UPDATER.compareAndSet(this, UNTERMINATED, TERMINATED_WITH_ERROR)) {
-                // It's safe to access all groups and emit the error.
-                // onNext and onError are in sequence so no group will be created in the loop.
-                for (GroupState<K, T> group : groups.values()) {
-                    emitItem(group, nl.error(e));
-                }
-                try {
-                    // we immediately tear everything down if we receive an error
-                    child.onError(e);
-                } finally {
-                    // We have not chained the subscribers, so need to call it explicitly.
-                    unsubscribe();
+            final Queue<GroupedObservable<K, V>> q = this.queue;
+            final Subscriber<? super GroupedObservable<K, V>> a = this.actual;
+
+            K key;
+            try {
+                key = keySelector.call(t);
+            } catch (Throwable ex) {
+                unsubscribe();
+                errorAll(a, q, ex);
+                return;
+            }
+            
+            boolean notNew = true;
+            Object mapKey = key != null ? key : NULL_KEY;
+            GroupedUnicast<K, V> group = groups.get(mapKey);
+            if (group == null) {
+                // if the main has been cancelled, stop creating groups
+                // and skip this value
+                if (cancelled == 0) {
+                    group = GroupedUnicast.createWith(key, bufferSize, this, delayError);
+                    groups.put(mapKey, group);
+                    
+                    GROUP_COUNT.getAndIncrement(this);
+                    
+                    notNew = false;
+                    q.offer(group);
+                    drain();
+                } else {
+                    return;
                 }
             }
-        }
+            
+            V v;
+            try {
+                v = valueSelector.call(t);
+            } catch (Throwable ex) {
+                unsubscribe();
+                errorAll(a, q, ex);
+                return;
+            }
 
-        // The grouped observable propagates the 'producer.request' call from it's subscriber to this method
-        // Here we keep track of the requested count for each group
-        // If we already have items queued when a request comes in we vend those and decrement the outstanding request count
+            group.onNext(v);
 
-        void requestFromGroupedObservable(long n, GroupState<K, T> group) {
-            BackpressureUtils.getAndAddRequest(group.requested, n);
-            if (group.count.getAndIncrement() == 0) {
-                pollQueue(group);
+            if (notNew) {
+                s.request(1);
             }
         }
-
-        private Object groupedKey(K key) {
-            return key == null ? NULL_KEY : key;
+        
+        @Override
+        public void onError(Throwable t) {
+            if (done) {
+                RxJavaPlugins.getInstance().getErrorHandler().handleError(t);
+                return;
+            }
+            error = t;
+            done = true;
+            GROUP_COUNT.decrementAndGet(this);
+            drain();
         }
-
-        @SuppressWarnings("unchecked")
-        private K getKey(Object groupedKey) {
-            return groupedKey == NULL_KEY ? null : (K) groupedKey;
+        
+        @Override
+        public void onCompleted() {
+            if (done) {
+                return;
+            }
+            done = true;
+            GROUP_COUNT.decrementAndGet(this);
+            drain();
         }
 
-        @Override
-        public void onNext(T t) {
-            try {
-                final Object key = groupedKey(keySelector.call(t));
-                GroupState<K, T> group = groups.get(key);
-                if (group == null) {
-                    // this group doesn't exist
-                    if (child.isUnsubscribed()) {
-                        // we have been unsubscribed on the outer so won't send any  more groups
-                        return;
-                    }
-                    group = createNewGroup(key);
+        public void requestMore(long n) {
+            if (n < 0) {
+                throw new IllegalArgumentException("n >= 0 required but it was " + n);
+            }
+            
+            BackpressureUtils.getAndAddRequest(REQUESTED, this, n);
+            drain();
+        }
+        
+        public void cancel() {
+            // cancelling the main source means we don't want any more groups
+            // but running groups still require new values
+            if (CANCELLED.compareAndSet(this, 0, 1)) {
+                if (GROUP_COUNT.decrementAndGet(this) == 0) {
+                    unsubscribe();
                 }
-                if (group != null) {
-                    emitItem(group, nl.next(t));
+            }
+        }
+        
+        public void cancel(K key) {
+            Object mapKey = key != null ? key : NULL_KEY;
+            if (groups.remove(mapKey) != null) {
+                if (GROUP_COUNT.decrementAndGet(this) == 0) {
+                    unsubscribe();
                 }
-            } catch (Throwable e) {
-                Exceptions.throwOrReport(e, this, t);
             }
         }
-
-        private GroupState<K, T> createNewGroup(final Object key) {
-            final GroupState<K, T> groupState = new GroupState<K, T>();
-
-            GroupedObservable<K, R> go = GroupedObservable.create(getKey(key), new OnSubscribe<R>() {
-
-                @Override
-                public void call(final Subscriber<? super R> o) {
-                    o.setProducer(new Producer() {
-
-                        @Override
-                        public void request(long n) {
-                            requestFromGroupedObservable(n, groupState);
-                        }
-
-                    });
-
-                    final AtomicBoolean once = new AtomicBoolean();
-
-                    groupState.getObservable().doOnUnsubscribe(new Action0() {
-
-                        @Override
-                        public void call() {
-                            if (once.compareAndSet(false, true)) {
-                                // done once per instance, either onComplete or onUnSubscribe
-                                cleanupGroup(key);
-                            }
-                        }
-
-                    }).unsafeSubscribe(new Subscriber<T>(o) {
-                        @Override
-                        public void onCompleted() {
-                            o.onCompleted();
-                            // eagerly cleanup instead of waiting for unsubscribe
-                            if (once.compareAndSet(false, true)) {
-                                // done once per instance, either onComplete or onUnSubscribe
-                                cleanupGroup(key);
-                            }
-                        }
-
-                        @Override
-                        public void onError(Throwable e) {
-                            o.onError(e);
-                            // eagerly cleanup instead of waiting for unsubscribe
-                            if (once.compareAndSet(false, true)) {
-                                // done once per instance, either onComplete or onUnSubscribe
-                                cleanupGroup(key);
-                            }
-                        }
-
-                        @Override
-                        public void onNext(T t) {
-                            try {
-                                o.onNext(elementSelector.call(t));
-                            } catch (Throwable e) {
-                                Exceptions.throwOrReport(e, this, t);
-                            }
-                        }
-                    });
+        
+        void drain() {
+            if (WIP.getAndIncrement(this) != 0) {
+                return;
+            }
+            
+            int missed = 1;
+            
+            final Queue<GroupedObservable<K, V>> q = this.queue;
+            final Subscriber<? super GroupedObservable<K, V>> a = this.actual;
+            
+            for (;;) {
+                
+                if (checkTerminated(done, q.isEmpty(), a, q)) {
+                    return;
                 }
-            });
+                
+                long r = requested;
+                boolean unbounded = r == Long.MAX_VALUE;
+                long e = 0L;
+                
+                while (r != 0) {
+                    boolean d = done;
+                    
+                    GroupedObservable<K, V> t = q.poll();
+                    
+                    boolean empty = t == null;
+                    
+                    if (checkTerminated(d, empty, a, q)) {
+                        return;
+                    }
+                    
+                    if (empty) {
+                        break;
+                    }
 
-            GroupState<K, T> putIfAbsent;
-            for (;;) {
-                int wip = wipForUnsubscribe;
-                if (wip <= 0) {
-                    return null;
+                    a.onNext(t);
+                    
+                    r--;
+                    e--;
+                }
+                
+                if (e != 0L) {
+                    if (!unbounded) {
+                        REQUESTED.addAndGet(this, e);
+                    }
+                    s.request(-e);
                 }
-                if (WIP_FOR_UNSUBSCRIBE_UPDATER.compareAndSet(this, wip, wip + 1)) {
-                    putIfAbsent = groups.putIfAbsent(key, groupState);
+                
+                missed = WIP.addAndGet(this, -missed);
+                if (missed == 0) {
                     break;
                 }
             }
-            if (putIfAbsent != null) {
-                // this shouldn't happen (because we receive onNext sequentially) and would mean we have a bug
-                throw new IllegalStateException("Group already existed while creating a new one");
+        }
+        
+        void errorAll(Subscriber<? super GroupedObservable<K, V>> a, Queue<?> q, Throwable ex) {
+            q.clear();
+            List<GroupedUnicast<K, V>> list = new ArrayList<GroupedUnicast<K, V>>(groups.values());
+            groups.clear();
+            
+            for (GroupedUnicast<K, V> e : list) {
+                e.onError(ex);
             }
-            child.onNext(go);
-
-            return groupState;
+            
+            a.onError(ex);
         }
-
-        private void cleanupGroup(Object key) {
-            GroupState<K, T> removed;
-            removed = groups.remove(key);
-            if (removed != null) {
-                if (!removed.buffer.isEmpty()) {
-                    BUFFERED_COUNT.addAndGet(self, -removed.buffer.size());
+        
+        boolean checkTerminated(boolean d, boolean empty, 
+                Subscriber<? super GroupedObservable<K, V>> a, Queue<?> q) {
+            if (d) {
+                Throwable err = error;
+                if (err != null) {
+                    errorAll(a, q, err);
+                    return true;
+                } else
+                if (empty) {
+                    List<GroupedUnicast<K, V>> list = new ArrayList<GroupedUnicast<K, V>>(groups.values());
+                    groups.clear();
+                    
+                    for (GroupedUnicast<K, V> e : list) {
+                        e.onComplete();
+                    }
+                    
+                    actual.onCompleted();
+                    return true;
                 }
-                completeInner();
-                // since we may have unsubscribed early with items in the buffer 
-                // we remove those above and have freed up room to request more
-                // so give it a chance to request more now
-                requestMoreIfNecessary();
             }
+            return false;
         }
+    }
+    
+    static final class GroupedUnicast<K, T> extends GroupedObservable<K, T> {
+        
+        public static <T, K> GroupedUnicast<K, T> createWith(K key, int bufferSize, GroupBySubscriber<?, K, T> parent, boolean delayError) {
+            State<T, K> state = new State<T, K>(bufferSize, parent, key, delayError);
+            return new GroupedUnicast<K, T>(key, state);
+        }
+        
+        final State<T, K> state;
+        
+        protected GroupedUnicast(K key, State<T, K> state) {
+            super(key, state);
+            this.state = state;
+        }
+        
+        public void onNext(T t) {
+            state.onNext(t);
+        }
+        
+        public void onError(Throwable e) {
+            state.onError(e);
+        }
+        
+        public void onComplete() {
+            state.onComplete();
+        }
+    }
+    
+    static final class State<T, K> extends AtomicInteger implements Producer, Subscription, OnSubscribe<T> {
+        /** */
+        private static final long serialVersionUID = -3852313036005250360L;
+
+        final K key;
+        final Queue<Object> queue;
+        final GroupBySubscriber<?, K, T> parent;
+        final boolean delayError;
+        
+        volatile long requested;
+        @SuppressWarnings("rawtypes")
+        static final AtomicLongFieldUpdater<State> REQUESTED =
+                AtomicLongFieldUpdater.newUpdater(State.class, "requested");
+        
+        volatile boolean done;
+        Throwable error;
+        
+        volatile int cancelled;
+        @SuppressWarnings("rawtypes")
+        static final AtomicIntegerFieldUpdater<State> CANCELLED =
+                AtomicIntegerFieldUpdater.newUpdater(State.class, "cancelled");
+        
+        volatile Subscriber<? super T> actual;
+        @SuppressWarnings("rawtypes")
+        static final AtomicReferenceFieldUpdater<State, Subscriber> ACTUAL =
+                AtomicReferenceFieldUpdater.newUpdater(State.class, Subscriber.class, "actual");
 
-        private void emitItem(GroupState<K, T> groupState, Object item) {
-            Queue<Object> q = groupState.buffer;
-            AtomicLong keyRequested = groupState.requested;
-            //don't need to check for requested being Long.MAX_VALUE because this
-            //field is capped at MAX_QUEUE_SIZE
-            REQUESTED.decrementAndGet(this);
-            // short circuit buffering
-            if (keyRequested != null && keyRequested.get() > 0 && (q == null || q.isEmpty())) {
-                @SuppressWarnings("unchecked")
-                Observer<Object> obs = (Observer<Object>)groupState.getObserver();
-                nl.accept(obs, item);
-                if (keyRequested.get() != Long.MAX_VALUE) {
-                    // best endeavours check (no CAS loop here) because we mainly care about 
-                    // the initial request being Long.MAX_VALUE and that value being conserved.
-                    keyRequested.decrementAndGet();
-                }
-            } else {
-                q.add(item);
-                BUFFERED_COUNT.incrementAndGet(this);
-
-                if (groupState.count.getAndIncrement() == 0) {
-                    pollQueue(groupState);
-                }
+        volatile int once;
+        @SuppressWarnings("rawtypes")
+        static final AtomicIntegerFieldUpdater<State> ONCE =
+                AtomicIntegerFieldUpdater.newUpdater(State.class, "once");
+
+        
+        public State(int bufferSize, GroupBySubscriber<?, K, T> parent, K key, boolean delayError) {
+            this.queue = new ConcurrentLinkedQueue<Object>();
+            this.parent = parent;
+            this.key = key;
+            this.delayError = delayError;
+        }
+        
+        @Override
+        public void request(long n) {
+            if (n < 0) {
+                throw new IllegalArgumentException("n >= required but it was " + n);
+            }
+            if (n != 0L) {
+                BackpressureUtils.getAndAddRequest(REQUESTED, this, n);
+                drain();
             }
-            requestMoreIfNecessary();
         }
-
-        private void pollQueue(GroupState<K, T> groupState) {
-            do {
-                drainIfPossible(groupState);
-                long c = groupState.count.decrementAndGet();
-                if (c > 1) {
-
-                    /*
-                     * Set down to 1 and then iterate again.
-                     * we lower it to 1 otherwise it could have grown very large while in the last poll loop
-                     * and then we can end up looping all those times again here before existing even once we've drained
-                     */
-                    groupState.count.set(1);
-                    // we now loop again, and if anything tries scheduling again after this it will increment and cause us to loop again after
+        
+        @Override
+        public boolean isUnsubscribed() {
+            return cancelled != 0;
+        }
+        
+        @Override
+        public void unsubscribe() {
+            if (CANCELLED.compareAndSet(this, 0, 1)) {
+                if (getAndIncrement() == 0) {
+                    parent.cancel(key);
                 }
-            } while (groupState.count.get() > 0);
+            }
+        }
+        
+        @Override
+        public void call(Subscriber<? super T> s) {
+            if (ONCE.compareAndSet(this, 0, 1)) {
+                s.add(this);
+                s.setProducer(this);
+                ACTUAL.lazySet(this, s);
+                drain();
+            } else {
+                s.onError(new IllegalStateException("Only one Subscriber allowed!"));
+            }
         }
 
-        private void requestMoreIfNecessary() {
-            if (REQUESTED.get(this) == 0 && terminated == 0) {
-                long toRequest = MAX_QUEUE_SIZE - BUFFERED_COUNT.get(this);
-                if (toRequest > 0 && REQUESTED.compareAndSet(this, 0, toRequest)) {
-                    request(toRequest);
-                }
+        public void onNext(T t) {
+            if (t == null) {
+                error = new NullPointerException();
+                done = true;
+            } else {
+                queue.offer(NotificationLite.instance().next(t));
             }
+            drain();
+        }
+        
+        public void onError(Throwable e) {
+            error = e;
+            done = true;
+            drain();
+        }
+        
+        public void onComplete() {
+            done = true;
+            drain();
         }
 
-        private void drainIfPossible(GroupState<K, T> groupState) {
-            while (groupState.requested.get() > 0) {
-                Object t = groupState.buffer.poll();
-                if (t != null) {
-                    @SuppressWarnings("unchecked")
-                    Observer<Object> obs = (Observer<Object>)groupState.getObserver();
-                    nl.accept(obs, t);
-                    if (groupState.requested.get()!=Long.MAX_VALUE) {
-                        // best endeavours check (no CAS loop here) because we mainly care about 
-                        // the initial request being Long.MAX_VALUE and that value being conserved.
-                        groupState.requested.decrementAndGet();
+        void drain() {
+            if (getAndIncrement() != 0) {
+                return;
+            }
+            int missed = 1;
+            
+            final Queue<Object> q = queue;
+            final boolean delayError = this.delayError;
+            Subscriber<? super T> a = actual;
+            NotificationLite<T> nl = NotificationLite.instance();
+            for (;;) {
+                if (a != null) {
+                    if (checkTerminated(done, q.isEmpty(), a, delayError)) {
+                        return;
                     }
-                    BUFFERED_COUNT.decrementAndGet(this);
-
-                    // if we have used up all the events we requested from upstream then figure out what to ask for this time based on the empty space in the buffer
-                    requestMoreIfNecessary();
-                } else {
-                    // queue is empty break
+                    
+                    long r = requested;
+                    boolean unbounded = r == Long.MAX_VALUE;
+                    long e = 0;
+                    
+                    while (r != 0L) {
+                        boolean d = done;
+                        Object v = q.poll();
+                        boolean empty = v == null;
+                        
+                        if (checkTerminated(d, empty, a, delayError)) {
+                            return;
+                        }
+                        
+                        if (empty) {
+                            break;
+                        }
+                        
+                        a.onNext(nl.getValue(v));
+                        
+                        r--;
+                        e--;
+                    }
+                    
+                    if (e != 0L) {
+                        if (!unbounded) {
+                            REQUESTED.addAndGet(this, e);
+                        }
+                        parent.s.request(-e);
+                    }
+                }
+                
+                missed = addAndGet(-missed);
+                if (missed == 0) {
                     break;
                 }
+                if (a == null) {
+                    a = actual;
+                }
             }
         }
-
-        private void completeInner() {
-            // A group is removed, so check if we need to call `unsubscribe`
-            if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) {
-                // It means `groups.isEmpty() && child.isUnsubscribed()` is true
-                unsubscribe();
-            } else if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) {
-                // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer
-                // completionEmitted ensures we only emit onCompleted once
-                if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) {
-                    child.onCompleted();
+        
+        boolean checkTerminated(boolean d, boolean empty, Subscriber<? super T> a, boolean delayError) {
+            if (cancelled != 0) {
+                queue.clear();
+                parent.cancel(key);
+                return true;
+            }
+            
+            if (d) {
+                if (delayError) {
+                    if (empty) {
+                        Throwable e = error;
+                        if (e != null) {
+                            a.onError(e);
+                        } else {
+                            a.onCompleted();
+                        }
+                        return true;
+                    }
+                } else {
+                    Throwable e = error;
+                    if (e != null) {
+                        queue.clear();
+                        a.onError(e);
+                        return true;
+                    } else
+                    if (empty) {
+                        a.onCompleted();
+                        return true;
+                    }
                 }
             }
+            
+            return false;
         }
-
     }
-
-    private final static Func1<Object, Object> IDENTITY = new Func1<Object, Object>() {
-        @Override
-        public Object call(Object t) {
-            return t;
-        }
-    };
-
-    private static final Object NULL_KEY = new Object();
 }
diff --git a/src/main/java/rx/internal/operators/OperatorIgnoreElements.java b/src/main/java/rx/internal/operators/OperatorIgnoreElements.java
index 3f38d8e585..00098f85a2 100644
--- a/src/main/java/rx/internal/operators/OperatorIgnoreElements.java
+++ b/src/main/java/rx/internal/operators/OperatorIgnoreElements.java
@@ -29,7 +29,7 @@
         return (OperatorIgnoreElements<T>) Holder.INSTANCE;
     }
 
-    private OperatorIgnoreElements() {
+    OperatorIgnoreElements() {
 
     }
 
diff --git a/src/main/java/rx/internal/operators/OperatorMap.java b/src/main/java/rx/internal/operators/OperatorMap.java
index 5816887479..90925c2764 100644
--- a/src/main/java/rx/internal/operators/OperatorMap.java
+++ b/src/main/java/rx/internal/operators/OperatorMap.java
@@ -28,7 +28,7 @@
  */
 public final class OperatorMap<T, R> implements Operator<R, T> {
 
-    private final Func1<? super T, ? extends R> transformer;
+    final Func1<? super T, ? extends R> transformer;
 
     public OperatorMap(Func1<? super T, ? extends R> transformer) {
         this.transformer = transformer;
diff --git a/src/main/java/rx/internal/operators/OperatorMapNotification.java b/src/main/java/rx/internal/operators/OperatorMapNotification.java
index a0c0994032..8abe7b828e 100644
--- a/src/main/java/rx/internal/operators/OperatorMapNotification.java
+++ b/src/main/java/rx/internal/operators/OperatorMapNotification.java
@@ -34,9 +34,9 @@
  */
 public final class OperatorMapNotification<T, R> implements Operator<R, T> {
 
-    private final Func1<? super T, ? extends R> onNext;
-    private final Func1<? super Throwable, ? extends R> onError;
-    private final Func0<? extends R> onCompleted;
+    final Func1<? super T, ? extends R> onNext;
+    final Func1<? super Throwable, ? extends R> onError;
+    final Func0<? extends R> onCompleted;
 
     public OperatorMapNotification(Func1<? super T, ? extends R> onNext, Func1<? super Throwable, ? extends R> onError, Func0<? extends R> onCompleted) {
         this.onNext = onNext;
@@ -58,8 +58,8 @@ public OperatorMapNotification(Func1<? super T, ? extends R> onNext, Func1<? sup
         private final Subscriber<? super R> o;
         private final ProducerArbiter pa;
         final SingleEmitter<R> emitter;
-        
-        private MapNotificationSubscriber(ProducerArbiter pa, Subscriber<? super R> o) {
+
+        MapNotificationSubscriber(ProducerArbiter pa, Subscriber<? super R> o) {
             this.pa = pa;
             this.o = o;
             this.emitter = new SingleEmitter<R>(o, pa, this);
diff --git a/src/main/java/rx/internal/operators/OperatorMaterialize.java b/src/main/java/rx/internal/operators/OperatorMaterialize.java
index 32b49c6c77..4a90f1f43f 100644
--- a/src/main/java/rx/internal/operators/OperatorMaterialize.java
+++ b/src/main/java/rx/internal/operators/OperatorMaterialize.java
@@ -47,7 +47,7 @@
         return (OperatorMaterialize<T>) Holder.INSTANCE;
     }
 
-    private OperatorMaterialize() {
+    OperatorMaterialize() {
     }
 
     @Override
diff --git a/src/main/java/rx/internal/operators/OperatorMerge.java b/src/main/java/rx/internal/operators/OperatorMerge.java
index 3fd96791a0..56a7058d26 100644
--- a/src/main/java/rx/internal/operators/OperatorMerge.java
+++ b/src/main/java/rx/internal/operators/OperatorMerge.java
@@ -90,7 +90,7 @@
     final boolean delayErrors;
     final int maxConcurrent;
 
-    private OperatorMerge(boolean delayErrors, int maxConcurrent) {
+    OperatorMerge(boolean delayErrors, int maxConcurrent) {
         this.delayErrors = delayErrors;
         this.maxConcurrent = maxConcurrent;
     }
diff --git a/src/main/java/rx/internal/operators/OperatorMulticast.java b/src/main/java/rx/internal/operators/OperatorMulticast.java
index 8ec88140c2..fcdededbed 100644
--- a/src/main/java/rx/internal/operators/OperatorMulticast.java
+++ b/src/main/java/rx/internal/operators/OperatorMulticast.java
@@ -46,9 +46,9 @@
     final List<Subscriber<? super R>> waitingForConnect;
 
     /** Guarded by guard. */
-    private Subscriber<T> subscription;
+    Subscriber<T> subscription;
     // wraps subscription above for unsubscription using guard
-    private Subscription guardedSubscription;
+    Subscription guardedSubscription;
 
     public OperatorMulticast(Observable<? extends T> source, final Func0<? extends Subject<? super T, ? extends R>> subjectFactory) {
         this(new Object(), new AtomicReference<Subject<? super T, ? extends R>>(), new ArrayList<Subscriber<? super R>>(), source, subjectFactory);
diff --git a/src/main/java/rx/internal/operators/OperatorOnBackpressureBlock.java b/src/main/java/rx/internal/operators/OperatorOnBackpressureBlock.java
deleted file mode 100644
index 71a5fc4993..0000000000
--- a/src/main/java/rx/internal/operators/OperatorOnBackpressureBlock.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/**
- * Copyright 2014 Netflix, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package rx.internal.operators;
-
-import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.BlockingQueue;
-
-import rx.Observable.Operator;
-import rx.Subscriber;
-import rx.internal.util.BackpressureDrainManager;
-
-/**
- * Operator that blocks the producer thread in case a backpressure is needed.
- */
-public class OperatorOnBackpressureBlock<T> implements Operator<T, T> {
-    final int max;
-    public OperatorOnBackpressureBlock(int max) {
-        this.max = max;
-    }
-    @Override
-    public Subscriber<? super T> call(Subscriber<? super T> child) {
-        BlockingSubscriber<T> s = new BlockingSubscriber<T>(max, child);
-        s.init();
-        return s;
-    }
-    
-    static final class BlockingSubscriber<T> extends Subscriber<T> implements BackpressureDrainManager.BackpressureQueueCallback {
-        final NotificationLite<T> nl = NotificationLite.instance();
-        final BlockingQueue<Object> queue;
-        final Subscriber<? super T> child;
-        final BackpressureDrainManager manager;
-        public BlockingSubscriber(int max, Subscriber<? super T> child) {
-            this.queue = new ArrayBlockingQueue<Object>(max);
-            this.child = child;
-            this.manager = new BackpressureDrainManager(this);
-        }
-        void init() {
-            child.add(this);
-            child.setProducer(manager);
-        }
-        @Override
-        public void onNext(T t) {
-            try {
-                queue.put(nl.next(t));
-                manager.drain();
-            } catch (InterruptedException ex) {
-                if (!isUnsubscribed()) {
-                    onError(ex);
-                }
-            }
-        }
-        @Override
-        public void onError(Throwable e) {
-            manager.terminateAndDrain(e);
-        }
-        @Override
-        public void onCompleted() {
-            manager.terminateAndDrain();
-        }
-        @Override
-        public boolean accept(Object value) {
-            return nl.accept(child, value);
-        }
-        @Override
-        public void complete(Throwable exception) {
-            if (exception != null) {
-                child.onError(exception);
-            } else {
-                child.onCompleted();
-            }
-        }
-        @Override
-        public Object peek() {
-            return queue.peek();
-        }
-        @Override
-        public Object poll() {
-            return queue.poll();
-        }
-    }
-}
diff --git a/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java b/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java
index cb39a53ef7..4aff6fc162 100644
--- a/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java
+++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureBuffer.java
@@ -39,8 +39,8 @@
     public static <T> OperatorOnBackpressureBuffer<T> instance() {
         return (OperatorOnBackpressureBuffer<T>) Holder.INSTANCE;
     }
-    
-    private OperatorOnBackpressureBuffer() {
+
+    OperatorOnBackpressureBuffer() {
         this.capacity = null;
         this.onOverflow = null;
     }
diff --git a/src/main/java/rx/internal/operators/OperatorOnBackpressureDrop.java b/src/main/java/rx/internal/operators/OperatorOnBackpressureDrop.java
index fee6289a4b..a9a8def2d4 100644
--- a/src/main/java/rx/internal/operators/OperatorOnBackpressureDrop.java
+++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureDrop.java
@@ -38,9 +38,9 @@
         return (OperatorOnBackpressureDrop<T>)Holder.INSTANCE;
     }
 
-    private final Action1<? super T> onDrop;
+    final Action1<? super T> onDrop;
 
-    private OperatorOnBackpressureDrop() {
+    OperatorOnBackpressureDrop() {
         this(null);
     }
 
diff --git a/src/main/java/rx/internal/operators/OperatorOnBackpressureLatest.java b/src/main/java/rx/internal/operators/OperatorOnBackpressureLatest.java
index 512010515c..2bf909289e 100644
--- a/src/main/java/rx/internal/operators/OperatorOnBackpressureLatest.java
+++ b/src/main/java/rx/internal/operators/OperatorOnBackpressureLatest.java
@@ -194,7 +194,7 @@ void emit() {
     static final class LatestSubscriber<T> extends Subscriber<T> {
         private final LatestEmitter<T> producer;
 
-        private LatestSubscriber(LatestEmitter<T> producer) {
+        LatestSubscriber(LatestEmitter<T> producer) {
             this.producer = producer;
         }
 
diff --git a/src/main/java/rx/internal/operators/OperatorOnErrorResumeNextViaFunction.java b/src/main/java/rx/internal/operators/OperatorOnErrorResumeNextViaFunction.java
index 5141a0974d..b12c10d391 100644
--- a/src/main/java/rx/internal/operators/OperatorOnErrorResumeNextViaFunction.java
+++ b/src/main/java/rx/internal/operators/OperatorOnErrorResumeNextViaFunction.java
@@ -43,7 +43,7 @@
  */
 public final class OperatorOnErrorResumeNextViaFunction<T> implements Operator<T, T> {
 
-    private final Func1<Throwable, ? extends Observable<? extends T>> resumeFunction;
+    final Func1<Throwable, ? extends Observable<? extends T>> resumeFunction;
 
     public OperatorOnErrorResumeNextViaFunction(Func1<Throwable, ? extends Observable<? extends T>> f) {
         this.resumeFunction = f;
diff --git a/src/main/java/rx/internal/operators/OperatorReplay.java b/src/main/java/rx/internal/operators/OperatorReplay.java
index 93d78ee14b..a76f2f3c0b 100644
--- a/src/main/java/rx/internal/operators/OperatorReplay.java
+++ b/src/main/java/rx/internal/operators/OperatorReplay.java
@@ -221,6 +221,10 @@ public void call(Subscriber<? super T> child) {
                     // the producer has been registered with the current subscriber-to-source so 
                     // at least it will receive the next terminal event
                     child.add(inner);
+                    
+                    // pin the head of the buffer here, shouldn't affect anything else
+                    r.buffer.replay(inner);
+                    
                     // setting the producer will trigger the first request to be considered by 
                     // the subscriber-to-source.
                     child.setProducer(inner);
@@ -858,9 +862,15 @@ public void replay(InnerProducer<T> output) {
     static final class Node extends AtomicReference<Node> {
         /** */
         private static final long serialVersionUID = 245354315435971818L;
+        
+        /** The contained value. */
         final Object value;
-        public Node(Object value) {
+        /** The absolute index of the value. */
+        final long index;
+        
+        public Node(Object value, long index) {
             this.value = value;
+            this.index = index;
         }
     }
     
@@ -878,9 +888,12 @@ public Node(Object value) {
         Node tail;
         int size;
         
+        /** The total number of received values so far. */
+        long index;
+        
         public BoundedReplayBuffer() {
             nl = NotificationLite.instance();
-            Node n = new Node(null);
+            Node n = new Node(null, 0);
             tail = n;
             set(n);
         }
@@ -929,7 +942,7 @@ final void setFirst(Node n) {
         @Override
         public final void next(T value) {
             Object o = enterTransform(nl.next(value));
-            Node n = new Node(o);
+            Node n = new Node(o, ++index);
             addLast(n);
             truncate();
         }
@@ -937,7 +950,7 @@ public final void next(T value) {
         @Override
         public final void error(Throwable e) {
             Object o = enterTransform(nl.error(e));
-            Node n = new Node(o);
+            Node n = new Node(o, ++index);
             addLast(n);
             truncateFinal();
         }
@@ -945,7 +958,7 @@ public final void error(Throwable e) {
         @Override
         public final void complete() {
             Object o = enterTransform(nl.completed());
-            Node n = new Node(o);
+            Node n = new Node(o, ++index);
             addLast(n);
             truncateFinal();
         }
@@ -965,15 +978,25 @@ public final void replay(InnerProducer<T> output) {
                 }
 
                 long r = output.get();
-                long r0 = r;
+                boolean unbounded = r == Long.MAX_VALUE;
                 long e = 0L;
                 
                 Node node = output.index();
                 if (node == null) {
                     node = get();
                     output.index = node;
+                    
+                    /*
+                     * Since this is a latecommer, fix its total requested amount
+                     * as if it got all the values up to the node.index
+                     */
+                    output.addTotalRequested(node.index);
                 }
-                
+
+                if (output.isUnsubscribed()) {
+                    return;
+                }
+
                 while (r != 0) {
                     Node v = node.get();
                     if (v != null) {
@@ -993,6 +1016,7 @@ public final void replay(InnerProducer<T> output) {
                             return;
                         }
                         e++;
+                        r--;
                         node = v;
                     } else {
                         break;
@@ -1004,7 +1028,7 @@ public final void replay(InnerProducer<T> output) {
 
                 if (e != 0L) {
                     output.index = node;
-                    if (r0 != Long.MAX_VALUE) {
+                    if (!unbounded) {
                         output.produced(e);
                     }
                 }
diff --git a/src/main/java/rx/internal/operators/OperatorScan.java b/src/main/java/rx/internal/operators/OperatorScan.java
index 5b132fd767..4ce2e4ce4c 100644
--- a/src/main/java/rx/internal/operators/OperatorScan.java
+++ b/src/main/java/rx/internal/operators/OperatorScan.java
@@ -16,6 +16,7 @@
 package rx.internal.operators;
 
 import java.util.Queue;
+import java.util.concurrent.atomic.AtomicLong;
 
 import rx.*;
 import rx.Observable.Operator;
@@ -43,7 +44,7 @@
 public final class OperatorScan<R, T> implements Operator<R, T> {
 
     private final Func0<R> initialValueFactory;
-    private final Func2<R, ? super T, R> accumulator;
+    final Func2<R, ? super T, R> accumulator;
     // sentinel if we don't receive an initial value
     private static final Object NO_INITIAL_VALUE = new Object();
 
@@ -175,12 +176,10 @@ public void setProducer(final Producer producer) {
         boolean missed;
         /** Missed a request. */
         long missedRequested;
-        /** Missed a producer. */
-        Producer missedProducer;
         /** The current requested amount. */
-        long requested;
+        final AtomicLong requested;
         /** The current producer. */
-        Producer producer;
+        volatile Producer producer;
         
         volatile boolean done;
         Throwable error;
@@ -196,41 +195,7 @@ public InitialProducer(R initialValue, Subscriber<? super R> child) {
             }
             this.queue = q;
             q.offer(NotificationLite.instance().next(initialValue));
-        }
-        
-        @Override
-        public void request(long n) {
-            if (n < 0L) {
-                throw new IllegalArgumentException("n >= required but it was " + n);
-            } else
-            if (n != 0L) {
-                synchronized (this) {
-                    if (emitting) {
-                        long mr = missedRequested;
-                        long mu = mr + n;
-                        if (mu < 0L) {
-                            mu = Long.MAX_VALUE;
-                        }
-                        missedRequested = mu;
-                        return;
-                    }
-                    emitting = true;
-                }
-                
-                long r = requested;
-                long u = r + n;
-                if (u < 0L) {
-                    u = Long.MAX_VALUE;
-                }
-                requested = u;
-                
-                Producer p = producer;
-                if (p != null) {
-                    p.request(n);
-                }
-                
-                emitLoop();
-            }
+            this.requested = new AtomicLong();
         }
         
         @Override
@@ -270,23 +235,51 @@ public void onCompleted() {
             emit();
         }
         
+        @Override
+        public void request(long n) {
+            if (n < 0L) {
+                throw new IllegalArgumentException("n >= required but it was " + n);
+            } else
+            if (n != 0L) {
+                BackpressureUtils.getAndAddRequest(requested, n);
+                Producer p = producer;
+                if (p == null) {
+                    // not synchronizing on this to avoid clash with emit()
+                    synchronized (requested) {
+                        p = producer;
+                        if (p == null) {
+                            long mr = missedRequested;
+                            missedRequested = BackpressureUtils.addCap(mr, n);
+                        }
+                    }
+                }
+                if (p != null) {
+                    p.request(n);
+                }
+                emit();
+            }
+        }
+        
         public void setProducer(Producer p) {
             if (p == null) {
                 throw new NullPointerException();
             }
-            synchronized (this) {
-                if (emitting) {
-                    missedProducer = p;
-                    return;
+            long mr;
+            // not synchronizing on this to avoid clash with emit()
+            synchronized (requested) {
+                if (producer != null) {
+                    throw new IllegalStateException("Can't set more than one Producer!");
                 }
-                emitting = true;
+                // request one less because of the initial value, this happens once
+                mr = missedRequested - 1;
+                missedRequested = 0L;
+                producer = p;
             }
-            producer = p;
-            long r = requested;
-            if (r != 0L) {
-                p.request(r);
+            
+            if (mr > 0L) {
+                p.request(mr);
             }
-            emitLoop();
+            emit();
         }
         
         void emit() {
@@ -304,7 +297,9 @@ void emitLoop() {
             final Subscriber<? super R> child = this.child;
             final Queue<Object> queue = this.queue;
             final NotificationLite<R> nl = NotificationLite.instance();
-            long r = requested;
+            AtomicLong requested = this.requested;
+            
+            long r = requested.get();
             for (;;) {
                 boolean max = r == Long.MAX_VALUE;
                 boolean d = done;
@@ -312,6 +307,7 @@ void emitLoop() {
                 if (checkTerminated(d, empty, child)) {
                     return;
                 }
+                long e = 0L;
                 while (r != 0L) {
                     d = done;
                     Object o = queue.poll();
@@ -325,52 +321,25 @@ void emitLoop() {
                     R v = nl.getValue(o);
                     try {
                         child.onNext(v);
-                    } catch (Throwable e) {
-                        Exceptions.throwIfFatal(e);
-                        child.onError(OnErrorThrowable.addValueAsLastCause(e, v));
+                    } catch (Throwable ex) {
+                        Exceptions.throwIfFatal(ex);
+                        child.onError(OnErrorThrowable.addValueAsLastCause(ex, v));
                         return;
                     }
-                    if (!max) {
-                        r--;
-                    }
+                    r--;
+                    e--;
                 }
-                if (!max) {
-                    requested = r;
+                
+                if (e != 0 && !max) {
+                    r = requested.addAndGet(e);
                 }
                 
-                Producer p;
-                long mr;
                 synchronized (this) {
-                    p = missedProducer;
-                    mr = missedRequested;
-                    if (!missed && p == null && mr == 0L) {
+                    if (!missed) {
                         emitting = false;
                         return;
                     }
                     missed = false;
-                    missedProducer = null;
-                    missedRequested = 0L;
-                }
-                
-                if (mr != 0L && !max) {
-                    long u = r + mr;
-                    if (u < 0L) {
-                        u = Long.MAX_VALUE;
-                    }
-                    requested = u;
-                    r = u;
-                }
-                
-                if (p != null) {
-                    producer = p;
-                    if (r != 0L) {
-                        p.request(r);
-                    }
-                } else {
-                    p = producer;
-                    if (p != null && mr != 0L) {
-                        p.request(mr);
-                    }
                 }
             }
         }
diff --git a/src/main/java/rx/internal/operators/OperatorSequenceEqual.java b/src/main/java/rx/internal/operators/OperatorSequenceEqual.java
index b03855f63a..06a30edcde 100644
--- a/src/main/java/rx/internal/operators/OperatorSequenceEqual.java
+++ b/src/main/java/rx/internal/operators/OperatorSequenceEqual.java
@@ -33,7 +33,7 @@ private OperatorSequenceEqual() {
     }
 
     /** NotificationLite doesn't work as zip uses it. */
-    private static final Object LOCAL_ONCOMPLETED = new Object();
+    static final Object LOCAL_ONCOMPLETED = new Object();
     static <T> Observable<Object> materializeLite(Observable<T> source) {
         return concat(
                 source.map(new Func1<T, Object>() {
diff --git a/src/main/java/rx/internal/operators/OperatorSerialize.java b/src/main/java/rx/internal/operators/OperatorSerialize.java
index 334ddef679..a8d7dd4a47 100644
--- a/src/main/java/rx/internal/operators/OperatorSerialize.java
+++ b/src/main/java/rx/internal/operators/OperatorSerialize.java
@@ -32,7 +32,7 @@
     public static <T> OperatorSerialize<T> instance() {
         return (OperatorSerialize<T>)Holder.INSTANCE;
     }
-    private OperatorSerialize() { }
+    OperatorSerialize() { }
     @Override
     public Subscriber<? super T> call(final Subscriber<? super T> s) {
         return new SerializedSubscriber<T>(new Subscriber<T>(s) {
diff --git a/src/main/java/rx/internal/operators/OperatorSingle.java b/src/main/java/rx/internal/operators/OperatorSingle.java
index 53afca58c8..252b6c4ac3 100644
--- a/src/main/java/rx/internal/operators/OperatorSingle.java
+++ b/src/main/java/rx/internal/operators/OperatorSingle.java
@@ -46,8 +46,8 @@
     public static <T> OperatorSingle<T> instance() {
         return (OperatorSingle<T>) Holder.INSTANCE;
     }
-    
-    private OperatorSingle() {
+
+    OperatorSingle() {
         this(false, null);
     }
 
diff --git a/src/main/java/rx/internal/operators/OperatorSkipLast.java b/src/main/java/rx/internal/operators/OperatorSkipLast.java
index 995e4eb777..be877a6b48 100644
--- a/src/main/java/rx/internal/operators/OperatorSkipLast.java
+++ b/src/main/java/rx/internal/operators/OperatorSkipLast.java
@@ -26,7 +26,7 @@
  */
 public class OperatorSkipLast<T> implements Operator<T, T> {
 
-    private final int count;
+    final int count;
 
     public OperatorSkipLast(int count) {
         if (count < 0) {
diff --git a/src/main/java/rx/internal/operators/OperatorSkipLastTimed.java b/src/main/java/rx/internal/operators/OperatorSkipLastTimed.java
index 7ea9c774b0..6bc24579ae 100644
--- a/src/main/java/rx/internal/operators/OperatorSkipLastTimed.java
+++ b/src/main/java/rx/internal/operators/OperatorSkipLastTimed.java
@@ -29,8 +29,8 @@
  */
 public class OperatorSkipLastTimed<T> implements Operator<T, T> {
 
-    private final long timeInMillis;
-    private final Scheduler scheduler;
+    final long timeInMillis;
+    final Scheduler scheduler;
 
     public OperatorSkipLastTimed(long time, TimeUnit unit, Scheduler scheduler) {
         this.timeInMillis = unit.toMillis(time);
diff --git a/src/main/java/rx/internal/operators/OperatorSkipWhile.java b/src/main/java/rx/internal/operators/OperatorSkipWhile.java
index 37ff4b498d..7936901a0e 100644
--- a/src/main/java/rx/internal/operators/OperatorSkipWhile.java
+++ b/src/main/java/rx/internal/operators/OperatorSkipWhile.java
@@ -25,7 +25,7 @@
  * as soon as the condition becomes false.
  */
 public final class OperatorSkipWhile<T> implements Operator<T, T> {
-    private final Func2<? super T, Integer, Boolean> predicate;
+    final Func2<? super T, Integer, Boolean> predicate;
 
     public OperatorSkipWhile(Func2<? super T, Integer, Boolean> predicate) {
         this.predicate = predicate;
diff --git a/src/main/java/rx/internal/operators/OperatorSubscribeOn.java b/src/main/java/rx/internal/operators/OperatorSubscribeOn.java
index 152bc504e4..7dcba6bbd3 100644
--- a/src/main/java/rx/internal/operators/OperatorSubscribeOn.java
+++ b/src/main/java/rx/internal/operators/OperatorSubscribeOn.java
@@ -15,96 +15,84 @@
  */
 package rx.internal.operators;
 
-import rx.Observable;
-import rx.Observable.Operator;
-import rx.Producer;
-import rx.Scheduler;
+import rx.*;
+import rx.Observable.OnSubscribe;
 import rx.Scheduler.Worker;
-import rx.Subscriber;
 import rx.functions.Action0;
 
 /**
  * Subscribes Observers on the specified {@code Scheduler}.
  * <p>
  * <img width="640" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/subscribeOn.png" alt="">
+ * 
+ * @param <T> the value type of the actual source
  */
-public class OperatorSubscribeOn<T> implements Operator<T, Observable<T>> {
+public class OperatorSubscribeOn<T> implements OnSubscribe<T> {
 
-    private final Scheduler scheduler;
+    final Scheduler scheduler;
+    final Observable<T> source;
 
-    public OperatorSubscribeOn(Scheduler scheduler) {
+    public OperatorSubscribeOn(Observable<T> source, Scheduler scheduler) {
         this.scheduler = scheduler;
+        this.source = source;
     }
 
     @Override
-    public Subscriber<? super Observable<T>> call(final Subscriber<? super T> subscriber) {
+    public void call(final Subscriber<? super T> subscriber) {
         final Worker inner = scheduler.createWorker();
         subscriber.add(inner);
-        return new Subscriber<Observable<T>>(subscriber) {
-
-            @Override
-            public void onCompleted() {
-                // ignore because this is a nested Observable and we expect only 1 Observable<T> emitted to onNext
-            }
-
-            @Override
-            public void onError(Throwable e) {
-                subscriber.onError(e);
-            }
-
+        
+        inner.schedule(new Action0() {
             @Override
-            public void onNext(final Observable<T> o) {
-                inner.schedule(new Action0() {
-
+            public void call() {
+                final Thread t = Thread.currentThread();
+                
+                Subscriber<T> s = new Subscriber<T>(subscriber) {
                     @Override
-                    public void call() {
-                        final Thread t = Thread.currentThread();
-                        o.unsafeSubscribe(new Subscriber<T>(subscriber) {
-
-                            @Override
-                            public void onCompleted() {
-                                subscriber.onCompleted();
-                            }
-
-                            @Override
-                            public void onError(Throwable e) {
-                                subscriber.onError(e);
-                            }
-
-                            @Override
-                            public void onNext(T t) {
-                                subscriber.onNext(t);
-                            }
-
+                    public void onNext(T t) {
+                        subscriber.onNext(t);
+                    }
+                    
+                    @Override
+                    public void onError(Throwable e) {
+                        try {
+                            subscriber.onError(e);
+                        } finally {
+                            inner.unsubscribe();
+                        }
+                    }
+                    
+                    @Override
+                    public void onCompleted() {
+                        try {
+                            subscriber.onCompleted();
+                        } finally {
+                            inner.unsubscribe();
+                        }
+                    }
+                    
+                    @Override
+                    public void setProducer(final Producer p) {
+                        subscriber.setProducer(new Producer() {
                             @Override
-                            public void setProducer(final Producer producer) {
-                                subscriber.setProducer(new Producer() {
-
-                                    @Override
-                                    public void request(final long n) {
-                                        if (Thread.currentThread() == t) {
-                                            // don't schedule if we're already on the thread (primarily for first setProducer call)
-                                            // see unit test 'testSetProducerSynchronousRequest' for more context on this
-                                            producer.request(n);
-                                        } else {
-                                            inner.schedule(new Action0() {
-
-                                                @Override
-                                                public void call() {
-                                                    producer.request(n);
-                                                }
-                                            });
+                            public void request(final long n) {
+                                if (t == Thread.currentThread()) {
+                                    p.request(n);
+                                } else {
+                                    inner.schedule(new Action0() {
+                                        @Override
+                                        public void call() {
+                                            p.request(n);
                                         }
-                                    }
-
-                                });
+                                    });
+                                }
                             }
-
                         });
                     }
-                });
+                };
+                
+                source.unsafeSubscribe(s);
             }
-
-        };
+        });
     }
-}
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/OperatorSwitch.java b/src/main/java/rx/internal/operators/OperatorSwitch.java
index cbd02e1b58..5f95f38c3d 100644
--- a/src/main/java/rx/internal/operators/OperatorSwitch.java
+++ b/src/main/java/rx/internal/operators/OperatorSwitch.java
@@ -47,9 +47,9 @@
     public static <T> OperatorSwitch<T> instance() {
         return (OperatorSwitch<T>)Holder.INSTANCE;
     }
-    
-    private OperatorSwitch() { }
-    
+
+    OperatorSwitch() { }
+
     @Override
     public Subscriber<? super Observable<? extends T>> call(final Subscriber<? super T> child) {
         SwitchSubscriber<T> sws = new SwitchSubscriber<T>(child);
diff --git a/src/main/java/rx/internal/operators/OperatorTakeLast.java b/src/main/java/rx/internal/operators/OperatorTakeLast.java
index 54c1a0c43a..2812c4e87c 100644
--- a/src/main/java/rx/internal/operators/OperatorTakeLast.java
+++ b/src/main/java/rx/internal/operators/OperatorTakeLast.java
@@ -28,7 +28,7 @@
  */
 public final class OperatorTakeLast<T> implements Operator<T, T> {
 
-    private final int count;
+    final int count;
 
     public OperatorTakeLast(int count) {
         if (count < 0) {
diff --git a/src/main/java/rx/internal/operators/OperatorTakeLastOne.java b/src/main/java/rx/internal/operators/OperatorTakeLastOne.java
index a7998a1667..6f8bf86259 100644
--- a/src/main/java/rx/internal/operators/OperatorTakeLastOne.java
+++ b/src/main/java/rx/internal/operators/OperatorTakeLastOne.java
@@ -18,7 +18,7 @@
         return (OperatorTakeLastOne<T>) Holder.INSTANCE;
     }
 
-    private OperatorTakeLastOne() {
+    OperatorTakeLastOne() {
 
     }
 
diff --git a/src/main/java/rx/internal/operators/OperatorTakeLastTimed.java b/src/main/java/rx/internal/operators/OperatorTakeLastTimed.java
index 48544f505c..ec7cc12493 100644
--- a/src/main/java/rx/internal/operators/OperatorTakeLastTimed.java
+++ b/src/main/java/rx/internal/operators/OperatorTakeLastTimed.java
@@ -30,9 +30,9 @@
  */
 public final class OperatorTakeLastTimed<T> implements Operator<T, T> {
 
-    private final long ageMillis;
-    private final Scheduler scheduler;
-    private final int count;
+    final long ageMillis;
+    final Scheduler scheduler;
+    final int count;
 
     public OperatorTakeLastTimed(long time, TimeUnit unit, Scheduler scheduler) {
         this.ageMillis = unit.toMillis(time);
diff --git a/src/main/java/rx/internal/operators/OperatorTakeUntilPredicate.java b/src/main/java/rx/internal/operators/OperatorTakeUntilPredicate.java
index c33fab0b47..36ce00271b 100644
--- a/src/main/java/rx/internal/operators/OperatorTakeUntilPredicate.java
+++ b/src/main/java/rx/internal/operators/OperatorTakeUntilPredicate.java
@@ -17,7 +17,6 @@
 
 import rx.*;
 import rx.Observable.Operator;
-import rx.annotations.Experimental;
 import rx.exceptions.Exceptions;
 import rx.functions.Func1;
 
@@ -26,14 +25,13 @@
  * the provided predicate returns false
  * <p>
  */
-@Experimental
 public final class OperatorTakeUntilPredicate<T> implements Operator<T, T> {
     /** Subscriber returned to the upstream. */
     private final class ParentSubscriber extends Subscriber<T> {
         private final Subscriber<? super T> child;
         private boolean done = false;
 
-        private ParentSubscriber(Subscriber<? super T> child) {
+        ParentSubscriber(Subscriber<? super T> child) {
             this.child = child;
         }
 
@@ -75,7 +73,7 @@ void downstreamRequest(long n) {
         }
     }
 
-    private final Func1<? super T, Boolean> stopPredicate;
+    final Func1<? super T, Boolean> stopPredicate;
 
     public OperatorTakeUntilPredicate(final Func1<? super T, Boolean> stopPredicate) {
         this.stopPredicate = stopPredicate;
diff --git a/src/main/java/rx/internal/operators/OperatorTakeWhile.java b/src/main/java/rx/internal/operators/OperatorTakeWhile.java
index 0c34df7b6f..e241ace057 100644
--- a/src/main/java/rx/internal/operators/OperatorTakeWhile.java
+++ b/src/main/java/rx/internal/operators/OperatorTakeWhile.java
@@ -28,7 +28,7 @@
  */
 public final class OperatorTakeWhile<T> implements Operator<T, T> {
 
-    private final Func2<? super T, ? super Integer, Boolean> predicate;
+    final Func2<? super T, ? super Integer, Boolean> predicate;
 
     public OperatorTakeWhile(final Func1<? super T, Boolean> underlying) {
         this(new Func2<T, Integer, Boolean>() {
diff --git a/src/main/java/rx/internal/operators/OperatorThrottleFirst.java b/src/main/java/rx/internal/operators/OperatorThrottleFirst.java
index 0f14839e47..2bf960931d 100644
--- a/src/main/java/rx/internal/operators/OperatorThrottleFirst.java
+++ b/src/main/java/rx/internal/operators/OperatorThrottleFirst.java
@@ -25,8 +25,8 @@
  */
 public final class OperatorThrottleFirst<T> implements Operator<T, T> {
 
-    private final long timeInMilliseconds;
-    private final Scheduler scheduler;
+    final long timeInMilliseconds;
+    final Scheduler scheduler;
 
     public OperatorThrottleFirst(long windowDuration, TimeUnit unit, Scheduler scheduler) {
         this.timeInMilliseconds = unit.toMillis(windowDuration);
diff --git a/src/main/java/rx/internal/operators/OperatorTimeInterval.java b/src/main/java/rx/internal/operators/OperatorTimeInterval.java
index 4b76ea768d..e73f6fd0d3 100644
--- a/src/main/java/rx/internal/operators/OperatorTimeInterval.java
+++ b/src/main/java/rx/internal/operators/OperatorTimeInterval.java
@@ -25,7 +25,7 @@
  */
 public final class OperatorTimeInterval<T> implements Operator<TimeInterval<T>, T> {
 
-    private final Scheduler scheduler;
+    final Scheduler scheduler;
 
     public OperatorTimeInterval(Scheduler scheduler) {
         this.scheduler = scheduler;
diff --git a/src/main/java/rx/internal/operators/OperatorTimeoutBase.java b/src/main/java/rx/internal/operators/OperatorTimeoutBase.java
index 65b940640c..8d0bdfd56e 100644
--- a/src/main/java/rx/internal/operators/OperatorTimeoutBase.java
+++ b/src/main/java/rx/internal/operators/OperatorTimeoutBase.java
@@ -16,16 +16,11 @@
 package rx.internal.operators;
 
 import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
 
-import rx.Observable;
+import rx.*;
 import rx.Observable.Operator;
-import rx.Scheduler;
-import rx.Subscriber;
-import rx.Subscription;
-import rx.functions.Func3;
-import rx.functions.Func4;
+import rx.functions.*;
+import rx.internal.producers.ProducerArbiter;
 import rx.observers.SerializedSubscriber;
 import rx.subscriptions.SerialSubscription;
 
@@ -65,15 +60,21 @@
     public Subscriber<? super T> call(Subscriber<? super T> subscriber) {
         Scheduler.Worker inner = scheduler.createWorker();
         subscriber.add(inner);
-        final SerialSubscription serial = new SerialSubscription();
-        subscriber.add(serial);
         // Use SynchronizedSubscriber for safe memory access
         // as the subscriber will be accessed in the current thread or the
         // scheduler or other Observables.
         final SerializedSubscriber<T> synchronizedSubscriber = new SerializedSubscriber<T>(subscriber);
 
+        final SerialSubscription serial = new SerialSubscription();
+        synchronizedSubscriber.add(serial);
+
         TimeoutSubscriber<T> timeoutSubscriber = new TimeoutSubscriber<T>(synchronizedSubscriber, timeoutStub, serial, other, inner);
+        
+        synchronizedSubscriber.add(timeoutSubscriber);
+        synchronizedSubscriber.setProducer(timeoutSubscriber.arbiter);
+        
         serial.set(firstTimeoutStub.call(timeoutSubscriber, 0L, inner));
+        
         return timeoutSubscriber;
     }
 
@@ -81,51 +82,64 @@
             Subscriber<T> {
 
         private final SerialSubscription serial;
-        private final Object gate = new Object();
 
         private final SerializedSubscriber<T> serializedSubscriber;
 
         private final TimeoutStub<T> timeoutStub;
 
         private final Observable<? extends T> other;
+        
         private final Scheduler.Worker inner;
         
-        final AtomicInteger terminated = new AtomicInteger();
-        final AtomicLong actual = new AtomicLong();
+        final ProducerArbiter arbiter;
+        
+        /** Guarded by this. */
+        boolean terminated;
+        /** Guarded by this. */
+        long actual;
         
         private TimeoutSubscriber(
                 SerializedSubscriber<T> serializedSubscriber,
                 TimeoutStub<T> timeoutStub, SerialSubscription serial,
                 Observable<? extends T> other,
                 Scheduler.Worker inner) {
-            super(serializedSubscriber);
             this.serializedSubscriber = serializedSubscriber;
             this.timeoutStub = timeoutStub;
             this.serial = serial;
             this.other = other;
             this.inner = inner;
+            this.arbiter = new ProducerArbiter();
         }
 
+        @Override
+        public void setProducer(Producer p) {
+            arbiter.setProducer(p);
+        }
+        
         @Override
         public void onNext(T value) {
             boolean onNextWins = false;
-            synchronized (gate) {
-                if (terminated.get() == 0) {
-                    actual.incrementAndGet();
+            long a;
+            synchronized (this) {
+                if (!terminated) {
+                    a = ++actual;
                     onNextWins = true;
+                } else {
+                    a = actual;
                 }
             }
             if (onNextWins) {
                 serializedSubscriber.onNext(value);
-                serial.set(timeoutStub.call(this, actual.get(), value, inner));
+                serial.set(timeoutStub.call(this, a, value, inner));
             }
         }
 
         @Override
         public void onError(Throwable error) {
             boolean onErrorWins = false;
-            synchronized (gate) {
-                if (terminated.getAndSet(1) == 0) {
+            synchronized (this) {
+                if (!terminated) {
+                    terminated = true;
                     onErrorWins = true;
                 }
             }
@@ -138,8 +152,9 @@ public void onError(Throwable error) {
         @Override
         public void onCompleted() {
             boolean onCompletedWins = false;
-            synchronized (gate) {
-                if (terminated.getAndSet(1) == 0) {
+            synchronized (this) {
+                if (!terminated) {
+                    terminated = true;
                     onCompletedWins = true;
                 }
             }
@@ -152,8 +167,9 @@ public void onCompleted() {
         public void onTimeout(long seqId) {
             long expected = seqId;
             boolean timeoutWins = false;
-            synchronized (gate) {
-                if (expected == actual.get() && terminated.getAndSet(1) == 0) {
+            synchronized (this) {
+                if (expected == actual && !terminated) {
+                    terminated = true;
                     timeoutWins = true;
                 }
             }
@@ -161,10 +177,31 @@ public void onTimeout(long seqId) {
                 if (other == null) {
                     serializedSubscriber.onError(new TimeoutException());
                 } else {
-                    other.unsafeSubscribe(serializedSubscriber);
-                    serial.set(serializedSubscriber);
+                    Subscriber<T> second = new Subscriber<T>() {
+                        @Override
+                        public void onNext(T t) {
+                            serializedSubscriber.onNext(t);
+                        }
+                        
+                        @Override
+                        public void onError(Throwable e) {
+                            serializedSubscriber.onError(e);
+                        }
+                        
+                        @Override
+                        public void onCompleted() {
+                            serializedSubscriber.onCompleted();
+                        }
+                        
+                        @Override
+                        public void setProducer(Producer p) {
+                            arbiter.setProducer(p);
+                        }
+                    };
+                    other.unsafeSubscribe(second);
+                    serial.set(second);
                 }
             }
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/OperatorTimestamp.java b/src/main/java/rx/internal/operators/OperatorTimestamp.java
index 2e24fbf169..284c0e2124 100644
--- a/src/main/java/rx/internal/operators/OperatorTimestamp.java
+++ b/src/main/java/rx/internal/operators/OperatorTimestamp.java
@@ -27,7 +27,7 @@
  */
 public final class OperatorTimestamp<T> implements Operator<Timestamped<T>, T> {
 
-    private final Scheduler scheduler;
+    final Scheduler scheduler;
 
     public OperatorTimestamp(Scheduler scheduler) {
         this.scheduler = scheduler;
diff --git a/src/main/java/rx/internal/operators/OperatorToMap.java b/src/main/java/rx/internal/operators/OperatorToMap.java
index 97decaa6da..0a1ea9fcd0 100644
--- a/src/main/java/rx/internal/operators/OperatorToMap.java
+++ b/src/main/java/rx/internal/operators/OperatorToMap.java
@@ -21,8 +21,10 @@
 
 import rx.Observable.Operator;
 import rx.Subscriber;
+import rx.exceptions.Exceptions;
 import rx.functions.Func0;
 import rx.functions.Func1;
+import rx.observers.Subscribers;
 
 /**
  * Maps the elements of the source observable into a java.util.Map instance and
@@ -43,9 +45,9 @@
     }
 
 
-    private final Func1<? super T, ? extends K> keySelector;
+    final Func1<? super T, ? extends K> keySelector;
 
-    private final Func1<? super T, ? extends V> valueSelector;
+    final Func1<? super T, ? extends V> valueSelector;
 
     private final Func0<? extends Map<K, V>> mapFactory;
 
@@ -75,9 +77,24 @@ public OperatorToMap(
 
     @Override
     public Subscriber<? super T> call(final Subscriber<? super Map<K, V>> subscriber) {
+        
+        Map<K, V> localMap;
+        
+        try {
+            localMap = mapFactory.call();
+        } catch (Throwable ex) {
+            Exceptions.throwIfFatal(ex);
+            subscriber.onError(ex);
+            Subscriber<? super T> parent = Subscribers.empty();
+            parent.unsubscribe();
+            return parent;
+        }
+        
+        final Map<K, V> fLocalMap = localMap;
+        
         return new Subscriber<T>(subscriber) {
 
-            private Map<K, V> map = mapFactory.call();
+            private Map<K, V> map = fLocalMap;
 
             @Override
             public void onStart() {
@@ -86,8 +103,18 @@ public void onStart() {
             
             @Override
             public void onNext(T v) {
-                K key = keySelector.call(v);
-                V value = valueSelector.call(v);
+                K key;
+                V value;
+
+                try {
+                    key = keySelector.call(v);
+                    value = valueSelector.call(v);
+                } catch (Throwable ex) {
+                    Exceptions.throwIfFatal(ex);
+                    subscriber.onError(ex);
+                    return;
+                }
+                
                 map.put(key, value);
             }
 
diff --git a/src/main/java/rx/internal/operators/OperatorToMultimap.java b/src/main/java/rx/internal/operators/OperatorToMultimap.java
index f7b998ed94..1f3423e02c 100644
--- a/src/main/java/rx/internal/operators/OperatorToMultimap.java
+++ b/src/main/java/rx/internal/operators/OperatorToMultimap.java
@@ -22,9 +22,11 @@
 import java.util.Map;
 
 import rx.Observable.Operator;
+import rx.exceptions.Exceptions;
 import rx.Subscriber;
 import rx.functions.Func0;
 import rx.functions.Func1;
+import rx.observers.Subscribers;
 
 /**
  * Maps the elements of the source observable into a multimap
@@ -56,10 +58,10 @@
         }
     }
 
-    private final Func1<? super T, ? extends K> keySelector;
-    private final Func1<? super T, ? extends V> valueSelector;
+    final Func1<? super T, ? extends K> keySelector;
+    final Func1<? super T, ? extends V> valueSelector;
     private final Func0<? extends Map<K, Collection<V>>> mapFactory;
-    private final Func1<? super K, ? extends Collection<V>> collectionFactory;
+    final Func1<? super K, ? extends Collection<V>> collectionFactory;
 
     /**
      * ToMultimap with key selector, custom value selector,
@@ -103,8 +105,24 @@ public OperatorToMultimap(
 
     @Override
     public Subscriber<? super T> call(final Subscriber<? super Map<K, Collection<V>>> subscriber) {
+        
+        Map<K, Collection<V>> localMap;
+        
+        try {
+            localMap = mapFactory.call();
+        } catch (Throwable ex) {
+            Exceptions.throwIfFatal(ex);
+            subscriber.onError(ex);
+            
+            Subscriber<? super T> parent = Subscribers.empty();
+            parent.unsubscribe();
+            return parent;
+        }
+        
+        final Map<K, Collection<V>> fLocalMap = localMap;
+        
         return new Subscriber<T>(subscriber) {
-            private Map<K, Collection<V>> map = mapFactory.call();
+            private Map<K, Collection<V>> map = fLocalMap;
 
             @Override
             public void onStart() {
@@ -113,11 +131,27 @@ public void onStart() {
             
             @Override
             public void onNext(T v) {
-                K key = keySelector.call(v);
-                V value = valueSelector.call(v);
+                K key;
+                V value;
+
+                try {
+                    key = keySelector.call(v);
+                    value = valueSelector.call(v);
+                } catch (Throwable ex) {
+                    Exceptions.throwIfFatal(ex);
+                    subscriber.onError(ex);
+                    return;
+                }
+                
                 Collection<V> collection = map.get(key);
                 if (collection == null) {
-                    collection = collectionFactory.call(key);
+                    try {
+                        collection = collectionFactory.call(key);
+                    } catch (Throwable ex) {
+                        Exceptions.throwIfFatal(ex);
+                        subscriber.onError(ex);
+                        return;
+                    }
                     map.put(key, collection);
                 }
                 collection.add(value);
diff --git a/src/main/java/rx/internal/operators/OperatorToObservableList.java b/src/main/java/rx/internal/operators/OperatorToObservableList.java
index d2e9d717f6..66e0bb188a 100644
--- a/src/main/java/rx/internal/operators/OperatorToObservableList.java
+++ b/src/main/java/rx/internal/operators/OperatorToObservableList.java
@@ -49,7 +49,7 @@
     public static <T> OperatorToObservableList<T> instance() {
         return (OperatorToObservableList<T>)Holder.INSTANCE;
     }
-    private OperatorToObservableList() { }
+    OperatorToObservableList() { }
     @Override
     public Subscriber<? super T> call(final Subscriber<? super List<T>> o) {
         final SingleDelayedProducer<List<T>> producer = new SingleDelayedProducer<List<T>>(o);
diff --git a/src/main/java/rx/internal/operators/OperatorToObservableSortedList.java b/src/main/java/rx/internal/operators/OperatorToObservableSortedList.java
index 19246cbe7c..ab74e44f17 100644
--- a/src/main/java/rx/internal/operators/OperatorToObservableSortedList.java
+++ b/src/main/java/rx/internal/operators/OperatorToObservableSortedList.java
@@ -34,8 +34,8 @@
  *          the type of the items emitted by the source and the resulting {@code Observable}s
  */
 public final class OperatorToObservableSortedList<T> implements Operator<List<T>, T> {
-    private final Comparator<? super T> sortFunction;
-    private final int initialCapacity;
+    final Comparator<? super T> sortFunction;
+    final int initialCapacity;
 
     @SuppressWarnings("unchecked")
     public OperatorToObservableSortedList(int initialCapacity) {
@@ -105,6 +105,8 @@ public void onNext(T value) {
     private static Comparator DEFAULT_SORT_FUNCTION = new DefaultComparableFunction();
 
     private static class DefaultComparableFunction implements Comparator<Object> {
+        DefaultComparableFunction() {
+        }
 
         // unchecked because we want to support Object for this default
         @SuppressWarnings("unchecked")
diff --git a/src/main/java/rx/internal/operators/OperatorUnsubscribeOn.java b/src/main/java/rx/internal/operators/OperatorUnsubscribeOn.java
index 20957e29f4..327b4d1d24 100644
--- a/src/main/java/rx/internal/operators/OperatorUnsubscribeOn.java
+++ b/src/main/java/rx/internal/operators/OperatorUnsubscribeOn.java
@@ -27,7 +27,7 @@
  */
 public class OperatorUnsubscribeOn<T> implements Operator<T, T> {
 
-    private final Scheduler scheduler;
+    final Scheduler scheduler;
 
     public OperatorUnsubscribeOn(Scheduler scheduler) {
         this.scheduler = scheduler;
diff --git a/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java b/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java
index 3b7e1c1cac..4b2cbb7dd8 100644
--- a/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java
+++ b/src/main/java/rx/internal/operators/OperatorWindowWithObservable.java
@@ -154,7 +154,7 @@ void replaceSubject() {
             child.onNext(producer);
         }
         void createNewWindow() {
-            BufferUntilSubscriber<T> bus = BufferUntilSubscriber.create();
+            UnicastSubject<T> bus = UnicastSubject.create();
             consumer = bus;
             producer = bus;
         }
diff --git a/src/main/java/rx/internal/operators/OperatorWindowWithObservableFactory.java b/src/main/java/rx/internal/operators/OperatorWindowWithObservableFactory.java
index a764850c79..5ac748e6f1 100644
--- a/src/main/java/rx/internal/operators/OperatorWindowWithObservableFactory.java
+++ b/src/main/java/rx/internal/operators/OperatorWindowWithObservableFactory.java
@@ -160,7 +160,7 @@ void replaceSubject() {
             child.onNext(producer);
         }
         void createNewWindow() {
-            BufferUntilSubscriber<T> bus = BufferUntilSubscriber.create();
+            UnicastSubject<T> bus = UnicastSubject.create();
             consumer = bus;
             producer = bus;
             Observable<? extends U> other;
diff --git a/src/main/java/rx/internal/operators/OperatorWindowWithSize.java b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java
index e5aae95aaa..48d80d9cfb 100644
--- a/src/main/java/rx/internal/operators/OperatorWindowWithSize.java
+++ b/src/main/java/rx/internal/operators/OperatorWindowWithSize.java
@@ -60,7 +60,7 @@ public OperatorWindowWithSize(int size, int skip) {
     final class ExactSubscriber extends Subscriber<T> {
         final Subscriber<? super Observable<T>> child;
         int count;
-        BufferUntilSubscriber<T> window;
+        UnicastSubject<T> window;
         volatile boolean noWindow = true;
         public ExactSubscriber(Subscriber<? super Observable<T>> child) {
             /**
@@ -107,7 +107,7 @@ void requestMore(long n) {
         public void onNext(T t) {
             if (window == null) {
                 noWindow = false;
-                window = BufferUntilSubscriber.create();
+                window = UnicastSubject.create();
                 child.onNext(window);
             }
             window.onNext(t);
@@ -241,7 +241,7 @@ public void onCompleted() {
         }
 
         CountedSubject<T> createCountedSubject() {
-            final BufferUntilSubscriber<T> bus = BufferUntilSubscriber.create();
+            final UnicastSubject<T> bus = UnicastSubject.create();
             return new CountedSubject<T>(bus, bus);
         }
     }
diff --git a/src/main/java/rx/internal/operators/OperatorWindowWithStartEndObservable.java b/src/main/java/rx/internal/operators/OperatorWindowWithStartEndObservable.java
index 82d1474163..07dea16e76 100644
--- a/src/main/java/rx/internal/operators/OperatorWindowWithStartEndObservable.java
+++ b/src/main/java/rx/internal/operators/OperatorWindowWithStartEndObservable.java
@@ -233,7 +233,7 @@ void endWindow(SerializedSubject<T> window) {
             }
         }
         SerializedSubject<T> createSerializedSubject() {
-            BufferUntilSubscriber<T> bus = BufferUntilSubscriber.create();
+            UnicastSubject<T> bus = UnicastSubject.create();
             return new SerializedSubject<T>(bus, bus);
         }
     }
diff --git a/src/main/java/rx/internal/operators/OperatorWindowWithTime.java b/src/main/java/rx/internal/operators/OperatorWindowWithTime.java
index cac94c5ba0..d55f0db31c 100644
--- a/src/main/java/rx/internal/operators/OperatorWindowWithTime.java
+++ b/src/main/java/rx/internal/operators/OperatorWindowWithTime.java
@@ -214,7 +214,7 @@ boolean replaceSubject() {
                 unsubscribe();
                 return false;
             }
-            BufferUntilSubscriber<T> bus = BufferUntilSubscriber.create();
+            UnicastSubject<T> bus = UnicastSubject.create();
             state = state.create(bus, bus);
             child.onNext(bus);
             return true;
@@ -492,7 +492,7 @@ void terminateChunk(CountedSerializedSubject<T> chunk) {
             }
         }
         CountedSerializedSubject<T> createCountedSerializedSubject() {
-            BufferUntilSubscriber<T> bus = BufferUntilSubscriber.create();
+            UnicastSubject<T> bus = UnicastSubject.create();
             return new CountedSerializedSubject<T>(bus, bus);
         }
     }
diff --git a/src/main/java/rx/internal/operators/OperatorZip.java b/src/main/java/rx/internal/operators/OperatorZip.java
index df9dc4a00d..a35e176d54 100644
--- a/src/main/java/rx/internal/operators/OperatorZip.java
+++ b/src/main/java/rx/internal/operators/OperatorZip.java
@@ -17,23 +17,10 @@
 
 import java.util.concurrent.atomic.AtomicLong;
 
-import rx.Observable;
+import rx.*;
 import rx.Observable.Operator;
-import rx.Observer;
-import rx.Producer;
-import rx.Subscriber;
-import rx.exceptions.Exceptions;
-import rx.exceptions.MissingBackpressureException;
-import rx.functions.Func2;
-import rx.functions.Func3;
-import rx.functions.Func4;
-import rx.functions.Func5;
-import rx.functions.Func6;
-import rx.functions.Func7;
-import rx.functions.Func8;
-import rx.functions.Func9;
-import rx.functions.FuncN;
-import rx.functions.Functions;
+import rx.exceptions.*;
+import rx.functions.*;
 import rx.internal.util.RxRingBuffer;
 import rx.subscriptions.CompositeSubscription;
 
@@ -111,8 +98,11 @@ public OperatorZip(Func9 f) {
     public Subscriber<? super Observable[]> call(final Subscriber<? super R> child) {
         final Zip<R> zipper = new Zip<R>(child, zipFunction);
         final ZipProducer<R> producer = new ZipProducer<R>(zipper);
-        child.setProducer(producer);
         final ZipSubscriber subscriber = new ZipSubscriber(child, zipper, producer);
+
+        child.add(subscriber);
+        child.setProducer(producer);
+        
         return subscriber;
     }
 
@@ -124,7 +114,6 @@ public OperatorZip(Func9 f) {
         final ZipProducer<R> producer;
 
         public ZipSubscriber(Subscriber<? super R> child, Zip<R> zipper, ZipProducer<R> producer) {
-            super(child);
             this.child = child;
             this.zipper = zipper;
             this.producer = producer;
@@ -176,6 +165,8 @@ public void request(long n) {
     }
 
     private static final class Zip<R> extends AtomicLong {
+        /** */
+        private static final long serialVersionUID = 3014069338189397063L;
         private final Observer<? super R> child;
         private final FuncN<? extends R> zipFunction;
         private final CompositeSubscription childSubscription = new CompositeSubscription();
@@ -330,4 +321,4 @@ public void onNext(Object t) {
         };
     }
 
-}
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/operators/OperatorZipIterable.java b/src/main/java/rx/internal/operators/OperatorZipIterable.java
index f913854d1d..a90e62f470 100644
--- a/src/main/java/rx/internal/operators/OperatorZipIterable.java
+++ b/src/main/java/rx/internal/operators/OperatorZipIterable.java
@@ -46,23 +46,31 @@ public OperatorZipIterable(Iterable<? extends T2> iterable, Func2<? super T1, ?
             return Subscribers.empty();
         }
         return new Subscriber<T1>(subscriber) {
-            boolean once;
+            boolean done;
             @Override
             public void onCompleted() {
-                if (once) {
+                if (done) {
                     return;
                 }
-                once = true;
+                done = true;
                 subscriber.onCompleted();
             }
 
             @Override
             public void onError(Throwable e) {
+                if (done) {
+                    Exceptions.throwIfFatal(e);
+                    return;
+                }
+                done = true;
                 subscriber.onError(e);
             }
 
             @Override
             public void onNext(T1 t) {
+                if (done) {
+                    return;
+                }
                 try {
                     subscriber.onNext(zipFunction.call(t, iterator.next()));
                     if (!iterator.hasNext()) {
diff --git a/src/main/java/rx/internal/operators/SingleOperatorZip.java b/src/main/java/rx/internal/operators/SingleOperatorZip.java
new file mode 100644
index 0000000000..936750941f
--- /dev/null
+++ b/src/main/java/rx/internal/operators/SingleOperatorZip.java
@@ -0,0 +1,72 @@
+package rx.internal.operators;
+
+import rx.Single;
+import rx.SingleSubscriber;
+import rx.exceptions.Exceptions;
+import rx.functions.FuncN;
+import rx.plugins.RxJavaPlugins;
+import rx.subscriptions.CompositeSubscription;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class SingleOperatorZip {
+
+    public static <T, R> Single<R> zip(final Single<? extends T>[] singles, final FuncN<? extends R> zipper) {
+        return Single.create(new Single.OnSubscribe<R>() {
+            @Override
+            public void call(final SingleSubscriber<? super R> subscriber) {
+                final AtomicInteger wip = new AtomicInteger(singles.length);
+                final AtomicBoolean once = new AtomicBoolean();
+                final Object[] values = new Object[singles.length];
+
+                CompositeSubscription compositeSubscription = new CompositeSubscription();
+                subscriber.add(compositeSubscription);
+
+                for (int i = 0; i < singles.length; i++) {
+                    if (compositeSubscription.isUnsubscribed() || once.get()) {
+                        break;
+                    }
+
+                    final int j = i;
+                    SingleSubscriber<T> singleSubscriber = new SingleSubscriber<T>() {
+                        @Override
+                        public void onSuccess(T value) {
+                            values[j] = value;
+                            if (wip.decrementAndGet() == 0) {
+                                R r;
+
+                                try {
+                                    r = zipper.call(values);
+                                } catch (Throwable e) {
+                                    Exceptions.throwIfFatal(e);
+                                    onError(e);
+                                    return;
+                                }
+
+                                subscriber.onSuccess(r);
+                            }
+                        }
+
+                        @Override
+                        public void onError(Throwable error) {
+                            if (once.compareAndSet(false, true)) {
+                                subscriber.onError(error);
+                            } else {
+                                RxJavaPlugins.getInstance().getErrorHandler().handleError(error);
+                            }
+                        }
+                    };
+
+                    compositeSubscription.add(singleSubscriber);
+
+                    if (compositeSubscription.isUnsubscribed() || once.get()) {
+                        break;
+                    }
+
+                    singles[i].subscribe(singleSubscriber);
+                }
+            }
+        });
+    }
+}
diff --git a/src/main/java/rx/internal/operators/UnicastSubject.java b/src/main/java/rx/internal/operators/UnicastSubject.java
new file mode 100644
index 0000000000..44bba2b90e
--- /dev/null
+++ b/src/main/java/rx/internal/operators/UnicastSubject.java
@@ -0,0 +1,333 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx.internal.operators;
+
+import java.util.Queue;
+import java.util.concurrent.atomic.*;
+
+import rx.*;
+import rx.exceptions.*;
+import rx.functions.*;
+import rx.internal.util.atomic.*;
+import rx.internal.util.unsafe.*;
+import rx.subjects.Subject;
+import rx.subscriptions.Subscriptions;
+
+/**
+ * A Subject variant which buffers events until a single Subscriber arrives and replays them to it
+ * and potentially switches to direct delivery once the Subscriber caught up and requested an unlimited
+ * amount. In this case, the buffered values are no longer retained. If the Subscriber
+ * requests a limited amount, queueing is involved and only those values are retained which
+ * weren't requested by the Subscriber at that time.
+ */
+public final class UnicastSubject<T> extends Subject<T, T> {
+
+    /**
+     * Constructs an empty UnicastSubject instance with the default capacity hint of 16 elements.
+     * 
+     * @return the created UnicastSubject instance
+     */
+    public static <T> UnicastSubject<T> create() {
+        return create(16);
+    }
+    /**
+     * Constructs an empty UnicastSubject instance with a capacity hint.
+     * <p>The capacity hint determines the internal queue's island size: the larger
+     * it is the less frequent allocation will happen if there is no subscriber
+     * or the subscriber hasn't caught up.
+     * @param capacityHint the capacity hint for the internal queue
+     * @return the created BufferUntilSubscriber instance
+     */
+    public static <T> UnicastSubject<T> create(int capacityHint) {
+        State<T> state = new State<T>(capacityHint);
+        return new UnicastSubject<T>(state);
+    }
+    
+    final State<T> state;
+
+    private UnicastSubject(State<T> state) {
+        super(state);
+        this.state = state;
+    }
+    
+    @Override
+    public void onNext(T t) {
+        state.onNext(t);
+    }
+    
+    @Override
+    public void onError(Throwable e) {
+        state.onError(e);
+    }
+    
+    @Override
+    public void onCompleted() {
+        state.onCompleted();
+    }
+    
+    @Override
+    public boolean hasObservers() {
+        return state.subscriber.get() != null;
+    }
+    
+    /**
+     * The single-consumption replaying state.
+     *
+     * @param <T> the value type
+     */
+    static final class State<T> extends AtomicLong implements Producer, Observer<T>, Action0, OnSubscribe<T> {
+        /** */
+        private static final long serialVersionUID = -9044104859202255786L;
+        /** The single subscriber. */
+        final AtomicReference<Subscriber<? super T>> subscriber;
+        /** The queue holding values until the subscriber arrives and catches up. */
+        final Queue<Object> queue;
+        /** JCTools queues don't accept nulls. */
+        final NotificationLite<T> nl;
+        /** In case the source emitted an error. */
+        Throwable error;
+        /** Indicates the source has terminated. */
+        volatile boolean done;
+        /** Emitter loop: emitting indicator. Guarded by this. */
+        boolean emitting;
+        /** Emitter loop: missed emission indicator. Guarded by this. */
+        boolean missed;
+        /** Indicates the queue can be bypassed because the child has caught up with the replay. */
+        volatile boolean caughtUp;
+        /**
+         * Constructor.
+         * @param capacityHint indicates how large each island in the Spsc queue should be to
+         * reduce allocation frequency
+         */
+        public State(int capacityHint) {
+            this.nl = NotificationLite.instance();
+            this.subscriber = new AtomicReference<Subscriber<? super T>>();
+            Queue<Object> q;
+            if (capacityHint > 1) {
+                q = UnsafeAccess.isUnsafeAvailable()
+                        ? new SpscUnboundedArrayQueue<Object>(capacityHint)
+                        : new SpscUnboundedAtomicArrayQueue<Object>(capacityHint);
+            } else {
+                q = UnsafeAccess.isUnsafeAvailable()
+                        ? new SpscLinkedQueue<Object>()
+                        : new SpscLinkedAtomicQueue<Object>();
+            }
+            this.queue = q;
+        }
+        
+        @Override
+        public void onNext(T t) {
+            if (!done) {
+                if (!caughtUp) {
+                    boolean stillReplay = false;
+                    /*
+                     * We need to offer while holding the lock because
+                     * we have to atomically switch caughtUp to true
+                     * that can only happen if there isn't any concurrent
+                     * offer() happening while the emission is in replayLoop().
+                     */
+                    synchronized (this) {
+                        if (!caughtUp) {
+                            queue.offer(nl.next(t));
+                            stillReplay = true;
+                        }
+                    }
+                    if (stillReplay) {
+                        replay();
+                        return;
+                    }
+                }
+                Subscriber<? super T> s = subscriber.get();
+                try {
+                    s.onNext(t);
+                } catch (Throwable ex) {
+                    Exceptions.throwIfFatal(ex);
+                    s.onError(OnErrorThrowable.addValueAsLastCause(ex, t));
+                }
+            }
+        }
+        @Override
+        public void onError(Throwable e) {
+            if (!done) {
+                error = e;
+                done = true;
+                if (!caughtUp) {
+                    boolean stillReplay = false;
+                    synchronized (this) {
+                        stillReplay = !caughtUp;
+                    }
+                    if (stillReplay) {
+                        replay();
+                        return;
+                    }
+                }
+                subscriber.get().onError(e);
+            }
+        }
+        @Override
+        public void onCompleted() {
+            if (!done) {
+                done = true;
+                if (!caughtUp) {
+                    boolean stillReplay = false;
+                    synchronized (this) {
+                        stillReplay = !caughtUp;
+                    }
+                    if (stillReplay) {
+                        replay();
+                        return;
+                    }
+                }
+                subscriber.get().onCompleted();
+            }
+        }
+        
+        @Override
+        public void request(long n) {
+            if (n < 0L) {
+                throw new IllegalArgumentException("n >= 0 required");
+            } else
+            if (n > 0L) {
+                BackpressureUtils.getAndAddRequest(this, n);
+                replay();
+            } else
+            if (done) { // terminal events can be delivered for zero requests
+                replay();
+            }
+        }
+        /**
+         * Tries to set the given subscriber if not already set, sending an
+         * IllegalStateException to the subscriber otherwise.
+         * @param subscriber
+         */
+        @Override
+        public void call(Subscriber<? super T> subscriber) {
+            if (this.subscriber.compareAndSet(null, subscriber)) {
+                subscriber.add(Subscriptions.create(this));
+                subscriber.setProducer(this);
+            } else {
+                subscriber.onError(new IllegalStateException("Only a single subscriber is allowed"));
+            }
+        }
+        /**
+         * Tries to replay the contents of the queue.
+         */
+        void replay() {
+            synchronized (this) {
+                if (emitting) {
+                    missed = true;
+                    return;
+                }
+                emitting = true;
+            }
+            Queue<Object> q = queue;
+            for (;;) {
+                Subscriber<? super T> s = subscriber.get();
+                boolean unlimited = false;
+                if (s != null) {
+                    boolean d = done;
+                    boolean empty = q.isEmpty();
+                    
+                    if (checkTerminated(d, empty, s)) {
+                        return;
+                    }
+                    long r = get();
+                    unlimited = r == Long.MAX_VALUE;
+                    long e = 0L;
+                    
+                    while (r != 0) {
+                        d = done;
+                        Object v = q.poll();
+                        empty = v == null;
+                        if (checkTerminated(d, empty, s)) {
+                            return;
+                        }
+                        if (empty) {
+                            break;
+                        }
+                        T value = nl.getValue(v);
+                        try {
+                            s.onNext(value);
+                        } catch (Throwable ex) {
+                            q.clear();
+                            Exceptions.throwIfFatal(ex);
+                            s.onError(OnErrorThrowable.addValueAsLastCause(ex, value));
+                            return;
+                        }
+                        r--;
+                        e++;
+                    }
+                    if (!unlimited && e != 0L) {
+                        addAndGet(-e);
+                    }
+                }
+                
+                synchronized (this) {
+                    if (!missed) {
+                        if (unlimited && q.isEmpty()) {
+                            caughtUp = true;
+                        }
+                        emitting = false;
+                        return;
+                    }
+                    missed = false;
+                }
+            }
+        }
+        /**
+         * Terminates the state by setting the done flag and tries to clear the queue.
+         * Should be called only when the child unsubscribes
+         */
+        @Override
+        public void call() {
+            done = true;
+            synchronized (this) {
+                if (emitting) {
+                    return;
+                }
+                emitting = true;
+            }
+            queue.clear();
+        }
+        /**
+         * Checks if one of the terminal conditions have been met: child unsubscribed,
+         * an error happened or the source terminated and the queue is empty
+         * @param done
+         * @param empty
+         * @param s
+         * @return
+         */
+        boolean checkTerminated(boolean done, boolean empty, Subscriber<? super T> s) {
+            if (s.isUnsubscribed()) {
+                queue.clear();
+                return true;
+            }
+            if (done) {
+                Throwable e = error;
+                if (e != null) {
+                    queue.clear();
+                    s.onError(e);
+                    return true;
+                } else
+                if (empty) {
+                    s.onCompleted();
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/producers/ProducerObserverArbiter.java b/src/main/java/rx/internal/producers/ProducerObserverArbiter.java
index 7600815094..985352a3f4 100644
--- a/src/main/java/rx/internal/producers/ProducerObserverArbiter.java
+++ b/src/main/java/rx/internal/producers/ProducerObserverArbiter.java
@@ -20,6 +20,7 @@
 import rx.*;
 import rx.Observer;
 import rx.exceptions.*;
+import rx.internal.operators.BackpressureUtils;
 
 /**
  * Producer that serializes any event emission with requesting and producer changes.
@@ -135,6 +136,7 @@ public void request(long n) {
             }
             emitting = true;
         }
+        Producer p = currentProducer;
         boolean skipFinal = false;
         try {
             long r = requested;
@@ -143,12 +145,7 @@ public void request(long n) {
                 u = Long.MAX_VALUE;
             }
             requested = u;
-            
-            Producer p = currentProducer;
-            if (p != null) {
-                p.request(n);
-            }
-            
+
             emitLoop();
             skipFinal = true;
         } finally {
@@ -158,6 +155,9 @@ public void request(long n) {
                 }
             }
         }
+        if (p != null) {
+            p.request(n);
+        }
     }
     
     public void setProducer(Producer p) {
@@ -169,12 +169,9 @@ public void setProducer(Producer p) {
             emitting = true;
         }
         boolean skipFinal = false;
+        currentProducer = p;
+        long r = requested;
         try {
-            currentProducer = p;
-            long r = requested;
-            if (p != null && r != 0) {
-                p.request(r);
-            }
             emitLoop();
             skipFinal = true;
         } finally {
@@ -184,17 +181,24 @@ public void setProducer(Producer p) {
                 }
             }
         }
+        if (p != null && r != 0) {
+            p.request(r);
+        }
     }
     
     void emitLoop() {
         final Subscriber<? super T> c = child;
 
+        long toRequest = 0L;
+        Producer requestFrom = null;
+        
         outer:
         for (;;) {
             long localRequested;
             Producer localProducer;
             Object localTerminal;
             List<T> q;
+            boolean quit = false;
             synchronized (this) {
                 localRequested = missedRequested;
                 localProducer = missedProducer;
@@ -203,13 +207,21 @@ void emitLoop() {
                 if (localRequested == 0L && localProducer == null && q == null
                         && localTerminal == null) {
                     emitting = false;
-                    return;
+                    quit = true;
+                } else {
+                    missedRequested = 0L;
+                    missedProducer = null;
+                    queue = null;
+                    missedTerminal = null;
                 }
-                missedRequested = 0L;
-                missedProducer = null;
-                queue = null;
-                missedTerminal = null;
             }
+            if (quit) {
+                if (toRequest != 0L && requestFrom != null) {
+                    requestFrom.request(toRequest);
+                }
+                return;
+            }
+            
             boolean empty = q == null || q.isEmpty();
             if (localTerminal != null) {
                 if (localTerminal != Boolean.TRUE) {
@@ -266,13 +278,15 @@ void emitLoop() {
                 } else {
                     currentProducer = localProducer;
                     if (r != 0L) {
-                        localProducer.request(r);
+                        toRequest = BackpressureUtils.addCap(toRequest, r);
+                        requestFrom = localProducer;
                     }
                 }
             } else {
                 Producer p = currentProducer;
                 if (p != null && localRequested != 0L) {
-                    p.request(localRequested);
+                    toRequest = BackpressureUtils.addCap(toRequest, localRequested);
+                    requestFrom = p;
                 }
             }
         }
diff --git a/src/main/java/rx/internal/schedulers/EventLoopsScheduler.java b/src/main/java/rx/internal/schedulers/EventLoopsScheduler.java
index 76d3f95926..afcf7464ed 100644
--- a/src/main/java/rx/internal/schedulers/EventLoopsScheduler.java
+++ b/src/main/java/rx/internal/schedulers/EventLoopsScheduler.java
@@ -26,8 +26,8 @@
 public class EventLoopsScheduler extends Scheduler implements SchedulerLifecycle {
     /** Manages a fixed number of workers. */
     private static final String THREAD_NAME_PREFIX = "RxComputationThreadPool-";
-    private static final RxThreadFactory THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX);
-    /** 
+    static final RxThreadFactory THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX);
+    /**
      * Key to setting the maximum number of computation scheduler threads.
      * Zero or less is interpreted as use available. Capped by available.
      */
@@ -172,8 +172,8 @@ public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
             return poolWorker.scheduleActual(action, delayTime, unit, timed);
         }
     }
-    
-    private static final class PoolWorker extends NewThreadWorker {
+
+    static final class PoolWorker extends NewThreadWorker {
         PoolWorker(ThreadFactory threadFactory) {
             super(threadFactory);
         }
diff --git a/src/main/java/rx/internal/schedulers/GenericScheduledExecutorService.java b/src/main/java/rx/internal/schedulers/GenericScheduledExecutorService.java
index 8d0d5bdec2..82260207ae 100644
--- a/src/main/java/rx/internal/schedulers/GenericScheduledExecutorService.java
+++ b/src/main/java/rx/internal/schedulers/GenericScheduledExecutorService.java
@@ -35,18 +35,18 @@
 
     private static final String THREAD_NAME_PREFIX = "RxScheduledExecutorPool-";
     private static final RxThreadFactory THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX);
-    
-    /* Schedulers needs acces to this in order to work with the lifecycle. */
-    public final static GenericScheduledExecutorService INSTANCE = new GenericScheduledExecutorService();
-    
-    private final AtomicReference<ScheduledExecutorService> executor;
-    
-    static final ScheduledExecutorService NONE;
+
+    private static final ScheduledExecutorService NONE;
     static {
         NONE = Executors.newScheduledThreadPool(0);
         NONE.shutdownNow();
     }
+
+    /* Schedulers needs acces to this in order to work with the lifecycle. */
+    public final static GenericScheduledExecutorService INSTANCE = new GenericScheduledExecutorService();
     
+    private final AtomicReference<ScheduledExecutorService> executor;
+
     private GenericScheduledExecutorService() {
         executor = new AtomicReference<ScheduledExecutorService>(NONE);
         start();
diff --git a/src/main/java/rx/internal/schedulers/ScheduledAction.java b/src/main/java/rx/internal/schedulers/ScheduledAction.java
index 8ddd18870b..0f7d145a20 100644
--- a/src/main/java/rx/internal/schedulers/ScheduledAction.java
+++ b/src/main/java/rx/internal/schedulers/ScheduledAction.java
@@ -131,7 +131,7 @@ public void addParent(SubscriptionList parent) {
     private final class FutureCompleter implements Subscription {
         private final Future<?> f;
 
-        private FutureCompleter(Future<?> f) {
+        FutureCompleter(Future<?> f) {
             this.f = f;
         }
 
diff --git a/src/main/java/rx/internal/util/BackpressureDrainManager.java b/src/main/java/rx/internal/util/BackpressureDrainManager.java
index 38f714b67f..c90e9591df 100644
--- a/src/main/java/rx/internal/util/BackpressureDrainManager.java
+++ b/src/main/java/rx/internal/util/BackpressureDrainManager.java
@@ -23,7 +23,9 @@
 /**
  * Manages the producer-backpressure-consumer interplay by
  * matching up available elements with requested elements and/or
- * terminal events. 
+ * terminal events.
+ * 
+ * @since 1.1.0
  */
 @Experimental
 public final class BackpressureDrainManager extends AtomicLong implements Producer {
diff --git a/src/main/java/rx/internal/util/BlockingUtils.java b/src/main/java/rx/internal/util/BlockingUtils.java
new file mode 100644
index 0000000000..951e49c83d
--- /dev/null
+++ b/src/main/java/rx/internal/util/BlockingUtils.java
@@ -0,0 +1,59 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.util;
+
+import rx.Subscription;
+import rx.annotations.Experimental;
+
+import java.util.concurrent.CountDownLatch;
+
+/**
+ * Utility functions relating to blocking types.
+ * <p/>
+ * Not intended to be part of the public API.
+ */
+@Experimental
+public final class BlockingUtils {
+
+    private BlockingUtils() { }
+
+    /**
+     * Blocks and waits for a {@link Subscription} to complete.
+     *
+     * @param latch        a CountDownLatch
+     * @param subscription the Subscription to wait on.
+     */
+    @Experimental
+    public static void awaitForComplete(CountDownLatch latch, Subscription subscription) {
+        if (latch.getCount() == 0) {
+            // Synchronous observable completes before awaiting for it.
+            // Skip await so InterruptedException will never be thrown.
+            return;
+        }
+        // block until the subscription completes and then return
+        try {
+            latch.await();
+        } catch (InterruptedException e) {
+            subscription.unsubscribe();
+            // set the interrupted flag again so callers can still get it
+            // for more information see https://github.com/ReactiveX/RxJava/pull/147#issuecomment-13624780
+            Thread.currentThread().interrupt();
+            // using Runtime so it is not checked
+            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);
+        }
+    }
+}
diff --git a/src/main/java/rx/internal/util/IndexedRingBuffer.java b/src/main/java/rx/internal/util/IndexedRingBuffer.java
index f2fe163276..4bf941dee1 100644
--- a/src/main/java/rx/internal/util/IndexedRingBuffer.java
+++ b/src/main/java/rx/internal/util/IndexedRingBuffer.java
@@ -290,7 +290,7 @@ public void unsubscribe() {
         releaseToPool();
     }
 
-    private IndexedRingBuffer() {
+    IndexedRingBuffer() {
     }
 
     /**
@@ -483,8 +483,11 @@ private int forEach(Func1<? super E, Boolean> action, int startIndex, int endInd
     }
 
     private static class ElementSection<E> {
-        private final AtomicReferenceArray<E> array = new AtomicReferenceArray<E>(SIZE);
-        private final AtomicReference<ElementSection<E>> next = new AtomicReference<ElementSection<E>>();
+        final AtomicReferenceArray<E> array = new AtomicReferenceArray<E>(SIZE);
+        final AtomicReference<ElementSection<E>> next = new AtomicReference<ElementSection<E>>();
+
+        ElementSection() {
+        }
 
         ElementSection<E> getNext() {
             if (next.get() != null) {
@@ -506,6 +509,9 @@ private int forEach(Func1<? super E, Boolean> action, int startIndex, int endInd
 
         private final AtomicIntegerArray unsafeArray = new AtomicIntegerArray(SIZE);
 
+        IndexSection() {
+        }
+
         public int getAndSet(int expected, int newValue) {
             return unsafeArray.getAndSet(expected, newValue);
         }
diff --git a/src/main/java/rx/internal/util/ObjectPool.java b/src/main/java/rx/internal/util/ObjectPool.java
index 504c10cad4..0aa005208e 100644
--- a/src/main/java/rx/internal/util/ObjectPool.java
+++ b/src/main/java/rx/internal/util/ObjectPool.java
@@ -28,9 +28,9 @@
 import rx.schedulers.Schedulers;
 
 public abstract class ObjectPool<T> implements SchedulerLifecycle {
-    private Queue<T> pool;
-    private final int minSize;
-    private final int maxSize;
+    Queue<T> pool;
+    final int minSize;
+    final int maxSize;
     private final long validationInterval;
 
     private final AtomicReference<Worker> schedulerWorker;
diff --git a/src/main/java/rx/internal/util/ScalarSynchronousObservable.java b/src/main/java/rx/internal/util/ScalarSynchronousObservable.java
index 145a67096e..797a4e4406 100644
--- a/src/main/java/rx/internal/util/ScalarSynchronousObservable.java
+++ b/src/main/java/rx/internal/util/ScalarSynchronousObservable.java
@@ -15,137 +15,273 @@
  */
 package rx.internal.util;
 
-import rx.Observable;
-import rx.Scheduler;
-import rx.Scheduler.Worker;
-import rx.Subscriber;
-import rx.functions.Action0;
-import rx.functions.Func1;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import rx.*;
+import rx.exceptions.Exceptions;
+import rx.functions.*;
+import rx.internal.producers.SingleProducer;
 import rx.internal.schedulers.EventLoopsScheduler;
+import rx.observers.Subscribers;
+import rx.schedulers.Schedulers;
 
+/**
+ * An Observable that emits a single constant scalar value to Subscribers.
+ * <p>
+ * This is a direct implementation of the Observable class to allow identifying it
+ * in flatMap and bypass the subscription to it altogether.
+ *
+ * @param <T> the value type
+ */
 public final class ScalarSynchronousObservable<T> extends Observable<T> {
 
+    /**
+     * We expect the Schedulers.computation() to return an EventLoopsScheduler all the time.
+     */
+    static final Func1<Action0, Subscription> COMPUTATION_ONSCHEDULE = new Func1<Action0, Subscription>() {
+        final EventLoopsScheduler els = (EventLoopsScheduler)Schedulers.computation();
+        
+        @Override
+        public Subscription call(Action0 t) {
+            return els.scheduleDirect(t);
+        }
+    };
+
+    /**
+     * Indicates that the Producer used by this Observable should be fully
+     * threadsafe. It is possible, but unlikely that multiple concurrent
+     * requests will arrive to just().
+     */
+    static final boolean STRONG_MODE;
+    static {
+        String wp = System.getProperty("rx.just.strong-mode", "false");
+        STRONG_MODE = Boolean.valueOf(wp);
+    }
+
+    /**
+     * Creates a scalar producer depending on the state of STRONG_MODE.
+     * @param <T> the type of the scalar value
+     * @param s the target subscriber
+     * @param v the value to emit
+     * @return the created Producer
+     */
+    static <T> Producer createProducer(Subscriber<? super T> s, T v) {
+        if (STRONG_MODE) {
+            return new SingleProducer<T>(s, v);
+        }
+        return new WeakSingleProducer<T>(s, v);
+    }
+    
+    /**
+     * Constructs a ScalarSynchronousObservable with the given constant value.
+     * @param <T> the value type
+     * @param t the value to emit when requested
+     * @return the new Observable
+     */
     public static final <T> ScalarSynchronousObservable<T> create(T t) {
         return new ScalarSynchronousObservable<T>(t);
     }
 
-    private final T t;
+    /** The constant scalar value to emit on request. */
+    final T t;
 
     protected ScalarSynchronousObservable(final T t) {
         super(new OnSubscribe<T>() {
 
             @Override
             public void call(Subscriber<? super T> s) {
-                /*
-                 *  We don't check isUnsubscribed as it is a significant performance impact in the fast-path use cases.
-                 *  See PerfBaseline tests and https://github.com/ReactiveX/RxJava/issues/1383 for more information.
-                 *  The assumption here is that when asking for a single item we should emit it and not concern ourselves with 
-                 *  being unsubscribed already. If the Subscriber unsubscribes at 0, they shouldn't have subscribed, or it will 
-                 *  filter it out (such as take(0)). This prevents us from paying the price on every subscription. 
-                 */
-                s.onNext(t);
-                s.onCompleted();
+                s.setProducer(createProducer(s, t));
             }
 
         });
         this.t = t;
     }
 
+    /**
+     * Returns the scalar constant value directly.
+     * @return the scalar constant value directly
+     */
     public T get() {
         return t;
     }
+    
+    
     /**
      * Customized observeOn/subscribeOn implementation which emits the scalar
      * value directly or with less overhead on the specified scheduler.
      * @param scheduler the target scheduler
      * @return the new observable
      */
-    public Observable<T> scalarScheduleOn(Scheduler scheduler) {
+    public Observable<T> scalarScheduleOn(final Scheduler scheduler) {
+        final Func1<Action0, Subscription> onSchedule;
         if (scheduler instanceof EventLoopsScheduler) {
-            EventLoopsScheduler es = (EventLoopsScheduler) scheduler;
-            return create(new DirectScheduledEmission<T>(es, t));
+            onSchedule = COMPUTATION_ONSCHEDULE;
+        } else {
+            onSchedule = new Func1<Action0, Subscription>() {
+                @Override
+                public Subscription call(final Action0 a) {
+                    final Scheduler.Worker w = scheduler.createWorker();
+                    w.schedule(new Action0() {
+                        @Override
+                        public void call() {
+                            try {
+                                a.call();
+                            } finally {
+                                w.unsubscribe();
+                            }
+                        }
+                    });
+                    return w;
+                }
+            };
         }
-        return create(new NormalScheduledEmission<T>(scheduler, t));
+        
+        return create(new ScalarAsyncOnSubscribe<T>(t, onSchedule));
     }
     
-    /** Optimized observeOn for scalar value observed on the EventLoopsScheduler. */
-    static final class DirectScheduledEmission<T> implements OnSubscribe<T> {
-        private final EventLoopsScheduler es;
-        private final T value;
-        DirectScheduledEmission(EventLoopsScheduler es, T value) {
-            this.es = es;
-            this.value = value;
-        }
-        @Override
-        public void call(final Subscriber<? super T> child) {
-            child.add(es.scheduleDirect(new ScalarSynchronousAction<T>(child, value)));
-        }
-    }
-    /** Emits a scalar value on a general scheduler. */
-    static final class NormalScheduledEmission<T> implements OnSubscribe<T> {
-        private final Scheduler scheduler;
-        private final T value;
+    /**
+     * The OnSubscribe implementation that creates the ScalarAsyncProducer for each
+     * incoming subscriber.
+     *
+     * @param <T> the value type
+     */
+    static final class ScalarAsyncOnSubscribe<T> implements OnSubscribe<T> {
+        final T value;
+        final Func1<Action0, Subscription> onSchedule;
 
-        NormalScheduledEmission(Scheduler scheduler, T value) {
-            this.scheduler = scheduler;
+        ScalarAsyncOnSubscribe(T value, Func1<Action0, Subscription> onSchedule) {
             this.value = value;
+            this.onSchedule = onSchedule;
         }
-        
+
         @Override
-        public void call(final Subscriber<? super T> subscriber) {
-            Worker worker = scheduler.createWorker();
-            subscriber.add(worker);
-            worker.schedule(new ScalarSynchronousAction<T>(subscriber, value));
+        public void call(Subscriber<? super T> s) {
+            s.setProducer(new ScalarAsyncProducer<T>(s, value, onSchedule));
         }
     }
-    /** Action that emits a single value when called. */
-    static final class ScalarSynchronousAction<T> implements Action0 {
-        private final Subscriber<? super T> subscriber;
-        private final T value;
 
-        private ScalarSynchronousAction(Subscriber<? super T> subscriber,
-                T value) {
-            this.subscriber = subscriber;
+    /**
+     * Represents a producer which schedules the emission of a scalar value on
+     * the first positive request via the given scheduler callback.
+     *
+     * @param <T> the value type
+     */
+    static final class ScalarAsyncProducer<T> extends AtomicBoolean implements Producer, Action0 {
+        /** */
+        private static final long serialVersionUID = -2466317989629281651L;
+        final Subscriber<? super T> actual;
+        final T value;
+        final Func1<Action0, Subscription> onSchedule;
+        
+        public ScalarAsyncProducer(Subscriber<? super T> actual, T value, Func1<Action0, Subscription> onSchedule) {
+            this.actual = actual;
             this.value = value;
+            this.onSchedule = onSchedule;
         }
 
+        @Override
+        public void request(long n) {
+            if (n < 0L) {
+                throw new IllegalArgumentException("n >= 0 required but it was " + n);
+            }
+            if (n != 0 && compareAndSet(false, true)) {
+                actual.add(onSchedule.call(this));
+            }
+        }
+        
         @Override
         public void call() {
+            Subscriber<? super T> a = actual;
+            if (a.isUnsubscribed()) {
+                return;
+            }
+            T v = value;
             try {
-                subscriber.onNext(value);
-            } catch (Throwable t) {
-                subscriber.onError(t);
+                a.onNext(v);
+            } catch (Throwable e) {
+                Exceptions.throwOrReport(e, a, v);
+                return;
+            }
+            if (a.isUnsubscribed()) {
                 return;
             }
-            subscriber.onCompleted();
+            a.onCompleted();
+        }
+        
+        @Override
+        public String toString() {
+            return "ScalarAsyncProducer[" + value + ", " + get() + "]";
         }
     }
     
+    /**
+     * Given this scalar source as input to a flatMap, avoid one step of subscription
+     * and subscribes to the single Observable returned by the function.
+     * <p>
+     * If the functions returns another scalar, no subscription happens and this inner
+     * scalar value will be emitted once requested.
+     * @param <R> the result type
+     * @param func the mapper function that returns an Observable for the scalar value of this
+     * @return the new observable
+     */
     public <R> Observable<R> scalarFlatMap(final Func1<? super T, ? extends Observable<? extends R>> func) {
         return create(new OnSubscribe<R>() {
             @Override
             public void call(final Subscriber<? super R> child) {
                 Observable<? extends R> o = func.call(t);
-                if (o.getClass() == ScalarSynchronousObservable.class) {
-                    child.onNext(((ScalarSynchronousObservable<? extends R>)o).t);
-                    child.onCompleted();
+                if (o instanceof ScalarSynchronousObservable) {
+                    child.setProducer(createProducer(child, ((ScalarSynchronousObservable<? extends R>)o).t));
                 } else {
-                    o.unsafeSubscribe(new Subscriber<R>(child) {
-                        @Override
-                        public void onNext(R v) {
-                            child.onNext(v);
-                        }
-                        @Override
-                        public void onError(Throwable e) {
-                            child.onError(e);
-                        }
-                        @Override
-                        public void onCompleted() {
-                            child.onCompleted();
-                        }
-                    });
+                    o.unsafeSubscribe(Subscribers.wrap(child));
                 }
             }
         });
     }
-}
+    
+    /**
+     * This is the weak version of SingleProducer that uses plain fields
+     * to avoid reentrancy and as such is not threadsafe for concurrent
+     * request() calls.
+     *
+     * @param <T> the value type
+     */
+    static final class WeakSingleProducer<T> implements Producer {
+        final Subscriber<? super T> actual;
+        final T value;
+        boolean once;
+        
+        public WeakSingleProducer(Subscriber<? super T> actual, T value) {
+            this.actual = actual;
+            this.value = value;
+        }
+        
+        @Override
+        public void request(long n) {
+            if (once) {
+                return;
+            }
+            if (n < 0L) {
+                throw new IllegalStateException("n >= required but it was " + n);
+            }
+            if (n != 0L) {
+                once = true;
+                Subscriber<? super T> a = actual;
+                if (a.isUnsubscribed()) {
+                    return;
+                }
+                T v = value;
+                try {
+                    a.onNext(v);
+                } catch (Throwable e) {
+                    Exceptions.throwOrReport(e, a, v);
+                    return;
+                }
+                
+                if (a.isUnsubscribed()) {
+                    return;
+                }
+                a.onCompleted();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/util/UtilityFunctions.java b/src/main/java/rx/internal/util/UtilityFunctions.java
index 2a94cb95f9..2d233a4fb1 100644
--- a/src/main/java/rx/internal/util/UtilityFunctions.java
+++ b/src/main/java/rx/internal/util/UtilityFunctions.java
@@ -104,6 +104,9 @@ public Boolean call(Object o) {
             Func8<T0, T1, T2, T3, T4, T5, T6, T7, R>,
             Func9<T0, T1, T2, T3, T4, T5, T6, T7, T8, R>,
             FuncN<R> {
+        NullFunction() {
+        }
+
         @Override
         public R call() {
             return null;
diff --git a/src/main/java/rx/internal/util/unsafe/QueueProgressIndicators.java b/src/main/java/rx/internal/util/unsafe/QueueProgressIndicators.java
new file mode 100644
index 0000000000..185f0bd612
--- /dev/null
+++ b/src/main/java/rx/internal/util/unsafe/QueueProgressIndicators.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * 
+ * Original License: https://github.com/JCTools/JCTools/blob/master/LICENSE
+ * Original location: https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/QueueProgressIndicators.java
+ */
+package rx.internal.util.unsafe;
+
+/**
+ * This interface is provided for monitoring purposes only and is only available on queues where it is easy to
+ * provide it. The producer/consumer progress indicators usually correspond with the number of elements
+ * offered/polled, but they are not guaranteed to maintain that semantic.
+ * 
+ * @author nitsanw
+ *
+ */
+public interface QueueProgressIndicators {
+
+    /**
+     * This method has no concurrent visibility semantics. The value returned may be negative. Under normal
+     * circumstances 2 consecutive calls to this method can offer an idea of progress made by producer threads
+     * by subtracting the 2 results though in extreme cases (if producers have progressed by more than 2^64)
+     * this may also fail.<br/>
+     * This value will normally indicate number of elements passed into the queue, but may under some
+     * circumstances be a derivative of that figure. This method should not be used to derive size or
+     * emptiness.
+     * 
+     * @return the current value of the producer progress index
+     */
+    public long currentProducerIndex();
+
+    /**
+     * This method has no concurrent visibility semantics. The value returned may be negative. Under normal
+     * circumstances 2 consecutive calls to this method can offer an idea of progress made by consumer threads
+     * by subtracting the 2 results though in extreme cases (if consumers have progressed by more than 2^64)
+     * this may also fail.<br/>
+     * This value will normally indicate number of elements taken out of the queue, but may under some
+     * circumstances be a derivative of that figure. This method should not be used to derive size or
+     * emptiness.
+     * 
+     * @return the current value of the consumer progress index
+     */
+    public long currentConsumerIndex();
+}
\ No newline at end of file
diff --git a/src/main/java/rx/internal/util/unsafe/SpscUnboundedArrayQueue.java b/src/main/java/rx/internal/util/unsafe/SpscUnboundedArrayQueue.java
new file mode 100644
index 0000000000..c579864549
--- /dev/null
+++ b/src/main/java/rx/internal/util/unsafe/SpscUnboundedArrayQueue.java
@@ -0,0 +1,290 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * 
+ * Original License: https://github.com/JCTools/JCTools/blob/master/LICENSE
+ * Original location: https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/SpscUnboundedArrayQueue.java
+ */
+package rx.internal.util.unsafe;
+
+import static rx.internal.util.unsafe.UnsafeAccess.*;
+
+import java.lang.reflect.Field;
+import java.util.AbstractQueue;
+import java.util.Iterator;
+
+abstract class SpscUnboundedArrayQueueProducerFields<E> extends AbstractQueue<E> {
+    protected long producerIndex;
+}
+
+abstract class SpscUnboundedArrayQueueProducerColdFields<E> extends SpscUnboundedArrayQueueProducerFields<E> {
+    protected int producerLookAheadStep;
+    protected long producerLookAhead;
+    protected long producerMask;
+    protected E[] producerBuffer;
+}
+
+abstract class SpscUnboundedArrayQueueL2Pad<E> extends SpscUnboundedArrayQueueProducerColdFields<E> {
+    long p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12;
+}
+
+abstract class SpscUnboundedArrayQueueConsumerColdField<E> extends SpscUnboundedArrayQueueL2Pad<E> {
+    protected long consumerMask;
+    protected E[] consumerBuffer;
+}
+
+abstract class SpscUnboundedArrayQueueConsumerField<E> extends SpscUnboundedArrayQueueConsumerColdField<E> {
+    protected long consumerIndex;
+}
+
+public class SpscUnboundedArrayQueue<E> extends SpscUnboundedArrayQueueConsumerField<E>
+    implements QueueProgressIndicators{
+    static final int MAX_LOOK_AHEAD_STEP = Integer.getInteger("jctools.spsc.max.lookahead.step", 4096);
+    private final static long P_INDEX_OFFSET;
+    private final static long C_INDEX_OFFSET;
+    private static final long REF_ARRAY_BASE;
+    private static final int REF_ELEMENT_SHIFT;
+    private static final Object HAS_NEXT = new Object();
+    static {
+        final int scale = UnsafeAccess.UNSAFE.arrayIndexScale(Object[].class);
+        if (4 == scale) {
+            REF_ELEMENT_SHIFT = 2;
+        } else if (8 == scale) {
+            REF_ELEMENT_SHIFT = 3;
+        } else {
+            throw new IllegalStateException("Unknown pointer size");
+        }
+        // Including the buffer pad in the array base offset
+        REF_ARRAY_BASE = UnsafeAccess.UNSAFE.arrayBaseOffset(Object[].class);
+        try {
+            Field iField = SpscUnboundedArrayQueueProducerFields.class.getDeclaredField("producerIndex");
+            P_INDEX_OFFSET = UNSAFE.objectFieldOffset(iField);
+        } catch (NoSuchFieldException e) {
+            throw new RuntimeException(e);
+        }
+        try {
+            Field iField = SpscUnboundedArrayQueueConsumerField.class.getDeclaredField("consumerIndex");
+            C_INDEX_OFFSET = UNSAFE.objectFieldOffset(iField);
+        } catch (NoSuchFieldException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public SpscUnboundedArrayQueue(final int bufferSize) {
+        int p2capacity = Pow2.roundToPowerOfTwo(bufferSize);
+        long mask = p2capacity - 1;
+        E[] buffer = (E[]) new Object[p2capacity + 1];
+        producerBuffer = buffer;
+        producerMask = mask;
+        adjustLookAheadStep(p2capacity);
+        consumerBuffer = buffer;
+        consumerMask = mask;
+        producerLookAhead = mask - 1; // we know it's all empty to start with
+        soProducerIndex(0l);
+    }
+
+    @Override
+    public final Iterator<E> iterator() {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This implementation is correct for single producer thread use only.
+     */
+    @Override
+    public final boolean offer(final E e) {
+        if (null == e) {
+            throw new NullPointerException("Null is not a valid element");
+        }
+        // local load of field to avoid repeated loads after volatile reads
+        final E[] buffer = producerBuffer;
+        final long index = producerIndex;
+        final long mask = producerMask;
+        final long offset = calcWrappedOffset(index, mask);
+        if (index < producerLookAhead) {
+            return writeToQueue(buffer, e, index, offset);
+        } else {
+            final int lookAheadStep = producerLookAheadStep;
+            // go around the buffer or resize if full (unless we hit max capacity)
+            long lookAheadElementOffset = calcWrappedOffset(index + lookAheadStep, mask);
+            if (null == lvElement(buffer, lookAheadElementOffset)) {// LoadLoad
+                producerLookAhead = index + lookAheadStep - 1; // joy, there's plenty of room
+                return writeToQueue(buffer, e, index, offset);
+            } else if (null != lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full
+                return writeToQueue(buffer, e, index, offset);
+            } else {
+                resize(buffer, index, offset, e, mask); // add a buffer and link old to new
+                return true;
+            }
+        }
+    }
+
+    private boolean writeToQueue(final E[] buffer, final E e, final long index, final long offset) {
+        soProducerIndex(index + 1);// this ensures atomic write of long on 32bit platforms
+        soElement(buffer, offset, e);// StoreStore
+        return true;
+    }
+
+    @SuppressWarnings("unchecked")
+    private void resize(final E[] oldBuffer, final long currIndex, final long offset, final E e,
+            final long mask) {
+        final int capacity = oldBuffer.length;
+        final E[] newBuffer = (E[]) new Object[capacity];
+        producerBuffer = newBuffer;
+        producerLookAhead = currIndex + mask - 1;
+        soProducerIndex(currIndex + 1);// this ensures correctness on 32bit platforms
+        soElement(newBuffer, offset, e);// StoreStore
+        soNext(oldBuffer, newBuffer);
+        soElement(oldBuffer, offset, HAS_NEXT); // new buffer is visible after element is
+                                                                 // inserted
+    }
+
+    private void soNext(E[] curr, E[] next) {
+        soElement(curr, calcDirectOffset(curr.length -1), next);
+    }
+    @SuppressWarnings("unchecked")
+    private E[] lvNext(E[] curr) {
+        return (E[]) lvElement(curr, calcDirectOffset(curr.length -1));
+    }
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This implementation is correct for single consumer thread use only.
+     */
+    @SuppressWarnings("unchecked")
+    @Override
+    public final E poll() {
+        // local load of field to avoid repeated loads after volatile reads
+        final E[] buffer = consumerBuffer;
+        final long index = consumerIndex;
+        final long mask = consumerMask;
+        final long offset = calcWrappedOffset(index, mask);
+        final Object e = lvElement(buffer, offset);// LoadLoad
+        boolean isNextBuffer = e == HAS_NEXT;
+        if (null != e && !isNextBuffer) {
+            soConsumerIndex(index + 1);// this ensures correctness on 32bit platforms
+            soElement(buffer, offset, null);// StoreStore
+            return (E) e;
+        } else if (isNextBuffer) {
+            return newBufferPoll(lvNext(buffer), index, mask);
+        }
+
+        return null;
+    }
+
+    @SuppressWarnings("unchecked")
+    private E newBufferPoll(E[] nextBuffer, final long index, final long mask) {
+        consumerBuffer = nextBuffer;
+        final long offsetInNew = calcWrappedOffset(index, mask);
+        final E n = (E) lvElement(nextBuffer, offsetInNew);// LoadLoad
+        if (null == n) {
+            return null;
+        } else {
+            soConsumerIndex(index + 1);// this ensures correctness on 32bit platforms
+            soElement(nextBuffer, offsetInNew, null);// StoreStore
+            return n;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This implementation is correct for single consumer thread use only.
+     */
+    @SuppressWarnings("unchecked")
+    @Override
+    public final E peek() {
+        final E[] buffer = consumerBuffer;
+        final long index = consumerIndex;
+        final long mask = consumerMask;
+        final long offset = calcWrappedOffset(index, mask);
+        final Object e = lvElement(buffer, offset);// LoadLoad
+        if (e == HAS_NEXT) {
+            return newBufferPeek(lvNext(buffer), index, mask);
+        }
+
+        return (E) e;
+    }
+
+    @SuppressWarnings("unchecked")
+    private E newBufferPeek(E[] nextBuffer, final long index, final long mask) {
+        consumerBuffer = nextBuffer;
+        final long offsetInNew = calcWrappedOffset(index, mask);
+        return (E) lvElement(nextBuffer, offsetInNew);// LoadLoad
+    }
+
+    @Override
+    public final int size() {
+        /*
+         * It is possible for a thread to be interrupted or reschedule between the read of the producer and
+         * consumer indices, therefore protection is required to ensure size is within valid range. In the
+         * event of concurrent polls/offers to this method the size is OVER estimated as we read consumer
+         * index BEFORE the producer index.
+         */
+        long after = lvConsumerIndex();
+        while (true) {
+            final long before = after;
+            final long currentProducerIndex = lvProducerIndex();
+            after = lvConsumerIndex();
+            if (before == after) {
+                return (int) (currentProducerIndex - after);
+            }
+        }
+    }
+
+    private void adjustLookAheadStep(int capacity) {
+        producerLookAheadStep = Math.min(capacity / 4, MAX_LOOK_AHEAD_STEP);
+    }
+
+    private long lvProducerIndex() {
+        return UNSAFE.getLongVolatile(this, P_INDEX_OFFSET);
+    }
+
+    private long lvConsumerIndex() {
+        return UNSAFE.getLongVolatile(this, C_INDEX_OFFSET);
+    }
+
+    private void soProducerIndex(long v) {
+        UNSAFE.putOrderedLong(this, P_INDEX_OFFSET, v);
+    }
+
+    private void soConsumerIndex(long v) {
+        UNSAFE.putOrderedLong(this, C_INDEX_OFFSET, v);
+    }
+
+    private static final long calcWrappedOffset(long index, long mask) {
+        return calcDirectOffset(index & mask);
+    }
+    private static final long calcDirectOffset(long index) {
+        return REF_ARRAY_BASE + (index << REF_ELEMENT_SHIFT);
+    }
+    private static final void soElement(Object[] buffer, long offset, Object e) {
+        UNSAFE.putOrderedObject(buffer, offset, e);
+    }
+
+    private static final <E> Object lvElement(E[] buffer, long offset) {
+        return UNSAFE.getObjectVolatile(buffer, offset);
+    }
+    
+    @Override
+    public long currentProducerIndex() {
+        return lvProducerIndex();
+    }
+    
+    @Override
+    public long currentConsumerIndex() {
+        return lvConsumerIndex();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/rx/observables/AbstractOnSubscribe.java b/src/main/java/rx/observables/AbstractOnSubscribe.java
deleted file mode 100644
index 6becdc50a3..0000000000
--- a/src/main/java/rx/observables/AbstractOnSubscribe.java
+++ /dev/null
@@ -1,622 +0,0 @@
-/**
- * Copyright 2014 Netflix, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package rx.observables;
-
-import java.util.Arrays;
-import java.util.concurrent.atomic.*;
-
-import rx.*;
-import rx.Observable.OnSubscribe;
-import rx.annotations.Experimental;
-import rx.exceptions.CompositeException;
-import rx.functions.*;
-import rx.internal.operators.BackpressureUtils;
-
-/**
- * Abstract base class for the {@link OnSubscribe} interface that helps you build Observable sources one
- * {@code onNext} at a time, and automatically supports unsubscription and backpressure.
- * <p>
- * <h1>Usage rules</h1>
- * When you implement the {@code next()} method, you
- * <ul>
- *  <li>should either
- *   <ul>
- *   <li>create the next value and signal it via {@link SubscriptionState#onNext state.onNext()},</li>
- *   <li>signal a terminal condition via {@link SubscriptionState#onError state.onError()}, or
- *       {@link SubscriptionState#onCompleted state.onCompleted()}, or</li>
- *   <li>signal a stop condition via {@link SubscriptionState#stop state.stop()} indicating no further values
- *       will be sent.</li>
- *   </ul>
- *  </li>
- *  <li>may
- *   <ul>
- *   <li>call {@link SubscriptionState#onNext state.onNext()} and either
- *       {@link SubscriptionState#onError state.onError()} or
- *       {@link SubscriptionState#onCompleted state.onCompleted()} together, and
- *   <li>block or sleep.
- *   </ul>
- *  </li>
- *  <li>should not
- *   <ul>
- *   <li>do nothing or do async work and not produce any event or request stopping. If neither of 
- *       the methods are called, an {@link IllegalStateException} is forwarded to the {@code Subscriber} and
- *       the Observable is terminated;</li>
- *   <li>call the {@code state.on}<i>foo</i>() methods more than once (yields
- *       {@link IllegalStateException}).</li>
- *   </ul>
- *  </li>
- * </ul>
- * 
- * The {@link SubscriptionState} object features counters that may help implement a state machine:
- * <ul>
- * <li>A call counter, accessible via {@link SubscriptionState#calls state.calls()} tells how many times the
- *     {@code next()} was run (zero based).</li>
- * <li>You can use a phase counter, accessible via {@link SubscriptionState#phase state.phase}, that helps track
- *     the current emission phase, in a {@code switch()} statement to implement the state machine. (It is named
- *     {@code phase} to avoid confusion with the per-subscriber state.)</li>
- * <li>You can arbitrarily change the current phase with
- *     {@link SubscriptionState#advancePhase state.advancePhase()}, 
- *     {@link SubscriptionState#advancePhaseBy(int) state.advancedPhaseBy(int)} and
- *     {@link SubscriptionState#phase(int) state.phase(int)}.</li>
- * </ul>
- * <p>
- * When you implement {@code AbstractOnSubscribe}, you may override {@link AbstractOnSubscribe#onSubscribe} to
- * perform special actions (such as registering {@code Subscription}s with {@code Subscriber.add()}) and return
- * additional state for each subscriber subscribing. You can access this custom state with the
- * {@link SubscriptionState#state state.state()} method. If you need to do some cleanup, you can override the
- * {@link #onTerminated} method.
- * <p>
- * For convenience, a lambda-accepting static factory method, {@link #create}, is available.
- * Another convenience is {@link #toObservable} which turns an {@code AbstractOnSubscribe}
- * instance into an {@code Observable} fluently.
- * 
- * <h1>Examples</h1>
- * Note: these examples use the lambda-helper factories to avoid boilerplate.
- * 
- * <h3>Implement: just</h3>
- * <pre><code>
- * AbstractOnSubscribe.create(s -> {
- *   s.onNext(1);
- *   s.onCompleted();
- * }).toObservable().subscribe(System.out::println);
- * </code></pre>
-
- * <h3>Implement: from Iterable</h3>
- * <pre><code>
- * Iterable<T> iterable = ...;
- * AbstractOnSubscribe.create(s -> {
- *   Iterator<T> it = s.state();
- *   if (it.hasNext()) {
- *     s.onNext(it.next());
- *   }
- *   if (!it.hasNext()) {
- *     s.onCompleted();
- *   }
- * }, u -> iterable.iterator()).subscribe(System.out::println);
- * </code></pre>
- *
- * <h3>Implement source that fails a number of times before succeeding</h3>
- * <pre><code>
- * AtomicInteger fails = new AtomicInteger();
- * int numFails = 50;
- * AbstractOnSubscribe.create(s -> {
- *   long c = s.calls();
- *   switch (s.phase()) {
- *   case 0:
- *     s.onNext("Beginning");
- *     s.onError(new RuntimeException("Oh, failure.");
- *     if (c == numFails.getAndIncrement()) {
- *       s.advancePhase();
- *     }
- *     break;
- *   case 1:
- *     s.onNext("Beginning");
- *     s.advancePhase();
- *   case 2:
- *     s.onNext("Finally working");
- *     s.onCompleted();
- *     s.advancePhase();
- *   default:
- *     throw new IllegalStateException("How did we get here?");
- *   }
- * }).subscribe(System.out::println);
- * </code></pre>
-
- * <h3>Implement: never</h3>
- * <pre><code>
- * AbstractOnSubscribe.create(s -> {
- *   s.stop();
- * }).toObservable()
- * .timeout(1, TimeUnit.SECONDS)
- * .subscribe(System.out::println, Throwable::printStacktrace, () -> System.out.println("Done"));
- * </code></pre>
- *
- * @param <T> the value type
- * @param <S> the per-subscriber user-defined state type
- * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
- * @Experimental
- */
-@Experimental
-public abstract class AbstractOnSubscribe<T, S> implements OnSubscribe<T> {
-    /**
-     * Called when a Subscriber subscribes and lets the implementor create a per-subscriber custom state.
-     * <p>
-     * Override this method to have custom state per-subscriber. The default implementation returns
-     * {@code null}.
-     *
-     * @param subscriber the subscriber who is subscribing
-     * @return the custom state
-     */
-    protected S onSubscribe(Subscriber<? super T> subscriber) {
-        return null;
-    }
-
-    /**
-     * Called after the terminal emission or when the downstream unsubscribes.
-     * <p>
-     * This is called only once and no {@code onNext} call will run concurrently with it. The default
-     * implementation does nothing.
-     *
-     * @param state the user-provided state
-     */
-    protected void onTerminated(S state) {
-        
-    }
-
-    /**
-     * Override this method to create an emission state-machine.
-     *
-     * @param state the per-subscriber subscription state
-     */
-    protected abstract void next(SubscriptionState<T, S> state);
-
-    @Override
-    public final void call(final Subscriber<? super T> subscriber) {
-        final S custom = onSubscribe(subscriber);
-        final SubscriptionState<T, S> state = new SubscriptionState<T, S>(this, subscriber, custom);
-        subscriber.add(new SubscriptionCompleter<T, S>(state));
-        subscriber.setProducer(new SubscriptionProducer<T, S>(state));
-    }
-    
-    /**
-     * Convenience method to create an Observable from this implemented instance.
-     *
-     * @return the created observable
-     */
-    public final Observable<T> toObservable() {
-        return Observable.create(this);
-    }
-
-    /** Function that returns null. */
-    private static final Func1<Object, Object> NULL_FUNC1 = new Func1<Object, Object>() {
-        @Override
-        public Object call(Object t1) {
-            return null;
-        }
-    };
-    
-    /**
-     * Creates an {@code AbstractOnSubscribe} instance which calls the provided {@code next} action.
-     * <p>
-     * This is a convenience method to help create {@code AbstractOnSubscribe} instances with the help of
-     * lambdas.
-     *
-     * @param <T> the value type
-     * @param <S> the per-subscriber user-defined state type
-     * @param next the next action to call
-     * @return an {@code AbstractOnSubscribe} instance
-     */
-    public static <T, S> AbstractOnSubscribe<T, S> create(Action1<SubscriptionState<T, S>> next) {
-        @SuppressWarnings("unchecked")
-        Func1<? super Subscriber<? super T>, ? extends S> nullFunc =
-                (Func1<? super Subscriber<? super T>, ? extends S>)NULL_FUNC1;
-        return create(next, nullFunc, Actions.empty());
-    }
-
-    /**
-     * Creates an {@code AbstractOnSubscribe} instance which creates a custom state with the {@code onSubscribe}
-     * function and calls the provided {@code next} action.
-     * <p>
-     * This is a convenience method to help create {@code AbstractOnSubscribe} instances with the help of
-     * lambdas.
-     *
-     * @param <T> the value type
-     * @param <S> the per-subscriber user-defined state type
-     * @param next the next action to call
-     * @param onSubscribe the function that returns a per-subscriber state to be used by {@code next}
-     * @return an {@code AbstractOnSubscribe} instance
-     */
-    public static <T, S> AbstractOnSubscribe<T, S> create(Action1<SubscriptionState<T, S>> next,
-            Func1<? super Subscriber<? super T>, ? extends S> onSubscribe) {
-        return create(next, onSubscribe, Actions.empty());
-    }
-
-    /**
-     * Creates an {@code AbstractOnSubscribe} instance which creates a custom state with the {@code onSubscribe}
-     * function, calls the provided {@code next} action and calls the {@code onTerminated} action to release the
-     * state when its no longer needed.
-     * <p>
-     * This is a convenience method to help create {@code AbstractOnSubscribe} instances with the help of
-     * lambdas.
-     *
-     * @param <T> the value type
-     * @param <S> the per-subscriber user-defined state type
-     * @param next the next action to call
-     * @param onSubscribe the function that returns a per-subscriber state to be used by {@code next}
-     * @param onTerminated the action to call to release the state created by the {@code onSubscribe} function
-     * @return an {@code AbstractOnSubscribe} instance
-     */
-    public static <T, S> AbstractOnSubscribe<T, S> create(Action1<SubscriptionState<T, S>> next,
-            Func1<? super Subscriber<? super T>, ? extends S> onSubscribe, Action1<? super S> onTerminated) {
-        return new LambdaOnSubscribe<T, S>(next, onSubscribe, onTerminated);
-    }
-
-    /**
-     * An implementation that forwards the three main methods ({@code next}, {@code onSubscribe}, and
-     * {@code onTermianted}) to functional callbacks.
-     *
-     * @param <T> the value type
-     * @param <S> the per-subscriber user-defined state type
-     */
-    private static final class LambdaOnSubscribe<T, S> extends AbstractOnSubscribe<T, S> {
-        final Action1<SubscriptionState<T, S>> next;
-        final Func1<? super Subscriber<? super T>, ? extends S> onSubscribe;
-        final Action1<? super S> onTerminated;
-        private LambdaOnSubscribe(Action1<SubscriptionState<T, S>> next,
-                Func1<? super Subscriber<? super T>, ? extends S> onSubscribe, Action1<? super S> onTerminated) {
-            this.next = next;
-            this.onSubscribe = onSubscribe;
-            this.onTerminated = onTerminated;
-        }
-        @Override
-        protected S onSubscribe(Subscriber<? super T> subscriber) {
-            return onSubscribe.call(subscriber);
-        }
-        @Override
-        protected void onTerminated(S state) {
-            onTerminated.call(state);
-        }
-        @Override
-        protected void next(SubscriptionState<T, S> state) {
-            next.call(state);
-        }
-    }
-
-    /**
-     * Manages unsubscription of the state.
-     *
-     * @param <T> the value type
-     * @param <S> the per-subscriber user-defined state type
-     */
-    private static final class SubscriptionCompleter<T, S> extends AtomicBoolean implements Subscription {
-        private static final long serialVersionUID = 7993888274897325004L;
-        private final SubscriptionState<T, S> state;
-        private SubscriptionCompleter(SubscriptionState<T, S> state) {
-            this.state = state;
-        }
-        @Override
-        public boolean isUnsubscribed() {
-            return get();
-        }
-        @Override
-        public void unsubscribe() {
-            if (compareAndSet(false, true)) {
-                state.free();
-            }
-        }
-
-    }
-    /**
-     * Contains the producer loop that reacts to downstream requests of work.
-     *
-     * @param <T> the value type
-     * @param <S> the per-subscriber user-defined state type
-     */
-    private static final class SubscriptionProducer<T, S> implements Producer {
-        final SubscriptionState<T, S> state;
-        private SubscriptionProducer(SubscriptionState<T, S> state) {
-            this.state = state;
-        }
-        @Override
-        public void request(long n) {
-            if (n > 0 && BackpressureUtils.getAndAddRequest(state.requestCount, n) == 0) {
-                if (n == Long.MAX_VALUE) {
-                    // fast-path
-                    for (; !state.subscriber.isUnsubscribed(); ) {
-                        if (!doNext()) {
-                            break;
-                        }
-                    }
-                } else 
-                if (!state.subscriber.isUnsubscribed()) {
-                    do {
-                        if (!doNext()) {
-                            break;
-                        }
-                    } while (state.requestCount.decrementAndGet() > 0 && !state.subscriber.isUnsubscribed());
-                }
-            }
-        }
-
-        /**
-         * Executes the user-overridden next() method and performs state bookkeeping and
-         * verification.
-         *
-         * @return true if the outer loop may continue
-         */
-        protected boolean doNext() {
-            if (state.use()) {
-                try {
-                    int p = state.phase();
-                    state.parent.next(state);
-                    if (!state.verify()) {
-                        throw new IllegalStateException("No event produced or stop called @ Phase: " + p + " -> " + state.phase() + ", Calls: " + state.calls());
-                    }
-                    if (state.accept() || state.stopRequested()) {
-                        state.terminate();
-                        return false;
-                    }
-                    state.calls++;
-                } catch (Throwable t) {
-                    state.terminate();
-                    state.subscriber.onError(t);
-                    return false;
-                } finally {
-                    state.free();
-                }
-                return true;
-            }
-            return false;
-        }
-    }
-
-    /**
-     * Represents a per-subscription state for the {@code AbstractOnSubscribe} operation. It supports phasing
-     * and counts the number of times a value was requested by the downstream.
-     *
-     * @param <T> the value type 
-     * @param <S> the per-subscriber user-defined state type
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
-     * @Experimental
-     */
-    public static final class SubscriptionState<T, S> {
-        private final AbstractOnSubscribe<T, S> parent;
-        private final Subscriber<? super T> subscriber;
-        private final S state;
-        private final AtomicLong requestCount;
-        private final AtomicInteger inUse;
-        private int phase;
-        private long calls;
-        private T theValue;
-        private boolean hasOnNext;
-        private boolean hasCompleted;
-        private boolean stopRequested;
-        private Throwable theException;
-        private SubscriptionState(AbstractOnSubscribe<T, S> parent, Subscriber<? super T> subscriber, S state) {
-            this.parent = parent;
-            this.subscriber = subscriber;
-            this.state = state;
-            this.requestCount = new AtomicLong();
-            this.inUse = new AtomicInteger(1);
-        }
-
-        /**
-         * @return the per-subscriber specific user-defined state created via
-         *         {@link AbstractOnSubscribe#onSubscribe}
-         */
-        public S state() {
-            return state;
-        }
-
-        /**
-         * @return the current phase value
-         */
-        public int phase() {
-            return phase;
-        }
-
-        /**
-         * Sets a new phase value.
-         *
-         * @param newPhase
-         */
-        public void phase(int newPhase) {
-            phase = newPhase;
-        }
-
-        /**
-         * Advance the current phase by 1.
-         */
-        public void advancePhase() {
-            advancePhaseBy(1);
-        }
-
-        /**
-         * Advance the current phase by the given amount (can be negative).
-         *
-         * @param amount the amount to advance the phase
-         */
-        public void advancePhaseBy(int amount) {
-            phase += amount;
-        }
-
-        /**
-         * @return the number of times {@link AbstractOnSubscribe#next} was called so far, starting at 0 for the
-         *         very first call
-         */
-        public long calls() {
-            return calls;
-        }
-
-        /**
-         * Call this method to offer the next {@code onNext} value for the subscriber.
-         * 
-         * @param value the value to {@code onNext}
-         * @throws IllegalStateException if there is a value already offered but not taken or a terminal state
-         *         is reached
-         */
-        public void onNext(T value) {
-            if (hasOnNext) {
-                throw new IllegalStateException("onNext not consumed yet!");
-            } else
-            if (hasCompleted) {
-                throw new IllegalStateException("Already terminated", theException);
-            }
-            theValue = value;
-            hasOnNext = true;
-        }
-
-        /**
-         * Call this method to send an {@code onError} to the subscriber and terminate all further activities.
-         * If there is a pending {@code onNext}, that value is emitted to the subscriber followed by this
-         * exception.
-         * 
-         * @param e the exception to deliver to the client
-         * @throws IllegalStateException if the terminal state has been reached already
-         */
-        public void onError(Throwable e) {
-            if (e == null) {
-                throw new NullPointerException("e != null required");
-            }
-            if (hasCompleted) {
-                throw new IllegalStateException("Already terminated", theException);
-            }
-            theException = e;
-            hasCompleted = true;
-        }
-
-        /**
-         * Call this method to send an {@code onCompleted} to the subscriber and terminate all further
-         * activities. If there is a pending {@code onNext}, that value is emitted to the subscriber followed by
-         * this exception.
-         * 
-         * @throws IllegalStateException if the terminal state has been reached already
-         */
-        public void onCompleted() {
-            if (hasCompleted) {
-                throw new IllegalStateException("Already terminated", theException);
-            }
-            hasCompleted = true;
-        }
-
-        /**
-         * Signals that there won't be any further events.
-         */
-        public void stop() {
-            stopRequested = true;
-        }
-
-        /**
-         * Emits the {@code onNext} and/or the terminal value to the actual subscriber.
-         *
-         * @return {@code true} if the event was a terminal event
-         */
-        protected boolean accept() {
-            if (hasOnNext) {
-                T value = theValue;
-                theValue = null;
-                hasOnNext = false;
-                
-                try {
-                    subscriber.onNext(value);
-                } catch (Throwable t) {
-                    hasCompleted = true;
-                    Throwable e = theException;
-                    theException = null;
-                    if (e == null) {
-                        subscriber.onError(t);
-                    } else {
-                        subscriber.onError(new CompositeException(Arrays.asList(t, e)));
-                    }
-                    return true;
-                }
-            }
-            if (hasCompleted) {
-                Throwable e = theException;
-                theException = null;
-                
-                if (e != null) {
-                    subscriber.onError(e);
-                } else {
-                    subscriber.onCompleted();
-                }
-                return true;
-            }
-            return false;
-        }
-
-        /**
-         * Verify if the {@code next()} generated an event or requested a stop.
-         *
-         * @return true if either event was generated or stop was requested
-         */
-        protected boolean verify() {
-            return hasOnNext || hasCompleted || stopRequested;
-        }
-
-        /** @return true if the {@code next()} requested a stop */
-        protected boolean stopRequested() {
-            return stopRequested;
-        }
-
-        /**
-         * Request the state to be used by {@code onNext} or returns {@code false} if the downstream has
-         * unsubscribed.
-         *
-         * @return {@code true} if the state can be used exclusively
-         * @throws IllegalStateEception
-         * @warn "throws" section incomplete
-         */
-        protected boolean use() {
-            int i = inUse.get();
-            if (i == 0) {
-                return false;
-            } else
-            if (i == 1 && inUse.compareAndSet(1, 2)) {
-                return true;
-            }
-            throw new IllegalStateException("This is not reentrant nor threadsafe!");
-        }
-
-        /**
-         * Release the state if there are no more interest in it and it is not in use.
-         */
-        protected void free() {
-            int i = inUse.get();
-            if (i > 0 && inUse.decrementAndGet() == 0) {
-                parent.onTerminated(state);
-            }
-        }
-
-        /**
-         * Terminates the state immediately and calls {@link AbstractOnSubscribe#onTerminated} with the custom
-         * state.
-         */
-        protected void terminate() {
-            for (;;) {
-                int i = inUse.get();
-                if (i <= 0) {
-                    return;
-                }
-                if (inUse.compareAndSet(i, 0)) {
-                    parent.onTerminated(state);
-                    break;
-                }
-            }
-        }
-    }
-}
diff --git a/src/main/java/rx/observables/AsyncOnSubscribe.java b/src/main/java/rx/observables/AsyncOnSubscribe.java
index 61cbe79e7c..d95dc82b9d 100644
--- a/src/main/java/rx/observables/AsyncOnSubscribe.java
+++ b/src/main/java/rx/observables/AsyncOnSubscribe.java
@@ -264,7 +264,7 @@ public void call(Void t) {
         private final Func3<? super S, Long, ? super Observer<Observable<? extends T>>, ? extends S> next;
         private final Action1<? super S> onUnsubscribe;
 
-        private AsyncOnSubscribeImpl(Func0<? extends S> generator, Func3<? super S, Long, ? super Observer<Observable<? extends T>>, ? extends S> next, Action1<? super S> onUnsubscribe) {
+        AsyncOnSubscribeImpl(Func0<? extends S> generator, Func3<? super S, Long, ? super Observer<Observable<? extends T>>, ? extends S> next, Action1<? super S> onUnsubscribe) {
             this.generator = generator;
             this.next = next;
             this.onUnsubscribe = onUnsubscribe;
@@ -355,7 +355,7 @@ public void setProducer(Producer p) {
 
         private final AsyncOnSubscribe<S, T> parent;
         private final SerializedObserver<Observable<? extends T>> serializedSubscriber;
-        private final CompositeSubscription subscriptions = new CompositeSubscription();
+        final CompositeSubscription subscriptions = new CompositeSubscription();
 
         private boolean hasTerminated;
         private boolean onNextCalled;
@@ -647,7 +647,7 @@ public void onNext(T t) {
         }
 
         static final class State<T> implements OnSubscribe<T> {
-            private Subscriber<? super T> subscriber;
+            Subscriber<? super T> subscriber;
             @Override
             public void call(Subscriber<? super T> s) {
                 synchronized (this) {
diff --git a/src/main/java/rx/observables/BlockingObservable.java b/src/main/java/rx/observables/BlockingObservable.java
index 5463e9696e..c5b3588e32 100644
--- a/src/main/java/rx/observables/BlockingObservable.java
+++ b/src/main/java/rx/observables/BlockingObservable.java
@@ -26,6 +26,7 @@
 import rx.exceptions.OnErrorNotImplementedException;
 import rx.functions.*;
 import rx.internal.operators.*;
+import rx.internal.util.BlockingUtils;
 import rx.internal.util.UtilityFunctions;
 import rx.subscriptions.Subscriptions;
 
@@ -123,7 +124,7 @@ public void onNext(T args) {
                 onNext.call(args);
             }
         });
-        awaitForComplete(latch, subscription);
+        BlockingUtils.awaitForComplete(latch, subscription);
 
         if (exceptionFromOnError.get() != null) {
             if (exceptionFromOnError.get() instanceof RuntimeException) {
@@ -446,7 +447,7 @@ public void onNext(final T item) {
                 returnItem.set(item);
             }
         });
-        awaitForComplete(latch, subscription);
+        BlockingUtils.awaitForComplete(latch, subscription);
 
         if (returnException.get() != null) {
             if (returnException.get() instanceof RuntimeException) {
@@ -458,25 +459,6 @@ public void onNext(final T item) {
 
         return returnItem.get();
     }
-
-    private void awaitForComplete(CountDownLatch latch, Subscription subscription) {
-        if (latch.getCount() == 0) {
-            // Synchronous observable completes before awaiting for it.
-            // Skip await so InterruptedException will never be thrown.
-            return;
-        }
-        // block until the subscription completes and then return
-        try {
-            latch.await();
-        } catch (InterruptedException e) {
-            subscription.unsubscribe();
-            // set the interrupted flag again so callers can still get it
-            // for more information see https://github.com/ReactiveX/RxJava/pull/147#issuecomment-13624780
-            Thread.currentThread().interrupt();
-            // using Runtime so it is not checked
-            throw new RuntimeException("Interrupted while waiting for subscription to complete.", e);
-        }
-    }
     
     /**
      * Runs the source observable to a terminal event, ignoring any values and rethrowing any exception.
@@ -502,7 +484,7 @@ public void onCompleted() {
             }
         });
         
-        awaitForComplete(cdl, s);
+        BlockingUtils.awaitForComplete(cdl, s);
         Throwable e = error[0];
         if (e != null) {
             if (e instanceof RuntimeException) {
@@ -556,14 +538,14 @@ public void onCompleted() {
     }
     
     /** Constant to indicate the onStart method should be called. */
-    private static final Object ON_START = new Object();
-    
+    static final Object ON_START = new Object();
+
     /** Constant indicating the setProducer method should be called. */
-    private static final Object SET_PRODUCER = new Object();
+    static final Object SET_PRODUCER = new Object();
 
     /** Indicates an unsubscripton happened */
-    private static final Object UNSUBSCRIBE = new Object();
-    
+    static final Object UNSUBSCRIBE = new Object();
+
     /**
      * Subscribes to the source and calls the Subscriber methods on the current thread.
      * <p>
diff --git a/src/main/java/rx/observables/ConnectableObservable.java b/src/main/java/rx/observables/ConnectableObservable.java
index 868c2d3071..fe78ae55cd 100644
--- a/src/main/java/rx/observables/ConnectableObservable.java
+++ b/src/main/java/rx/observables/ConnectableObservable.java
@@ -16,7 +16,7 @@
 package rx.observables;
 
 import rx.*;
-import rx.annotations.Experimental;
+import rx.annotations.Beta;
 import rx.functions.*;
 import rx.internal.operators.*;
 
@@ -88,7 +88,7 @@ public void call(Subscription t1) {
      *         when the first Subscriber subscribes
      * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
      */
-    @Experimental
+    @Beta
     public Observable<T> autoConnect() {
         return autoConnect(1);
     }
@@ -103,7 +103,7 @@ public void call(Subscription t1) {
      *         when the specified number of Subscribers subscribe to it
      * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
      */
-    @Experimental
+    @Beta
     public Observable<T> autoConnect(int numberOfSubscribers) {
         return autoConnect(numberOfSubscribers, Actions.empty());
     }
@@ -123,7 +123,7 @@ public void call(Subscription t1) {
      *         specified callback with the Subscription associated with the established connection
      * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
      */
-    @Experimental
+    @Beta
     public Observable<T> autoConnect(int numberOfSubscribers, Action1<? super Subscription> connection) {
         if (numberOfSubscribers <= 0) {
             this.connect(connection);
diff --git a/src/main/java/rx/observables/SyncOnSubscribe.java b/src/main/java/rx/observables/SyncOnSubscribe.java
index c75173a094..707e047b2a 100644
--- a/src/main/java/rx/observables/SyncOnSubscribe.java
+++ b/src/main/java/rx/observables/SyncOnSubscribe.java
@@ -271,7 +271,7 @@ public void call(Void t) {
         private final Func2<? super S, ? super Observer<? super T>, ? extends S> next;
         private final Action1<? super S> onUnsubscribe;
 
-        private SyncOnSubscribeImpl(Func0<? extends S> generator, Func2<? super S, ? super Observer<? super T>, ? extends S> next, Action1<? super S> onUnsubscribe) {
+        SyncOnSubscribeImpl(Func0<? extends S> generator, Func2<? super S, ? super Observer<? super T>, ? extends S> next, Action1<? super S> onUnsubscribe) {
             this.generator = generator;
             this.next = next;
             this.onUnsubscribe = onUnsubscribe;
@@ -322,8 +322,8 @@ protected void onUnsubscribe(S state) {
         private boolean hasTerminated;
         
         private S state;
-        
-        private SubscriptionProducer(final Subscriber<? super T> subscriber, SyncOnSubscribe<S, T> parent, S state) {
+
+        SubscriptionProducer(final Subscriber<? super T> subscriber, SyncOnSubscribe<S, T> parent, S state) {
             this.actualSubscriber = subscriber;
             this.parent = parent;
             this.state = state;
diff --git a/src/main/java/rx/observers/Subscribers.java b/src/main/java/rx/observers/Subscribers.java
index 4e81c1af8d..c1d2e4d014 100644
--- a/src/main/java/rx/observers/Subscribers.java
+++ b/src/main/java/rx/observers/Subscribers.java
@@ -15,12 +15,9 @@
  */
 package rx.observers;
 
-import rx.Observer;
-import rx.Subscriber;
-import rx.annotations.Experimental;
+import rx.*;
 import rx.exceptions.OnErrorNotImplementedException;
-import rx.functions.Action0;
-import rx.functions.Action1;
+import rx.functions.*;
 
 /**
  * Helper methods and utilities for creating and working with {@link Subscriber} objects.
@@ -213,9 +210,8 @@ public final void onNext(T args) {
      *         <code>subscriber</code>, has backpressure controlled by
      *         <code>subscriber</code> and uses <code>subscriber</code> to
      *         manage unsubscription.
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public static <T> Subscriber<T> wrap(final Subscriber<? super T> subscriber) {
         return new Subscriber<T>(subscriber) {
 
diff --git a/src/main/java/rx/observers/TestSubscriber.java b/src/main/java/rx/observers/TestSubscriber.java
index 2d46a25179..6b9cf90d3e 100644
--- a/src/main/java/rx/observers/TestSubscriber.java
+++ b/src/main/java/rx/observers/TestSubscriber.java
@@ -20,7 +20,6 @@
 
 import rx.*;
 import rx.Observer;
-import rx.annotations.Experimental;
 import rx.exceptions.CompositeException;
 
 /**
@@ -58,10 +57,9 @@ public void onNext(Object t) {
      * Constructs a TestSubscriber with the initial request to be requested from upstream.
      *
      * @param initialRequest the initial request value, negative value will revert to the default unbounded behavior
-     * @since (if this graduates from "Experimental" replace this parenthetical with the release number)
+     * @since 1.1.0
      */
     @SuppressWarnings("unchecked")
-    @Experimental
     public TestSubscriber(long initialRequest) {
         this((Observer<T>)INERT, initialRequest);
     }
@@ -72,9 +70,9 @@ public TestSubscriber(long initialRequest) {
      *
      * @param initialRequest the initial request value, negative value will revert to the default unbounded behavior
      * @param delegate the Observer instance to wrap
-     * @since (if this graduates from "Experimental" replace this parenthetical with the release number)
+     * @throws NullPointerException if delegate is null
+     * @since 1.1.0
      */
-    @Experimental
     public TestSubscriber(Observer<T> delegate, long initialRequest) {
         if (delegate == null) {
             throw new NullPointerException();
@@ -83,46 +81,94 @@ public TestSubscriber(Observer<T> delegate, long initialRequest) {
         this.initialRequest = initialRequest;
     }
 
+    /**
+     * Constructs a TestSubscriber which requests Long.MAX_VALUE and delegates events to
+     * the given Subscriber.
+     * @param delegate the subscriber to delegate to.
+     * @throws NullPointerException if delegate is null
+     * @since 1.1.0
+     */
     public TestSubscriber(Subscriber<T> delegate) {
         this(delegate, -1);
     }
 
+    /**
+     * Constructs a TestSubscriber which requests Long.MAX_VALUE and delegates events to
+     * the given Observer.
+     * @param delegate the observer to delegate to.
+     * @throws NullPointerException if delegate is null
+     * @since 1.1.0
+     */
     public TestSubscriber(Observer<T> delegate) {
         this(delegate, -1);
     }
 
+    /**
+     * Constructs a TestSubscriber with an initial request of Long.MAX_VALUE and no delegation.
+     */
     public TestSubscriber() {
         this(-1);
     }
-    
-    @Experimental
+
+    /**
+     * Factory method to construct a TestSubscriber with an initial request of Long.MAX_VALUE and no delegation.
+     * @return the created TestSubscriber instance
+     * @since 1.1.0
+     */
     public static <T> TestSubscriber<T> create() {
         return new TestSubscriber<T>();
     }
     
-    @Experimental
+    /**
+     * Factory method to construct a TestSubscriber with the given initial request amount and no delegation.
+     * @param initialRequest the initial request amount, negative values revert to the default unbounded mode
+     * @return the created TestSubscriber instance
+     * @since 1.1.0
+     */
     public static <T> TestSubscriber<T> create(long initialRequest) {
         return new TestSubscriber<T>(initialRequest);
     }
     
-    @Experimental
+    /**
+     * Factory method to construct a TestSubscriber which delegates events to the given Observer and
+     * issues the given initial request amount.
+     * @param delegate the observer to delegate events to
+     * @param initialRequest the initial request amount, negative values revert to the default unbounded mode
+     * @return the created TestSubscriber instance
+     * @throws NullPointerException if delegate is null
+     * @since 1.1.0
+     */
     public static <T> TestSubscriber<T> create(Observer<T> delegate, long initialRequest) {
         return new TestSubscriber<T>(delegate, initialRequest);
     }
     
-    @Experimental
+    /**
+     * Factory method to construct a TestSubscriber which delegates events to the given Observer and
+     * an issues an initial request of Long.MAX_VALUE.
+     * @param delegate the observer to delegate events to
+     * @return the created TestSubscriber instance
+     * @throws NullPointerException if delegate is null
+     * @since 1.1.0
+     */
     public static <T> TestSubscriber<T> create(Subscriber<T> delegate) {
         return new TestSubscriber<T>(delegate);
     }
     
-    @Experimental
+    /**
+     * Factory method to construct a TestSubscriber which delegates events to the given Subscriber and
+     * an issues an initial request of Long.MAX_VALUE.
+     * @param delegate the subscriber to delegate events to
+     * @return the created TestSubscriber instance
+     * @throws NullPointerException if delegate is null
+     * @since 1.1.0
+     */
     public static <T> TestSubscriber<T> create(Observer<T> delegate) {
         return new TestSubscriber<T>(delegate);
     }
     
     @Override
     public void onStart() {
-        if  (initialRequest >= 0) {
+        if (initialRequest >= 0) {
             requestMore(initialRequest);
         }
     }
@@ -343,9 +389,8 @@ public Thread getLastSeenThread() {
      * Asserts that there is exactly one completion event.
      *
      * @throws AssertionError if there were zero, or more than one, onCompleted events
-     * @since (if this graduates from "Experimental" replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public void assertCompleted() {
         int s = testObserver.getOnCompletedEvents().size();
         if (s == 0) {
@@ -360,9 +405,8 @@ public void assertCompleted() {
      * Asserts that there is no completion event.
      *
      * @throws AssertionError if there were one or more than one onCompleted events
-     * @since (if this graduates from "Experimental" replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public void assertNotCompleted() {
         int s = testObserver.getOnCompletedEvents().size();
         if (s == 1) {
@@ -379,9 +423,8 @@ public void assertNotCompleted() {
      * @param clazz the class to check the error against.
      * @throws AssertionError if there were zero, or more than one, onError events, or if the single onError
      *                        event did not carry an error of a subclass of the given class
-     * @since (if this graduates from "Experimental" replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public void assertError(Class<? extends Throwable> clazz) {
         List<Throwable> err = testObserver.getOnErrorEvents();
         if (err.size() == 0) {
@@ -405,9 +448,8 @@ public void assertError(Class<? extends Throwable> clazz) {
      * @param throwable the throwable to check
      * @throws AssertionError if there were zero, or more than one, onError events, or if the single onError
      *                        event did not carry an error that matches the specified throwable
-     * @since (if this graduates from "Experimental" replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public void assertError(Throwable throwable) {
         List<Throwable> err = testObserver.getOnErrorEvents();
         if (err.size() == 0) {
@@ -429,9 +471,8 @@ public void assertError(Throwable throwable) {
      * Asserts that there are no onError and onCompleted events.
      *
      * @throws AssertionError if there was either an onError or onCompleted event
-     * @since (if this graduates from "Experimental" replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public void assertNoTerminalEvent() {
         List<Throwable> err = testObserver.getOnErrorEvents();
         int s = testObserver.getOnCompletedEvents().size();
@@ -455,9 +496,8 @@ public void assertNoTerminalEvent() {
      * Asserts that there are no onNext events received.
      *
      * @throws AssertionError if there were any onNext events
-     * @since (if this graduates from "Experimental" replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public void assertNoValues() {
         int s = testObserver.getOnNextEvents().size();
         if (s > 0) {
@@ -470,9 +510,8 @@ public void assertNoValues() {
      *
      * @param count the expected number of onNext events
      * @throws AssertionError if there were more or fewer onNext events than specified by {@code count}
-     * @since (if this graduates from "Experimental" replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public void assertValueCount(int count) {
         int s = testObserver.getOnNextEvents().size();
         if (s != count) {
@@ -485,9 +524,8 @@ public void assertValueCount(int count) {
      *
      * @param values the items to check
      * @throws AssertionError if the items emitted do not exactly match those specified by {@code values}
-     * @since (if this graduates from "Experimental" replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public void assertValues(T... values) {
         assertReceivedOnNext(Arrays.asList(values));
     }
@@ -497,9 +535,8 @@ public void assertValues(T... values) {
      *
      * @param value the item to check
      * @throws AssertionError if the Observable does not emit only the single item specified by {@code value}
-     * @since (if this graduates from "Experimental" replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public void assertValue(T value) {
         assertReceivedOnNext(Collections.singletonList(value));
     }
diff --git a/src/main/java/rx/plugins/RxJavaErrorHandler.java b/src/main/java/rx/plugins/RxJavaErrorHandler.java
index 85a21d447a..a6e56475ed 100644
--- a/src/main/java/rx/plugins/RxJavaErrorHandler.java
+++ b/src/main/java/rx/plugins/RxJavaErrorHandler.java
@@ -15,9 +15,8 @@
  */
 package rx.plugins;
 
-import rx.Observable;
-import rx.Subscriber;
-import rx.annotations.Experimental;
+import rx.*;
+import rx.annotations.Beta;
 import rx.exceptions.Exceptions;
 
 /**
@@ -67,7 +66,7 @@ public void handleError(Throwable e) {
      * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the
      *        release number)
      */
-    @Experimental
+    @Beta
     public final String handleOnNextValueRendering(Object item) {
 
         try {
@@ -98,7 +97,7 @@ public final String handleOnNextValueRendering(Object item) {
      * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the
      *        release number)
      */
-    @Experimental
+    @Beta
     protected String render (Object item) throws InterruptedException {
         //do nothing by default
         return null;
diff --git a/src/main/java/rx/plugins/RxJavaPlugins.java b/src/main/java/rx/plugins/RxJavaPlugins.java
index 2e48305989..09e542779d 100644
--- a/src/main/java/rx/plugins/RxJavaPlugins.java
+++ b/src/main/java/rx/plugins/RxJavaPlugins.java
@@ -15,6 +15,7 @@
  */
 package rx.plugins;
 
+import java.util.*;
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
@@ -26,7 +27,22 @@
  * property names)</li>
  * <li>default implementation</li>
  * </ol>
- *
+ * <p>In addition to the {@code rxjava.plugin.[simple classname].implementation} system properties,
+ * you can define two system property:<br>
+ * <pre><code>
+ * rxjava.plugin.[index].class}
+ * rxjava.plugin.[index].impl}
+ * </code></pre>
+ * 
+ * Where the {@code .class} property contains the simple classname from above and the {@code .impl}
+ * contains the fully qualified name of the implementation class. The {@code [index]} can be
+ * any short string or number of your chosing. For example, you can now define a custom 
+ * {@code RxJavaErrorHandler} via two system property:
+ * <pre><code>
+ * rxjava.plugin.1.class=RxJavaErrorHandler
+ * rxjava.plugin.1.impl=some.package.MyRxJavaErrorHandler
+ * </code></pre>
+ * 
  * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Plugins">RxJava Wiki: Plugins</a>
  */
 public class RxJavaPlugins {
@@ -64,13 +80,12 @@ public static RxJavaPlugins getInstance() {
      * <p>
      * Override the default by calling {@link #registerErrorHandler(RxJavaErrorHandler)} or by setting the
      * property {@code rxjava.plugin.RxJavaErrorHandler.implementation} with the full classname to load.
-     * 
      * @return {@link RxJavaErrorHandler} implementation to use
      */
     public RxJavaErrorHandler getErrorHandler() {
         if (errorHandler.get() == null) {
             // check for an implementation from System.getProperty first
-            Object impl = getPluginImplementationViaProperty(RxJavaErrorHandler.class);
+            Object impl = getPluginImplementationViaProperty(RxJavaErrorHandler.class, System.getProperties());
             if (impl == null) {
                 // nothing set via properties so initialize with default 
                 errorHandler.compareAndSet(null, DEFAULT_ERROR_HANDLER);
@@ -112,7 +127,7 @@ public void registerErrorHandler(RxJavaErrorHandler impl) {
     public RxJavaObservableExecutionHook getObservableExecutionHook() {
         if (observableExecutionHook.get() == null) {
             // check for an implementation from System.getProperty first
-            Object impl = getPluginImplementationViaProperty(RxJavaObservableExecutionHook.class);
+            Object impl = getPluginImplementationViaProperty(RxJavaObservableExecutionHook.class, System.getProperties());
             if (impl == null) {
                 // nothing set via properties so initialize with default 
                 observableExecutionHook.compareAndSet(null, RxJavaObservableExecutionHookDefault.getInstance());
@@ -141,15 +156,46 @@ public void registerObservableExecutionHook(RxJavaObservableExecutionHook impl)
         }
     }
 
-    private static Object getPluginImplementationViaProperty(Class<?> pluginClass) {
-        String classSimpleName = pluginClass.getSimpleName();
+    /* test */ static Object getPluginImplementationViaProperty(Class<?> pluginClass, Properties props) {
+        final String classSimpleName = pluginClass.getSimpleName();
         /*
          * Check system properties for plugin class.
          * <p>
          * This will only happen during system startup thus it's okay to use the synchronized
          * System.getProperties as it will never get called in normal operations.
          */
-        String implementingClass = System.getProperty("rxjava.plugin." + classSimpleName + ".implementation");
+        
+        final String pluginPrefix = "rxjava.plugin.";
+        
+        String defaultKey = pluginPrefix + classSimpleName + ".implementation";
+        String implementingClass = props.getProperty(defaultKey);
+
+        if (implementingClass == null) {
+            final String classSuffix = ".class";
+            final String implSuffix = ".impl";
+    
+            for (Map.Entry<Object, Object> e : props.entrySet()) {
+                String key = e.getKey().toString();
+                if (key.startsWith(pluginPrefix) && key.endsWith(classSuffix)) {
+                    String value = e.getValue().toString();
+                    
+                    if (classSimpleName.equals(value)) {
+                        String index = key.substring(0, key.length() - classSuffix.length()).substring(pluginPrefix.length());
+                        
+                        String implKey = pluginPrefix + index + implSuffix;
+                        
+                        implementingClass = props.getProperty(implKey);
+                        
+                        if (implementingClass == null) {
+                            throw new RuntimeException("Implementing class declaration for " + classSimpleName + " missing: " + implKey);
+                        }
+                        
+                        break;
+                    }
+                }
+            }
+        }
+
         if (implementingClass != null) {
             try {
                 Class<?> cls = Class.forName(implementingClass);
@@ -165,9 +211,9 @@ private static Object getPluginImplementationViaProperty(Class<?> pluginClass) {
             } catch (IllegalAccessException e) {
                 throw new RuntimeException(classSimpleName + " implementation not able to be accessed: " + implementingClass, e);
             }
-        } else {
-            return null;
         }
+
+        return null;
     }
 
     /**
@@ -183,7 +229,7 @@ private static Object getPluginImplementationViaProperty(Class<?> pluginClass) {
     public RxJavaSchedulersHook getSchedulersHook() {
         if (schedulersHook.get() == null) {
             // check for an implementation from System.getProperty first
-            Object impl = getPluginImplementationViaProperty(RxJavaSchedulersHook.class);
+            Object impl = getPluginImplementationViaProperty(RxJavaSchedulersHook.class, System.getProperties());
             if (impl == null) {
                 // nothing set via properties so initialize with default
                 schedulersHook.compareAndSet(null, RxJavaSchedulersHook.getDefaultInstance());
diff --git a/src/main/java/rx/schedulers/CachedThreadScheduler.java b/src/main/java/rx/schedulers/CachedThreadScheduler.java
index 6ef56a17cb..31c6f9288f 100644
--- a/src/main/java/rx/schedulers/CachedThreadScheduler.java
+++ b/src/main/java/rx/schedulers/CachedThreadScheduler.java
@@ -26,11 +26,11 @@
 
 /* package */final class CachedThreadScheduler extends Scheduler implements SchedulerLifecycle {
     private static final String WORKER_THREAD_NAME_PREFIX = "RxCachedThreadScheduler-";
-    private static final RxThreadFactory WORKER_THREAD_FACTORY =
+    static final RxThreadFactory WORKER_THREAD_FACTORY =
             new RxThreadFactory(WORKER_THREAD_NAME_PREFIX);
 
     private static final String EVICTOR_THREAD_NAME_PREFIX = "RxCachedWorkerPoolEvictor-";
-    private static final RxThreadFactory EVICTOR_THREAD_FACTORY =
+    static final RxThreadFactory EVICTOR_THREAD_FACTORY =
             new RxThreadFactory(EVICTOR_THREAD_NAME_PREFIX);
 
     private static final long KEEP_ALIVE_TIME = 60;
diff --git a/src/main/java/rx/schedulers/ImmediateScheduler.java b/src/main/java/rx/schedulers/ImmediateScheduler.java
index 4b9c27787f..e480754a58 100644
--- a/src/main/java/rx/schedulers/ImmediateScheduler.java
+++ b/src/main/java/rx/schedulers/ImmediateScheduler.java
@@ -45,6 +45,9 @@ public Worker createWorker() {
 
         final BooleanSubscription innerSubscription = new BooleanSubscription();
 
+        InnerImmediateScheduler() {
+        }
+
         @Override
         public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
             // since we are executing immediately on this thread we must cause this thread to sleep
diff --git a/src/main/java/rx/schedulers/TestScheduler.java b/src/main/java/rx/schedulers/TestScheduler.java
index c808a1a366..fec8bbcd75 100644
--- a/src/main/java/rx/schedulers/TestScheduler.java
+++ b/src/main/java/rx/schedulers/TestScheduler.java
@@ -31,17 +31,17 @@
  * advancing the clock at whatever pace you choose.
  */
 public class TestScheduler extends Scheduler {
-    private final Queue<TimedAction> queue = new PriorityQueue<TimedAction>(11, new CompareActionsByTime());
-    private static long counter = 0;
+    final Queue<TimedAction> queue = new PriorityQueue<TimedAction>(11, new CompareActionsByTime());
+    static long counter = 0;
 
     private static final class TimedAction {
 
-        private final long time;
-        private final Action0 action;
-        private final Worker scheduler;
+        final long time;
+        final Action0 action;
+        final Worker scheduler;
         private final long count = counter++; // for differentiating tasks at same time
 
-        private TimedAction(Worker scheduler, long time, Action0 action) {
+        TimedAction(Worker scheduler, long time, Action0 action) {
             this.time = time;
             this.action = action;
             this.scheduler = scheduler;
@@ -54,6 +54,9 @@ public String toString() {
     }
 
     private static class CompareActionsByTime implements Comparator<TimedAction> {
+        CompareActionsByTime() {
+        }
+
         @Override
         public int compare(TimedAction action1, TimedAction action2) {
             if (action1.time == action2.time) {
@@ -65,7 +68,7 @@ public int compare(TimedAction action1, TimedAction action2) {
     }
 
     // Storing time in nanoseconds internally.
-    private long time;
+    long time;
 
     @Override
     public long now() {
@@ -132,6 +135,9 @@ public Worker createWorker() {
 
         private final BooleanSubscription s = new BooleanSubscription();
 
+        InnerTestScheduler() {
+        }
+
         @Override
         public void unsubscribe() {
             s.unsubscribe();
diff --git a/src/main/java/rx/schedulers/TrampolineScheduler.java b/src/main/java/rx/schedulers/TrampolineScheduler.java
index 9f7b14eb43..45bb18546c 100644
--- a/src/main/java/rx/schedulers/TrampolineScheduler.java
+++ b/src/main/java/rx/schedulers/TrampolineScheduler.java
@@ -47,10 +47,13 @@ public Worker createWorker() {
     private static class InnerCurrentThreadScheduler extends Scheduler.Worker implements Subscription {
 
         final AtomicInteger counter = new AtomicInteger();
-        private final PriorityBlockingQueue<TimedAction> queue = new PriorityBlockingQueue<TimedAction>();
+        final PriorityBlockingQueue<TimedAction> queue = new PriorityBlockingQueue<TimedAction>();
         private final BooleanSubscription innerSubscription = new BooleanSubscription();
         private final AtomicInteger wip = new AtomicInteger();
 
+        InnerCurrentThreadScheduler() {
+        }
+
         @Override
         public Subscription schedule(Action0 action) {
             return enqueue(action, now());
@@ -108,7 +111,7 @@ public boolean isUnsubscribed() {
         final Long execTime;
         final int count; // In case if time between enqueueing took less than 1ms
 
-        private TimedAction(Action0 action, Long execTime, int count) {
+        TimedAction(Action0 action, Long execTime, int count) {
             this.action = action;
             this.execTime = execTime;
             this.count = count;
@@ -125,7 +128,7 @@ public int compareTo(TimedAction that) {
     }
 
     // because I can't use Integer.compare from Java 7
-    private static int compare(int x, int y) {
+    static int compare(int x, int y) {
         return (x < y) ? -1 : ((x == y) ? 0 : 1);
     }
 
diff --git a/src/main/java/rx/singles/BlockingSingle.java b/src/main/java/rx/singles/BlockingSingle.java
new file mode 100644
index 0000000000..6821bc5b82
--- /dev/null
+++ b/src/main/java/rx/singles/BlockingSingle.java
@@ -0,0 +1,106 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.singles;
+
+import rx.Single;
+import rx.SingleSubscriber;
+import rx.Subscription;
+import rx.annotations.Experimental;
+import rx.internal.operators.BlockingOperatorToFuture;
+import rx.internal.util.BlockingUtils;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * {@code BlockingSingle} is a blocking "version" of {@link Single} that provides blocking
+ * operators.
+ * <p/>
+ * You construct a {@code BlockingSingle} from a {@code Single} with {@link #from(Single)}
+ * or {@link Single#toBlocking()}.
+ */
+@Experimental
+public class BlockingSingle<T> {
+    private final Single<? extends T> single;
+
+    private BlockingSingle(Single<? extends T> single) {
+        this.single = single;
+    }
+
+    /**
+     * Converts a {@link Single} into a {@code BlockingSingle}.
+     *
+     * @param single the {@link Single} you want to convert
+     * @return a {@code BlockingSingle} version of {@code single}
+     */
+    @Experimental
+    public static <T> BlockingSingle<T> from(Single<? extends T> single) {
+        return new BlockingSingle<T>(single);
+    }
+
+    /**
+     * Returns the item emitted by this {@code BlockingSingle}.
+     * <p/>
+     * If the underlying {@link Single} returns successfully, the value emitted
+     * by the {@link Single} is returned. If the {@link Single} emits an error,
+     * the throwable emitted ({@link SingleSubscriber#onError(Throwable)}) is
+     * thrown.
+     *
+     * @return the value emitted by this {@code BlockingSingle}
+     */
+    @Experimental
+    public T value() {
+        final AtomicReference<T> returnItem = new AtomicReference<T>();
+        final AtomicReference<Throwable> returnException = new AtomicReference<Throwable>();
+        final CountDownLatch latch = new CountDownLatch(1);
+        Subscription subscription = single.subscribe(new SingleSubscriber<T>() {
+            @Override
+            public void onSuccess(T value) {
+                returnItem.set(value);
+                latch.countDown();
+            }
+
+            @Override
+            public void onError(Throwable error) {
+                returnException.set(error);
+                latch.countDown();
+            }
+        });
+
+        BlockingUtils.awaitForComplete(latch, subscription);
+        Throwable throwable = returnException.get();
+        if (throwable != null) {
+            if (throwable instanceof RuntimeException) {
+                throw (RuntimeException) throwable;
+            }
+            throw new RuntimeException(throwable);
+        }
+        return returnItem.get();
+    }
+
+    /**
+     * Returns a {@link Future} representing the value emitted by this {@code BlockingSingle}.
+     *
+     * @return a {@link Future} that returns the value
+     */
+    @Experimental
+    public Future<T> toFuture() {
+        return BlockingOperatorToFuture.toFuture(single.toObservable());
+    }
+}
+
diff --git a/src/main/java/rx/subjects/AsyncSubject.java b/src/main/java/rx/subjects/AsyncSubject.java
index b124b8966c..57539fa8eb 100644
--- a/src/main/java/rx/subjects/AsyncSubject.java
+++ b/src/main/java/rx/subjects/AsyncSubject.java
@@ -15,11 +15,10 @@
  */
 package rx.subjects;
 
-import java.lang.reflect.Array;
 import java.util.*;
 
 import rx.Observer;
-import rx.annotations.Experimental;
+import rx.annotations.Beta;
 import rx.exceptions.Exceptions;
 import rx.functions.Action1;
 import rx.internal.operators.NotificationLite;
@@ -141,8 +140,7 @@ public boolean hasObservers() {
      * retrieved by {@code getValue()} may get outdated.
      * @return true if and only if the subject has some value but not an error
      */
-    @Experimental
-    @Override
+    @Beta
     public boolean hasValue() {
         Object v = lastValue;
         Object o = state.getLatest();
@@ -152,8 +150,7 @@ public boolean hasValue() {
      * Check if the Subject has terminated with an exception.
      * @return true if the subject has received a throwable through {@code onError}.
      */
-    @Experimental
-    @Override
+    @Beta
     public boolean hasThrowable() {
         Object o = state.getLatest();
         return nl.isError(o);
@@ -162,8 +159,7 @@ public boolean hasThrowable() {
      * Check if the Subject has terminated normally.
      * @return true if the subject completed normally via {@code onCompleted()}
      */
-    @Experimental
-    @Override
+    @Beta
     public boolean hasCompleted() {
         Object o = state.getLatest();
         return o != null && !nl.isError(o);
@@ -177,8 +173,7 @@ public boolean hasCompleted() {
      * @return the current value or {@code null} if the Subject doesn't have a value,
      * has terminated with an exception or has an actual {@code null} as a value.
      */
-    @Experimental
-    @Override
+    @Beta
     public T getValue() {
         Object v = lastValue;
         Object o = state.getLatest();
@@ -192,8 +187,7 @@ public T getValue() {
      * @return the Throwable that terminated the Subject or {@code null} if the
      * subject hasn't terminated yet or it terminated normally.
      */
-    @Experimental
-    @Override
+    @Beta
     public Throwable getThrowable() {
         Object o = state.getLatest();
         if (nl.isError(o)) {
@@ -201,26 +195,4 @@ public Throwable getThrowable() {
         }
         return null;
     }
-    @Override
-    @Experimental
-    @Deprecated
-    @SuppressWarnings("unchecked")
-    public T[] getValues(T[] a) {
-        Object v = lastValue;
-        Object o = state.getLatest();
-        if (!nl.isError(o) && nl.isNext(v)) {
-            T val = nl.getValue(v);
-            if (a.length == 0) {
-                a = (T[])Array.newInstance(a.getClass().getComponentType(), 1);
-            }
-            a[0] = val;
-            if (a.length > 1) {
-                a[1] = null;
-            }
-        } else
-        if (a.length > 0) {
-            a[0] = null;
-        }
-        return a;
-    }
 }
diff --git a/src/main/java/rx/subjects/BehaviorSubject.java b/src/main/java/rx/subjects/BehaviorSubject.java
index d912e81411..ad8bd448f6 100644
--- a/src/main/java/rx/subjects/BehaviorSubject.java
+++ b/src/main/java/rx/subjects/BehaviorSubject.java
@@ -20,7 +20,7 @@
 import java.util.*;
 
 import rx.Observer;
-import rx.annotations.Experimental;
+import rx.annotations.Beta;
 import rx.exceptions.Exceptions;
 import rx.functions.Action1;
 import rx.internal.operators.NotificationLite;
@@ -177,8 +177,7 @@ public boolean hasObservers() {
      * retrieved by {@code getValue()} may get outdated.
      * @return true if and only if the subject has some value and hasn't terminated yet.
      */
-    @Experimental
-    @Override
+    @Beta
     public boolean hasValue() {
         Object o = state.getLatest();
         return nl.isNext(o);
@@ -187,8 +186,7 @@ public boolean hasValue() {
      * Check if the Subject has terminated with an exception.
      * @return true if the subject has received a throwable through {@code onError}.
      */
-    @Experimental
-    @Override
+    @Beta
     public boolean hasThrowable() {
         Object o = state.getLatest();
         return nl.isError(o);
@@ -197,8 +195,7 @@ public boolean hasThrowable() {
      * Check if the Subject has terminated normally.
      * @return true if the subject completed normally via {@code onCompleted()}
      */
-    @Experimental
-    @Override
+    @Beta
     public boolean hasCompleted() {
         Object o = state.getLatest();
         return nl.isCompleted(o);
@@ -212,8 +209,7 @@ public boolean hasCompleted() {
      * @return the current value or {@code null} if the Subject doesn't have a value,
      * has terminated or has an actual {@code null} as a valid value.
      */
-    @Experimental
-    @Override
+    @Beta
     public T getValue() {
         Object o = state.getLatest();
         if (nl.isNext(o)) {
@@ -226,8 +222,7 @@ public T getValue() {
      * @return the Throwable that terminated the Subject or {@code null} if the
      * subject hasn't terminated yet or it terminated normally.
      */
-    @Experimental
-    @Override
+    @Beta
     public Throwable getThrowable() {
         Object o = state.getLatest();
         if (nl.isError(o)) {
@@ -235,8 +230,13 @@ public Throwable getThrowable() {
         }
         return null;
     }
-    @Override
-    @Experimental
+    /**
+     * Returns a snapshot of the currently buffered non-terminal events into 
+     * the provided {@code a} array or creates a new array if it has not enough capacity.
+     * @param a the array to fill in
+     * @return the array {@code a} if it had enough capacity or a new array containing the available values 
+     */
+    @Beta
     @SuppressWarnings("unchecked")
     public T[] getValues(T[] a) {
         Object o = state.getLatest();
@@ -254,4 +254,24 @@ public Throwable getThrowable() {
         }
         return a;
     }
+    
+    /** An empty array to trigger getValues() to return a new array. */
+    private static final Object[] EMPTY_ARRAY = new Object[0];
+    
+    /**
+     * Returns a snapshot of the currently buffered non-terminal events.
+     * <p>The operation is threadsafe.
+     *
+     * @return a snapshot of the currently buffered non-terminal events.
+     * @since (If this graduates from being an Experimental class method, replace this parenthetical with the release number)
+     */
+    @SuppressWarnings("unchecked")
+    @Beta
+    public Object[] getValues() {
+        T[] r = getValues((T[])EMPTY_ARRAY);
+        if (r == EMPTY_ARRAY) {
+            return new Object[0]; // don't leak the default empty array.
+        }
+        return r;
+    }
 }
diff --git a/src/main/java/rx/subjects/PublishSubject.java b/src/main/java/rx/subjects/PublishSubject.java
index f9dd1f0e4f..42a4a18c7c 100644
--- a/src/main/java/rx/subjects/PublishSubject.java
+++ b/src/main/java/rx/subjects/PublishSubject.java
@@ -18,7 +18,7 @@
 import java.util.*;
 
 import rx.Observer;
-import rx.annotations.Experimental;
+import rx.annotations.Beta;
 import rx.exceptions.Exceptions;
 import rx.functions.Action1;
 import rx.internal.operators.NotificationLite;
@@ -124,8 +124,7 @@ public boolean hasObservers() {
      * Check if the Subject has terminated with an exception.
      * @return true if the subject has received a throwable through {@code onError}.
      */
-    @Experimental
-    @Override
+    @Beta
     public boolean hasThrowable() {
         Object o = state.getLatest();
         return nl.isError(o);
@@ -134,8 +133,7 @@ public boolean hasThrowable() {
      * Check if the Subject has terminated normally.
      * @return true if the subject completed normally via {@code onCompleted}
      */
-    @Experimental
-    @Override
+    @Beta
     public boolean hasCompleted() {
         Object o = state.getLatest();
         return o != null && !nl.isError(o);
@@ -145,8 +143,7 @@ public boolean hasCompleted() {
      * @return the Throwable that terminated the Subject or {@code null} if the
      * subject hasn't terminated yet or it terminated normally.
      */
-    @Experimental
-    @Override
+    @Beta
     public Throwable getThrowable() {
         Object o = state.getLatest();
         if (nl.isError(o)) {
@@ -154,49 +151,4 @@ public Throwable getThrowable() {
         }
         return null;
     }
-    
-    /**
-     * {@inheritDoc}
-     * @deprecated this method is scheduled to be removed in the next release
-     */
-    @Override
-    @Experimental
-    @Deprecated
-    public boolean hasValue() {
-        return false;
-    }
-
-    /**
-     * {@inheritDoc}
-     * @deprecated this method is scheduled to be removed in the next release
-     */
-    @Override
-    @Experimental
-    @Deprecated
-    public T getValue() {
-        return null;
-    }
-    /**
-     * {@inheritDoc}
-     * @deprecated this method is scheduled to be removed in the next release
-     */
-    @Override
-    @Experimental
-    @Deprecated
-    public Object[] getValues() {
-        return new Object[0];
-    }
-    /**
-     * {@inheritDoc}
-     * @deprecated this method is scheduled to be removed in the next release
-     */
-    @Override
-    @Experimental
-    @Deprecated
-    public T[] getValues(T[] a) {
-        if (a.length > 0) {
-            a[0] = null;
-        }
-        return a;
-    }
 }
diff --git a/src/main/java/rx/subjects/ReplaySubject.java b/src/main/java/rx/subjects/ReplaySubject.java
index 7ed517375e..ca166b6177 100644
--- a/src/main/java/rx/subjects/ReplaySubject.java
+++ b/src/main/java/rx/subjects/ReplaySubject.java
@@ -23,7 +23,7 @@
 
 import rx.Observer;
 import rx.Scheduler;
-import rx.annotations.Experimental;
+import rx.annotations.Beta;
 import rx.exceptions.Exceptions;
 import rx.functions.Action1;
 import rx.functions.Func1;
@@ -1097,8 +1097,7 @@ public void evictFinal(NodeList<Object> list) {
      * Check if the Subject has terminated with an exception.
      * @return true if the subject has received a throwable through {@code onError}.
      */
-    @Experimental
-    @Override
+    @Beta
     public boolean hasThrowable() {
         NotificationLite<T> nl = ssm.nl;
         Object o = ssm.getLatest();
@@ -1108,8 +1107,7 @@ public boolean hasThrowable() {
      * Check if the Subject has terminated normally.
      * @return true if the subject completed normally via {@code onCompleted}
      */
-    @Experimental
-    @Override
+    @Beta
     public boolean hasCompleted() {
         NotificationLite<T> nl = ssm.nl;
         Object o = ssm.getLatest();
@@ -1120,8 +1118,7 @@ public boolean hasCompleted() {
      * @return the Throwable that terminated the Subject or {@code null} if the
      * subject hasn't terminated yet or it terminated normally.
      */
-    @Experimental
-    @Override
+    @Beta
     public Throwable getThrowable() {
         NotificationLite<T> nl = ssm.nl;
         Object o = ssm.getLatest();
@@ -1134,19 +1131,18 @@ public Throwable getThrowable() {
      * Returns the current number of items (non-terminal events) available for replay.
      * @return the number of items available
      */
-    @Experimental
+    @Beta
     public int size() {
         return state.size();
     }
     /**
      * @return true if the Subject holds at least one non-terminal event available for replay
      */
-    @Experimental
+    @Beta
     public boolean hasAnyValue() {
         return !state.isEmpty();
     }
-    @Experimental
-    @Override
+    @Beta
     public boolean hasValue() {
         return hasAnyValue();
     }
@@ -1156,14 +1152,32 @@ public boolean hasValue() {
      * @param a the array to fill in
      * @return the array {@code a} if it had enough capacity or a new array containing the available values 
      */
-    @Experimental
-    @Override
+    @Beta
     public T[] getValues(T[] a) {
         return state.toArray(a);
     }
     
-    @Override
-    @Experimental
+    /** An empty array to trigger getValues() to return a new array. */
+    private static final Object[] EMPTY_ARRAY = new Object[0];
+    
+    /**
+     * Returns a snapshot of the currently buffered non-terminal events.
+     * <p>The operation is threadsafe.
+     *
+     * @return a snapshot of the currently buffered non-terminal events.
+     * @since (If this graduates from being an Experimental class method, replace this parenthetical with the release number)
+     */
+    @SuppressWarnings("unchecked")
+    @Beta
+    public Object[] getValues() {
+        T[] r = getValues((T[])EMPTY_ARRAY);
+        if (r == EMPTY_ARRAY) {
+            return new Object[0]; // don't leak the default empty array.
+        }
+        return r;
+    }
+    
+    @Beta
     public T getValue() {
         return state.latest();
     }
diff --git a/src/main/java/rx/subjects/SerializedSubject.java b/src/main/java/rx/subjects/SerializedSubject.java
index 6dd5a46592..33b532c7b4 100644
--- a/src/main/java/rx/subjects/SerializedSubject.java
+++ b/src/main/java/rx/subjects/SerializedSubject.java
@@ -16,7 +16,6 @@
 package rx.subjects;
 
 import rx.Subscriber;
-import rx.annotations.Experimental;
 import rx.observers.SerializedObserver;
 
 /**
@@ -69,75 +68,4 @@ public void onNext(T t) {
     public boolean hasObservers() {
         return actual.hasObservers();
     }
-    
-    /**
-     * {@inheritDoc}
-     * @deprecated this method is scheduled to be removed in the next release
-     */
-    @Override
-    @Experimental
-    @Deprecated
-    public boolean hasCompleted() {
-        return actual.hasCompleted();
-    }
-    /**
-     * {@inheritDoc}
-     * @deprecated this method is scheduled to be removed in the next release
-     */
-    @Override
-    @Experimental
-    @Deprecated
-    public boolean hasThrowable() {
-        return actual.hasThrowable();
-    }
-    /**
-     * {@inheritDoc}
-     * @deprecated this method is scheduled to be removed in the next release
-     */
-    @Override
-    @Experimental
-    @Deprecated
-    public boolean hasValue() {
-        return actual.hasValue();
-    }
-    /**
-     * {@inheritDoc}
-     * @deprecated this method is scheduled to be removed in the next release
-     */
-    @Override
-    @Experimental
-    @Deprecated
-    public Throwable getThrowable() {
-        return actual.getThrowable();
-    }
-    /**
-     * {@inheritDoc}
-     * @deprecated this method is scheduled to be removed in the next release
-     */
-    @Override
-    @Experimental
-    @Deprecated
-    public T getValue() {
-        return actual.getValue();
-    }
-    /**
-     * {@inheritDoc}
-     * @deprecated this method is scheduled to be removed in the next release
-     */
-    @Override
-    @Experimental
-    @Deprecated
-    public Object[] getValues() {
-        return actual.getValues();
-    }
-    /**
-     * {@inheritDoc}
-     * @deprecated this method is scheduled to be removed in the next release
-     */
-    @Override
-    @Experimental
-    @Deprecated
-    public T[] getValues(T[] a) {
-        return actual.getValues(a);
-    }
 }
diff --git a/src/main/java/rx/subjects/Subject.java b/src/main/java/rx/subjects/Subject.java
index b220cc1b51..94a289139a 100644
--- a/src/main/java/rx/subjects/Subject.java
+++ b/src/main/java/rx/subjects/Subject.java
@@ -15,10 +15,7 @@
  */
 package rx.subjects;
 
-import rx.Observable;
-import rx.Observer;
-import rx.Subscriber;
-import rx.annotations.Experimental;
+import rx.*;
 
 /**
  * Represents an object that is both an Observable and an Observer.
@@ -58,117 +55,4 @@ protected Subject(OnSubscribe<R> onSubscribe) {
         }
         return new SerializedSubject<T, R>(this);
     }
-    /**
-     * Check if the Subject has terminated with an exception.
-     * <p>The operation is threadsafe.
-     *
-     * @return {@code true} if the subject has received a throwable through {@code onError}.
-     * @since (If this graduates from being an Experimental class method, replace this parenthetical with the release number)
-     * @deprecated this method will be moved to each Subject class individually in the next release
-     */
-    @Experimental
-    @Deprecated
-    public boolean hasThrowable() {
-        throw new UnsupportedOperationException();
-    }
-    /**
-     * Check if the Subject has terminated normally.
-     * <p>The operation is threadsafe.
-     *
-     * @return {@code true} if the subject completed normally via {@code onCompleted}
-     * @since (If this graduates from being an Experimental class method, replace this parenthetical with the release number)
-     * @deprecated this method will be moved to each Subject class individually in the next release
-     */
-    @Experimental
-    @Deprecated
-    public boolean hasCompleted() {
-        throw new UnsupportedOperationException();
-    }
-    /**
-     * Returns the Throwable that terminated the Subject.
-     * <p>The operation is threadsafe.
-     *
-     * @return the Throwable that terminated the Subject or {@code null} if the subject hasn't terminated yet or
-     *         if it terminated normally.
-     * @since (If this graduates from being an Experimental class method, replace this parenthetical with the release number)
-     * @deprecated this method will be moved to each Subject class individually in the next release
-     */
-    @Experimental
-    @Deprecated
-    public Throwable getThrowable() {
-        throw new UnsupportedOperationException();
-    }
-    /**
-     * Check if the Subject has any value.
-     * <p>Use the {@link #getValue()} method to retrieve such a value.
-     * <p>Note that unless {@link #hasCompleted()} or {@link #hasThrowable()} returns true, the value
-     * retrieved by {@code getValue()} may get outdated.
-     * <p>The operation is threadsafe.
-     *
-     * @return {@code true} if and only if the subject has some value but not an error
-     * @since (If this graduates from being an Experimental class method, replace this parenthetical with the release number)
-     * @deprecated this method will be moved to each Subject class individually in the next release
-     */
-    @Experimental
-    @Deprecated
-    public boolean hasValue() {
-        throw new UnsupportedOperationException();
-    }
-    /**
-     * Returns the current or latest value of the Subject if there is such a value and
-     * the subject hasn't terminated with an exception.
-     * <p>The method can return {@code null} for various reasons. Use {@link #hasValue()}, {@link #hasThrowable()}
-     * and {@link #hasCompleted()} to determine if such {@code null} is a valid value, there was an
-     * exception or the Subject terminated without receiving any value. 
-     * <p>The operation is threadsafe.
-     *
-     * @return the current value or {@code null} if the Subject doesn't have a value, has terminated with an
-     *         exception or has an actual {@code null} as a value.
-     * @since (If this graduates from being an Experimental class method, replace this parenthetical with the release number)
-     * @deprecated this method will be moved to each Subject class individually in the next release
-     */
-    @Experimental
-    @Deprecated
-    public T getValue() {
-        throw new UnsupportedOperationException();
-    }
-    /** An empty array to trigger getValues() to return a new array. */
-    private static final Object[] EMPTY_ARRAY = new Object[0];
-    /**
-     * Returns a snapshot of the currently buffered non-terminal events.
-     * <p>The operation is threadsafe.
-     *
-     * @return a snapshot of the currently buffered non-terminal events.
-     * @since (If this graduates from being an Experimental class method, replace this parenthetical with the release number)
-     * @deprecated this method will be moved to each Subject class individually in the next release
-     */
-    @SuppressWarnings("unchecked")
-    @Experimental
-    @Deprecated
-    public Object[] getValues() {
-        T[] r = getValues((T[])EMPTY_ARRAY);
-        if (r == EMPTY_ARRAY) {
-            return new Object[0]; // don't leak the default empty array.
-        }
-        return r;
-    }
-    /**
-     * Returns a snapshot of the currently buffered non-terminal events into 
-     * the provided {@code a} array or creates a new array if it has not enough capacity.
-     * <p>If the subject's values fit in the specified array with room to spare
-     * (i.e., the array has more elements than the list), the element in
-     * the array immediately following the end of the subject's values is set to
-     * {@code null}.
-     * <p>The operation is threadsafe.
-     *
-     * @param a the array to fill in
-     * @return the array {@code a} if it had enough capacity or a new array containing the available values 
-     * @since (If this graduates from being an Experimental class method, replace this parenthetical with the release number)
-     * @deprecated this method will be moved to each Subject class individually in the next release
-     */
-    @Experimental
-    @Deprecated
-    public T[] getValues(T[] a) {
-        throw new UnsupportedOperationException();
-    }
 }
diff --git a/src/main/java/rx/subjects/TestSubject.java b/src/main/java/rx/subjects/TestSubject.java
index 2cc32b007c..f7a0caee2a 100644
--- a/src/main/java/rx/subjects/TestSubject.java
+++ b/src/main/java/rx/subjects/TestSubject.java
@@ -75,7 +75,7 @@ public void onCompleted() {
         onCompleted(0);
     }
 
-    private void _onCompleted() {
+    void _onCompleted() {
         if (state.active) {
             for (SubjectObserver<T> bo : state.terminate(NotificationLite.instance().completed())) {
                 bo.onCompleted();
@@ -108,7 +108,7 @@ public void onError(final Throwable e) {
         onError(e, 0);
     }
 
-    private void _onError(final Throwable e) {
+    void _onError(final Throwable e) {
         if (state.active) {
             for (SubjectObserver<T> bo : state.terminate(NotificationLite.instance().error(e))) {
                 bo.onError(e);
@@ -143,7 +143,7 @@ public void onNext(T v) {
         onNext(v, 0);
     }
 
-    private void _onNext(T v) {
+    void _onNext(T v) {
         for (Observer<? super T> o : state.observers()) {
             o.onNext(v);
         }
diff --git a/src/main/java/rx/subscriptions/Subscriptions.java b/src/main/java/rx/subscriptions/Subscriptions.java
index bbc075a3a9..64d941f13d 100644
--- a/src/main/java/rx/subscriptions/Subscriptions.java
+++ b/src/main/java/rx/subscriptions/Subscriptions.java
@@ -18,7 +18,6 @@
 import java.util.concurrent.Future;
 
 import rx.Subscription;
-import rx.annotations.Experimental;
 import rx.functions.Action0;
 
 /**
@@ -57,9 +56,8 @@ public static Subscription empty() {
      * </code></pre>
      *
      * @return a {@link Subscription} to which {@code unsubscribe} does nothing, as it is already unsubscribed
-     * @since (if this graduates from Experimental/Beta to supported, replace this parenthetical with the release number)
+     * @since 1.1.0
      */
-    @Experimental
     public static Subscription unsubscribed() {
         return UNSUBSCRIBED;
     }
@@ -122,7 +120,7 @@ public static CompositeSubscription from(Subscription... subscriptions) {
      */
     private static final Unsubscribed UNSUBSCRIBED = new Unsubscribed();
         /** Naming classes helps with debugging. */
-    private static final class Unsubscribed implements Subscription {
+    static final class Unsubscribed implements Subscription {
         @Override
         public void unsubscribe() {
         }
diff --git a/src/perf/java/rx/observables/SyncOnSubscribePerf.java b/src/perf/java/rx/observables/SyncOnSubscribePerf.java
index 8417bf3a8e..91882df8d0 100644
--- a/src/perf/java/rx/observables/SyncOnSubscribePerf.java
+++ b/src/perf/java/rx/observables/SyncOnSubscribePerf.java
@@ -80,36 +80,12 @@ public void benchFromIterable(final SingleInput input) {
         new OnSubscribeFromIterable<Integer>(input.iterable).call(input.newSubscriber());
     }
     
-//    @Benchmark
-//  @Group("single")
-    public void benchAbstractOnSubscribe(final SingleInput input) {
-        final Iterator<Integer> iterator = input.iterable.iterator();
-        createAbstractOnSubscribe(iterator).call(input.newSubscriber());
-    }
-
-    private AbstractOnSubscribe<Integer, Void> createAbstractOnSubscribe(final Iterator<Integer> iterator) {
-        return new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(rx.observables.AbstractOnSubscribe.SubscriptionState<Integer, Void> state) {
-                if (iterator.hasNext())
-                    state.onNext(iterator.next());
-                else
-                    state.onCompleted();
-            }};
-    }
-
     @Benchmark
 //    @Group("multi")
     public void benchSyncOnSubscribe2(final MultiInput input) {
         createSyncOnSubscribe(input.iterable.iterator()).call(input.newSubscriber());
     }
     
-//    @Benchmark
-//  @Group("multi")
-    public void benchAbstractOnSubscribe2(final MultiInput input) {
-        createAbstractOnSubscribe(input.iterable.iterator()).call(input.newSubscriber());
-    }
-    
     @Benchmark
 //    @Group("multi")
     public void benchFromIterable2(final MultiInput input) {
diff --git a/src/perf/java/rx/operators/FromComparison.java b/src/perf/java/rx/operators/FromComparison.java
new file mode 100644
index 0000000000..7a7a12545d
--- /dev/null
+++ b/src/perf/java/rx/operators/FromComparison.java
@@ -0,0 +1,123 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.operators;
+
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+
+import org.openjdk.jmh.annotations.*;
+import org.openjdk.jmh.infra.Blackhole;
+
+import rx.*;
+import rx.internal.operators.*;
+
+/**
+ * Benchmark typical atomic operations on volatile fields and AtomicXYZ classes.
+ * <p>
+ * gradlew benchmarks "-Pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 .*FromComparison.*"
+ * <p>
+ * gradlew benchmarks "-Pjmh=-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 .*FromComparison.*"
+ */
+@BenchmarkMode(Mode.Throughput)
+@OutputTimeUnit(TimeUnit.SECONDS)
+@State(Scope.Thread)
+public class FromComparison {
+    @Param({ "1", "10", "100", "1000", "1000000" })
+    public int times;
+    
+    Observable<Integer> iterableSource;
+    
+    Observable<Integer> arraySource;
+    
+    @Setup
+    public void setup() {
+        Integer[] array = new Integer[times];
+        
+        Arrays.fill(array, 1);
+        
+        iterableSource = Observable.create(new OnSubscribeFromIterable<Integer>(Arrays.asList(array)));
+        arraySource = Observable.create(new OnSubscribeFromArray<Integer>(array));
+    }
+    
+    @Benchmark
+    public void fastpathIterable(Blackhole bh) {
+        iterableSource.subscribe(new RequestingSubscriber<Object>(bh, Long.MAX_VALUE));
+    }
+
+    @Benchmark
+    public void fastpathArray(Blackhole bh) {
+        arraySource.subscribe(new RequestingSubscriber<Object>(bh, Long.MAX_VALUE));
+    }
+
+    @Benchmark
+    public void slowpathIterable(Blackhole bh) {
+        iterableSource.subscribe(new RequestingSubscriber<Object>(bh, times + 1));
+    }
+
+    @Benchmark
+    public void slowpathArray(Blackhole bh) {
+        arraySource.subscribe(new RequestingSubscriber<Object>(bh, times + 1));
+    }
+
+    @Benchmark
+    public void slowpathIterable2(Blackhole bh) {
+        iterableSource.subscribe(new RequestingSubscriber<Object>(bh, 128));
+    }
+
+    @Benchmark
+    public void slowpathArray2(Blackhole bh) {
+        arraySource.subscribe(new RequestingSubscriber<Object>(bh, 128));
+    }
+
+    
+    static final class RequestingSubscriber<T> extends Subscriber<T> {
+        final Blackhole bh;
+        final long limit;
+        long received;
+        Producer p;
+        
+        public RequestingSubscriber(Blackhole bh, long limit) {
+            this.bh = bh;
+            this.limit = limit;
+        }
+        
+        @Override
+        public void onNext(T t) {
+            bh.consume(t);
+            if (++received >= limit) {
+                received = 0L;
+                p.request(limit);
+            }
+        }
+        
+        @Override
+        public void onError(Throwable e) {
+            e.printStackTrace();
+        }
+        
+        @Override
+        public void onCompleted() {
+            
+        }
+        
+        @Override
+        public void setProducer(Producer p) {
+            this.p = p;
+            p.request(limit);
+        }
+    }
+}
diff --git a/src/test/java/rx/CompletableTest.java b/src/test/java/rx/CompletableTest.java
new file mode 100644
index 0000000000..e46eff8423
--- /dev/null
+++ b/src/test/java/rx/CompletableTest.java
@@ -0,0 +1,3606 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+
+import org.junit.*;
+
+import rx.Completable.*;
+import rx.Observable.OnSubscribe;
+import rx.exceptions.*;
+import rx.functions.*;
+import rx.observers.TestSubscriber;
+import rx.plugins.RxJavaPlugins;
+import rx.schedulers.*;
+import rx.subjects.PublishSubject;
+import rx.subscriptions.*;
+
+import static org.mockito.Mockito.*;
+import static org.junit.Assert.*;
+
+/**
+ * Test Completable methods and operators.
+ */
+public class CompletableTest {
+    /**
+     * Iterable that returns an Iterator that throws in its hasNext method.
+     */
+    static final class IterableIteratorNextThrows implements Iterable<Completable> {
+        @Override
+        public Iterator<Completable> iterator() {
+            return new Iterator<Completable>() {
+                @Override
+                public boolean hasNext() {
+                    return true;
+                }
+                
+                @Override
+                public Completable next() {
+                    throw new TestException();
+                }
+                
+                @Override
+                public void remove() {
+                    throw new UnsupportedOperationException();
+                }
+            };
+        }
+    }
+
+    /**
+     * Iterable that returns an Iterator that throws in its next method.
+     */
+    static final class IterableIteratorHasNextThrows implements Iterable<Completable> {
+        @Override
+        public Iterator<Completable> iterator() {
+            return new Iterator<Completable>() {
+                @Override
+                public boolean hasNext() {
+                    throw new TestException();
+                }
+                
+                @Override
+                public Completable next() {
+                    return null;
+                }
+                
+
+                @Override
+                public void remove() {
+                    throw new UnsupportedOperationException();
+                }
+            };
+        }
+    }
+
+    /**
+     * A class containing a completable instance and counts the number of subscribers.
+     */
+    static final class NormalCompletable extends AtomicInteger {
+        /** */
+        private static final long serialVersionUID = 7192337844700923752L;
+        
+        public final Completable completable = Completable.create(new CompletableOnSubscribe() {
+            @Override
+            public void call(CompletableSubscriber s) {
+                getAndIncrement();
+                s.onSubscribe(Subscriptions.unsubscribed());
+                s.onCompleted();
+            }
+        });
+        
+        /**
+         * Asserts the given number of subscriptions happened.
+         * @param n the expected number of subscriptions
+         */
+        public void assertSubscriptions(int n) {
+            Assert.assertEquals(n, get());
+        }
+    }
+
+    /**
+     * A class containing a completable instance that emits a TestException and counts
+     * the number of subscribers.
+     */
+    static final class ErrorCompletable extends AtomicInteger {
+        /** */
+        private static final long serialVersionUID = 7192337844700923752L;
+        
+        public final Completable completable = Completable.create(new CompletableOnSubscribe() {
+            @Override
+            public void call(CompletableSubscriber s) {
+                getAndIncrement();
+                s.onSubscribe(Subscriptions.unsubscribed());
+                s.onError(new TestException());
+            }
+        });
+        
+        /**
+         * Asserts the given number of subscriptions happened.
+         * @param n the expected number of subscriptions
+         */
+        public void assertSubscriptions(int n) {
+            Assert.assertEquals(n, get());
+        }
+    }
+
+    /** A normal Completable object. */
+    final NormalCompletable normal = new NormalCompletable();
+
+    /** An error Completable object. */
+    final ErrorCompletable error = new ErrorCompletable();
+
+    @Test(timeout = 1000)
+    public void complete() {
+        Completable c = Completable.complete();
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void concatNull() {
+        Completable.concat((Completable[])null);
+    }
+    
+    @Test(timeout = 1000)
+    public void concatEmpty() {
+        Completable c = Completable.concat();
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void concatSingleSource() {
+        Completable c = Completable.concat(normal.completable);
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void concatSingleSourceThrows() {
+        Completable c = Completable.concat(error.completable);
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void concatMultipleSources() {
+        Completable c = Completable.concat(normal.completable, normal.completable, normal.completable);
+        
+        c.await();
+        
+        normal.assertSubscriptions(3);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void concatMultipleOneThrows() {
+        Completable c = Completable.concat(normal.completable, error.completable, normal.completable);
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void concatMultipleOneIsNull() {
+        Completable c = Completable.concat(normal.completable, null);
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void concatIterableEmpty() {
+        Completable c = Completable.concat(Collections.<Completable>emptyList());
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void concatIterableNull() {
+        Completable.concat((Iterable<Completable>)null);
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void concatIterableIteratorNull() {
+        Completable c = Completable.concat(new Iterable<Completable>() {
+            @Override
+            public Iterator<Completable> iterator() {
+                return null;
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void concatIterableWithNull() {
+        Completable c = Completable.concat(Arrays.asList(normal.completable, (Completable)null));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void concatIterableSingle() {
+        Completable c = Completable.concat(Collections.singleton(normal.completable));
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000)
+    public void concatIterableMany() {
+        Completable c = Completable.concat(Arrays.asList(normal.completable, normal.completable, normal.completable));
+        
+        c.await();
+        
+        normal.assertSubscriptions(3);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void concatIterableOneThrows() {
+        Completable c = Completable.concat(Collections.singleton(error.completable));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void concatIterableManyOneThrows() {
+        Completable c = Completable.concat(Arrays.asList(normal.completable, error.completable));
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void concatIterableIterableThrows() {
+        Completable c = Completable.concat(new Iterable<Completable>() {
+            @Override
+            public Iterator<Completable> iterator() {
+                throw new TestException();
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void concatIterableIteratorHasNextThrows() {
+        Completable c = Completable.concat(new IterableIteratorHasNextThrows());
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void concatIterableIteratorNextThrows() {
+        Completable c = Completable.concat(new IterableIteratorNextThrows());
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void concatObservableEmpty() {
+        Completable c = Completable.concat(Observable.<Completable>empty());
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void concatObservableError() {
+        Completable c = Completable.concat(Observable.<Completable>error(new TestException()));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void concatObservableSingle() {
+        Completable c = Completable.concat(Observable.just(normal.completable));
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void concatObservableSingleThrows() {
+        Completable c = Completable.concat(Observable.just(error.completable));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void concatObservableMany() {
+        Completable c = Completable.concat(Observable.just(normal.completable).repeat(3));
+        
+        c.await();
+        
+        normal.assertSubscriptions(3);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void concatObservableManyOneThrows() {
+        Completable c = Completable.concat(Observable.just(normal.completable, error.completable));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void concatObservablePrefetch() {
+        final List<Long> requested = new ArrayList<Long>();
+        Observable<Completable> cs = Observable
+                .just(normal.completable)
+                .repeat(10)
+                .doOnRequest(new Action1<Long>() {
+                    @Override
+                    public void call(Long v) {
+                        requested.add(v);
+                    }
+                });
+        
+        Completable c = Completable.concat(cs, 5);
+        
+        c.await();
+        
+        // FIXME this request pattern looks odd because all 10 completions trigger 1 requests
+        Assert.assertEquals(Arrays.asList(5L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L), requested);
+    }
+    
+    @Test
+    public void andThen() {
+        TestSubscriber<String> ts = new TestSubscriber<String>(0);
+        Completable.complete().andThen(Observable.just("foo")).subscribe(ts);
+        ts.requestMore(1);
+        ts.assertValue("foo");
+        ts.assertCompleted();
+        ts.assertNoErrors();
+    }
+    
+    @Test
+    public void andThenNever() {
+        TestSubscriber<String> ts = new TestSubscriber<String>(0);
+        Completable.never().andThen(Observable.just("foo")).subscribe(ts);
+        ts.requestMore(1);
+        ts.assertNoValues();
+        ts.assertNoTerminalEvent();
+    }
+    
+    @Test
+    public void andThenError() {
+        TestSubscriber<String> ts = new TestSubscriber<String>(0);
+        final AtomicBoolean hasRun = new AtomicBoolean(false);
+        final Exception e = new Exception();
+        Completable.create(new CompletableOnSubscribe() {
+                @Override
+                public void call(CompletableSubscriber cs) {
+                    cs.onError(e);
+                }
+            })
+            .andThen(Observable.<String>create(new OnSubscribe<String>() {
+                @Override
+                public void call(Subscriber<? super String> s) {
+                    hasRun.set(true);
+                    s.onNext("foo");
+                    s.onCompleted();
+                }
+            }))
+            .subscribe(ts);
+        ts.assertNoValues();
+        ts.assertError(e);
+        Assert.assertFalse("Should not have subscribed to observable when completable errors", hasRun.get());
+    }
+    
+    @Test
+    public void andThenSubscribeOn() {
+        TestSubscriber<String> ts = new TestSubscriber<String>(0);
+        TestScheduler scheduler = new TestScheduler();
+        Completable.complete().andThen(Observable.just("foo").delay(1, TimeUnit.SECONDS, scheduler)).subscribe(ts);
+        ts.requestMore(1);
+        ts.assertNoValues();
+        ts.assertNoTerminalEvent();
+        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+        ts.assertValue("foo");
+        ts.assertCompleted();
+        ts.assertNoErrors();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void createNull() {
+        Completable.create(null);
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void createOnSubscribeThrowsNPE() {
+        Completable c = Completable.create(new CompletableOnSubscribe() {
+            @Override
+            public void call(CompletableSubscriber s) { throw new NullPointerException(); }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void createOnSubscribeThrowsRuntimeException() {
+        try {
+            Completable c = Completable.create(new CompletableOnSubscribe() {
+                @Override
+                public void call(CompletableSubscriber s) {
+                    throw new TestException();
+                }
+            });
+            
+            c.await();
+            
+            Assert.fail("Did not throw exception");
+        } catch (NullPointerException ex) {
+            if (!(ex.getCause() instanceof TestException)) {
+                ex.printStackTrace();
+                Assert.fail("Did not wrap the TestException but it returned: " + ex);
+            }
+        }
+    }
+    
+    @Test(timeout = 1000)
+    public void defer() {
+        Completable c = Completable.defer(new Func0<Completable>() {
+            @Override
+            public Completable call() {
+                return normal.completable;
+            }
+        });
+        
+        normal.assertSubscriptions(0);
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void deferNull() {
+        Completable.defer(null);
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void deferReturnsNull() {
+        Completable c = Completable.defer(new Func0<Completable>() {
+            @Override
+            public Completable call() {
+                return null;
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void deferFunctionThrows() {
+        Completable c = Completable.defer(new Func0<Completable>() {
+            @Override
+            public Completable call() { throw new TestException(); }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void deferErrorSource() {
+        Completable c = Completable.defer(new Func0<Completable>() {
+            @Override
+            public Completable call() {
+                return error.completable;
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void errorNull() {
+        Completable.error((Throwable)null);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void errorNormal() {
+        Completable c = Completable.error(new TestException());
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void fromCallableNull() {
+        Completable.fromCallable(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void fromCallableNormal() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = Completable.fromCallable(new Callable<Object>() {
+            @Override
+            public Object call() throws Exception {
+                return calls.getAndIncrement();
+            }
+        });
+        
+        c.await();
+        
+        Assert.assertEquals(1, calls.get());
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void fromCallableThrows() {
+        Completable c = Completable.fromCallable(new Callable<Object>() {
+            @Override
+            public Object call() throws Exception { throw new TestException(); }
+        });
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void fromObservableNull() {
+        Completable.fromObservable(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void fromObservableEmpty() {
+        Completable c = Completable.fromObservable(Observable.empty());
+        
+        c.await();
+    }
+
+    @Test(timeout = 5000)
+    public void fromObservableSome() {
+        for (int n = 1; n < 10000; n *= 10) {
+            Completable c = Completable.fromObservable(Observable.range(1, n));
+            
+            c.await();
+        }
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void fromObservableError() {
+        Completable c = Completable.fromObservable(Observable.error(new TestException()));
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void fromFutureNull() {
+        Completable.fromFuture(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void fromFutureNormal() {
+        ExecutorService exec = Executors.newSingleThreadExecutor();
+        
+        try {
+            Completable c = Completable.fromFuture(exec.submit(new Runnable() {
+                @Override
+                public void run() { 
+                    // no action
+                }
+            }));
+            
+            c.await();
+        } finally {
+            exec.shutdown();
+        }
+    }
+    
+    @Test(timeout = 1000)
+    public void fromFutureThrows() {
+        ExecutorService exec = Executors.newSingleThreadExecutor();
+        
+        Completable c = Completable.fromFuture(exec.submit(new Runnable() {
+            @Override
+            public void run() { 
+                throw new TestException();
+            }
+        }));
+        
+        try {
+            c.await();
+            Assert.fail("Failed to throw Exception");
+        } catch (RuntimeException ex) {
+            if (!((ex.getCause() instanceof ExecutionException) && (ex.getCause().getCause() instanceof TestException))) {
+                ex.printStackTrace();
+                Assert.fail("Wrong exception received");
+            }
+        } finally {
+            exec.shutdown();
+        }
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void fromActionNull() {
+        Completable.fromAction(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void fromActionNormal() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = Completable.fromAction(new Action0() {
+            @Override
+            public void call() {
+                calls.getAndIncrement();
+            }
+        });
+        
+        c.await();
+        
+        Assert.assertEquals(1, calls.get());
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void fromActionThrows() {
+        Completable c = Completable.fromAction(new Action0() {
+            @Override
+            public void call() { throw new TestException(); }
+        });
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void fromSingleNull() {
+        Completable.fromSingle(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void fromSingleNormal() {
+        Completable c = Completable.fromSingle(Single.just(1));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void fromSingleThrows() {
+        Completable c = Completable.fromSingle(Single.error(new TestException()));
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void mergeNull() {
+        Completable.merge((Completable[])null);
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeEmpty() {
+        Completable c = Completable.merge();
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeSingleSource() {
+        Completable c = Completable.merge(normal.completable);
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeSingleSourceThrows() {
+        Completable c = Completable.merge(error.completable);
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeMultipleSources() {
+        Completable c = Completable.merge(normal.completable, normal.completable, normal.completable);
+        
+        c.await();
+        
+        normal.assertSubscriptions(3);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeMultipleOneThrows() {
+        Completable c = Completable.merge(normal.completable, error.completable, normal.completable);
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void mergeMultipleOneIsNull() {
+        Completable c = Completable.merge(normal.completable, null);
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeIterableEmpty() {
+        Completable c = Completable.merge(Collections.<Completable>emptyList());
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void mergeIterableNull() {
+        Completable.merge((Iterable<Completable>)null);
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void mergeIterableIteratorNull() {
+        Completable c = Completable.merge(new Iterable<Completable>() {
+            @Override
+            public Iterator<Completable> iterator() {
+                return null;
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void mergeIterableWithNull() {
+        Completable c = Completable.merge(Arrays.asList(normal.completable, (Completable)null));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeIterableSingle() {
+        Completable c = Completable.merge(Collections.singleton(normal.completable));
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeIterableMany() {
+        Completable c = Completable.merge(Arrays.asList(normal.completable, normal.completable, normal.completable));
+        
+        c.await();
+        
+        normal.assertSubscriptions(3);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeIterableOneThrows() {
+        Completable c = Completable.merge(Collections.singleton(error.completable));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeIterableManyOneThrows() {
+        Completable c = Completable.merge(Arrays.asList(normal.completable, error.completable));
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void mergeIterableIterableThrows() {
+        Completable c = Completable.merge(new Iterable<Completable>() {
+            @Override
+            public Iterator<Completable> iterator() {
+                throw new TestException();
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void mergeIterableIteratorHasNextThrows() {
+        Completable c = Completable.merge(new IterableIteratorHasNextThrows());
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void mergeIterableIteratorNextThrows() {
+        Completable c = Completable.merge(new IterableIteratorNextThrows());
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeObservableEmpty() {
+        Completable c = Completable.merge(Observable.<Completable>empty());
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeObservableError() {
+        Completable c = Completable.merge(Observable.<Completable>error(new TestException()));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeObservableSingle() {
+        Completable c = Completable.merge(Observable.just(normal.completable));
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeObservableSingleThrows() {
+        Completable c = Completable.merge(Observable.just(error.completable));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeObservableMany() {
+        Completable c = Completable.merge(Observable.just(normal.completable).repeat(3));
+        
+        c.await();
+        
+        normal.assertSubscriptions(3);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeObservableManyOneThrows() {
+        Completable c = Completable.merge(Observable.just(normal.completable, error.completable));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeObservableMaxConcurrent() {
+        final List<Long> requested = new ArrayList<Long>();
+        Observable<Completable> cs = Observable
+                .just(normal.completable)
+                .repeat(10)
+                .doOnRequest(new Action1<Long>() {
+                    @Override
+                    public void call(Long v) {
+                        requested.add(v);
+                    }
+                });
+        
+        Completable c = Completable.merge(cs, 5);
+        
+        c.await();
+        
+        // FIXME this request pattern looks odd because all 10 completions trigger 1 requests
+        Assert.assertEquals(Arrays.asList(5L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L), requested);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void mergeDelayErrorNull() {
+        Completable.mergeDelayError((Completable[])null);
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorEmpty() {
+        Completable c = Completable.mergeDelayError();
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorSingleSource() {
+        Completable c = Completable.mergeDelayError(normal.completable);
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeDelayErrorSingleSourceThrows() {
+        Completable c = Completable.mergeDelayError(error.completable);
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorMultipleSources() {
+        Completable c = Completable.mergeDelayError(normal.completable, normal.completable, normal.completable);
+        
+        c.await();
+        
+        normal.assertSubscriptions(3);
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorMultipleOneThrows() {
+        Completable c = Completable.mergeDelayError(normal.completable, error.completable, normal.completable);
+        
+        try {
+            c.await();
+        } catch (TestException ex) {
+            normal.assertSubscriptions(2);
+        }
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void mergeDelayErrorMultipleOneIsNull() {
+        Completable c = Completable.mergeDelayError(normal.completable, null);
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorIterableEmpty() {
+        Completable c = Completable.mergeDelayError(Collections.<Completable>emptyList());
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void mergeDelayErrorIterableNull() {
+        Completable.mergeDelayError((Iterable<Completable>)null);
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void mergeDelayErrorIterableIteratorNull() {
+        Completable c = Completable.mergeDelayError(new Iterable<Completable>() {
+            @Override
+            public Iterator<Completable> iterator() {
+                return null;
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void mergeDelayErrorIterableWithNull() {
+        Completable c = Completable.mergeDelayError(Arrays.asList(normal.completable, (Completable)null));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorIterableSingle() {
+        Completable c = Completable.mergeDelayError(Collections.singleton(normal.completable));
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorIterableMany() {
+        Completable c = Completable.mergeDelayError(Arrays.asList(normal.completable, normal.completable, normal.completable));
+        
+        c.await();
+        
+        normal.assertSubscriptions(3);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeDelayErrorIterableOneThrows() {
+        Completable c = Completable.mergeDelayError(Collections.singleton(error.completable));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorIterableManyOneThrows() {
+        Completable c = Completable.mergeDelayError(Arrays.asList(normal.completable, error.completable, normal.completable));
+        
+        try {
+            c.await();
+        } catch (TestException ex) {
+            normal.assertSubscriptions(2);
+        }
+    }
+    
+    @Test(expected = TestException.class)
+    public void mergeDelayErrorIterableIterableThrows() {
+        Completable c = Completable.mergeDelayError(new Iterable<Completable>() {
+            @Override
+            public Iterator<Completable> iterator() {
+                throw new TestException();
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void mergeDelayErrorIterableIteratorHasNextThrows() {
+        Completable c = Completable.mergeDelayError(new IterableIteratorHasNextThrows());
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void mergeDelayErrorIterableIteratorNextThrows() {
+        Completable c = Completable.mergeDelayError(new IterableIteratorNextThrows());
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorObservableEmpty() {
+        Completable c = Completable.mergeDelayError(Observable.<Completable>empty());
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeDelayErrorObservableError() {
+        Completable c = Completable.mergeDelayError(Observable.<Completable>error(new TestException()));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorObservableSingle() {
+        Completable c = Completable.mergeDelayError(Observable.just(normal.completable));
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeDelayErrorObservableSingleThrows() {
+        Completable c = Completable.mergeDelayError(Observable.just(error.completable));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorObservableMany() {
+        Completable c = Completable.mergeDelayError(Observable.just(normal.completable).repeat(3));
+        
+        c.await();
+        
+        normal.assertSubscriptions(3);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void mergeDelayErrorObservableManyOneThrows() {
+        Completable c = Completable.mergeDelayError(Observable.just(normal.completable, error.completable));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeDelayErrorObservableMaxConcurrent() {
+        final List<Long> requested = new ArrayList<Long>();
+        Observable<Completable> cs = Observable
+                .just(normal.completable)
+                .repeat(10)
+                .doOnRequest(new Action1<Long>() {
+                    @Override
+                    public void call(Long v) {
+                        requested.add(v);
+                    }
+                });
+        
+        Completable c = Completable.mergeDelayError(cs, 5);
+        
+        c.await();
+        
+        // FIXME this request pattern looks odd because all 10 completions trigger 1 requests
+        Assert.assertEquals(Arrays.asList(5L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L), requested);
+    }
+
+    @Test(timeout = 1000)
+    public void never() {
+        final AtomicBoolean onSubscribeCalled = new AtomicBoolean();
+        final AtomicInteger calls = new AtomicInteger();
+        Completable.never().subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                onSubscribeCalled.set(true);
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                calls.getAndIncrement();
+            }
+            
+            @Override
+            public void onCompleted() {
+                calls.getAndIncrement();
+            }
+        });
+        
+        Assert.assertTrue("onSubscribe not called", onSubscribeCalled.get());
+        Assert.assertEquals("There were calls to onXXX methods", 0, calls.get());
+    }
+    
+    @Test(timeout = 1500)
+    public void timer() {
+        Completable c = Completable.timer(500, TimeUnit.MILLISECONDS);
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1500)
+    public void timerNewThread() {
+        Completable c = Completable.timer(500, TimeUnit.MILLISECONDS, Schedulers.newThread());
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void timerTestScheduler() {
+        TestScheduler scheduler = Schedulers.test();
+        
+        Completable c = Completable.timer(250, TimeUnit.MILLISECONDS, scheduler);
+        
+        final AtomicInteger calls = new AtomicInteger();
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+            
+            @Override
+            public void onCompleted() {
+                calls.getAndIncrement();
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
+            }
+        });
+
+        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);
+        
+        Assert.assertEquals(0, calls.get());
+        
+        scheduler.advanceTimeBy(200, TimeUnit.MILLISECONDS);
+        
+        Assert.assertEquals(1, calls.get());
+    }
+    
+    @Test(timeout = 2000)
+    public void timerCancel() throws InterruptedException {
+        Completable c = Completable.timer(250, TimeUnit.MILLISECONDS);
+        
+        final MultipleAssignmentSubscription mad = new MultipleAssignmentSubscription();
+        final AtomicInteger calls = new AtomicInteger();
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                mad.set(d);
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                calls.getAndIncrement();
+            }
+            
+            @Override
+            public void onCompleted() {
+                calls.getAndIncrement();
+            }
+        });
+        
+        Thread.sleep(100);
+        
+        mad.unsubscribe();
+        
+        Thread.sleep(200);
+        
+        Assert.assertEquals(0, calls.get());
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void timerUnitNull() {
+        Completable.timer(1, null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void timerSchedulerNull() {
+        Completable.timer(1, TimeUnit.SECONDS, null);
+    }
+    
+    @Test(timeout = 1000)
+    public void usingNormalEager() {
+        final AtomicInteger unsubscribe = new AtomicInteger();
+        
+        Completable c = Completable.using(new Func0<Integer>() {
+            @Override
+            public Integer call() {
+                return 1;
+            }
+        }, new Func1<Object, Completable>() {
+            @Override
+            public Completable call(Object v) {
+                return normal.completable;
+            }
+        }, new Action1<Integer>() {
+            @Override
+            public void call(Integer d) {
+                unsubscribe.set(d);
+            }
+        });
+        
+        final AtomicBoolean unsubscribedFirst = new AtomicBoolean();
+        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                error.lazySet(e);
+            }
+            
+            @Override
+            public void onCompleted() {
+                unsubscribedFirst.set(unsubscribe.get() != 0);
+            }
+        });
+        
+        Assert.assertEquals(1, unsubscribe.get());
+        Assert.assertTrue("Not unsubscribed first", unsubscribedFirst.get());
+        Assert.assertNull(error.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void usingNormalLazy() {
+        final AtomicInteger unsubscribe = new AtomicInteger();
+        
+        Completable c = Completable.using(new Func0<Integer>() {
+            @Override
+            public Integer call() {
+                return 1;
+            }
+        }, new Func1<Integer, Completable>() {
+            @Override
+            public Completable call(Integer v) {
+                return normal.completable;
+            }
+        }, new Action1<Integer>() {
+            @Override
+            public void call(Integer d) {
+                unsubscribe.set(d);
+            }
+        }, false);
+        
+        final AtomicBoolean unsubscribedFirst = new AtomicBoolean();
+        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                error.lazySet(e);
+            }
+            
+            @Override
+            public void onCompleted() {
+                unsubscribedFirst.set(unsubscribe.get() != 0);
+            }
+        });
+        
+        Assert.assertEquals(1, unsubscribe.get());
+        Assert.assertFalse("Disposed first", unsubscribedFirst.get());
+        Assert.assertNull(error.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void usingErrorEager() {
+        final AtomicInteger unsubscribe = new AtomicInteger();
+        
+        Completable c = Completable.using(new Func0<Integer>() {
+            @Override
+            public Integer call() {
+                return 1;
+            }
+        }, new Func1<Integer, Completable>() {
+            @Override
+            public Completable call(Integer v) {
+                return error.completable;
+            }
+        }, new Action1<Integer>() {
+            @Override
+            public void call(Integer d) {
+                unsubscribe.set(d);
+            }
+        });
+        
+        final AtomicBoolean unsubscribedFirst = new AtomicBoolean();
+        final AtomicBoolean complete = new AtomicBoolean();
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                unsubscribedFirst.set(unsubscribe.get() != 0);
+            }
+            
+            @Override
+            public void onCompleted() {
+                complete.set(true);
+            }
+        });
+        
+        Assert.assertEquals(1, unsubscribe.get());
+        Assert.assertTrue("Not unsubscribed first", unsubscribedFirst.get());
+        Assert.assertFalse(complete.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void usingErrorLazy() {
+        final AtomicInteger unsubscribe = new AtomicInteger();
+        
+        Completable c = Completable.using(new Func0<Integer>() {
+            @Override
+            public Integer call() {
+                return 1;
+            }
+        }, new Func1<Integer, Completable>() {
+            @Override
+            public Completable call(Integer v) {
+                return error.completable;
+            }
+        }, new Action1<Integer>() {
+            @Override
+            public void call(Integer d) {
+                unsubscribe.set(d);
+            }
+        }, false);
+        
+        final AtomicBoolean unsubscribedFirst = new AtomicBoolean();
+        final AtomicBoolean complete = new AtomicBoolean();
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                unsubscribedFirst.set(unsubscribe.get() != 0);
+            }
+            
+            @Override
+            public void onCompleted() {
+                complete.set(true);
+            }
+        });
+        
+        Assert.assertEquals(1, unsubscribe.get());
+        Assert.assertFalse("Disposed first", unsubscribedFirst.get());
+        Assert.assertFalse(complete.get());
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void usingResourceSupplierNull() {
+        Completable.using(null, new Func1<Object, Completable>() {
+            @Override
+            public Completable call(Object v) {
+                return normal.completable;
+            }
+        }, new Action1<Object>() {
+            @Override
+            public void call(Object v) { }
+        });
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void usingMapperNull() {
+        Completable.using(new Func0<Object>() {
+            @Override
+            public Object call() {
+                return 1;
+            }
+        }, null, new Action1<Object>() {
+            @Override
+            public void call(Object v) { }
+        });
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void usingMapperReturnsNull() {
+        Completable c = Completable.using(new Func0<Object>() {
+            @Override
+            public Object call() {
+                return 1;
+            }
+        }, new Func1<Object, Completable>() {
+            @Override
+            public Completable call(Object v) {
+                return null;
+            }
+        }, new Action1<Object>() {
+            @Override
+            public void call(Object v) { }
+        });
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void usingDisposeNull() {
+        Completable.using(new Func0<Object>() {
+            @Override
+            public Object call() {
+                return 1;
+            }
+        }, new Func1<Object, Completable>() {
+            @Override
+            public Completable call(Object v) {
+                return normal.completable;
+            }
+        }, null);
+    }
+    
+    @Test(expected = TestException.class)
+    public void usingResourceThrows() {
+        Completable c = Completable.using(new Func0<Object>() {
+            @Override
+            public Object call() { throw new TestException(); }
+        }, 
+                new Func1<Object, Completable>() {
+                    @Override
+                    public Completable call(Object v) {
+                        return normal.completable;
+                    }
+                }, new Action1<Object>() {
+                    @Override
+                    public void call(Object v) { }
+                });
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void usingMapperThrows() {
+        Completable c = Completable.using(new Func0<Object>() {
+            @Override
+            public Object call() {
+                return 1;
+            }
+        }, 
+                new Func1<Object, Completable>() {
+                    @Override
+                    public Completable call(Object v) { throw new TestException(); }
+                }, new Action1<Object>() {
+                    @Override
+                    public void call(Object v) { }
+                });
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void usingDisposerThrows() {
+        Completable c = Completable.using(new Func0<Object>() {
+            @Override
+            public Object call() {
+                return 1;
+            }
+        }, 
+                new Func1<Object, Completable>() {
+                    @Override
+                    public Completable call(Object v) {
+                        return normal.completable;
+                    }
+                }, new Action1<Object>() {
+                    @Override
+                    public void call(Object v) { throw new TestException(); }
+                });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void composeNormal() {
+        Completable c = error.completable.compose(new CompletableTransformer() {
+            @Override
+            public Completable call(Completable n) {
+                return n.onErrorComplete();
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void composeNull() {
+        error.completable.compose(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void concatWithNormal() {
+        Completable c = normal.completable.concatWith(normal.completable);
+        
+        c.await();
+        
+        normal.assertSubscriptions(2);
+    }
+
+    @Test(timeout = 1000, expected = TestException.class)
+    public void concatWithError() {
+        Completable c = normal.completable.concatWith(error.completable);
+        
+        c.await();
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void concatWithNull() {
+        normal.completable.concatWith(null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void delayUnitNull() {
+        normal.completable.delay(1, null);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void delaySchedulerNull() {
+        normal.completable.delay(1, TimeUnit.SECONDS, null);
+    }
+    
+    @Test(timeout = 1000)
+    public void delayNormal() throws InterruptedException {
+        Completable c = normal.completable.delay(250, TimeUnit.MILLISECONDS);
+        
+        final AtomicBoolean done = new AtomicBoolean();
+        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                error.set(e);
+            }
+            
+            @Override
+            public void onCompleted() {
+                done.set(true);
+            }
+        });
+        
+        Thread.sleep(100);
+        
+        Assert.assertFalse("Already done", done.get());
+        
+        Thread.sleep(200);
+        
+        Assert.assertTrue("Not done", done.get());
+        
+        Assert.assertNull(error.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void delayErrorImmediately() throws InterruptedException {
+        Completable c = error.completable.delay(250, TimeUnit.MILLISECONDS);
+        
+        final AtomicBoolean done = new AtomicBoolean();
+        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                error.set(e);
+            }
+            
+            @Override
+            public void onCompleted() {
+                done.set(true);
+            }
+        });
+
+        Assert.assertTrue(error.get().toString(), error.get() instanceof TestException);
+        Assert.assertFalse("Already done", done.get());
+
+        Thread.sleep(100);
+        
+        Assert.assertFalse("Already done", done.get());
+        
+        Thread.sleep(200);
+    }
+    
+    @Test(timeout = 1000)
+    public void delayErrorToo() throws InterruptedException {
+        Completable c = error.completable.delay(250, TimeUnit.MILLISECONDS, Schedulers.computation(), true);
+        
+        final AtomicBoolean done = new AtomicBoolean();
+        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                error.set(e);
+            }
+            
+            @Override
+            public void onCompleted() {
+                done.set(true);
+            }
+        });
+        
+        Thread.sleep(100);
+        
+        Assert.assertFalse("Already done", done.get());
+        Assert.assertNull(error.get());
+        
+        Thread.sleep(200);
+        
+        Assert.assertFalse("Already done", done.get());
+        Assert.assertTrue(error.get() instanceof TestException);
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnCompleteNormal() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = normal.completable.doOnComplete(new Action0() {
+            @Override
+            public void call() {
+                calls.getAndIncrement();
+            }
+        });
+        
+        c.await();
+        
+        Assert.assertEquals(1, calls.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnCompleteError() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = error.completable.doOnComplete(new Action0() {
+            @Override
+            public void call() {
+                calls.getAndIncrement();
+            }
+        });
+        
+        try {
+            c.await();
+            Assert.fail("Failed to throw TestException");
+        } catch (TestException ex) {
+            // expected
+        }
+        
+        Assert.assertEquals(0, calls.get());
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void doOnCompleteNull() {
+        normal.completable.doOnComplete(null);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void doOnCompleteThrows() {
+        Completable c = normal.completable.doOnComplete(new Action0() {
+            @Override
+            public void call() { throw new TestException(); }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnDisposeNormalDoesntCall() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = normal.completable.doOnUnsubscribe(new Action0() {
+            @Override
+            public void call() {
+                calls.getAndIncrement();
+            }
+        });
+        
+        c.await();
+        
+        Assert.assertEquals(0, calls.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnDisposeErrorDoesntCall() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = error.completable.doOnUnsubscribe(new Action0() {
+            @Override
+            public void call() {
+                calls.getAndIncrement();
+            }
+        });
+        
+        try {
+            c.await();
+            Assert.fail("No exception thrown");
+        } catch (TestException ex) {
+            // expected
+        }
+        Assert.assertEquals(0, calls.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnDisposeChildCancels() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = normal.completable.doOnUnsubscribe(new Action0() {
+            @Override
+            public void call() {
+                calls.getAndIncrement();
+            }
+        });
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                d.unsubscribe();
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                // ignored
+            }
+            
+            @Override
+            public void onCompleted() {
+                // ignored
+            }
+        });
+        
+        Assert.assertEquals(1, calls.get());
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void doOnDisposeNull() {
+        normal.completable.doOnUnsubscribe(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnDisposeThrows() {
+        Completable c = normal.completable.doOnUnsubscribe(new Action0() {
+            @Override
+            public void call() { throw new TestException(); }
+        });
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                d.unsubscribe();
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                // ignored
+            }
+            
+            @Override
+            public void onCompleted() {
+                // ignored
+            }
+        });
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnErrorNoError() {
+        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
+        
+        Completable c = normal.completable.doOnError(new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) {
+                error.set(e);
+            }
+        });
+        
+        c.await();
+        
+        Assert.assertNull(error.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnErrorHasError() {
+        final AtomicReference<Throwable> err = new AtomicReference<Throwable>();
+        
+        Completable c = error.completable.doOnError(new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) {
+                err.set(e);
+            }
+        });
+        
+        try {
+            c.await();
+            Assert.fail("Did not throw exception");
+        } catch (Throwable e) {
+            // expected
+        }
+        
+        Assert.assertTrue(err.get() instanceof TestException);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void doOnErrorNull() {
+        normal.completable.doOnError(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnErrorThrows() {
+        Completable c = error.completable.doOnError(new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) { throw new IllegalStateException(); }
+        });
+        
+        try {
+            c.await();
+        } catch (IllegalStateException ex) {
+            Throwable[] a = ex.getSuppressed();
+            Assert.assertEquals(1, a.length);
+            Assert.assertTrue(a[0] instanceof TestException);
+        }
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnSubscribeNormal() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = normal.completable.doOnSubscribe(new Action1<Subscription>() {
+            @Override
+            public void call(Subscription s) {
+                calls.getAndIncrement();
+            }
+        });
+        
+        for (int i = 0; i < 10; i++) {
+            c.await();
+        }
+        
+        Assert.assertEquals(10, calls.get());
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void doOnSubscribeNull() {
+        normal.completable.doOnSubscribe(null);
+    }
+    
+    @Test(expected = TestException.class)
+    public void doOnSubscribeThrows() {
+        Completable c = normal.completable.doOnSubscribe(new Action1<Subscription>() {
+            @Override
+            public void call(Subscription d) { throw new TestException(); }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnTerminateNormal() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = normal.completable.doOnTerminate(new Action0() {
+            @Override
+            public void call() {
+                calls.getAndIncrement();
+            }
+        });
+        
+        c.await();
+        
+        Assert.assertEquals(1, calls.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void doOnTerminateError() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = error.completable.doOnTerminate(new Action0() {
+            @Override
+            public void call() {
+                calls.getAndIncrement();
+            }
+        });
+        
+        try {
+            c.await();
+            Assert.fail("Did dot throw exception");
+        } catch (TestException ex) {
+            // expected
+        }
+        
+        Assert.assertEquals(1, calls.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void doAfterTerminateNormal() {
+        final AtomicBoolean doneAfter = new AtomicBoolean();
+        final AtomicBoolean complete = new AtomicBoolean();
+        
+        Completable c = normal.completable.doAfterTerminate(new Action0() {
+            @Override
+            public void call() {
+                doneAfter.set(complete.get());
+            }
+        });
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                
+            }
+            
+            @Override
+            public void onCompleted() {
+                complete.set(true);
+            }
+        });
+        
+        c.await();
+        
+        Assert.assertTrue("Not completed", complete.get());
+        Assert.assertTrue("Closure called before onComplete", doneAfter.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void doAfterTerminateWithError() {
+        final AtomicBoolean doneAfter = new AtomicBoolean();
+        
+        Completable c = error.completable.doAfterTerminate(new Action0() {
+            @Override
+            public void call() {
+                doneAfter.set(true);
+            }
+        });
+        
+        try {
+            c.await();
+            Assert.fail("Did not throw TestException");
+        } catch (TestException ex) {
+            // expected
+        }
+        
+        Assert.assertFalse("Closure called", doneAfter.get());
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void doAfterTerminateNull() {
+        normal.completable.doAfterTerminate(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void getNormal() {
+        Assert.assertNull(normal.completable.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void getError() {
+        Assert.assertTrue(error.completable.get() instanceof TestException);
+    }
+    
+    @Test(timeout = 1000)
+    public void getTimeout() {
+        try {
+            Completable.never().get(100, TimeUnit.MILLISECONDS);
+        } catch (RuntimeException ex) {
+            if (!(ex.getCause() instanceof TimeoutException)) {
+                Assert.fail("Wrong exception cause: " + ex.getCause());
+            }
+        }
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void getNullUnit() {
+        normal.completable.get(1, null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void liftNull() {
+        normal.completable.lift(null);
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void liftReturnsNull() {
+        Completable c = normal.completable.lift(new CompletableOperator() {
+            @Override
+            public CompletableSubscriber call(CompletableSubscriber v) {
+                return null;
+            }
+        });
+        
+        c.await();
+    }
+
+    final static class CompletableOperatorSwap implements CompletableOperator {
+        @Override
+        public CompletableSubscriber call(final CompletableSubscriber v) {
+            return new CompletableSubscriber() {
+
+                @Override
+                public void onCompleted() {
+                    v.onError(new TestException());
+                }
+
+                @Override
+                public void onError(Throwable e) {
+                    v.onCompleted();
+                }
+
+                @Override
+                public void onSubscribe(Subscription d) {
+                    v.onSubscribe(d);
+                }
+                
+            };
+        }
+    }
+    @Test(timeout = 1000, expected = TestException.class)
+    public void liftOnCompleteError() {
+        Completable c = normal.completable.lift(new CompletableOperatorSwap());
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void liftOnErrorComplete() {
+        Completable c = error.completable.lift(new CompletableOperatorSwap());
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void mergeWithNull() {
+        normal.completable.mergeWith(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void mergeWithNormal() {
+        Completable c = normal.completable.mergeWith(normal.completable);
+        
+        c.await();
+        
+        normal.assertSubscriptions(2);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void observeOnNull() {
+        normal.completable.observeOn(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void observeOnNormal() throws InterruptedException {
+        final AtomicReference<String> name = new AtomicReference<String>();
+        final AtomicReference<Throwable> err = new AtomicReference<Throwable>();
+        final CountDownLatch cdl = new CountDownLatch(1);
+        
+        Completable c = normal.completable.observeOn(Schedulers.computation());
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+            
+            @Override
+            public void onCompleted() {
+                name.set(Thread.currentThread().getName());
+                cdl.countDown();
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                err.set(e);
+                cdl.countDown();
+            }
+        });
+        
+        cdl.await();
+        
+        Assert.assertNull(err.get());
+        Assert.assertTrue(name.get().startsWith("RxComputation"));
+    }
+    
+    @Test(timeout = 1000)
+    public void observeOnError() throws InterruptedException {
+        final AtomicReference<String> name = new AtomicReference<String>();
+        final AtomicReference<Throwable> err = new AtomicReference<Throwable>();
+        final CountDownLatch cdl = new CountDownLatch(1);
+        
+        Completable c = error.completable.observeOn(Schedulers.computation());
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(Subscription d) {
+                
+            }
+            
+            @Override
+            public void onCompleted() {
+                name.set(Thread.currentThread().getName());
+                cdl.countDown();
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                name.set(Thread.currentThread().getName());
+                err.set(e);
+                cdl.countDown();
+            }
+        });
+        
+        cdl.await();
+        
+        Assert.assertTrue(err.get() instanceof TestException);
+        Assert.assertTrue(name.get().startsWith("RxComputation"));
+    }
+    
+    @Test(timeout = 1000)
+    public void onErrorComplete() {
+        Completable c = error.completable.onErrorComplete();
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void onErrorCompleteFalse() {
+        Completable c = error.completable.onErrorComplete(new Func1<Throwable, Boolean>() {
+            @Override
+            public Boolean call(Throwable e) {
+                return e instanceof IllegalStateException;
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void onErrorCompleteNull() {
+        error.completable.onErrorComplete(null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void onErrorResumeNextNull() {
+        error.completable.onErrorResumeNext(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void onErrorResumeNextFunctionReturnsNull() {
+        Completable c = error.completable.onErrorResumeNext(new Func1<Throwable, Completable>() {
+            @Override
+            public Completable call(Throwable e) {
+                return null;
+            }
+        });
+        
+        try {
+            c.await();
+            Assert.fail("Did not throw an exception");
+        } catch (NullPointerException ex) {
+            Throwable[] a = ex.getSuppressed();
+                    
+            Assert.assertEquals(1, a.length);
+            Assert.assertTrue(a[0] instanceof TestException);
+        }
+    }
+    
+    @Test(timeout = 1000)
+    public void onErrorResumeNextFunctionThrows() {
+        Completable c = error.completable.onErrorResumeNext(new Func1<Throwable, Completable>() {
+            @Override
+            public Completable call(Throwable e) { throw new TestException(); }
+        });
+        
+        try {
+            c.await();
+            Assert.fail("Did not throw an exception");
+        } catch (TestException ex) {
+            Throwable[] a = ex.getSuppressed();
+                    
+            Assert.assertEquals(1, a.length);
+            Assert.assertTrue(a[0] instanceof TestException);
+        }
+    }
+    
+    @Test(timeout = 1000)
+    public void onErrorResumeNextNormal() {
+        Completable c = error.completable.onErrorResumeNext(new Func1<Throwable, Completable>() {
+            @Override
+            public Completable call(Throwable v) {
+                return normal.completable;
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void onErrorResumeNextError() {
+        Completable c = error.completable.onErrorResumeNext(new Func1<Throwable, Completable>() {
+            @Override
+            public Completable call(Throwable v) {
+                return error.completable;
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 2000)
+    public void repeatNormal() {
+        final AtomicReference<Throwable> err = new AtomicReference<Throwable>();
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = Completable.fromCallable(new Callable<Object>() {
+            @Override
+            public Object call() throws Exception {
+                calls.getAndIncrement();
+                Thread.sleep(100);
+                return null;
+            }
+        }).repeat();
+        
+        c.subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(final Subscription d) {
+                final Scheduler.Worker w = Schedulers.io().createWorker();
+                w.schedule(new Action0() {
+                    @Override
+                    public void call() {
+                        try {
+                            d.unsubscribe();
+                        } finally {
+                            w.unsubscribe();
+                        }
+                    }
+                }, 550, TimeUnit.MILLISECONDS);
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                err.set(e);
+            }
+            
+            @Override
+            public void onCompleted() {
+                
+            }
+        });
+        
+        Assert.assertEquals(6, calls.get());
+        Assert.assertNull(err.get());
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void repeatError() {
+        Completable c = error.completable.repeat();
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void repeat5Times() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = Completable.fromCallable(new Callable<Object>() {
+            @Override
+            public Object call() throws Exception {
+                calls.getAndIncrement();
+                return null;
+            }
+        }).repeat(5);
+        
+        c.await();
+        
+        Assert.assertEquals(5, calls.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void repeat1Time() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = Completable.fromCallable(new Callable<Object>() {
+            @Override
+            public Object call() throws Exception {
+                calls.getAndIncrement();
+                return null;
+            }
+        }).repeat(1);
+        
+        c.await();
+        
+        Assert.assertEquals(1, calls.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void repeat0Time() {
+        final AtomicInteger calls = new AtomicInteger();
+        
+        Completable c = Completable.fromCallable(new Callable<Object>() {
+            @Override
+            public Object call() throws Exception {
+                calls.getAndIncrement();
+                return null;
+            }
+        }).repeat(0);
+        
+        c.await();
+        
+        Assert.assertEquals(0, calls.get());
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void repeatWhenNull() {
+        normal.completable.repeatWhen(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void retryNormal() {
+        Completable c = normal.completable.retry();
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000)
+    public void retry5Times() {
+        final AtomicInteger calls = new AtomicInteger(5);
+        
+        Completable c = Completable.fromAction(new Action0() {
+            @Override
+            public void call() {
+                if (calls.decrementAndGet() != 0) {
+                    throw new TestException();
+                }
+            }
+        }).retry();
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void retryBiPredicate5Times() {
+        Completable c = error.completable.retry(new Func2<Integer, Throwable, Boolean>() {
+            @Override
+            public Boolean call(Integer n, Throwable e) {
+                return n < 5;
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void retryTimes5Error() {
+        Completable c = error.completable.retry(5);
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void retryTimes5Normal() {
+        final AtomicInteger calls = new AtomicInteger(5);
+
+        Completable c = Completable.fromAction(new Action0() {
+            @Override
+            public void call() {
+                if (calls.decrementAndGet() != 0) {
+                    throw new TestException();
+                }
+            }
+        }).retry(5);
+        
+        c.await();
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void retryNegativeTimes() {
+        normal.completable.retry(-1);
+    }
+    
+    @Test(timeout = 1000)
+    public void retryWhen5Times() {
+        final AtomicInteger calls = new AtomicInteger(5);
+
+        Completable c = Completable.fromAction(new Action0() {
+            @Override
+            public void call() {
+                if (calls.decrementAndGet() != 0) {
+                    throw new TestException();
+                }
+            }
+        }).retryWhen(new Func1<Observable<? extends Throwable>, Observable<Object>>() {
+            @SuppressWarnings({ "unchecked", "rawtypes" })
+            @Override
+            public Observable<Object> call(Observable<? extends Throwable> o) {
+                return (Observable)o;
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void subscribe() throws InterruptedException {
+        final AtomicBoolean complete = new AtomicBoolean();
+        
+        Completable c = normal.completable
+                .delay(100, TimeUnit.MILLISECONDS)
+                .doOnComplete(new Action0() {
+                    @Override
+                    public void call() {
+                        complete.set(true);
+                    }
+                });
+        
+        c.subscribe();
+        
+        Thread.sleep(150);
+        
+        Assert.assertTrue("Not completed", complete.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void subscribeDispose() throws InterruptedException {
+        final AtomicBoolean complete = new AtomicBoolean();
+        
+        Completable c = normal.completable
+                .delay(200, TimeUnit.MILLISECONDS)
+                .doOnComplete(new Action0() {
+                    @Override
+                    public void call() {
+                        complete.set(true);
+                    }
+                });
+        
+        Subscription d = c.subscribe();
+        
+        Thread.sleep(100);
+        
+        d.unsubscribe();
+        
+        Thread.sleep(150);
+        
+        Assert.assertFalse("Completed", complete.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void subscribeTwoCallbacksNormal() {
+        final AtomicReference<Throwable> err = new AtomicReference<Throwable>();
+        final AtomicBoolean complete = new AtomicBoolean();
+        normal.completable.subscribe(new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) {
+                err.set(e);
+            }
+        }, new Action0() {
+            @Override
+            public void call() {
+                complete.set(true);
+            }
+        });
+        
+        Assert.assertNull(err.get());
+        Assert.assertTrue("Not completed", complete.get());
+    }
+    
+    @Test(timeout = 1000)
+    public void subscribeTwoCallbacksError() {
+        final AtomicReference<Throwable> err = new AtomicReference<Throwable>();
+        final AtomicBoolean complete = new AtomicBoolean();
+        error.completable.subscribe(new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) {
+                err.set(e);
+            }
+        }, new Action0() {
+            @Override
+            public void call() {
+                complete.set(true);
+            }
+        });
+        
+        Assert.assertTrue(err.get() instanceof TestException);
+        Assert.assertFalse("Not completed", complete.get());
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void subscribeTwoCallbacksFirstNull() {
+        normal.completable.subscribe(null, new Action0() {
+            @Override
+            public void call() { }
+        });
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void subscribeTwoCallbacksSecondNull() {
+        normal.completable.subscribe(null, new Action0() {
+            @Override
+            public void call() { }
+        });
+    }
+    
+    @Test(timeout = 1000)
+    public void subscribeTwoCallbacksCompleteThrows() {
+        final AtomicReference<Throwable> err = new AtomicReference<Throwable>();
+        normal.completable.subscribe(new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) {
+                err.set(e);
+            }
+        }, new Action0() {
+            @Override
+            public void call() { throw new TestException(); }
+        });
+        
+        Assert.assertTrue(String.valueOf(err.get()), err.get() instanceof TestException);
+    }
+    
+    @Test(timeout = 1000)
+    public void subscribeTwoCallbacksOnErrorThrows() {
+        error.completable.subscribe(new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) { throw new TestException(); }
+        }, new Action0() {
+            @Override
+            public void call() { }
+        });
+    }
+    
+    @Test(timeout = 1000)
+    public void subscribeActionNormal() {
+        final AtomicBoolean run = new AtomicBoolean();
+        
+        normal.completable.subscribe(new Action0() {
+            @Override
+            public void call() {
+                run.set(true);
+            }
+        });
+        
+        Assert.assertTrue("Not completed", run.get());
+    }
+
+    @Test(timeout = 1000)
+    public void subscribeActionError() {
+        final AtomicBoolean run = new AtomicBoolean();
+        
+        error.completable.subscribe(new Action0() {
+            @Override
+            public void call() {
+                run.set(true);
+            }
+        });
+        
+        Assert.assertFalse("Completed", run.get());
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void subscribeActionNull() {
+        normal.completable.subscribe((Action0)null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void subscribeSubscriberNull() {
+        normal.completable.subscribe((Subscriber<Object>)null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void subscribeCompletableSubscriberNull() {
+        normal.completable.subscribe((CompletableSubscriber)null);
+    }
+
+    @Test(timeout = 1000)
+    public void subscribeSubscriberNormal() {
+        TestSubscriber<Object> ts = new TestSubscriber<Object>();
+        
+        normal.completable.subscribe(ts);
+        
+        ts.assertCompleted();
+        ts.assertNoValues();
+        ts.assertNoErrors();
+    }
+
+    @Test(timeout = 1000)
+    public void subscribeSubscriberError() {
+        TestSubscriber<Object> ts = new TestSubscriber<Object>();
+        
+        error.completable.subscribe(ts);
+        
+        ts.assertNotCompleted();
+        ts.assertNoValues();
+        ts.assertError(TestException.class);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void subscribeOnNull() {
+        normal.completable.subscribeOn(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void subscribeOnNormal() {
+        final AtomicReference<String> name = new  AtomicReference<String>();
+        
+        Completable c = Completable.create(new CompletableOnSubscribe() {
+            @Override
+            public void call(CompletableSubscriber s) { 
+                name.set(Thread.currentThread().getName());
+                s.onSubscribe(Subscriptions.unsubscribed());
+                s.onCompleted();
+            }
+        }).subscribeOn(Schedulers.computation());
+        
+        c.await();
+        
+        Assert.assertTrue(name.get().startsWith("RxComputation"));
+    }
+    
+    @Test(timeout = 1000)
+    public void subscribeOnError() {
+        final AtomicReference<String> name = new  AtomicReference<String>();
+        
+        Completable c = Completable.create(new CompletableOnSubscribe() {
+            @Override
+            public void call(CompletableSubscriber s) { 
+                name.set(Thread.currentThread().getName());
+                s.onSubscribe(Subscriptions.unsubscribed());
+                s.onError(new TestException());
+            }
+        }).subscribeOn(Schedulers.computation());
+        
+        try {
+            c.await();
+            Assert.fail("No exception thrown");
+        } catch (TestException ex) {
+            // expected
+        }
+        
+        Assert.assertTrue(name.get().startsWith("RxComputation"));
+    }
+    
+    @Test(timeout = 1000)
+    public void timeoutEmitError() {
+        Throwable e = Completable.never().timeout(100, TimeUnit.MILLISECONDS).get();
+        
+        Assert.assertTrue(e instanceof TimeoutException);
+    }
+    
+    @Test(timeout = 1000)
+    public void timeoutSwitchNormal() {
+        Completable c = Completable.never().timeout(100, TimeUnit.MILLISECONDS, normal.completable);
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000)
+    public void timeoutTimerCancelled() throws InterruptedException {
+        Completable c = Completable.fromCallable(new Callable<Object>() {
+            @Override
+            public Object call() throws Exception {
+                Thread.sleep(50);
+                return null;
+            }
+        }).timeout(100, TimeUnit.MILLISECONDS, normal.completable);
+        
+        c.await();
+        
+        Thread.sleep(100);
+        
+        normal.assertSubscriptions(0);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void timeoutUnitNull() {
+        normal.completable.timeout(1, null);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void timeoutSchedulerNull() {
+        normal.completable.timeout(1, TimeUnit.SECONDS, (Scheduler)null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void timeoutOtherNull() {
+        normal.completable.timeout(1, TimeUnit.SECONDS, (Completable)null);
+    }
+    
+    @Test(timeout = 1000)
+    public void toNormal() {
+        Observable<?> flow = normal.completable.to(new Func1<Completable, Observable<Object>>() {
+            @Override
+            public Observable<Object> call(Completable c) {
+                return c.toObservable();
+            }
+        });
+        
+        flow.toBlocking().forEach(new Action1<Object>(){
+            @Override 
+            public void call(Object e){ }
+        });
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void toNull() {
+        normal.completable.to(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void toObservableNormal() {
+        normal.completable.toObservable().toBlocking().forEach(new Action1<Object>() {
+            @Override
+            public void call(Object e) { }
+        });
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void toObservableError() {
+        error.completable.toObservable().toBlocking().forEach(new Action1<Object>() {
+            @Override
+            public void call(Object e) { }
+        });
+    }
+
+    static <T> T get(Single<T> single) {
+        final CountDownLatch cdl = new CountDownLatch(1);
+        
+        final AtomicReference<T> v = new AtomicReference<T>();
+        final AtomicReference<Throwable> e = new AtomicReference<Throwable>();
+        
+        single.subscribe(new SingleSubscriber<T>() {
+
+            @Override
+            public void onSuccess(T value) {
+                v.set(value);
+                cdl.countDown();
+            }
+
+            @Override
+            public void onError(Throwable error) {
+                e.set(error);
+                cdl.countDown();
+            }
+        });
+        
+        try {
+            cdl.await();
+        } catch (InterruptedException ex) {
+            Exceptions.propagate(ex);
+        }
+        
+        if (e.get() != null) {
+            Exceptions.propagate(e.get());
+        }
+        return v.get();
+    }
+    
+    @Test(timeout = 1000)
+    public void toSingleSupplierNormal() {
+        int v = get(normal.completable.toSingle(new Func0<Integer>() {
+            @Override
+            public Integer call() {
+                return 1;
+            }
+        }));
+        
+        Assert.assertEquals(1, v);
+    }
+
+    @Test(timeout = 1000, expected = TestException.class)
+    public void toSingleSupplierError() {
+        get(error.completable.toSingle(new Func0<Object>() {
+            @Override
+            public Object call() {
+                return 1;
+            }
+        }));
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void toSingleSupplierNull() {
+        normal.completable.toSingle(null);
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void toSingleSupplierReturnsNull() {
+        get(normal.completable.toSingle(new Func0<Object>() {
+            @Override
+            public Object call() {
+                return null;
+            }
+        }));
+    }
+
+    @Test(expected = TestException.class)
+    public void toSingleSupplierThrows() {
+        get(normal.completable.toSingle(new Func0<Object>() {
+            @Override
+            public Object call() { throw new TestException(); }
+        }));
+    }
+
+    @Test(timeout = 1000, expected = TestException.class)
+    public void toSingleDefaultError() {
+        get(error.completable.toSingleDefault(1));
+    }
+    
+    @Test(timeout = 1000)
+    public void toSingleDefaultNormal() {
+        Assert.assertEquals((Integer)1, get(normal.completable.toSingleDefault(1)));
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void toSingleDefaultNull() {
+        normal.completable.toSingleDefault(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void unsubscribeOnNormal() throws InterruptedException {
+        final AtomicReference<String> name = new AtomicReference<String>();
+        final CountDownLatch cdl = new CountDownLatch(1);
+        
+        normal.completable.delay(1, TimeUnit.SECONDS)
+        .doOnUnsubscribe(new Action0() {
+            @Override
+            public void call() {
+                name.set(Thread.currentThread().getName());
+                cdl.countDown();
+            }
+        })
+        .unsubscribeOn(Schedulers.computation())
+        .subscribe(new CompletableSubscriber() {
+            @Override
+            public void onSubscribe(final Subscription d) {
+                final Scheduler.Worker w = Schedulers.io().createWorker();
+                
+                w.schedule(new Action0() {
+                    @Override
+                    public void call() {
+                        try {
+                            d.unsubscribe();
+                        } finally {
+                            w.unsubscribe();
+                        }
+                    }
+                }, 100, TimeUnit.MILLISECONDS);
+            }
+            
+            @Override
+            public void onError(Throwable e) {
+                
+            }
+            
+            @Override
+            public void onCompleted() {
+                
+            }
+        });
+        
+        cdl.await();
+        
+        Assert.assertTrue(name.get().startsWith("RxComputation"));
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void ambArrayNull() {
+        Completable.amb((Completable[])null);
+    }
+
+    @Test(timeout = 1000)
+    public void ambArrayEmpty() {
+        Completable c = Completable.amb();
+                
+        c.await();
+    }
+
+    @Test(timeout = 1000)
+    public void ambArraySingleNormal() {
+        Completable c = Completable.amb(normal.completable);
+                
+        c.await();
+    }
+
+    @Test(timeout = 1000, expected = TestException.class)
+    public void ambArraySingleError() {
+        Completable c = Completable.amb(error.completable);
+                
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void ambArrayOneFires() {
+        PublishSubject<Object> ps1 = PublishSubject.create();
+        PublishSubject<Object> ps2 = PublishSubject.create();
+        
+        Completable c1 = Completable.fromObservable(ps1);
+
+        Completable c2 = Completable.fromObservable(ps2);
+        
+        Completable c = Completable.amb(c1, c2);
+        
+        final AtomicBoolean complete = new AtomicBoolean();
+        
+        c.subscribe(new Action0() {
+            @Override
+            public void call() {
+                complete.set(true);
+            }
+        });
+        
+        Assert.assertTrue("First subject no subscribers", ps1.hasObservers());
+        Assert.assertTrue("Second subject no subscribers", ps2.hasObservers());
+        
+        ps1.onCompleted();
+        
+        Assert.assertFalse("First subject has subscribers", ps1.hasObservers());
+        Assert.assertFalse("Second subject has subscribers", ps2.hasObservers());
+        
+        Assert.assertTrue("Not completed", complete.get());
+    }
+
+    @Test(timeout = 1000)
+    public void ambArrayOneFiresError() {
+        PublishSubject<Object> ps1 = PublishSubject.create();
+        PublishSubject<Object> ps2 = PublishSubject.create();
+        
+        Completable c1 = Completable.fromObservable(ps1);
+
+        Completable c2 = Completable.fromObservable(ps2);
+        
+        Completable c = Completable.amb(c1, c2);
+        
+        final AtomicReference<Throwable> complete = new AtomicReference<Throwable>();
+        
+        c.subscribe(new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) {
+                complete.set(e);
+            }
+        }, new Action0() {
+            @Override
+            public void call() { }
+        });
+        
+        Assert.assertTrue("First subject no subscribers", ps1.hasObservers());
+        Assert.assertTrue("Second subject no subscribers", ps2.hasObservers());
+        
+        ps1.onError(new TestException());
+        
+        Assert.assertFalse("First subject has subscribers", ps1.hasObservers());
+        Assert.assertFalse("Second subject has subscribers", ps2.hasObservers());
+        
+        Assert.assertTrue("Not completed", complete.get() instanceof TestException);
+    }
+    
+    @Test(timeout = 1000)
+    public void ambArraySecondFires() {
+        PublishSubject<Object> ps1 = PublishSubject.create();
+        PublishSubject<Object> ps2 = PublishSubject.create();
+        
+        Completable c1 = Completable.fromObservable(ps1);
+
+        Completable c2 = Completable.fromObservable(ps2);
+        
+        Completable c = Completable.amb(c1, c2);
+        
+        final AtomicBoolean complete = new AtomicBoolean();
+        
+        c.subscribe(new Action0() {
+            @Override
+            public void call() {
+                complete.set(true);
+            }
+        });
+        
+        Assert.assertTrue("First subject no subscribers", ps1.hasObservers());
+        Assert.assertTrue("Second subject no subscribers", ps2.hasObservers());
+        
+        ps2.onCompleted();
+        
+        Assert.assertFalse("First subject has subscribers", ps1.hasObservers());
+        Assert.assertFalse("Second subject has subscribers", ps2.hasObservers());
+        
+        Assert.assertTrue("Not completed", complete.get());
+    }
+
+    @Test(timeout = 1000)
+    public void ambArraySecondFiresError() {
+        PublishSubject<Object> ps1 = PublishSubject.create();
+        PublishSubject<Object> ps2 = PublishSubject.create();
+        
+        Completable c1 = Completable.fromObservable(ps1);
+
+        Completable c2 = Completable.fromObservable(ps2);
+        
+        Completable c = Completable.amb(c1, c2);
+        
+        final AtomicReference<Throwable> complete = new AtomicReference<Throwable>();
+        
+        c.subscribe(new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) {
+                complete.set(e);
+            }
+        }, new Action0() {
+            @Override
+            public void call() { }
+        });
+        
+        Assert.assertTrue("First subject no subscribers", ps1.hasObservers());
+        Assert.assertTrue("Second subject no subscribers", ps2.hasObservers());
+        
+        ps2.onError(new TestException());
+        
+        Assert.assertFalse("First subject has subscribers", ps1.hasObservers());
+        Assert.assertFalse("Second subject has subscribers", ps2.hasObservers());
+        
+        Assert.assertTrue("Not completed", complete.get() instanceof TestException);
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void ambMultipleOneIsNull() {
+        Completable c = Completable.amb(null, normal.completable);
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void ambIterableEmpty() {
+        Completable c = Completable.amb(Collections.<Completable>emptyList());
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void ambIterableNull() {
+        Completable.amb((Iterable<Completable>)null);
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void ambIterableIteratorNull() {
+        Completable c = Completable.amb(new Iterable<Completable>() {
+            @Override
+            public Iterator<Completable> iterator() {
+                return null;
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = NullPointerException.class)
+    public void ambIterableWithNull() {
+        Completable c = Completable.amb(Arrays.asList(null, normal.completable));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000)
+    public void ambIterableSingle() {
+        Completable c = Completable.amb(Collections.singleton(normal.completable));
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000)
+    public void ambIterableMany() {
+        Completable c = Completable.amb(Arrays.asList(normal.completable, normal.completable, normal.completable));
+        
+        c.await();
+        
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void ambIterableOneThrows() {
+        Completable c = Completable.amb(Collections.singleton(error.completable));
+        
+        c.await();
+    }
+    
+    @Test(timeout = 1000, expected = TestException.class)
+    public void ambIterableManyOneThrows() {
+        Completable c = Completable.amb(Arrays.asList(error.completable, normal.completable));
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void ambIterableIterableThrows() {
+        Completable c = Completable.amb(new Iterable<Completable>() {
+            @Override
+            public Iterator<Completable> iterator() {
+                throw new TestException();
+            }
+        });
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void ambIterableIteratorHasNextThrows() {
+        Completable c = Completable.amb(new IterableIteratorHasNextThrows());
+        
+        c.await();
+    }
+    
+    @Test(expected = TestException.class)
+    public void ambIterableIteratorNextThrows() {
+        Completable c = Completable.amb(new IterableIteratorNextThrows());
+        
+        c.await();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void ambWithNull() {
+        normal.completable.ambWith(null);
+    }
+    
+    @Test(timeout = 1000)
+    public void ambWithArrayOneFires() {
+        PublishSubject<Object> ps1 = PublishSubject.create();
+        PublishSubject<Object> ps2 = PublishSubject.create();
+        
+        Completable c1 = Completable.fromObservable(ps1);
+
+        Completable c2 = Completable.fromObservable(ps2);
+        
+        Completable c = c1.ambWith(c2);
+        
+        final AtomicBoolean complete = new AtomicBoolean();
+        
+        c.subscribe(new Action0() {
+            @Override
+            public void call() {
+                complete.set(true);
+            }
+        });
+        
+        Assert.assertTrue("First subject no subscribers", ps1.hasObservers());
+        Assert.assertTrue("Second subject no subscribers", ps2.hasObservers());
+        
+        ps1.onCompleted();
+        
+        Assert.assertFalse("First subject has subscribers", ps1.hasObservers());
+        Assert.assertFalse("Second subject has subscribers", ps2.hasObservers());
+        
+        Assert.assertTrue("Not completed", complete.get());
+    }
+
+    @Test(timeout = 1000)
+    public void ambWithArrayOneFiresError() {
+        PublishSubject<Object> ps1 = PublishSubject.create();
+        PublishSubject<Object> ps2 = PublishSubject.create();
+        
+        Completable c1 = Completable.fromObservable(ps1);
+
+        Completable c2 = Completable.fromObservable(ps2);
+        
+        Completable c = c1.ambWith(c2);
+        
+        final AtomicReference<Throwable> complete = new AtomicReference<Throwable>();
+        
+        c.subscribe(new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) {
+                complete.set(e);
+            }
+        }, new Action0() {
+            @Override
+            public void call() { }
+        });
+        
+        Assert.assertTrue("First subject no subscribers", ps1.hasObservers());
+        Assert.assertTrue("Second subject no subscribers", ps2.hasObservers());
+        
+        ps1.onError(new TestException());
+        
+        Assert.assertFalse("First subject has subscribers", ps1.hasObservers());
+        Assert.assertFalse("Second subject has subscribers", ps2.hasObservers());
+        
+        Assert.assertTrue("Not completed", complete.get() instanceof TestException);
+    }
+    
+    @Test(timeout = 1000)
+    public void ambWithArraySecondFires() {
+        PublishSubject<Object> ps1 = PublishSubject.create();
+        PublishSubject<Object> ps2 = PublishSubject.create();
+        
+        Completable c1 = Completable.fromObservable(ps1);
+
+        Completable c2 = Completable.fromObservable(ps2);
+        
+        Completable c = c1.ambWith(c2);
+        
+        final AtomicBoolean complete = new AtomicBoolean();
+        
+        c.subscribe(new Action0() {
+            @Override
+            public void call() {
+                complete.set(true);
+            }
+        });
+        
+        Assert.assertTrue("First subject no subscribers", ps1.hasObservers());
+        Assert.assertTrue("Second subject no subscribers", ps2.hasObservers());
+        
+        ps2.onCompleted();
+        
+        Assert.assertFalse("First subject has subscribers", ps1.hasObservers());
+        Assert.assertFalse("Second subject has subscribers", ps2.hasObservers());
+        
+        Assert.assertTrue("Not completed", complete.get());
+    }
+
+    @Test(timeout = 1000)
+    public void ambWithArraySecondFiresError() {
+        PublishSubject<Object> ps1 = PublishSubject.create();
+        PublishSubject<Object> ps2 = PublishSubject.create();
+        
+        Completable c1 = Completable.fromObservable(ps1);
+
+        Completable c2 = Completable.fromObservable(ps2);
+        
+        Completable c = c1.ambWith(c2);
+        
+        final AtomicReference<Throwable> complete = new AtomicReference<Throwable>();
+        
+        c.subscribe(new Action1<Throwable>() {
+            @Override
+            public void call(Throwable e) {
+                complete.set(e);
+            }
+        }, new Action0() {
+            @Override
+            public void call() { }
+        });
+        
+        Assert.assertTrue("First subject no subscribers", ps1.hasObservers());
+        Assert.assertTrue("Second subject no subscribers", ps2.hasObservers());
+        
+        ps2.onError(new TestException());
+        
+        Assert.assertFalse("First subject has subscribers", ps1.hasObservers());
+        Assert.assertFalse("Second subject has subscribers", ps2.hasObservers());
+        
+        Assert.assertTrue("Not completed", complete.get() instanceof TestException);
+    }
+    
+    @Test(timeout = 1000)
+    public void startWithCompletableNormal() {
+        final AtomicBoolean run = new AtomicBoolean();
+        Completable c = normal.completable
+                .startWith(Completable.fromCallable(new Callable<Object>() {
+                    @Override
+                    public Object call() throws Exception {
+                        run.set(normal.get() == 0);
+                        return null;
+                    }
+                }));
+        
+        c.await();
+        
+        Assert.assertTrue("Did not start with other", run.get());
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000)
+    public void startWithCompletableError() {
+        Completable c = normal.completable.startWith(error.completable);
+        
+        try {
+            c.await();
+            Assert.fail("Did not throw TestException");
+        } catch (TestException ex) {
+            normal.assertSubscriptions(0);
+            error.assertSubscriptions(1);
+        }
+    }
+    
+    @Test(timeout = 1000)
+    public void startWithFlowableNormal() {
+        final AtomicBoolean run = new AtomicBoolean();
+        Observable<Object> c = normal.completable
+                .startWith(Observable.fromCallable(new Callable<Object>() {
+                    @Override
+                    public Object call() throws Exception {
+                        run.set(normal.get() == 0);
+                        return 1;
+                    }
+                }));
+        
+        TestSubscriber<Object> ts = new TestSubscriber<Object>();
+        
+        c.subscribe(ts);
+        
+        Assert.assertTrue("Did not start with other", run.get());
+        normal.assertSubscriptions(1);
+        
+        ts.assertValue(1);
+        ts.assertCompleted();
+        ts.assertNoErrors();
+    }
+    
+    @Test(timeout = 1000)
+    public void startWithFlowableError() {
+        Observable<Object> c = normal.completable
+                .startWith(Observable.error(new TestException()));
+        
+        TestSubscriber<Object> ts = new TestSubscriber<Object>();
+        
+        c.subscribe(ts);
+        
+        normal.assertSubscriptions(0);
+        
+        ts.assertNoValues();
+        ts.assertError(TestException.class);
+        ts.assertNotCompleted();
+    }
+    
+    @Test(expected = NullPointerException.class)
+    public void startWithCompletableNull() {
+        normal.completable.startWith((Completable)null);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void startWithFlowableNull() {
+        normal.completable.startWith((Observable<Object>)null);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void endWithCompletableNull() {
+        normal.completable.endWith((Completable)null);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void endWithFlowableNull() {
+        normal.completable.endWith((Observable<Object>)null);
+    }
+
+    @Test(timeout = 1000)
+    public void endWithCompletableNormal() {
+        final AtomicBoolean run = new AtomicBoolean();
+        Completable c = normal.completable
+                .endWith(Completable.fromCallable(new Callable<Object>() {
+                    @Override
+                    public Object call() throws Exception {
+                        run.set(normal.get() == 0);
+                        return null;
+                    }
+                }));
+        
+        c.await();
+        
+        Assert.assertFalse("Start with other", run.get());
+        normal.assertSubscriptions(1);
+    }
+    
+    @Test(timeout = 1000)
+    public void endWithCompletableError() {
+        Completable c = normal.completable.endWith(error.completable);
+        
+        try {
+            c.await();
+            Assert.fail("Did not throw TestException");
+        } catch (TestException ex) {
+            normal.assertSubscriptions(1);
+            error.assertSubscriptions(1);
+        }
+    }
+    
+    @Test(timeout = 1000)
+    public void endWithFlowableNormal() {
+        final AtomicBoolean run = new AtomicBoolean();
+        Observable<Object> c = normal.completable
+                .endWith(Observable.fromCallable(new Callable<Object>() {
+                    @Override
+                    public Object call() throws Exception {
+                        run.set(normal.get() == 0);
+                        return 1;
+                    }
+                }));
+        
+        TestSubscriber<Object> ts = new TestSubscriber<Object>();
+        
+        c.subscribe(ts);
+        
+        Assert.assertFalse("Start with other", run.get());
+        normal.assertSubscriptions(1);
+        
+        ts.assertValue(1);
+        ts.assertCompleted();
+        ts.assertNoErrors();
+    }
+    
+    @Test(timeout = 1000)
+    public void endWithFlowableError() {
+        Observable<Object> c = normal.completable
+                .endWith(Observable.error(new TestException()));
+        
+        TestSubscriber<Object> ts = new TestSubscriber<Object>();
+        
+        c.subscribe(ts);
+        
+        normal.assertSubscriptions(1);
+        
+        ts.assertNoValues();
+        ts.assertError(TestException.class);
+        ts.assertNotCompleted();
+    }
+    
+    @Test
+    public void usingFactoryThrows() {
+        @SuppressWarnings("unchecked")
+        Action1<Integer> onDispose = mock(Action1.class);
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Completable.using(new Func0<Integer>() {
+            @Override
+            public Integer call() {
+                return 1;
+            }
+        },
+        new Func1<Integer, Completable>() {
+            @Override
+            public Completable call(Integer t) {
+                throw new TestException();
+            }
+        }, onDispose).subscribe(ts);
+        
+        verify(onDispose).call(1);
+        
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+        ts.assertError(TestException.class);
+    }
+
+    @Test
+    public void usingFactoryAndDisposerThrow() {
+        Action1<Integer> onDispose = new Action1<Integer>() {
+            @Override
+            public void call(Integer t) {
+                throw new TestException();
+            }
+        };
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Completable.using(new Func0<Integer>() {
+            @Override
+            public Integer call() {
+                return 1;
+            }
+        },
+        new Func1<Integer, Completable>() {
+            @Override
+            public Completable call(Integer t) {
+                throw new TestException();
+            }
+        }, onDispose).subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+        ts.assertError(CompositeException.class);
+        
+        CompositeException ex = (CompositeException)ts.getOnErrorEvents().get(0);
+        
+        List<Throwable> listEx = ex.getExceptions();
+        
+        assertEquals(2, listEx.size());
+        
+        assertTrue(listEx.get(0).toString(), listEx.get(0) instanceof TestException);
+        assertTrue(listEx.get(1).toString(), listEx.get(1) instanceof TestException);
+    }
+
+    @Test
+    public void usingFactoryReturnsNull() {
+        @SuppressWarnings("unchecked")
+        Action1<Integer> onDispose = mock(Action1.class);
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Completable.using(new Func0<Integer>() {
+            @Override
+            public Integer call() {
+                return 1;
+            }
+        },
+        new Func1<Integer, Completable>() {
+            @Override
+            public Completable call(Integer t) {
+                return null;
+            }
+        }, onDispose).subscribe(ts);
+        
+        verify(onDispose).call(1);
+        
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+        ts.assertError(NullPointerException.class);
+    }
+
+    @Test
+    public void usingFactoryReturnsNullAndDisposerThrows() {
+        Action1<Integer> onDispose = new Action1<Integer>() {
+            @Override
+            public void call(Integer t) {
+                throw new TestException();
+            }
+        };
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        Completable.using(new Func0<Integer>() {
+            @Override
+            public Integer call() {
+                return 1;
+            }
+        },
+        new Func1<Integer, Completable>() {
+            @Override
+            public Completable call(Integer t) {
+                return null;
+            }
+        }, onDispose).subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+        ts.assertError(CompositeException.class);
+        
+        CompositeException ex = (CompositeException)ts.getOnErrorEvents().get(0);
+        
+        List<Throwable> listEx = ex.getExceptions();
+        
+        assertEquals(2, listEx.size());
+        
+        assertTrue(listEx.get(0).toString(), listEx.get(0) instanceof NullPointerException);
+        assertTrue(listEx.get(1).toString(), listEx.get(1) instanceof TestException);
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/rx/ObservableTests.java b/src/test/java/rx/ObservableTests.java
index d59e8c41a9..2d6598132b 100644
--- a/src/test/java/rx/ObservableTests.java
+++ b/src/test/java/rx/ObservableTests.java
@@ -663,7 +663,7 @@ public void run() {
                     }
                 }).start();
             }
-        }).cache(1);
+        }).cacheWithInitialCapacity(1);
 
         // we then expect the following 2 subscriptions to get that same value
         final CountDownLatch latch = new CountDownLatch(2);
diff --git a/src/test/java/rx/SchedulerWorkerTest.java b/src/test/java/rx/SchedulerWorkerTest.java
new file mode 100644
index 0000000000..8bb1094b46
--- /dev/null
+++ b/src/test/java/rx/SchedulerWorkerTest.java
@@ -0,0 +1,153 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx;
+
+import static org.junit.Assert.assertTrue;
+
+import java.util.*;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Test;
+
+import rx.functions.Action0;
+import rx.schedulers.Schedulers;
+
+public class SchedulerWorkerTest {
+    
+    static final class CustomDriftScheduler extends Scheduler {
+        public volatile long drift;
+        @Override
+        public Worker createWorker() {
+            final Worker w = Schedulers.computation().createWorker();
+            return new Worker() {
+
+                @Override
+                public void unsubscribe() {
+                    w.unsubscribe();
+                }
+
+                @Override
+                public boolean isUnsubscribed() {
+                    return w.isUnsubscribed();
+                }
+
+                @Override
+                public Subscription schedule(Action0 action) {
+                    return w.schedule(action);
+                }
+
+                @Override
+                public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
+                    return w.schedule(action, delayTime, unit);
+                }
+                
+                @Override
+                public long now() {
+                    return super.now() + drift;
+                }
+            };
+        }
+        
+        @Override
+        public long now() {
+            return super.now() + drift;
+        }
+    }
+    
+    @Test
+    public void testCurrentTimeDriftBackwards() throws Exception {
+        CustomDriftScheduler s = new CustomDriftScheduler();
+        
+        Scheduler.Worker w = s.createWorker();
+        
+        try {
+            final List<Long> times = new ArrayList<Long>();
+            
+            Subscription d = w.schedulePeriodically(new Action0() {
+                @Override
+                public void call() {
+                    times.add(System.currentTimeMillis());
+                }
+            }, 100, 100, TimeUnit.MILLISECONDS);
+
+            Thread.sleep(150);
+            
+            s.drift = -1000 - TimeUnit.NANOSECONDS.toMillis(Scheduler.CLOCK_DRIFT_TOLERANCE_NANOS);
+            
+            Thread.sleep(400);
+            
+            d.unsubscribe();
+            
+            Thread.sleep(150);
+            
+            System.out.println("Runs: " + times.size());
+            
+            for (int i = 0; i < times.size() - 1 ; i++) {
+                long diff = times.get(i + 1) - times.get(i);
+                System.out.println("Diff #" + i + ": " + diff);
+                assertTrue("" + i + ":" + diff, diff < 150 && diff > 50);
+            }
+
+            assertTrue("Too few invocations: " + times.size(), times.size() > 2);
+            
+        } finally {
+            w.unsubscribe();
+        }
+        
+    }
+    
+    @Test
+    public void testCurrentTimeDriftForwards() throws Exception {
+        CustomDriftScheduler s = new CustomDriftScheduler();
+        
+        Scheduler.Worker w = s.createWorker();
+        
+        try {
+            final List<Long> times = new ArrayList<Long>();
+            
+            Subscription d = w.schedulePeriodically(new Action0() {
+                @Override
+                public void call() {
+                    times.add(System.currentTimeMillis());
+                }
+            }, 100, 100, TimeUnit.MILLISECONDS);
+
+            Thread.sleep(150);
+            
+            s.drift = 1000 + TimeUnit.NANOSECONDS.toMillis(Scheduler.CLOCK_DRIFT_TOLERANCE_NANOS);
+            
+            Thread.sleep(400);
+            
+            d.unsubscribe();
+            
+            Thread.sleep(150);
+            
+            System.out.println("Runs: " + times.size());
+            
+            assertTrue(times.size() > 2);
+            
+            for (int i = 0; i < times.size() - 1 ; i++) {
+                long diff = times.get(i + 1) - times.get(i);
+                System.out.println("Diff #" + i + ": " + diff);
+                assertTrue("Diff out of range: " + diff, diff < 250 && diff > 50);
+            }
+            
+        } finally {
+            w.unsubscribe();
+        }
+        
+    }
+}
diff --git a/src/test/java/rx/SingleTest.java b/src/test/java/rx/SingleTest.java
index bba4d09bc7..2871450708 100644
--- a/src/test/java/rx/SingleTest.java
+++ b/src/test/java/rx/SingleTest.java
@@ -13,38 +13,50 @@
 package rx;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Matchers.eq;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyZeroInteractions;
 import static org.mockito.Mockito.when;
 
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Test;
 
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 import rx.Single.OnSubscribe;
 import rx.exceptions.CompositeException;
+import rx.functions.Action;
 import rx.functions.Action0;
 import rx.functions.Action1;
 import rx.functions.Func1;
 import rx.functions.Func2;
+import rx.functions.FuncN;
 import rx.schedulers.TestScheduler;
+import rx.singles.BlockingSingle;
 import rx.observers.TestSubscriber;
 import rx.schedulers.Schedulers;
 import rx.subscriptions.Subscriptions;
 
-
 public class SingleTest {
 
     @Test
@@ -107,6 +119,57 @@ public String call(String a, String b) {
         ts.assertReceivedOnNext(Arrays.asList("AB"));
     }
 
+    @Test
+    public void zipIterableShouldZipListOfSingles() {
+        TestSubscriber<String> ts = new TestSubscriber<String>();
+        Iterable<Single<Integer>> singles = Arrays.asList(Single.just(1), Single.just(2), Single.just(3));
+
+        Single
+                .zip(singles, new FuncN<String>() {
+                    @Override
+                    public String call(Object... args) {
+                        StringBuilder stringBuilder = new StringBuilder();
+                        for (Object arg : args) {
+                            stringBuilder.append(arg);
+                        }
+                        return stringBuilder.toString();
+                    }
+                }).subscribe(ts);
+
+        ts.assertValue("123");
+        ts.assertNoErrors();
+        ts.assertCompleted();
+    }
+
+    @Test
+    public void zipIterableShouldZipSetOfSingles() {
+        TestSubscriber<String> ts = new TestSubscriber<String>();
+        Set<Single<String>> singlesSet = Collections.newSetFromMap(new LinkedHashMap<Single<String>, Boolean>(2));
+        Single<String> s1 = Single.just("1");
+        Single<String> s2 = Single.just("2");
+        Single<String> s3 = Single.just("3");
+
+        singlesSet.add(s1);
+        singlesSet.add(s2);
+        singlesSet.add(s3);
+
+        Single
+                .zip(singlesSet, new FuncN<String>() {
+                    @Override
+                    public String call(Object... args) {
+                        StringBuilder stringBuilder = new StringBuilder();
+                        for (Object arg : args) {
+                            stringBuilder.append(arg);
+                        }
+                        return stringBuilder.toString();
+                    }
+                }).subscribe(ts);
+
+        ts.assertValue("123");
+        ts.assertNoErrors();
+        ts.assertCompleted();
+    }
+
     @Test
     public void testZipWith() {
         TestSubscriber<String> ts = new TestSubscriber<String>();
@@ -260,6 +323,14 @@ public void call(SingleSubscriber<? super String> s) {
         ts.assertValue("hello");
     }
 
+    @Test
+    public void testToBlocking() {
+        Single<String> s = Single.just("one");
+        BlockingSingle<String> blocking = s.toBlocking();
+        assertNotNull(blocking);
+        assertEquals("one", blocking.value());
+    }
+
     @Test
     public void testUnsubscribe() throws InterruptedException {
         TestSubscriber<String> ts = new TestSubscriber<String>();
@@ -689,4 +760,273 @@ public void call(SingleSubscriber<? super Integer> singleSubscriber) {
         subscriber.assertNoValues();
         subscriber.assertError(expected);
     }
+
+    @Test
+    public void deferShouldNotCallFactoryFuncUntilSubscriberSubscribes() throws Exception {
+        Callable<Single<Object>> singleFactory = mock(Callable.class);
+        Single.defer(singleFactory);
+        verifyZeroInteractions(singleFactory);
+    }
+
+    @Test
+    public void deferShouldSubscribeSubscriberToSingleFromFactoryFuncAndEmitValue() throws Exception {
+        Callable<Single<Object>> singleFactory = mock(Callable.class);
+        Object value = new Object();
+        Single<Object> single = Single.just(value);
+
+        when(singleFactory.call()).thenReturn(single);
+
+        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
+
+        Single
+                .defer(singleFactory)
+                .subscribe(testSubscriber);
+
+        testSubscriber.assertValue(value);
+        testSubscriber.assertNoErrors();
+
+        verify(singleFactory).call();
+    }
+
+    @Test
+    public void deferShouldSubscribeSubscriberToSingleFromFactoryFuncAndEmitError() throws Exception {
+        Callable<Single<Object>> singleFactory = mock(Callable.class);
+        Throwable error = new IllegalStateException();
+        Single<Object> single = Single.error(error);
+
+        when(singleFactory.call()).thenReturn(single);
+
+        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
+
+        Single
+                .defer(singleFactory)
+                .subscribe(testSubscriber);
+
+        testSubscriber.assertNoValues();
+        testSubscriber.assertError(error);
+
+        verify(singleFactory).call();
+    }
+
+    @Test
+    public void deferShouldPassErrorFromSingleFactoryToTheSubscriber() throws Exception {
+        Callable<Single<Object>> singleFactory = mock(Callable.class);
+        Throwable errorFromSingleFactory = new IllegalStateException();
+        when(singleFactory.call()).thenThrow(errorFromSingleFactory);
+
+        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
+
+        Single
+                .defer(singleFactory)
+                .subscribe(testSubscriber);
+
+        testSubscriber.assertNoValues();
+        testSubscriber.assertError(errorFromSingleFactory);
+
+        verify(singleFactory).call();
+    }
+
+    @Test
+    public void deferShouldCallSingleFactoryForEachSubscriber() throws Exception {
+        Callable<Single<String>> singleFactory = mock(Callable.class);
+
+        String[] values = {"1", "2", "3"};
+        final Single[] singles = new Single[]{Single.just(values[0]), Single.just(values[1]), Single.just(values[2])};
+
+        final AtomicInteger singleFactoryCallsCounter = new AtomicInteger();
+
+        when(singleFactory.call()).thenAnswer(new Answer<Single<String>>() {
+            @Override
+            public Single<String> answer(InvocationOnMock invocation) throws Throwable {
+                return singles[singleFactoryCallsCounter.getAndIncrement()];
+            }
+        });
+
+        Single<String> deferredSingle = Single.defer(singleFactory);
+
+        for (int i = 0; i < singles.length; i ++) {
+            TestSubscriber<String> testSubscriber = new TestSubscriber<String>();
+
+            deferredSingle.subscribe(testSubscriber);
+
+            testSubscriber.assertValue(values[i]);
+            testSubscriber.assertNoErrors();
+        }
+
+        verify(singleFactory, times(3)).call();
+    }
+
+    @Test
+    public void deferShouldPassNullPointerExceptionToTheSubscriberIfSingleFactoryIsNull() {
+        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
+
+        Single
+                .defer(null)
+                .subscribe(testSubscriber);
+
+        testSubscriber.assertNoValues();
+        testSubscriber.assertError(NullPointerException.class);
+    }
+
+
+    @Test
+    public void deferShouldPassNullPointerExceptionToTheSubscriberIfSingleFactoryReturnsNull() throws Exception {
+        Callable<Single<Object>> singleFactory = mock(Callable.class);
+        when(singleFactory.call()).thenReturn(null);
+
+        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
+
+        Single
+                .defer(singleFactory)
+                .subscribe(testSubscriber);
+
+        testSubscriber.assertNoValues();
+        testSubscriber.assertError(NullPointerException.class);
+
+        verify(singleFactory).call();
+    }
+
+    @Test
+    public void doOnUnsubscribeShouldInvokeActionAfterSuccess() {
+        Action0 action = mock(Action0.class);
+
+        Single<String> single = Single
+            .just("test")
+            .doOnUnsubscribe(action);
+
+        verifyZeroInteractions(action);
+
+        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();
+        single.subscribe(testSubscriber);
+
+        testSubscriber.assertValue("test");
+        testSubscriber.assertCompleted();
+
+        verify(action).call();
+    }
+
+    @Test
+    public void doOnUnsubscribeShouldInvokeActionAfterError() {
+        Action0 action = mock(Action0.class);
+
+        Single<Object> single = Single
+            .error(new RuntimeException("test"))
+            .doOnUnsubscribe(action);
+
+        verifyZeroInteractions(action);
+
+        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
+        single.subscribe(testSubscriber);
+
+        testSubscriber.assertError(RuntimeException.class);
+        assertEquals("test", testSubscriber.getOnErrorEvents().get(0).getMessage());
+
+        verify(action).call();
+    }
+
+    @Test
+    public void doOnUnsubscribeShouldInvokeActionAfterExplicitUnsubscription() {
+        Action0 action = mock(Action0.class);
+
+        Single<Object> single = Single
+            .create(new OnSubscribe<Object>() {
+                @Override
+                public void call(SingleSubscriber<? super Object> singleSubscriber) {
+                    // Broken Single that never ends itself (simulates long computation in one thread).
+                }
+            })
+            .doOnUnsubscribe(action);
+
+        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
+        Subscription subscription = single.subscribe(testSubscriber);
+
+        verifyZeroInteractions(action);
+
+        subscription.unsubscribe();
+        verify(action).call();
+        testSubscriber.assertNoValues();
+        testSubscriber.assertNoTerminalEvent();
+    }
+
+    @Test
+    public void doAfterTerminateActionShouldBeInvokedAfterOnSuccess() {
+        Action0 action = mock(Action0.class);
+
+        TestSubscriber<String> testSubscriber = new TestSubscriber<String>();
+
+        Single
+                .just("value")
+                .doAfterTerminate(action)
+                .subscribe(testSubscriber);
+
+        testSubscriber.assertValue("value");
+        testSubscriber.assertNoErrors();
+
+        verify(action).call();
+    }
+
+    @Test
+    public void doAfterTerminateActionShouldBeInvokedAfterOnError() {
+        Action0 action = mock(Action0.class);
+
+        TestSubscriber<Object> testSubscriber = new TestSubscriber<Object>();
+
+        Throwable error = new IllegalStateException();
+
+        Single
+                .error(error)
+                .doAfterTerminate(action)
+                .subscribe(testSubscriber);
+
+        testSubscriber.assertNoValues();
+        testSubscriber.assertError(error);
+
+        verify(action).call();
+    }
+
+    @Test
+    public void doAfterTerminateActionShouldNotBeInvokedUntilSubscriberSubscribes() {
+        Action0 action = mock(Action0.class);
+
+        Single
+                .just("value")
+                .doAfterTerminate(action);
+
+        Single
+                .error(new IllegalStateException())
+                .doAfterTerminate(action);
+
+        verifyZeroInteractions(action);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void iterableToArrayShouldThrowNullPointerExceptionIfIterableNull() {
+        Single.iterableToArray(null);
+    }
+
+    @Test
+    public void iterableToArrayShouldConvertList() {
+        List<Single<String>> singlesList = Arrays.asList(Single.just("1"), Single.just("2"));
+
+        Single<? extends String>[] singlesArray = Single.iterableToArray(singlesList);
+        assertEquals(2, singlesArray.length);
+        assertSame(singlesList.get(0), singlesArray[0]);
+        assertSame(singlesList.get(1), singlesArray[1]);
+    }
+
+    @Test
+    public void iterableToArrayShouldConvertSet() {
+        // Just to trigger different path of the code that handles non-list iterables.
+        Set<Single<String>> singlesSet = Collections.newSetFromMap(new LinkedHashMap<Single<String>, Boolean>(2));
+        Single<String> s1 = Single.just("1");
+        Single<String> s2 = Single.just("2");
+
+        singlesSet.add(s1);
+        singlesSet.add(s2);
+
+        Single<? extends String>[] singlesArray = Single.iterableToArray(singlesSet);
+        assertEquals(2, singlesArray.length);
+        assertSame(s1, singlesArray[0]);
+        assertSame(s2, singlesArray[1]);
+    }
 }
diff --git a/src/test/java/rx/internal/operators/BufferUntilSubscriberTest.java b/src/test/java/rx/internal/operators/BufferUntilSubscriberTest.java
index 50be759581..801138d4ab 100644
--- a/src/test/java/rx/internal/operators/BufferUntilSubscriberTest.java
+++ b/src/test/java/rx/internal/operators/BufferUntilSubscriberTest.java
@@ -15,20 +15,19 @@
  */
 package rx.internal.operators;
 
-import org.junit.Assert;
-import org.junit.Test;
+import java.util.List;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+
+import org.junit.*;
+
 import rx.Observable;
-import rx.functions.Action1;
-import rx.functions.Func1;
+import rx.exceptions.TestException;
+import rx.functions.*;
+import rx.observers.TestSubscriber;
 import rx.schedulers.Schedulers;
 import rx.subjects.PublishSubject;
 
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicLong;
-
 public class BufferUntilSubscriberTest {
 
     @Test
@@ -82,4 +81,98 @@ public void call(List<Integer> integers) {
         else
             Assert.assertEquals(NITERS, counter.get());
     }
-}
+    
+    @Test
+    public void testBackpressure() {
+        UnicastSubject<Integer> bus = UnicastSubject.create();
+        for (int i = 0; i < 32; i++) {
+            bus.onNext(i);
+        }
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        
+        bus.subscribe(ts);
+        
+        ts.assertValueCount(0);
+        ts.assertNoTerminalEvent();
+        
+        ts.requestMore(10);
+        
+        ts.assertValueCount(10);
+        
+        ts.requestMore(22);
+        ts.assertValueCount(32);
+
+        Assert.assertFalse(bus.state.caughtUp);
+
+        ts.requestMore(Long.MAX_VALUE);
+        
+        Assert.assertTrue(bus.state.caughtUp);
+
+        for (int i = 32; i < 64; i++) {
+            bus.onNext(i);
+        }
+        bus.onCompleted();
+        
+        ts.assertValueCount(64);
+        ts.assertNoErrors();
+        ts.assertCompleted();
+    }
+    @Test
+    public void testErrorCutsAhead() {
+        UnicastSubject<Integer> bus = UnicastSubject.create();
+        for (int i = 0; i < 32; i++) {
+            bus.onNext(i);
+        }
+        bus.onError(new TestException());
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        
+        bus.subscribe(ts);
+        
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+        ts.assertError(TestException.class);
+    }
+    @Test
+    public void testErrorCutsAheadAfterSubscribed() {
+        UnicastSubject<Integer> bus = UnicastSubject.create();
+        for (int i = 0; i < 32; i++) {
+            bus.onNext(i);
+        }
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        
+        bus.subscribe(ts);
+
+        ts.assertNoValues();
+        ts.assertNoTerminalEvent();
+
+        bus.onError(new TestException());
+        
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+        ts.assertError(TestException.class);
+    }
+    @Test
+    public void testUnsubscribeClearsQueue() {
+        UnicastSubject<Integer> bus = UnicastSubject.create();
+        for (int i = 0; i < 32; i++) {
+            bus.onNext(i);
+        }
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        ts.unsubscribe();
+        
+        bus.subscribe(ts);
+        
+        ts.assertNoTerminalEvent();
+        ts.assertNoValues();
+        
+        Assert.assertTrue(bus.state.queue.isEmpty());
+        
+        bus.onNext(32);
+        
+        Assert.assertTrue(bus.state.queue.isEmpty());
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/rx/internal/operators/OnBackpressureBlockTest.java b/src/test/java/rx/internal/operators/OnBackpressureBlockTest.java
deleted file mode 100644
index 47d3cebd71..0000000000
--- a/src/test/java/rx/internal/operators/OnBackpressureBlockTest.java
+++ /dev/null
@@ -1,347 +0,0 @@
-/**
- * Copyright 2014 Netflix, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package rx.internal.operators;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.*;
-
-import java.util.Arrays;
-import java.util.Collections;
-
-import org.junit.Test;
-
-import rx.Observable;
-import rx.Observable.OnSubscribe;
-import rx.Observer;
-import rx.Subscriber;
-import rx.exceptions.MissingBackpressureException;
-import rx.exceptions.TestException;
-import rx.internal.util.RxRingBuffer;
-import rx.observers.TestObserver;
-import rx.observers.TestSubscriber;
-import rx.schedulers.Schedulers;
-import rx.subjects.PublishSubject;
-
-/**
- * Test the onBackpressureBlock() behavior.
- */
-public class OnBackpressureBlockTest {
-    static final int WAIT = 200;
-    
-    @Test(timeout = 1000)
-    public void testSimpleBelowCapacity() {
-        Observable<Integer> source = Observable.just(1).onBackpressureBlock(10);
-        
-        TestObserver<Integer> o = new TestObserver<Integer>();
-        source.subscribe(o);
-        
-        o.assertReceivedOnNext(Arrays.asList(1));
-        o.assertTerminalEvent();
-        assertTrue(o.getOnErrorEvents().isEmpty());
-    }
-    @Test(timeout = 10000)
-    public void testSimpleAboveCapacity() throws InterruptedException {
-        Observable<Integer> source = Observable.range(1, 11).subscribeOn(Schedulers.newThread())
-                .onBackpressureBlock(10);
-        
-        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {
-            @Override
-            public void onStart() {
-                request(0); // make sure it doesn't start in unlimited mode
-            }
-        };
-        source.subscribe(o);
-        o.requestMore(10);
-
-        Thread.sleep(WAIT);
-        
-        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
-        
-        o.requestMore(10);
-        
-        Thread.sleep(WAIT);
-
-        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11));
-
-        o.assertTerminalEvent();
-        assertTrue(o.getOnErrorEvents().isEmpty());
-    }
-    
-    @Test(timeout = 3000)
-    public void testNoMissingBackpressureException() {
-        final int NUM_VALUES = RxRingBuffer.SIZE * 3;
-        Observable<Integer> source = Observable.create(new OnSubscribe<Integer>() {
-            @Override
-            public void call(Subscriber<? super Integer> t1) {
-                for (int i = 0; i < NUM_VALUES; i++) {
-                    t1.onNext(i);
-                }
-                t1.onCompleted();
-            }
-        }).subscribeOn(Schedulers.newThread());
-        
-        @SuppressWarnings("unchecked")
-        Observer<Integer> o = mock(Observer.class);
-
-        TestSubscriber<Integer> s = new TestSubscriber<Integer>(o);
-        
-        source.onBackpressureBlock(RxRingBuffer.SIZE).observeOn(Schedulers.newThread()).subscribe(s);
-        
-        s.awaitTerminalEvent();
-        
-        verify(o, never()).onError(any(MissingBackpressureException.class));
-        
-        s.assertNoErrors();
-        verify(o, times(NUM_VALUES)).onNext(any(Integer.class));
-        verify(o).onCompleted();
-    }
-    @Test(timeout = 10000)
-    public void testBlockedProducerCanBeUnsubscribed() throws InterruptedException {
-        Observable<Integer> source = Observable.range(1, 11).subscribeOn(Schedulers.newThread())
-                .onBackpressureBlock(5);
-        
-        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {
-            @Override
-            public void onStart() {
-                request(0); // make sure it doesn't start in unlimited mode
-            }
-        };
-        source.subscribe(o);
-        
-        o.requestMore(5);
-        
-        Thread.sleep(WAIT);
-        
-        o.unsubscribe();
-
-        Thread.sleep(WAIT);
-
-        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5));
-        o.assertNoErrors();
-        assertTrue(o.getOnCompletedEvents().isEmpty());
-    }
-    @Test(timeout = 10000)
-    public void testExceptionIsDelivered() throws InterruptedException {
-        Observable<Integer> source = Observable.range(1, 10)
-                .concatWith(Observable.<Integer>error(new TestException("Forced failure")))
-                .subscribeOn(Schedulers.newThread())
-                .onBackpressureBlock(5);
-        
-        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {
-            @Override
-            public void onStart() {
-                request(0); // make sure it doesn't start in unlimited mode
-            }
-        };
-        source.subscribe(o);
-
-        o.requestMore(7);
-
-        Thread.sleep(WAIT);
-        
-        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7));
-        o.assertNoErrors();
-        assertTrue(o.getOnCompletedEvents().isEmpty());
-
-        o.requestMore(3);
-        
-        Thread.sleep(WAIT);
-
-        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
-        o.assertTerminalEvent();
-        assertEquals(1, o.getOnErrorEvents().size());
-        assertTrue(o.getOnErrorEvents().get(0) instanceof TestException);
-
-        o.requestMore(10);
-        
-        Thread.sleep(WAIT);
-        
-        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
-        o.assertTerminalEvent();
-        assertEquals(1, o.getOnErrorEvents().size());
-        assertTrue(o.getOnErrorEvents().get(0) instanceof TestException);
-    }
-    @Test(timeout = 10000)
-    public void testExceptionIsDeliveredAfterValues() throws InterruptedException {
-        Observable<Integer> source = Observable.range(1, 10)
-                .concatWith(Observable.<Integer>error(new TestException("Forced failure")))
-                .subscribeOn(Schedulers.newThread())
-                .onBackpressureBlock(5);
-        
-        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {
-            @Override
-            public void onStart() {
-                request(0); // make sure it doesn't start in unlimited mode
-            }
-        };
-        source.subscribe(o);
-
-        o.requestMore(7);
-
-        Thread.sleep(WAIT);
-        
-        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7));
-        o.assertNoErrors();
-        assertTrue(o.getOnCompletedEvents().isEmpty());
-
-        o.requestMore(7);
-        
-        Thread.sleep(WAIT);
-
-        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
-        assertEquals(1, o.getOnErrorEvents().size());
-        assertTrue(o.getOnErrorEvents().get(0) instanceof TestException);
-        assertTrue(o.getOnCompletedEvents().isEmpty());
-    }
-    @Test(timeout = 10000)
-    public void testTakeWorksWithSubscriberRequesting() {
-        Observable<Integer> source = Observable.range(1, 10)
-                .concatWith(Observable.<Integer>error(new TestException("Forced failure")))
-                .subscribeOn(Schedulers.newThread())
-                .onBackpressureBlock(5).take(7);
-        
-        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {
-            @Override
-            public void onStart() {
-                request(0); // make sure it doesn't start in unlimited mode
-            }
-        };
-        source.subscribe(o);
-
-        o.requestMore(7);
-
-        o.awaitTerminalEvent();
-        
-        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7));
-        o.assertNoErrors();
-        o.assertTerminalEvent();
-    }
-    @Test(timeout = 10000)
-    public void testTakeWorksSubscriberRequestUnlimited() {
-        Observable<Integer> source = Observable.range(1, 10)
-                .concatWith(Observable.<Integer>error(new TestException("Forced failure")))
-                .subscribeOn(Schedulers.newThread())
-                .onBackpressureBlock(5).take(7);
-        
-        TestSubscriber<Integer> o = new TestSubscriber<Integer>();
-        source.subscribe(o);
-
-        o.awaitTerminalEvent();
-        
-        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7));
-        o.assertNoErrors();
-        o.assertTerminalEvent();
-    }
-    @Test(timeout = 10000)
-    public void testTakeWorksSubscriberRequestUnlimitedBufferedException() {
-        Observable<Integer> source = Observable.range(1, 10)
-                .concatWith(Observable.<Integer>error(new TestException("Forced failure")))
-                .subscribeOn(Schedulers.newThread())
-                .onBackpressureBlock(11).take(7);
-        
-        TestSubscriber<Integer> o = new TestSubscriber<Integer>();
-        source.subscribe(o);
-
-        o.awaitTerminalEvent();
-        
-        o.assertReceivedOnNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7));
-        o.assertNoErrors();
-        o.assertTerminalEvent();
-    }
-    @Test(timeout = 10000)
-    public void testOnCompletedDoesntWaitIfNoEvents() {
-        
-        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {
-            @Override
-            public void onStart() {
-                request(0); // make sure it doesn't start in unlimited mode
-            }
-        };
-        Observable.<Integer>empty().onBackpressureBlock(2).subscribe(o);
-        
-        o.assertNoErrors();
-        o.assertTerminalEvent();
-        o.assertReceivedOnNext(Collections.<Integer>emptyList());
-    }
-    @Test(timeout = 10000)
-    public void testOnCompletedDoesWaitIfEvents() {
-        
-        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {
-            @Override
-            public void onStart() {
-                request(0); // make sure it doesn't start in unlimited mode
-            }
-        };
-        Observable.just(1).onBackpressureBlock(2).subscribe(o);
-        
-        o.assertReceivedOnNext(Collections.<Integer>emptyList());
-        assertTrue(o.getOnErrorEvents().isEmpty());
-        assertTrue(o.getOnCompletedEvents().isEmpty());
-    }
-    @Test(timeout = 10000)
-    public void testOnCompletedDoesntWaitIfNoEvents2() {
-        final PublishSubject<Integer> ps = PublishSubject.create();
-        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {
-            @Override
-            public void onStart() {
-                request(0); // make sure it doesn't start in unlimited mode
-            }
-            @Override
-            public void onNext(Integer t) {
-                super.onNext(t);
-                ps.onCompleted(); // as if an async completion arrived while in the loop
-            }
-        };
-        ps.onBackpressureBlock(2).unsafeSubscribe(o);
-        ps.onNext(1);
-        o.requestMore(1);
-        
-        o.assertNoErrors();
-        o.assertTerminalEvent();
-        o.assertReceivedOnNext(Arrays.asList(1));
-    }
-    @Test(timeout = 10000)
-    public void testOnCompletedDoesntWaitIfNoEvents3() {
-        final PublishSubject<Integer> ps = PublishSubject.create();
-        TestSubscriber<Integer> o = new TestSubscriber<Integer>() {
-            boolean once = true;
-            @Override
-            public void onStart() {
-                request(0); // make sure it doesn't start in unlimited mode
-            }
-            @Override
-            public void onNext(Integer t) {
-                super.onNext(t);
-                if (once) {
-                    once = false;
-                    ps.onNext(2);
-                    ps.onCompleted(); // as if an async completion arrived while in the loop
-                    requestMore(1);
-                }
-            }
-        };
-        ps.onBackpressureBlock(3).unsafeSubscribe(o);
-        ps.onNext(1);
-        o.requestMore(1);
-        
-        o.assertNoErrors();
-        o.assertTerminalEvent();
-        o.assertReceivedOnNext(Arrays.asList(1, 2));
-    }
-}
diff --git a/src/test/java/rx/internal/operators/OnSubscribeCompletableTest.java b/src/test/java/rx/internal/operators/OnSubscribeCompletableTest.java
new file mode 100644
index 0000000000..e30bb78062
--- /dev/null
+++ b/src/test/java/rx/internal/operators/OnSubscribeCompletableTest.java
@@ -0,0 +1,98 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx.internal.operators;
+
+import static org.junit.Assert.assertFalse;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.junit.Test;
+
+import rx.Completable;
+import rx.Observable;
+import rx.functions.Action0;
+import rx.observers.TestSubscriber;
+
+public class OnSubscribeCompletableTest {
+
+    @Test
+    public void testJustSingleItemObservable() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        Completable cmp = Observable.just("Hello World!").toCompletable();
+        cmp.subscribe(subscriber);
+
+        subscriber.assertNoValues();
+        subscriber.assertCompleted();
+        subscriber.assertNoErrors();
+    }
+
+    @Test
+    public void testErrorObservable() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        IllegalArgumentException error = new IllegalArgumentException("Error");
+        Completable cmp = Observable.<String>error(error).toCompletable();
+        cmp.subscribe(subscriber);
+
+        subscriber.assertError(error);
+        subscriber.assertNoValues();
+    }
+
+    @Test
+    public void testJustTwoEmissionsObservableThrowsError() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        Completable cmp = Observable.just("First", "Second").toCompletable();
+        cmp.subscribe(subscriber);
+
+        subscriber.assertNoErrors();
+        subscriber.assertNoValues();
+    }
+
+    @Test
+    public void testEmptyObservable() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        Completable cmp = Observable.<String>empty().toCompletable();
+        cmp.subscribe(subscriber);
+
+        subscriber.assertNoErrors();
+        subscriber.assertNoValues();
+        subscriber.assertCompleted();
+    }
+
+    @Test
+    public void testNeverObservable() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        Completable cmp = Observable.<String>never().toCompletable();
+        cmp.subscribe(subscriber);
+
+        subscriber.assertNoTerminalEvent();
+        subscriber.assertNoValues();
+    }
+
+    @Test
+    public void testShouldUseUnsafeSubscribeInternallyNotSubscribe() {
+        TestSubscriber<String> subscriber = TestSubscriber.create();
+        final AtomicBoolean unsubscribed = new AtomicBoolean(false);
+        Completable cmp = Observable.just("Hello World!").doOnUnsubscribe(new Action0() {
+
+            @Override
+            public void call() {
+                unsubscribed.set(true);
+            }}).toCompletable();
+        cmp.subscribe(subscriber);
+        subscriber.assertCompleted();
+        assertFalse(unsubscribed.get());
+    }
+}
diff --git a/src/test/java/rx/internal/operators/OnSubscribeDelaySubscriptionOtherTest.java b/src/test/java/rx/internal/operators/OnSubscribeDelaySubscriptionOtherTest.java
new file mode 100644
index 0000000000..e157a788e5
--- /dev/null
+++ b/src/test/java/rx/internal/operators/OnSubscribeDelaySubscriptionOtherTest.java
@@ -0,0 +1,246 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package rx.internal.operators;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.*;
+
+import rx.Observable;
+import rx.exceptions.TestException;
+import rx.functions.Action0;
+import rx.observers.TestSubscriber;
+import rx.subjects.PublishSubject;
+
+public class OnSubscribeDelaySubscriptionOtherTest {
+    @Test
+    public void testNoPrematureSubscription() {
+        PublishSubject<Object> other = PublishSubject.create();
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        final AtomicInteger subscribed = new AtomicInteger();
+        
+        Observable.just(1)
+        .doOnSubscribe(new Action0() {
+            @Override
+            public void call() {
+                subscribed.getAndIncrement();
+            }
+        })
+        .delaySubscription(other)
+        .subscribe(ts);
+        
+        ts.assertNotCompleted();
+        ts.assertNoErrors();
+        ts.assertNoValues();
+        
+        Assert.assertEquals("Premature subscription", 0, subscribed.get());
+        
+        other.onNext(1);
+        
+        Assert.assertEquals("No subscription", 1, subscribed.get());
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertCompleted();
+    }
+    
+    @Test
+    public void testNoMultipleSubscriptions() {
+        PublishSubject<Object> other = PublishSubject.create();
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        final AtomicInteger subscribed = new AtomicInteger();
+        
+        Observable.just(1)
+        .doOnSubscribe(new Action0() {
+            @Override
+            public void call() {
+                subscribed.getAndIncrement();
+            }
+        })
+        .delaySubscription(other)
+        .subscribe(ts);
+        
+        ts.assertNotCompleted();
+        ts.assertNoErrors();
+        ts.assertNoValues();
+        
+        Assert.assertEquals("Premature subscription", 0, subscribed.get());
+        
+        other.onNext(1);
+        other.onNext(2);
+        
+        Assert.assertEquals("No subscription", 1, subscribed.get());
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertCompleted();
+    }
+    
+    @Test
+    public void testCompleteTriggersSubscription() {
+        PublishSubject<Object> other = PublishSubject.create();
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        final AtomicInteger subscribed = new AtomicInteger();
+        
+        Observable.just(1)
+        .doOnSubscribe(new Action0() {
+            @Override
+            public void call() {
+                subscribed.getAndIncrement();
+            }
+        })
+        .delaySubscription(other)
+        .subscribe(ts);
+        
+        ts.assertNotCompleted();
+        ts.assertNoErrors();
+        ts.assertNoValues();
+        
+        Assert.assertEquals("Premature subscription", 0, subscribed.get());
+        
+        other.onCompleted();
+        
+        Assert.assertEquals("No subscription", 1, subscribed.get());
+        
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertCompleted();
+    }
+    
+    @Test
+    public void testNoPrematureSubscriptionToError() {
+        PublishSubject<Object> other = PublishSubject.create();
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        final AtomicInteger subscribed = new AtomicInteger();
+        
+        Observable.<Integer>error(new TestException())
+        .doOnSubscribe(new Action0() {
+            @Override
+            public void call() {
+                subscribed.getAndIncrement();
+            }
+        })
+        .delaySubscription(other)
+        .subscribe(ts);
+        
+        ts.assertNotCompleted();
+        ts.assertNoErrors();
+        ts.assertNoValues();
+        
+        Assert.assertEquals("Premature subscription", 0, subscribed.get());
+        
+        other.onCompleted();
+        
+        Assert.assertEquals("No subscription", 1, subscribed.get());
+        
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+        ts.assertError(TestException.class);
+    }
+    
+    @Test
+    public void testNoSubscriptionIfOtherErrors() {
+        PublishSubject<Object> other = PublishSubject.create();
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create();
+        
+        final AtomicInteger subscribed = new AtomicInteger();
+        
+        Observable.<Integer>error(new TestException())
+        .doOnSubscribe(new Action0() {
+            @Override
+            public void call() {
+                subscribed.getAndIncrement();
+            }
+        })
+        .delaySubscription(other)
+        .subscribe(ts);
+        
+        ts.assertNotCompleted();
+        ts.assertNoErrors();
+        ts.assertNoValues();
+        
+        Assert.assertEquals("Premature subscription", 0, subscribed.get());
+        
+        other.onError(new TestException());
+        
+        Assert.assertEquals("Premature subscription", 0, subscribed.get());
+        
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+        ts.assertError(TestException.class);
+    }
+    
+    @Test
+    public void testBackpressurePassesThrough() {
+        
+        PublishSubject<Object> other = PublishSubject.create();
+        
+        TestSubscriber<Integer> ts = TestSubscriber.create(0L);
+        
+        final AtomicInteger subscribed = new AtomicInteger();
+        
+        Observable.just(1, 2, 3, 4, 5)
+        .doOnSubscribe(new Action0() {
+            @Override
+            public void call() {
+                subscribed.getAndIncrement();
+            }
+        })
+        .delaySubscription(other)
+        .subscribe(ts);
+        
+        ts.assertNotCompleted();
+        ts.assertNoErrors();
+        ts.assertNoValues();
+        
+        Assert.assertEquals("Premature subscription", 0, subscribed.get());
+        
+        other.onNext(1);
+        
+        Assert.assertEquals("No subscription", 1, subscribed.get());
+
+        Assert.assertFalse("Not unsubscribed from other", other.hasObservers());
+        
+        ts.assertNotCompleted();
+        ts.assertNoErrors();
+        ts.assertNoValues();
+        
+        ts.requestMore(1);
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertNotCompleted();
+
+        ts.requestMore(2);
+        ts.assertValues(1, 2, 3);
+        ts.assertNoErrors();
+        ts.assertNotCompleted();
+
+        ts.requestMore(10);
+        ts.assertValues(1, 2, 3, 4, 5);
+        ts.assertNoErrors();
+        ts.assertCompleted();
+    }
+}
diff --git a/src/test/java/rx/internal/operators/OnSubscribeFromArrayTest.java b/src/test/java/rx/internal/operators/OnSubscribeFromArrayTest.java
new file mode 100644
index 0000000000..3b7ec5220b
--- /dev/null
+++ b/src/test/java/rx/internal/operators/OnSubscribeFromArrayTest.java
@@ -0,0 +1,67 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.operators;
+
+import org.junit.Test;
+
+import rx.Observable;
+import rx.observers.TestSubscriber;
+
+public class OnSubscribeFromArrayTest {
+    
+    Observable<Integer> create(int n) {
+        Integer[] array = new Integer[n];
+        for (int i = 0; i < n; i++) {
+            array[i] = i;
+        }
+        return Observable.create(new OnSubscribeFromArray<Integer>(array));
+    }
+    @Test
+    public void simple() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        
+        create(1000).subscribe(ts);
+        
+        ts.assertNoErrors();
+        ts.assertValueCount(1000);
+        ts.assertCompleted();
+    }
+
+    @Test
+    public void backpressure() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+        
+        create(1000).subscribe(ts);
+        
+        ts.assertNoErrors();
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+        
+        ts.requestMore(10);
+        
+        ts.assertNoErrors();
+        ts.assertValueCount(10);
+        ts.assertNotCompleted();
+        
+        ts.requestMore(1000);
+        
+        ts.assertNoErrors();
+        ts.assertValueCount(1000);
+        ts.assertCompleted();
+    }
+
+}
diff --git a/src/test/java/rx/internal/operators/OperatorConcatTest.java b/src/test/java/rx/internal/operators/OperatorConcatTest.java
index bce41e0e16..8812dd50eb 100644
--- a/src/test/java/rx/internal/operators/OperatorConcatTest.java
+++ b/src/test/java/rx/internal/operators/OperatorConcatTest.java
@@ -728,7 +728,7 @@ public void testIssue2890NoStackoverflow() throws InterruptedException {
                 Observable<Integer> observable = Observable.just(t)
                         .subscribeOn(sch)
                 ;
-                Subject<Integer, Integer> subject = BufferUntilSubscriber.create();
+                Subject<Integer, Integer> subject = UnicastSubject.create();
                 observable.subscribe(subject);
                 return subject;
             }
@@ -822,4 +822,4 @@ public void concatMapRangeAsyncLoopIssue2876() {
         }
     }
     
-}
+}
\ No newline at end of file
diff --git a/src/test/java/rx/internal/operators/OperatorFinallyTest.java b/src/test/java/rx/internal/operators/OperatorDoAfterTerminateTest.java
similarity index 71%
rename from src/test/java/rx/internal/operators/OperatorFinallyTest.java
rename to src/test/java/rx/internal/operators/OperatorDoAfterTerminateTest.java
index 5403e7ebe6..6295386ae1 100644
--- a/src/test/java/rx/internal/operators/OperatorFinallyTest.java
+++ b/src/test/java/rx/internal/operators/OperatorDoAfterTerminateTest.java
@@ -15,6 +15,8 @@
  */
 package rx.internal.operators;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -26,7 +28,7 @@
 import rx.Observer;
 import rx.functions.Action0;
 
-public class OperatorFinallyTest {
+public class OperatorDoAfterTerminateTest {
 
     private Action0 aAction0;
     private Observer<String> observer;
@@ -40,17 +42,27 @@ public void before() {
     }
 
     private void checkActionCalled(Observable<String> input) {
-        input.finallyDo(aAction0).subscribe(observer);
+        input.doAfterTerminate(aAction0).subscribe(observer);
         verify(aAction0, times(1)).call();
     }
 
     @Test
-    public void testFinallyCalledOnComplete() {
+    public void testDoAfterTerminateCalledOnComplete() {
         checkActionCalled(Observable.from(new String[] { "1", "2", "3" }));
     }
 
     @Test
-    public void testFinallyCalledOnError() {
+    public void testDoAfterTerminateCalledOnError() {
         checkActionCalled(Observable.<String> error(new RuntimeException("expected")));
     }
+
+    @Test
+    public void nullActionShouldBeCheckedInConstructor() {
+        try {
+            new OperatorDoAfterTerminate<Object>(null);
+            fail();
+        } catch (NullPointerException expected) {
+            assertEquals("Action can not be null", expected.getMessage());
+        }
+    }
 }
diff --git a/src/test/java/rx/internal/operators/OperatorGroupByTest.java b/src/test/java/rx/internal/operators/OperatorGroupByTest.java
index 43aad7eedf..3474e4c905 100644
--- a/src/test/java/rx/internal/operators/OperatorGroupByTest.java
+++ b/src/test/java/rx/internal/operators/OperatorGroupByTest.java
@@ -15,45 +15,24 @@
  */
 package rx.internal.operators;
 
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Matchers;
-import org.mockito.MockitoAnnotations;
-
-import rx.Notification;
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.*;
+import static org.mockito.Mockito.*;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
+
+import org.junit.*;
+import org.mockito.*;
+
+import rx.*;
 import rx.Observable;
 import rx.Observable.OnSubscribe;
 import rx.Observer;
-import rx.Subscriber;
-import rx.Subscription;
 import rx.exceptions.TestException;
-import rx.functions.Action0;
-import rx.functions.Action1;
-import rx.functions.Func1;
-import rx.internal.util.UtilityFunctions;
+import rx.functions.*;
+import rx.internal.util.*;
 import rx.observables.GroupedObservable;
 import rx.observers.TestSubscriber;
 import rx.schedulers.Schedulers;
@@ -1501,4 +1480,105 @@ public void onNext(Integer t) {
                     }});
         assertTrue(completed.get());
     }
+    
+    /**
+     * Issue #3425.
+     * 
+     * The problem is that a request of 1 may create a new group, emit to the desired group
+     * or emit to a completely different group. In this test, the merge requests N which
+     * must be produced by the range, however it will create a bunch of groups before the actual
+     * group receives a value.
+     */
+    @Test
+    public void testBackpressureObserveOnOuter() {
+        for (int j = 0; j < 1000; j++) {
+            Observable.merge(
+                    Observable.range(0, 500)
+                    .groupBy(new Func1<Integer, Object>() {
+                        @Override
+                        public Object call(Integer i) {
+                            return i % (RxRingBuffer.SIZE + 2);
+                        }
+                    })
+                    .observeOn(Schedulers.computation())
+            ).toBlocking().last();
+        }
+    }
+    
+    /**
+     * Synchronous verification of issue #3425.
+     */
+    @Test
+    public void testBackpressureInnerDoesntOverflowOuter() {
+        TestSubscriber<Object> ts = TestSubscriber.create(0);
+        
+        Observable.just(1, 2)
+                .groupBy(new Func1<Integer, Object>() {
+                    @Override
+                    public Object call(Integer v) {
+                        return v;
+                    }
+                })
+                .doOnNext(new Action1<GroupedObservable<Object, Integer>>() {
+                    @Override
+                    public void call(GroupedObservable<Object, Integer> g) {
+                        // this will request Long.MAX_VALUE
+                        g.subscribe();
+                    }
+                })
+                // this won't request anything just yet
+                .subscribe(ts)
+                ;
+        ts.requestMore(1);
+        
+        ts.assertNotCompleted();
+        ts.assertNoErrors();
+        ts.assertValueCount(1);
+    }
+    
+    @Test
+    public void testOneGroupInnerRequestsTwiceBuffer() {
+        TestSubscriber<Object> ts1 = TestSubscriber.create(0);
+        final TestSubscriber<Object> ts2 = TestSubscriber.create(0);
+        
+        Observable.range(1, RxRingBuffer.SIZE * 2)
+        .groupBy(new Func1<Integer, Object>() {
+            @Override
+            public Object call(Integer v) {
+                return 1;
+            }
+        })
+        .doOnNext(new Action1<GroupedObservable<Object, Integer>>() {
+            @Override
+            public void call(GroupedObservable<Object, Integer> g) {
+                g.subscribe(ts2);
+            }
+        })
+        .subscribe(ts1);
+        
+        ts1.assertNoValues();
+        ts1.assertNoErrors();
+        ts1.assertNotCompleted();
+        
+        ts2.assertNoValues();
+        ts2.assertNoErrors();
+        ts2.assertNotCompleted();
+        
+        ts1.requestMore(1);
+        
+        ts1.assertValueCount(1);
+        ts1.assertNoErrors();
+        ts1.assertNotCompleted();
+        
+        ts2.assertNoValues();
+        ts2.assertNoErrors();
+        ts2.assertNotCompleted();
+        
+        ts2.requestMore(RxRingBuffer.SIZE * 2);
+        
+        ts2.assertValueCount(RxRingBuffer.SIZE * 2);
+        ts2.assertNoErrors();
+        ts2.assertNotCompleted();
+    }
+
 }
diff --git a/src/test/java/rx/internal/operators/OperatorObserveOnTest.java b/src/test/java/rx/internal/operators/OperatorObserveOnTest.java
index e505bf0672..65a4085384 100644
--- a/src/test/java/rx/internal/operators/OperatorObserveOnTest.java
+++ b/src/test/java/rx/internal/operators/OperatorObserveOnTest.java
@@ -138,7 +138,7 @@ public void call(String t1) {
                 assertTrue(correctThreadName);
             }
 
-        }).finallyDo(new Action0() {
+        }).doAfterTerminate(new Action0() {
 
             @Override
             public void call() {
diff --git a/src/test/java/rx/internal/operators/OperatorReplayTest.java b/src/test/java/rx/internal/operators/OperatorReplayTest.java
index c0ec384d84..1117ade147 100644
--- a/src/test/java/rx/internal/operators/OperatorReplayTest.java
+++ b/src/test/java/rx/internal/operators/OperatorReplayTest.java
@@ -623,7 +623,8 @@ public void testIssue2191_SchedulerUnsubscribe() throws Exception {
         verifyObserverMock(mockObserverAfterConnect, 2, 6);
 
         verify(spiedWorker, times(1)).isUnsubscribed();
-        verify(spiedWorker, times(1)).unsubscribe();
+        // subscribeOn didn't unsubscribe the worker before but it should have
+        verify(spiedWorker, times(2)).unsubscribe();
         verify(sourceUnsubscribed, times(1)).call();
 
         verifyNoMoreInteractions(sourceNext);
@@ -684,7 +685,8 @@ public void testIssue2191_SchedulerUnsubscribeOnError() throws Exception {
         verifyObserver(mockObserverAfterConnect, 2, 2, illegalArgumentException);
 
         verify(spiedWorker, times(1)).isUnsubscribed();
-        verify(spiedWorker, times(1)).unsubscribe();
+     // subscribeOn didn't unsubscribe the worker before but it should have
+        verify(spiedWorker, times(2)).unsubscribe();
         verify(sourceUnsubscribed, times(1)).call();
 
         verifyNoMoreInteractions(sourceNext);
@@ -749,11 +751,11 @@ public boolean isUnsubscribed() {
     @Test
     public void testBoundedReplayBuffer() {
         BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<Integer>();
-        buf.addLast(new Node(1));
-        buf.addLast(new Node(2));
-        buf.addLast(new Node(3));
-        buf.addLast(new Node(4));
-        buf.addLast(new Node(5));
+        buf.addLast(new Node(1, 0));
+        buf.addLast(new Node(2, 1));
+        buf.addLast(new Node(3, 2));
+        buf.addLast(new Node(4, 3));
+        buf.addLast(new Node(5, 4));
         
         List<Integer> values = new ArrayList<Integer>();
         buf.collect(values);
@@ -768,8 +770,8 @@ public void testBoundedReplayBuffer() {
         buf.collect(values);
         Assert.assertTrue(values.isEmpty());
 
-        buf.addLast(new Node(5));
-        buf.addLast(new Node(6));
+        buf.addLast(new Node(5, 5));
+        buf.addLast(new Node(6, 6));
         buf.collect(values);
         
         Assert.assertEquals(Arrays.asList(5, 6), values);
@@ -1145,4 +1147,107 @@ public void call(Long t) {
         Assert.assertEquals(Arrays.asList(5L, 5L), requests);
     }
     
+    @Test
+    public void testSubscribersComeAndGoAtRequestBoundaries() {
+        ConnectableObservable<Integer> source = Observable.range(1, 10).replay(1);
+        source.connect();
+        
+        TestSubscriber<Integer> ts1 = TestSubscriber.create(2);
+        
+        source.subscribe(ts1);
+        
+        ts1.assertValues(1, 2);
+        ts1.assertNoErrors();
+        ts1.unsubscribe();
+        
+        TestSubscriber<Integer> ts2 = TestSubscriber.create(2);
+        
+        source.subscribe(ts2);
+        
+        ts2.assertValues(2, 3);
+        ts2.assertNoErrors();
+        ts2.unsubscribe();
+
+        TestSubscriber<Integer> ts21 = TestSubscriber.create(1);
+        
+        source.subscribe(ts21);
+        
+        ts21.assertValues(3);
+        ts21.assertNoErrors();
+        ts21.unsubscribe();
+
+        TestSubscriber<Integer> ts22 = TestSubscriber.create(1);
+        
+        source.subscribe(ts22);
+        
+        ts22.assertValues(3);
+        ts22.assertNoErrors();
+        ts22.unsubscribe();
+
+        
+        TestSubscriber<Integer> ts3 = TestSubscriber.create();
+        
+        source.subscribe(ts3);
+        
+        ts3.assertNoErrors();
+        System.out.println(ts3.getOnNextEvents());
+        ts3.assertValues(3, 4, 5, 6, 7, 8, 9, 10);
+        ts3.assertCompleted();
+    }
+    
+    @Test
+    public void testSubscribersComeAndGoAtRequestBoundaries2() {
+        ConnectableObservable<Integer> source = Observable.range(1, 10).replay(2);
+        source.connect();
+        
+        TestSubscriber<Integer> ts1 = TestSubscriber.create(2);
+        
+        source.subscribe(ts1);
+        
+        ts1.assertValues(1, 2);
+        ts1.assertNoErrors();
+        ts1.unsubscribe();
+
+        TestSubscriber<Integer> ts11 = TestSubscriber.create(2);
+        
+        source.subscribe(ts11);
+        
+        ts11.assertValues(1, 2);
+        ts11.assertNoErrors();
+        ts11.unsubscribe();
+
+        TestSubscriber<Integer> ts2 = TestSubscriber.create(3);
+        
+        source.subscribe(ts2);
+        
+        ts2.assertValues(1, 2, 3);
+        ts2.assertNoErrors();
+        ts2.unsubscribe();
+
+        TestSubscriber<Integer> ts21 = TestSubscriber.create(1);
+        
+        source.subscribe(ts21);
+        
+        ts21.assertValues(2);
+        ts21.assertNoErrors();
+        ts21.unsubscribe();
+
+        TestSubscriber<Integer> ts22 = TestSubscriber.create(1);
+        
+        source.subscribe(ts22);
+        
+        ts22.assertValues(2);
+        ts22.assertNoErrors();
+        ts22.unsubscribe();
+
+        
+        TestSubscriber<Integer> ts3 = TestSubscriber.create();
+        
+        source.subscribe(ts3);
+        
+        ts3.assertNoErrors();
+        System.out.println(ts3.getOnNextEvents());
+        ts3.assertValues(2, 3, 4, 5, 6, 7, 8, 9, 10);
+        ts3.assertCompleted();
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/rx/internal/operators/OperatorRetryTest.java b/src/test/java/rx/internal/operators/OperatorRetryTest.java
index 146ee3c254..dc6eb510a9 100644
--- a/src/test/java/rx/internal/operators/OperatorRetryTest.java
+++ b/src/test/java/rx/internal/operators/OperatorRetryTest.java
@@ -874,6 +874,7 @@ public void call(Subscriber<? super String> o) {
         });
         
         origin.retry()
+        .onBackpressureBuffer() // FIXME the new GroupBy won't request enough for this particular test and retry overflows
         .groupBy(new Func1<String, String>() {
             @Override
             public String call(String t1) {
diff --git a/src/test/java/rx/internal/operators/OperatorScanTest.java b/src/test/java/rx/internal/operators/OperatorScanTest.java
index 96c1b1dbe1..20e53668a6 100644
--- a/src/test/java/rx/internal/operators/OperatorScanTest.java
+++ b/src/test/java/rx/internal/operators/OperatorScanTest.java
@@ -27,9 +27,9 @@
 
 import rx.*;
 import rx.Observable;
+import rx.Observable.OnSubscribe;
 import rx.Observer;
 import rx.functions.*;
-import rx.observables.AbstractOnSubscribe;
 import rx.observers.TestSubscriber;
 import rx.subjects.PublishSubject;
 
@@ -371,12 +371,17 @@ public Integer call(Integer t1, Integer t2) {
     
     @Test
     public void testInitialValueEmittedWithProducer() {
-        Observable<Integer> source = new AbstractOnSubscribe<Integer, Void>() {
+        Observable<Integer> source = Observable.create(new OnSubscribe<Integer>() {
             @Override
-            protected void next(rx.observables.AbstractOnSubscribe.SubscriptionState<Integer, Void> state) {
-                state.stop();
+            public void call(Subscriber<? super Integer> t) {
+                t.setProducer(new Producer() {
+                    @Override
+                    public void request(long n) {
+                        // deliberately no op
+                    }
+                });
             }
-        }.toObservable();
+        });
         
         TestSubscriber<Integer> ts = TestSubscriber.create();
         
@@ -426,4 +431,24 @@ public Integer call(Integer t1, Integer t2) {
         ts.assertNoErrors();
         ts.assertCompleted();
     }
+    
+    @Test(timeout = 1000)
+    public void testUnboundedSource() {
+        Observable.range(0, Integer.MAX_VALUE)
+        .scan(0, new Func2<Integer, Integer, Integer>() {
+            @Override
+            public Integer call(Integer a, Integer b) {
+                return 0;
+            }
+        })
+        .subscribe(new TestSubscriber<Integer>() {
+            int count;
+            @Override
+            public void onNext(Integer t) {
+                if (++count == 2) {
+                    unsubscribe();
+                }
+            }
+        });
+    }
 }
diff --git a/src/test/java/rx/internal/operators/OperatorToMapTest.java b/src/test/java/rx/internal/operators/OperatorToMapTest.java
index 669b85c234..466cff0df8 100644
--- a/src/test/java/rx/internal/operators/OperatorToMapTest.java
+++ b/src/test/java/rx/internal/operators/OperatorToMapTest.java
@@ -16,24 +16,19 @@
 package rx.internal.operators;
 
 import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.*;
 
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.Map;
+import java.util.*;
 
-import org.junit.Before;
-import org.junit.Test;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
+import org.junit.*;
+import org.mockito.*;
 
 import rx.Observable;
 import rx.Observer;
-import rx.functions.Func0;
-import rx.functions.Func1;
+import rx.exceptions.TestException;
+import rx.functions.*;
 import rx.internal.util.UtilityFunctions;
+import rx.observers.TestSubscriber;
 
 public class OperatorToMapTest {
     @Mock
@@ -224,4 +219,66 @@ public Integer call(String t1) {
         verify(objectObserver, times(1)).onError(any(Throwable.class));
     }
 
+    @Test
+    public void testKeySelectorThrows() {
+        TestSubscriber<Object> ts = TestSubscriber.create();
+        
+        Observable.just(1, 2).toMap(new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                throw new TestException();
+            }
+        }).subscribe(ts);
+        
+        ts.assertError(TestException.class);
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+    }
+    
+    @Test
+    public void testValueSelectorThrows() {
+        TestSubscriber<Object> ts = TestSubscriber.create();
+        
+        Observable.just(1, 2).toMap(new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                return v;
+            }
+        }, new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                throw new TestException();
+            }
+        }).subscribe(ts);
+        
+        ts.assertError(TestException.class);
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+    }
+    
+    @Test
+    public void testMapFactoryThrows() {
+        TestSubscriber<Object> ts = TestSubscriber.create();
+        
+        Observable.just(1, 2).toMap(new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                return v;
+            }
+        }, new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                return v;
+            }
+        }, new Func0<Map<Integer, Integer>>() {
+            @Override
+            public Map<Integer, Integer> call() {
+                throw new TestException();
+            }
+        }).subscribe(ts);
+        
+        ts.assertError(TestException.class);
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+    }
 }
diff --git a/src/test/java/rx/internal/operators/OperatorToMultimapTest.java b/src/test/java/rx/internal/operators/OperatorToMultimapTest.java
index b8f57f04f6..f93f57500d 100644
--- a/src/test/java/rx/internal/operators/OperatorToMultimapTest.java
+++ b/src/test/java/rx/internal/operators/OperatorToMultimapTest.java
@@ -36,11 +36,13 @@
 
 import rx.Observable;
 import rx.Observer;
+import rx.exceptions.TestException;
 import rx.functions.Func0;
 import rx.functions.Func1;
 import rx.internal.operators.OperatorToMultimap.DefaultMultimapCollectionFactory;
 import rx.internal.operators.OperatorToMultimap.DefaultToMultimapFactory;
 import rx.internal.util.UtilityFunctions;
+import rx.observers.TestSubscriber;
 
 public class OperatorToMultimapTest {
     @Mock
@@ -269,4 +271,98 @@ public void testToMultimapWithThrowingCollectionFactory() {
         verify(objectObserver, never()).onNext(expected);
         verify(objectObserver, never()).onCompleted();
     }
+    
+    @Test
+    public void testKeySelectorThrows() {
+        TestSubscriber<Object> ts = TestSubscriber.create();
+        
+        Observable.just(1, 2).toMultimap(new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                throw new TestException();
+            }
+        }).subscribe(ts);
+        
+        ts.assertError(TestException.class);
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+    }
+    
+    @Test
+    public void testValueSelectorThrows() {
+        TestSubscriber<Object> ts = TestSubscriber.create();
+        
+        Observable.just(1, 2).toMultimap(new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                return v;
+            }
+        }, new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                throw new TestException();
+            }
+        }).subscribe(ts);
+        
+        ts.assertError(TestException.class);
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+    }
+    
+    @Test
+    public void testMapFactoryThrows() {
+        TestSubscriber<Object> ts = TestSubscriber.create();
+        
+        Observable.just(1, 2).toMultimap(new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                return v;
+            }
+        }, new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                return v;
+            }
+        }, new Func0<Map<Integer, Collection<Integer>>>() {
+            @Override
+            public Map<Integer, Collection<Integer>> call() {
+                throw new TestException();
+            }
+        }).subscribe(ts);
+        
+        ts.assertError(TestException.class);
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+    }
+    
+    @Test
+    public void testCollectionFactoryThrows() {
+        TestSubscriber<Object> ts = TestSubscriber.create();
+        
+        Observable.just(1, 2).toMultimap(new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                return v;
+            }
+        }, new Func1<Integer, Integer>() {
+            @Override
+            public Integer call(Integer v) {
+                return v;
+            }
+        }, new Func0<Map<Integer, Collection<Integer>>>() {
+            @Override
+            public Map<Integer, Collection<Integer>> call() {
+                return new HashMap<Integer, Collection<Integer>>();
+            }
+        }, new Func1<Integer, Collection<Integer>>() {
+            @Override
+            public Collection<Integer> call(Integer k) {
+                throw new TestException();
+            }
+        }).subscribe(ts);
+        
+        ts.assertError(TestException.class);
+        ts.assertNoValues();
+        ts.assertNotCompleted();
+    }
 }
diff --git a/src/test/java/rx/internal/operators/OperatorUnsubscribeOnTest.java b/src/test/java/rx/internal/operators/OperatorUnsubscribeOnTest.java
index 08bce82609..4be8b96298 100644
--- a/src/test/java/rx/internal/operators/OperatorUnsubscribeOnTest.java
+++ b/src/test/java/rx/internal/operators/OperatorUnsubscribeOnTest.java
@@ -20,7 +20,7 @@
 import static org.junit.Assert.assertTrue;
 
 import java.util.Arrays;
-import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.Test;
@@ -31,13 +31,14 @@
 import rx.Subscriber;
 import rx.Subscription;
 import rx.functions.Action0;
+import rx.internal.util.RxThreadFactory;
 import rx.observers.TestObserver;
 import rx.schedulers.Schedulers;
 import rx.subscriptions.Subscriptions;
 
 public class OperatorUnsubscribeOnTest {
 
-    @Test
+    @Test(timeout = 1000)
     public void testUnsubscribeWhenSubscribeOnAndUnsubscribeOnAreOnSameThread() throws InterruptedException {
         UIEventLoopScheduler UI_EVENT_LOOP = new UIEventLoopScheduler();
         try {
@@ -56,7 +57,11 @@ public void call(Subscriber<? super Integer> t1) {
             });
 
             TestObserver<Integer> observer = new TestObserver<Integer>();
-            w.subscribeOn(UI_EVENT_LOOP).observeOn(Schedulers.computation()).unsubscribeOn(UI_EVENT_LOOP).subscribe(observer);
+            w
+            .subscribeOn(UI_EVENT_LOOP)
+            .observeOn(Schedulers.computation())
+            .unsubscribeOn(UI_EVENT_LOOP)
+            .subscribe(observer);
 
             Thread unsubscribeThread = subscription.getThread();
 
@@ -78,7 +83,7 @@ public void call(Subscriber<? super Integer> t1) {
         }
     }
 
-    @Test
+    @Test(timeout = 1000)
     public void testUnsubscribeWhenSubscribeOnAndUnsubscribeOnAreOnDifferentThreads() throws InterruptedException {
         UIEventLoopScheduler UI_EVENT_LOOP = new UIEventLoopScheduler();
         try {
@@ -97,7 +102,11 @@ public void call(Subscriber<? super Integer> t1) {
             });
 
             TestObserver<Integer> observer = new TestObserver<Integer>();
-            w.subscribeOn(Schedulers.newThread()).observeOn(Schedulers.computation()).unsubscribeOn(UI_EVENT_LOOP).subscribe(observer);
+            w
+            .subscribeOn(Schedulers.newThread())
+            .observeOn(Schedulers.computation())
+            .unsubscribeOn(UI_EVENT_LOOP)
+            .subscribe(observer);
 
             Thread unsubscribeThread = subscription.getThread();
 
@@ -110,7 +119,10 @@ public void call(Subscriber<? super Integer> t1) {
 
             System.out.println("unsubscribeThread: " + unsubscribeThread);
             System.out.println("subscribeThread.get(): " + subscribeThread.get());
-            assertTrue(unsubscribeThread == UI_EVENT_LOOP.getThread());
+            Thread uiThread = UI_EVENT_LOOP.getThread();
+            System.out.println("UI_EVENT_LOOP: " + uiThread);
+
+            assertTrue(unsubscribeThread == uiThread);
 
             observer.assertReceivedOnNext(Arrays.asList(1, 2));
             observer.assertTerminalEvent();
@@ -153,23 +165,24 @@ public Thread getThread() throws InterruptedException {
 
     public static class UIEventLoopScheduler extends Scheduler {
 
-        private final Scheduler.Worker eventLoop;
-        private final Subscription s;
+        private final ExecutorService eventLoop;
+        final Scheduler single;
         private volatile Thread t;
 
         public UIEventLoopScheduler() {
 
-            eventLoop = Schedulers.newThread().createWorker();
-            s = eventLoop;
+            eventLoop = Executors.newSingleThreadExecutor(new RxThreadFactory("Test-EventLoop"));
 
+            single = Schedulers.from(eventLoop);
+            
             /*
              * DON'T DO THIS IN PRODUCTION CODE
              */
             final CountDownLatch latch = new CountDownLatch(1);
-            eventLoop.schedule(new Action0() {
+            eventLoop.submit(new Runnable() {
 
                 @Override
-                public void call() {
+                public void run() {
                     t = Thread.currentThread();
                     latch.countDown();
                 }
@@ -184,11 +197,11 @@ public void call() {
         
         @Override
         public Worker createWorker() {
-            return eventLoop;
+            return single.createWorker();
         }
 
         public void shutdown() {
-            s.unsubscribe();
+            eventLoop.shutdownNow();
         }
 
         public Thread getThread() {
@@ -196,4 +209,4 @@ public Thread getThread() {
         }
 
     }
-}
+}
\ No newline at end of file
diff --git a/src/test/java/rx/internal/operators/OperatorWindowWithObservableTest.java b/src/test/java/rx/internal/operators/OperatorWindowWithObservableTest.java
index 05488379c2..9d6ee60baa 100644
--- a/src/test/java/rx/internal/operators/OperatorWindowWithObservableTest.java
+++ b/src/test/java/rx/internal/operators/OperatorWindowWithObservableTest.java
@@ -383,7 +383,7 @@ public void testChildUnsubscribed() {
         ts.assertValueCount(1);
     }
     @Test
-    public void testNoBackpressure() {
+    public void testInnerBackpressure() {
         Observable<Integer> source = Observable.range(1, 10);
         final PublishSubject<Integer> boundary = PublishSubject.create();
         Func0<Observable<Integer>> boundaryFunc = new Func0<Observable<Integer>>() {
@@ -409,7 +409,13 @@ public void onNext(Observable<Integer> t) {
         ts1.assertValueCount(1);
         
         ts.assertNoErrors();
+        ts.assertNotCompleted();
+        ts.assertValues(1);
+        
+        ts.requestMore(11);
+        
         ts.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
+        ts.assertNoErrors();
         ts.assertCompleted();
     }
     @Test
diff --git a/src/test/java/rx/internal/operators/OperatorZipIterableTest.java b/src/test/java/rx/internal/operators/OperatorZipIterableTest.java
index 15ae12570d..2aa2ed9a9d 100644
--- a/src/test/java/rx/internal/operators/OperatorZipIterableTest.java
+++ b/src/test/java/rx/internal/operators/OperatorZipIterableTest.java
@@ -23,6 +23,7 @@
 
 import java.util.Arrays;
 import java.util.Iterator;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import static org.junit.Assert.assertEquals;
 
@@ -37,6 +38,8 @@
 import rx.functions.Func1;
 import rx.functions.Func2;
 import rx.functions.Func3;
+import rx.observers.TestSubscriber;
+import rx.schedulers.TestScheduler;
 import rx.subjects.PublishSubject;
 
 public class OperatorZipIterableTest {
@@ -378,4 +381,22 @@ public String call(Integer t1) {
         
         assertEquals(2, squareStr.counter.get());
     }
+
+    @Test
+    public void testZipIterableWithDelay() {
+        TestScheduler scheduler = new TestScheduler();
+        Observable<Integer> o = Observable.just(1, 2).zipWith(Arrays.asList(1), new Func2<Integer, Integer, Integer>() {
+            @Override
+            public Integer call(Integer v1, Integer v2) {
+                return v1;
+            }
+        }).delay(500, TimeUnit.MILLISECONDS, scheduler);
+
+        TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();
+        o.subscribe(subscriber);
+        scheduler.advanceTimeBy(1000, TimeUnit.MILLISECONDS);
+        subscriber.assertValue(1);
+        subscriber.assertNoErrors();
+        subscriber.assertCompleted();
+    }
 }
diff --git a/src/test/java/rx/internal/operators/OperatorZipTest.java b/src/test/java/rx/internal/operators/OperatorZipTest.java
index dcf323da7e..f13ba0ccb9 100644
--- a/src/test/java/rx/internal/operators/OperatorZipTest.java
+++ b/src/test/java/rx/internal/operators/OperatorZipTest.java
@@ -1308,4 +1308,32 @@ public Integer call(Integer t1, Integer t2) {
         ts.assertNoErrors();
         ts.assertReceivedOnNext(Arrays.asList(11));
     }
+    
+    @SuppressWarnings("cast")
+    @Test
+    public void testZipObservableObservableBackpressure() {
+        @SuppressWarnings("unchecked")
+        Observable<Integer>[] osArray = new Observable[] { 
+                Observable.range(0, 10), 
+                Observable.range(0, 10) 
+        };
+        
+        Observable<Observable<Integer>> os = (Observable<Observable<Integer>>) Observable.from(osArray);
+        Observable<Integer> o1 = Observable.zip(os, new FuncN<Integer>() {
+            @Override
+            public Integer call(Object... a) {
+                return 0;
+            }
+        });
+        
+        TestSubscriber<Integer> sub1 = TestSubscriber.create(5);
+        
+        o1.subscribe(sub1);
+
+        sub1.requestMore(5);
+
+        sub1.assertValueCount(10);
+        sub1.assertNoErrors();
+        sub1.assertCompleted();
+    }
 }
diff --git a/src/test/java/rx/internal/producers/ProducersTest.java b/src/test/java/rx/internal/producers/ProducersTest.java
index 0e5beacdfa..81377f29a3 100644
--- a/src/test/java/rx/internal/producers/ProducersTest.java
+++ b/src/test/java/rx/internal/producers/ProducersTest.java
@@ -23,8 +23,8 @@
 import org.junit.*;
 
 import rx.*;
-import rx.Observable.OnSubscribe;
 import rx.Observable;
+import rx.Observable.*;
 import rx.Observer;
 import rx.functions.*;
 import rx.observers.TestSubscriber;
@@ -378,4 +378,52 @@ public void testObserverArbiterAsync() {
                 20L, 21L, 22L, 23L, 24L,
                 40L, 41L, 42L, 43L, 44L));
     }
+    
+    @Test(timeout = 1000)
+    public void testProducerObserverArbiterUnbounded() {
+        Observable.range(0, Integer.MAX_VALUE)
+        .lift(new Operator<Integer, Integer>() {
+            @Override
+            public Subscriber<? super Integer> call(Subscriber<? super Integer> t) {
+                final ProducerObserverArbiter<Integer> poa = new ProducerObserverArbiter<Integer>(t);
+                
+                Subscriber<Integer> parent = new Subscriber<Integer>() {
+
+                    @Override
+                    public void onCompleted() {
+                        poa.onCompleted();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        poa.onError(e);
+                    }
+
+                    @Override
+                    public void onNext(Integer t) {
+                        poa.onNext(t);
+                    }
+                    
+                    
+                    @Override
+                    public void setProducer(Producer p) {
+                        poa.setProducer(p);
+                    }
+                };
+                
+                t.add(parent);
+                t.setProducer(poa);
+                
+                return parent;
+            }
+        }).subscribe(new TestSubscriber<Integer>() {
+            int count;
+            @Override
+            public void onNext(Integer t) {
+                if (++count == 2) {
+                    unsubscribe();
+                }
+            }
+        });
+    }
 }
diff --git a/src/test/java/rx/internal/util/BlockingUtilsTest.java b/src/test/java/rx/internal/util/BlockingUtilsTest.java
new file mode 100644
index 0000000000..02047b9d2f
--- /dev/null
+++ b/src/test/java/rx/internal/util/BlockingUtilsTest.java
@@ -0,0 +1,111 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.util;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.junit.*;
+
+import rx.*;
+import rx.schedulers.Schedulers;
+
+/**
+ * Test suite for {@link BlockingUtils}.
+ */
+public class BlockingUtilsTest {
+    
+    @Before
+    @After
+    public void before() {
+        // make sure the interrupted flag is cleared
+        Thread.interrupted();
+    }
+    
+    @Test
+    public void awaitCompleteShouldReturnIfCountIsZero() {
+        Subscription subscription = mock(Subscription.class);
+        CountDownLatch latch = new CountDownLatch(0);
+        BlockingUtils.awaitForComplete(latch, subscription);
+        verifyZeroInteractions(subscription);
+    }
+
+    @Test
+    public void awaitCompleteShouldReturnOnEmpty() {
+        final CountDownLatch latch = new CountDownLatch(1);
+        Subscriber<Object> subscription = createSubscription(latch);
+        Observable<Object> observable = Observable.empty().subscribeOn(Schedulers.newThread());
+        observable.subscribe(subscription);
+        BlockingUtils.awaitForComplete(latch, subscription);
+    }
+
+    @Test
+    public void awaitCompleteShouldReturnOnError() {
+        final CountDownLatch latch = new CountDownLatch(1);
+        Subscriber<Object> subscription = createSubscription(latch);
+        Observable<Object> observable = Observable.error(new RuntimeException()).subscribeOn(Schedulers.newThread());
+        observable.subscribe(subscription);
+        BlockingUtils.awaitForComplete(latch, subscription);
+    }
+
+    @Test
+    public void shouldThrowRuntimeExceptionOnThreadInterrupted() throws Exception {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final Subscription subscription = mock(Subscription.class);
+        final AtomicReference<Exception> caught = new AtomicReference<Exception>();
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Thread.currentThread().interrupt();
+                try {
+                    BlockingUtils.awaitForComplete(latch, subscription);
+                } catch (RuntimeException e) {
+                    caught.set(e);
+                }
+            }
+        });
+        thread.run();
+        verify(subscription).unsubscribe();
+        Exception actual = caught.get();
+        assertNotNull(actual);
+        assertNotNull(actual.getCause());
+        assertTrue(actual.getCause() instanceof InterruptedException);
+    }
+
+
+    private static <T> Subscriber<T> createSubscription(final CountDownLatch latch) {
+        return new Subscriber<T>() {
+            @Override
+            public void onNext(T t) {
+                //no-oop
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                latch.countDown();
+            }
+
+            @Override
+            public void onCompleted() {
+                latch.countDown();
+            }
+        };
+    }
+}
diff --git a/src/test/java/rx/internal/util/ScalarSynchronousObservableTest.java b/src/test/java/rx/internal/util/ScalarSynchronousObservableTest.java
new file mode 100644
index 0000000000..fee7b6f8e1
--- /dev/null
+++ b/src/test/java/rx/internal/util/ScalarSynchronousObservableTest.java
@@ -0,0 +1,233 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.internal.util;
+
+import org.junit.Test;
+
+import rx.Observable;
+import rx.exceptions.TestException;
+import rx.functions.Func1;
+import rx.observers.TestSubscriber;
+import rx.schedulers.Schedulers;
+
+public class ScalarSynchronousObservableTest {
+    @Test
+    public void testBackpressure() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+
+        Observable.just(1).subscribe(ts);
+
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertNotCompleted();
+
+        ts.requestMore(1);
+
+        ts.assertValue(1);
+        ts.assertCompleted();
+        ts.assertNoErrors();
+
+        ts.requestMore(1);
+
+        ts.assertValue(1);
+        ts.assertCompleted();
+        ts.assertNoErrors();
+    }
+
+    @Test(timeout = 1000)
+    public void testBackpressureSubscribeOn() throws Exception {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+
+        Observable.just(1).subscribeOn(Schedulers.computation()).subscribe(ts);
+
+        Thread.sleep(200);
+
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertNotCompleted();
+
+        ts.requestMore(1);
+
+        ts.awaitTerminalEvent();
+
+        ts.assertValue(1);
+        ts.assertCompleted();
+        ts.assertNoErrors();
+    }
+
+    @Test(timeout = 1000)
+    public void testBackpressureObserveOn() throws Exception {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+
+        Observable.just(1).observeOn(Schedulers.computation()).subscribe(ts);
+
+        Thread.sleep(200);
+
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertNotCompleted();
+
+        ts.requestMore(1);
+
+        ts.awaitTerminalEvent();
+
+        ts.assertValue(1);
+        ts.assertCompleted();
+        ts.assertNoErrors();
+    }
+
+    @Test
+    public void testBackpressureFlatMapJust() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+
+        Observable.just(1).flatMap(new Func1<Integer, Observable<Integer>>() {
+            @Override
+            public Observable<Integer> call(Integer v) {
+                return Observable.just(v);
+            }
+        }).subscribe(ts);
+
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertNotCompleted();
+
+        ts.requestMore(1);
+
+        ts.assertValue(1);
+        ts.assertCompleted();
+        ts.assertNoErrors();
+
+        ts.requestMore(1);
+
+        ts.assertValue(1);
+        ts.assertCompleted();
+        ts.assertNoErrors();
+    }
+
+    @Test
+    public void testBackpressureFlatMapRange() {
+        TestSubscriber<Integer> ts = TestSubscriber.create(0);
+
+        Observable.just(1).flatMap(new Func1<Integer, Observable<Integer>>() {
+            @Override
+            public Observable<Integer> call(Integer v) {
+                return Observable.range(v, 2);
+            }
+        }).subscribe(ts);
+
+        ts.assertNoValues();
+        ts.assertNoErrors();
+        ts.assertNotCompleted();
+
+        ts.requestMore(1);
+
+        ts.assertValue(1);
+        ts.assertNoErrors();
+        ts.assertNotCompleted();
+
+        ts.requestMore(1);
+        ts.assertValues(1, 2);
+        ts.assertCompleted();
+        ts.assertNoErrors();
+
+        ts.requestMore(1);
+
+        ts.assertValues(1, 2);
+        ts.assertCompleted();
+        ts.assertNoErrors();
+    }
+
+    @Test
+    public void emptiesAndJust() {
+        TestSubscriber<Object> ts = TestSubscriber.create();
+
+        Observable.just(1)
+        .flatMap(new Func1<Integer, Observable<String>>() {
+            @Override
+            public Observable<String> call(Integer n) {
+                return Observable.<String>just(null, null)
+                        .filter(new Func1<Object, Boolean>() {
+                            @Override
+                            public Boolean call(Object o) {
+                                return o != null;
+                            }
+                        })
+                        .switchIfEmpty(Observable.<String>empty().switchIfEmpty(Observable.just("Hello")));
+            }
+        }).subscribe(ts);
+
+        ts.assertValue("Hello");
+        ts.assertNoErrors();
+        ts.assertCompleted();
+    }
+
+    @Test
+    public void syncObserverNextThrows() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                throw new TestException();
+            }
+        };
+
+        Observable.just(1).unsafeSubscribe(ts);
+
+        ts.assertNoValues();
+        ts.assertError(TestException.class);
+        ts.assertNotCompleted();
+    }
+
+    @Test
+    public void syncFlatMapJustObserverNextThrows() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                throw new TestException();
+            }
+        };
+
+        Observable.just(1)
+        .flatMap(new Func1<Integer, Observable<Integer>>() {
+            @Override
+            public Observable<Integer> call(Integer v) {
+                return Observable.just(v);
+            }
+        })
+        .unsafeSubscribe(ts);
+
+        ts.assertNoValues();
+        ts.assertError(TestException.class);
+        ts.assertNotCompleted();
+    }
+
+    @Test(timeout = 1000)
+    public void asyncObserverNextThrows() {
+        TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {
+            @Override
+            public void onNext(Integer t) {
+                throw new TestException();
+            }
+        };
+
+        Observable.just(1).subscribeOn(Schedulers.computation()).unsafeSubscribe(ts);
+
+        ts.awaitTerminalEvent();
+        ts.assertNoValues();
+        ts.assertError(TestException.class);
+        ts.assertNotCompleted();
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/rx/observables/AbstractOnSubscribeTest.java b/src/test/java/rx/observables/AbstractOnSubscribeTest.java
deleted file mode 100644
index 95e3eac011..0000000000
--- a/src/test/java/rx/observables/AbstractOnSubscribeTest.java
+++ /dev/null
@@ -1,540 +0,0 @@
-/**
- * Copyright 2014 Netflix, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package rx.observables;
-
-import static org.junit.Assert.*;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.*;
-
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.junit.Test;
-import org.mockito.InOrder;
-
-import rx.*;
-import rx.Observable;
-import rx.Observer;
-import rx.exceptions.TestException;
-import rx.functions.*;
-import rx.observables.AbstractOnSubscribe.SubscriptionState;
-import rx.observers.TestSubscriber;
-import rx.schedulers.Schedulers;
-
-/**
- * Test if AbstractOnSubscribe adheres to the usual unsubscription and backpressure contracts.
- */
-public class AbstractOnSubscribeTest {
-    @Test
-    public void testJust() {
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                state.onNext(1);
-                state.onCompleted();
-            }
-        };
-        
-        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
-        
-        aos.toObservable().subscribe(ts);
-        
-        ts.assertNoErrors();
-        ts.assertTerminalEvent();
-        ts.assertReceivedOnNext(Arrays.asList(1));
-    }
-    @Test
-    public void testJustMisbehaving() {
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                state.onNext(1);
-                state.onNext(2);
-                state.onCompleted();
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        
-        aos.toObservable().subscribe(o);
-
-        verify(o, never()).onNext(any(Integer.class));
-        verify(o, never()).onCompleted();
-        verify(o).onError(any(IllegalStateException.class));
-    }
-    @Test
-    public void testJustMisbehavingOnCompleted() {
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                state.onNext(1);
-                state.onCompleted();
-                state.onCompleted();
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        
-        aos.toObservable().subscribe(o);
-
-        verify(o, never()).onNext(any(Integer.class));
-        verify(o, never()).onCompleted();
-        verify(o).onError(any(IllegalStateException.class));
-    }
-    @Test
-    public void testJustMisbehavingOnError() {
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                state.onNext(1);
-                state.onError(new TestException("Forced failure 1"));
-                state.onError(new TestException("Forced failure 2"));
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        
-        aos.toObservable().subscribe(o);
-
-        verify(o, never()).onNext(any(Integer.class));
-        verify(o, never()).onCompleted();
-        verify(o).onError(any(IllegalStateException.class));
-    }
-    @Test
-    public void testEmpty() {
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                state.onCompleted();
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        
-        aos.toObservable().subscribe(o);
-        
-        verify(o, never()).onNext(any(Integer.class));
-        verify(o, never()).onError(any(Throwable.class));
-        verify(o).onCompleted();
-    }
-    @Test
-    public void testNever() {
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                state.stop();
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        
-        aos.toObservable().subscribe(o);
-        
-        verify(o, never()).onNext(any(Integer.class));
-        verify(o, never()).onError(any(Throwable.class));
-        verify(o, never()).onCompleted();
-    }
-
-    @Test
-    public void testThrows() {
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                throw new TestException("Forced failure");
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        
-        aos.toObservable().subscribe(o);
-        
-        verify(o, never()).onNext(any(Integer.class));
-        verify(o, never()).onCompleted();
-        verify(o).onError(any(TestException.class));
-    }
-
-    @Test
-    public void testError() {
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                state.onError(new TestException("Forced failure"));
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        
-        aos.toObservable().subscribe(o);
-        
-        verify(o, never()).onNext(any(Integer.class));
-        verify(o).onError(any(TestException.class));
-        verify(o, never()).onCompleted();
-    }
-    @Test
-    public void testRange() {
-        final int start = 1;
-        final int count = 100;
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                long calls = state.calls();
-                if (calls <= count) {
-                    state.onNext((int)calls + start);
-                    if (calls == count) {
-                        state.onCompleted();
-                    }
-                }
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        InOrder inOrder = inOrder(o);
-        
-        aos.toObservable().subscribe(o);
-        
-        verify(o, never()).onError(any(TestException.class));
-        for (int i = start; i < start + count; i++) {
-            inOrder.verify(o).onNext(i);
-        }
-        inOrder.verify(o).onCompleted();
-        inOrder.verifyNoMoreInteractions();
-    }
-    @Test
-    public void testFromIterable() {
-        int n = 100;
-        final List<Integer> source = new ArrayList<Integer>();
-        for (int i = 0; i < n; i++) {
-            source.add(i);
-        }
-        
-        AbstractOnSubscribe<Integer, Iterator<Integer>> aos = new AbstractOnSubscribe<Integer, Iterator<Integer>>() {
-            @Override
-            protected Iterator<Integer> onSubscribe(
-                    Subscriber<? super Integer> subscriber) {
-                return source.iterator();
-            }
-            @Override
-            protected void next(SubscriptionState<Integer, Iterator<Integer>> state) {
-                Iterator<Integer> it = state.state();
-                if (it.hasNext()) {
-                    state.onNext(it.next());
-                }
-                if (!it.hasNext()) {
-                    state.onCompleted();
-                }
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        InOrder inOrder = inOrder(o);
-        
-        aos.toObservable().subscribe(o);
-        
-        verify(o, never()).onError(any(TestException.class));
-        for (int i = 0; i < n; i++) {
-            inOrder.verify(o).onNext(i);
-        }
-        inOrder.verify(o).onCompleted();
-        inOrder.verifyNoMoreInteractions();
-    }
-    
-    @Test
-    public void testPhased() {
-        final int count = 100;
-        AbstractOnSubscribe<String, Void> aos = new AbstractOnSubscribe<String, Void>() {
-            @Override
-            protected void next(SubscriptionState<String, Void> state) {
-                long c = state.calls();
-                switch (state.phase()) {
-                case 0:
-                    if (c < count) {
-                        state.onNext("Beginning");
-                        if (c == count - 1) {
-                            state.advancePhase();
-                        }
-                    }
-                    break;
-                case 1:
-                    state.onNext("Beginning");
-                    state.advancePhase();
-                    break;
-                case 2:
-                    state.onNext("Finally");
-                    state.onCompleted();
-                    state.advancePhase();
-                    break;
-                default:
-                    throw new IllegalStateException("Wrong phase: " + state.phase());
-                }
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        InOrder inOrder = inOrder(o);
-        
-        aos.toObservable().subscribe(o);
-        
-        verify(o, never()).onError(any(Throwable.class));
-        inOrder.verify(o, times(count + 1)).onNext("Beginning");
-        inOrder.verify(o).onNext("Finally");
-        inOrder.verify(o).onCompleted();
-        inOrder.verifyNoMoreInteractions();
-    }
-    @Test
-    public void testPhasedRetry() {
-        final int count = 100;
-        AbstractOnSubscribe<String, Void> aos = new AbstractOnSubscribe<String, Void>() {
-            int calls;
-            int phase;
-            @Override
-            protected void next(SubscriptionState<String, Void> state) {
-                switch (phase) {
-                case 0:
-                    if (calls++ < count) {
-                        state.onNext("Beginning");
-                        state.onError(new TestException());
-                    } else {
-                        phase++;
-                    }
-                    break;
-                case 1:
-                    state.onNext("Beginning");
-                    phase++;
-                    break;
-                case 2:
-                    state.onNext("Finally");
-                    state.onCompleted();
-                    phase++;
-                    break;
-                default:
-                    throw new IllegalStateException("Wrong phase: " + state.phase());
-                }
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        InOrder inOrder = inOrder(o);
-        
-        aos.toObservable().retry(2 * count).subscribe(o);
-        
-        verify(o, never()).onError(any(Throwable.class));
-        inOrder.verify(o, times(count + 1)).onNext("Beginning");
-        inOrder.verify(o).onNext("Finally");
-        inOrder.verify(o).onCompleted();
-        inOrder.verifyNoMoreInteractions();
-    }
-    @Test
-    public void testInfiniteTake() {
-        int count = 100;
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                state.onNext((int)state.calls());
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        InOrder inOrder = inOrder(o);
-        
-        aos.toObservable().take(count).subscribe(o);
-        
-        verify(o, never()).onError(any(Throwable.class));
-        for (int i = 0; i < 100; i++) {
-            inOrder.verify(o).onNext(i);
-        }
-        inOrder.verify(o).onCompleted();
-        inOrder.verifyNoMoreInteractions();
-    }
-    @Test
-    public void testInfiniteRequestSome() {
-        int count = 100;
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                state.onNext((int)state.calls());
-            }
-        };
-        
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        InOrder inOrder = inOrder(o);
-        
-        TestSubscriber<Object> ts = new TestSubscriber<Object>(o) {
-            @Override
-            public void onStart() {
-                requestMore(0); // don't start right away
-            }
-        };
-        
-        aos.toObservable().subscribe(ts);
-        
-        ts.requestMore(count);
-        
-        verify(o, never()).onError(any(Throwable.class));
-        verify(o, never()).onCompleted();
-        for (int i = 0; i < count; i++) {
-            inOrder.verify(o).onNext(i);
-        }
-        inOrder.verifyNoMoreInteractions();
-    }
-    @Test
-    public void testIndependentStates() {
-        int count = 100;
-        final ConcurrentHashMap<Object, Object> states = new ConcurrentHashMap<Object, Object>();
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                states.put(state, state);
-                state.stop();
-            }
-        };
-        Observable<Integer> source = aos.toObservable();
-        for (int i = 0; i < count; i++) {
-            source.subscribe();
-        }
-        
-        assertEquals(count, states.size());
-    }
-    @Test(timeout = 3000)
-    public void testSubscribeOn() {
-        final int start = 1;
-        final int count = 100;
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                long calls = state.calls();
-                if (calls <= count) {
-                    state.onNext((int)calls + start);
-                    if (calls == count) {
-                        state.onCompleted();
-                    }
-                }
-            }
-        };
-
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-        InOrder inOrder = inOrder(o);
-
-        TestSubscriber<Object> ts = new TestSubscriber<Object>(o);
-
-        aos.toObservable().subscribeOn(Schedulers.newThread()).subscribe(ts);
-        
-        ts.awaitTerminalEvent();
-        
-        verify(o, never()).onError(any(Throwable.class));
-        for (int i = 1; i <= count; i++) {
-            inOrder.verify(o).onNext(i);
-        }
-        inOrder.verify(o).onCompleted();
-        inOrder.verifyNoMoreInteractions();
-
-    }
-    @Test(timeout = 10000)
-    public void testObserveOn() {
-        final int start = 1;
-        final int count = 1000;
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                long calls = state.calls();
-                if (calls <= count) {
-                    state.onNext((int)calls + start);
-                    if (calls == count) {
-                        state.onCompleted();
-                    }
-                }
-            }
-        };
-
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-
-        TestSubscriber<Object> ts = new TestSubscriber<Object>(o);
-
-        aos.toObservable().observeOn(Schedulers.newThread()).subscribe(ts);
-        
-        ts.awaitTerminalEvent();
-        
-        verify(o, never()).onError(any(Throwable.class));
-        verify(o, times(count + 1)).onNext(any(Integer.class));
-        verify(o).onCompleted();
-        
-        for (int i = 0; i < ts.getOnNextEvents().size(); i++) {
-            Object object = ts.getOnNextEvents().get(i);
-            assertEquals(i + 1, object);
-        }
-    }
-    @Test
-    public void testMissingEmission() {
-        @SuppressWarnings("unchecked")
-        Observer<Object> o = mock(Observer.class);
-
-        Action1<SubscriptionState<Object, Void>> empty = Actions.empty();
-        AbstractOnSubscribe.create(empty).toObservable().subscribe(o);
-        
-        verify(o, never()).onCompleted();
-        verify(o, never()).onNext(any(Object.class));
-        verify(o).onError(any(IllegalStateException.class));
-    }
-    
-    @Test
-    public void testCanRequestInOnNext() {
-        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
-            @Override
-            protected void next(SubscriptionState<Integer, Void> state) {
-                state.onNext(1);
-                state.onCompleted();
-            }
-        };
-        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
-        aos.toObservable().subscribe(new Subscriber<Integer>() {
-
-            @Override
-            public void onCompleted() {
-
-            }
-
-            @Override
-            public void onError(Throwable e) {
-                exception.set(e);
-            }
-
-            @Override
-            public void onNext(Integer t) {
-                request(1);
-            }
-        });
-        if (exception.get()!=null) {
-            exception.get().printStackTrace();
-        }
-        assertNull(exception.get());
-    }
-}
diff --git a/src/test/java/rx/observables/SyncOnSubscribeTest.java b/src/test/java/rx/observables/SyncOnSubscribeTest.java
index 22e1f11cfd..82cfc0b033 100644
--- a/src/test/java/rx/observables/SyncOnSubscribeTest.java
+++ b/src/test/java/rx/observables/SyncOnSubscribeTest.java
@@ -16,57 +16,25 @@
 
 package rx.observables;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.isA;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.BrokenBarrierException;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.CyclicBarrier;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
+import static org.junit.Assert.*;
+import static org.mockito.Matchers.*;
+import static org.mockito.Mockito.*;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.*;
 
 import org.junit.Test;
-import org.mockito.InOrder;
-import org.mockito.Matchers;
-import org.mockito.Mockito;
+import org.mockito.*;
 
+import rx.*;
 import rx.Observable;
-import rx.Observable.OnSubscribe;
-import rx.Observable.Operator;
+import rx.Observable.*;
 import rx.Observer;
-import rx.Producer;
-import rx.Subscriber;
 import rx.exceptions.TestException;
-import rx.functions.Action0;
-import rx.functions.Action1;
-import rx.functions.Action2;
-import rx.functions.Func0;
-import rx.functions.Func2;
+import rx.functions.*;
 import rx.observers.TestSubscriber;
-import rx.schedulers.Schedulers;
-import rx.schedulers.TestScheduler;
+import rx.schedulers.*;
 
 /**
  * Test if SyncOnSubscribe adheres to the usual unsubscription and backpressure contracts.
@@ -489,6 +457,16 @@ public Integer call(Integer state, Observer<? super Integer> observer) {
         verify(onUnSubscribe, times(1)).call(any(Integer.class));
     }
 
+    @Test
+    public void testConcurrentRequestsLoop() throws InterruptedException {
+        for (int i = 0; i < 100; i++) {
+            if (i % 10 == 0) {
+                System.out.println("testConcurrentRequestsLoop >> " + i);
+            }
+            testConcurrentRequests();
+        }
+    }
+    
     @Test
     public void testConcurrentRequests() throws InterruptedException {
         final int count1 = 1000;
@@ -498,8 +476,14 @@ public void testConcurrentRequests() throws InterruptedException {
         final CountDownLatch l1 = new CountDownLatch(1);
         final CountDownLatch l2 = new CountDownLatch(1);
         
-        @SuppressWarnings("unchecked")
-        Action1<? super Integer> onUnSubscribe = mock(Action1.class);
+        final CountDownLatch l3 = new CountDownLatch(1);
+
+        final Action1<Object> onUnSubscribe = new Action1<Object>() {
+            @Override
+            public void call(Object t) {
+                l3.countDown();
+            }
+        };
         
         OnSubscribe<Integer> os = SyncOnSubscribe.createStateful(
                 new Func0<Integer>() {
@@ -514,12 +498,20 @@ public Integer call(Integer state, Observer<? super Integer> observer) {
                         l2.countDown();
                         // wait until the 2nd request returns then proceed
                         try {
-                            if (!l1.await(1, TimeUnit.SECONDS))
-                                throw new IllegalStateException();
-                        } catch (InterruptedException e) {}
+                            if (!l1.await(2, TimeUnit.SECONDS)) {
+                                observer.onError(new TimeoutException());
+                                return state + 1;
+                            }
+                        } catch (InterruptedException e) {
+                            observer.onError(e);
+                            return state + 1;
+                        }
                         observer.onNext(state);
-                        if (state == finalCount)
+                        
+                        if (state == finalCount) {
                             observer.onCompleted();
+                        }
+                        
                         return state + 1;
                     }},
                 onUnSubscribe);
@@ -532,10 +524,9 @@ public Integer call(Integer state, Observer<? super Integer> observer) {
         Observable.create(os).subscribeOn(Schedulers.newThread()).subscribe(ts);
 
         // wait until the first request has started processing
-        try {
-            if (!l2.await(1, TimeUnit.SECONDS))
-                throw new IllegalStateException();
-        } catch (InterruptedException e) {}
+        if (!l2.await(2, TimeUnit.SECONDS)) {
+            fail("SyncOnSubscribe failed to countDown in time");
+        }
         // make a concurrent request, this should return
         ts.requestMore(count2);
         // unblock the 1st thread to proceed fulfilling requests
@@ -547,7 +538,10 @@ public Integer call(Integer state, Observer<? super Integer> observer) {
         inOrder.verify(o, times(finalCount)).onNext(any());
         inOrder.verify(o, times(1)).onCompleted();
         inOrder.verifyNoMoreInteractions();
-        verify(onUnSubscribe, times(1)).call(any(Integer.class));
+        
+        if (!l3.await(2, TimeUnit.SECONDS)) {
+            fail("SyncOnSubscribe failed to countDown onUnSubscribe latch");
+        }
     }
 
     @Test
diff --git a/src/test/java/rx/plugins/RxJavaPluginsTest.java b/src/test/java/rx/plugins/RxJavaPluginsTest.java
index 3d18923915..e4cd9f69ae 100644
--- a/src/test/java/rx/plugins/RxJavaPluginsTest.java
+++ b/src/test/java/rx/plugins/RxJavaPluginsTest.java
@@ -15,21 +15,12 @@
  */
 package rx.plugins;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import java.util.Calendar;
-import java.util.Collections;
-import java.util.Date;
+import static org.junit.Assert.*;
+
+import java.util.*;
 import java.util.concurrent.TimeUnit;
 
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
+import org.junit.*;
 
 import rx.Observable;
 import rx.Subscriber;
@@ -251,4 +242,33 @@ private static String getFullClassNameForTestClass(Class<?> cls) {
         return RxJavaPlugins.class.getPackage()
                                   .getName() + "." + RxJavaPluginsTest.class.getSimpleName() + "$" + cls.getSimpleName();
     }
+    
+    @Test
+    public void testShortPluginDiscovery() {
+        Properties props = new Properties();
+        
+        props.setProperty("rxjava.plugin.1.class", "Map");
+        props.setProperty("rxjava.plugin.1.impl", "java.util.HashMap");
+
+        props.setProperty("rxjava.plugin.xyz.class", "List");
+        props.setProperty("rxjava.plugin.xyz.impl", "java.util.ArrayList");
+
+        
+        Object o = RxJavaPlugins.getPluginImplementationViaProperty(Map.class, props);
+        
+        assertTrue("" + o, o instanceof HashMap);
+        
+        o = RxJavaPlugins.getPluginImplementationViaProperty(List.class, props);
+        
+        assertTrue("" + o, o instanceof ArrayList);
+    }
+    
+    @Test(expected = RuntimeException.class)
+    public void testShortPluginDiscoveryMissing() {
+        Properties props = new Properties();
+        
+        props.setProperty("rxjava.plugin.1.class", "Map");
+
+        RxJavaPlugins.getPluginImplementationViaProperty(Map.class, props);
+    }
 }
diff --git a/src/test/java/rx/singles/BlockingSingleTest.java b/src/test/java/rx/singles/BlockingSingleTest.java
new file mode 100644
index 0000000000..48c5b7eb03
--- /dev/null
+++ b/src/test/java/rx/singles/BlockingSingleTest.java
@@ -0,0 +1,80 @@
+/**
+ * Copyright 2015 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package rx.singles;
+
+import static org.junit.Assert.*;
+
+import java.util.concurrent.Future;
+
+import org.junit.Test;
+
+import rx.Single;
+import rx.exceptions.TestException;
+
+/**
+ * Test suite for {@link BlockingSingle}.
+ */
+public class BlockingSingleTest {
+
+    @Test
+    public void testSingleGet() {
+        Single<String> single = Single.just("one");
+        BlockingSingle<? extends String> blockingSingle = BlockingSingle.from(single);
+        assertEquals("one", blockingSingle.value());
+    }
+
+    @Test
+    public void testSingleError() {
+        TestException expected = new TestException();
+        Single<String> single = Single.error(expected);
+        BlockingSingle<? extends String> blockingSingle = BlockingSingle.from(single);
+
+        try {
+            blockingSingle.value();
+            fail("Expecting an exception to be thrown");
+        } catch (Exception caughtException) {
+            assertSame(expected, caughtException);
+        }
+    }
+
+    @Test
+    public void testSingleErrorChecked() {
+        TestCheckedException expected = new TestCheckedException();
+        Single<String> single = Single.error(expected);
+        BlockingSingle<? extends String> blockingSingle = BlockingSingle.from(single);
+
+        try {
+            blockingSingle.value();
+            fail("Expecting an exception to be thrown");
+        } catch (Exception caughtException) {
+            assertNotNull(caughtException.getCause());
+            assertSame(expected, caughtException.getCause() );
+        }
+    }
+
+    @Test
+    public void testSingleToFuture() throws Exception {
+        Single<String> single = Single.just("one");
+        BlockingSingle<? extends String> blockingSingle = BlockingSingle.from(single);
+        Future<? extends String> future = blockingSingle.toFuture();
+        String result = future.get();
+        assertEquals("one", result);
+    }
+
+    private static final class TestCheckedException extends Exception {
+    }
+}
diff --git a/src/test/java/rx/subjects/AsyncSubjectTest.java b/src/test/java/rx/subjects/AsyncSubjectTest.java
index 623cdceb3f..968e71f571 100644
--- a/src/test/java/rx/subjects/AsyncSubjectTest.java
+++ b/src/test/java/rx/subjects/AsyncSubjectTest.java
@@ -15,11 +15,7 @@
  */
 package rx.subjects;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import static org.junit.Assert.*;
 import static org.mockito.Matchers.any;
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Mockito.inOrder;
@@ -395,4 +391,43 @@ public void testCurrentStateMethodsError() {
         assertNull(as.getValue());
         assertTrue(as.getThrowable() instanceof TestException);
     }
+    
+    @Test
+    public void testAsyncSubjectValueRelay() {
+        AsyncSubject<Integer> async = AsyncSubject.create();
+        async.onNext(1);
+        async.onCompleted();
+        
+        assertFalse(async.hasObservers());
+        assertTrue(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertEquals((Integer)1, async.getValue());
+        assertTrue(async.hasValue());
+    }
+    @Test
+    public void testAsyncSubjectValueEmpty() {
+        AsyncSubject<Integer> async = AsyncSubject.create();
+        async.onCompleted();
+        
+        assertFalse(async.hasObservers());
+        assertTrue(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+    }
+    @Test
+    public void testAsyncSubjectValueError() {
+        AsyncSubject<Integer> async = AsyncSubject.create();
+        TestException te = new TestException();
+        async.onError(te);
+        
+        assertFalse(async.hasObservers());
+        assertFalse(async.hasCompleted());
+        assertTrue(async.hasThrowable());
+        assertSame(te, async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+    }
 }
diff --git a/src/test/java/rx/subjects/BehaviorSubjectTest.java b/src/test/java/rx/subjects/BehaviorSubjectTest.java
index 9e9e4c90e7..bc71fd212a 100644
--- a/src/test/java/rx/subjects/BehaviorSubjectTest.java
+++ b/src/test/java/rx/subjects/BehaviorSubjectTest.java
@@ -15,17 +15,14 @@
  */
 package rx.subjects;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import static org.junit.Assert.*;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicReference;
@@ -61,8 +58,7 @@ public void testThatObserverReceivesDefaultValueAndSubsequentEvents() {
         verify(observer, times(1)).onNext("one");
         verify(observer, times(1)).onNext("two");
         verify(observer, times(1)).onNext("three");
-        verify(observer, never()).onError(testException);
-        verify(observer, never()).onCompleted();
+        verifyNoMoreInteractions(observer);
     }
 
     @Test
@@ -78,12 +74,10 @@ public void testThatObserverReceivesLatestAndThenSubsequentEvents() {
         subject.onNext("two");
         subject.onNext("three");
 
-        verify(observer, never()).onNext("default");
         verify(observer, times(1)).onNext("one");
         verify(observer, times(1)).onNext("two");
         verify(observer, times(1)).onNext("three");
-        verify(observer, never()).onError(testException);
-        verify(observer, never()).onCompleted();
+        verifyNoMoreInteractions(observer);
     }
 
     @Test
@@ -99,8 +93,8 @@ public void testSubscribeThenOnComplete() {
 
         verify(observer, times(1)).onNext("default");
         verify(observer, times(1)).onNext("one");
-        verify(observer, never()).onError(any(Throwable.class));
         verify(observer, times(1)).onCompleted();
+        verifyNoMoreInteractions(observer);
     }
 
     @Test
@@ -113,10 +107,8 @@ public void testSubscribeToCompletedOnlyEmitsOnComplete() {
         Observer<String> observer = mock(Observer.class);
         subject.subscribe(observer);
 
-        verify(observer, never()).onNext("default");
-        verify(observer, never()).onNext("one");
-        verify(observer, never()).onError(any(Throwable.class));
         verify(observer, times(1)).onCompleted();
+        verifyNoMoreInteractions(observer);
     }
 
     @Test
@@ -130,10 +122,8 @@ public void testSubscribeToErrorOnlyEmitsOnError() {
         Observer<String> observer = mock(Observer.class);
         subject.subscribe(observer);
 
-        verify(observer, never()).onNext("default");
-        verify(observer, never()).onNext("one");
         verify(observer, times(1)).onError(re);
-        verify(observer, never()).onCompleted();
+        verifyNoMoreInteractions(observer);
     }
 
     @Test
@@ -198,8 +188,7 @@ public void testCompletedAfterErrorIsNotSent() {
         verify(observer, times(1)).onNext("default");
         verify(observer, times(1)).onNext("one");
         verify(observer, times(1)).onError(testException);
-        verify(observer, never()).onNext("two");
-        verify(observer, never()).onCompleted();
+        verifyNoMoreInteractions(observer);
     }
 
     @Test
@@ -218,15 +207,13 @@ public void testCompletedAfterErrorIsNotSent2() {
         verify(observer, times(1)).onNext("default");
         verify(observer, times(1)).onNext("one");
         verify(observer, times(1)).onError(testException);
-        verify(observer, never()).onNext("two");
-        verify(observer, never()).onCompleted();
+        verifyNoMoreInteractions(observer);
 
         @SuppressWarnings("unchecked")
         Observer<Object> o2 = mock(Observer.class);
         subject.subscribe(o2);
         verify(o2, times(1)).onError(testException);
-        verify(o2, never()).onNext(any());
-        verify(o2, never()).onCompleted();
+        verifyNoMoreInteractions(o2);
     }
 
     @Test
@@ -245,15 +232,13 @@ public void testCompletedAfterErrorIsNotSent3() {
         verify(observer, times(1)).onNext("default");
         verify(observer, times(1)).onNext("one");
         verify(observer, times(1)).onCompleted();
-        verify(observer, never()).onError(any(Throwable.class));
-        verify(observer, never()).onNext("two");
+        verifyNoMoreInteractions(observer);
 
         @SuppressWarnings("unchecked")
         Observer<Object> o2 = mock(Observer.class);
         subject.subscribe(o2);
         verify(o2, times(1)).onCompleted();
-        verify(o2, never()).onNext(any());
-        verify(o2, never()).onError(any(Throwable.class));
+        verifyNoMoreInteractions(o2);
     }
     @Test(timeout = 1000)
     public void testUnsubscriptionCase() {
@@ -344,8 +329,7 @@ public void testStartEmptyCompleteWithOne() {
         source.subscribe(o);
 
         verify(o).onCompleted();
-        verify(o, never()).onError(any(Throwable.class));
-        verify(o, never()).onNext(any());
+        verifyNoMoreInteractions(o);
     }
     
     @Test
@@ -358,8 +342,8 @@ public void testTakeOneSubscriber() {
         
         verify(o).onNext(1);
         verify(o).onCompleted();
-        verify(o, never()).onError(any(Throwable.class));
-        
+        verifyNoMoreInteractions(o);
+
         assertEquals(0, source.subscriberCount());
         assertFalse(source.hasObservers());
     }
@@ -569,4 +553,86 @@ public void testCurrentStateMethodsError() {
         assertNull(as.getValue());
         assertTrue(as.getThrowable() instanceof TestException);
     }
+    
+    @Test
+    public void testBehaviorSubjectValueRelay() {
+        BehaviorSubject<Integer> async = BehaviorSubject.create();
+        async.onNext(1);
+        async.onCompleted();
+        
+        assertFalse(async.hasObservers());
+        assertTrue(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+        assertArrayEquals(new Object[] { }, async.getValues());
+        assertArrayEquals(new Integer[] { }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testBehaviorSubjectValueRelayIncomplete() {
+        BehaviorSubject<Integer> async = BehaviorSubject.create();
+        async.onNext(1);
+        
+        assertFalse(async.hasObservers());
+        assertFalse(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertEquals((Integer)1, async.getValue());
+        assertTrue(async.hasValue());
+        assertArrayEquals(new Object[] { 1 }, async.getValues());
+        assertArrayEquals(new Integer[] { 1 }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { 1 }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { 1, null }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testBehaviorSubjectIncompleteEmpty() {
+        BehaviorSubject<Integer> async = BehaviorSubject.create();
+        
+        assertFalse(async.hasObservers());
+        assertFalse(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+        assertArrayEquals(new Object[] { }, async.getValues());
+        assertArrayEquals(new Integer[] { }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testBehaviorSubjectEmpty() {
+        BehaviorSubject<Integer> async = BehaviorSubject.create();
+        async.onCompleted();
+        
+        assertFalse(async.hasObservers());
+        assertTrue(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+        assertArrayEquals(new Object[] { }, async.getValues());
+        assertArrayEquals(new Integer[] { }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testBehaviorSubjectError() {
+        BehaviorSubject<Integer> async = BehaviorSubject.create();
+        TestException te = new TestException();
+        async.onError(te);
+        
+        assertFalse(async.hasObservers());
+        assertFalse(async.hasCompleted());
+        assertTrue(async.hasThrowable());
+        assertSame(te, async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+        assertArrayEquals(new Object[] { }, async.getValues());
+        assertArrayEquals(new Integer[] { }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, async.getValues(new Integer[] { 0, 0 }));
+    }
 }
diff --git a/src/test/java/rx/subjects/PublishSubjectTest.java b/src/test/java/rx/subjects/PublishSubjectTest.java
index 44fe824a5c..93c9be4bd3 100644
--- a/src/test/java/rx/subjects/PublishSubjectTest.java
+++ b/src/test/java/rx/subjects/PublishSubjectTest.java
@@ -15,17 +15,14 @@
  */
 package rx.subjects;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import static org.junit.Assert.*;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
 
 import java.util.ArrayList;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -67,7 +64,7 @@ public void testCompleted() {
         subject.onError(new Throwable());
 
         assertCompletedObserver(observer);
-        // todo bug?            assertNeverObserver(anotherObserver);
+        assertNeverObserver(anotherObserver);
     }
 
     @Test
@@ -117,8 +114,20 @@ private void assertCompletedObserver(Observer<String> observer) {
         verify(observer, times(1)).onNext("one");
         verify(observer, times(1)).onNext("two");
         verify(observer, times(1)).onNext("three");
+        verify(observer, never()).onNext("four");
         verify(observer, never()).onError(any(Throwable.class));
         verify(observer, times(1)).onCompleted();
+        verifyNoMoreInteractions(observer);
+    }
+
+    private void assertNeverObserver(Observer<String> observer) {
+        verify(observer, never()).onNext("one");
+        verify(observer, never()).onNext("two");
+        verify(observer, never()).onNext("three");
+        verify(observer, never()).onNext("four");
+        verify(observer, never()).onError(any(Throwable.class));
+        verify(observer, times(1)).onCompleted();
+        verifyNoMoreInteractions(observer);
     }
 
     @Test
@@ -143,7 +152,7 @@ public void testError() {
         subject.onCompleted();
 
         assertErrorObserver(observer);
-        // todo bug?            assertNeverObserver(anotherObserver);
+        assertNeverErrorObserver(anotherObserver);
     }
 
     private void assertErrorObserver(Observer<String> observer) {
@@ -152,6 +161,17 @@ private void assertErrorObserver(Observer<String> observer) {
         verify(observer, times(1)).onNext("three");
         verify(observer, times(1)).onError(testException);
         verify(observer, never()).onCompleted();
+        verifyNoMoreInteractions(observer);
+    }
+
+    private void assertNeverErrorObserver(Observer<String> observer) {
+        verify(observer, never()).onNext("one");
+        verify(observer, never()).onNext("two");
+        verify(observer, never()).onNext("three");
+        verify(observer, never()).onNext("four");
+        verify(observer, times(1)).onError(any(Throwable.class));
+        verify(observer, never()).onCompleted();
+        verifyNoMoreInteractions(observer);
     }
 
     @Test
@@ -447,4 +467,38 @@ public void testCurrentStateMethodsError() {
         assertFalse(as.hasCompleted());
         assertTrue(as.getThrowable() instanceof TestException);
     }
+    
+    @Test
+    public void testPublishSubjectValueRelay() {
+        PublishSubject<Integer> async = PublishSubject.create();
+        async.onNext(1);
+        async.onCompleted();
+        
+        assertFalse(async.hasObservers());
+        assertTrue(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+    }
+    
+    @Test
+    public void testPublishSubjectValueEmpty() {
+        PublishSubject<Integer> async = PublishSubject.create();
+        async.onCompleted();
+        
+        assertFalse(async.hasObservers());
+        assertTrue(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+    }
+    @Test
+    public void testPublishSubjectValueError() {
+        PublishSubject<Integer> async = PublishSubject.create();
+        TestException te = new TestException();
+        async.onError(te);
+        
+        assertFalse(async.hasObservers());
+        assertFalse(async.hasCompleted());
+        assertTrue(async.hasThrowable());
+        assertSame(te, async.getThrowable());
+    }
 }
diff --git a/src/test/java/rx/subjects/ReplaySubjectTest.java b/src/test/java/rx/subjects/ReplaySubjectTest.java
index 5ebb871604..cd04fc02cc 100644
--- a/src/test/java/rx/subjects/ReplaySubjectTest.java
+++ b/src/test/java/rx/subjects/ReplaySubjectTest.java
@@ -15,12 +15,7 @@
  */
 package rx.subjects;
 
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import static org.junit.Assert.*;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
@@ -887,4 +882,171 @@ public void testGetValuesUnbounded() {
         assertArrayEquals(expected, rs.getValues());
         
     }
+    
+    @Test
+    public void testReplaySubjectValueRelay() {
+        ReplaySubject<Integer> async = ReplaySubject.create();
+        async.onNext(1);
+        async.onCompleted();
+        
+        assertFalse(async.hasObservers());
+        assertTrue(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertEquals((Integer)1, async.getValue());
+        assertTrue(async.hasValue());
+        assertArrayEquals(new Object[] { 1 }, async.getValues());
+        assertArrayEquals(new Integer[] { 1 }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { 1 }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { 1, null }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectValueRelayIncomplete() {
+        ReplaySubject<Integer> async = ReplaySubject.create();
+        async.onNext(1);
+        
+        assertFalse(async.hasObservers());
+        assertFalse(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertEquals((Integer)1, async.getValue());
+        assertTrue(async.hasValue());
+        assertArrayEquals(new Object[] { 1 }, async.getValues());
+        assertArrayEquals(new Integer[] { 1 }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { 1 }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { 1, null }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectValueRelayBounded() {
+        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
+        async.onNext(0);
+        async.onNext(1);
+        async.onCompleted();
+        
+        assertFalse(async.hasObservers());
+        assertTrue(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertEquals((Integer)1, async.getValue());
+        assertTrue(async.hasValue());
+        assertArrayEquals(new Object[] { 1 }, async.getValues());
+        assertArrayEquals(new Integer[] { 1 }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { 1 }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { 1, null }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectValueRelayBoundedIncomplete() {
+        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
+        async.onNext(0);
+        async.onNext(1);
+        
+        assertFalse(async.hasObservers());
+        assertFalse(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertEquals((Integer)1, async.getValue());
+        assertTrue(async.hasValue());
+        assertArrayEquals(new Object[] { 1 }, async.getValues());
+        assertArrayEquals(new Integer[] { 1 }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { 1 }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { 1, null }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectValueRelayBoundedEmptyIncomplete() {
+        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
+        
+        assertFalse(async.hasObservers());
+        assertFalse(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+        assertArrayEquals(new Object[] { }, async.getValues());
+        assertArrayEquals(new Integer[] { }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectValueRelayEmptyIncomplete() {
+        ReplaySubject<Integer> async = ReplaySubject.create();
+        
+        assertFalse(async.hasObservers());
+        assertFalse(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+        assertArrayEquals(new Object[] { }, async.getValues());
+        assertArrayEquals(new Integer[] { }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    
+    @Test
+    public void testReplaySubjectEmpty() {
+        ReplaySubject<Integer> async = ReplaySubject.create();
+        async.onCompleted();
+        
+        assertFalse(async.hasObservers());
+        assertTrue(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+        assertArrayEquals(new Object[] { }, async.getValues());
+        assertArrayEquals(new Integer[] { }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectError() {
+        ReplaySubject<Integer> async = ReplaySubject.create();
+        TestException te = new TestException();
+        async.onError(te);
+        
+        assertFalse(async.hasObservers());
+        assertFalse(async.hasCompleted());
+        assertTrue(async.hasThrowable());
+        assertSame(te, async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+        assertArrayEquals(new Object[] { }, async.getValues());
+        assertArrayEquals(new Integer[] { }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    
+    @Test
+    public void testReplaySubjectBoundedEmpty() {
+        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
+        async.onCompleted();
+        
+        assertFalse(async.hasObservers());
+        assertTrue(async.hasCompleted());
+        assertFalse(async.hasThrowable());
+        assertNull(async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+        assertArrayEquals(new Object[] { }, async.getValues());
+        assertArrayEquals(new Integer[] { }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, async.getValues(new Integer[] { 0, 0 }));
+    }
+    @Test
+    public void testReplaySubjectBoundedError() {
+        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
+        TestException te = new TestException();
+        async.onError(te);
+        
+        assertFalse(async.hasObservers());
+        assertFalse(async.hasCompleted());
+        assertTrue(async.hasThrowable());
+        assertSame(te, async.getThrowable());
+        assertNull(async.getValue());
+        assertFalse(async.hasValue());
+        assertArrayEquals(new Object[] { }, async.getValues());
+        assertArrayEquals(new Integer[] { }, async.getValues(new Integer[0]));
+        assertArrayEquals(new Integer[] { null }, async.getValues(new Integer[] { 0 }));
+        assertArrayEquals(new Integer[] { null, 0 }, async.getValues(new Integer[] { 0, 0 }));
+    }
 }
diff --git a/src/test/java/rx/subjects/SerializedSubjectTest.java b/src/test/java/rx/subjects/SerializedSubjectTest.java
index 097fcd311e..b31a458ffd 100644
--- a/src/test/java/rx/subjects/SerializedSubjectTest.java
+++ b/src/test/java/rx/subjects/SerializedSubjectTest.java
@@ -15,13 +15,12 @@
  */
 package rx.subjects;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertSame;
 
 import java.util.Arrays;
 
 import org.junit.Test;
 
-import rx.exceptions.TestException;
 import rx.observers.TestSubscriber;
 
 public class SerializedSubjectTest {
@@ -37,379 +36,6 @@ public void testBasic() {
         ts.assertReceivedOnNext(Arrays.asList("hello"));
     }
     
-    @Test
-    public void testAsyncSubjectValueRelay() {
-        AsyncSubject<Integer> async = AsyncSubject.create();
-        async.onNext(1);
-        async.onCompleted();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertTrue(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertEquals((Integer)1, serial.getValue());
-        assertTrue(serial.hasValue());
-        assertArrayEquals(new Object[] { 1 }, serial.getValues());
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testAsyncSubjectValueEmpty() {
-        AsyncSubject<Integer> async = AsyncSubject.create();
-        async.onCompleted();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertTrue(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testAsyncSubjectValueError() {
-        AsyncSubject<Integer> async = AsyncSubject.create();
-        TestException te = new TestException();
-        async.onError(te);
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertFalse(serial.hasCompleted());
-        assertTrue(serial.hasThrowable());
-        assertSame(te, serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testPublishSubjectValueRelay() {
-        PublishSubject<Integer> async = PublishSubject.create();
-        async.onNext(1);
-        async.onCompleted();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertTrue(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        
-        assertArrayEquals(new Object[0], serial.getValues());
-        assertArrayEquals(new Integer[0], serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    
-    @Test
-    public void testPublishSubjectValueEmpty() {
-        PublishSubject<Integer> async = PublishSubject.create();
-        async.onCompleted();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertTrue(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testPublishSubjectValueError() {
-        PublishSubject<Integer> async = PublishSubject.create();
-        TestException te = new TestException();
-        async.onError(te);
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertFalse(serial.hasCompleted());
-        assertTrue(serial.hasThrowable());
-        assertSame(te, serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-
-    @Test
-    public void testBehaviorSubjectValueRelay() {
-        BehaviorSubject<Integer> async = BehaviorSubject.create();
-        async.onNext(1);
-        async.onCompleted();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertTrue(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testBehaviorSubjectValueRelayIncomplete() {
-        BehaviorSubject<Integer> async = BehaviorSubject.create();
-        async.onNext(1);
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertFalse(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertEquals((Integer)1, serial.getValue());
-        assertTrue(serial.hasValue());
-        assertArrayEquals(new Object[] { 1 }, serial.getValues());
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testBehaviorSubjectIncompleteEmpty() {
-        BehaviorSubject<Integer> async = BehaviorSubject.create();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertFalse(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testBehaviorSubjectEmpty() {
-        BehaviorSubject<Integer> async = BehaviorSubject.create();
-        async.onCompleted();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertTrue(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testBehaviorSubjectError() {
-        BehaviorSubject<Integer> async = BehaviorSubject.create();
-        TestException te = new TestException();
-        async.onError(te);
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertFalse(serial.hasCompleted());
-        assertTrue(serial.hasThrowable());
-        assertSame(te, serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    
-    @Test
-    public void testReplaySubjectValueRelay() {
-        ReplaySubject<Integer> async = ReplaySubject.create();
-        async.onNext(1);
-        async.onCompleted();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertTrue(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertEquals((Integer)1, serial.getValue());
-        assertTrue(serial.hasValue());
-        assertArrayEquals(new Object[] { 1 }, serial.getValues());
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testReplaySubjectValueRelayIncomplete() {
-        ReplaySubject<Integer> async = ReplaySubject.create();
-        async.onNext(1);
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertFalse(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertEquals((Integer)1, serial.getValue());
-        assertTrue(serial.hasValue());
-        assertArrayEquals(new Object[] { 1 }, serial.getValues());
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testReplaySubjectValueRelayBounded() {
-        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
-        async.onNext(0);
-        async.onNext(1);
-        async.onCompleted();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertTrue(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertEquals((Integer)1, serial.getValue());
-        assertTrue(serial.hasValue());
-        assertArrayEquals(new Object[] { 1 }, serial.getValues());
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testReplaySubjectValueRelayBoundedIncomplete() {
-        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
-        async.onNext(0);
-        async.onNext(1);
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertFalse(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertEquals((Integer)1, serial.getValue());
-        assertTrue(serial.hasValue());
-        assertArrayEquals(new Object[] { 1 }, serial.getValues());
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { 1 }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { 1, null }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testReplaySubjectValueRelayBoundedEmptyIncomplete() {
-        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertFalse(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testReplaySubjectValueRelayEmptyIncomplete() {
-        ReplaySubject<Integer> async = ReplaySubject.create();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertFalse(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    
-    @Test
-    public void testReplaySubjectEmpty() {
-        ReplaySubject<Integer> async = ReplaySubject.create();
-        async.onCompleted();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertTrue(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testReplaySubjectError() {
-        ReplaySubject<Integer> async = ReplaySubject.create();
-        TestException te = new TestException();
-        async.onError(te);
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertFalse(serial.hasCompleted());
-        assertTrue(serial.hasThrowable());
-        assertSame(te, serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    
-    @Test
-    public void testReplaySubjectBoundedEmpty() {
-        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
-        async.onCompleted();
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertTrue(serial.hasCompleted());
-        assertFalse(serial.hasThrowable());
-        assertNull(serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    @Test
-    public void testReplaySubjectBoundedError() {
-        ReplaySubject<Integer> async = ReplaySubject.createWithSize(1);
-        TestException te = new TestException();
-        async.onError(te);
-        Subject<Integer, Integer> serial = async.toSerialized();
-        
-        assertFalse(serial.hasObservers());
-        assertFalse(serial.hasCompleted());
-        assertTrue(serial.hasThrowable());
-        assertSame(te, serial.getThrowable());
-        assertNull(serial.getValue());
-        assertFalse(serial.hasValue());
-        assertArrayEquals(new Object[] { }, serial.getValues());
-        assertArrayEquals(new Integer[] { }, serial.getValues(new Integer[0]));
-        assertArrayEquals(new Integer[] { null }, serial.getValues(new Integer[] { 0 }));
-        assertArrayEquals(new Integer[] { null, 0 }, serial.getValues(new Integer[] { 0, 0 }));
-    }
-    
     @Test
     public void testDontWrapSerializedSubjectAgain() {
         PublishSubject<Object> s = PublishSubject.create();
