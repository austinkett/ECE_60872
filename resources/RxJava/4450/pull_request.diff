diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java
index 9a53721e4a..fe71698b8c 100644
--- a/src/main/java/io/reactivex/Flowable.java
+++ b/src/main/java/io/reactivex/Flowable.java
@@ -5086,7 +5086,7 @@ public final T blockingSingle(T defaultItem) {
      * @see <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX documentation: To</a>
      */
     public final Future<T> toFuture() {
-        return FlowableToFuture.toFuture(this);
+        return subscribeWith(new FutureSubscriber<T>());
     }
     
     /**
diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java
index 793063a2e2..5fb46d4b55 100644
--- a/src/main/java/io/reactivex/Observable.java
+++ b/src/main/java/io/reactivex/Observable.java
@@ -4538,7 +4538,7 @@ public final T blockingSingle(T defaultItem) {
      * @see <a href="http://reactivex.io/documentation/operators/to.html">ReactiveX documentation: To</a>
      */
     public final Future<T> toFuture() {
-        return ObservableToFuture.toFuture(this);
+        return subscribeWith(new FutureObserver<T>());
     }
     
     /**
diff --git a/src/main/java/io/reactivex/disposables/Disposables.java b/src/main/java/io/reactivex/disposables/Disposables.java
index 4c3664370b..e2bbe95703 100644
--- a/src/main/java/io/reactivex/disposables/Disposables.java
+++ b/src/main/java/io/reactivex/disposables/Disposables.java
@@ -37,8 +37,20 @@ private Disposables() {
      * executed exactly once when the Disposable is disposed.
      * @param run the Runnable to wrap
      * @return the new Disposable instance
+     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity
      */
+    @Deprecated
     public static Disposable from(Runnable run) {
+        return fromRunnable(run);
+    }
+
+    /**
+     * Construct a Disposable by wrapping a Runnable that is
+     * executed exactly once when the Disposable is disposed.
+     * @param run the Runnable to wrap
+     * @return the new Disposable instance
+     */
+    public static Disposable fromRunnable(Runnable run) {
         ObjectHelper.requireNonNull(run, "run is null");
         return new RunnableDisposable(run);
     }
@@ -48,8 +60,20 @@ public static Disposable from(Runnable run) {
      * executed exactly once when the Disposable is disposed.
      * @param run the Action to wrap
      * @return the new Disposable instance
+     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity
      */
+    @Deprecated
     public static Disposable from(Action run) {
+        return fromAction(run);
+    }
+
+    /**
+     * Construct a Disposable by wrapping a Action that is
+     * executed exactly once when the Disposable is disposed.
+     * @param run the Action to wrap
+     * @return the new Disposable instance
+     */
+    public static Disposable fromAction(Action run) {
         ObjectHelper.requireNonNull(run, "run is null");
         return new ActionDisposable(run);
     }
@@ -59,10 +83,11 @@ public static Disposable from(Action run) {
      * cancelled exactly once when the Disposable is disposed.
      * @param future the Future to wrap
      * @return the new Disposable instance
+     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity
      */
+    @Deprecated
     public static Disposable from(Future<?> future) {
-        ObjectHelper.requireNonNull(future, "future is null");
-        return from(future, true);
+        return fromFuture(future, true);
     }
 
     /**
@@ -71,8 +96,32 @@ public static Disposable from(Future<?> future) {
      * @param future the Runnable to wrap
      * @param allowInterrupt if true, the future cancel happens via Future.cancel(true)
      * @return the new Disposable instance
+     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity
      */
+    @Deprecated
     public static Disposable from(Future<?> future, boolean allowInterrupt) {
+        return fromFuture(future, allowInterrupt);
+    }
+
+    /**
+     * Construct a Disposable by wrapping a Future that is
+     * cancelled exactly once when the Disposable is disposed.
+     * @param future the Future to wrap
+     * @return the new Disposable instance
+     */
+    public static Disposable fromFuture(Future<?> future) {
+        ObjectHelper.requireNonNull(future, "future is null");
+        return fromFuture(future, true);
+    }
+
+    /**
+     * Construct a Disposable by wrapping a Runnable that is
+     * executed exactly once when the Disposable is disposed.
+     * @param future the Runnable to wrap
+     * @param allowInterrupt if true, the future cancel happens via Future.cancel(true)
+     * @return the new Disposable instance
+     */
+    public static Disposable fromFuture(Future<?> future, boolean allowInterrupt) {
         ObjectHelper.requireNonNull(future, "future is null");
         return new FutureDisposable(future, allowInterrupt);
     }
@@ -82,8 +131,20 @@ public static Disposable from(Future<?> future, boolean allowInterrupt) {
      * cancelled exactly once when the Disposable is disposed.
      * @param subscription the Runnable to wrap
      * @return the new Disposable instance
+     * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity
      */
+    @Deprecated
     public static Disposable from(Subscription subscription) {
+        return fromSubscription(subscription);
+    }
+
+    /**
+     * Construct a Disposable by wrapping a Subscription that is
+     * cancelled exactly once when the Disposable is disposed.
+     * @param subscription the Runnable to wrap
+     * @return the new Disposable instance
+     */
+    public static Disposable fromSubscription(Subscription subscription) {
         ObjectHelper.requireNonNull(subscription, "subscription is null");
         return new SubscriptionDisposable(subscription);
     }
@@ -93,7 +154,7 @@ public static Disposable from(Subscription subscription) {
      * @return a new, non-disposed Disposable instance
      */
     public static Disposable empty() {
-        return from(Functions.EMPTY_RUNNABLE);
+        return fromRunnable(Functions.EMPTY_RUNNABLE);
     }
 
     /**
diff --git a/src/main/java/io/reactivex/internal/functions/Functions.java b/src/main/java/io/reactivex/internal/functions/Functions.java
index a6cb1e7b4f..b95574163a 100644
--- a/src/main/java/io/reactivex/internal/functions/Functions.java
+++ b/src/main/java/io/reactivex/internal/functions/Functions.java
@@ -23,8 +23,12 @@
 /**
  * Utility methods to convert the Function3..Function9 instances to Function of Object array.
  */
-public enum Functions {
-    ;
+public final class Functions {
+
+    /** Utility class. */
+    private Functions() {
+        throw new IllegalStateException("No instances!");
+    }
     
     @SuppressWarnings("unchecked")
     public static <T1, T2, R> Function<Object[], R> toFunction(final BiFunction<? super T1, ? super T2, ? extends R> biFunction) {
diff --git a/src/main/java/io/reactivex/internal/functions/ObjectHelper.java b/src/main/java/io/reactivex/internal/functions/ObjectHelper.java
index 3471c8eee9..c094e5acb8 100644
--- a/src/main/java/io/reactivex/internal/functions/ObjectHelper.java
+++ b/src/main/java/io/reactivex/internal/functions/ObjectHelper.java
@@ -18,8 +18,13 @@
  * Utility methods containing the backport of Java 7's Objects utility class.
  * <p>Named as such to avoid clash with java.util.Objects.
  */
-public enum ObjectHelper {
-    ;
+public final class ObjectHelper {
+    
+    /** Utility class. */
+    private ObjectHelper() {
+        throw new IllegalStateException("No instances!");
+    }
+    
     /**
      * Verifies if the object is not null and returns it or throws a NullPointerException
      * with the given message.
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableFromPublisher.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableFromPublisher.java
index fcefd092d9..e5b78258d1 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableFromPublisher.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableFromPublisher.java
@@ -16,7 +16,8 @@
 import org.reactivestreams.*;
 
 import io.reactivex.*;
-import io.reactivex.disposables.Disposables;
+import io.reactivex.disposables.*;
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
 
 public final class CompletableFromPublisher<T> extends Completable {
 
@@ -28,30 +29,56 @@ public CompletableFromPublisher(Publisher<T> flowable) {
 
     @Override
     protected void subscribeActual(final CompletableObserver cs) {
-        flowable.subscribe(new Subscriber<T>() {
+        flowable.subscribe(new FromPublisherSubscriber<T>(cs));
+    }
+    
+    static final class FromPublisherSubscriber<T> implements Subscriber<T>, Disposable {
 
-            @Override
-            public void onComplete() {
-                cs.onComplete();
+        final CompletableObserver cs;
+        
+        Subscription s;
+        
+        public FromPublisherSubscriber(CompletableObserver actual) {
+            this.cs = actual;
+        }
+        
+        @Override
+        public void onSubscribe(Subscription s) {
+            if (SubscriptionHelper.validate(this.s, s)) {
+                this.s = s;
+                
+                cs.onSubscribe(this);
+                
+                s.request(Long.MAX_VALUE);
             }
+        }
 
-            @Override
-            public void onError(Throwable t) {
-                cs.onError(t);
-            }
 
-            @Override
-            public void onNext(T t) {
-                // ignored
-            }
+        @Override
+        public void onNext(T t) {
+            // ignored
+        }
 
-            @Override
-            public void onSubscribe(Subscription s) {
-                cs.onSubscribe(Disposables.from(s));
-                s.request(Long.MAX_VALUE);
-            }
-            
-        });
+        @Override
+        public void onError(Throwable t) {
+            cs.onError(t);
+        }
+
+        @Override
+        public void onComplete() {
+            cs.onComplete();
+        }
+
+        @Override
+        public void dispose() {
+            s.cancel();
+            s = SubscriptionHelper.CANCELLED;
+        }
+        
+        @Override
+        public boolean isDisposed() {
+            return s == SubscriptionHelper.CANCELLED;
+        }
     }
 
 }
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableMerge.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableMerge.java
index 63bc4906f0..7a25a89c27 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableMerge.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableMerge.java
@@ -19,10 +19,8 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.*;
-import io.reactivex.exceptions.*;
-import io.reactivex.internal.fuseable.SimpleQueue;
-import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
+import io.reactivex.internal.util.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class CompletableMerge extends Completable {
@@ -49,23 +47,27 @@ public void subscribeActual(CompletableObserver s) {
         private static final long serialVersionUID = -2108443387387077490L;
         
         final CompletableObserver actual;
-        final CompositeDisposable set;
         final int maxConcurrency;
         final boolean delayErrors;
+
+        final AtomicThrowable error;
         
+        final AtomicBoolean once;
+
+        final CompositeDisposable set;
+
         Subscription s;
         
         volatile boolean done;
-        
-        final AtomicReference<SimpleQueue<Throwable>> errors = new AtomicReference<SimpleQueue<Throwable>>();
-        
-        final AtomicBoolean once = new AtomicBoolean();
+
         
         public CompletableMergeSubscriber(CompletableObserver actual, int maxConcurrency, boolean delayErrors) {
             this.actual = actual;
             this.maxConcurrency = maxConcurrency;
             this.delayErrors = delayErrors;
             this.set = new CompositeDisposable();
+            this.error = new AtomicThrowable();
+            this.once = new AtomicBoolean();
             lazySet(1);
         }
         
@@ -84,7 +86,6 @@ public boolean isDisposed() {
         public void onSubscribe(Subscription s) {
             if (SubscriptionHelper.validate(this.s, s)) {
                 this.s = s;
-                set.add(Disposables.from(s));
                 actual.onSubscribe(this);
                 if (maxConcurrency == Integer.MAX_VALUE) {
                     s.request(Long.MAX_VALUE);
@@ -94,20 +95,6 @@ public void onSubscribe(Subscription s) {
             }
         }
         
-        SimpleQueue<Throwable> getOrCreateErrors() {
-            SimpleQueue<Throwable> q = errors.get();
-            
-            if (q != null) {
-                return q;
-            }
-            
-            q = new MpscLinkedQueue<Throwable>();
-            if (errors.compareAndSet(null, q)) {
-                return q;
-            }
-            return errors.get();
-        }
-
         @Override
         public void onNext(CompletableSource t) {
             if (done) {
@@ -116,57 +103,16 @@ public void onNext(CompletableSource t) {
 
             getAndIncrement();
             
-            t.subscribe(new CompletableObserver() {
-                Disposable d;
-                boolean innerDone;
-                @Override
-                public void onSubscribe(Disposable d) {
-                    this.d = d;
-                    set.add(d);
-                }
-                
-                @Override
-                public void onError(Throwable e) {
-                    if (innerDone) {
-                        RxJavaPlugins.onError(e);
-                        return;
-                    }
-                    innerDone = true;
-                    set.remove(d);
-                    
-                    getOrCreateErrors().offer(e);
-                    
-                    terminate();
-                    
-                    if (delayErrors && !done) {
-                        s.request(1);
-                    }
-                }
-                
-                @Override
-                public void onComplete() {
-                    if (innerDone) {
-                        return;
-                    }
-                    innerDone = true;
-                    set.remove(d);
-                    
-                    terminate();
-                    
-                    if (!done) {
-                        s.request(1);
-                    }
-                }
-            });
+            t.subscribe(new InnerObserver());
         }
 
         @Override
         public void onError(Throwable t) {
-            if (done) {
+            if (done || !error.addThrowable(t)) {
                 RxJavaPlugins.onError(t);
                 return;
             }
-            getOrCreateErrors().offer(t);
+            
             done = true;
             terminate();
         }
@@ -182,75 +128,69 @@ public void onComplete() {
 
         void terminate() {
             if (decrementAndGet() == 0) {
-                SimpleQueue<Throwable> q = errors.get();
-                if (q == null || q.isEmpty()) {
+                Throwable ex = error.terminate();
+                if (ex == null && ex != ExceptionHelper.TERMINATED) {
                     actual.onComplete();
                 } else {
-                    Throwable e = collectErrors(q);
-                    if (once.compareAndSet(false, true)) {
-                        actual.onError(e);
-                    } else {
-                        RxJavaPlugins.onError(e);
-                    }
+                    actual.onError(ex);
                 }
-            } else
-            if (!delayErrors) {
-                SimpleQueue<Throwable> q = errors.get();
-                if (q != null && !q.isEmpty()) {
-                    Throwable e = collectErrors(q);
+            }
+            else if (!delayErrors) {
+                Throwable ex = error.get();
+                if (ex != null && ex != ExceptionHelper.TERMINATED) {
+                    s.cancel();
+                    set.dispose();
                     if (once.compareAndSet(false, true)) {
-                        actual.onError(e);
+                        actual.onError(error.terminate());
                     } else {
-                        RxJavaPlugins.onError(e);
+                        RxJavaPlugins.onError(ex);
                     }
                 }
             }
         }
-    }
-    
-    /**
-     * Collects the Throwables from the queue, adding subsequent Throwables as suppressed to
-     * the first Throwable and returns it.
-     * @param q the queue to drain
-     * @return the Throwable containing all other Throwables as suppressed
-     */
-    public static Throwable collectErrors(SimpleQueue<Throwable> q) {
-        CompositeException composite = null;
-        Throwable first = null;
         
-        Throwable t;
-        int count = 0;
-        for (;;) {
-            
-            try {
-                t = q.poll();
-            } catch (Throwable ex) {
-                Exceptions.throwIfFatal(ex);
-                if (composite == null) {
-                    composite = new CompositeException(first);
-                }
-                composite.suppress(ex);
-                break;
+        final class InnerObserver implements CompletableObserver {
+            Disposable d;
+            boolean innerDone;
+
+            @Override
+            public void onSubscribe(Disposable d) {
+                this.d = d;
+                set.add(d);
             }
-            
-            if (t == null) {
-                break;
+
+            @Override
+            public void onError(Throwable e) {
+                if (innerDone || !error.addThrowable(e)) {
+                    RxJavaPlugins.onError(e);
+                    return;
+                }
+                
+                set.delete(d);
+                innerDone = true;
+                
+                terminate();
+                
+                if (delayErrors && !done) {
+                    s.request(1);
+                }
             }
-            
-            if (count == 0) {
-                first = t;
-            } else {
-                if (composite == null) {
-                    composite = new CompositeException(first);
+
+            @Override
+            public void onComplete() {
+                if (innerDone) {
+                    return;
+                }
+                
+                set.delete(d);
+                innerDone = true;
+                
+                terminate();
+                
+                if (!done) {
+                    s.request(1);
                 }
-                composite.suppress(t);
             }
-            
-            count++;
-        }
-        if (composite != null) {
-            return composite;
         }
-        return first;
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorArray.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorArray.java
index b39de8b143..2bbdd3614f 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorArray.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorArray.java
@@ -17,10 +17,11 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.*;
-import io.reactivex.internal.fuseable.SimpleQueue;
-import io.reactivex.internal.queue.MpscLinkedQueue;
+import io.reactivex.internal.util.AtomicThrowable;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public final class CompletableMergeDelayErrorArray extends Completable {
+
     final CompletableSource[] sources;
     
     public CompletableMergeDelayErrorArray(CompletableSource[] sources) {
@@ -31,8 +32,8 @@ public CompletableMergeDelayErrorArray(CompletableSource[] sources) {
     public void subscribeActual(final CompletableObserver s) {
         final CompositeDisposable set = new CompositeDisposable();
         final AtomicInteger wip = new AtomicInteger(sources.length + 1);
-        
-        final SimpleQueue<Throwable> q = new MpscLinkedQueue<Throwable>();
+
+        final AtomicThrowable error = new AtomicThrowable();
         
         s.onSubscribe(set);
         
@@ -42,48 +43,68 @@ public void subscribeActual(final CompletableObserver s) {
             }
             
             if (c == null) {
-                q.offer(new NullPointerException("A completable source is null"));
+                Throwable ex = new NullPointerException("A completable source is null");
+                error.addThrowable(ex);
                 wip.decrementAndGet();
                 continue;
             }
             
-            c.subscribe(new CompletableObserver() {
-                @Override
-                public void onSubscribe(Disposable d) {
-                    set.add(d);
-                }
-
-                @Override
-                public void onError(Throwable e) {
-                    q.offer(e);
-                    tryTerminate();
-                }
-
-                @Override
-                public void onComplete() {
-                    tryTerminate();
-                }
-                
-                void tryTerminate() {
-                    if (wip.decrementAndGet() == 0) {
-                        if (q.isEmpty()) {
-                            s.onComplete();
-                        } else {
-                            s.onError(CompletableMerge.collectErrors(q));
-                        }
-                    }
-                }
-                
-            });
+            c.subscribe(new MergeInnerCompletableObserver(s, set, error, wip));
         }
         
         if (wip.decrementAndGet() == 0) {
-            if (q.isEmpty()) {
+            Throwable ex = error.terminate();
+            if (ex == null) {
                 s.onComplete();
             } else {
-                s.onError(CompletableMerge.collectErrors(q));
+                s.onError(ex);
+            }
+        }
+    }
+
+    static final class MergeInnerCompletableObserver 
+    implements CompletableObserver {
+        final CompletableObserver actual;
+        final CompositeDisposable set;
+        final AtomicThrowable error;
+        final AtomicInteger wip;
+
+        MergeInnerCompletableObserver(CompletableObserver s, CompositeDisposable set, AtomicThrowable error,
+                AtomicInteger wip) {
+            this.actual = s;
+            this.set = set;
+            this.error = error;
+            this.wip = wip;
+        }
+
+        @Override
+        public void onSubscribe(Disposable d) {
+            set.add(d);
+        }
+
+        @Override
+        public void onError(Throwable e) {
+            if (error.addThrowable(e)) {
+                tryTerminate();
+            } else {
+                RxJavaPlugins.onError(e);
+            }
+        }
+
+        @Override
+        public void onComplete() {
+            tryTerminate();
+        }
+
+        void tryTerminate() {
+            if (wip.decrementAndGet() == 0) {
+                Throwable ex = error.terminate();
+                if (ex == null) {
+                    actual.onComplete();
+                } else {
+                    actual.onError(ex);
+                }
             }
         }
-        
     }
 }
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorIterable.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorIterable.java
index a5eb8a5628..02f8c6e629 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorIterable.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorIterable.java
@@ -17,12 +17,14 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.reactivex.*;
-import io.reactivex.disposables.*;
+import io.reactivex.disposables.CompositeDisposable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.fuseable.SimpleQueue;
-import io.reactivex.internal.queue.MpscLinkedQueue;
+import io.reactivex.internal.functions.ObjectHelper;
+import io.reactivex.internal.operators.completable.CompletableMergeDelayErrorArray.MergeInnerCompletableObserver;
+import io.reactivex.internal.util.AtomicThrowable;
 
 public final class CompletableMergeDelayErrorIterable extends Completable {
+
     final Iterable<? extends CompletableSource> sources;
     
     public CompletableMergeDelayErrorIterable(Iterable<? extends CompletableSource> sources) {
@@ -51,8 +53,8 @@ public void subscribeActual(final CompletableObserver s) {
         }
 
         final AtomicInteger wip = new AtomicInteger(1);
-        
-        final SimpleQueue<Throwable> queue = new MpscLinkedQueue<Throwable>();
+
+        final AtomicThrowable error = new AtomicThrowable();
 
         for (;;) {
             if (set.isDisposed()) {
@@ -64,15 +66,8 @@ public void subscribeActual(final CompletableObserver s) {
                 b = iterator.hasNext();
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                queue.offer(e);
-                if (wip.decrementAndGet() == 0) {
-                    if (queue.isEmpty()) {
-                        s.onComplete();
-                    } else {
-                        s.onError(CompletableMerge.collectErrors(queue));
-                    }
-                }
-                return;
+                error.addThrowable(e);
+                break;
             }
                     
             if (!b) {
@@ -86,73 +81,28 @@ public void subscribeActual(final CompletableObserver s) {
             CompletableSource c;
             
             try {
-                c = iterator.next();
+                c = ObjectHelper.requireNonNull(iterator.next(), "The iterator returned a null CompletableSource");
             } catch (Throwable e) {
                 Exceptions.throwIfFatal(e);
-                queue.offer(e);
-                if (wip.decrementAndGet() == 0) {
-                    if (queue.isEmpty()) {
-                        s.onComplete();
-                    } else {
-                        s.onError(CompletableMerge.collectErrors(queue));
-                    }
-                }
-                return;
+                error.addThrowable(e);
+                break;
             }
             
             if (set.isDisposed()) {
                 return;
             }
             
-            if (c == null) {
-                NullPointerException e = new NullPointerException("A completable source is null");
-                queue.offer(e);
-                if (wip.decrementAndGet() == 0) {
-                    if (queue.isEmpty()) {
-                        s.onComplete();
-                    } else {
-                        s.onError(CompletableMerge.collectErrors(queue));
-                    }
-                }
-                return;
-            }
-            
             wip.getAndIncrement();
             
-            c.subscribe(new CompletableObserver() {
-                @Override
-                public void onSubscribe(Disposable d) {
-                    set.add(d);
-                }
-
-                @Override
-                public void onError(Throwable e) {
-                    queue.offer(e);
-                    tryTerminate();
-                }
-
-                @Override
-                public void onComplete() {
-                    tryTerminate();
-                }
-                
-                void tryTerminate() {
-                    if (wip.decrementAndGet() == 0) {
-                        if (queue.isEmpty()) {
-                            s.onComplete();
-                        } else {
-                            s.onError(CompletableMerge.collectErrors(queue));
-                        }
-                    }
-                }
-            });
+            c.subscribe(new MergeInnerCompletableObserver(s, set, error, wip));
         }
         
         if (wip.decrementAndGet() == 0) {
-            if (queue.isEmpty()) {
+            Throwable ex = error.terminate();
+            if (ex == null) {
                 s.onComplete();
             } else {
-                s.onError(CompletableMerge.collectErrors(queue));
+                s.onError(ex);
             }
         }
     }
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java b/src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java
index 7f89b61db0..e729dea32f 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java
@@ -103,7 +103,7 @@ public void onSubscribe(final Disposable d) {
                     return;
                 }
                 
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         try {
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableSubscribeOn.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableSubscribeOn.java
index 5d39acbe27..8b6d0431ad 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableSubscribeOn.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableSubscribeOn.java
@@ -13,7 +13,11 @@
 
 package io.reactivex.internal.operators.completable;
 
+import java.util.concurrent.atomic.AtomicReference;
+
 import io.reactivex.*;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.disposables.*;
 
 public final class CompletableSubscribeOn extends Completable {
     final CompletableSource source;
@@ -25,16 +29,63 @@ public CompletableSubscribeOn(CompletableSource source, Scheduler scheduler) {
         this.scheduler = scheduler;
     }
 
-
-
     @Override
     protected void subscribeActual(final CompletableObserver s) {
-     // FIXME cancellation of this schedule
-        scheduler.scheduleDirect(new Runnable() {
+
+        final SubscribeOnObserver parent = new SubscribeOnObserver(s);
+        s.onSubscribe(parent);
+        
+        Disposable f = scheduler.scheduleDirect(new Runnable() {
             @Override
             public void run() {
-                source.subscribe(s);
+                source.subscribe(parent);
             }
         });
+        
+        parent.task.replace(f);
+    
     }
+    
+    static final class SubscribeOnObserver 
+    extends AtomicReference<Disposable>
+    implements CompletableObserver, Disposable {
+        /** */
+        private static final long serialVersionUID = 7000911171163930287L;
+
+        final CompletableObserver actual;
+        
+        final SequentialDisposable task;
+        
+        public SubscribeOnObserver(CompletableObserver actual) {
+            this.actual = actual;
+            this.task = new SequentialDisposable();
+        }
+        
+        @Override
+        public void onSubscribe(Disposable d) {
+            DisposableHelper.setOnce(this, d);
+        }
+        
+        @Override
+        public void onError(Throwable e) {
+            actual.onError(e);
+        }
+        
+        @Override
+        public void onComplete() {
+            actual.onComplete();
+        }
+        
+        @Override
+        public void dispose() {
+            DisposableHelper.dispose(this);
+            task.dispose();
+        }
+        
+        @Override
+        public boolean isDisposed() {
+            return DisposableHelper.isDisposed(this);
+        }
+    }
+    
 }
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableUnsubscribeOn.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableUnsubscribeOn.java
index c8cc33e363..9b01c36e04 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableUnsubscribeOn.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableUnsubscribeOn.java
@@ -43,7 +43,7 @@ public void onError(Throwable e) {
 
             @Override
             public void onSubscribe(final Disposable d) {
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         scheduler.scheduleDirect(new Runnable() {
diff --git a/src/main/java/io/reactivex/internal/operators/completable/CompletableUsing.java b/src/main/java/io/reactivex/internal/operators/completable/CompletableUsing.java
index 6f3f782a5b..4709becd38 100644
--- a/src/main/java/io/reactivex/internal/operators/completable/CompletableUsing.java
+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableUsing.java
@@ -130,7 +130,7 @@ public void onError(Throwable e) {
             @Override
             public void onSubscribe(Disposable d) {
                 this.d = d;
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         disposeThis();
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java
index be24ba150c..bb2c1558c1 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java
@@ -179,7 +179,7 @@ void doSubscribe(final Subscriber<? super T> subscriber, final CompositeDisposab
     }
 
     private Disposable disconnect(final CompositeDisposable current) {
-        return Disposables.from(new Runnable() {
+        return Disposables.fromRunnable(new Runnable() {
             @Override
             public void run() {
                 lock.lock();
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableToFuture.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToFuture.java
deleted file mode 100644
index b3e43b9597..0000000000
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableToFuture.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- * Copyright 2016 Netflix, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
- * the License for the specific language governing permissions and limitations under the License.
- */
-
-package io.reactivex.internal.operators.flowable;
-
-import java.util.NoSuchElementException;
-import java.util.concurrent.*;
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.reactivestreams.*;
-
-import io.reactivex.disposables.Disposables;
-import io.reactivex.internal.disposables.SequentialDisposable;
-
-/**
- * Utility method to turn a Publisher into a Future.
- */
-public enum FlowableToFuture {
-    ;
-    
-    public static <T> Future<T> toFuture(Publisher<? extends T> o) {
-        final CountDownLatch cdl = new CountDownLatch(1);
-        final AtomicReference<T> value = new AtomicReference<T>();
-        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
-        final SequentialDisposable sd = new SequentialDisposable();
-        
-        o.subscribe(new Subscriber<T>() {
-
-            @Override
-            public void onSubscribe(Subscription d) {
-                sd.replace(Disposables.from(d));
-                d.request(Long.MAX_VALUE);
-            }
-
-            @Override
-            public void onNext(T v) {
-                if (value.get() != null) {
-                    sd.dispose();
-                    onError(new IndexOutOfBoundsException("More than one element received"));
-                    return;
-                }
-                value.lazySet(v);
-            }
-
-            @Override
-            public void onError(Throwable e) {
-                error.lazySet(e);
-                cdl.countDown();
-            }
-
-            @Override
-            public void onComplete() {
-                if (value.get() == null) {
-                    onError(new NoSuchElementException("The source is empty"));
-                    return;
-                }
-                cdl.countDown();
-            }
-            
-        });
-        
-        return new Future<T>() {
-            
-            @Override
-            public boolean cancel(boolean mayInterruptIfRunning) {
-                if (cdl.getCount() != 0) {
-                    sd.dispose();
-                    error.set(new CancellationException());
-                    cdl.countDown();
-                    return true;
-                }
-                return false;
-            }
-
-            @Override
-            public boolean isCancelled() {
-                return sd.isDisposed();
-            }
-
-            @Override
-            public boolean isDone() {
-                return cdl.getCount() == 0 && !sd.isDisposed();
-            }
-
-            @Override
-            public T get() throws InterruptedException, ExecutionException {
-                if (cdl.getCount() != 0) {
-                    cdl.await();
-                }
-                Throwable e = error.get();
-                if (e != null) {
-                    if (e instanceof CancellationException) {
-                        throw (CancellationException)e;
-                    }
-                    throw new ExecutionException(e);
-                }
-                return value.get();
-            }
-
-            @Override
-            public T get(long timeout, TimeUnit unit)
-                    throws InterruptedException, ExecutionException, TimeoutException {
-                if (cdl.getCount() != 0) {
-                    if (!cdl.await(timeout, unit)) {
-                        throw new TimeoutException();
-                    }
-                }
-                Throwable e = error.get();
-                if (e != null) {
-                    if (e instanceof CancellationException) {
-                        throw (CancellationException)e;
-                    }
-                    throw new ExecutionException(e);
-                }
-                return value.get();
-            }
-            
-        };
-    }
-}
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java
index e82899e2fb..561a27e333 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java
@@ -115,7 +115,7 @@ void doSubscribe(final Observer<? super T> subscriber, final CompositeDisposable
     }
 
     private Disposable disconnect(final CompositeDisposable current) {
-        return Disposables.from(new Runnable() {
+        return Disposables.fromRunnable(new Runnable() {
             @Override
             public void run() {
                 lock.lock();
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableToFuture.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableToFuture.java
deleted file mode 100644
index 2dd97f1c4d..0000000000
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableToFuture.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/**
- * Copyright 2016 Netflix, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is
- * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
- * the License for the specific language governing permissions and limitations under the License.
- */
-
-package io.reactivex.internal.operators.observable;
-
-import java.util.NoSuchElementException;
-import java.util.concurrent.*;
-import java.util.concurrent.atomic.AtomicReference;
-
-import io.reactivex.*;
-import io.reactivex.disposables.*;
-import io.reactivex.internal.disposables.SequentialDisposable;
-
-/**
- * Utility method to turn a Publisher into a Future.
- */
-public enum ObservableToFuture {
-    ;
-    
-    public static <T> Future<T> toFuture(ObservableSource<? extends T> o) {
-        final CountDownLatch cdl = new CountDownLatch(1);
-        final AtomicReference<T> value = new AtomicReference<T>();
-        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
-        final SequentialDisposable sd = new SequentialDisposable();
-        
-        o.subscribe(new Observer<T>() {
-
-            @Override
-            public void onSubscribe(Disposable d) {
-                sd.replace(d);
-            }
-
-            @Override
-            public void onNext(T v) {
-                if (value.get() != null) {
-                    sd.dispose();
-                    onError(new IndexOutOfBoundsException("More than one element received"));
-                    return;
-                }
-                value.lazySet(v);
-            }
-
-            @Override
-            public void onError(Throwable e) {
-                error.lazySet(e);
-                cdl.countDown();
-            }
-
-            @Override
-            public void onComplete() {
-                if (value.get() == null) {
-                    onError(new NoSuchElementException("The source is empty"));
-                    return;
-                }
-                cdl.countDown();
-            }
-            
-        });
-        
-        return new Future<T>() {
-            
-            @Override
-            public boolean cancel(boolean mayInterruptIfRunning) {
-                if (cdl.getCount() != 0) {
-                    sd.dispose();
-                    error.set(new CancellationException());
-                    cdl.countDown();
-                    return true;
-                }
-                return false;
-            }
-
-            @Override
-            public boolean isCancelled() {
-                return sd.isDisposed();
-            }
-
-            @Override
-            public boolean isDone() {
-                return cdl.getCount() == 0 && !sd.isDisposed();
-            }
-
-            @Override
-            public T get() throws InterruptedException, ExecutionException {
-                if (cdl.getCount() != 0) {
-                    cdl.await();
-                }
-                Throwable e = error.get();
-                if (e != null) {
-                    if (e instanceof CancellationException) {
-                        throw (CancellationException)e;
-                    }
-                    throw new ExecutionException(e);
-                }
-                return value.get();
-            }
-
-            @Override
-            public T get(long timeout, TimeUnit unit)
-                    throws InterruptedException, ExecutionException, TimeoutException {
-                if (cdl.getCount() != 0) {
-                    if (!cdl.await(timeout, unit)) {
-                        throw new TimeoutException();
-                    }
-                }
-                Throwable e = error.get();
-                if (e != null) {
-                    if (e instanceof CancellationException) {
-                        throw (CancellationException)e;
-                    }
-                    throw new ExecutionException(e);
-                }
-                return value.get();
-            }
-            
-        };
-    }
-}
diff --git a/src/main/java/io/reactivex/internal/operators/single/SingleSubscribeOn.java b/src/main/java/io/reactivex/internal/operators/single/SingleSubscribeOn.java
index 98820c6493..d256d43785 100644
--- a/src/main/java/io/reactivex/internal/operators/single/SingleSubscribeOn.java
+++ b/src/main/java/io/reactivex/internal/operators/single/SingleSubscribeOn.java
@@ -17,7 +17,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 
 public final class SingleSubscribeOn<T> extends Single<T> {
     final SingleSource<? extends T> source;
@@ -42,7 +42,7 @@ public void run() {
             }
         });
         
-        DisposableHelper.replace(parent, f);
+        parent.task.replace(f);
     
     }
     
@@ -54,8 +54,11 @@ public void run() {
 
         final SingleObserver<? super T> actual;
         
+        final SequentialDisposable task;
+        
         public SubscribeOnObserver(SingleObserver<? super T> actual) {
             this.actual = actual;
+            this.task = new SequentialDisposable();
         }
         
         @Override
@@ -76,6 +79,7 @@ public void onError(Throwable e) {
         @Override
         public void dispose() {
             DisposableHelper.dispose(this);
+            task.dispose();
         }
         
         @Override
diff --git a/src/main/java/io/reactivex/internal/operators/single/SingleUsing.java b/src/main/java/io/reactivex/internal/operators/single/SingleUsing.java
index 12d052e539..3d90be2274 100644
--- a/src/main/java/io/reactivex/internal/operators/single/SingleUsing.java
+++ b/src/main/java/io/reactivex/internal/operators/single/SingleUsing.java
@@ -71,7 +71,7 @@ public void onSubscribe(Disposable d) {
                 if (eager) {
                     CompositeDisposable set = new CompositeDisposable();
                     set.add(d);
-                    set.add(Disposables.from(new Runnable() {
+                    set.add(Disposables.fromRunnable(new Runnable() {
                         @Override
                         public void run() {
                             try {
diff --git a/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java b/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java
index 5221c492b7..f2b4a87c26 100644
--- a/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java
+++ b/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java
@@ -45,7 +45,7 @@ public Disposable scheduleDirect(Runnable run) {
         try {
             if (executor instanceof ExecutorService) {
                 Future<?> f = ((ExecutorService)executor).submit(decoratedRun);
-                return Disposables.from(f);
+                return Disposables.fromFuture(f);
             }
             
             BooleanRunnable br = new BooleanRunnable(decoratedRun);
@@ -63,7 +63,7 @@ public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
         if (executor instanceof ScheduledExecutorService) {
             try {
                 Future<?> f = ((ScheduledExecutorService)executor).schedule(decoratedRun, delay, unit);
-                return Disposables.from(f);
+                return Disposables.fromFuture(f);
             } catch (RejectedExecutionException ex) {
                 RxJavaPlugins.onError(ex);
                 return EmptyDisposable.INSTANCE;
@@ -91,7 +91,7 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
             Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
             try {
                 Future<?> f = ((ScheduledExecutorService)executor).scheduleAtFixedRate(decoratedRun, initialDelay, period, unit);
-                return Disposables.from(f);
+                return Disposables.fromFuture(f);
             } catch (RejectedExecutionException ex) {
                 RxJavaPlugins.onError(ex);
                 return EmptyDisposable.INSTANCE;
diff --git a/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
index 9f8eb35eba..9db7a1bae1 100644
--- a/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
+++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java
@@ -64,7 +64,7 @@ public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit un
             } else {
                 f = executor.schedule(decoratedRun, delayTime, unit);
             }
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;
@@ -84,7 +84,7 @@ public Disposable schedulePeriodicallyDirect(final Runnable run, long initialDel
         Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
         try {
             Future<?> f = executor.scheduleAtFixedRate(decoratedRun, initialDelay, period, unit);
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;
diff --git a/src/main/java/io/reactivex/internal/schedulers/SingleScheduler.java b/src/main/java/io/reactivex/internal/schedulers/SingleScheduler.java
index e94ab2feb1..15b5e0a61c 100644
--- a/src/main/java/io/reactivex/internal/schedulers/SingleScheduler.java
+++ b/src/main/java/io/reactivex/internal/schedulers/SingleScheduler.java
@@ -85,7 +85,7 @@ public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) {
             } else {
                 f = executor.get().schedule(decoratedRun, delay, unit);
             }
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;
@@ -97,7 +97,7 @@ public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, lo
         Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
         try {
             Future<?> f = executor.get().scheduleAtFixedRate(decoratedRun, initialDelay, period, unit);
-            return Disposables.from(f);
+            return Disposables.fromFuture(f);
         } catch (RejectedExecutionException ex) {
             RxJavaPlugins.onError(ex);
             return EmptyDisposable.INSTANCE;
diff --git a/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java b/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
index a400d02010..f472237f75 100644
--- a/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
+++ b/src/main/java/io/reactivex/internal/schedulers/TrampolineScheduler.java
@@ -111,7 +111,7 @@ Disposable enqueue(Runnable action, long execTime) {
                 return EmptyDisposable.INSTANCE;
             } else {
                 // queue wasn't empty, a parent is already processing so we just add to the end of the queue
-                return Disposables.from(new Runnable() {
+                return Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         timedRunnable.disposed = true;
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/FutureSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/FutureSubscriber.java
new file mode 100644
index 0000000000..2d30c28106
--- /dev/null
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/FutureSubscriber.java
@@ -0,0 +1,172 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscribers.flowable;
+
+import java.util.NoSuchElementException;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.reactivestreams.*;
+
+import io.reactivex.internal.subscriptions.SubscriptionHelper;
+import io.reactivex.plugins.RxJavaPlugins;
+
+/**
+ * A Subscriber + Future that expects exactly one upstream value and provides it
+ * via the (blocking) Future API.
+ *
+ * @param <T> the value type
+ */
+public final class FutureSubscriber<T> extends CountDownLatch
+implements Subscriber<T>, Future<T>, Subscription {
+
+    T value;
+    Throwable error;
+    
+    final AtomicReference<Subscription> s;
+    
+    public FutureSubscriber() {
+        super(1);
+        this.s = new AtomicReference<Subscription>();
+    }
+    
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        for (;;) {
+            Subscription a = s.get();
+            if (a == this || a == SubscriptionHelper.CANCELLED) {
+                return false;
+            }
+            
+            if (s.compareAndSet(a, SubscriptionHelper.CANCELLED)) {
+                if (a != null) {
+                    a.cancel();
+                }
+                countDown();
+                return true;
+            }
+        }
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return SubscriptionHelper.isCancelled(s.get());
+    }
+
+    @Override
+    public boolean isDone() {
+        return getCount() == 0;
+    }
+
+    @Override
+    public T get() throws InterruptedException, ExecutionException {
+        if (getCount() != 0) {
+            await();
+        }
+        
+        if (isCancelled()) {
+            throw new CancellationException();
+        }
+        Throwable ex = error;
+        if (ex != null) {
+            throw new ExecutionException(ex);
+        }
+        return value;
+    }
+
+    @Override
+    public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+        if (getCount() != 0) {
+            if (!await(timeout, unit)) {
+                throw new TimeoutException();
+            }
+        }
+        
+        if (isCancelled()) {
+            throw new CancellationException();
+        }
+        
+        Throwable ex = error;
+        if (ex != null) {
+            throw new ExecutionException(ex);
+        }
+        return value;
+    }
+
+    @Override
+    public void onSubscribe(Subscription s) {
+        if (SubscriptionHelper.setOnce(this.s, s)) {
+            s.request(Long.MAX_VALUE);
+        }
+    }
+
+    @Override
+    public void onNext(T t) {
+        if (value != null) {
+            s.get().cancel();
+            onError(new IndexOutOfBoundsException("More than one element received"));
+            return;
+        }
+        value = t;
+    }
+
+    @Override
+    public void onError(Throwable t) {
+        if (error == null) {
+            error = t;
+
+            for (;;) {
+                Subscription a = s.get();
+                if (a == this || a == SubscriptionHelper.CANCELLED) {
+                    RxJavaPlugins.onError(t);
+                    return;
+                }
+                if (s.compareAndSet(a, this)) {
+                    countDown();
+                    return;
+                }
+            }
+        } else {
+            RxJavaPlugins.onError(t);
+        }
+    }
+
+    @Override
+    public void onComplete() {
+        if (value == null) {
+            onError(new NoSuchElementException("The source is empty"));
+            return;
+        }
+        for (;;) {
+            Subscription a = s.get();
+            if (a == this || a == SubscriptionHelper.CANCELLED) {
+                return;
+            }
+            if (s.compareAndSet(a, this)) {
+                countDown();
+                return;
+            }
+        }
+    }
+    
+    @Override
+    public void cancel() {
+        // ignoring as `this` means a finished Subscription only
+    }
+    
+    @Override
+    public void request(long n) {
+        // ignoring as `this` means a finished Subscription only
+    }
+}
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/FutureObserver.java b/src/main/java/io/reactivex/internal/subscribers/observable/FutureObserver.java
new file mode 100644
index 0000000000..18fffb7aa8
--- /dev/null
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/FutureObserver.java
@@ -0,0 +1,170 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscribers.observable;
+
+import java.util.NoSuchElementException;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.plugins.RxJavaPlugins;
+
+/**
+ * A Observer + Future that expects exactly one upstream value and provides it
+ * via the (blocking) Future API.
+ *
+ * @param <T> the value type
+ */
+public final class FutureObserver<T> extends CountDownLatch
+implements Observer<T>, Future<T>, Disposable {
+
+    T value;
+    Throwable error;
+    
+    final AtomicReference<Disposable> s;
+    
+    public FutureObserver() {
+        super(1);
+        this.s = new AtomicReference<Disposable>();
+    }
+    
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+        for (;;) {
+            Disposable a = s.get();
+            if (a == this || a == DisposableHelper.DISPOSED) {
+                return false;
+            }
+            
+            if (s.compareAndSet(a, DisposableHelper.DISPOSED)) {
+                if (a != null) {
+                    a.dispose();
+                }
+                countDown();
+                return true;
+            }
+        }
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return DisposableHelper.isDisposed(s.get());
+    }
+
+    @Override
+    public boolean isDone() {
+        return getCount() == 0;
+    }
+
+    @Override
+    public T get() throws InterruptedException, ExecutionException {
+        if (getCount() != 0) {
+            await();
+        }
+        
+        if (isCancelled()) {
+            throw new CancellationException();
+        }
+        Throwable ex = error;
+        if (ex != null) {
+            throw new ExecutionException(ex);
+        }
+        return value;
+    }
+
+    @Override
+    public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
+        if (getCount() != 0) {
+            if (!await(timeout, unit)) {
+                throw new TimeoutException();
+            }
+        }
+        
+        if (isCancelled()) {
+            throw new CancellationException();
+        }
+        
+        Throwable ex = error;
+        if (ex != null) {
+            throw new ExecutionException(ex);
+        }
+        return value;
+    }
+
+    @Override
+    public void onSubscribe(Disposable s) {
+        DisposableHelper.setOnce(this.s, s);
+    }
+
+    @Override
+    public void onNext(T t) {
+        if (value != null) {
+            s.get().dispose();
+            onError(new IndexOutOfBoundsException("More than one element received"));
+            return;
+        }
+        value = t;
+    }
+
+    @Override
+    public void onError(Throwable t) {
+        if (error == null) {
+            error = t;
+
+            for (;;) {
+                Disposable a = s.get();
+                if (a == this || a == DisposableHelper.DISPOSED) {
+                    RxJavaPlugins.onError(t);
+                    return;
+                }
+                if (s.compareAndSet(a, this)) {
+                    countDown();
+                    return;
+                }
+            }
+        } else {
+            RxJavaPlugins.onError(t);
+        }
+    }
+
+    @Override
+    public void onComplete() {
+        if (value == null) {
+            onError(new NoSuchElementException("The source is empty"));
+            return;
+        }
+        for (;;) {
+            Disposable a = s.get();
+            if (a == this || a == DisposableHelper.DISPOSED) {
+                return;
+            }
+            if (s.compareAndSet(a, this)) {
+                countDown();
+                return;
+            }
+        }
+    }
+    
+    @Override
+    public void dispose() {
+        // ignoring as `this` means a finished Disposable only
+    }
+    
+    @Override
+    public boolean isDisposed() {
+        return isDone();
+    }
+}
diff --git a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
index bb66811bd6..e98bcda279 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionHelper.java
@@ -24,13 +24,23 @@
 /**
  * Utility methods to validate Subscriptions in the various onSubscribe calls.
  */
-public enum SubscriptionHelper {
-    ;
+public enum SubscriptionHelper implements Subscription {
     /**
      * Represents a cancelled Subscription.
      * <p>Don't leak this instance!
      */
-    public static final Subscription CANCELLED = Cancelled.INSTANCE;
+    CANCELLED
+    ;
+
+    @Override
+    public void request(long n) {
+        // deliberately ignored
+    }
+    
+    @Override
+    public void cancel() {
+        // deliberately ignored
+    }
     
     /**
      * Verifies that current is null, next is not null, otherwise signals errors
@@ -53,7 +63,8 @@ public static boolean validate(Subscription current, Subscription next) {
     }
     
     /**
-     * Reports that the subscription is already set to the RxJavaPlugins error handler.
+     * Reports that the subscription is already set to the RxJavaPlugins error handler, 
+     * which is an indication of a onSubscribe management bug.
      */
     public static void reportSubscriptionSet() {
         RxJavaPlugins.onError(new IllegalStateException("Subscription already set!"));
@@ -72,6 +83,11 @@ public static boolean validate(long n) {
         return true;
     }
     
+    /**
+     * Reports to the plugin error handler that there were more values produced than requested, which
+     * is a sign of internal backpressure handling bug.
+     * @param n the overproduction amount
+     */
     public static void reportMoreProduced(long n) {
         RxJavaPlugins.onError(new IllegalStateException("More produced than requested: " + n));
     }
@@ -178,24 +194,12 @@ public static boolean cancel(AtomicReference<Subscription> field) {
     }
     
     /**
-     * The common cancelled instance implemented as a singleton enum.
+     * Atomically sets the new Subscription on the field and requests any accumulated amount
+     * from the requested field.
+     * @param field the target field for the new Subscription
+     * @param requested the current requested amount
+     * @param s the new Subscription, not null (verified)
      */
-    enum Cancelled implements Subscription {
-        INSTANCE
-        ;
-
-        @Override
-        public void request(long n) {
-            // deliberately ignored
-        }
-
-        @Override
-        public void cancel() {
-            // deliberately ignored
-        }
-        
-    }
-    
     public static void deferredSetOnce(AtomicReference<Subscription> field, AtomicLong requested, 
             Subscription s) {
         if (SubscriptionHelper.setOnce(field, s)) {
@@ -206,6 +210,13 @@ public static void deferredSetOnce(AtomicReference<Subscription> field, AtomicLo
         }
     }
     
+    /**
+     * Atomically requests from the Subscription in the field if not null, otherwise accumulates
+     * the request amount in the requested field to be requested once the field is set to non-null.
+     * @param field the target field that may already contain a Subscription
+     * @param requested the current requested amount
+     * @param n the request amount, positive (verified)
+     */
     public static void deferredRequest(AtomicReference<Subscription> field, AtomicLong requested, long n) {
         Subscription s = field.get();
         if (s != null) {
diff --git a/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java b/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
index c9f41ac3bc..87ea265c3a 100644
--- a/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
+++ b/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java
@@ -62,27 +62,6 @@ public void setFirst(T value) {
         head[0] = value;
     }
     
-    /**
-     * Loops through all elements of the list.
-     * @param consumer the consumer of elements
-     * @throws Exception if the consumer throws
-     */
-    @SuppressWarnings("unchecked")
-    public void forEach(Consumer<? super T> consumer) throws Exception {
-        Object[] a = head;
-        final int c = capacity;
-        while (a != null) {
-            for (int i = 0; i < c; i++) {
-                Object o = a[i];
-                if (o == null) {
-                    return;
-                }
-                consumer.accept((T)o);
-            }
-            a = (Object[])a[c];
-        }
-    }
-    
     /**
      * Loops over all elements of the array until a null element is encountered or
      * the given predicate returns true.
@@ -107,6 +86,14 @@ public void forEachWhile(Predicate<? super T> consumer) throws Exception {
         }
     }
     
+    /**
+     * Loops over all elements of the array until a null element is encountered or
+     * the given predicate returns true.
+     * @param <S> the extra state type
+     * @param state the extra state passed into the consumer
+     * @param consumer the consumer of values that returns true if the forEach should terminate
+     * @throws Exception if the predicate throws
+     */
     @SuppressWarnings("unchecked")
     public <S> void forEachWhile(S state, BiPredicate<? super S, ? super T> consumer) throws Exception {
         Object[] a = head;
diff --git a/src/main/java/io/reactivex/internal/util/BackpressureHelper.java b/src/main/java/io/reactivex/internal/util/BackpressureHelper.java
index 6e6d398ff3..30321bafa1 100644
--- a/src/main/java/io/reactivex/internal/util/BackpressureHelper.java
+++ b/src/main/java/io/reactivex/internal/util/BackpressureHelper.java
@@ -19,8 +19,12 @@
 /**
  * Utility class to help with backpressure-related operations such as request aggregation.
  */
-public enum BackpressureHelper {
-    ;
+public final class BackpressureHelper {
+    /** Utility class. */
+    private BackpressureHelper() {
+        throw new IllegalStateException("No instances!");
+    }
+    
     /**
      * Adds two long values and caps the sum at Long.MAX_VALUE.
      * @param a the first value
diff --git a/src/main/java/io/reactivex/internal/util/ExceptionHelper.java b/src/main/java/io/reactivex/internal/util/ExceptionHelper.java
index 663826d9a5..0f44c703fc 100644
--- a/src/main/java/io/reactivex/internal/util/ExceptionHelper.java
+++ b/src/main/java/io/reactivex/internal/util/ExceptionHelper.java
@@ -21,8 +21,12 @@
 /**
  * Terminal atomics for Throwable containers.
  */
-public enum ExceptionHelper {
-    ;
+public final class ExceptionHelper {
+
+    /** Utility class. */
+    private ExceptionHelper() {
+        throw new IllegalStateException("No instances!");
+    }
     
     /**
      * If the provided Throwable is an Error this method
diff --git a/src/main/java/io/reactivex/internal/util/HalfSerializer.java b/src/main/java/io/reactivex/internal/util/HalfSerializer.java
index ca98a96813..8b877131ab 100644
--- a/src/main/java/io/reactivex/internal/util/HalfSerializer.java
+++ b/src/main/java/io/reactivex/internal/util/HalfSerializer.java
@@ -24,8 +24,11 @@
  * where onNext is guaranteed to be called from a single thread but
  * onError or onCompleted may be called from any threads.
  */
-public enum HalfSerializer {
-    ;
+public final class HalfSerializer {
+    /** Utility class. */
+    private HalfSerializer() {
+        throw new IllegalStateException("No instances!");
+    }
     
     public static <T> void onNext(Subscriber<? super T> subscriber, T value, 
             AtomicInteger wip, AtomicThrowable error) {
diff --git a/src/main/java/io/reactivex/internal/util/LinkedArrayList.java b/src/main/java/io/reactivex/internal/util/LinkedArrayList.java
index ff736edd8e..f813814c8f 100644
--- a/src/main/java/io/reactivex/internal/util/LinkedArrayList.java
+++ b/src/main/java/io/reactivex/internal/util/LinkedArrayList.java
@@ -79,13 +79,7 @@ public void add(Object o) {
     public Object[] head() {
         return head; // NOPMD
     }
-    /**
-     * Returns the tail buffer segment or null if the list is empty.
-     * @return the tail object array
-     */
-    public Object[] tail() {
-        return tail; // NOPMD
-    }
+
     /**
      * Returns the total size of the list.
      * @return the total size of the list
@@ -93,21 +87,8 @@ public void add(Object o) {
     public int size() {
         return size;
     }
-    /**
-     * Returns the index of the next slot in the tail buffer segment.
-     * @return the index of the next slot in the tail buffer segment
-     */
-    public int indexInTail() {
-        return indexInTail;
-    }
-    /**
-     * Returns the capacity hint that indicates the capacity of each buffer segment.
-     * @return the capacity hint that indicates the capacity of each buffer segment
-     */
-    public int capacityHint() {
-        return capacityHint;
-    }
-    /* Test support */List<Object> toList() {
+    @Override
+    public String toString() {
         final int cap = capacityHint;
         final int s = size;
         final List<Object> list = new ArrayList<Object>(s + 1);
@@ -124,10 +105,6 @@ public int capacityHint() {
             }
         }
         
-        return list;
-    }
-    @Override
-    public String toString() {
-        return toList().toString();
+        return list.toString();
     }
 }
\ No newline at end of file
diff --git a/src/main/java/io/reactivex/internal/util/OpenHashSet.java b/src/main/java/io/reactivex/internal/util/OpenHashSet.java
index d15e21785a..6e343aac24 100644
--- a/src/main/java/io/reactivex/internal/util/OpenHashSet.java
+++ b/src/main/java/io/reactivex/internal/util/OpenHashSet.java
@@ -18,11 +18,6 @@
 
 package io.reactivex.internal.util;
 
-import java.util.Arrays;
-
-import io.reactivex.exceptions.*;
-import io.reactivex.functions.Consumer;
-
 /**
  * A simple open hash set with add, remove and clear capabilities only.
  * <p>Doesn't support nor checks for {@code null}s.
@@ -136,20 +131,6 @@ boolean removeEntry(int pos, T[] a, int m) {
         }
     }
     
-    public void clear(Consumer<? super T> clearAction) throws Exception {
-        if (size == 0) {
-            return;
-        }
-        T[] a = keys;
-        for (T e : a) {
-            if (e != null) {
-                clearAction.accept(e);
-            }
-        }
-        Arrays.fill(a, null);
-        size = 0;
-    }
-    
     @SuppressWarnings("unchecked")
     void rehash() {
         T[] a = keys;
@@ -184,47 +165,6 @@ static int mix(int x) {
         return h ^ (h >>> 16);
     }
     
-    public void forEach(Consumer<? super T> consumer) throws Exception  {
-        for (T k : keys) {
-            if (k != null) {
-                consumer.accept(k);
-            }
-        }
-    }
-
-    /**
-     * Loops through all values in the set and collects any exceptions from the consumer
-     * into a Throwable.
-     * @param consumer the consumer to call
-     * @return if not null, contains a CompositeException with all the suppressed exceptions
-     */
-    public Throwable forEachSuppress(Consumer<? super T> consumer) {
-        CompositeException ex = null;
-        int count = 0;
-        for (T k : keys) {
-            if (k != null) {
-                try {
-                    consumer.accept(k);
-                } catch (Throwable e) {
-                    Exceptions.throwIfFatal(e);
-                    if (ex == null) {
-                        ex = new CompositeException();
-                    }
-                    count++;
-                    ex.suppress(e);
-                }
-            }
-        }
-        if (count == 1) {
-            return ex.getExceptions().get(0);
-        }
-        return ex;
-    }
-    
-    public boolean isEmpty() {
-        return size == 0;
-    }
-    
     public Object[] keys() {
         return keys; // NOPMD
     }
diff --git a/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
index e9e486227c..1ed4712020 100644
--- a/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
+++ b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java
@@ -27,139 +27,12 @@
 /**
  * Utility class to help with the queue-drain serialization idiom.
  */
-public enum QueueDrainHelper {
-    ;
-
-    /**
-     * A fast-path queue-drain serialization logic.
-     * <p>The decrementing of the state is left to the drain callback.
-     * @param <T> the instance type
-     * @param instance the work-in-progress counter
-     * @param fastPath called if the instance is not contended.
-     * @param queue called if the instance is contended to queue up work
-     * @param drain called if the instance transitions to the drain state successfully
-     */
-    public static <T> void queueDrain(AtomicInteger instance,
-            Runnable fastPath, Runnable queue, Runnable drain) {
-        if (instance.get() == 0 && instance.compareAndSet(0, 1)) {
-            fastPath.run();
-            if (instance.decrementAndGet() == 0) {
-                return;
-            }
-        } else {
-            queue.run();
-            if (instance.getAndIncrement() != 0) {
-                return;
-            }
-        }
-        drain.run();
-    }
-
-    /**
-     * A fast-path queue-drain serialization logic with the ability to leave the state
-     * in fast-path/drain mode or not continue after the call to queue.
-     * <p>The decrementing of the state is left to the drain callback.
-     * @param <T> the instance type
-     * @param instance the work-in-progress counter
-     * @param fastPath called if the instance is not contended.
-     * @param queue called if the instance is contended to queue up work
-     * @param drain called if the instance transitions to the drain state successfully
-     * @throws Exception if the callbacks throw
-     */
-    public static <T> void queueDrainIf(AtomicInteger instance,
-            BooleanSupplier fastPath, BooleanSupplier queue, Runnable drain) throws Exception  {
-        if (instance.get() == 0 && instance.compareAndSet(0, 1)) {
-            if (fastPath.getAsBoolean()) {
-                return;
-            }
-            if (instance.decrementAndGet() == 0) {
-                return;
-            }
-        } else {
-            if (queue.getAsBoolean()) {
-                return;
-            }
-            if (instance.getAndIncrement() != 0) {
-                return;
-            }
-        }
-        drain.run();
-    }
-
-    /**
-     * A fast-path queue-drain serialization logic where the drain is looped until
-     * the instance state reaches 0 again.
-     * @param <T> the instance type
-     * @param instance the work-in-progress counter
-     * @param fastPath called if the instance is not contended.
-     * @param queue called if the instance is contended to queue up work
-     * @param drain called if the instance transitions to the drain state successfully
-     */
-    public static <T> void queueDrainLoop(AtomicInteger instance,
-            Runnable fastPath, Runnable queue, Runnable drain) {
-        if (instance.get() == 0 && instance.compareAndSet(0, 1)) {
-            fastPath.run();
-            if (instance.decrementAndGet() == 0) {
-                return;
-            }
-        } else {
-            queue.run();
-            if (instance.getAndIncrement() != 0) {
-                return;
-            }
-        }
-        int missed = 1;
-        for (;;) {
-            drain.run();
-            
-            missed = instance.addAndGet(-missed);
-            if (missed == 0) {
-                return;
-            }
-        }
+public final class QueueDrainHelper {
+    /** Utility class. */
+    private QueueDrainHelper() {
+        throw new IllegalStateException("No instances!");
     }
     
-    /**
-     * A fast-path queue-drain serialization logic with looped drain call and the ability to leave the state
-     * in fast-path/drain mode or not continue after the call to queue.
-     * @param <T> the instance type
-     * @param instance the work-in-progress counter
-     * @param fastPath called if the instance is not contended.
-     * @param queue called if the instance is contended to queue up work
-     * @param drain called if the instance transitions to the drain state successfully
-     * @throws Exception if the callbacks throw
-     */
-    public static <T> void queueDrainLoopIf(AtomicInteger instance,
-            BooleanSupplier fastPath, BooleanSupplier queue, BooleanSupplier drain) throws Exception {
-        if (instance.get() == 0 && instance.compareAndSet(0, 1)) {
-            if (fastPath.getAsBoolean()) {
-                return;
-            }
-            if (instance.decrementAndGet() == 0) {
-                return;
-            }
-        } else {
-            if (queue.getAsBoolean()) {
-                return;
-            }
-            if (instance.getAndIncrement() != 0) {
-                return;
-            }
-        }
-        int missed = 1;
-        for (;;) {
-            
-            if (drain.getAsBoolean()) {
-                return;
-            }
-            
-            missed = instance.addAndGet(-missed);
-            if (missed == 0) {
-                return;
-            }
-        }
-    }
-
     public static <T, U> void drainLoop(SimpleQueue<T> q, Subscriber<? super U> a, boolean delayError, QueueDrain<T, U> qd) {
         
         int missed = 1;
diff --git a/src/main/java/io/reactivex/schedulers/TestScheduler.java b/src/main/java/io/reactivex/schedulers/TestScheduler.java
index 4ea1c2b014..726aa81238 100644
--- a/src/main/java/io/reactivex/schedulers/TestScheduler.java
+++ b/src/main/java/io/reactivex/schedulers/TestScheduler.java
@@ -145,7 +145,7 @@ public Disposable schedule(Runnable run, long delayTime, TimeUnit unit) {
             final TimedRunnable timedAction = new TimedRunnable(this, time + unit.toNanos(delayTime), run, counter++);
             queue.add(timedAction);
             
-            return Disposables.from(new Runnable() {
+            return Disposables.fromRunnable(new Runnable() {
                 @Override
                 public void run() {
                     queue.remove(timedAction);
@@ -160,7 +160,7 @@ public Disposable schedule(Runnable run) {
             }
             final TimedRunnable timedAction = new TimedRunnable(this, 0, run, counter++);
             queue.add(timedAction);
-            return Disposables.from(new Runnable() {
+            return Disposables.fromRunnable(new Runnable() {
                 @Override
                 public void run() {
                     queue.remove(timedAction);
diff --git a/src/test/java/io/reactivex/disposables/CompositeDisposableTest.java b/src/test/java/io/reactivex/disposables/CompositeDisposableTest.java
index 6a1f6ddce8..297efdc083 100644
--- a/src/test/java/io/reactivex/disposables/CompositeDisposableTest.java
+++ b/src/test/java/io/reactivex/disposables/CompositeDisposableTest.java
@@ -33,7 +33,7 @@
     public void testSuccess() {
         final AtomicInteger counter = new AtomicInteger();
         CompositeDisposable s = new CompositeDisposable();
-        s.add(Disposables.from(new Runnable() {
+        s.add(Disposables.fromRunnable(new Runnable() {
 
             @Override
             public void run() {
@@ -42,7 +42,7 @@ public void run() {
 
         }));
 
-        s.add(Disposables.from(new Runnable() {
+        s.add(Disposables.fromRunnable(new Runnable() {
 
             @Override
             public void run() {
@@ -63,7 +63,7 @@ public void shouldUnsubscribeAll() throws InterruptedException {
         final int count = 10;
         final CountDownLatch start = new CountDownLatch(1);
         for (int i = 0; i < count; i++) {
-            s.add(Disposables.from(new Runnable() {
+            s.add(Disposables.fromRunnable(new Runnable() {
 
                 @Override
                 public void run() {
@@ -101,7 +101,7 @@ public void run() {
     public void testException() {
         final AtomicInteger counter = new AtomicInteger();
         CompositeDisposable s = new CompositeDisposable();
-        s.add(Disposables.from(new Runnable() {
+        s.add(Disposables.fromRunnable(new Runnable() {
 
             @Override
             public void run() {
@@ -110,7 +110,7 @@ public void run() {
 
         }));
 
-        s.add(Disposables.from(new Runnable() {
+        s.add(Disposables.fromRunnable(new Runnable() {
 
             @Override
             public void run() {
@@ -135,7 +135,7 @@ public void run() {
     public void testCompositeException() {
         final AtomicInteger counter = new AtomicInteger();
         CompositeDisposable s = new CompositeDisposable();
-        s.add(Disposables.from(new Runnable() {
+        s.add(Disposables.fromRunnable(new Runnable() {
 
             @Override
             public void run() {
@@ -144,7 +144,7 @@ public void run() {
 
         }));
 
-        s.add(Disposables.from(new Runnable() {
+        s.add(Disposables.fromRunnable(new Runnable() {
 
             @Override
             public void run() {
@@ -152,7 +152,7 @@ public void run() {
             }
         }));
 
-        s.add(Disposables.from(new Runnable() {
+        s.add(Disposables.fromRunnable(new Runnable() {
 
             @Override
             public void run() {
@@ -219,7 +219,7 @@ public void testClear() {
     public void testUnsubscribeIdempotence() {
         final AtomicInteger counter = new AtomicInteger();
         CompositeDisposable s = new CompositeDisposable();
-        s.add(Disposables.from(new Runnable() {
+        s.add(Disposables.fromRunnable(new Runnable() {
 
             @Override
             public void run() {
@@ -244,7 +244,7 @@ public void testUnsubscribeIdempotenceConcurrently()
 
         final int count = 10;
         final CountDownLatch start = new CountDownLatch(1);
-        s.add(Disposables.from(new Runnable() {
+        s.add(Disposables.fromRunnable(new Runnable() {
 
             @Override
             public void run() {
@@ -443,7 +443,7 @@ public void delete() {
     
     @Test
     public void disposeRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
             
             Runnable run = new Runnable() {
@@ -459,7 +459,7 @@ public void run() {
 
     @Test
     public void addRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
             
             Runnable run = new Runnable() {
@@ -475,7 +475,7 @@ public void run() {
 
     @Test
     public void addAllRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
             
             Runnable run = new Runnable() {
@@ -491,7 +491,7 @@ public void run() {
 
     @Test
     public void removeRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
             
             final Disposable d1 = Disposables.empty();
@@ -511,7 +511,7 @@ public void run() {
 
     @Test
     public void deleteRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
             
             final Disposable d1 = Disposables.empty();
@@ -531,7 +531,7 @@ public void run() {
 
     @Test
     public void clearRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
             
             final Disposable d1 = Disposables.empty();
@@ -551,7 +551,7 @@ public void run() {
     
     @Test
     public void addDisposeRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
             
             Runnable run = new Runnable() {
@@ -574,7 +574,7 @@ public void run() {
     
     @Test
     public void addAllDisposeRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
             
             Runnable run = new Runnable() {
@@ -597,7 +597,7 @@ public void run() {
     
     @Test
     public void removeDisposeRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
 
             final Disposable d1 = Disposables.empty();
@@ -624,7 +624,7 @@ public void run() {
     
     @Test
     public void deleteDisposeRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
 
             final Disposable d1 = Disposables.empty();
@@ -651,7 +651,7 @@ public void run() {
     
     @Test
     public void clearDisposeRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
 
             final Disposable d1 = Disposables.empty();
@@ -678,7 +678,7 @@ public void run() {
     
     @Test
     public void sizeDisposeRace() {
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 500; i++) {
             final CompositeDisposable cd = new CompositeDisposable();
 
             final Disposable d1 = Disposables.empty();
@@ -707,7 +707,7 @@ public void run() {
     public void disposeThrowsIAE() {
         CompositeDisposable cd = new CompositeDisposable();
         
-        cd.add(Disposables.from(new Action() {
+        cd.add(Disposables.fromAction(new Action() {
             @Override
             public void run() throws Exception {
                 throw new IllegalArgumentException();
@@ -732,7 +732,7 @@ public void run() throws Exception {
     public void disposeThrowsError() {
         CompositeDisposable cd = new CompositeDisposable();
         
-        cd.add(Disposables.from(new Action() {
+        cd.add(Disposables.fromAction(new Action() {
             @Override
             public void run() throws Exception {
                 throw new AssertionError();
@@ -757,7 +757,7 @@ public void run() throws Exception {
     public void disposeThrowsCheckedException() {
         CompositeDisposable cd = new CompositeDisposable();
         
-        cd.add(Disposables.from(new Action() {
+        cd.add(Disposables.fromAction(new Action() {
             @Override
             public void run() throws Exception {
                 throw new IOException();
diff --git a/src/test/java/io/reactivex/disposables/DisposablesTest.java b/src/test/java/io/reactivex/disposables/DisposablesTest.java
index 30c0ae3323..6f4d725178 100644
--- a/src/test/java/io/reactivex/disposables/DisposablesTest.java
+++ b/src/test/java/io/reactivex/disposables/DisposablesTest.java
@@ -25,13 +25,12 @@
 import io.reactivex.functions.Action;
 import io.reactivex.schedulers.Schedulers;
 
-
 public class DisposablesTest {
 
     @Test
     public void testUnsubscribeOnlyOnce() {
         Runnable dispose = mock(Runnable.class);
-        Disposable subscription = Disposables.from(dispose);
+        Disposable subscription = Disposables.fromRunnable(dispose);
         subscription.dispose();
         subscription.dispose();
         verify(dispose, times(1)).run();
@@ -70,7 +69,7 @@ public void run() throws Exception {
         
         AtomicAction aa = new AtomicAction();
         
-        Disposables.from(aa).dispose();
+        Disposables.fromAction(aa).dispose();
         
         assertTrue(aa.get());
     }
@@ -78,7 +77,7 @@ public void run() throws Exception {
     @Test
     public void fromActionThrows() {
         try {
-            Disposables.from(new Action() {
+            Disposables.fromAction(new Action() {
                 @Override
                 public void run() throws Exception {
                     throw new IllegalArgumentException();
@@ -90,7 +89,7 @@ public void run() throws Exception {
         }
         
         try {
-            Disposables.from(new Action() {
+            Disposables.fromAction(new Action() {
                 @Override
                 public void run() throws Exception {
                     throw new InternalError();
@@ -102,7 +101,7 @@ public void run() throws Exception {
         }
         
         try {
-            Disposables.from(new Action() {
+            Disposables.fromAction(new Action() {
                 @Override
                 public void run() throws Exception {
                     throw new IOException();
diff --git a/src/test/java/io/reactivex/internal/disposables/ListCompositeDisposableTest.java b/src/test/java/io/reactivex/internal/disposables/ListCompositeDisposableTest.java
index 26a56ba85e..8e28a0d8a1 100644
--- a/src/test/java/io/reactivex/internal/disposables/ListCompositeDisposableTest.java
+++ b/src/test/java/io/reactivex/internal/disposables/ListCompositeDisposableTest.java
@@ -22,6 +22,7 @@
 import io.reactivex.TestHelper;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.*;
+import io.reactivex.schedulers.Schedulers;
 
 public class ListCompositeDisposableTest {
 
@@ -175,4 +176,239 @@ public void remove() {
 
         assertFalse(lcd.delete(d));
     }
+
+    @Test
+    public void disposeRace() {
+        for (int i = 0; i < 500; i++) {
+            final ListCompositeDisposable cd = new ListCompositeDisposable();
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void addRace() {
+        for (int i = 0; i < 500; i++) {
+            final ListCompositeDisposable cd = new ListCompositeDisposable();
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.add(Disposables.empty());
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void addAllRace() {
+        for (int i = 0; i < 500; i++) {
+            final ListCompositeDisposable cd = new ListCompositeDisposable();
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.addAll(Disposables.empty());
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void removeRace() {
+        for (int i = 0; i < 500; i++) {
+            final ListCompositeDisposable cd = new ListCompositeDisposable();
+            
+            final Disposable d1 = Disposables.empty();
+            
+            cd.add(d1);
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.remove(d1);
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void deleteRace() {
+        for (int i = 0; i < 500; i++) {
+            final ListCompositeDisposable cd = new ListCompositeDisposable();
+            
+            final Disposable d1 = Disposables.empty();
+
+            cd.add(d1);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.delete(d1);
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void clearRace() {
+        for (int i = 0; i < 500; i++) {
+            final ListCompositeDisposable cd = new ListCompositeDisposable();
+            
+            final Disposable d1 = Disposables.empty();
+
+            cd.add(d1);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.clear();
+                }
+            };
+            
+            TestHelper.race(run, run, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void addDisposeRace() {
+        for (int i = 0; i < 500; i++) {
+            final ListCompositeDisposable cd = new ListCompositeDisposable();
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+
+            Runnable run2 = new Runnable() {
+                @Override
+                public void run() {
+                    cd.add(Disposables.empty());
+                }
+            };
+
+            TestHelper.race(run, run2, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void addAllDisposeRace() {
+        for (int i = 0; i < 500; i++) {
+            final ListCompositeDisposable cd = new ListCompositeDisposable();
+            
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+
+            Runnable run2 = new Runnable() {
+                @Override
+                public void run() {
+                    cd.addAll(Disposables.empty());
+                }
+            };
+
+            TestHelper.race(run, run2, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void removeDisposeRace() {
+        for (int i = 0; i < 500; i++) {
+            final ListCompositeDisposable cd = new ListCompositeDisposable();
+
+            final Disposable d1 = Disposables.empty();
+
+            cd.add(d1);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+
+            Runnable run2 = new Runnable() {
+                @Override
+                public void run() {
+                    cd.remove(d1);
+                }
+            };
+
+            TestHelper.race(run, run2, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void deleteDisposeRace() {
+        for (int i = 0; i < 500; i++) {
+            final ListCompositeDisposable cd = new ListCompositeDisposable();
+
+            final Disposable d1 = Disposables.empty();
+
+            cd.add(d1);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+
+            Runnable run2 = new Runnable() {
+                @Override
+                public void run() {
+                    cd.delete(d1);
+                }
+            };
+
+            TestHelper.race(run, run2, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void clearDisposeRace() {
+        for (int i = 0; i < 500; i++) {
+            final ListCompositeDisposable cd = new ListCompositeDisposable();
+
+            final Disposable d1 = Disposables.empty();
+
+            cd.add(d1);
+
+            Runnable run = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+
+            Runnable run2 = new Runnable() {
+                @Override
+                public void run() {
+                    cd.clear();
+                }
+            };
+
+            TestHelper.race(run, run2, Schedulers.io());
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/functions/FunctionsTest.java b/src/test/java/io/reactivex/internal/functions/FunctionsTest.java
new file mode 100644
index 0000000000..a0961d3925
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/functions/FunctionsTest.java
@@ -0,0 +1,192 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.functions;
+
+import static org.junit.Assert.*;
+
+import java.lang.reflect.Method;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions.*;
+import io.reactivex.internal.util.ExceptionHelper;
+
+public class FunctionsTest {
+    @Test
+    public void utilityClass() {
+        TestHelper.checkUtilityClass(Functions.class);
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void hashSetCallableEnum() {
+        // inlined TestHelper.checkEnum due to access restrictions
+        try {
+            Method m = Functions.HashSetCallable.class.getMethod("values");
+            m.setAccessible(true);
+            Method e = Functions.HashSetCallable.class.getMethod("valueOf", String.class);
+            m.setAccessible(true);
+            
+            for (Enum<HashSetCallable> o : (Enum<HashSetCallable>[])m.invoke(null)) {
+                assertSame(o, e.invoke(null, o.name()));
+            }
+            
+        } catch (Throwable ex) {
+            throw ExceptionHelper.wrapOrThrow(ex);
+        }
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void naturalComparatorEnum() {
+        // inlined TestHelper.checkEnum due to access restrictions
+        try {
+            Method m = Functions.NaturalComparator.class.getMethod("values");
+            m.setAccessible(true);
+            Method e = Functions.NaturalComparator.class.getMethod("valueOf", String.class);
+            m.setAccessible(true);
+            
+            for (Enum<NaturalComparator> o : (Enum<NaturalComparator>[])m.invoke(null)) {
+                assertSame(o, e.invoke(null, o.name()));
+            }
+            
+        } catch (Throwable ex) {
+            throw ExceptionHelper.wrapOrThrow(ex);
+        }
+    }
+
+    @Test
+    public void booleanSupplierPredicateReverse() throws Exception {
+        BooleanSupplier s = new BooleanSupplier() {
+            @Override
+            public boolean getAsBoolean() throws Exception {
+                return false;
+            }
+        };
+        
+        assertTrue(Functions.predicateReverseFor(s).test(1));
+        
+        s = new BooleanSupplier() {
+            @Override
+            public boolean getAsBoolean() throws Exception {
+                return true;
+            }
+        };
+        
+        assertFalse(Functions.predicateReverseFor(s).test(1));
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void toFunction2() throws Exception {
+        Functions.toFunction(new BiFunction<Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1, Integer t2) throws Exception {
+                return null;
+            }
+        }).apply(new Object[20]);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void toFunction3() throws Exception {
+        Functions.toFunction(new Function3<Integer, Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1, Integer t2, Integer t3) throws Exception {
+                return null;
+            }
+        }).apply(new Object[20]);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void toFunction4() throws Exception {
+        Functions.toFunction(new Function4<Integer, Integer, Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1, Integer t2, Integer t3, Integer t4) throws Exception {
+                return null;
+            }
+        }).apply(new Object[20]);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void toFunction5() throws Exception {
+        Functions.toFunction(new Function5<Integer, Integer, Integer, Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1, Integer t2, Integer t3, Integer t4, Integer t5) throws Exception {
+                return null;
+            }
+        }).apply(new Object[20]);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void toFunction6() throws Exception {
+        Functions.toFunction(new Function6<Integer, Integer, Integer, Integer, Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1, Integer t2, Integer t3, Integer t4, Integer t5, Integer t6) throws Exception {
+                return null;
+            }
+        }).apply(new Object[20]);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void toFunction7() throws Exception {
+        Functions.toFunction(new Function7<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1, Integer t2, Integer t3, Integer t4, Integer t5, Integer t6, Integer t7) throws Exception {
+                return null;
+            }
+        }).apply(new Object[20]);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void toFunction8() throws Exception {
+        Functions.toFunction(new Function8<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1, Integer t2, Integer t3, Integer t4, Integer t5, Integer t6, Integer t7, Integer t8) throws Exception {
+                return null;
+            }
+        }).apply(new Object[20]);
+    }
+    
+    @Test(expected = IllegalArgumentException.class)
+    public void toFunction9() throws Exception {
+        Functions.toFunction(new Function9<Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer>() {
+            @Override
+            public Integer apply(Integer t1, Integer t2, Integer t3, Integer t4, Integer t5, Integer t6, Integer t7, Integer t8, Integer t9) throws Exception {
+                return null;
+            }
+        }).apply(new Object[20]);
+    }
+
+    @Test
+    public void identityFunctionToString() {
+        assertEquals("IdentityFunction", Functions.identity().toString());
+    }
+
+    @Test
+    public void emptyActionToString() {
+        assertEquals("EmptyAction", Functions.EMPTY_ACTION.toString());
+    }
+
+    @Test
+    public void emptyRunnableToString() {
+        assertEquals("EmptyRunnable", Functions.EMPTY_RUNNABLE.toString());
+    }
+
+    @Test
+    public void emptyConsumerToString() {
+        assertEquals("EmptyConsumer", Functions.EMPTY_CONSUMER.toString());
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java b/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java
new file mode 100644
index 0000000000..c1275074bf
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java
@@ -0,0 +1,42 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.functions;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+import io.reactivex.TestHelper;
+
+public class ObjectHelperTest {
+
+    @Test
+    public void utilityClass() {
+        TestHelper.checkUtilityClass(ObjectHelper.class);
+    }
+    
+    @Test
+    public void hashCodeOf() {
+        assertEquals(0, ObjectHelper.hashCode(null));
+        
+        assertEquals(((Integer)1).hashCode(), ObjectHelper.hashCode(1));
+    }
+    
+    @Test
+    public void compare() {
+        
+        assertEquals(-1, ObjectHelper.compare(0, 2));
+        assertEquals(0, ObjectHelper.compare(0, 0));
+        assertEquals(1, ObjectHelper.compare(2, 0));
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableSubscribeOnTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableSubscribeOnTest.java
new file mode 100644
index 0000000000..cd194ea9e8
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableSubscribeOnTest.java
@@ -0,0 +1,49 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.completable;
+
+import static org.junit.Assert.assertTrue;
+
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class CompletableSubscribeOnTest {
+
+    @Test
+    public void normal() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        try {
+            TestScheduler scheduler = new TestScheduler();
+            
+            TestSubscriber<Void> ts = Completable.complete()
+            .subscribeOn(scheduler)
+            .test();
+            
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+            
+            ts.assertResult();
+            
+            assertTrue(list.toString(), list.isEmpty());
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableToFutureTest.java b/src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableToFutureTest.java
index dddfbf5191..ef060cb4b6 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableToFutureTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableToFutureTest.java
@@ -34,33 +34,30 @@ public void constructorShouldBePrivate() {
 //        TestHelper.checkUtilityClass(FlowableToFuture.class);
     }
 
-    static <T> Future<T> toFuture(Flowable<T> f) {
-        return f.toFuture();
-    }
-    
     @Test
     public void testToFuture() throws InterruptedException, ExecutionException {
         Flowable<String> obs = Flowable.just("one");
-        Future<String> f = toFuture(obs);
+        Future<String> f = obs.toFuture();
         assertEquals("one", f.get());
     }
 
     @Test
     public void testToFutureList() throws InterruptedException, ExecutionException {
         Flowable<String> obs = Flowable.just("one", "two", "three");
-        Future<List<String>> f = toFuture(obs.toList());
+        Future<List<String>> f = obs.toList().toFuture();
         assertEquals("one", f.get().get(0));
         assertEquals("two", f.get().get(1));
         assertEquals("three", f.get().get(2));
     }
 
-    @Test(expected = IndexOutOfBoundsException.class)
+    @Test(/* timeout = 5000, */expected = IndexOutOfBoundsException.class)
     public void testExceptionWithMoreThanOneElement() throws Throwable {
         Flowable<String> obs = Flowable.just("one", "two");
-        Future<String> f = toFuture(obs);
+        Future<String> f = obs.toFuture();
         try {
             // we expect an exception since there are more than 1 element
             f.get();
+            fail("Should have thrown!");
         }
         catch(ExecutionException e) {
             throw e.getCause();
@@ -79,7 +76,7 @@ public void subscribe(Subscriber<? super String> observer) {
             }
         });
 
-        Future<String> f = toFuture(obs);
+        Future<String> f = obs.toFuture();
         try {
             f.get();
             fail("expected exception");
@@ -91,7 +88,7 @@ public void subscribe(Subscriber<? super String> observer) {
     @Test(expected=CancellationException.class)
     public void testGetAfterCancel() throws Exception {
         Flowable<String> obs = Flowable.never();
-        Future<String> f = toFuture(obs);
+        Future<String> f = obs.toFuture();
         boolean cancelled = f.cancel(true);
         assertTrue(cancelled);  // because OperationNeverComplete never does
         f.get();                // Future.get() docs require this to throw
@@ -100,7 +97,7 @@ public void testGetAfterCancel() throws Exception {
     @Test(expected=CancellationException.class)
     public void testGetWithTimeoutAfterCancel() throws Exception {
         Flowable<String> obs = Flowable.never();
-        Future<String> f = toFuture(obs);
+        Future<String> f = obs.toFuture();
         boolean cancelled = f.cancel(true);
         assertTrue(cancelled);  // because OperationNeverComplete never does
         f.get(Long.MAX_VALUE, TimeUnit.NANOSECONDS);    // Future.get() docs require this to throw
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
index 411caf5877..930cfd8057 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableUsingTest.java
@@ -207,7 +207,7 @@ private void performTestUsingWithObservableFactoryError(boolean disposeEagerly)
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 
@@ -245,7 +245,7 @@ private void performTestUsingWithObservableFactoryErrorInOnSubscribe(boolean dis
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 
diff --git a/src/test/java/io/reactivex/internal/operators/observable/BlockingObservableToFutureTest.java b/src/test/java/io/reactivex/internal/operators/observable/BlockingObservableToFutureTest.java
new file mode 100644
index 0000000000..27bc22629f
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/observable/BlockingObservableToFutureTest.java
@@ -0,0 +1,126 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.reactivex.internal.operators.observable;
+
+import static org.junit.Assert.*;
+
+import java.util.*;
+import java.util.concurrent.*;
+
+import org.junit.*;
+
+import io.reactivex.Observable;
+import io.reactivex.ObservableSource;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposables;
+import io.reactivex.exceptions.TestException;
+
+public class BlockingObservableToFutureTest {
+    @Ignore("No separate file")
+    @Test
+    public void constructorShouldBePrivate() {
+//        TestHelper.checkUtilityClass(FlowableToFuture.class);
+    }
+
+    @Test
+    public void testToFuture() throws InterruptedException, ExecutionException {
+        Observable<String> obs = Observable.just("one");
+        Future<String> f = obs.toFuture();
+        assertEquals("one", f.get());
+    }
+
+    @Test
+    public void testToFutureList() throws InterruptedException, ExecutionException {
+        Observable<String> obs = Observable.just("one", "two", "three");
+        Future<List<String>> f = obs.toList().toFuture();
+        assertEquals("one", f.get().get(0));
+        assertEquals("two", f.get().get(1));
+        assertEquals("three", f.get().get(2));
+    }
+
+    @Test(/* timeout = 5000, */expected = IndexOutOfBoundsException.class)
+    public void testExceptionWithMoreThanOneElement() throws Throwable {
+        Observable<String> obs = Observable.just("one", "two");
+        Future<String> f = obs.toFuture();
+        try {
+            // we expect an exception since there are more than 1 element
+            f.get();
+            fail("Should have thrown!");
+        }
+        catch(ExecutionException e) {
+            throw e.getCause();
+        }
+    }
+
+    @Test
+    public void testToFutureWithException() {
+        Observable<String> obs = Observable.unsafeCreate(new ObservableSource<String>() {
+
+            @Override
+            public void subscribe(Observer<? super String> observer) {
+                observer.onSubscribe(Disposables.empty());
+                observer.onNext("one");
+                observer.onError(new TestException());
+            }
+        });
+
+        Future<String> f = obs.toFuture();
+        try {
+            f.get();
+            fail("expected exception");
+        } catch (Throwable e) {
+            assertEquals(TestException.class, e.getCause().getClass());
+        }
+    }
+
+    @Test(expected=CancellationException.class)
+    public void testGetAfterCancel() throws Exception {
+        Observable<String> obs = Observable.never();
+        Future<String> f = obs.toFuture();
+        boolean cancelled = f.cancel(true);
+        assertTrue(cancelled);  // because OperationNeverComplete never does
+        f.get();                // Future.get() docs require this to throw
+    }
+
+    @Test(expected=CancellationException.class)
+    public void testGetWithTimeoutAfterCancel() throws Exception {
+        Observable<String> obs = Observable.never();
+        Future<String> f = obs.toFuture();
+        boolean cancelled = f.cancel(true);
+        assertTrue(cancelled);  // because OperationNeverComplete never does
+        f.get(Long.MAX_VALUE, TimeUnit.NANOSECONDS);    // Future.get() docs require this to throw
+    }
+
+    @Test(expected = NoSuchElementException.class)
+    public void testGetWithEmptyFlowable() throws Throwable {
+        Observable<String> obs = Observable.empty();
+        Future<String> f = obs.toFuture();
+        try {
+            f.get();
+        }
+        catch(ExecutionException e) {
+            throw e.getCause();
+        }
+    }
+
+    @Ignore("null value is not allowed")
+    @Test
+    public void testGetWithASingleNullItem() throws Exception {
+        Observable<String> obs = Observable.just((String)null);
+        Future<String> f = obs.toFuture();
+        assertEquals(null, f.get());
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java
index f046f65040..e0f5189395 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableMergeTest.java
@@ -132,7 +132,7 @@ public void testUnSubscribeObservableOfObservables() throws InterruptedException
             @Override
             public void subscribe(final Observer<? super Observable<Long>> NbpObserver) {
                 // verbose on purpose so I can track the inside of it
-                final Disposable s = Disposables.from(new Runnable() {
+                final Disposable s = Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         System.out.println("*** unsubscribed");
@@ -502,7 +502,7 @@ public void subscribe(final Observer<? super Long> child) {
                 .subscribe(new Observer<Long>() {
                     @Override
                     public void onSubscribe(final Disposable s) {
-                        child.onSubscribe(Disposables.from(new Runnable() {
+                        child.onSubscribe(Disposables.fromRunnable(new Runnable() {
                             @Override
                             public void run() {
                                 unsubscribed.set(true);
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java
index 432aec6e2d..8cdbe43730 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableRefCountTest.java
@@ -301,7 +301,7 @@ public void accept(Disposable s) {
             @Override
             public void subscribe(Observer<? super Long> NbpSubscriber) {
                 final AtomicBoolean cancel = new AtomicBoolean();
-                NbpSubscriber.onSubscribe(Disposables.from(new Runnable() {
+                NbpSubscriber.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         cancel.set(true);
@@ -329,7 +329,7 @@ public void onlyFirstShouldSubscribeAndLastUnsubscribe() {
             @Override
             public void subscribe(Observer<? super Integer> NbpObserver) {
                 subscriptionCount.incrementAndGet();
-                NbpObserver.onSubscribe(Disposables.from(new Runnable() {
+                NbpObserver.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                             unsubscriptionCount.incrementAndGet();
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java
index 15d1d2d3bc..4a0b8fe81e 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableRetryTest.java
@@ -429,7 +429,7 @@ public void testRetryAllowsSubscriptionAfterAllSubscriptionsUnsubscribed() throw
             @Override
             public void subscribe(Observer<? super String> s) {
                 subsCount.incrementAndGet();
-                s.onSubscribe(Disposables.from(new Runnable() {
+                s.onSubscribe(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                             subsCount.decrementAndGet();
@@ -533,7 +533,7 @@ public SlowObservable(int emitDelay, int countNext) {
         @Override
         public void subscribe(final Observer<? super Long> NbpSubscriber) {
             final AtomicBoolean terminate = new AtomicBoolean(false);
-            NbpSubscriber.onSubscribe(Disposables.from(new Runnable() {
+            NbpSubscriber.onSubscribe(Disposables.fromRunnable(new Runnable() {
                 @Override
                 public void run() {
                         terminate.set(true);
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java
index 716ea9033d..519b642ff4 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java
@@ -206,7 +206,7 @@ private void performTestUsingWithObservableFactoryError(boolean disposeEagerly)
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 
@@ -244,7 +244,7 @@ private void performTestUsingWithObservableFactoryErrorInOnSubscribe(boolean dis
         Callable<Disposable> resourceFactory = new Callable<Disposable>() {
             @Override
             public Disposable call() {
-                return Disposables.from(unsubscribe);
+                return Disposables.fromRunnable(unsubscribe);
             }
         };
 
diff --git a/src/test/java/io/reactivex/internal/operators/single/SingleSubscribeOnTest.java b/src/test/java/io/reactivex/internal/operators/single/SingleSubscribeOnTest.java
new file mode 100644
index 0000000000..b69eb45daa
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/single/SingleSubscribeOnTest.java
@@ -0,0 +1,49 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.single;
+
+import static org.junit.Assert.assertTrue;
+
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.schedulers.TestScheduler;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class SingleSubscribeOnTest {
+
+    @Test
+    public void normal() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        try {
+            TestScheduler scheduler = new TestScheduler();
+            
+            TestSubscriber<Integer> ts = Single.just(1)
+            .subscribeOn(scheduler)
+            .test();
+            
+            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);
+            
+            ts.assertResult(1);
+            
+            assertTrue(list.toString(), list.isEmpty());
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/util/AtomicThrowableTest.java b/src/test/java/io/reactivex/internal/util/AtomicThrowableTest.java
new file mode 100644
index 0000000000..17f13da497
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/util/AtomicThrowableTest.java
@@ -0,0 +1,32 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.util;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class AtomicThrowableTest {
+
+    @Test
+    public void isTerminated() {
+        AtomicThrowable ex = new AtomicThrowable();
+        
+        assertFalse(ex.isTerminated());
+        
+        assertNull(ex.terminate());
+        
+        assertTrue(ex.isTerminated());
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/util/BackpressureHelperTest.java b/src/test/java/io/reactivex/internal/util/BackpressureHelperTest.java
index 4605fbab5c..ea4afce6f1 100644
--- a/src/test/java/io/reactivex/internal/util/BackpressureHelperTest.java
+++ b/src/test/java/io/reactivex/internal/util/BackpressureHelperTest.java
@@ -17,9 +17,14 @@
 
 import static org.junit.Assert.assertEquals;
 
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+
 import org.junit.*;
 
 import io.reactivex.TestHelper;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.schedulers.Schedulers;
 
 public class BackpressureHelperTest {
     @Ignore("BackpressureHelper is an enum")
@@ -45,4 +50,102 @@ public void testMultiplyCap() {
         assertEquals(Long.MAX_VALUE, BackpressureHelper.multiplyCap(1L << 32, 1L << 32));
 
     }
+    
+    @Test
+    public void producedMore() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            AtomicLong requested = new AtomicLong(1);
+            
+            assertEquals(0, BackpressureHelper.produced(requested, 2));
+            
+            TestHelper.assertError(list, 0, IllegalStateException.class, "More produced than requested: -1");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void requestProduceRace() {
+        final AtomicLong requested = new AtomicLong(1);
+
+        for (int i = 0; i < 500; i++) {
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    BackpressureHelper.produced(requested, 1);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    BackpressureHelper.add(requested, 1);
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+        }
+    }
+    
+    @Test
+    public void requestCancelProduceRace() {
+        final AtomicLong requested = new AtomicLong(1);
+
+        for (int i = 0; i < 500; i++) {
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    BackpressureHelper.produced(requested, 1);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    BackpressureHelper.addCancel(requested, 1);
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+        }
+    }
+    
+    @Test
+    public void utilityClass() {
+        TestHelper.checkUtilityClass(BackpressureHelper.class);
+    }
+    
+    @Test
+    public void capped() {
+        final AtomicLong requested = new AtomicLong(Long.MIN_VALUE);
+
+        assertEquals(Long.MIN_VALUE, BackpressureHelper.addCancel(requested, 1));
+        assertEquals(Long.MIN_VALUE, BackpressureHelper.addCancel(requested, Long.MAX_VALUE));
+        
+        requested.set(0);
+        
+        assertEquals(0, BackpressureHelper.addCancel(requested, Long.MAX_VALUE));
+        assertEquals(Long.MAX_VALUE, BackpressureHelper.addCancel(requested, 1));
+        assertEquals(Long.MAX_VALUE, BackpressureHelper.addCancel(requested, Long.MAX_VALUE));
+        
+        requested.set(0);
+        
+        assertEquals(0, BackpressureHelper.add(requested, Long.MAX_VALUE));
+        assertEquals(Long.MAX_VALUE, BackpressureHelper.add(requested, 1));
+        assertEquals(Long.MAX_VALUE, BackpressureHelper.add(requested, Long.MAX_VALUE));
+        
+        assertEquals(Long.MAX_VALUE, BackpressureHelper.produced(requested, 1));
+        assertEquals(Long.MAX_VALUE, BackpressureHelper.produced(requested, Long.MAX_VALUE));
+    }
+    
+    @Test
+    public void multiplyCap() {
+        assertEquals(Long.MAX_VALUE, BackpressureHelper.multiplyCap(3, Long.MAX_VALUE >> 1));
+        
+        assertEquals(Long.MAX_VALUE, BackpressureHelper.multiplyCap(1, Long.MAX_VALUE));
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/util/ExceptionHelperTest.java b/src/test/java/io/reactivex/internal/util/ExceptionHelperTest.java
new file mode 100644
index 0000000000..b098b09365
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/util/ExceptionHelperTest.java
@@ -0,0 +1,49 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.util;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.schedulers.Schedulers;
+
+public class ExceptionHelperTest {
+    @Test
+    public void utilityClass() {
+        TestHelper.checkUtilityClass(ExceptionHelper.class);
+    }
+    
+    @Test
+    public void addRace() {
+        for (int i = 0; i < 500; i++) {
+            
+            final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
+            
+            final TestException ex = new TestException();
+           
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    assertTrue(ExceptionHelper.addThrowable(error, ex));
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.single());
+        }
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/util/HalfSerializerObserverTest.java b/src/test/java/io/reactivex/internal/util/HalfSerializerObserverTest.java
new file mode 100644
index 0000000000..bf9939bc60
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/util/HalfSerializerObserverTest.java
@@ -0,0 +1,273 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+package io.reactivex.internal.util;
+
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.observers.TestObserver;
+import io.reactivex.schedulers.Schedulers;
+
+public class HalfSerializerObserverTest {
+
+    @Test
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public void reentrantOnNextOnNext() {
+        final AtomicInteger wip = new AtomicInteger();
+        final AtomicThrowable error = new AtomicThrowable();
+        
+        final Observer[] a = { null };
+
+        final TestObserver ts = new TestObserver();
+        
+        Observer s = new Observer() {
+            @Override
+            public void onSubscribe(Disposable s) {
+                ts.onSubscribe(s);
+            }
+            
+            @Override
+            public void onNext(Object t) {
+                if (t.equals(1)) {
+                    HalfSerializer.onNext(a[0], 2, wip, error);
+                }
+                ts.onNext(t);
+            }
+            
+            @Override
+            public void onError(Throwable t) {
+                ts.onError(t);
+            }
+            
+            @Override
+            public void onComplete() {
+                ts.onComplete();
+            }
+        };
+        
+        a[0] = s;
+        
+        s.onSubscribe(Disposables.empty());
+        
+        HalfSerializer.onNext(s, 1, wip, error);
+        
+        ts.assertValue(1).assertNoErrors().assertNotComplete();
+    }
+    
+    @Test
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public void reentrantOnNextOnError() {
+        final AtomicInteger wip = new AtomicInteger();
+        final AtomicThrowable error = new AtomicThrowable();
+        
+        final Observer[] a = { null };
+
+        final TestObserver ts = new TestObserver();
+        
+        Observer s = new Observer() {
+            @Override
+            public void onSubscribe(Disposable s) {
+                ts.onSubscribe(s);
+            }
+            
+            @Override
+            public void onNext(Object t) {
+                if (t.equals(1)) {
+                    HalfSerializer.onError(a[0], new TestException(), wip, error);
+                }
+                ts.onNext(t);
+            }
+            
+            @Override
+            public void onError(Throwable t) {
+                ts.onError(t);
+            }
+            
+            @Override
+            public void onComplete() {
+                ts.onComplete();
+            }
+        };
+        
+        a[0] = s;
+
+        s.onSubscribe(Disposables.empty());
+
+        HalfSerializer.onNext(s, 1, wip, error);
+        
+        ts.assertFailure(TestException.class, 1);
+    }
+
+    @Test
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public void reentrantOnNextOnComplete() {
+        final AtomicInteger wip = new AtomicInteger();
+        final AtomicThrowable error = new AtomicThrowable();
+        
+        final Observer[] a = { null };
+
+        final TestObserver ts = new TestObserver();
+        
+        Observer s = new Observer() {
+            @Override
+            public void onSubscribe(Disposable s) {
+                ts.onSubscribe(s);
+            }
+            
+            @Override
+            public void onNext(Object t) {
+                if (t.equals(1)) {
+                    HalfSerializer.onComplete(a[0], wip, error);
+                }
+                ts.onNext(t);
+            }
+            
+            @Override
+            public void onError(Throwable t) {
+                ts.onError(t);
+            }
+            
+            @Override
+            public void onComplete() {
+                ts.onComplete();
+            }
+        };
+        
+        a[0] = s;
+
+        s.onSubscribe(Disposables.empty());
+
+        HalfSerializer.onNext(s, 1, wip, error);
+        
+        ts.assertResult(1);
+    }
+
+    @Test
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public void reentrantErrorOnError() {
+        final AtomicInteger wip = new AtomicInteger();
+        final AtomicThrowable error = new AtomicThrowable();
+        
+        final Observer[] a = { null };
+
+        final TestObserver ts = new TestObserver();
+        
+        Observer s = new Observer() {
+            @Override
+            public void onSubscribe(Disposable s) {
+                ts.onSubscribe(s);
+            }
+            
+            @Override
+            public void onNext(Object t) {
+                ts.onNext(t);
+            }
+            
+            @Override
+            public void onError(Throwable t) {
+                ts.onError(t);
+                HalfSerializer.onError(a[0], new IOException(), wip, error);
+            }
+            
+            @Override
+            public void onComplete() {
+                ts.onComplete();
+            }
+        };
+        
+        a[0] = s;
+
+        s.onSubscribe(Disposables.empty());
+
+        HalfSerializer.onError(s, new TestException(), wip, error);
+        
+        ts.assertFailure(TestException.class);
+    }
+    
+    @Test
+    public void onNextOnCompleteRace() {
+        for (int i = 0; i < 500; i++) {
+
+            final AtomicInteger wip = new AtomicInteger();
+            final AtomicThrowable error = new AtomicThrowable();
+            
+            final TestObserver<Integer> ts = new TestObserver<Integer>();
+            ts.onSubscribe(Disposables.empty());
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    HalfSerializer.onNext(ts, 1, wip, error);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    HalfSerializer.onComplete(ts, wip, error);
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+            
+            ts.assertComplete().assertNoErrors();
+            
+            assertTrue(ts.valueCount() <= 1);
+        }
+    }
+    
+    @Test
+    public void onErrorOnCompleteRace() {
+        for (int i = 0; i < 500; i++) {
+
+            final AtomicInteger wip = new AtomicInteger();
+            final AtomicThrowable error = new AtomicThrowable();
+            
+            final TestObserver<Integer> ts = new TestObserver<Integer>();
+
+            ts.onSubscribe(Disposables.empty());
+            
+            final TestException ex = new TestException();
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    HalfSerializer.onError(ts, ex, wip, error);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    HalfSerializer.onComplete(ts, wip, error);
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+
+            if (ts.completions() != 0) {
+                ts.assertResult();
+            } else {
+                ts.assertFailure(TestException.class);
+            }
+        }
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/util/HalfSerializerSubscriberTest.java b/src/test/java/io/reactivex/internal/util/HalfSerializerSubscriberTest.java
new file mode 100644
index 0000000000..654de5b059
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/util/HalfSerializerSubscriberTest.java
@@ -0,0 +1,279 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+package io.reactivex.internal.util;
+
+import static org.junit.Assert.*;
+
+import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.Test;
+import org.reactivestreams.*;
+
+import io.reactivex.TestHelper;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.schedulers.Schedulers;
+import io.reactivex.subscribers.TestSubscriber;
+
+public class HalfSerializerSubscriberTest {
+
+    @Test
+    public void utilityClass() {
+        TestHelper.checkUtilityClass(HalfSerializer.class);
+    }
+    
+    @Test
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public void reentrantOnNextOnNext() {
+        final AtomicInteger wip = new AtomicInteger();
+        final AtomicThrowable error = new AtomicThrowable();
+        
+        final Subscriber[] a = { null };
+
+        final TestSubscriber ts = new TestSubscriber();
+        
+        Subscriber s = new Subscriber() {
+            @Override
+            public void onSubscribe(Subscription s) {
+                ts.onSubscribe(s);
+            }
+            
+            @Override
+            public void onNext(Object t) {
+                if (t.equals(1)) {
+                    HalfSerializer.onNext(a[0], 2, wip, error);
+                }
+                ts.onNext(t);
+            }
+            
+            @Override
+            public void onError(Throwable t) {
+                ts.onError(t);
+            }
+            
+            @Override
+            public void onComplete() {
+                ts.onComplete();
+            }
+        };
+        
+        a[0] = s;
+        
+        s.onSubscribe(new BooleanSubscription());
+        
+        HalfSerializer.onNext(s, 1, wip, error);
+        
+        ts.assertValue(1).assertNoErrors().assertNotComplete();
+    }
+    
+    @Test
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public void reentrantOnNextOnError() {
+        final AtomicInteger wip = new AtomicInteger();
+        final AtomicThrowable error = new AtomicThrowable();
+        
+        final Subscriber[] a = { null };
+
+        final TestSubscriber ts = new TestSubscriber();
+        
+        Subscriber s = new Subscriber() {
+            @Override
+            public void onSubscribe(Subscription s) {
+                ts.onSubscribe(s);
+            }
+            
+            @Override
+            public void onNext(Object t) {
+                if (t.equals(1)) {
+                    HalfSerializer.onError(a[0], new TestException(), wip, error);
+                }
+                ts.onNext(t);
+            }
+            
+            @Override
+            public void onError(Throwable t) {
+                ts.onError(t);
+            }
+            
+            @Override
+            public void onComplete() {
+                ts.onComplete();
+            }
+        };
+        
+        a[0] = s;
+
+        s.onSubscribe(new BooleanSubscription());
+
+        HalfSerializer.onNext(s, 1, wip, error);
+        
+        ts.assertFailure(TestException.class, 1);
+    }
+
+    @Test
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public void reentrantOnNextOnComplete() {
+        final AtomicInteger wip = new AtomicInteger();
+        final AtomicThrowable error = new AtomicThrowable();
+        
+        final Subscriber[] a = { null };
+
+        final TestSubscriber ts = new TestSubscriber();
+        
+        Subscriber s = new Subscriber() {
+            @Override
+            public void onSubscribe(Subscription s) {
+                ts.onSubscribe(s);
+            }
+            
+            @Override
+            public void onNext(Object t) {
+                if (t.equals(1)) {
+                    HalfSerializer.onComplete(a[0], wip, error);
+                }
+                ts.onNext(t);
+            }
+            
+            @Override
+            public void onError(Throwable t) {
+                ts.onError(t);
+            }
+            
+            @Override
+            public void onComplete() {
+                ts.onComplete();
+            }
+        };
+        
+        a[0] = s;
+
+        s.onSubscribe(new BooleanSubscription());
+
+        HalfSerializer.onNext(s, 1, wip, error);
+        
+        ts.assertResult(1);
+    }
+
+    @Test
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public void reentrantErrorOnError() {
+        final AtomicInteger wip = new AtomicInteger();
+        final AtomicThrowable error = new AtomicThrowable();
+        
+        final Subscriber[] a = { null };
+
+        final TestSubscriber ts = new TestSubscriber();
+        
+        Subscriber s = new Subscriber() {
+            @Override
+            public void onSubscribe(Subscription s) {
+                ts.onSubscribe(s);
+            }
+            
+            @Override
+            public void onNext(Object t) {
+                ts.onNext(t);
+            }
+            
+            @Override
+            public void onError(Throwable t) {
+                ts.onError(t);
+                HalfSerializer.onError(a[0], new IOException(), wip, error);
+            }
+            
+            @Override
+            public void onComplete() {
+                ts.onComplete();
+            }
+        };
+        
+        a[0] = s;
+
+        s.onSubscribe(new BooleanSubscription());
+
+        HalfSerializer.onError(s, new TestException(), wip, error);
+        
+        ts.assertFailure(TestException.class);
+    }
+    
+    @Test
+    public void onNextOnCompleteRace() {
+        for (int i = 0; i < 500; i++) {
+
+            final AtomicInteger wip = new AtomicInteger();
+            final AtomicThrowable error = new AtomicThrowable();
+            
+            final TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+            ts.onSubscribe(new BooleanSubscription());
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    HalfSerializer.onNext(ts, 1, wip, error);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    HalfSerializer.onComplete(ts, wip, error);
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+            
+            ts.assertComplete().assertNoErrors();
+            
+            assertTrue(ts.valueCount() <= 1);
+        }
+    }
+    
+    @Test
+    public void onErrorOnCompleteRace() {
+        for (int i = 0; i < 500; i++) {
+
+            final AtomicInteger wip = new AtomicInteger();
+            final AtomicThrowable error = new AtomicThrowable();
+            
+            final TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+
+            ts.onSubscribe(new BooleanSubscription());
+            
+            final TestException ex = new TestException();
+            
+            Runnable r1 = new Runnable() {
+                @Override
+                public void run() {
+                    HalfSerializer.onError(ts, ex, wip, error);
+                }
+            };
+            
+            Runnable r2 = new Runnable() {
+                @Override
+                public void run() {
+                    HalfSerializer.onComplete(ts, wip, error);
+                }
+            };
+            
+            TestHelper.race(r1, r2, Schedulers.single());
+
+            if (ts.completions() != 0) {
+                ts.assertResult();
+            } else {
+                ts.assertFailure(TestException.class);
+            }
+        }
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/util/MiscUtilTest.java b/src/test/java/io/reactivex/internal/util/MiscUtilTest.java
index cce84e44c9..fa9ef1cdfd 100644
--- a/src/test/java/io/reactivex/internal/util/MiscUtilTest.java
+++ b/src/test/java/io/reactivex/internal/util/MiscUtilTest.java
@@ -14,9 +14,13 @@
 package io.reactivex.internal.util;
 
 import static org.junit.Assert.*;
+
+import java.util.*;
+
 import org.junit.Test;
 
 import io.reactivex.TestHelper;
+import io.reactivex.functions.BiPredicate;
 
 public class MiscUtilTest {
     @Test
@@ -40,4 +44,70 @@ public void isPowerOf2() {
     public void hashMapSupplier() {
         TestHelper.checkEnum(HashMapSupplier.class);
     }
+    
+    @Test
+    public void arrayListSupplier() {
+        TestHelper.checkEnum(ArrayListSupplier.class);
+    }
+    
+    @Test
+    public void errorModeEnum() {
+        TestHelper.checkEnum(ErrorMode.class);
+    }
+    
+    @Test
+    public void linkedArrayList() {
+        LinkedArrayList list = new LinkedArrayList(2);
+        list.add(1);
+        list.add(2);
+        list.add(3);
+        assertEquals("[1, 2, 3]", list.toString());
+    }
+    
+    @Test
+    public void appendOnlyLinkedArrayListForEachWhile() throws Exception {
+        AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(2);
+        
+        list.add(1);
+        list.add(2);
+        list.add(3);
+        
+        final List<Integer> out = new ArrayList<Integer>();
+        
+        list.forEachWhile(2, new BiPredicate<Integer, Integer>() {
+            @Override
+            public boolean test(Integer t1, Integer t2) throws Exception {
+                out.add(t2);
+                return t1.equals(t2);
+            }
+        });
+        
+        assertEquals(Arrays.asList(1, 2), out);
+    }
+
+    @Test
+    public void appendOnlyLinkedArrayListForEachWhileAll() throws Exception {
+        AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(2);
+        
+        list.add(1);
+        list.add(2);
+        list.add(3);
+        
+        final List<Integer> out = new ArrayList<Integer>();
+        
+        list.forEachWhile(3, new BiPredicate<Integer, Integer>() {
+            @Override
+            public boolean test(Integer t1, Integer t2) throws Exception {
+                out.add(t2);
+                return false;
+            }
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3), out);
+    }
+
+    @Test
+    public void queueDrainHelperUtility() {
+        TestHelper.checkUtilityClass(QueueDrainHelper.class);
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/util/NotificationLiteTest.java b/src/test/java/io/reactivex/internal/util/NotificationLiteTest.java
new file mode 100644
index 0000000000..64e09d5f3e
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/util/NotificationLiteTest.java
@@ -0,0 +1,50 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.util;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.observers.TestObserver;
+
+public class NotificationLiteTest {
+
+    @Test
+    public void acceptFullObserver() {
+        TestObserver<Integer> to = new TestObserver<Integer>();
+        
+        Disposable d = Disposables.empty();
+        
+        assertFalse(NotificationLite.acceptFull(NotificationLite.disposable(d), to));
+        
+        to.assertSubscribed();
+        
+        to.cancel();
+        
+        assertTrue(d.isDisposed());
+    }
+    
+    @Test
+    public void errorNotificationCompare() {
+        TestException ex = new TestException();
+        Object n1 = NotificationLite.error(ex);
+        
+        assertEquals(ex.hashCode(), n1.hashCode());
+        
+        assertFalse(n1.equals(NotificationLite.complete()));
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/util/OpenHashSetTest.java b/src/test/java/io/reactivex/internal/util/OpenHashSetTest.java
new file mode 100644
index 0000000000..f9a249516a
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/util/OpenHashSetTest.java
@@ -0,0 +1,51 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.util;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+public class OpenHashSetTest {
+
+    static class Value {
+        
+        @Override
+        public int hashCode() {
+            return 1;
+        }
+        
+    }
+    
+    @Test
+    public void addRemoveCollision() {
+        Value v1 = new Value();
+        Value v2 = new Value();
+        
+        OpenHashSet<Value> set = new OpenHashSet<Value>();
+        
+        assertTrue(set.add(v1));
+        
+        assertFalse(set.add(v1));
+
+        assertFalse(set.remove(v2));
+        
+        assertTrue(set.add(v2));
+
+        assertFalse(set.add(v2));
+
+        assertTrue(set.remove(v2));
+        
+        assertFalse(set.remove(v2));
+    }
+}
diff --git a/src/test/java/io/reactivex/single/SingleTest.java b/src/test/java/io/reactivex/single/SingleTest.java
index 32c60fd08c..21b4c29402 100644
--- a/src/test/java/io/reactivex/single/SingleTest.java
+++ b/src/test/java/io/reactivex/single/SingleTest.java
@@ -265,7 +265,7 @@ public void run() {
                     }
 
                 });
-                sd.replace(Disposables.from(new Runnable() {
+                sd.replace(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         unsubscribed.set(true);
@@ -339,7 +339,7 @@ public void run() {
                     }
 
                 });
-                sd.replace(Disposables.from(new Runnable() {
+                sd.replace(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         unsubscribed.set(true);
@@ -395,7 +395,7 @@ public void run() {
                     }
 
                 });
-                sd.replace(Disposables.from(new Runnable() {
+                sd.replace(Disposables.fromRunnable(new Runnable() {
                     @Override
                     public void run() {
                         unsubscribed.set(true);
