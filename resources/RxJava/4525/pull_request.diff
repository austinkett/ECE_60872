diff --git a/src/main/java/io/reactivex/Flowable.java b/src/main/java/io/reactivex/Flowable.java
index 27ba8c954d..0dad7ebcc9 100644
--- a/src/main/java/io/reactivex/Flowable.java
+++ b/src/main/java/io/reactivex/Flowable.java
@@ -140,6 +140,11 @@ public static int bufferSize() {
      * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
      * the source Publishers each time an item is received from any of the source Publishers, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
@@ -163,7 +168,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
-    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super T[], ? extends R> combiner) {
+    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {
         return combineLatest(sources, combiner, bufferSize());
     }
 
@@ -171,6 +176,11 @@ public static int bufferSize() {
      * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
      * the source Publishers each time an item is received from any of the source Publishers, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
@@ -194,7 +204,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
-    public static <T, R> Flowable<R> combineLatest(Function<? super T[], ? extends R> combiner, Publisher<? extends T>... sources) {
+    public static <T, R> Flowable<R> combineLatest(Function<? super Object[], ? extends R> combiner, Publisher<? extends T>... sources) {
         return combineLatest(sources, combiner, bufferSize());
     }
 
@@ -202,6 +212,11 @@ public static int bufferSize() {
      * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
      * the source Publishers each time an item is received from any of the source Publishers, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
@@ -227,7 +242,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
-    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super T[], ? extends R> combiner, int bufferSize) {
+    public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
         if (sources.length == 0) {
             return empty();
@@ -241,6 +256,11 @@ public static int bufferSize() {
      * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
      * the source Publishers each time an item is received from any of the source Publishers, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
@@ -265,7 +285,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources,
-            Function<? super T[], ? extends R> combiner) {
+            Function<? super Object[], ? extends R> combiner) {
         return combineLatest(sources, combiner, bufferSize());
     }
 
@@ -273,6 +293,11 @@ public static int bufferSize() {
      * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
      * the source Publishers each time an item is received from any of the source Publishers, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
@@ -299,7 +324,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatest(Iterable<? extends Publisher<? extends T>> sources,
-            Function<? super T[], ? extends R> combiner, int bufferSize) {
+            Function<? super Object[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
         ObjectHelper.requireNonNull(combiner, "combiner is null");
         ObjectHelper.verifyPositive(bufferSize, "bufferSize");
@@ -310,6 +335,11 @@ public static int bufferSize() {
      * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
      * the source Publishers each time an item is received from any of the source Publishers, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
      *  <dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
@@ -334,7 +364,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources,
-            Function<? super T[], ? extends R> combiner) {
+            Function<? super Object[], ? extends R> combiner) {
         return combineLatestDelayError(sources, combiner, bufferSize());
     }
 
@@ -343,6 +373,10 @@ public static int bufferSize() {
      * the source Publishers each time an item is received from any of the source Publishers, where this
      * aggregation is defined by a specified function and delays any error from the sources until
      * all source Publishers terminate.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
      *
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
@@ -367,7 +401,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
-    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super T[], ? extends R> combiner,
+    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super Object[], ? extends R> combiner,
             Publisher<? extends T>... sources) {
         return combineLatestDelayError(sources, combiner, bufferSize());
     }
@@ -377,6 +411,10 @@ public static int bufferSize() {
      * the source ObservableSources each time an item is received from any of the source Publisher, where this
      * aggregation is defined by a specified function and delays any error from the sources until
      * all source Publishers terminate.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
      *
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -398,7 +436,7 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super T[], ? extends R> combiner,
+    public static <T, R> Flowable<R> combineLatestDelayError(Function<? super Object[], ? extends R> combiner,
             int bufferSize, Publisher<? extends T>... sources) {
         return combineLatestDelayError(sources, combiner, bufferSize);
     }
@@ -408,6 +446,10 @@ public static int bufferSize() {
      * the source Publishers each time an item is received from any of the source Publishers, where this
      * aggregation is defined by a specified function and delays any error from the sources until
      * all source Publishers terminate.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
      *
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
@@ -435,7 +477,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatestDelayError(Publisher<? extends T>[] sources,
-            Function<? super T[], ? extends R> combiner, int bufferSize) {
+            Function<? super Object[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
         ObjectHelper.requireNonNull(combiner, "combiner is null");
         ObjectHelper.verifyPositive(bufferSize, "bufferSize");
@@ -450,6 +492,10 @@ public static int bufferSize() {
      * the source Publishers each time an item is received from any of the source Publishers, where this
      * aggregation is defined by a specified function and delays any error from the sources until
      * all source Publishers terminate.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
      *
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
@@ -475,7 +521,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources,
-            Function<? super T[], ? extends R> combiner) {
+            Function<? super Object[], ? extends R> combiner) {
         return combineLatestDelayError(sources, combiner, bufferSize());
     }
 
@@ -484,6 +530,10 @@ public static int bufferSize() {
      * the source Publishers each time an item is received from any of the source Publishers, where this
      * aggregation is defined by a specified function and delays any error from the sources until
      * all source Publishers terminate.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
      *
      * <dl>
      *  <dt><b>Backpressure:</b></dt>
@@ -511,7 +561,7 @@ public static int bufferSize() {
     @SchedulerSupport(SchedulerSupport.NONE)
     @BackpressureSupport(BackpressureKind.FULL)
     public static <T, R> Flowable<R> combineLatestDelayError(Iterable<? extends Publisher<? extends T>> sources,
-            Function<? super T[], ? extends R> combiner, int bufferSize) {
+            Function<? super Object[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
         ObjectHelper.requireNonNull(combiner, "combiner is null");
         ObjectHelper.verifyPositive(bufferSize, "bufferSize");
@@ -14955,4 +15005,4 @@ public final Completable toCompletable() {
         return ts;
     }
 
-}
\ No newline at end of file
+}
diff --git a/src/main/java/io/reactivex/Maybe.java b/src/main/java/io/reactivex/Maybe.java
index 85a25fc3e0..cb0a0f0fc0 100644
--- a/src/main/java/io/reactivex/Maybe.java
+++ b/src/main/java/io/reactivex/Maybe.java
@@ -1343,6 +1343,11 @@
      * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
      * items emitted, in sequence, by an Iterable of other MaybeSources.
      * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
+     * <p>
      * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
      * <p>This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
      * also means it is possible some sources may not get subscribed to at all.
@@ -1362,7 +1367,7 @@
      * @see <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T, R> Maybe<R> zip(Iterable<? extends MaybeSource<? extends T>> sources, Function<? super T[], ? extends R> zipper) {
+    public static <T, R> Maybe<R> zip(Iterable<? extends MaybeSource<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {
         ObjectHelper.requireNonNull(zipper, "zipper is null");
         ObjectHelper.requireNonNull(sources, "sources is null");
         return RxJavaPlugins.onAssembly(new MaybeZipIterable<T, R>(sources, zipper));
@@ -1774,6 +1779,11 @@
      * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
      * items emitted, in sequence, by an array of other MaybeSources.
      * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
+     * <p>
      * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
      * <p>This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
      * also means it is possible some sources may not get subscribed to at all.
@@ -1796,6 +1806,7 @@
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, R> Maybe<R> zipArray(Function<? super Object[], ? extends R> zipper,
             MaybeSource<? extends T>... sources) {
+        ObjectHelper.requireNonNull(sources, "sources is null");
         if (sources.length == 0) {
             return empty();
         }
diff --git a/src/main/java/io/reactivex/Observable.java b/src/main/java/io/reactivex/Observable.java
index 5996e7180a..74469ee628 100644
--- a/src/main/java/io/reactivex/Observable.java
+++ b/src/main/java/io/reactivex/Observable.java
@@ -128,6 +128,11 @@ public static int bufferSize() {
      * Combines a collection of source ObservableSources by emitting an item that aggregates the latest values of each of
      * the source ObservableSources each time an item is received from any of the source ObservableSources, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -148,7 +153,7 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T, R> Observable<R> combineLatest(Function<? super T[], ? extends R> combiner, int bufferSize, ObservableSource<? extends T>... sources) {
+    public static <T, R> Observable<R> combineLatest(Function<? super Object[], ? extends R> combiner, int bufferSize, ObservableSource<? extends T>... sources) {
         return combineLatest(sources, combiner, bufferSize);
     }
 
@@ -156,6 +161,11 @@ public static int bufferSize() {
      * Combines a collection of source ObservableSources by emitting an item that aggregates the latest values of each of
      * the source ObservableSources each time an item is received from any of the source ObservableSources, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -175,7 +185,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, R> Observable<R> combineLatest(Iterable<? extends ObservableSource<? extends T>> sources,
-            Function<? super T[], ? extends R> combiner) {
+            Function<? super Object[], ? extends R> combiner) {
         return combineLatest(sources, combiner, bufferSize());
     }
 
@@ -184,6 +194,11 @@ public static int bufferSize() {
      * Combines a collection of source ObservableSources by emitting an item that aggregates the latest values of each of
      * the source ObservableSources each time an item is received from any of the source ObservableSources, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -205,7 +220,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, R> Observable<R> combineLatest(Iterable<? extends ObservableSource<? extends T>> sources,
-            Function<? super T[], ? extends R> combiner, int bufferSize) {
+            Function<? super Object[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
         ObjectHelper.requireNonNull(combiner, "combiner is null");
         ObjectHelper.verifyPositive(bufferSize, "bufferSize");
@@ -219,6 +234,11 @@ public static int bufferSize() {
      * Combines a collection of source ObservableSources by emitting an item that aggregates the latest values of each of
      * the source ObservableSources each time an item is received from any of the source ObservableSources, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -238,7 +258,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, R> Observable<R> combineLatest(ObservableSource<? extends T>[] sources,
-            Function<? super T[], ? extends R> combiner) {
+            Function<? super Object[], ? extends R> combiner) {
         return combineLatest(sources, combiner, bufferSize());
     }
 
@@ -246,6 +266,11 @@ public static int bufferSize() {
      * Combines a collection of source ObservableSources by emitting an item that aggregates the latest values of each of
      * the source ObservableSources each time an item is received from any of the source ObservableSources, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -267,7 +292,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, R> Observable<R> combineLatest(ObservableSource<? extends T>[] sources,
-            Function<? super T[], ? extends R> combiner, int bufferSize) {
+            Function<? super Object[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
         if (sources.length == 0) {
             return empty();
@@ -640,6 +665,11 @@ public static int bufferSize() {
      * Combines a collection of source ObservableSources by emitting an item that aggregates the latest values of each of
      * the source ObservableSources each time an item is received from any of the source ObservableSources, where this
      * aggregation is defined by a specified function.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
      *  <dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.</dd>
@@ -659,7 +689,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, R> Observable<R> combineLatestDelayError(ObservableSource<? extends T>[] sources,
-            Function<? super T[], ? extends R> combiner) {
+            Function<? super Object[], ? extends R> combiner) {
         return combineLatestDelayError(sources, combiner, bufferSize());
     }
 
@@ -668,6 +698,10 @@ public static int bufferSize() {
      * the source ObservableSources each time an item is received from any of the source ObservableSources, where this
      * aggregation is defined by a specified function and delays any error from the sources until
      * all source ObservableSources terminate.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
      *
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -689,7 +723,7 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T, R> Observable<R> combineLatestDelayError(Function<? super T[], ? extends R> combiner,
+    public static <T, R> Observable<R> combineLatestDelayError(Function<? super Object[], ? extends R> combiner,
             int bufferSize, ObservableSource<? extends T>... sources) {
         return combineLatestDelayError(sources, combiner, bufferSize);
     }
@@ -699,6 +733,10 @@ public static int bufferSize() {
      * the source ObservableSources each time an item is received from any of the source ObservableSources, where this
      * aggregation is defined by a specified function and delays any error from the sources until
      * all source ObservableSources terminate.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
      *
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -721,7 +759,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, R> Observable<R> combineLatestDelayError(ObservableSource<? extends T>[] sources,
-            Function<? super T[], ? extends R> combiner, int bufferSize) {
+            Function<? super Object[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.verifyPositive(bufferSize, "bufferSize");
         ObjectHelper.requireNonNull(combiner, "combiner is null");
         if (sources.length == 0) {
@@ -737,6 +775,10 @@ public static int bufferSize() {
      * the source ObservableSources each time an item is received from any of the source ObservableSources, where this
      * aggregation is defined by a specified function and delays any error from the sources until
      * all source ObservableSources terminate.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
      *
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -757,7 +799,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, R> Observable<R> combineLatestDelayError(Iterable<? extends ObservableSource<? extends T>> sources,
-            Function<? super T[], ? extends R> combiner) {
+            Function<? super Object[], ? extends R> combiner) {
         return combineLatestDelayError(sources, combiner, bufferSize());
     }
 
@@ -766,6 +808,10 @@ public static int bufferSize() {
      * the source ObservableSources each time an item is received from any of the source ObservableSources, where this
      * aggregation is defined by a specified function and delays any error from the sources until
      * all source ObservableSources terminate.
+     * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
      *
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -788,7 +834,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, R> Observable<R> combineLatestDelayError(Iterable<? extends ObservableSource<? extends T>> sources,
-            Function<? super T[], ? extends R> combiner, int bufferSize) {
+            Function<? super Object[], ? extends R> combiner, int bufferSize) {
         ObjectHelper.requireNonNull(sources, "sources is null");
         ObjectHelper.requireNonNull(combiner, "combiner is null");
         ObjectHelper.verifyPositive(bufferSize, "bufferSize");
@@ -3358,6 +3404,11 @@ public static int bufferSize() {
      * use {@code doOnUnsubscribed()} as well or use {@code using()} to do cleanup in case of completion
      * or unsubscription.
      * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
+     * <p>
      * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -3375,7 +3426,7 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T, R> Observable<R> zip(Iterable<? extends ObservableSource<? extends T>> sources, Function<? super T[], ? extends R> zipper) {
+    public static <T, R> Observable<R> zip(Iterable<? extends ObservableSource<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {
         ObjectHelper.requireNonNull(zipper, "zipper is null");
         ObjectHelper.requireNonNull(sources, "sources is null");
         return RxJavaPlugins.onAssembly(new ObservableZip<T, R>(null, sources, zipper, bufferSize(), false));
@@ -3405,6 +3456,11 @@ public static int bufferSize() {
      * use {@code doOnUnsubscribed()} as well or use {@code using()} to do cleanup in case of completion
      * or unsubscription.
      * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
+     * <p>
      * <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.o.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -3423,7 +3479,7 @@ public static int bufferSize() {
      */
     @SuppressWarnings({ "rawtypes", "unchecked" })
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T, R> Observable<R> zip(ObservableSource<? extends ObservableSource<? extends T>> sources, final Function<? super T[], ? extends R> zipper) {
+    public static <T, R> Observable<R> zip(ObservableSource<? extends ObservableSource<? extends T>> sources, final Function<? super Object[], ? extends R> zipper) {
         ObjectHelper.requireNonNull(zipper, "zipper is null");
         ObjectHelper.requireNonNull(sources, "sources is null");
         return RxJavaPlugins.onAssembly(new ObservableToList(sources, 16)
@@ -4074,6 +4130,11 @@ public static int bufferSize() {
      * use {@code doOnUnsubscribed()} as well or use {@code using()} to do cleanup in case of completion
      * or unsubscription.
      * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
+     * <p>
      * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -4095,7 +4156,7 @@ public static int bufferSize() {
      * @see <a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>
      */
     @SchedulerSupport(SchedulerSupport.NONE)
-    public static <T, R> Observable<R> zipArray(Function<? super T[], ? extends R> zipper,
+    public static <T, R> Observable<R> zipArray(Function<? super Object[], ? extends R> zipper,
             boolean delayError, int bufferSize, ObservableSource<? extends T>... sources) {
         if (sources.length == 0) {
             return empty();
@@ -4129,6 +4190,11 @@ public static int bufferSize() {
      * use {@code doOnUnsubscribed()} as well or use {@code using()} to do cleanup in case of completion
      * or unsubscription.
      * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
+     * <p>
      * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
      * <dl>
      *  <dt><b>Scheduler:</b></dt>
@@ -4152,7 +4218,7 @@ public static int bufferSize() {
      */
     @SchedulerSupport(SchedulerSupport.NONE)
     public static <T, R> Observable<R> zipIterable(Iterable<? extends ObservableSource<? extends T>> sources,
-            Function<? super T[], ? extends R> zipper, boolean delayError,
+            Function<? super Object[], ? extends R> zipper, boolean delayError,
             int bufferSize) {
         ObjectHelper.requireNonNull(zipper, "zipper is null");
         ObjectHelper.requireNonNull(sources, "sources is null");
diff --git a/src/main/java/io/reactivex/Single.java b/src/main/java/io/reactivex/Single.java
index 80ab7d5d77..e22aaabadf 100644
--- a/src/main/java/io/reactivex/Single.java
+++ b/src/main/java/io/reactivex/Single.java
@@ -877,6 +877,11 @@
      * value and calls a zipper function with an array of these values to return a result
      * to be emitted to downstream.
      * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
+     * <p>
      * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
      * <p>
      * If any of the SingleSources signal an error, all other SingleSources get cancelled and the
@@ -1295,6 +1300,11 @@
      * value and calls a zipper function with an array of these values to return a result
      * to be emitted to downstream.
      * <p>
+     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
+     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
+     * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}.
+     *
+     * <p>
      * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png" alt="">
      * <p>
      * If any of the SingleSources signal an error, all other SingleSources get cancelled and the
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
index a6f21df0cf..fa490a8da1 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java
@@ -40,14 +40,14 @@
 
     final Iterable<? extends Publisher<? extends T>> iterable;
 
-    final Function<? super T[], ? extends R> combiner;
+    final Function<? super Object[], ? extends R> combiner;
 
     final int bufferSize;
 
     final boolean delayErrors;
 
     public FlowableCombineLatest(Publisher<? extends T>[] array,
-            Function<? super T[], ? extends R> combiner,
+            Function<? super Object[], ? extends R> combiner,
                     int bufferSize, boolean delayErrors) {
         if (bufferSize <= 0) {
             throw new IllegalArgumentException("BUFFER_SIZE > 0 required but it was " + bufferSize);
@@ -61,7 +61,7 @@ public FlowableCombineLatest(Publisher<? extends T>[] array,
     }
 
     public FlowableCombineLatest(Iterable<? extends Publisher<? extends T>> iterable,
-            Function<? super T[], ? extends R> combiner,
+            Function<? super Object[], ? extends R> combiner,
                     int bufferSize, boolean delayErrors) {
         if (bufferSize <= 0) {
             throw new IllegalArgumentException("BUFFER_SIZE > 0 required but it was " + bufferSize);
@@ -173,7 +173,7 @@ public R apply(T t) throws Exception {
 
         final Subscriber<? super R> actual;
 
-        final Function<? super T[], ? extends R> combiner;
+        final Function<? super Object[], ? extends R> combiner;
 
         final CombineLatestInnerSubscriber<T>[] subscribers;
 
@@ -198,7 +198,7 @@ public R apply(T t) throws Exception {
         final AtomicReference<Throwable> error;
 
         public CombineLatestCoordinator(Subscriber<? super R> actual,
-                Function<? super T[], ? extends R> combiner, int n,
+                Function<? super Object[], ? extends R> combiner, int n,
                 int bufferSize, boolean delayErrors) {
             this.actual = actual;
             this.combiner = combiner;
diff --git a/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipArray.java b/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipArray.java
index aece8cc510..5f58a7e62c 100644
--- a/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipArray.java
+++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipArray.java
@@ -27,9 +27,9 @@
 
     final MaybeSource<? extends T>[] sources;
 
-    final Function<? super T[], ? extends R> zipper;
+    final Function<? super Object[], ? extends R> zipper;
 
-    public MaybeZipArray(MaybeSource<? extends T>[] sources, Function<? super T[], ? extends R> zipper) {
+    public MaybeZipArray(MaybeSource<? extends T>[] sources, Function<? super Object[], ? extends R> zipper) {
         this.sources = sources;
         this.zipper = zipper;
     }
@@ -71,14 +71,14 @@ public R apply(T t) throws Exception {
 
         final MaybeObserver<? super R> actual;
 
-        final Function<? super T[], ? extends R> zipper;
+        final Function<? super Object[], ? extends R> zipper;
 
         final ZipMaybeObserver<T>[] observers;
 
         final Object[] values;
 
         @SuppressWarnings("unchecked")
-        public ZipCoordinator(MaybeObserver<? super R> observer, int n, Function<? super T[], ? extends R> zipper) {
+        public ZipCoordinator(MaybeObserver<? super R> observer, int n, Function<? super Object[], ? extends R> zipper) {
             super(n);
             this.actual = observer;
             this.zipper = zipper;
diff --git a/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipIterable.java b/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipIterable.java
index 8f89193c33..4ea94f0731 100644
--- a/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipIterable.java
+++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipIterable.java
@@ -25,9 +25,9 @@
 
     final Iterable<? extends MaybeSource<? extends T>> sources;
 
-    final Function<? super T[], ? extends R> zipper;
+    final Function<? super Object[], ? extends R> zipper;
 
-    public MaybeZipIterable(Iterable<? extends MaybeSource<? extends T>> sources, Function<? super T[], ? extends R> zipper) {
+    public MaybeZipIterable(Iterable<? extends MaybeSource<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {
         this.sources = sources;
         this.zipper = zipper;
     }
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java
index 3797763783..f0ffecfbb7 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java
@@ -27,13 +27,13 @@
 public final class ObservableCombineLatest<T, R> extends Observable<R> {
     final ObservableSource<? extends T>[] sources;
     final Iterable<? extends ObservableSource<? extends T>> sourcesIterable;
-    final Function<? super T[], ? extends R> combiner;
+    final Function<? super Object[], ? extends R> combiner;
     final int bufferSize;
     final boolean delayError;
 
     public ObservableCombineLatest(ObservableSource<? extends T>[] sources,
             Iterable<? extends ObservableSource<? extends T>> sourcesIterable,
-            Function<? super T[], ? extends R> combiner, int bufferSize,
+            Function<? super Object[], ? extends R> combiner, int bufferSize,
             boolean delayError) {
         this.sources = sources;
         this.sourcesIterable = sourcesIterable;
@@ -75,7 +75,7 @@ public void subscribeActual(Observer<? super R> s) {
         /** */
         private static final long serialVersionUID = 8567835998786448817L;
         final Observer<? super R> actual;
-        final Function<? super T[], ? extends R> combiner;
+        final Function<? super Object[], ? extends R> combiner;
         final int count;
         final CombinerSubscriber<T, R>[] subscribers;
         final int bufferSize;
@@ -94,7 +94,7 @@ public void subscribeActual(Observer<? super R> s) {
 
         @SuppressWarnings("unchecked")
         public LatestCoordinator(Observer<? super R> actual,
-                Function<? super T[], ? extends R> combiner,
+                Function<? super Object[], ? extends R> combiner,
                 int count, int bufferSize, boolean delayError) {
             this.actual = actual;
             this.combiner = combiner;
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableInternalHelper.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableInternalHelper.java
index 411bd44218..f9aaac221e 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableInternalHelper.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableInternalHelper.java
@@ -296,9 +296,9 @@ public boolean test(Notification<Object> t) throws Exception {
 
     static final class ZipIterableFunction<T, R>
     implements Function<List<ObservableSource<? extends T>>, ObservableSource<? extends R>> {
-        private final Function<? super T[], ? extends R> zipper;
+        private final Function<? super Object[], ? extends R> zipper;
 
-        ZipIterableFunction(Function<? super T[], ? extends R> zipper) {
+        ZipIterableFunction(Function<? super Object[], ? extends R> zipper) {
             this.zipper = zipper;
         }
 
@@ -308,7 +308,7 @@ public boolean test(Notification<Object> t) throws Exception {
         }
     }
 
-    public static <T, R> Function<List<ObservableSource<? extends T>>, ObservableSource<? extends R>> zipIterable(final Function<? super T[], ? extends R> zipper) {
+    public static <T, R> Function<List<ObservableSource<? extends T>>, ObservableSource<? extends R>> zipIterable(final Function<? super Object[], ? extends R> zipper) {
         return new ZipIterableFunction<T, R>(zipper);
     }
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java
index 92b54a110d..e110813703 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableZip.java
@@ -27,13 +27,13 @@
 
     final ObservableSource<? extends T>[] sources;
     final Iterable<? extends ObservableSource<? extends T>> sourcesIterable;
-    final Function<? super T[], ? extends R> zipper;
+    final Function<? super Object[], ? extends R> zipper;
     final int bufferSize;
     final boolean delayError;
 
     public ObservableZip(ObservableSource<? extends T>[] sources,
             Iterable<? extends ObservableSource<? extends T>> sourcesIterable,
-            Function<? super T[], ? extends R> zipper,
+            Function<? super Object[], ? extends R> zipper,
             int bufferSize,
             boolean delayError) {
         this.sources = sources;
@@ -75,7 +75,7 @@ public void subscribeActual(Observer<? super R> s) {
         /** */
         private static final long serialVersionUID = 2983708048395377667L;
         final Observer<? super R> actual;
-        final Function<? super T[], ? extends R> zipper;
+        final Function<? super Object[], ? extends R> zipper;
         final ZipSubscriber<T, R>[] subscribers;
         final T[] row;
         final boolean delayError;
@@ -84,7 +84,7 @@ public void subscribeActual(Observer<? super R> s) {
 
         @SuppressWarnings("unchecked")
         public ZipCoordinator(Observer<? super R> actual,
-                Function<? super T[], ? extends R> zipper,
+                Function<? super Object[], ? extends R> zipper,
                 int count, boolean delayError) {
             this.actual = actual;
             this.zipper = zipper;
diff --git a/src/test/java/io/reactivex/flowable/FlowableTests.java b/src/test/java/io/reactivex/flowable/FlowableTests.java
index de01ccac68..fc56cd59de 100644
--- a/src/test/java/io/reactivex/flowable/FlowableTests.java
+++ b/src/test/java/io/reactivex/flowable/FlowableTests.java
@@ -1060,4 +1060,34 @@ public void toObservableRange() {
     public void toObservableError() {
         Flowable.error(new TestException()).toObservable().test().assertFailure(TestException.class);
     }
+
+    @Test
+    public void zipIterableObject() {
+        final List<Flowable<Integer>> flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3));
+        Flowable.zip(flowables, new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] o) throws Exception {
+                int sum = 0;
+                for (Object i : o) {
+                    sum += (Integer) i;
+                }
+                return sum;
+            }
+        }).test().assertResult(2, 4, 6);
+    }
+
+    @Test
+    public void combineLatestObject() {
+        final List<Flowable<Integer>> flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3));
+        Flowable.combineLatest(flowables, new Function<Object[], Object>() {
+            @Override
+            public Object apply(final Object[] o) throws Exception {
+                int sum = 1;
+                for (Object i : o) {
+                    sum *= (Integer) i;
+                }
+                return sum;
+            }
+        }).test().assertResult(3, 6, 9);
+    }
 }
diff --git a/src/test/java/io/reactivex/maybe/MaybeTest.java b/src/test/java/io/reactivex/maybe/MaybeTest.java
index 56330ba989..b1e1db85d3 100644
--- a/src/test/java/io/reactivex/maybe/MaybeTest.java
+++ b/src/test/java/io/reactivex/maybe/MaybeTest.java
@@ -2858,4 +2858,18 @@ public void ambWith2SignalsSuccess() {
         ts.assertResult(2);
     }
 
+    @Test
+    public void zipIterableObject() {
+        final List<Maybe<Integer>> maybes = Arrays.asList(Maybe.just(1), Maybe.just(4));
+        Maybe.zip(maybes, new Function<Object[], Object>() {
+            @Override
+            public Object apply(final Object[] o) throws Exception {
+                int sum = 0;
+                for (Object i : o) {
+                    sum += (Integer) i;
+                }
+                return sum;
+            }
+        }).test().assertResult(5);
+    }
 }
diff --git a/src/test/java/io/reactivex/observable/ObservableTest.java b/src/test/java/io/reactivex/observable/ObservableTest.java
index 0df7803154..6dcaea8fd2 100644
--- a/src/test/java/io/reactivex/observable/ObservableTest.java
+++ b/src/test/java/io/reactivex/observable/ObservableTest.java
@@ -1056,4 +1056,34 @@ public void singleDefault() {
 
         Observable.empty().toSingle(100).test().assertResult(100);
     }
+
+    @Test
+    public void zipIterableObject() {
+        final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3));
+        Observable.zip(observables, new Function<Object[], Object>() {
+            @Override
+            public Object apply(Object[] o) throws Exception {
+                int sum = 0;
+                for (Object i : o) {
+                    sum += (Integer) i;
+                }
+                return sum;
+            }
+        }).test().assertResult(2, 4, 6);
+    }
+
+    @Test
+    public void combineLatestObject() {
+        final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3));
+        Observable.combineLatest(observables, new Function<Object[], Object>() {
+            @Override
+            public Object apply(final Object[] o) throws Exception {
+                int sum = 1;
+                for (Object i : o) {
+                    sum *= (Integer) i;
+                }
+                return sum;
+            }
+        }).test().assertResult(3, 6, 9);
+    }
 }
diff --git a/src/test/java/io/reactivex/single/SingleTest.java b/src/test/java/io/reactivex/single/SingleTest.java
index ee8e52a00f..5a6396c298 100644
--- a/src/test/java/io/reactivex/single/SingleTest.java
+++ b/src/test/java/io/reactivex/single/SingleTest.java
@@ -515,5 +515,20 @@ public void toFlowableIterableRemove() {
         iterator.next();
         iterator.remove();
     }
+
+    @Test
+    public void zipIterableObject() {
+        final List<Single<Integer>> singles = Arrays.asList(Single.just(1), Single.just(4));
+        Single.zip(singles, new Function<Object[], Object>() {
+            @Override
+            public Object apply(final Object[] o) throws Exception {
+                int sum = 0;
+                for (Object i : o) {
+                    sum += (Integer) i;
+                }
+                return sum;
+            }
+        }).test().assertResult(5);
+    }
 }
 
