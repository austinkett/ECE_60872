diff --git a/src/main/java/io/reactivex/disposables/RunnableDisposable.java b/src/main/java/io/reactivex/disposables/RunnableDisposable.java
index 665300ca5a..809e1dac36 100644
--- a/src/main/java/io/reactivex/disposables/RunnableDisposable.java
+++ b/src/main/java/io/reactivex/disposables/RunnableDisposable.java
@@ -27,4 +27,9 @@
     protected void onDisposed(Runnable value) {
         value.run();
     }
+    
+    @Override
+    public String toString() {
+        return "RunnableDisposable(disposed=" + isDisposed() + ", " + get() + ")";
+    }
 }
diff --git a/src/main/java/io/reactivex/disposables/SerialDisposable.java b/src/main/java/io/reactivex/disposables/SerialDisposable.java
index 9f0c59e1e7..21287259f5 100644
--- a/src/main/java/io/reactivex/disposables/SerialDisposable.java
+++ b/src/main/java/io/reactivex/disposables/SerialDisposable.java
@@ -15,7 +15,7 @@
 
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 
 /**
  * A Disposable container that allows atomically updating/replacing the contained
diff --git a/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java
index 2b2c23c7d7..b1855d7f55 100644
--- a/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java
+++ b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java
@@ -22,14 +22,13 @@
 /**
  * Utility methods for working with Disposables atomically.
  */
-public enum DisposableHelper {
-    ;
-    
-    /**
-     * Marker instance compared by identity for indicating a previously referenced
-     * {@link Disposable} was disposed. DO NOT USE this instance as an arbitrary, empty disposable!
+public enum DisposableHelper implements Disposable {
+    /** 
+     * The singleton instance representing a terminal, disposed state;
+     * Don't leak it!
      */
-    public static final Disposable DISPOSED = Disposed.INSTANCE;
+    DISPOSED
+    ;
     
     public static boolean isDisposed(Disposable d) {
         return d == DISPOSED;
@@ -82,9 +81,10 @@ public static boolean replace(AtomicReference<Disposable> field, Disposable d) {
     
     public static boolean dispose(AtomicReference<Disposable> field) {
         Disposable current = field.get();
-        if (current != DISPOSED) {
-            current = field.getAndSet(DISPOSED);
-            if (current != DISPOSED) {
+        Disposable d = DISPOSED;
+        if (current != d) {
+            current = field.getAndSet(d);
+            if (current != d) {
                 if (current != null) {
                     current.dispose();
                 }
@@ -121,18 +121,13 @@ public static void reportDisposableSet() {
         RxJavaPlugins.onError(new IllegalStateException("Disposable already set!"));
     }
 
-    enum Disposed implements Disposable {
-        INSTANCE;
-        
-        @Override
-        public void dispose() {
-            // deliberately no-op
-        }
-
-        @Override
-        public boolean isDisposed() {
-            return true;
-        }
+    @Override
+    public void dispose() {
+        // deliberately no-op
+    }
+    
+    @Override
+    public boolean isDisposed() {
+        return true;
     }
-
 }
diff --git a/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java b/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java
index 1f3d01325c..8167361437 100644
--- a/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java
+++ b/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java
@@ -42,6 +42,7 @@ public ListCompositeDisposable(Disposable... resources) {
     
     public ListCompositeDisposable(Iterable<? extends Disposable> resources) {
         ObjectHelper.requireNonNull(resources, "resources is null");
+        this.resources = new LinkedList<Disposable>();
         for (Disposable d : resources) {
             ObjectHelper.requireNonNull(d, "Disposable item is null");
             this.resources.add(d);
diff --git a/src/main/java/io/reactivex/internal/functions/Functions.java b/src/main/java/io/reactivex/internal/functions/Functions.java
index 58c422e900..a6cb1e7b4f 100644
--- a/src/main/java/io/reactivex/internal/functions/Functions.java
+++ b/src/main/java/io/reactivex/internal/functions/Functions.java
@@ -148,6 +148,11 @@ public R apply(Object[] a) throws Exception {
         public Object apply(Object v) {
             return v;
         }
+
+        @Override
+        public String toString() {
+            return "IdentityFunction";
+        }
     };
     
     /**
@@ -163,16 +168,31 @@ public Object apply(Object v) {
     public static final Runnable EMPTY_RUNNABLE = new Runnable() {
         @Override
         public void run() { }
+        
+        @Override
+        public String toString() {
+            return "EmptyRunnable";
+        }
     };
 
     public static final Action EMPTY_ACTION = new Action() {
         @Override
         public void run() { }
+
+        @Override
+        public String toString() {
+            return "EmptyAction";
+        }
     };
 
     static final Consumer<Object> EMPTY_CONSUMER = new Consumer<Object>() {
         @Override
         public void accept(Object v) { }
+
+        @Override
+        public String toString() {
+            return "EmptyConsumer";
+        }
     };
     
     /**
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java
index c2dff49870..4cafe9f957 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java
@@ -21,7 +21,7 @@
 
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.subscribers.flowable.QueueDrainSubscriber;
 import io.reactivex.internal.subscriptions.*;
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
index fa9a242212..dede8c8ace 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java
@@ -19,11 +19,11 @@
 
 import org.reactivestreams.*;
 
-import io.reactivex.*;
+import io.reactivex.Scheduler;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.subscribers.flowable.QueueDrainSubscriber;
 import io.reactivex.internal.subscriptions.*;
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
index 6458ce705d..ea1045256a 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java
@@ -18,10 +18,10 @@
 
 import org.reactivestreams.*;
 
-import io.reactivex.*;
+import io.reactivex.Scheduler;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 import io.reactivex.plugins.RxJavaPlugins;
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java
index 5503cefbdf..1a38f3852c 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java
@@ -21,7 +21,7 @@
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.MissingBackpressureException;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java
index ea22c32d45..cebb2044d3 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java
@@ -20,7 +20,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.internal.util.BackpressureHelper;
 
diff --git a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
index 76519d5fb3..9fd942f7b6 100644
--- a/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java
@@ -24,7 +24,7 @@
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.fuseable.SimpleQueue;
 import io.reactivex.internal.queue.MpscLinkedQueue;
 import io.reactivex.internal.subscribers.flowable.QueueDrainSubscriber;
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java
index cc9cfdb57d..a298dc26e9 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.observers.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java
index 9bdacc756d..52e3d6070d 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java
@@ -19,7 +19,7 @@
 import io.reactivex.*;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java
index 569a00dc09..b3708f701d 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java
@@ -22,7 +22,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Function;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.fuseable.*;
 import io.reactivex.internal.queue.*;
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableInterval.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableInterval.java
index e9d6fa6d60..9303524091 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableInterval.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableInterval.java
@@ -18,7 +18,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 
 public final class ObservableInterval extends Observable<Long> {
     final Scheduler scheduler;
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableIntervalRange.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableIntervalRange.java
index 71812012d9..a23b40a790 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableIntervalRange.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableIntervalRange.java
@@ -18,7 +18,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 
 public final class ObservableIntervalRange extends Observable<Long> {
     final Scheduler scheduler;
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleWithObservable.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleWithObservable.java
index 251340667f..4873e8b141 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleWithObservable.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleWithObservable.java
@@ -17,7 +17,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.observers.SerializedObserver;
 
 public final class ObservableSampleWithObservable<T> extends AbstractObservableWithUpstream<T, T> {
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTimed.java b/src/main/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTimed.java
index 1b5b3036b5..647c4c86ed 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTimed.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableThrottleFirstTimed.java
@@ -19,7 +19,7 @@
 import io.reactivex.*;
 import io.reactivex.Scheduler.Worker;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.observers.SerializedObserver;
 import io.reactivex.plugins.RxJavaPlugins;
 
diff --git a/src/main/java/io/reactivex/internal/operators/observable/ObserverResourceWrapper.java b/src/main/java/io/reactivex/internal/operators/observable/ObserverResourceWrapper.java
index e30c51ea37..b729baed93 100644
--- a/src/main/java/io/reactivex/internal/operators/observable/ObserverResourceWrapper.java
+++ b/src/main/java/io/reactivex/internal/operators/observable/ObserverResourceWrapper.java
@@ -17,7 +17,7 @@
 
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 
 public final class ObserverResourceWrapper<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {
     /** */
diff --git a/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java b/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java
index 5f89143e0a..a7c3a2d957 100644
--- a/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java
+++ b/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java
@@ -20,7 +20,7 @@
 
 import io.reactivex.*;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
 
diff --git a/src/main/java/io/reactivex/internal/subscribers/completable/CallbackCompletableObserver.java b/src/main/java/io/reactivex/internal/subscribers/completable/CallbackCompletableObserver.java
index 3dac7ac492..f59b1e451f 100644
--- a/src/main/java/io/reactivex/internal/subscribers/completable/CallbackCompletableObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/completable/CallbackCompletableObserver.java
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.*;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class CallbackCompletableObserver
diff --git a/src/main/java/io/reactivex/internal/subscribers/completable/EmptyCompletableObserver.java b/src/main/java/io/reactivex/internal/subscribers/completable/EmptyCompletableObserver.java
index d49a359d09..3de1116e92 100644
--- a/src/main/java/io/reactivex/internal/subscribers/completable/EmptyCompletableObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/completable/EmptyCompletableObserver.java
@@ -17,7 +17,7 @@
 
 import io.reactivex.CompletableObserver;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class EmptyCompletableObserver
diff --git a/src/main/java/io/reactivex/internal/subscribers/flowable/ForEachWhileSubscriber.java b/src/main/java/io/reactivex/internal/subscribers/flowable/ForEachWhileSubscriber.java
index 74e4ce9e10..582e06bd97 100644
--- a/src/main/java/io/reactivex/internal/subscribers/flowable/ForEachWhileSubscriber.java
+++ b/src/main/java/io/reactivex/internal/subscribers/flowable/ForEachWhileSubscriber.java
@@ -18,7 +18,7 @@
 import org.reactivestreams.*;
 
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
 import io.reactivex.internal.subscriptions.SubscriptionHelper;
 import io.reactivex.plugins.RxJavaPlugins;
@@ -85,7 +85,7 @@ public void onError(Throwable t) {
             onError.accept(t);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            RxJavaPlugins.onError(ex);
+            RxJavaPlugins.onError(new CompositeException(t, ex));
         }
     }
     
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/BlockingObserver.java b/src/main/java/io/reactivex/internal/subscribers/observable/BlockingObserver.java
index 5ddb2f2af0..f965d960f9 100644
--- a/src/main/java/io/reactivex/internal/subscribers/observable/BlockingObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/BlockingObserver.java
@@ -16,9 +16,9 @@
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicReference;
 
-import io.reactivex.*;
+import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.util.NotificationLite;
 
 public final class BlockingObserver<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/DeferredScalarObserver.java b/src/main/java/io/reactivex/internal/subscribers/observable/DeferredScalarObserver.java
index 2aefa86bcf..ad797a59d7 100644
--- a/src/main/java/io/reactivex/internal/subscribers/observable/DeferredScalarObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/DeferredScalarObserver.java
@@ -16,15 +16,18 @@
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.internal.disposables.DisposableHelper;
-import io.reactivex.internal.fuseable.QueueDisposable;
 
 /**
  * A fuseable Observer that can generate 0 or 1 resulting value. 
  * @param <T> the input value type
  * @param <R> the output value type
  */
-public abstract class DeferredScalarObserver<T, R> extends BaseQueueDisposable<R>
+public abstract class DeferredScalarObserver<T, R> 
+extends BaseIntQueueDisposable<R>
 implements Observer<T> {
+    /** */
+    private static final long serialVersionUID = -266195175408988651L;
+
     protected final Observer<? super R> actual;
     
     /** The upstream disposable. */
@@ -36,9 +39,6 @@
     /** The result value. */
     protected R value;
 
-    /** Holds the current fusion mode, see the constants below. */
-    protected int fusionState;
-    
     static final int NOT_FUSED = 0;
     static final int EMPTY = 1;
     static final int READY = 2;
@@ -66,8 +66,12 @@ public void onSubscribe(Disposable s) {
     
     @Override
     public void onError(Throwable t) {
-        value = null;
-        actual.onError(t);
+        int state = get();
+        if (state == NOT_FUSED || state == EMPTY) {
+            value = null;
+            lazySet(CONSUMED);
+            actual.onError(t);
+        }
     }
     
     @Override
@@ -75,17 +79,24 @@ public void onComplete() {
         if (hasValue) {
             complete(value);
         } else {
-            actual.onComplete();
+            int state = get();
+            if (state == NOT_FUSED || state == EMPTY) {
+                lazySet(CONSUMED);
+                actual.onComplete();
+            }
         }
     }
     
     protected final void complete(R value) {
-        if (disposed) {
+        int state = get();
+        if (state == READY || state == CONSUMED || disposed) {
             return;
         }
-        if (fusionState == EMPTY) {
-            fusionState = READY;
+        if (state == EMPTY) {
             this.value = value;
+            lazySet(READY);
+        } else {
+            lazySet(CONSUMED);
         }
         actual.onNext(value);
         if (disposed) {
@@ -96,9 +107,11 @@ protected final void complete(R value) {
     
     @Override
     public final R poll() {
-        if (fusionState == READY) {
-            fusionState = CONSUMED;
-            return value;
+        if (get() == READY) {
+            R v = value;
+            value = null;
+            lazySet(CONSUMED);
+            return v;
         }
         return null;
     }
@@ -116,17 +129,21 @@ public final void dispose() {
     
     @Override
     public final boolean isEmpty() {
-        return fusionState != READY;
+        return get() != READY;
     }
     
     @Override
     public final int requestFusion(int mode) {
-        return mode & QueueDisposable.ASYNC;
+        if ((mode & ASYNC) != 0) {
+            lazySet(EMPTY);
+            return ASYNC;
+        }
+        return NONE;
     }
     
     @Override
     public void clear() {
         value = null;
-        fusionState = CONSUMED;
+        lazySet(CONSUMED);
     }
 }
diff --git a/src/main/java/io/reactivex/internal/subscribers/observable/LambdaObserver.java b/src/main/java/io/reactivex/internal/subscribers/observable/LambdaObserver.java
index ceed46e101..db1202ca19 100644
--- a/src/main/java/io/reactivex/internal/subscribers/observable/LambdaObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/observable/LambdaObserver.java
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.Exceptions;
 import io.reactivex.functions.*;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class LambdaObserver<T> extends AtomicReference<Disposable> implements Observer<T>, Disposable {
diff --git a/src/main/java/io/reactivex/internal/subscribers/single/BiConsumerSingleObserver.java b/src/main/java/io/reactivex/internal/subscribers/single/BiConsumerSingleObserver.java
index f1c92f4c5f..0fdc34efbc 100644
--- a/src/main/java/io/reactivex/internal/subscribers/single/BiConsumerSingleObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/single/BiConsumerSingleObserver.java
@@ -17,9 +17,9 @@
 
 import io.reactivex.SingleObserver;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.Exceptions;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.BiConsumer;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class BiConsumerSingleObserver<T>
@@ -40,7 +40,7 @@ public void onError(Throwable e) {
             onCallback.accept(null, e);
         } catch (Throwable ex) {
             Exceptions.throwIfFatal(ex);
-            RxJavaPlugins.onError(ex);
+            RxJavaPlugins.onError(new CompositeException(e, ex));
         }
     }
     
diff --git a/src/main/java/io/reactivex/internal/subscribers/single/ConsumerSingleObserver.java b/src/main/java/io/reactivex/internal/subscribers/single/ConsumerSingleObserver.java
index 0b1642ba61..2ab30f33b1 100644
--- a/src/main/java/io/reactivex/internal/subscribers/single/ConsumerSingleObserver.java
+++ b/src/main/java/io/reactivex/internal/subscribers/single/ConsumerSingleObserver.java
@@ -19,7 +19,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.*;
 import io.reactivex.functions.Consumer;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.plugins.RxJavaPlugins;
 
 public final class ConsumerSingleObserver<T>
diff --git a/src/main/java/io/reactivex/internal/subscriptions/BooleanSubscription.java b/src/main/java/io/reactivex/internal/subscriptions/BooleanSubscription.java
index ab07e6ee52..623ef14a24 100644
--- a/src/main/java/io/reactivex/internal/subscriptions/BooleanSubscription.java
+++ b/src/main/java/io/reactivex/internal/subscriptions/BooleanSubscription.java
@@ -41,4 +41,9 @@ public void cancel() {
     public boolean isCancelled() {
         return get();
     }
+    
+    @Override
+    public String toString() {
+        return "BooleanSubscription(cancelled=" + get() + ")";
+    }
 }
diff --git a/src/main/java/io/reactivex/internal/util/BlockingHelper.java b/src/main/java/io/reactivex/internal/util/BlockingHelper.java
index 4818bcee49..db688556ae 100644
--- a/src/main/java/io/reactivex/internal/util/BlockingHelper.java
+++ b/src/main/java/io/reactivex/internal/util/BlockingHelper.java
@@ -20,8 +20,11 @@
 /**
  * Utility methods for helping common blocking operations.
  */
-public enum BlockingHelper {
-    ;
+public final class BlockingHelper {
+    /** Utility class. */
+    private BlockingHelper() {
+        throw new IllegalStateException("No instances!");
+    }
     
     public static void awaitForComplete(CountDownLatch latch, Disposable subscription) {
         if (latch.getCount() == 0) {
diff --git a/src/main/java/io/reactivex/internal/util/NotificationLite.java b/src/main/java/io/reactivex/internal/util/NotificationLite.java
index 81f3de0215..c028a1ccc2 100644
--- a/src/main/java/io/reactivex/internal/util/NotificationLite.java
+++ b/src/main/java/io/reactivex/internal/util/NotificationLite.java
@@ -24,20 +24,9 @@
  * Lightweight notification handling utility class.
  */
 public enum NotificationLite {
-    // No instances
+    COMPLETE
     ;
     
-    /**
-     * Indicates a completion notification.
-     */
-    private enum Complete {
-        INSTANCE;
-        @Override
-        public String toString() {
-            return "NotificationLite.Complete";
-        }
-    }
-    
     /**
      * Wraps a Throwable.
      */
@@ -119,7 +108,7 @@ public String toString() {
      * @return a complete notification
      */
     public static Object complete() {
-        return Complete.INSTANCE;
+        return COMPLETE;
     }
     
     /**
@@ -155,7 +144,7 @@ public static Object disposable(Disposable d) {
      * @return true if the object represents a complete notification
      */
     public static boolean isComplete(Object o) {
-        return o == Complete.INSTANCE;
+        return o == COMPLETE;
     }
     
     /**
@@ -224,7 +213,7 @@ public static Disposable getDisposable(Object o) {
      */
     @SuppressWarnings("unchecked")
     public static <T> boolean accept(Object o, Subscriber<? super T> s) {
-        if (o == Complete.INSTANCE) {
+        if (o == COMPLETE) {
             s.onComplete();
             return true;
         } else
@@ -246,7 +235,7 @@ public static Disposable getDisposable(Object o) {
      */
     @SuppressWarnings("unchecked")
     public static <T> boolean accept(Object o, Observer<? super T> s) {
-        if (o == Complete.INSTANCE) {
+        if (o == COMPLETE) {
             s.onComplete();
             return true;
         } else
@@ -268,7 +257,7 @@ public static Disposable getDisposable(Object o) {
      */
     @SuppressWarnings("unchecked")
     public static <T> boolean acceptFull(Object o, Subscriber<? super T> s) {
-        if (o == Complete.INSTANCE) {
+        if (o == COMPLETE) {
             s.onComplete();
             return true;
         } else
@@ -294,7 +283,7 @@ public static Disposable getDisposable(Object o) {
      */
     @SuppressWarnings("unchecked")
     public static <T> boolean acceptFull(Object o, Observer<? super T> s) {
-        if (o == Complete.INSTANCE) {
+        if (o == COMPLETE) {
             s.onComplete();
             return true;
         } else
@@ -309,4 +298,9 @@ public static Disposable getDisposable(Object o) {
         s.onNext((T)o);
         return false;
     }
+
+    @Override
+    public String toString() {
+        return "NotificationLite.Complete";
+    }
 }
diff --git a/src/main/java/io/reactivex/observers/DisposableObserver.java b/src/main/java/io/reactivex/observers/DisposableObserver.java
index 803c9e9af1..e48d51cdfe 100644
--- a/src/main/java/io/reactivex/observers/DisposableObserver.java
+++ b/src/main/java/io/reactivex/observers/DisposableObserver.java
@@ -17,7 +17,7 @@
 
 import io.reactivex.Observer;
 import io.reactivex.disposables.Disposable;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 
 /**
  * An abstract Observer that allows asynchronous cancellation by implementing Disposable.
diff --git a/src/main/java/io/reactivex/observers/SafeObserver.java b/src/main/java/io/reactivex/observers/SafeObserver.java
index ee53f4391a..af0c662cd0 100644
--- a/src/main/java/io/reactivex/observers/SafeObserver.java
+++ b/src/main/java/io/reactivex/observers/SafeObserver.java
@@ -42,9 +42,6 @@ public SafeObserver(Observer<? super T> actual) {
     
     @Override
     public void onSubscribe(Disposable s) {
-        if (done) {
-            return;
-        }
         if (DisposableHelper.validate(this.s, s)) {
             this.s = s;
             try {
@@ -57,7 +54,7 @@ public void onSubscribe(Disposable s) {
                     s.dispose();
                 } catch (Throwable e1) {
                     Exceptions.throwIfFatal(e1);
-                    RxJavaPlugins.onError(e1);
+                    RxJavaPlugins.onError(new CompositeException(e, e1));
                 }
                 RxJavaPlugins.onError(e);
             }
@@ -80,22 +77,60 @@ public void onNext(T t) {
         if (done) {
             return;
         }
-        if (t == null) {
-            onError(new NullPointerException());
+        if (s == null) {
+            onNextNoSubscription();
             return;
         }
-        if (s == null) {
-            onError(null); // null is okay here, onError checks for subscription == null first
+
+        if (t == null) {
+            Throwable ex = new NullPointerException();
+            try {
+                s.dispose();
+            } catch (Throwable e1) {
+                Exceptions.throwIfFatal(e1);
+                onError(new CompositeException(ex, e1));
+                return;
+            }
+            onError(ex);
             return;
         }
+        
         try {
             actual.onNext(t);
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
+            try {
+                s.dispose();
+            } catch (Throwable e1) {
+                Exceptions.throwIfFatal(e1);
+                onError(new CompositeException(e, e1));
+                return;
+            }
             onError(e);
         }
     }
     
+    void onNextNoSubscription() {
+        
+        Throwable ex = new NullPointerException("Subscription not set!");
+        
+        try {
+            actual.onSubscribe(EmptyDisposable.INSTANCE);
+        } catch (Throwable e) {
+            Exceptions.throwIfFatal(e);
+            // can't call onError because the actual's state may be corrupt at this point
+            RxJavaPlugins.onError(new CompositeException(ex, e));
+            return;
+        }
+        try {
+            actual.onError(ex);
+        } catch (Throwable e) {
+            Exceptions.throwIfFatal(e);
+            // if onError failed, all that's left is to report the error to plugins
+            RxJavaPlugins.onError(new CompositeException(ex, e));
+        }
+    }
+    
     @Override
     public void onError(Throwable t) {
         if (done) {
@@ -128,33 +163,16 @@ public void onError(Throwable t) {
             return;
         }
         
-        CompositeException t2 = null;
         if (t == null) {
             t = new NullPointerException();
         }
 
         try {
-            s.dispose();
-        } catch (Throwable e) {
-            Exceptions.throwIfFatal(e);
-            t2 = new CompositeException(e, t);
-        }
-
-        try {
-            if (t2 != null) {
-                actual.onError(t2);
-            } else {
-                actual.onError(t);
-            }
-        } catch (Throwable e) {
-            Exceptions.throwIfFatal(e);
-            if (t2 == null) {
-                RxJavaPlugins.onError(e);
-            } else {
-                t2.suppress(e);
-
-                RxJavaPlugins.onError(t2);
-            }
+            actual.onError(t);
+        } catch (Throwable ex) {
+            Exceptions.throwIfFatal(ex);
+            
+            RxJavaPlugins.onError(new CompositeException(t, ex));
         }
     }
     
@@ -164,30 +182,39 @@ public void onComplete() {
             return;
         }
         if (s == null) {
-            onError(null); // null is okay here, onError checks for subscription == null first
+            onCompleteNoSubscription();
             return;
         }
 
         done = true;
 
         try {
-            s.dispose();
+            actual.onComplete();
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
-            try {
-                actual.onError(e);
-            } catch (Throwable e1) {
-                Exceptions.throwIfFatal(e1);
-                RxJavaPlugins.onError(new CompositeException(e1, e));
-            }
-            return;
+            RxJavaPlugins.onError(e);
         }
+    }
+
+    void onCompleteNoSubscription() {
+        
+        Throwable ex = new NullPointerException("Subscription not set!");
         
         try {
-            actual.onComplete();
+            actual.onSubscribe(EmptyDisposable.INSTANCE);
         } catch (Throwable e) {
             Exceptions.throwIfFatal(e);
-            RxJavaPlugins.onError(e);
+            // can't call onError because the actual's state may be corrupt at this point
+            RxJavaPlugins.onError(new CompositeException(ex, e));
+            return;
+        }
+        try {
+            actual.onError(ex);
+        } catch (Throwable e) {
+            Exceptions.throwIfFatal(e);
+            // if onError failed, all that's left is to report the error to plugins
+            RxJavaPlugins.onError(new CompositeException(ex, e));
         }
     }
+
 }
diff --git a/src/main/java/io/reactivex/observers/TestObserver.java b/src/main/java/io/reactivex/observers/TestObserver.java
index 62aa3ebcbe..0d19c75acd 100644
--- a/src/main/java/io/reactivex/observers/TestObserver.java
+++ b/src/main/java/io/reactivex/observers/TestObserver.java
@@ -21,7 +21,7 @@
 import io.reactivex.disposables.Disposable;
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.Consumer;
-import io.reactivex.internal.disposables.DisposableHelper;
+import io.reactivex.internal.disposables.*;
 import io.reactivex.internal.functions.ObjectHelper;
 import io.reactivex.internal.fuseable.QueueDisposable;
 import io.reactivex.internal.util.ExceptionHelper;
@@ -50,9 +50,6 @@
     /** The last thread seen by the observer. */
     private Thread lastThread;
     
-    /** Makes sure the incoming Disposables get cancelled immediately. */
-    private volatile boolean cancelled;
-
     /** Holds the current subscription if any. */
     private final AtomicReference<Disposable> subscription = new AtomicReference<Disposable>();
 
@@ -113,15 +110,11 @@ public void onSubscribe(Disposable s) {
         if (!subscription.compareAndSet(null, s)) {
             s.dispose();
             if (subscription.get() != DisposableHelper.DISPOSED) {
-                errors.add(new NullPointerException("onSubscribe received multiple subscriptions: " + s));
+                errors.add(new IllegalStateException("onSubscribe received multiple subscriptions: " + s));
             }
             return;
         }
         
-        if (cancelled) {
-            s.dispose();
-        }
-        
         if (initialFusionMode != 0) {
             if (s instanceof QueueDisposable) {
                 qs = (QueueDisposable<T>)s;
@@ -147,12 +140,7 @@ public void onSubscribe(Disposable s) {
             }
         }
 
-        if (cancelled) {
-            return;
-        }
-
         actual.onSubscribe(s);
-        
     }
     
     @Override
@@ -198,10 +186,10 @@ public void onError(Throwable t) {
 
         try {
             lastThread = Thread.currentThread();
-            errors.add(t);
-
             if (t == null) {
-                errors.add(new NullPointerException("onError received a null Subscription"));
+                errors.add(new NullPointerException("onError received a null Throwable"));
+            } else {
+                errors.add(t);
             }
 
             actual.onError(t);
@@ -234,7 +222,7 @@ public void onComplete() {
      * @return true if this TestSubscriber has been cancelled
      */
     public final boolean isCancelled() {
-        return cancelled;
+        return isDisposed();
     }
     
     /**
@@ -248,15 +236,12 @@ public final void cancel() {
     
     @Override
     public final void dispose() {
-        if (!cancelled) {
-            cancelled = true;
-            DisposableHelper.dispose(subscription);
-        }
+        DisposableHelper.dispose(subscription);
     }
 
     @Override
     public final boolean isDisposed() {
-        return cancelled;
+        return DisposableHelper.isDisposed(subscription.get());
     }
 
     // state retrieval methods
@@ -363,7 +348,7 @@ public final boolean await(long time, TimeUnit unit) throws InterruptedException
      * 
      * @param message the message to use
      */
-    private void fail(String message) {
+    private AssertionError fail(String message) {
         StringBuilder b = new StringBuilder(64 + message.length());
         b.append(message);
         
@@ -378,16 +363,12 @@ private void fail(String message) {
         AssertionError ae = new AssertionError(b.toString());
         CompositeException ce = new CompositeException();
         for (Throwable e : errors) {
-            if (e == null) {
-                ce.suppress(new NullPointerException("Throwable was null!"));
-            } else {
-                ce.suppress(e);
-            }
+            ce.suppress(e);
         }
         if (!ce.isEmpty()) {
             ae.initCause(ce);
         }
-        throw ae;
+        return ae;
     }
     
     /**
@@ -397,10 +378,10 @@ private void fail(String message) {
     public final TestObserver<T> assertComplete() {
         long c = completions;
         if (c == 0) {
-            fail("Not completed");
+            throw fail("Not completed");
         } else
         if (c > 1) {
-            fail("Multiple completions: " + c);
+            throw fail("Multiple completions: " + c);
         }
         return this;
     }
@@ -412,10 +393,10 @@ private void fail(String message) {
     public final TestObserver<T> assertNotComplete() {
         long c = completions;
         if (c == 1) {
-            fail("Completed!");
+            throw fail("Completed!");
         } else 
         if (c > 1) {
-            fail("Multiple completions: " + c);
+            throw fail("Multiple completions: " + c);
         }
         return this;
     }
@@ -427,7 +408,7 @@ private void fail(String message) {
     public final TestObserver<T> assertNoErrors() {
         int s = errors.size();
         if (s != 0) {
-            fail("Error(s) present: " + errors);
+            throw fail("Error(s) present: " + errors);
         }
         return this;
     }
@@ -445,14 +426,14 @@ private void fail(String message) {
     public final TestObserver<T> assertError(Throwable error) {
         int s = errors.size();
         if (s == 0) {
-            fail("No errors");
+            throw fail("No errors");
         }
         if (errors.contains(error)) {
             if (s != 1) {
-                fail("Error present but other errors as well");
+                throw fail("Error present but other errors as well");
             }
         } else {
-            fail("Error not present");
+            throw fail("Error not present");
         }
         return this;
     }
@@ -466,7 +447,7 @@ private void fail(String message) {
     public final TestObserver<T> assertError(Class<? extends Throwable> errorClass) {
         int s = errors.size();
         if (s == 0) {
-            fail("No errors");
+            throw fail("No errors");
         }
         
         boolean found = false;
@@ -480,10 +461,10 @@ private void fail(String message) {
         
         if (found) {
             if (s != 1) {
-                fail("Error present but other errors as well");
+                throw fail("Error present but other errors as well");
             }
         } else {
-            fail("Error not present");
+            throw fail("Error not present");
         }
         return this;
     }
@@ -497,11 +478,11 @@ private void fail(String message) {
     public final TestObserver<T> assertValue(T value) {
         int s = values.size();
         if (s != 1) {
-            fail("Expected: " + valueAndClass(value) + ", Actual: " + values);
+            throw fail("Expected: " + valueAndClass(value) + ", Actual: " + values);
         }
         T v = values.get(0);
         if (!ObjectHelper.equals(value, v)) {
-            fail("Expected: " + valueAndClass(value) + ", Actual: " + valueAndClass(v));
+            throw fail("Expected: " + valueAndClass(value) + ", Actual: " + valueAndClass(v));
         }
         return this;
     }
@@ -522,7 +503,7 @@ static String valueAndClass(Object o) {
     public final TestObserver<T> assertValueCount(int count) {
         int s = values.size();
         if (s != count) {
-            fail("Value counts differ; Expected: " + count + ", Actual: " + s);
+            throw fail("Value counts differ; Expected: " + count + ", Actual: " + s);
         }
         return this;
     }
@@ -544,14 +525,14 @@ static String valueAndClass(Object o) {
     public final TestObserver<T> assertValues(T... values) {
         int s = this.values.size();
         if (s != values.length) {
-            fail("Value count differs; Expected: " + values.length + " " + Arrays.toString(values)
+            throw fail("Value count differs; Expected: " + values.length + " " + Arrays.toString(values)
             + ", Actual: " + s + " " + this.values);
         }
         for (int i = 0; i < s; i++) {
             T v = this.values.get(i);
             T u = values[i];
             if (!ObjectHelper.equals(u, v)) {
-                fail("Values at position " + i + " differ; Expected: " + valueAndClass(u) + ", Actual: " + valueAndClass(v));
+                throw fail("Values at position " + i + " differ; Expected: " + valueAndClass(u) + ", Actual: " + valueAndClass(v));
             }
         }
         return this;
@@ -566,14 +547,13 @@ static String valueAndClass(Object o) {
      * @return this;
      */
     public final TestObserver<T> assertValueSet(Collection<? extends T> expected) {
-        int s = this.values.size();
-        if (s != expected.size()) {
-            fail("Value count differs; Expected: " + expected.size() + " " + expected
-            + ", Actual: " + s + " " + this.values);
+        if (expected.isEmpty()) {
+            assertNoValues();
+            return this;
         }
         for (T v : this.values) {
             if (!expected.contains(v)) {
-                fail("Value not in the expected collection: " + valueAndClass(v));
+                throw fail("Value not in the expected collection: " + valueAndClass(v));
             }
         }
         return this;
@@ -588,23 +568,32 @@ static String valueAndClass(Object o) {
         int i = 0;
         Iterator<T> vit = values.iterator();
         Iterator<? extends T> it = sequence.iterator();
-        boolean itNext = false;
-        boolean vitNext = false;
-        while ((itNext = it.hasNext()) && (vitNext = vit.hasNext())) {
+        boolean actualNext = false;
+        boolean expectedNext = false;
+        for (;;) {
+            actualNext = it.hasNext();
+            expectedNext = vit.hasNext();
+
+            if (!actualNext || !expectedNext) {
+                break;
+            }
+            
             T v = it.next();
             T u = vit.next();
             
             if (!ObjectHelper.equals(u, v)) {
-                fail("Values at position " + i + " differ; Expected: " + valueAndClass(u) + ", Actual: " + valueAndClass(v));
+                throw fail("Values at position " + i + " differ; Expected: " + valueAndClass(u) + ", Actual: " + valueAndClass(v));
             }
             i++;
+            actualNext = false;
+            expectedNext = false;
         }
         
-        if (itNext && !vitNext) {
-            fail("More values received than expected (" + i + ")");
+        if (actualNext) {
+            throw fail("More values received than expected (" + i + ")");
         }
-        if (!itNext && !vitNext) {
-            fail("Fever values received than expected (" + i + ")");
+        if (expectedNext) {
+            throw fail("Fever values received than expected (" + i + ")");
         }
         return this;
     }
@@ -615,19 +604,19 @@ static String valueAndClass(Object o) {
      */
     public final TestObserver<T> assertTerminated() {
         if (done.getCount() != 0) {
-            fail("Subscriber still running!");
+            throw fail("Subscriber still running!");
         }
         long c = completions;
         if (c > 1) {
-            fail("Terminated with multiple completions: " + c);
+            throw fail("Terminated with multiple completions: " + c);
         }
         int s = errors.size();
         if (s > 1) {
-            fail("Terminated with multiple errors: " + s);
+            throw fail("Terminated with multiple errors: " + s);
         }
         
         if (c != 0 && s != 0) {
-            fail("Terminated with multiple completions and errors: " + c);
+            throw fail("Terminated with multiple completions and errors: " + c);
         }
         return this;
     }
@@ -638,7 +627,7 @@ static String valueAndClass(Object o) {
      */
     public final TestObserver<T> assertNotTerminated() {
         if (done.getCount() == 0) {
-            fail("Subscriber terminated!");
+            throw fail("Subscriber terminated!");
         }
         return this;
     }
@@ -649,7 +638,7 @@ static String valueAndClass(Object o) {
      */
     public final TestObserver<T> assertSubscribed() {
         if (subscription.get() == null) {
-            fail("Not subscribed!");
+            throw fail("Not subscribed!");
         }
         return this;
     }
@@ -660,10 +649,10 @@ static String valueAndClass(Object o) {
      */
     public final TestObserver<T> assertNotSubscribed() {
         if (subscription.get() != null) {
-            fail("Subscribed!");
+            throw fail("Subscribed!");
         } else
         if (!errors.isEmpty()) {
-            fail("Not subscribed but errors found");
+            throw fail("Not subscribed but errors found");
         }
         return this;
     }
@@ -707,20 +696,19 @@ public final boolean awaitTerminalEvent(long duration, TimeUnit unit) {
     public final TestObserver<T> assertErrorMessage(String message) {
         int s = errors.size();
         if (s == 0) {
-            fail("No errors");
+            throw fail("No errors");
         } else
         if (s == 1) {
             Throwable e = errors.get(0);
             if (e == null) {
-                fail("Error is null");
-                return this;
+                throw fail("Error is null");
             }
             String errorMessage = e.getMessage();
             if (!ObjectHelper.equals(message, errorMessage)) {
-                fail("Error message differs; Expected: " + message + ", Actual: " + errorMessage);
+                throw fail("Error message differs; Expected: " + message + ", Actual: " + errorMessage);
             }
         } else {
-            fail("Multiple errors");
+            throw fail("Multiple errors");
         }
         return this;
     }
@@ -781,7 +769,7 @@ public final boolean awaitTerminalEvent(long duration, TimeUnit unit) {
         return this;
     }
     
-    private String fusionModeToString(int mode) {
+    static String fusionModeToString(int mode) {
         switch (mode) {
         case QueueDisposable.NONE : return "NONE";
         case QueueDisposable.SYNC : return "SYNC";
@@ -874,21 +862,6 @@ private String fusionModeToString(int mode) {
                 .assertNotComplete();
     }
 
-    /**
-     * Awaits until the internal latch is counted down.
-     * <p>If the wait times out or gets interrupted, the TestSubscriber is cancelled.
-     * @return this
-     * @throws InterruptedException if the wait is interrupted
-     */
-    public final TestObserver<T> awaitDone() throws InterruptedException {
-        try {
-            done.await();
-        } catch (InterruptedException ex) {
-            cancel();
-        }
-        return this;
-    }
-
     /**
      * Awaits until the internal latch is counted down.
      * <p>If the wait times out or gets interrupted, the TestSubscriber is cancelled.
@@ -913,7 +886,7 @@ private String fusionModeToString(int mode) {
     /**
      * An observer that ignores all events and does not report errors.
      */
-    private enum EmptyObserver implements Observer<Object> {
+    enum EmptyObserver implements Observer<Object> {
         INSTANCE;
 
         @Override
diff --git a/src/test/java/io/reactivex/TestHelper.java b/src/test/java/io/reactivex/TestHelper.java
index e71ff5fe27..99da8ff3b9 100644
--- a/src/test/java/io/reactivex/TestHelper.java
+++ b/src/test/java/io/reactivex/TestHelper.java
@@ -29,8 +29,11 @@
 
 import io.reactivex.exceptions.CompositeException;
 import io.reactivex.functions.Consumer;
+import io.reactivex.internal.fuseable.SimpleQueue;
 import io.reactivex.internal.util.ExceptionHelper;
+import io.reactivex.observers.TestObserver;
 import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.subscribers.TestSubscriber;
 
 /**
  * Common methods for helping with tests from 1.x mostly.
@@ -104,12 +107,62 @@ public void accept(Throwable t) {
         
         return list;
     }
-    
+
+    public static void assertError(List<Throwable> list, int index, Class<? extends Throwable> clazz) {
+        assertTrue(list.get(index).toString(), clazz.isInstance(list.get(index)));
+    }
+
     public static void assertError(List<Throwable> list, int index, Class<? extends Throwable> clazz, String message) {
         assertTrue(list.get(index).toString(), clazz.isInstance(list.get(index)));
         assertEquals(message, list.get(index).getMessage());
     }
     
+    public static void assertError(TestObserver<?> ts, int index, Class<? extends Throwable> clazz) {
+        Throwable ex = ts.errors().get(0);
+        if (ex instanceof CompositeException) {
+            CompositeException ce = (CompositeException) ex;
+            List<Throwable> cel = ce.getExceptions();
+            assertTrue(cel.get(index).toString(), clazz.isInstance(cel.get(index)));
+        } else {
+            fail(ex.toString() + ": not a CompositeException");
+        }
+    }
+
+    public static void assertError(TestSubscriber<?> ts, int index, Class<? extends Throwable> clazz) {
+        Throwable ex = ts.errors().get(0);
+        if (ex instanceof CompositeException) {
+            CompositeException ce = (CompositeException) ex;
+            List<Throwable> cel = ce.getExceptions();
+            assertTrue(cel.get(index).toString(), clazz.isInstance(cel.get(index)));
+        } else {
+            fail(ex.toString() + ": not a CompositeException");
+        }
+    }
+
+    public static void assertError(TestObserver<?> ts, int index, Class<? extends Throwable> clazz, String message) {
+        Throwable ex = ts.errors().get(0);
+        if (ex instanceof CompositeException) {
+            CompositeException ce = (CompositeException) ex;
+            List<Throwable> cel = ce.getExceptions();
+            assertTrue(cel.get(index).toString(), clazz.isInstance(cel.get(index)));
+            assertEquals(message, cel.get(index).getMessage());
+        } else {
+            fail(ex.toString() + ": not a CompositeException");
+        }
+    }
+
+    public static void assertError(TestSubscriber<?> ts, int index, Class<? extends Throwable> clazz, String message) {
+        Throwable ex = ts.errors().get(0);
+        if (ex instanceof CompositeException) {
+            CompositeException ce = (CompositeException) ex;
+            List<Throwable> cel = ce.getExceptions();
+            assertTrue(cel.get(index).toString(), clazz.isInstance(cel.get(index)));
+            assertEquals(message, cel.get(index).getMessage());
+        } else {
+            fail(ex.toString() + ": not a CompositeException");
+        }
+    }
+
     /**
      * Verify that a specific enum type has no enum constants.
      * @param <E> the enum type
@@ -119,9 +172,14 @@ public static void assertError(List<Throwable> list, int index, Class<? extends
         assertEquals(0, e.getEnumConstants().length);
         
         try {
-            Method m = e.getDeclaredMethod("valueOf", String.class);
-            
             try {
+                Method m0 = e.getDeclaredMethod("values");
+
+                Object[] a = (Object[])m0.invoke(null);
+                assertEquals(0, a.length);
+                
+                Method m = e.getDeclaredMethod("valueOf", String.class);
+            
                 m.invoke("INSTANCE");
                 fail("Should have thrown!");
             } catch (InvocationTargetException ex) {
@@ -250,4 +308,44 @@ public void run() {
             throw new CompositeException(errors);
         }
     }
+    
+    public static List<Throwable> compositeList(Throwable ex) {
+        return ((CompositeException)ex).getExceptions();
+    }
+    
+    /**
+     * Assert that the offer methods throw UnsupportedOperationExcetpion.
+     * @param q the queue implementation
+     */
+    public static void assertNoOffer(SimpleQueue<?> q) {
+        try {
+            q.offer(null);
+            fail("Should have thrown!");
+        } catch (UnsupportedOperationException ex) {
+            // expected
+        }
+        try {
+            q.offer(null, null);
+            fail("Should have thrown!");
+        } catch (UnsupportedOperationException ex) {
+            // expected
+        }
+    }
+    
+    @SuppressWarnings("unchecked")
+    public static <E extends Enum<E>> void checkEnum(Class<E> enumClass) {
+        try {
+            Method m = enumClass.getMethod("values");
+            m.setAccessible(true);
+            Method e = enumClass.getMethod("valueOf", String.class);
+            m.setAccessible(true);
+            
+            for (Enum<E> o : (Enum<E>[])m.invoke(null)) {
+                assertSame(o, e.invoke(null, o.name()));
+            }
+            
+        } catch (Throwable ex) {
+            throw ExceptionHelper.wrapOrThrow(ex);
+        }
+    }
 }
diff --git a/src/test/java/io/reactivex/disposables/DisposablesTest.java b/src/test/java/io/reactivex/disposables/DisposablesTest.java
index a7d4cbdb5b..30c0ae3323 100644
--- a/src/test/java/io/reactivex/disposables/DisposablesTest.java
+++ b/src/test/java/io/reactivex/disposables/DisposablesTest.java
@@ -23,6 +23,7 @@
 
 import io.reactivex.TestHelper;
 import io.reactivex.functions.Action;
+import io.reactivex.schedulers.Schedulers;
 
 
 public class DisposablesTest {
@@ -116,4 +117,20 @@ public void run() throws Exception {
         }
 
     }
+    
+    @Test
+    public void disposeRace() {
+        for (int i = 0; i < 100; i++) {
+            final Disposable d = Disposables.empty();
+            
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    d.dispose();
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.io());
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java b/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
index 4086761b4e..89eba5d179 100644
--- a/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
+++ b/src/test/java/io/reactivex/flowable/FlowableSubscriberTest.java
@@ -13,7 +13,7 @@
 
 package io.reactivex.flowable;
 
-import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.*;
 
 import java.util.*;
 import java.util.concurrent.*;
@@ -22,9 +22,15 @@
 import org.junit.*;
 import org.reactivestreams.*;
 
-import io.reactivex.Flowable;
-import io.reactivex.FlowableOperator;
+import io.reactivex.*;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.*;
+import io.reactivex.functions.*;
 import io.reactivex.internal.functions.Functions;
+import io.reactivex.internal.subscribers.flowable.ForEachWhileSubscriber;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.processors.PublishProcessor;
 import io.reactivex.subscribers.*;
 
 public class FlowableSubscriberTest {
@@ -546,4 +552,183 @@ public void onNext(Integer t) {
             }});
         assertEquals(Arrays.asList(1,2,3,4,5), list);
     }
+    
+    @Test
+    public void forEachWhile() {
+        PublishProcessor<Integer> pp = PublishProcessor.create();
+        
+        final List<Integer> list = new ArrayList<Integer>();
+        
+        Disposable d = pp.forEachWhile(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) throws Exception {
+                list.add(v);
+                return v < 3;
+            }
+        });
+        
+        assertFalse(d.isDisposed());
+        
+        pp.onNext(1);
+        pp.onNext(2);
+        pp.onNext(3);
+        
+        assertFalse(pp.hasSubscribers());
+        
+        assertEquals(Arrays.asList(1, 2, 3), list);
+    }
+    
+    @Test
+    public void doubleSubscribe() {
+        ForEachWhileSubscriber<Integer> s = new ForEachWhileSubscriber<Integer>(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) throws Exception {
+                return true;
+            }
+        }, Functions.<Throwable>emptyConsumer(), Functions.EMPTY_ACTION);
+        
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            s.onSubscribe(new BooleanSubscription());
+            
+            BooleanSubscription d = new BooleanSubscription();
+            s.onSubscribe(d);
+            
+            assertTrue(d.isCancelled());
+            
+            TestHelper.assertError(list, 0, IllegalStateException.class, "Subscription already set!");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void suppressAfterCompleteEvents() {
+        final TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        ts.onSubscribe(new BooleanSubscription());
+
+        ForEachWhileSubscriber<Integer> s = new ForEachWhileSubscriber<Integer>(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) throws Exception {
+                ts.onNext(v);
+                return true;
+            }
+        }, new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) throws Exception {
+                ts.onError(e);
+            }
+        }, new Action() {
+            @Override
+            public void run() throws Exception {
+                ts.onComplete();
+            }
+        });
+
+        s.onComplete();
+        s.onNext(1);
+        s.onError(new TestException());
+        s.onComplete();
+        
+        ts.assertResult();
+    }
+
+    @Test
+    public void onNextCrashes() {
+        final TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
+        ts.onSubscribe(new BooleanSubscription());
+
+        ForEachWhileSubscriber<Integer> s = new ForEachWhileSubscriber<Integer>(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) throws Exception {
+                throw new TestException();
+            }
+        }, new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) throws Exception {
+                ts.onError(e);
+            }
+        }, new Action() {
+            @Override
+            public void run() throws Exception {
+                ts.onComplete();
+            }
+        });
+
+        BooleanSubscription b = new BooleanSubscription();
+        
+        s.onSubscribe(b);
+        s.onNext(1);
+        
+        assertTrue(b.isCancelled());
+        ts.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void onErrorThrows() {
+        ForEachWhileSubscriber<Integer> s = new ForEachWhileSubscriber<Integer>(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) throws Exception {
+                return true;
+            }
+        }, new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) throws Exception {
+                throw new TestException("Inner");
+            }
+        }, new Action() {
+            @Override
+            public void run() throws Exception {
+                
+            }
+        });
+        
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            s.onSubscribe(new BooleanSubscription());
+            
+            s.onError(new TestException("Outer"));
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> cel = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(cel, 0, TestException.class, "Outer");
+            TestHelper.assertError(cel, 1, TestException.class, "Inner");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteThrows() {
+        ForEachWhileSubscriber<Integer> s = new ForEachWhileSubscriber<Integer>(new Predicate<Integer>() {
+            @Override
+            public boolean test(Integer v) throws Exception {
+                return true;
+            }
+        }, new Consumer<Throwable>() {
+            @Override
+            public void accept(Throwable e) throws Exception {
+            }
+        }, new Action() {
+            @Override
+            public void run() throws Exception {
+                throw new TestException("Inner");
+            }
+        });
+        
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            s.onSubscribe(new BooleanSubscription());
+            
+            s.onComplete();
+            
+            TestHelper.assertError(list, 0, TestException.class, "Inner");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/internal/disposables/ArrayCompositeDisposableTest.java b/src/test/java/io/reactivex/internal/disposables/ArrayCompositeDisposableTest.java
new file mode 100644
index 0000000000..9cf746cfed
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/disposables/ArrayCompositeDisposableTest.java
@@ -0,0 +1,119 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.disposables;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.disposables.*;
+import io.reactivex.schedulers.Schedulers;
+
+public class ArrayCompositeDisposableTest {
+
+    @Test
+    public void normal() {
+        ArrayCompositeDisposable acd = new ArrayCompositeDisposable(2);
+        
+        Disposable d1 = Disposables.empty();
+        Disposable d2 = Disposables.empty();
+        
+        assertTrue(acd.setResource(0, d1));
+        assertTrue(acd.setResource(1, d2));
+        
+        Disposable d3 = Disposables.empty();
+        Disposable d4 = Disposables.empty();
+        
+        acd.replaceResource(0, d3);
+        acd.replaceResource(1, d4);
+        
+        assertFalse(d1.isDisposed());
+        assertFalse(d2.isDisposed());
+        
+        acd.setResource(0, d1);
+        acd.setResource(1, d2);
+        
+        assertTrue(d3.isDisposed());
+        assertTrue(d4.isDisposed());
+
+        assertFalse(acd.isDisposed());
+
+        acd.dispose();
+        acd.dispose();
+        
+        assertTrue(acd.isDisposed());
+        
+        assertTrue(d1.isDisposed());
+        assertTrue(d2.isDisposed());
+        
+        Disposable d5 = Disposables.empty();
+        Disposable d6 = Disposables.empty();
+
+        assertFalse(acd.setResource(0, d5));
+        acd.replaceResource(1, d6);
+    
+        assertTrue(d5.isDisposed());
+        assertTrue(d6.isDisposed());
+    }
+    
+    @Test
+    public void disposeRace() {
+        for (int i = 0; i < 100; i++) {
+            final ArrayCompositeDisposable acd = new ArrayCompositeDisposable(2);
+            
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    acd.dispose();
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.io());
+        }        
+    }
+
+    @Test
+    public void replaceRace() {
+        for (int i = 0; i < 100; i++) {
+            final ArrayCompositeDisposable acd = new ArrayCompositeDisposable(2);
+            
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    acd.replaceResource(0, Disposables.empty());
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.io());
+        }        
+    }
+
+    @Test
+    public void setRace() {
+        for (int i = 0; i < 100; i++) {
+            final ArrayCompositeDisposable acd = new ArrayCompositeDisposable(2);
+            
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    acd.setResource(0, Disposables.empty());
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.io());
+        }        
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/disposables/CancellableDisposableTest.java b/src/test/java/io/reactivex/internal/disposables/CancellableDisposableTest.java
new file mode 100644
index 0000000000..89242103d3
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/disposables/CancellableDisposableTest.java
@@ -0,0 +1,112 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.disposables;
+
+import static org.junit.Assert.*;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.Cancellable;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.schedulers.Schedulers;
+
+public class CancellableDisposableTest {
+
+    @Test
+    public void normal() {
+        final AtomicInteger count = new AtomicInteger();
+        
+        Cancellable c = new Cancellable() {
+            @Override
+            public void cancel() throws Exception {
+                count.getAndIncrement();
+            }
+        };
+        
+        CancellableDisposable cd = new CancellableDisposable(c);
+        
+        assertFalse(cd.isDisposed());
+        
+        cd.dispose();
+        cd.dispose();
+        
+        assertTrue(cd.isDisposed());
+        
+        assertEquals(1, count.get());
+    }
+
+    @Test
+    public void cancelThrows() {
+        final AtomicInteger count = new AtomicInteger();
+        
+        Cancellable c = new Cancellable() {
+            @Override
+            public void cancel() throws Exception {
+                count.getAndIncrement();
+                throw new TestException();
+            }
+        };
+        
+        CancellableDisposable cd = new CancellableDisposable(c);
+        
+        assertFalse(cd.isDisposed());
+
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        try {
+            cd.dispose();
+            cd.dispose();
+            
+            TestHelper.assertError(list, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+        assertTrue(cd.isDisposed());
+        
+        assertEquals(1, count.get());
+    }
+    
+    @Test
+    public void disposeRace() {
+
+        for (int i = 0; i < 100; i++) {
+            final AtomicInteger count = new AtomicInteger();
+            
+            Cancellable c = new Cancellable() {
+                @Override
+                public void cancel() throws Exception {
+                    count.getAndIncrement();
+                }
+            };
+            
+            final CancellableDisposable cd = new CancellableDisposable(c);
+    
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    cd.dispose();
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.io());
+            
+            assertEquals(1, count.get());
+        }
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/disposables/DisposableHelperTest.java b/src/test/java/io/reactivex/internal/disposables/DisposableHelperTest.java
new file mode 100644
index 0000000000..032ef5f554
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/disposables/DisposableHelperTest.java
@@ -0,0 +1,121 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.disposables;
+
+import static org.junit.Assert.*;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.disposables.*;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.schedulers.Schedulers;
+
+public class DisposableHelperTest {
+    @Test
+    public void enumMethods() {
+        assertEquals(1, DisposableHelper.values().length);
+        assertNotNull(DisposableHelper.valueOf("DISPOSED"));
+    }
+    
+    @Test
+    public void innerDisposed() {
+        assertTrue(DisposableHelper.DISPOSED.isDisposed());
+        DisposableHelper.DISPOSED.dispose();
+        assertTrue(DisposableHelper.DISPOSED.isDisposed());
+    }
+    
+    @Test
+    public void validationNull() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        try {
+            assertFalse(DisposableHelper.validate(null, null));
+            
+            TestHelper.assertError(list, 0, NullPointerException.class, "next is null");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void disposeRace() {
+        for (int i = 0; i < 500; i++) {
+            final AtomicReference<Disposable> d = new AtomicReference<Disposable>();
+            
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    DisposableHelper.dispose(d);
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void setReplace() {
+        for (int i = 0; i < 500; i++) {
+            final AtomicReference<Disposable> d = new AtomicReference<Disposable>();
+            
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    DisposableHelper.replace(d, Disposables.empty());
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.io());
+        }
+    }
+
+    @Test
+    public void setRace() {
+        for (int i = 0; i < 500; i++) {
+            final AtomicReference<Disposable> d = new AtomicReference<Disposable>();
+            
+            Runnable r = new Runnable() {
+                @Override
+                public void run() {
+                    DisposableHelper.set(d, Disposables.empty());
+                }
+            };
+            
+            TestHelper.race(r, r, Schedulers.io());
+        }
+    }
+    
+    @Test
+    public void setReplaceNull() {
+        final AtomicReference<Disposable> d = new AtomicReference<Disposable>();
+
+        DisposableHelper.dispose(d);
+        
+        assertFalse(DisposableHelper.set(d, null));
+        assertFalse(DisposableHelper.replace(d, null));
+    }
+
+    @Test
+    public void dispose() {
+        Disposable u = Disposables.empty();
+        final AtomicReference<Disposable> d = new AtomicReference<Disposable>(u);
+        
+        DisposableHelper.dispose(d);
+        
+        assertTrue(u.isDisposed());
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/disposables/EmptyDisposableTest.java b/src/test/java/io/reactivex/internal/disposables/EmptyDisposableTest.java
new file mode 100644
index 0000000000..50832deeca
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/disposables/EmptyDisposableTest.java
@@ -0,0 +1,40 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.disposables;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.internal.fuseable.QueueDisposable;
+
+public class EmptyDisposableTest {
+
+    @Test
+    public void noOffer() {
+        TestHelper.assertNoOffer(EmptyDisposable.INSTANCE);
+    }
+    
+    @Test
+    public void asyncFusion() {
+        assertEquals(QueueDisposable.NONE, EmptyDisposable.INSTANCE.requestFusion(QueueDisposable.SYNC));
+        assertEquals(QueueDisposable.ASYNC, EmptyDisposable.INSTANCE.requestFusion(QueueDisposable.ASYNC));
+    }
+    
+    @Test
+    public void checkEnum() {
+        assertEquals(1, EmptyDisposable.values().length);
+        assertNotNull(EmptyDisposable.valueOf("INSTANCE"));
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/disposables/ListCompositeDisposableTest.java b/src/test/java/io/reactivex/internal/disposables/ListCompositeDisposableTest.java
new file mode 100644
index 0000000000..26a56ba85e
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/disposables/ListCompositeDisposableTest.java
@@ -0,0 +1,178 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.disposables;
+
+import static org.junit.Assert.*;
+
+import java.util.*;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.*;
+
+public class ListCompositeDisposableTest {
+
+    @Test
+    public void constructorAndAddVarargs() {
+        Disposable d1 = Disposables.empty();
+        Disposable d2 = Disposables.empty();
+        
+        ListCompositeDisposable lcd = new ListCompositeDisposable(d1, d2);
+        
+        lcd.clear();
+        
+        assertFalse(lcd.isDisposed());
+        
+        assertTrue(d1.isDisposed());
+        assertTrue(d2.isDisposed());
+
+        d1 = Disposables.empty();
+        d2 = Disposables.empty();
+
+        lcd.addAll(d1, d2);
+        
+        lcd.dispose();
+        
+        assertTrue(lcd.isDisposed());
+        assertTrue(d1.isDisposed());
+        assertTrue(d2.isDisposed());
+    }
+
+    @Test
+    public void constructorIterable() {
+        Disposable d1 = Disposables.empty();
+        Disposable d2 = Disposables.empty();
+        
+        ListCompositeDisposable lcd = new ListCompositeDisposable(Arrays.asList(d1, d2));
+        
+        lcd.clear();
+        
+        assertFalse(lcd.isDisposed());
+        
+        assertTrue(d1.isDisposed());
+        assertTrue(d2.isDisposed());
+
+        d1 = Disposables.empty();
+        d2 = Disposables.empty();
+
+        lcd.add(d1);
+        lcd.addAll(d2);
+        
+        lcd.dispose();
+        
+        assertTrue(lcd.isDisposed());
+        assertTrue(d1.isDisposed());
+        assertTrue(d2.isDisposed());
+    }
+
+    @Test
+    public void empty() {
+        ListCompositeDisposable lcd = new ListCompositeDisposable();
+        
+        assertFalse(lcd.isDisposed());
+        
+        lcd.clear();
+        
+        assertFalse(lcd.isDisposed());
+        
+        lcd.dispose();
+
+        lcd.dispose();
+        
+        lcd.clear();
+        
+        assertTrue(lcd.isDisposed());
+    }
+    
+    @Test
+    public void afterDispose() {
+        ListCompositeDisposable lcd = new ListCompositeDisposable();
+        lcd.dispose();
+        
+        Disposable d = Disposables.empty();
+        assertFalse(lcd.add(d));
+        assertTrue(d.isDisposed());
+        
+        d = Disposables.empty();
+        assertFalse(lcd.addAll(d));
+        assertTrue(d.isDisposed());
+    }
+    
+    @Test
+    public void disposeThrows() {
+        Disposable d = new Disposable() {
+
+            @Override
+            public void dispose() {
+                throw new TestException();
+            }
+
+            @Override
+            public boolean isDisposed() {
+                return false;
+            }
+            
+        };
+        
+        ListCompositeDisposable lcd = new ListCompositeDisposable(d, d);
+        
+        try {
+            lcd.dispose();
+            fail("Should have thrown!");
+        } catch (CompositeException ex) {
+            List<Throwable> list = ex.getExceptions();
+            TestHelper.assertError(list, 0, TestException.class);
+            TestHelper.assertError(list, 1, TestException.class);
+        }
+        
+        lcd = new ListCompositeDisposable(d);
+        
+        try {
+            lcd.dispose();
+            fail("Should have thrown!");
+        } catch (TestException  ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void remove() {
+        ListCompositeDisposable lcd = new ListCompositeDisposable();
+        Disposable d = Disposables.empty();
+        
+        lcd.add(d);
+        
+        assertTrue(lcd.delete(d));
+        
+        assertFalse(d.isDisposed());
+        
+        lcd.add(d);
+        
+        assertTrue(lcd.remove(d));
+        
+        assertTrue(d.isDisposed());
+        
+        assertFalse(lcd.remove(d));
+        
+        assertFalse(lcd.delete(d));
+        
+        lcd = new ListCompositeDisposable();
+        
+        assertFalse(lcd.remove(d));
+
+        assertFalse(lcd.delete(d));
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/operators/completable/CompletableSubscribeTest.java b/src/test/java/io/reactivex/internal/operators/completable/CompletableSubscribeTest.java
index 422aa3e145..c07900012b 100644
--- a/src/test/java/io/reactivex/internal/operators/completable/CompletableSubscribeTest.java
+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableSubscribeTest.java
@@ -17,6 +17,7 @@
 import org.junit.Test;
 
 import io.reactivex.processors.PublishProcessor;
+import io.reactivex.subjects.PublishSubject;
 
 public class CompletableSubscribeTest {
     @Test
@@ -28,4 +29,14 @@ public void subscribeAlreadyCancelled() {
         
         assertFalse(pp.hasSubscribers());
     }
+
+
+    @Test
+    public void methodTestNoCancel() {
+        PublishSubject<Integer> ps = PublishSubject.create();
+        
+        ps.toCompletable().test(false);
+        
+        assertTrue(ps.hasObservers());
+    }
 }
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/FlowableBlockingTest.java b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBlockingTest.java
new file mode 100644
index 0000000000..53f8c2adbc
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableBlockingTest.java
@@ -0,0 +1,217 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.operators.flowable;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.*;
+
+import org.junit.Test;
+import org.reactivestreams.*;
+
+import io.reactivex.Flowable;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.schedulers.Schedulers;
+
+public class FlowableBlockingTest {
+
+    @Test
+    public void blockingFirst() {
+        assertEquals(1, Flowable.range(1, 10)
+                .subscribeOn(Schedulers.computation()).blockingFirst().intValue());
+    }
+
+    @Test
+    public void blockingFirstDefault() {
+        assertEquals(1, Flowable.<Integer>empty()
+                .subscribeOn(Schedulers.computation()).blockingFirst(1).intValue());
+    }
+
+    @Test
+    public void blockingSubscribeConsumer() {
+        final List<Integer> list = new ArrayList<Integer>();
+        
+        Flowable.range(1, 5)
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5), list);
+    }
+
+    @Test
+    public void blockingSubscribeConsumerConsumer() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        Flowable.range(1, 5)
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer v) throws Exception {
+                list.add(v);
+            }
+        }, Functions.emptyConsumer());
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5), list);
+    }
+
+    @Test
+    public void blockingSubscribeConsumerConsumerError() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        TestException ex = new TestException();
+        
+        Consumer<Object> cons = new Consumer<Object>() {
+            @Override
+            public void accept(Object v) throws Exception {
+                list.add(v);
+            }
+        };
+        
+        Flowable.range(1, 5).concatWith(Flowable.<Integer>error(ex))
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(cons, cons);
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5, ex), list);
+    }
+
+    @Test
+    public void blockingSubscribeConsumerConsumerAction() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        Consumer<Object> cons = new Consumer<Object>() {
+            @Override
+            public void accept(Object v) throws Exception {
+                list.add(v);
+            }
+        };
+        
+        Flowable.range(1, 5)
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(cons, cons, new Action() {
+            @Override
+            public void run() throws Exception {
+                list.add(100);
+            }
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 100), list);
+    }
+
+    @Test
+    public void blockingSubscribeObserver() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        Flowable.range(1, 5)
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(new Subscriber<Object>() {
+
+            @Override
+            public void onSubscribe(Subscription d) {
+                d.request(Long.MAX_VALUE);
+            }
+
+            @Override
+            public void onNext(Object value) {
+                list.add(value);
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                list.add(e);
+            }
+
+            @Override
+            public void onComplete() {
+                list.add(100);
+            }
+            
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 100), list);
+    }
+
+    @Test
+    public void blockingSubscribeObserverError() {
+        final List<Object> list = new ArrayList<Object>();
+        
+        final TestException ex = new TestException();
+        
+        Flowable.range(1, 5).concatWith(Flowable.<Integer>error(ex))
+        .subscribeOn(Schedulers.computation())
+        .blockingSubscribe(new Subscriber<Object>() {
+
+            @Override
+            public void onSubscribe(Subscription d) {
+                d.request(Long.MAX_VALUE);
+            }
+
+            @Override
+            public void onNext(Object value) {
+                list.add(value);
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                list.add(e);
+            }
+
+            @Override
+            public void onComplete() {
+                list.add(100);
+            }
+            
+        });
+        
+        assertEquals(Arrays.asList(1, 2, 3, 4, 5, ex), list);
+    }
+
+    @Test(expected = TestException.class)
+    public void blockingForEachThrows() {
+        Flowable.just(1)
+        .blockingForEach(new Consumer<Integer>() {
+            @Override
+            public void accept(Integer e) throws Exception {
+                throw new TestException();
+            }
+        });
+    }
+    
+    @Test(expected = NoSuchElementException.class)
+    public void blockingFirstEmpty() {
+        Flowable.empty().blockingFirst();
+    }
+
+    @Test(expected = NoSuchElementException.class)
+    public void blockingLastEmpty() {
+        Flowable.empty().blockingLast();
+    }
+
+    @Test
+    public void blockingFirstNormal() {
+        assertEquals(1, Flowable.just(1, 2).blockingFirst(3).intValue());
+    }
+
+    @Test
+    public void blockingLastNormal() {
+        assertEquals(2, Flowable.just(1, 2).blockingLast(3).intValue());
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/operators/flowable/NotificationLiteTest.java b/src/test/java/io/reactivex/internal/operators/flowable/NotificationLiteTest.java
index 574852d387..c14e3ea379 100644
--- a/src/test/java/io/reactivex/internal/operators/flowable/NotificationLiteTest.java
+++ b/src/test/java/io/reactivex/internal/operators/flowable/NotificationLiteTest.java
@@ -16,7 +16,12 @@
 import static org.junit.Assert.*;
 
 import org.junit.Test;
+import org.reactivestreams.Subscription;
 
+import io.reactivex.TestHelper;
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.subscriptions.BooleanSubscription;
 import io.reactivex.internal.util.NotificationLite;
 
 
@@ -38,6 +43,70 @@ public void testValueKind() {
         assertSame(1, NotificationLite.next(1));
     }
     
+    @Test
+    public void soloEnum() {
+        TestHelper.checkEnum(NotificationLite.class);
+    }
+    
+    @Test
+    public void errorNotification() {
+        Object o = NotificationLite.error(new TestException());
+        
+        assertEquals("NotificationLite.Error[io.reactivex.exceptions.TestException]", o.toString());
+        
+        assertTrue(NotificationLite.isError(o));
+        assertFalse(NotificationLite.isComplete(o));
+        assertFalse(NotificationLite.isDisposable(o));
+        assertFalse(NotificationLite.isSubscription(o));
+        
+        assertTrue(NotificationLite.getError(o) instanceof TestException);
+    }
+    
+    @Test
+    public void completeNotification() {
+        Object o = NotificationLite.complete();
+        Object o2 = NotificationLite.complete();
+        
+        assertSame(o, o2);
+
+        assertFalse(NotificationLite.isError(o));
+        assertTrue(NotificationLite.isComplete(o));
+        assertFalse(NotificationLite.isDisposable(o));
+        assertFalse(NotificationLite.isSubscription(o));
+
+        assertEquals("NotificationLite.Complete", o.toString());
+        
+        assertTrue(NotificationLite.isComplete(o));
+    }
+
+    @Test
+    public void disposableNotification() {
+        Object o = NotificationLite.disposable(Disposables.empty());
+        
+        assertEquals("NotificationLite.Disposable[RunnableDisposable(disposed=false, EmptyRunnable)]", o.toString());
+
+        assertFalse(NotificationLite.isError(o));
+        assertFalse(NotificationLite.isComplete(o));
+        assertTrue(NotificationLite.isDisposable(o));
+        assertFalse(NotificationLite.isSubscription(o));
+
+        assertTrue(NotificationLite.getDisposable(o) instanceof Disposable);
+    }
+    
+    @Test
+    public void subscriptionNotification() {
+        Object o = NotificationLite.subscription(new BooleanSubscription());
+        
+        assertEquals("NotificationLite.Subscription[BooleanSubscription(cancelled=false)]", o.toString());
+
+        assertFalse(NotificationLite.isError(o));
+        assertFalse(NotificationLite.isComplete(o));
+        assertFalse(NotificationLite.isDisposable(o));
+        assertTrue(NotificationLite.isSubscription(o));
+
+        assertTrue(NotificationLite.getSubscription(o) instanceof Subscription);
+    }
+
     // TODO this test is no longer relevant as nulls are not allowed and value maps to itself
 //    @Test
 //    public void testValueKind() {
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
index 14751098ef..de861b4beb 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableCollectTest.java
@@ -1,3 +1,16 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
 package io.reactivex.internal.operators.observable;
 
 import static io.reactivex.internal.util.TestingHelper.*;
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableFromTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableFromTest.java
index 4054ad9326..2ce55c1ecb 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableFromTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFromTest.java
@@ -30,7 +30,7 @@ public void fromFutureTimeout() throws Exception {
         Observable.fromFuture(Observable.never()
         .toFuture(), 100, TimeUnit.MILLISECONDS, Schedulers.io())
         .test()
-        .awaitDone()
+        .awaitDone(5, TimeUnit.SECONDS)
         .assertFailure(TimeoutException.class);
     }
     
diff --git a/src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java b/src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java
index 39f1c735c6..716ea9033d 100644
--- a/src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java
+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableUsingTest.java
@@ -296,7 +296,7 @@ public void testUsingDisposesEagerlyBeforeCompletion() {
         
         o.safeSubscribe(NbpObserver);
 
-        assertEquals(Arrays.asList("disposed", "completed", "unsub"), events);
+        assertEquals(Arrays.asList("disposed", "completed" /* , "unsub" */), events);
 
     }
 
@@ -323,7 +323,7 @@ public void testUsingDoesNotDisposesEagerlyBeforeCompletion() {
         
         o.safeSubscribe(NbpObserver);
 
-        assertEquals(Arrays.asList("completed", "unsub", "disposed"), events);
+        assertEquals(Arrays.asList("completed", /*"unsub",*/ "disposed"), events);
 
     }
 
@@ -353,7 +353,7 @@ public void testUsingDisposesEagerlyBeforeError() {
         
         o.safeSubscribe(NbpObserver);
 
-        assertEquals(Arrays.asList("disposed", "error", "unsub"), events);
+        assertEquals(Arrays.asList("disposed", "error" /*, "unsub"*/), events);
 
     }
     
@@ -381,7 +381,7 @@ public void testUsingDoesNotDisposesEagerlyBeforeError() {
         
         o.safeSubscribe(NbpObserver);
 
-        assertEquals(Arrays.asList("error", "unsub", "disposed"), events);
+        assertEquals(Arrays.asList("error", /* "unsub",*/ "disposed"), events);
     }
 
     private static Action createUnsubAction(final List<String> events) {
diff --git a/src/test/java/io/reactivex/internal/subscribers/observable/DeferredScalarObserverTest.java b/src/test/java/io/reactivex/internal/subscribers/observable/DeferredScalarObserverTest.java
new file mode 100644
index 0000000000..8aeaba499b
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/subscribers/observable/DeferredScalarObserverTest.java
@@ -0,0 +1,460 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.subscribers.observable;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+import io.reactivex.*;
+import io.reactivex.disposables.*;
+import io.reactivex.exceptions.TestException;
+import io.reactivex.internal.fuseable.QueueDisposable;
+import io.reactivex.observers.*;
+
+public class DeferredScalarObserverTest {
+
+    static final class TakeFirst extends DeferredScalarObserver<Integer, Integer> {
+        public TakeFirst(Observer<? super Integer> actual) {
+            super(actual);
+        }
+
+        /** */
+        private static final long serialVersionUID = -2793723002312330530L;
+
+        @Override
+        public void onNext(Integer value) {
+            s.dispose();
+            complete(value);
+            complete(value);
+        }
+        
+    }
+    
+    @Test
+    public void normal() {
+        TestObserver<Integer> to = new TestObserver<Integer>();
+        
+        TakeFirst source = new TakeFirst(to);
+        
+        source.onSubscribe(Disposables.empty());
+        
+        Disposable d = Disposables.empty();
+        source.onSubscribe(d);
+        
+        assertTrue(d.isDisposed());
+        
+        source.onNext(1);
+        
+        to.assertResult(1);
+    }
+
+    @Test
+    public void error() {
+        TestObserver<Integer> to = new TestObserver<Integer>();
+        
+        TakeFirst source = new TakeFirst(to);
+        
+        source.onSubscribe(Disposables.empty());
+        source.onError(new TestException());
+        
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void complete() {
+        TestObserver<Integer> to = new TestObserver<Integer>();
+        
+        TakeFirst source = new TakeFirst(to);
+        
+        source.onSubscribe(Disposables.empty());
+        source.onComplete();
+        
+        to.assertResult();
+    }
+    
+    @Test
+    public void dispose() {
+        TestObserver<Integer> to = new TestObserver<Integer>();
+        
+        TakeFirst source = new TakeFirst(to);
+        
+        Disposable d = Disposables.empty();
+        
+        source.onSubscribe(d);
+
+        assertFalse(d.isDisposed());
+        
+        to.cancel();
+        
+        assertTrue(d.isDisposed());
+        
+        assertTrue(source.isDisposed());
+    }
+
+    @Test
+    public void fused() {
+        TestObserver<Integer> to = ObserverFusion.newTest(QueueDisposable.ANY);
+        
+        TakeFirst source = new TakeFirst(to);
+        
+        Disposable d = Disposables.empty();
+        
+        source.onSubscribe(d);
+        
+        to.assertOf(ObserverFusion.<Integer>assertFuseable());
+        to.assertOf(ObserverFusion.<Integer>assertFusionMode(QueueDisposable.ASYNC));
+        
+        source.onNext(1);
+        source.onNext(1);
+        source.onError(new TestException());
+        source.onComplete();
+        
+        assertTrue(d.isDisposed());
+        
+        to.assertResult(1);
+    }
+
+    @Test
+    public void fusedReject() {
+        TestObserver<Integer> to = ObserverFusion.newTest(QueueDisposable.SYNC);
+        
+        TakeFirst source = new TakeFirst(to);
+        
+        Disposable d = Disposables.empty();
+        
+        source.onSubscribe(d);
+        
+        to.assertOf(ObserverFusion.<Integer>assertFuseable());
+        to.assertOf(ObserverFusion.<Integer>assertFusionMode(QueueDisposable.NONE));
+        
+        source.onNext(1);
+        source.onNext(1);
+        source.onError(new TestException());
+        source.onComplete();
+        
+        assertTrue(d.isDisposed());
+        
+        to.assertResult(1);
+    }
+
+    static final class TakeLast extends DeferredScalarObserver<Integer, Integer> {
+        public TakeLast(Observer<? super Integer> actual) {
+            super(actual);
+        }
+
+        /** */
+        private static final long serialVersionUID = -2793723002312330530L;
+
+        @Override
+        public void onNext(Integer value) {
+            hasValue = true;
+            this.value = value;
+        }
+        
+    }
+
+    @Test
+    public void nonfusedTerminateMore() {
+        TestObserver<Integer> to = ObserverFusion.newTest(QueueDisposable.NONE);
+        
+        TakeLast source = new TakeLast(to);
+        
+        Disposable d = Disposables.empty();
+        
+        source.onSubscribe(d);
+
+        source.onNext(1);
+        source.onComplete();
+        source.onComplete();
+        source.onError(new TestException());
+        
+        to.assertResult(1);
+    }
+
+    @Test
+    public void nonfusedError() {
+        TestObserver<Integer> to = ObserverFusion.newTest(QueueDisposable.NONE);
+        
+        TakeLast source = new TakeLast(to);
+        
+        Disposable d = Disposables.empty();
+        
+        source.onSubscribe(d);
+
+        source.onNext(1);
+        source.onError(new TestException());
+        source.onError(new TestException());
+        source.onComplete();
+        
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void fusedTerminateMore() {
+        TestObserver<Integer> to = ObserverFusion.newTest(QueueDisposable.ANY);
+        
+        TakeLast source = new TakeLast(to);
+        
+        Disposable d = Disposables.empty();
+        
+        source.onSubscribe(d);
+
+        source.onNext(1);
+        source.onComplete();
+        source.onComplete();
+        source.onError(new TestException());
+        
+        to.assertResult(1);
+    }
+
+    @Test
+    public void fusedError() {
+        TestObserver<Integer> to = ObserverFusion.newTest(QueueDisposable.ANY);
+        
+        TakeLast source = new TakeLast(to);
+        
+        Disposable d = Disposables.empty();
+        
+        source.onSubscribe(d);
+
+        source.onNext(1);
+        source.onError(new TestException());
+        source.onError(new TestException());
+        source.onComplete();
+        
+        to.assertFailure(TestException.class);
+    }
+
+    @Test
+    public void disposed() {
+        TestObserver<Integer> to = ObserverFusion.newTest(QueueDisposable.NONE);
+        
+        TakeLast source = new TakeLast(to);
+        
+        Disposable d = Disposables.empty();
+        
+        source.onSubscribe(d);
+
+        to.cancel();
+        
+        source.onNext(1);
+        source.onComplete();
+
+        to.assertNoValues().assertNoErrors().assertNotComplete();
+    }
+    
+    @Test
+    public void disposedAfterOnNext() {
+        final TestObserver<Integer> to = new TestObserver<Integer>();
+        
+        TakeLast source = new TakeLast(new Observer<Integer>() {
+            Disposable d;
+
+            @Override
+            public void onSubscribe(Disposable d) {
+                this.d = d;
+                to.onSubscribe(d);
+            }
+
+            @Override
+            public void onNext(Integer value) {
+                to.onNext(value);
+                d.dispose();
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                to.onError(e);
+            }
+
+            @Override
+            public void onComplete() {
+                to.onComplete();
+            }
+        });
+        
+        source.onSubscribe(Disposables.empty());
+        source.onNext(1);
+        source.onComplete();
+        
+        to.assertValue(1).assertNoErrors().assertNotComplete();
+    }
+
+    @Test
+    public void fusedEmpty() {
+        TestObserver<Integer> to = ObserverFusion.newTest(QueueDisposable.ANY);
+        
+        TakeLast source = new TakeLast(to);
+        
+        Disposable d = Disposables.empty();
+        
+        source.onSubscribe(d);
+
+        source.onComplete();
+        
+        to.assertResult();
+    }
+
+    @Test
+    public void nonfusedEmpty() {
+        TestObserver<Integer> to = ObserverFusion.newTest(QueueDisposable.NONE);
+        
+        TakeLast source = new TakeLast(to);
+        
+        Disposable d = Disposables.empty();
+        
+        source.onSubscribe(d);
+
+        source.onComplete();
+        
+        to.assertResult();
+    }
+
+    @Test
+    public void customFusion() {
+        final TestObserver<Integer> to = new TestObserver<Integer>();
+        
+        TakeLast source = new TakeLast(new Observer<Integer>() {
+            QueueDisposable<Integer> d;
+
+            @SuppressWarnings("unchecked")
+            @Override
+            public void onSubscribe(Disposable d) {
+                this.d = (QueueDisposable<Integer>)d;
+                to.onSubscribe(d);
+                this.d.requestFusion(QueueDisposable.ANY);
+            }
+
+            @Override
+            public void onNext(Integer value) {
+                if (!d.isEmpty()) {
+                    Integer v = null;
+                    try {
+                        to.onNext(d.poll());
+                    
+                        v = d.poll();
+                    } catch (Throwable ex) {
+                        to.onError(ex);
+                    }
+                        
+                    assertNull(v);
+                    assertTrue(d.isEmpty());
+                }
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                to.onError(e);
+            }
+
+            @Override
+            public void onComplete() {
+                to.onComplete();
+            }
+        });
+        
+        source.onSubscribe(Disposables.empty());
+        source.onNext(1);
+        source.onComplete();
+        
+        to.assertResult(1);
+    }
+
+    @Test
+    public void customFusionClear() {
+        final TestObserver<Integer> to = new TestObserver<Integer>();
+        
+        TakeLast source = new TakeLast(new Observer<Integer>() {
+            QueueDisposable<Integer> d;
+
+            @SuppressWarnings("unchecked")
+            @Override
+            public void onSubscribe(Disposable d) {
+                this.d = (QueueDisposable<Integer>)d;
+                to.onSubscribe(d);
+                this.d.requestFusion(QueueDisposable.ANY);
+            }
+
+            @Override
+            public void onNext(Integer value) {
+                d.clear();
+                assertTrue(d.isEmpty());
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                to.onError(e);
+            }
+
+            @Override
+            public void onComplete() {
+                to.onComplete();
+            }
+        });
+        
+        source.onSubscribe(Disposables.empty());
+        source.onNext(1);
+        source.onComplete();
+        
+        to.assertNoValues().assertNoErrors().assertComplete();
+    }
+
+    @Test
+    public void offerThrow() {
+        TestObserver<Integer> to = ObserverFusion.newTest(QueueDisposable.NONE);
+        
+        TakeLast source = new TakeLast(to);
+
+        TestHelper.assertNoOffer(source);
+    }
+
+    @Test
+    public void customFusionDontConsume() {
+        final TestObserver<Integer> to = new TestObserver<Integer>();
+        
+        TakeFirst source = new TakeFirst(new Observer<Integer>() {
+            QueueDisposable<Integer> d;
+
+            @SuppressWarnings("unchecked")
+            @Override
+            public void onSubscribe(Disposable d) {
+                this.d = (QueueDisposable<Integer>)d;
+                to.onSubscribe(d);
+                this.d.requestFusion(QueueDisposable.ANY);
+            }
+
+            @Override
+            public void onNext(Integer value) {
+                // not consuming
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                to.onError(e);
+            }
+
+            @Override
+            public void onComplete() {
+                to.onComplete();
+            }
+        });
+        
+        source.onSubscribe(Disposables.empty());
+        source.onNext(1);
+        
+        to.assertNoValues().assertNoErrors().assertComplete();
+    }
+
+}
diff --git a/src/test/java/io/reactivex/internal/util/BlockingHelperTest.java b/src/test/java/io/reactivex/internal/util/BlockingHelperTest.java
new file mode 100644
index 0000000000..a3b5eb202f
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/util/BlockingHelperTest.java
@@ -0,0 +1,65 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.util;
+
+import static org.junit.Assert.*;
+
+import java.util.concurrent.*;
+
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+import io.reactivex.disposables.*;
+import io.reactivex.schedulers.Schedulers;
+
+public class BlockingHelperTest {
+
+    @Test
+    public void emptyEnum() {
+        TestHelper.checkUtilityClass(BlockingHelper.class);
+    }
+    
+    @Test
+    public void interrupted() {
+        CountDownLatch cdl = new CountDownLatch(1);
+        Disposable d = Disposables.empty();
+        
+        Thread.currentThread().interrupt();
+        
+        try {
+            BlockingHelper.awaitForComplete(cdl, d);
+        } catch (IllegalStateException ex) {
+            // expected
+        }
+        assertTrue(d.isDisposed());
+        assertTrue(Thread.interrupted());
+    }
+    
+    @Test
+    public void unblock() {
+        final CountDownLatch cdl = new CountDownLatch(1);
+        Disposable d = Disposables.empty();
+        
+        Schedulers.computation().scheduleDirect(new Runnable() {
+            @Override
+            public void run() {
+                cdl.countDown();
+            }
+        }, 100, TimeUnit.MILLISECONDS);
+        
+        BlockingHelper.awaitForComplete(cdl, d);
+        
+        assertFalse(d.isDisposed());
+    }
+}
diff --git a/src/test/java/io/reactivex/internal/util/MiscUtilTest.java b/src/test/java/io/reactivex/internal/util/MiscUtilTest.java
new file mode 100644
index 0000000000..cce84e44c9
--- /dev/null
+++ b/src/test/java/io/reactivex/internal/util/MiscUtilTest.java
@@ -0,0 +1,43 @@
+/**
+ * Copyright 2016 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
+ * the License for the specific language governing permissions and limitations under the License.
+ */
+
+package io.reactivex.internal.util;
+
+import static org.junit.Assert.*;
+import org.junit.Test;
+
+import io.reactivex.TestHelper;
+
+public class MiscUtilTest {
+    @Test
+    public void pow2UtilityClass() {
+        TestHelper.checkUtilityClass(Pow2.class);
+    }
+    
+    @Test
+    public void isPowerOf2() {
+        for (int i = 1; i > 0; i *= 2) {
+            assertTrue(Pow2.isPowerOfTwo(i));
+        }
+        
+        assertFalse(Pow2.isPowerOfTwo(3));
+        assertFalse(Pow2.isPowerOfTwo(5));
+        assertFalse(Pow2.isPowerOfTwo(6));
+        assertFalse(Pow2.isPowerOfTwo(7));
+    }
+    
+    @Test
+    public void hashMapSupplier() {
+        TestHelper.checkEnum(HashMapSupplier.class);
+    }
+}
diff --git a/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java b/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
index cc01e7a747..c35a050796 100644
--- a/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
+++ b/src/test/java/io/reactivex/observable/ObservableSubscriberTest.java
@@ -178,4 +178,15 @@ public void safeSubscriberAlreadySafe() {
         
         ts.assertResult(1);
     }
+
+
+    @Test
+    public void methodTestNoCancel() {
+        PublishSubject<Integer> ps = PublishSubject.create();
+        
+        ps.test(false);
+        
+        assertTrue(ps.hasObservers());
+    }
+
 }
diff --git a/src/test/java/io/reactivex/observers/SafeObserverTest.java b/src/test/java/io/reactivex/observers/SafeObserverTest.java
index 55fd057e13..02f6805925 100644
--- a/src/test/java/io/reactivex/observers/SafeObserverTest.java
+++ b/src/test/java/io/reactivex/observers/SafeObserverTest.java
@@ -20,9 +20,10 @@
 
 import org.junit.*;
 
-import io.reactivex.Observer;
+import io.reactivex.*;
 import io.reactivex.disposables.*;
 import io.reactivex.exceptions.*;
+import io.reactivex.plugins.RxJavaPlugins;
 
 public class SafeObserverTest {
 
@@ -486,4 +487,433 @@ public void onComplete() {
 
         assertSame(actual, s.actual);
     }
+    
+    @Test
+    public void dispose() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        
+        SafeObserver<Integer> so = new SafeObserver<Integer>(ts);
+        
+        Disposable d = Disposables.empty();
+        
+        so.onSubscribe(d);
+        
+        ts.dispose();
+        
+        assertTrue(d.isDisposed());
+        
+        assertTrue(so.isDisposed());
+    }
+
+    @Test
+    public void onNextAfterComplete() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        
+        SafeObserver<Integer> so = new SafeObserver<Integer>(ts);
+        
+        Disposable d = Disposables.empty();
+        
+        so.onSubscribe(d);
+
+        so.onComplete();
+        
+        so.onNext(1);
+        
+        so.onError(new TestException());
+        
+        so.onComplete();
+        
+        ts.assertResult();
+    }
+
+    @Test
+    public void onNextNull() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        
+        SafeObserver<Integer> so = new SafeObserver<Integer>(ts);
+        
+        Disposable d = Disposables.empty();
+        
+        so.onSubscribe(d);
+
+        so.onNext(null);
+        
+        ts.assertFailure(NullPointerException.class);
+    }
+
+    @Test
+    public void onNextWithoutOnSubscribe() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        
+        SafeObserver<Integer> so = new SafeObserver<Integer>(ts);
+        
+        so.onNext(1);
+        
+        ts.assertFailureAndMessage(NullPointerException.class, "Subscription not set!");
+    }
+
+    @Test
+    public void onErrorWithoutOnSubscribe() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        
+        SafeObserver<Integer> so = new SafeObserver<Integer>(ts);
+        
+        so.onError(new TestException());
+        
+        ts.assertFailure(CompositeException.class);
+        
+        TestHelper.assertError(ts, 0, TestException.class);
+        TestHelper.assertError(ts, 1, NullPointerException.class, "Subscription not set!");
+    }
+
+    @Test
+    public void onCompleteWithoutOnSubscribe() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        
+        SafeObserver<Integer> so = new SafeObserver<Integer>(ts);
+        
+        so.onComplete();
+        
+        ts.assertFailureAndMessage(NullPointerException.class, "Subscription not set!");
+    }
+
+    @Test
+    public void onNextNormal() {
+        TestObserver<Integer> ts = new TestObserver<Integer>();
+        
+        SafeObserver<Integer> so = new SafeObserver<Integer>(ts);
+        
+        Disposable d = Disposables.empty();
+        
+        so.onSubscribe(d);
+
+        so.onNext(1);
+        so.onComplete();
+        
+        ts.assertResult(1);
+    }
+    
+    static final class CrashDummy implements Observer<Object>, Disposable {
+        boolean crashOnSubscribe;
+        int crashOnNext;
+        boolean crashOnError;
+        boolean crashOnComplete;
+        
+        boolean crashDispose;
+        
+        Throwable error;
+        
+        public CrashDummy(boolean crashOnSubscribe, int crashOnNext, 
+                boolean crashOnError, boolean crashOnComplete, boolean crashDispose) {
+            this.crashOnSubscribe = crashOnSubscribe;
+            this.crashOnNext = crashOnNext;
+            this.crashOnError = crashOnError;
+            this.crashOnComplete = crashOnComplete;
+            this.crashDispose = crashDispose;
+        }
+
+        @Override
+        public void dispose() {
+            if (crashDispose) {
+                throw new TestException("dispose()");
+            }
+        }
+
+        @Override
+        public boolean isDisposed() {
+            return false;
+        }
+
+        @Override
+        public void onSubscribe(Disposable d) {
+            if (crashOnSubscribe) {
+                throw new TestException("onSubscribe()");
+            }
+        }
+
+        @Override
+        public void onNext(Object value) {
+            if (--crashOnNext == 0) {
+                throw new TestException("onNext(" + value + ")");
+            }
+        }
+
+        @Override
+        public void onError(Throwable e) {
+            if (crashOnError) {
+                throw new TestException("onError(" + e + ")");
+            }
+            error = e;
+        }
+
+        @Override
+        public void onComplete() {
+            if (crashOnComplete) {
+                throw new TestException("onComplete()");
+            }
+        }
+        
+        public SafeObserver<Object> toSafe() {
+            return new SafeObserver<Object>(this);
+        }
+        
+        public CrashDummy assertError(Class<? extends Throwable> clazz) {
+            if (!clazz.isInstance(error)) {
+                throw new AssertionError("Different error: " + error);
+            }
+            return this;
+        }
+        
+        public CrashDummy assertInnerError(int index, Class<? extends Throwable> clazz) {
+            List<Throwable> cel = TestHelper.compositeList(error);
+            TestHelper.assertError(cel, index, clazz);
+            return this;
+        }
+
+        public CrashDummy assertInnerError(int index, Class<? extends Throwable> clazz, String message) {
+            List<Throwable> cel = TestHelper.compositeList(error);
+            TestHelper.assertError(cel, index, clazz, message);
+            return this;
+        }
+
+    }
+
+    @Test
+    public void onNextOnErrorCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, true, false, false);
+            SafeObserver<Object> so = cd.toSafe();
+            so.onSubscribe(cd);
+            
+            so.onNext(1);
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, TestException.class, "onNext(1)");
+            TestHelper.assertError(ce, 1, TestException.class, "onError(io.reactivex.exceptions.TestException: onNext(1))");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onNextDisposeCrash() {
+        CrashDummy cd = new CrashDummy(false, 1, false, false, true);
+        SafeObserver<Object> so = cd.toSafe();
+        so.onSubscribe(cd);
+        
+        so.onNext(1);
+
+        cd.assertError(CompositeException.class);
+        cd.assertInnerError(0, TestException.class, "onNext(1)");
+        cd.assertInnerError(1, TestException.class, "dispose()");
+    }
+
+    @Test
+    public void onSubscribeTwice() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, false, false, false);
+            SafeObserver<Object> so = cd.toSafe();
+            so.onSubscribe(cd);
+            so.onSubscribe(cd);
+            
+            TestHelper.assertError(list, 0, IllegalStateException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onSubscribeCrashes() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(true, 1, false, false, false);
+            SafeObserver<Object> so = cd.toSafe();
+            so.onSubscribe(cd);
+            
+            TestHelper.assertError(list, 0, TestException.class, "onSubscribe()");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onSubscribeAndDisposeCrashes() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(true, 1, false, false, true);
+            SafeObserver<Object> so = cd.toSafe();
+            so.onSubscribe(cd);
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, TestException.class, "onSubscribe()");
+            TestHelper.assertError(ce, 1, TestException.class, "dispose()");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onNextOnSubscribeCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(true, 1, false, false, false);
+            SafeObserver<Object> so = cd.toSafe();
+
+            so.onNext(1);
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, NullPointerException.class, "Subscription not set!");
+            TestHelper.assertError(ce, 1, TestException.class, "onSubscribe()");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+    
+    @Test
+    public void onNextNullDisposeCrashes() {
+        CrashDummy cd = new CrashDummy(false, 1, false, false, true);
+        SafeObserver<Object> so = cd.toSafe();
+        so.onSubscribe(cd);
+        
+        so.onNext(null);
+        
+        cd.assertInnerError(0, NullPointerException.class);
+        cd.assertInnerError(1, TestException.class, "dispose()");
+    }
+
+    @Test
+    public void noSubscribeOnErrorCrashes() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, true, false, false);
+            SafeObserver<Object> so = cd.toSafe();
+
+            so.onNext(1);
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, NullPointerException.class, "Subscription not set!");
+            TestHelper.assertError(ce, 1, TestException.class, "onError(java.lang.NullPointerException: Subscription not set!)");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onErrorNull() {
+        CrashDummy cd = new CrashDummy(false, 1, false, false, false);
+        SafeObserver<Object> so = cd.toSafe();
+        so.onSubscribe(cd);
+        
+        so.onError(null);
+        
+        cd.assertError(NullPointerException.class);
+    }
+
+    @Test
+    public void onErrorNoSubscribeCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(true, 1, false, false, false);
+            SafeObserver<Object> so = cd.toSafe();
+            
+            so.onError(new TestException());
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, TestException.class);
+            TestHelper.assertError(ce, 1, NullPointerException.class, "Subscription not set!");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onErrorNoSubscribeOnErrorCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, true, false, false);
+            SafeObserver<Object> so = cd.toSafe();
+            
+            so.onError(new TestException());
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, TestException.class);
+            TestHelper.assertError(ce, 1, NullPointerException.class, "Subscription not set!");
+            TestHelper.assertError(ce, 2, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteteCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, false, true, false);
+            SafeObserver<Object> so = cd.toSafe();
+            
+            so.onSubscribe(cd);
+            
+            so.onComplete();
+            
+            TestHelper.assertError(list, 0, TestException.class, "onComplete()");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteteNoSubscribeCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(true, 1, false, true, false);
+            SafeObserver<Object> so = cd.toSafe();
+            
+            so.onComplete();
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, NullPointerException.class, "Subscription not set!");
+            TestHelper.assertError(ce, 1, TestException.class, "onSubscribe()");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void onCompleteteNoSubscribeOnErrorCrash() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            CrashDummy cd = new CrashDummy(false, 1, true, true, false);
+            SafeObserver<Object> so = cd.toSafe();
+            
+            so.onComplete();
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> ce = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(ce, 0, NullPointerException.class, "Subscription not set!");
+            TestHelper.assertError(ce, 1, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
 }
diff --git a/src/test/java/io/reactivex/observers/TestObserverTest.java b/src/test/java/io/reactivex/observers/TestObserverTest.java
index 020de05b23..7c21341929 100644
--- a/src/test/java/io/reactivex/observers/TestObserverTest.java
+++ b/src/test/java/io/reactivex/observers/TestObserverTest.java
@@ -16,7 +16,9 @@
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
 
+import java.io.IOException;
 import java.util.*;
+import java.util.concurrent.*;
 
 import org.junit.*;
 import org.junit.rules.ExpectedException;
@@ -24,9 +26,14 @@
 import org.reactivestreams.Subscriber;
 
 import io.reactivex.*;
+import io.reactivex.disposables.*;
 import io.reactivex.exceptions.TestException;
+import io.reactivex.functions.Consumer;
+import io.reactivex.internal.fuseable.QueueDisposable;
+import io.reactivex.internal.operators.observable.ObservableScalarXMap.ScalarDisposable;
 import io.reactivex.internal.subscriptions.EmptySubscription;
 import io.reactivex.processors.PublishProcessor;
+import io.reactivex.schedulers.Schedulers;
 import io.reactivex.subscribers.TestSubscriber;
 
 public class TestObserverTest {
@@ -232,4 +239,641 @@ public void testTerminalOneKind() {
         }
         fail("Failed to report multiple kinds of events!");
     }
+    
+    @Test
+    public void createDelegate() {
+        TestObserver<Integer> ts1 = TestObserver.create();
+        
+        TestObserver<Integer> ts = TestObserver.create(ts1);
+        
+        ts.assertNotSubscribed();
+
+        assertFalse(ts.hasSubscription());
+
+        ts.onSubscribe(Disposables.empty());
+        
+        try {
+            ts.assertNotSubscribed();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+        assertTrue(ts.hasSubscription());
+        
+        assertFalse(ts.isDisposed());
+        
+        ts.onNext(1);
+        ts.onError(new TestException());
+        ts.onComplete();
+        
+        ts1.assertValue(1).assertError(TestException.class).assertComplete();
+        
+        ts.dispose();
+        
+        assertTrue(ts.isDisposed());
+        
+        assertTrue(ts.isTerminated());
+        
+        assertSame(Thread.currentThread(), ts.lastThread());
+
+        try {
+            ts.assertNoValues();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+
+        try {
+            ts.assertValueCount(0);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+        
+        ts.assertValueSequence(Arrays.asList(1));
+        
+        try {
+            ts.assertValueSequence(Arrays.asList(2));
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+
+        ts.assertValueSet(Collections.singleton(1));
+
+        try {
+            ts.assertValueSet(Collections.singleton(2));
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+
+    }
+    
+    @Test
+    public void assertError() {
+        TestObserver<Integer> ts = TestObserver.create();
+        
+        try {
+            ts.assertError(TestException.class);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+        try {
+            ts.assertError(new TestException());
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+        try {
+            ts.assertErrorMessage("");
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            
+        }
+
+        try {
+            ts.assertSubscribed();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            
+        }
+
+        try {
+            ts.assertTerminated();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            
+        }
+
+        ts.onSubscribe(Disposables.empty());
+
+        ts.assertSubscribed();
+        
+        ts.assertNoErrors();
+
+        TestException ex = new TestException("Forced failure");
+        
+        ts.onError(ex);
+
+        ts.assertError(ex);
+        
+        ts.assertError(TestException.class);
+
+        ts.assertErrorMessage("Forced failure");
+        
+        try {
+            ts.assertErrorMessage("");
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            
+        }
+        
+        try {
+            ts.assertError(new RuntimeException());
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+
+        try {
+            ts.assertError(IOException.class);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+
+        try {
+            ts.assertNoErrors();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError exc) {
+            // expected
+        }
+        
+        ts.assertTerminated();
+        
+        ts.assertValueCount(0);
+        
+        ts.assertNoValues();
+        
+        
+    }
+    
+    @Test
+    public void emptyObserverEnum() {
+        assertEquals(1, TestObserver.EmptyObserver.values().length);
+        assertNotNull(TestObserver.EmptyObserver.valueOf("INSTANCE"));
+    }
+    
+    @Test
+    public void valueAndClass() {
+        assertEquals("null", TestObserver.valueAndClass(null));
+        assertEquals("1 (class: Integer)", TestObserver.valueAndClass(1));
+    }
+    
+    @Test
+    public void assertFailure() {
+        TestObserver<Integer> ts = TestObserver.create();
+        
+        ts.onSubscribe(Disposables.empty());
+        
+        ts.onError(new TestException("Forced failure"));
+
+        ts.assertFailure(TestException.class);
+        
+        ts.assertFailureAndMessage(TestException.class, "Forced failure");
+        
+        ts.onNext(1);
+
+        ts.assertFailure(TestException.class, 1);
+        
+        ts.assertFailureAndMessage(TestException.class, "Forced failure", 1);
+    }
+    
+    @Test
+    public void assertFuseable() {
+        TestObserver<Integer> ts = TestObserver.create();
+
+        ts.onSubscribe(Disposables.empty());
+        
+        ts.assertNotFuseable();
+        
+        try {
+            ts.assertFuseable();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        ts = TestObserver.create();
+        ts.setInitialFusionMode(QueueDisposable.ANY);
+        
+        ts.onSubscribe(new ScalarDisposable<Integer>(ts, 1));
+        
+        ts.assertFuseable();
+        
+        ts.assertFusionMode(QueueDisposable.SYNC);
+        
+        try {
+            ts.assertFusionMode(QueueDisposable.NONE);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        try {
+            ts.assertNotFuseable();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+    }
+    
+    @Test
+    public void assertTerminated() {
+        TestObserver<Integer> ts = TestObserver.create();
+        
+        ts.assertNotTerminated();
+        
+        ts.onError(null);
+        
+        try {
+            ts.assertNotTerminated();
+            throw new RuntimeException("Should have thrown!");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void assertOf() {
+        TestObserver<Integer> ts = TestObserver.create();
+       
+        ts.assertOf(new Consumer<TestObserver<Integer>>() {
+            @Override
+            public void accept(TestObserver<Integer> f) throws Exception {
+                f.assertNotSubscribed();
+            }
+        });
+        
+        try {
+            ts.assertOf(new Consumer<TestObserver<Integer>>() {
+                @Override
+                public void accept(TestObserver<Integer> f) throws Exception {
+                    f.assertSubscribed();
+                }
+            });
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        try {
+            ts.assertOf(new Consumer<TestObserver<Integer>>() {
+                @Override
+                public void accept(TestObserver<Integer> f) throws Exception {
+                    throw new IllegalArgumentException();
+                }
+            });
+            throw new RuntimeException("Should have thrown");
+        } catch (IllegalArgumentException ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void assertResult() {
+        TestObserver<Integer> ts = TestObserver.create();
+
+        ts.onSubscribe(Disposables.empty());
+        
+        ts.onComplete();
+        
+        ts.assertResult();
+        
+        try {
+            ts.assertResult(1);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        ts.onNext(1);
+        
+        ts.assertResult(1);
+        
+        try {
+            ts.assertResult(2);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        try {
+            ts.assertResult();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+    }
+    
+    @Test(timeout = 5000)
+    public void await() throws Exception {
+        TestObserver<Integer> ts = TestObserver.create();
+
+        ts.onSubscribe(Disposables.empty());
+
+        assertFalse(ts.await(100, TimeUnit.MILLISECONDS));
+        
+        ts.awaitDone(100, TimeUnit.MILLISECONDS);
+        
+        assertTrue(ts.isDisposed());
+
+        assertFalse(ts.awaitTerminalEvent(100, TimeUnit.MILLISECONDS));
+        
+        assertEquals(0, ts.completions());
+        assertEquals(0, ts.errorCount());
+
+        ts.onComplete();
+        
+        assertTrue(ts.await(100, TimeUnit.MILLISECONDS));
+        
+        ts.await();
+        
+        ts.awaitDone(5, TimeUnit.SECONDS);
+        
+        assertEquals(1, ts.completions());
+        assertEquals(0, ts.errorCount());
+        
+        assertTrue(ts.awaitTerminalEvent());
+        
+        final TestObserver<Integer> ts1 = TestObserver.create();
+
+        ts1.onSubscribe(Disposables.empty());
+
+        Schedulers.single().scheduleDirect(new Runnable() {
+            @Override
+            public void run() {
+                ts1.onComplete();
+            }
+        }, 200, TimeUnit.MILLISECONDS);
+        
+        ts1.await();
+        
+        ts1.assertValueSet(Collections.<Integer>emptySet());
+    }
+    
+    @Test
+    public void errors() {
+        TestObserver<Integer> ts = TestObserver.create();
+
+        ts.onSubscribe(Disposables.empty());
+
+        assertEquals(0, ts.errors().size());
+        
+        ts.onError(new TestException());
+
+        assertEquals(1, ts.errors().size());
+        
+        TestHelper.assertError(ts.errors(), 0, TestException.class);
+    }
+    
+    @SuppressWarnings("unchecked")
+    @Test
+    public void onNext() {
+        TestObserver<Integer> ts = TestObserver.create();
+
+        ts.onSubscribe(Disposables.empty());
+
+        assertEquals(0, ts.valueCount());
+        
+        assertEquals(Arrays.asList(), ts.values());
+        
+        ts.onNext(1);
+        
+        assertEquals(Arrays.asList(1), ts.values());
+        
+        ts.cancel();
+        
+        assertTrue(ts.isCancelled());
+        assertTrue(ts.isDisposed());
+        
+        ts.assertValue(1);
+        
+        assertEquals(Arrays.asList(Arrays.asList(1), Collections.emptyList(), Collections.emptyList()), ts.getEvents());
+    }
+    
+    @Test
+    public void fusionModeToString() {
+        assertEquals("NONE", TestObserver.fusionModeToString(QueueDisposable.NONE));
+        assertEquals("SYNC", TestObserver.fusionModeToString(QueueDisposable.SYNC));
+        assertEquals("ASYNC", TestObserver.fusionModeToString(QueueDisposable.ASYNC));
+        assertEquals("Unknown(100)", TestObserver.fusionModeToString(100));
+    }
+    
+    @Test
+    public void multipleTerminals() {
+        TestObserver<Integer> ts = TestObserver.create();
+
+        ts.onSubscribe(Disposables.empty());
+
+        ts.assertNotComplete();
+
+        ts.onComplete();
+
+        try {
+            ts.assertNotComplete();
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+
+        ts.assertTerminated();
+        
+        ts.onComplete();
+        
+        try {
+            ts.assertComplete();
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+
+        try {
+            ts.assertTerminated();
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+
+        try {
+            ts.assertNotComplete();
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void assertValue() {
+        TestObserver<Integer> ts = TestObserver.create();
+
+        ts.onSubscribe(Disposables.empty());
+
+        try {
+            ts.assertValue(1);
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+        
+        ts.onNext(1);
+        
+        ts.assertValue(1);
+        
+        try {
+            ts.assertValue(2);
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+
+        ts.onNext(2);
+        
+        try {
+            ts.assertValue(1);
+            throw new RuntimeException("Should have thrown");
+        } catch (Throwable ex) {
+            // expected
+        }
+    }
+
+    @Test
+    public void onNextMisbehave() {
+        TestObserver<Integer> ts = TestObserver.create();
+
+        ts.onNext(1);
+        
+        ts.assertError(IllegalStateException.class);
+        
+        ts = TestObserver.create();
+        
+        ts.onSubscribe(Disposables.empty());
+        
+        ts.onNext(null);
+        
+        ts.assertFailure(NullPointerException.class, (Integer)null);
+    }
+    
+    @Test
+    public void awaitTerminalEventInterrupt() {
+        final TestObserver<Integer> ts = TestObserver.create();
+        
+        ts.onSubscribe(Disposables.empty());
+
+        Thread.currentThread().interrupt();
+        
+        ts.awaitTerminalEvent();
+
+        assertTrue(Thread.interrupted());
+        
+        Thread.currentThread().interrupt();
+
+        ts.awaitTerminalEvent(5, TimeUnit.SECONDS);
+
+        assertTrue(Thread.interrupted());
+    }
+    
+    @Test
+    public void assertTerminated2() {
+        TestObserver<Integer> ts = TestObserver.create();
+        
+        ts.onSubscribe(Disposables.empty());
+
+        assertFalse(ts.isTerminated());
+        
+        ts.onError(new TestException());
+        ts.onError(new IOException());
+        
+        assertTrue(ts.isTerminated());
+        
+        try {
+            ts.assertTerminated();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+        try {
+            ts.assertError(TestException.class);
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+        
+
+        ts = TestObserver.create();
+        
+        ts.onSubscribe(Disposables.empty());
+
+        ts.onError(new TestException());
+        ts.onComplete();
+
+        try {
+            ts.assertTerminated();
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
+    
+    @Test
+    public void onSubscribe() {
+        TestObserver<Integer> ts = TestObserver.create();
+        
+        ts.onSubscribe(null);
+        
+        ts.assertFailure(NullPointerException.class);
+
+        ts = TestObserver.create();
+        
+        ts.onSubscribe(Disposables.empty());
+        
+        Disposable d1 = Disposables.empty();
+        
+        ts.onSubscribe(d1);
+        
+        assertTrue(d1.isDisposed());
+        
+        ts.assertError(IllegalStateException.class);
+
+        ts = TestObserver.create();
+        ts.dispose();
+        
+        d1 = Disposables.empty();
+        
+        ts.onSubscribe(d1);
+        
+        assertTrue(d1.isDisposed());
+        
+    }
+
+    @Test
+    public void assertValueSequence() {
+        TestObserver<Integer> ts = TestObserver.create();
+
+        ts.onSubscribe(Disposables.empty());
+        
+        ts.onNext(1);
+        ts.onNext(2);
+        
+        try {
+            ts.assertValueSequence(Arrays.<Integer>asList());
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+        try {
+            ts.assertValueSequence(Arrays.asList(1));
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+
+        ts.assertValueSequence(Arrays.asList(1, 2));
+
+        try {
+            ts.assertValueSequence(Arrays.asList(1, 2, 3));
+            throw new RuntimeException("Should have thrown");
+        } catch (AssertionError ex) {
+            // expected
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/io/reactivex/single/SingleSubscribeTest.java b/src/test/java/io/reactivex/single/SingleSubscribeTest.java
index e489dd0020..41c7517d73 100644
--- a/src/test/java/io/reactivex/single/SingleSubscribeTest.java
+++ b/src/test/java/io/reactivex/single/SingleSubscribeTest.java
@@ -15,11 +15,17 @@
 
 import static org.junit.Assert.*;
 
+import java.util.List;
+
 import org.junit.Test;
 
 import io.reactivex.*;
-import io.reactivex.exceptions.TestException;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.*;
 import io.reactivex.functions.*;
+import io.reactivex.internal.functions.Functions;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.subjects.PublishSubject;
 
 public class SingleSubscribeTest {
 
@@ -86,5 +92,129 @@ protected void subscribeActual(SingleObserver<? super Integer> observer) {
             }
         }
     }
+    
+    @Test
+    public void biConsumerDispose() {
+        PublishSubject<Integer> ps = PublishSubject.create();
+        
+        Disposable d = ps.toSingle().subscribe(new BiConsumer<Object, Object>() {
+            @Override
+            public void accept(Object t1, Object t2) throws Exception {
+                
+            }
+        });
+
+        assertFalse(d.isDisposed());
+
+        d.dispose();
+        
+        assertTrue(d.isDisposed());
+
+        assertFalse(ps.hasObservers());
+    }
+
+    @Test
+    public void consumerDispose() {
+        PublishSubject<Integer> ps = PublishSubject.create();
+        
+        Disposable d = ps.toSingle().subscribe(Functions.<Integer>emptyConsumer());
+
+        assertFalse(d.isDisposed());
+
+        d.dispose();
+        
+        assertTrue(d.isDisposed());
+
+        assertFalse(ps.hasObservers());
+    }
+
+    @Test
+    public void consumerSuccessThrows() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            Single.just(1).subscribe(new Consumer<Integer>() {
+                @Override
+                public void accept(Integer t) throws Exception {
+                    throw new TestException();
+                }
+            });
+            
+            TestHelper.assertError(list, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
 
+    @Test
+    public void consumerErrorThrows() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            Single.<Integer>error(new TestException("Outer failure")).subscribe(
+            Functions.<Integer>emptyConsumer(),
+            new Consumer<Throwable>() {
+                @Override
+                public void accept(Throwable t) throws Exception {
+                    throw new TestException("Inner failure");
+                }
+            });
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> cel = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(cel, 0, TestException.class, "Outer failure");
+            TestHelper.assertError(cel, 1, TestException.class, "Inner failure");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void biConsumerThrows() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            Single.just(1).subscribe(new BiConsumer<Integer, Throwable>() {
+                @Override
+                public void accept(Integer t, Throwable e) throws Exception {
+                    throw new TestException();
+                }
+            });
+            
+            TestHelper.assertError(list, 0, TestException.class);
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void biConsumerErrorThrows() {
+        List<Throwable> list = TestHelper.trackPluginErrors();
+        
+        try {
+            Single.<Integer>error(new TestException("Outer failure")).subscribe(
+            new BiConsumer<Integer, Throwable>() {
+                @Override
+                public void accept(Integer a, Throwable t) throws Exception {
+                    throw new TestException("Inner failure");
+                }
+            });
+            
+            TestHelper.assertError(list, 0, CompositeException.class);
+            List<Throwable> cel = TestHelper.compositeList(list.get(0));
+            TestHelper.assertError(cel, 0, TestException.class, "Outer failure");
+            TestHelper.assertError(cel, 1, TestException.class, "Inner failure");
+        } finally {
+            RxJavaPlugins.reset();
+        }
+    }
+
+    @Test
+    public void methodTestNoCancel() {
+        PublishSubject<Integer> ps = PublishSubject.create();
+        
+        ps.toSingle().test(false);
+        
+        assertTrue(ps.hasObservers());
+    }
 }
diff --git a/src/test/java/io/reactivex/subjects/PublishSubjectTest.java b/src/test/java/io/reactivex/subjects/PublishSubjectTest.java
index 490d7ee35e..93e33b38ec 100644
--- a/src/test/java/io/reactivex/subjects/PublishSubjectTest.java
+++ b/src/test/java/io/reactivex/subjects/PublishSubjectTest.java
@@ -649,7 +649,7 @@ public void run() {
 
             TestHelper.race(r1, r2, Schedulers.io());
             
-            ts.awaitDone()
+            ts.awaitDone(5, TimeUnit.SECONDS)
             .assertResult();
         }
     }
